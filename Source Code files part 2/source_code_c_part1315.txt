[30];
    DWORD dwIndex;
    BOOL bShowTitle;


    pGPOTemp = pGPO;

    while (pGPOTemp)
    {
        bShowTitle = TRUE;

        lstrcpy (szPath, pGPOTemp->lpFileSysPath);
        lstrcat (szPath, TEXT("\\Scripts\\Scripts.ini"));

        dwIndex = 0;

        while (TRUE)
        {
            //
            // Get the command line
            //

            szCmdLine[0] = TEXT('\0');
            wsprintf (szTemp, TEXT("%dCmdLine"), dwIndex);
            GetPrivateProfileString (lpScriptType, szTemp, TEXT(""),
                                     szCmdLine, MAX_PATH,
                                     szPath);

            //
            // If the command line is empty, we're finished
            //

            if (szCmdLine[0] == TEXT('\0'))
            {
                break;
            }

            //
            // Get the parameters
            //

            szArgs[0] = TEXT('\0');
            wsprintf (szTemp, TEXT("%dParameters"), dwIndex);
            GetPrivateProfileString (lpScriptType, szTemp, TEXT(""),
                                     szArgs, MAX_PATH,
                                     szPath);


            if (bShowTitle)
            {
                PrintString(IDS_SCRIPTS_TITLE, lpTitle, pGPOTemp->lpDisplayName);
                bShowTitle = FALSE;
            }

            PrintString(IDS_SCRIPTS_ENTRY, szCmdLine, szArgs);

            dwIndex++;
        }

        pGPOTemp = pGPOTemp->pNext;
    }
}

void DumpAppMgmt (BOOL bMachine)
{
    DWORD dwNumApps = 0, i, dwCount;
    PMANAGEDAPPLICATION pPubApps = NULL;
    PLOCALMANAGEDAPPLICATION pLocalApps = NULL;


    //
    // Assigned applications first
    //

    if (bMachine)
    {
        PrintString(IDS_APPMGMT_TITLE1);
    }
    else
    {
        PrintString (IDS_APPMGMT_TITLE2);
    }

    dwCount = 0;

    if (GetLocalManagedApplications (!bMachine, &dwNumApps, &pLocalApps) == ERROR_SUCCESS)
    {
        for (i=0; i < dwNumApps; i++)
        {
            if (pLocalApps[i].dwState & LOCALSTATE_ASSIGNED)
            {
                PrintString(IDS_APPMGMT_NAME, pLocalApps[i].pszDeploymentName);
                PrintString(IDS_APPMGMT_GPONAME, pLocalApps[i].pszPolicyName);

                if (pLocalApps[i].dwState & LOCALSTATE_POLICYREMOVE_ORPHAN)
                {
                    PrintString(IDS_APPMGMT_ORPHAN);
                }

                if (pLocalApps[i].dwState & LOCALSTATE_POLICYREMOVE_UNINSTALL)
                {
                    PrintString(IDS_APPMGMT_UNINSTALL);
                }

                dwCount++;
            }
        }
    }

    if (dwCount == 0)
    {
        PrintString(IDS_APPMGMT_NONE);
    }


    //
    // Exit now if this is machine processing
    //

    if (bMachine)
    {
        if (pLocalApps)
        {
            LocalFree (pLocalApps);
        }

        return;
    }


    //
    // Now published applications
    //

    PrintString(IDS_APPMGMT_TITLE3);

    dwCount = 0;

    for (i=0; i < dwNumApps; i++)
    {
        if (pLocalApps[i].dwState & LOCALSTATE_PUBLISHED)
        {
            PrintString(IDS_APPMGMT_NAME, pLocalApps[i].pszDeploymentName);
            PrintString(IDS_APPMGMT_GPONAME, pLocalApps[i].pszPolicyName);

            if (pLocalApps[i].dwState & LOCALSTATE_POLICYREMOVE_ORPHAN)
            {
                PrintString(IDS_APPMGMT_ORPHAN);
            }

            if (pLocalApps[i].dwState & LOCALSTATE_POLICYREMOVE_UNINSTALL)
            {
                PrintString(IDS_APPMGMT_UNINSTALL);
            }

            dwCount++;
        }
    }

    if (dwCount == 0)
    {
        PrintString(IDS_APPMGMT_NONE);
    }

    if (pLocalApps)
    {
        LocalFree (pLocalApps);
    }



    //
    // Exit now if we are not in super verbose mode
    //

    if (!g_bSuperVerbose)
    {
        PrintString(IDS_APPMGMT_ARP1);
        return;
    }


    //
    // Query for the full list of published applications
    //

    PrintString(IDS_APPMGMT_ARP2);

    dwCount = 0;
    if (GetManagedApplications (NULL, MANAGED_APPS_USERAPPLICATIONS, MANAGED_APPS_INFOLEVEL_DEFAULT,
                                &dwNumApps, &pPubApps) == ERROR_SUCCESS)
    {
        for (i=0; i < dwNumApps; i++)
        {
            PrintString(IDS_APPMGMT_NAME, pPubApps[i].pszPackageName);
            PrintString(IDS_APPMGMT_GPONAME, pPubApps[i].pszPolicyName);

            if (pPubApps[i].bInstalled)
            {
                PrintString(IDS_APPMGMT_STATE1);
            }
            else
            {
                PrintString(IDS_APPMGMT_STATE2);
            }

            dwCount++;
        }

        if (pPubApps)
        {
            LocalFree (pPubApps);
        }
    }

    if (dwCount == 0)
    {
        PrintString(IDS_APPMGMT_NONE);
    }

}

void PrintString(UINT uiStringId, ...)
{
    LPTSTR lpMsg;
    TCHAR szFormat[100];
    TCHAR szBuffer[200];
    va_list marker;


    va_start(marker, uiStringId);

    if (LoadString (GetModuleHandle(NULL), uiStringId, szFormat, ARRAYSIZE(szFormat)))
    {
        wvsprintf(szBuffer, szFormat, marker);

        if (g_bDebuggerOutput)
        {
            OutputDebugString (szBuffer);
        }
        else
        {
            _tprintf(TEXT("%s"), szBuffer);
        }
    }

    va_end(marker);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\usrinfo.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

    usrinfo.cxx

Abstract:
    This module contains the implementation of the members of the class
    CUsrInfo which is used to store and manipulate pertinent information
    about the logged on user, e.g. the HOMEDIR path, the user name,
    logon domain, etc.


Author:

    Rahul Thombre (RahulTh) 2/28/2000

Revision History:

    2/28/2000   RahulTh         Created this module.

--*/

#include "fdeploy.hxx"

CUsrInfo::CUsrInfo () : _pwszNameBuf (NULL),
                        _pwszUserName (NULL),
                        _pwszDomain (NULL),
                        _pwszHomeDir (NULL),
                        _bAttemptedGetUserName (FALSE),
                        _bAttemptedGetHomeDir (FALSE),
                        _StatusUserName (ERROR_SUCCESS),
                        _StatusHomeDir (ERROR_SUCCESS),
                        _pPlanningModeContext (NULL)
{
}

CUsrInfo::~CUsrInfo ()
{
	ResetMembers();
}

//+--------------------------------------------------------------------------
//
//  Member:		CUsrInfo::ResetMembers
//
//  Synopsis:	Resets the member variables to their default values.
//
//  Arguments:	none.
//
//  Returns:	nothing.
//
//  History:	12/17/2000  RahulTh  created
//
//  Notes:		This function was added to facilitate the reinitialization
//				of the member functions of global variables. This is necessary
//				for consecutive runs of folder redirection (if fdeploy.dll) does
//				not get reloaded for some reason and the constructors for the
//				global variables are not invoked. This can lead to strange
//				undesirable results especially if the two consecutive runs are
//				for two different users.
//
//---------------------------------------------------------------------------
void CUsrInfo::ResetMembers(void)
{
	if (_pwszNameBuf)
	{
		delete [] _pwszNameBuf;
		_pwszNameBuf = NULL;
	}
	
    //
    // Note: _pwszUserName and _pwszDomain are const pointers pointing to the
    //       domain and user name within _pwszNameBuf. So there is no need to
    //       delete them here.
	//
	_pwszUserName = _pwszDomain = NULL;
	
	if (_pwszHomeDir)
	{
		delete [] _pwszHomeDir;
		_pwszHomeDir = NULL;
	}
	
	_bAttemptedGetHomeDir = _bAttemptedGetHomeDir = FALSE;
	_StatusUserName = _StatusHomeDir = ERROR_SUCCESS;
	_pPlanningModeContext = NULL;
	
	return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::GetUserName
//
//  Synopsis:   Retrieves the name of the logged on user.
//
//  Arguments:  [out] DWORD : StatusCode : the status code of the operation
//
//  Returns:    NULL : if the user name could not be obtained.
//              const pointer to a string containing the username otherwise.
//
//  History:    2/28/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
const WCHAR * CUsrInfo::GetUserName (OUT DWORD & StatusCode)
{
    ULONG       ulNameLen;
    BOOL        bStatus;
    WCHAR *     wszPtr = NULL;

    //
    // In planning mode, if no user name was specified because the
    // caller targeted a SOM and not a user, we will return NULL
    // with a success status to indicate this
    //
    if ( _pPlanningModeContext && 
        ! _pPlanningModeContext->_pRsopTarget->pwszAccountName )
    {
        StatusCode = ERROR_SUCCESS;
        return NULL;
    }

    if (_bAttemptedGetUserName)
        goto GetUserName_CleanupAndQuit;

    _bAttemptedGetUserName = TRUE;

    for (ulNameLen = UNLEN + 1;;)
    {
        if (_pwszNameBuf)
        {
            delete [] _pwszNameBuf;
            _pwszNameBuf = NULL;
        }

        _pwszNameBuf = new WCHAR [ulNameLen];

        if (! _pwszNameBuf)
        {
            _StatusUserName = ERROR_OUTOFMEMORY;
            goto GetUserName_CleanupAndQuit;
        }

        //
        // In non-planning mode, we can use standard system api's
        // to retrieve a sam compatible user name ("domain\username").
        //
        if ( ! _pPlanningModeContext )
        {
            bStatus = GetUserNameEx (NameSamCompatible, _pwszNameBuf, &ulNameLen);
            if (!bStatus)
                _StatusUserName = GetLastError();
        }
        else
        {
            _StatusUserName = GetPlanningModeSamCompatibleUserName( 
                _pwszNameBuf,
                &ulNameLen);
        }

        if (ERROR_MORE_DATA == _StatusUserName)
            continue;
        else if (ERROR_SUCCESS == _StatusUserName)
            break;
        else
            goto GetUserName_CleanupAndQuit;
    }

    wszPtr = wcschr (_pwszNameBuf, L'\\');

    // Make sure it is in the form domain\username
    if (!wszPtr || L'\0' == wszPtr[1] || wszPtr == _pwszNameBuf)
    {
        _StatusUserName = ERROR_NO_SUCH_USER;
        goto GetUserName_CleanupAndQuit;
    }

    //
    // If we are here, we already have a SAM compatible name, in the form of
    // domain\username. Now we just need to make sure that _pwszUserName
    // and _pwszDomain point to the right places in the string.
    //
    // First NULL out the \ so that the string is split into the domain part
    // and the username part
    //
    *wszPtr = L'\0';

    // Assign the proper pointers
    _pwszUserName = &wszPtr[1];
    _pwszDomain = _pwszNameBuf;

    // Record success
    _StatusUserName = ERROR_SUCCESS;

GetUserName_CleanupAndQuit:
    StatusCode = _StatusUserName;
    return _pwszUserName;
}

//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::GetHomeDir
//
//  Synopsis:   Retrieves the homedir of the logged on user, if defined.
//
//  Arguments:  [out] DWORD : StatusCode : the status code of the operation
//
//  Returns:    NULL : if homedir is not defined or the information cannot be
//                     obtained.
//              const pointer to a string containing the homedir otherwise.
//
//  History:    2/28/2000  RahulTh  created
//
//  Notes:      If the homedir is not set for the user, then this function
//              returns NULL, but the StatusCode is set to ERROR_SUCCESS
//              That is how we differentiate between the case where there
//              is no homedir because there was an error trying to obtain it
//              and the case where there was no error but the homedir has not
//              been set for the user.
//
//---------------------------------------------------------------------------
const WCHAR * CUsrInfo::GetHomeDir (OUT DWORD & StatusCode)
{
    const WCHAR *   pwszUName = NULL;
    PUSER_INFO_2    pUserInfo = NULL;
    NET_API_STATUS  netStatus = NERR_Success;
    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;

    if (_bAttemptedGetHomeDir)
        goto GetHomeDir_CleanupAndQuit;

    _bAttemptedGetHomeDir = TRUE;

    // Get the user name and domain so that we can query for the homedir.

    if (_bAttemptedGetUserName)
    {
        _StatusHomeDir = _StatusUserName;
        pwszUName = _pwszUserName;
    }
    else
    {
        pwszUName = this->GetUserName (_StatusHomeDir);
    }

    if (NULL == pwszUName || ERROR_SUCCESS != _StatusHomeDir)
        goto GetHomeDir_CleanupAndQuit;

    //
    // If we are here, we have the user name and the domain info.
    // So now we try to get the user's home directory from the user
    // object.
    //
    // First get a domain controller
    //

    DebugMsg ((DM_VERBOSE, IDS_QUERYDSFORHOMEDIR, _pwszUserName));

    _StatusHomeDir = DsGetDcName (NULL, _pwszDomain, NULL, NULL,
                                  DS_DIRECTORY_SERVICE_REQUIRED, &pDCInfo);
    if (NO_ERROR != _StatusHomeDir)
        goto GetHomeDir_CleanupAndQuit;

    netStatus = NetUserGetInfo (pDCInfo->DomainControllerName,
                                pwszUName,
                                2,
                                (LPBYTE *) &pUserInfo
                                );
    switch (netStatus)
    {
    case NERR_Success:
        break;
    case NERR_InvalidComputer:
        _StatusHomeDir = ERROR_INVALID_COMPUTERNAME;
        goto GetHomeDir_CleanupAndQuit;
        break;
    case NERR_UserNotFound:
        _StatusHomeDir = ERROR_NO_SUCH_USER;
        goto GetHomeDir_CleanupAndQuit;
        break;
    case ERROR_ACCESS_DENIED:
        _StatusHomeDir = ERROR_ACCESS_DENIED;
        goto GetHomeDir_CleanupAndQuit;
        break;
    default:
        //
        // We encountered some other unexpected network error. Just translate it to a 
        // generic error code.
        //
        _StatusHomeDir = ERROR_UNEXP_NET_ERR;
        goto GetHomeDir_CleanupAndQuit;
        break;
    }

    //
    // If we are here, we managed to get the user info.
    // Now, check if the user has a home directory
    //
    // Note: If the user does not have a home directory set, we return
    //       NULL, but _StatusHomeDir is set to ERROR_SUCCESS
    _StatusHomeDir = ERROR_SUCCESS;
    if (pUserInfo->usri2_home_dir && L'\0' != pUserInfo->usri2_home_dir)
    {
        _pwszHomeDir = new WCHAR [lstrlen (pUserInfo->usri2_home_dir) + 1];
        if (_pwszHomeDir)
        {
            lstrcpy (_pwszHomeDir, pUserInfo->usri2_home_dir);
            DebugMsg ((DM_VERBOSE, IDS_OBTAINED_HOMEDIR, _pwszHomeDir));
        }
        else
        {
            _StatusHomeDir = ERROR_OUTOFMEMORY;
        }
    }

GetHomeDir_CleanupAndQuit:
    // Cleanup
    if (pDCInfo)
        NetApiBufferFree ((LPVOID)pDCInfo);

    if (pUserInfo)
        NetApiBufferFree ((LPVOID)pUserInfo);

    // Set return values and quit
    StatusCode = _StatusHomeDir;
    if (ERROR_SUCCESS != StatusCode)
    {
        DebugMsg ((DM_VERBOSE, IDS_FAILED_GETHOMEDIR));
    }
    return (const WCHAR *) _pwszHomeDir;
}


//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::SetPlanningModeContext
//
//  Synopsis:   Set's this object's planning mode information -- setting
//              this causes this object to believe it is in planning mode
//
//  Arguments:  [in] CRsopContext* pRsopContext : pointer to planning mode
//              context object.  The lifetime of the context object is not
//              owned by this object -- it does not need to be refcounted
//              before calling this method.
//
//  History:    7/6/2000  AdamEd  created
//
//---------------------------------------------------------------------------
void CUsrInfo::SetPlanningModeContext( CRsopContext* pRsopContext )
{
    _pPlanningModeContext = pRsopContext;
}


//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::GetPlanningModeSamCompatibleUserName
//
//  Synopsis:   Retrieves the user name of the user specified in this
//              object's planning mode context
//
//  Arguments:  [in] WCHAR* : pwszUserName : buffer in which to store
//              the same compatbile user name ("domain\username" format).
//              [in, out] : pcchUserName : length, in chars, including
//              the null terminator, of the pwszUserName  buffer.
//              On output, the it is the number of characters
//              needed in the buffer, including the null terminator
//  Returns:    NULL : ERROR_SUCCESS if the user name is successfully
//                  copied to the pwszUserName buffer, ERROR_MORE_DATA otherwise
//
//  History:    7/6/2000  AdamEd  created
//
//---------------------------------------------------------------------------
DWORD CUsrInfo::GetPlanningModeSamCompatibleUserName( WCHAR* pwszUserName, ULONG* pcchUserName )
{
    DWORD  Status;
    WCHAR* pwszUserNameSource;
    ULONG  ulActualLen;

    //
    // The interface to this method is designed to mirror that of the
    // GetUserNameEx api to simplify code that executes in both planning
    // and normal modes.
    //

    //
    // In planning mode, we retrieve the user name from the RSoP context.
    // This RSoP context has the user name in sam compatible form.
    //
    pwszUserNameSource = _pPlanningModeContext->_pRsopTarget->pwszAccountName;

    ulActualLen = lstrlen( pwszUserNameSource );

    //
    // If we have enough space, copy the string
    //
    if ( ulActualLen < *pcchUserName )
    {
        lstrcpy( pwszUserName, pwszUserNameSource );

        Status = ERROR_SUCCESS;
    }
    else
    {
        Status = ERROR_MORE_DATA;
    }

    *pcchUserName = ulActualLen;
   
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpresult\gpresult.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <lm.h>
#define SECURITY_WIN32
#include <security.h>
#include <userenv.h>
#include <dsgetdc.h>
#include <tchar.h>
#include <stdio.h>
#include <shlobj.h>
#include <appmgmt.h>


//
// String ids
//

#define IDS_NEWLINE             100
#define IDS_2NEWLINE            101
#define IDS_LEGAL1              102
#define IDS_LEGAL2              103

#define IDS_USAGE1              110
#define IDS_USAGE2              111
#define IDS_USAGE3              112
#define IDS_USAGE4              113
#define IDS_USAGE5              114
#define IDS_USAGE6              115

#define IDS_CREATEINFO          118

#define IDS_OSINFO              120
#define IDS_OS_PRO              121
#define IDS_OS_SRV              122
#define IDS_OS_DC               123

#define IDS_OS_BUILDNUMBER1     124
#define IDS_OS_BUILDNUMBER2     125

#define IDS_TS_REMOTEADMIN      130
#define IDS_TS_APPSERVER        131
#define IDS_TS_NONE             132
#define IDS_TS_NOTSUPPORTED     133

#define IDS_LINE                135
#define IDS_LINE2               136
#define IDS_COMPRESULTS1        137
#define IDS_COMPRESULTS2        138
#define IDS_DOMAINNAME          139
#define IDS_W2KDOMAIN           140
#define IDS_SITENAME            141
#define IDS_LOCALCOMP           142
#define IDS_NT4DOMAIN           143

#define IDS_USERRESULTS1        144
#define IDS_USERRESULTS2        145
#define IDS_LOCALUSER           146

#define IDS_LASTTIME            149
#define IDS_DCNAME              150

#define IDS_COMPREGPOLICY       152
#define IDS_USERREGPOLICY       153

#define IDS_COMPPOLICY          155
#define IDS_USERPOLICY          156

#define IDS_GPONAME             158

#define IDS_SECEDIT             160
#define IDS_NOINFO              161

#define IDS_ROAMINGPROFILE      164
#define IDS_NOROAMINGPROFILE    165
#define IDS_LOCALPROFILE        166
#define IDS_NOLOCALPROFILE      167

#define IDS_SECURITYGROUPS1     170
#define IDS_SECURITYGROUPS2     171
#define IDS_GROUPNAME           172
#define IDS_SECURITYPRIVILEGES  173

#define IDS_REVISIONNUMBER1     175
#define IDS_REVISIONNUMBER2     176
#define IDS_UNIQUENAME          177
#define IDS_DOMAINNAME2         178

#define IDS_LOCALLINK           180
#define IDS_SITELINK            181
#define IDS_DOMAINLINK          182
#define IDS_OULINK              183
#define IDS_UNKNOWNLINK         184

#define IDS_FOLDERREDIR         186

#define IDS_IPSEC_NAME          188
#define IDS_IPSEC_DESC          189
#define IDS_IPSEC_PATH          190

#define IDS_DQ_ENABLED1         195
#define IDS_DQ_ENABLED2         196
#define IDS_DQ_ENFORCED1        197
#define IDS_DQ_ENFORCED2        198
#define IDS_DQ_LIMIT1           199
#define IDS_DQ_LIMIT2           200
#define IDS_DQ_KB               201
#define IDS_DQ_MB               202
#define IDS_DQ_GB               203
#define IDS_DQ_TB               204
#define IDS_DQ_PB               205
#define IDS_DQ_EB               206
#define IDS_DQ_WARNING1         207
#define IDS_DQ_WARNING2         208
#define IDS_DQ_LIMIT_EXCEED1    209
#define IDS_DQ_LIMIT_EXCEED2    210
#define IDS_DQ_LIMIT_EXCEED3    211
#define IDS_DQ_LIMIT_EXCEED4    212
#define IDS_DQ_REMOVABLE1       213
#define IDS_DQ_REMOVABLE2       214

#define IDS_SCRIPTS_TITLE       216
#define IDS_SCRIPTS_ENTRY       217

#define IDS_APPMGMT_TITLE1      218
#define IDS_APPMGMT_TITLE2      219
#define IDS_APPMGMT_NAME        220
#define IDS_APPMGMT_GPONAME     221
#define IDS_APPMGMT_ORPHAN      222
#define IDS_APPMGMT_UNINSTALL   223
#define IDS_APPMGMT_NONE        224
#define IDS_APPMGMT_ARP1        225
#define IDS_APPMGMT_ARP2        226
#define IDS_APPMGMT_TITLE3      227
#define IDS_APPMGMT_STATE1      228
#define IDS_APPMGMT_STATE2      229

#define IDS_REGVIEW_PREF1       235
#define IDS_REGVIEW_PREF2       236
#define IDS_REGVIEW_PREF3       237
#define IDS_REGVIEW_GPONAME     238
#define IDS_REGVIEW_KEYNAME     239
#define IDS_REGVIEW_VALUENAME   240
#define IDS_REGVIEW_DWORD       241
#define IDS_REGVIEW_DWORDDATA   242
#define IDS_REGVIEW_SZ          243
#define IDS_REGVIEW_SZDATA      244
#define IDS_REGVIEW_EXPANDSZ    245
#define IDS_REGVIEW_MULTISZ     246
#define IDS_REGVIEW_MULTIDATA1  247
#define IDS_REGVIEW_MULTIDATA2  248
#define IDS_REGVIEW_BINARY      249
#define IDS_REGVIEW_BINARYDATA1 250
#define IDS_REGVIEW_BINARYFRMT  251
#define IDS_REGVIEW_NEXTLINE    252
#define IDS_REGVIEW_SPACE       253
#define IDS_REGVIEW_STRING1     254
#define IDS_REGVIEW_STRING2     255
#define IDS_REGVIEW_VERBOSE     256
#define IDS_REGVIEW_NONE        257
#define IDS_REGVIEW_NOVALUES    258
#define IDS_REGVIEW_UNKNOWN     259
#define IDS_REGVIEW_UNKNOWNSIZE 260


#define IDS_OPENHISTORYFAILED   1000
#define IDS_QUERYKEYINFOFAILED  1001
#define IDS_OPENPROCESSTOKEN    1002
#define IDS_QUERYSID            1003
#define IDS_QUERYVALUEFAILED    1004
#define IDS_MEMALLOCFAILED      1005
#define IDS_TOKENINFO           1006
#define IDS_LOOKUPACCOUNT       1007
#define IDS_PRIVSIZE            1008
#define IDS_LOOKUPFAILED        1009
#define IDS_GETFOLDERPATH       1010
#define IDS_GETPRIVATEPROFILE   1011
#define IDS_CREATEFILE          1012
#define IDS_INVALIDSIGNATURE1   1013
#define IDS_INVALIDSIGNATURE2   1014
#define IDS_VERSIONNUMBER1      1015
#define IDS_VERSIONNUMBER2      1016
#define IDS_FAILEDFIRSTCHAR     1017
#define IDS_FAILEDKEYNAMECHAR   1018
#define IDS_FAILEDSEMICOLON     1019
#define IDS_FAILEDVALUENAME     1020
#define IDS_FAILEDTYPE          1021
#define IDS_FAILEDDATALENGTH    1022
#define IDS_FAILEDDATA          1023
#define IDS_CLOSINGBRACKET1     1024
#define IDS_CLOSINGBRACKET2     1025



#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

BOOL DisplayRegistryData (LPTSTR lpRegistry);

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid);
NTSTATUS LoadSidAuthFromString (const WCHAR* pString, PSID_IDENTIFIER_AUTHORITY pSidAuth);
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue);
void PrintString(UINT uiStringId, ...);

extern BOOL g_bVerbose;
extern BOOL g_bSuperVerbose;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\inc\ginacomn.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ginacomn.h

Abstract:

    This module contains the declarations shared between gina components.

Author:

    Cenk Ergan (cenke) - 2001/05/07

Environment:

    User Mode

--*/

#ifndef _GINACOMN_H
#define _GINACOMN_H

#ifdef __cplusplus
extern "C" {
#endif  

//
// Shared routines for optimized logon.
//

DWORD
GcCheckIfProfileAllowsCachedLogon(
    PUNICODE_STRING HomeDirectory,
    PUNICODE_STRING ProfilePath,
    PWCHAR UserSidString,
    PDWORD NextLogonCacheable
    );

BOOL 
GcCheckIfLogonScriptsRunSync(
    PWCHAR UserSidString
    );

DWORD
GcAccessProfileListUserSetting (
    PWCHAR UserSidString,
    BOOL SetValue,
    PWCHAR ValueName,
    PDWORD Value
    );

DWORD
GcGetNextLogonCacheable(
    PWCHAR UserSidString,
    PDWORD NextLogonCacheable
    );

DWORD
GcSetNextLogonCacheable(
    PWCHAR UserSidString,
    DWORD NextLogonCacheable
    );

DWORD
GcSetOptimizedLogonStatus(
    PWCHAR UserSidString,
    DWORD OptimizedLogonStatus
    );

DWORD 
GcGetUserPreferenceValue(
    LPTSTR SidString
    );

//
// Shared routines for sid to string conversion.
//

PSID
GcGetUserSid( 
    HANDLE UserToken 
    );

LPWSTR
GcGetSidString( 
    HANDLE UserToken 
    );

VOID
GcDeleteSidString( 
    LPWSTR SidString 
    );

//
// Shared routines for dealing with services.
//

BOOL 
GcWaitForServiceToStart (
    LPTSTR lpServiceName, 
    DWORD dwMaxWait
    );

//
// Shared routines for dealing with paths.
//

LPTSTR 
GcCheckSlash (
    LPTSTR lpDir
    );

BOOL 
GcIsUNCPath(
    LPTSTR lpPath
    );

#ifdef __cplusplus
}
#endif    

#endif // _GINACOMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpresult\sid.c ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "gpresult.h"

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}

//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    SID_IDENTIFIER_AUTHORITY Auth;

    pSidStr = LocalAlloc(LPTR, (lstrlen (lpszSidStr) + 1)*sizeof(WCHAR));;
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    lstrcpy (pSidStr, lpszSidStr);
    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        LocalFree( pSidStr );
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = lstrlenW (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    len = lstrlen (szNum);
    pwszNumStr = LocalAlloc( LPTR, (len + 1) * sizeof(WCHAR));

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    lstrcpy (pwszNumStr, szNum);
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        LocalFree( pwszNumStr );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\mpnotify\mpnotify.c ===
/****************************** Module Header ******************************\
* Module Name: mpnotify.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* MpNotify main module
*
* Mpnotify is an app executed by winlogon to notify network providers
* of authentication events. Currently this means logon and password change.
* This functionality is in a separate process to avoid network providers
* having to handle the asynchronous events that winlogon receives.
*
* Winlogon initializes environment variables to describe the event
* and then executes this process in system context on the winlogon
* desktop. While this process executes, winlogon handls all screen-saver
* and logoff notifications. Winlogon will terminate this process if required
* to respond to events (e.g. remote shutdown).
*
* On completion this process signals winlogon by sending a buffer of
* data to it in a WM_COPYDATA message and then quits.
*
* History:
* 01-12-93 Davidc       Created.
\***************************************************************************/

#include "mpnotify.h"
#include <ntmsv1_0.h>
#include <mpr.h>
#include <npapi.h>

#include <stdio.h>


//
// Define to enable verbose output for this module
//

// #define DEBUG_MPNOTIFY

#ifdef DEBUG_MPNOTIFY
#define VerbosePrint(s) MPPrint(s)
#else
#define VerbosePrint(s)
#endif



//
// Define the environment variable names used to pass the
// notification event data
//

#define MPR_STATION_NAME_VARIABLE       TEXT("WlMprNotifyStationName")
#define MPR_STATION_HANDLE_VARIABLE     TEXT("WlMprNotifyStationHandle")
#define MPR_WINLOGON_WINDOW_VARIABLE    TEXT("WlMprNotifyWinlogonWindow")

#define MPR_LOGON_FLAG_VARIABLE         TEXT("WlMprNotifyLogonFlag")
#define MPR_USERNAME_VARIABLE           TEXT("WlMprNotifyUserName")
#define MPR_DOMAIN_VARIABLE             TEXT("WlMprNotifyDomain")
#define MPR_PASSWORD_VARIABLE           TEXT("WlMprNotifyPassword")
#define MPR_OLD_PASSWORD_VARIABLE       TEXT("WlMprNotifyOldPassword")
#define MPR_OLD_PASSWORD_VALID_VARIABLE TEXT("WlMprNotifyOldPasswordValid")
#define MPR_LOGONID_VARIABLE            TEXT("WlMprNotifyLogonId")
#define MPR_CHANGE_INFO_VARIABLE        TEXT("WlMprNotifyChangeInfo")
#define MPR_PASSTHROUGH_VARIABLE        TEXT("WlMprNotifyPassThrough")
#define MPR_PROVIDER_VARIABLE           TEXT("WlMprNotifyProvider")
#define MPR_DESKTOP_VARIABLE            TEXT("WlMprNotifyDesktop")

#define WINLOGON_DESKTOP_NAME   TEXT("Winlogon")


//
// Define the authentication info type that we use
// This lets the provider know that we're passing
// an MSV1_0_INTERACTIVE_LOGON structure.
//

#define AUTHENTICATION_INFO_TYPE        TEXT("MSV1_0:Interactive")

//
// Define the primary authenticator
//

#define PRIMARY_AUTHENTICATOR           TEXT("Microsoft Windows Network")



/***************************************************************************\
* AllocAndGetEnvironmentVariable
*
* Version of GetEnvironmentVariable that allocates the return buffer.
*
* Returns pointer to environment variable or NULL on failure. This routine
* will also return NULL if the environment variable is a 0 length string.
*
* The returned buffer should be free using Free()
*
* History:
* 09-Dec-92     Davidc  Created
*
\***************************************************************************/
LPTSTR
AllocAndGetEnvironmentVariable(
    LPTSTR lpName
    )
{
    LPTSTR Buffer;
    DWORD LengthRequired;
    DWORD LengthUsed;
    DWORD BytesRequired;

    //
    // Go search for the variable and find its length
    //

    LengthRequired = GetEnvironmentVariable(lpName, NULL, 0);

    if (LengthRequired == 0) {
        VerbosePrint(("Environment variable <%ws> not found, error = %d", lpName, GetLastError()));
        return(NULL);
    }

    //
    // Allocate a buffer to hold the variable
    //

    BytesRequired = LengthRequired * sizeof(TCHAR);

    Buffer = Alloc(BytesRequired);
    if (Buffer == NULL) {
        MPPrint(("Failed to allocate %d bytes for environment variable", BytesRequired));
        return(NULL);
    }

    //
    // Go get the variable and pass a buffer this time
    //

    LengthUsed = GetEnvironmentVariable(lpName, Buffer, LengthRequired);

    if (LengthUsed != LengthRequired - 1) {
        MPPrint(("Unexpected result from GetEnvironmentVariable. Length passed = %d, length used = %d (expected %d)", LengthRequired, LengthUsed, LengthRequired - 1));
        Free(Buffer);
        return(NULL);
    }

    return(Buffer);
}


/***************************************************************************\
* FUNCTION: GetEnvironmentULong
*
* PURPOSE:  Gets the value of an environment variable and converts it back
*           to its normal form. The variable should have been written
*           using SetEnvironmentULong. (See winlogon)
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetEnvironmentULong(
    LPTSTR Variable,
    PULONG Value
    )
{
    LPTSTR String;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    String = AllocAndGetEnvironmentVariable(Variable);
    if (String == NULL) {
        return(FALSE);
    }

    //
    // Convert to ansi
    //

    RtlInitUnicodeString(&UnicodeString, String);
    Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

    Free(String);

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Convert to numeric value
    //

    if (1 != sscanf(AnsiString.Buffer, "%x", Value)) {
        Value = 0;
    }

    RtlFreeAnsiString(&AnsiString);

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: GetEnvironmentLargeInt
*
* PURPOSE:  Gets the value of an environment variable and converts it back
*           to its normal form. The variable should have been written
*           using SetEnvironmentLargeInt. (See winlogon)
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetEnvironmentLargeInt(
    LPTSTR Variable,
    PLARGE_INTEGER Value
    )
{
    LPTSTR String;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    String = AllocAndGetEnvironmentVariable(Variable);
    if (String == NULL) {
        return(FALSE);
    }

    //
    // Convert to ansi
    //

    RtlInitUnicodeString(&UnicodeString, String);
    Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

    Free(String);

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Convert to numeric value
    //

    if (2 != sscanf(AnsiString.Buffer, "%x:%x", &Value->HighPart, &Value->LowPart)) {
        Value->LowPart = 0;
        Value->HighPart = 0;
    }

    RtlFreeAnsiString(&AnsiString);

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: GetCommonNotifyVariables
*
* PURPOSE:  Gets environment variables describing values common to all
*           notification events
*
*           On successful return, all values should be free using Free()
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetCommonNotifyVariables(
    PULONG LogonFlag,
    PHWND hwndWinlogon,
    PLPTSTR StationName,
    PHWND StationHandle,
    PLPTSTR Name,
    PLPTSTR Domain,
    PLPTSTR Password,
    PLPTSTR OldPassword
    )
{
    BOOL Result = TRUE;
    ULONG OldPasswordValid;

    //
    // Prepare for failure
    //

    *hwndWinlogon = NULL;
    *StationName = NULL;
    *StationHandle = NULL;
    *Name = NULL;
    *Domain = NULL;
    *Password = NULL;
    *OldPassword = NULL;


    Result = GetEnvironmentULong(MPR_WINLOGON_WINDOW_VARIABLE, (PULONG)hwndWinlogon);

    if (Result) {
        *StationName = AllocAndGetEnvironmentVariable(MPR_STATION_NAME_VARIABLE);
        Result = (*StationName != NULL);
    }
    if (Result) {
        Result = GetEnvironmentULong(MPR_STATION_HANDLE_VARIABLE, (PULONG)StationHandle);
    }

    if (Result) {
        *Name = AllocAndGetEnvironmentVariable(MPR_USERNAME_VARIABLE);
//        Result = (*Name != NULL);
    }
    if (Result) {
        *Domain = AllocAndGetEnvironmentVariable(MPR_DOMAIN_VARIABLE);
//        Result = (*Domain != NULL);
    }
    if (Result) {
        *Password = AllocAndGetEnvironmentVariable(MPR_PASSWORD_VARIABLE);
        // If the password is NULL that's ok
    }
    if (Result) {
        Result = GetEnvironmentULong(MPR_OLD_PASSWORD_VALID_VARIABLE, &OldPasswordValid);
    }
    if (Result && OldPasswordValid) {
        *OldPassword = AllocAndGetEnvironmentVariable(MPR_OLD_PASSWORD_VARIABLE);
        // If the old password is NULL that's ok
    }
    if (Result) {
        Result = GetEnvironmentULong(MPR_LOGON_FLAG_VARIABLE, LogonFlag);
    }



    if (!Result) {
        MPPrint(("GetCommonNotifyVariables: Failed to get a variable, error = %d", GetLastError()));

        //
        // Free up any memory we allocated
        //

        if (*StationName != NULL) {
            Free(*StationName);
        }
        if (*Name != NULL) {
            Free(*Name);
        }
        if (*Domain != NULL) {
            Free(*Domain);
        }
        if (*Password != NULL) {
            Free(*Password);
        }
        if (*OldPassword != NULL) {
            Free(*OldPassword);
        }
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: GetLogonNotifyVariables
*
* PURPOSE:  Get logon specific notify data
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetLogonNotifyVariables(
    PLUID   LogonId
    )
{
    BOOL Result;

    Result = GetEnvironmentLargeInt(MPR_LOGONID_VARIABLE, (PLARGE_INTEGER) LogonId);

    if (!Result) {
        MPPrint(("GetLogonNotifyVariables: Failed to get variable, error = %d", GetLastError()));
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: GetChangePasswordNotifyVariables
*
* PURPOSE:  Gets change-password specific notify data
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetChangePasswordNotifyVariables(
    PDWORD ChangeInfo,
    PBOOL PassThrough,
    PWSTR * ProviderName
    )
{
    BOOL Result;

    Result = GetEnvironmentULong(MPR_CHANGE_INFO_VARIABLE, ChangeInfo);
    if (Result) {
        Result = GetEnvironmentULong(MPR_PASSTHROUGH_VARIABLE, PassThrough);
    }
    if (Result)
    {
        *ProviderName = AllocAndGetEnvironmentVariable( MPR_PROVIDER_VARIABLE );
    }

    if (!Result) {
        MPPrint(("GetChangePasswordNotifyVariables: Failed to get variable, error = %d", GetLastError()));
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: NotifyWinlogon
*
* PURPOSE:  Informs winlogon that credential provider notification
*           has completed and passes the logon scripts buffer back.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
NotifyWinlogon(
    HWND hwndWinlogon,
    DWORD Error,
    LPTSTR MultiSz OPTIONAL
    )
{
    DWORD MultiSzSize = 0;
    COPYDATASTRUCT CopyData;

    if (MultiSz != NULL) {

        LPTSTR StringPointer = MultiSz;
        DWORD Length;

        VerbosePrint(("NotifyWinlogon : logon scripts strings start"));

        do {
            Length = lstrlen(StringPointer);
            if (Length != 0) {
                VerbosePrint(("<%ws>", StringPointer));
            }

            MultiSzSize += ((Length + 1) * sizeof(TCHAR));
            StringPointer += Length + 1;

        } while (Length != 0);

        VerbosePrint(("NotifyWinlogon : logon scripts strings end"));

    }

    CopyData.dwData = Error;
    CopyData.cbData = MultiSzSize;
    CopyData.lpData = MultiSz;

    SendMessage(hwndWinlogon, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&CopyData);

    return(TRUE);
}

DWORD
NotifySpecificProvider(
    PWSTR Provider,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    DWORD               dwChangeInfo
    )
{
    HMODULE hDll;
    HKEY    hKey;
    WCHAR   szText[MAX_PATH];
    WCHAR   szPath[128];
    PWSTR   pszPath;
    DWORD   dwType;
    DWORD   dwLen;
    int     err;
    PF_NPPasswordChangeNotify pFunc;


    wcscpy(szText, TEXT("System\\CurrentControlSet\\Services\\") );
    wcscat(szText, Provider );
    wcscat(szText, TEXT("\\networkprovider") );

    err = RegOpenKey(   HKEY_LOCAL_MACHINE,
                        szText,
                        &hKey );

    if ( err )
    {
        return( err );
    }

    dwLen = sizeof( szPath );
    pszPath = szPath;

    err = RegQueryValueEx(  hKey,
                            TEXT("ProviderPath"),
                            NULL,
                            &dwType,
                            (PUCHAR) pszPath,
                            &dwLen );

    if ( err )
    {
        if ( err == ERROR_BUFFER_OVERFLOW )
        {

            pszPath = LocalAlloc( LMEM_FIXED, dwLen );
            if (pszPath)
            {
                err = RegQueryValueEx(  hKey,
                                        TEXT("ProviderPath"),
                                        NULL,
                                        &dwType,
                                        (PUCHAR) pszPath,
                                        &dwLen );
            }

        }

        if ( err )
        {
            RegCloseKey( hKey );

            if ( pszPath != szPath )
            {
                LocalFree( pszPath );
            }

            return( err );
        }
    }

    RegCloseKey( hKey );

    if ( dwType == REG_EXPAND_SZ )
    {
        ExpandEnvironmentStrings( pszPath, szText, MAX_PATH );
    }
    else if (dwType == REG_SZ )
    {
        wcscpy( szText, pszPath );
    }
    else
    {
        if (pszPath != szPath)
        {
            LocalFree( pszPath );
        }

        return( err );
    }

    //
    // Ok, now we have expanded the DLL where the NP code lives, and it
    // is in szText.  Load it, call it.
    //

    if ( pszPath != szPath )
    {
        LocalFree( pszPath );
        pszPath = NULL;
    }

    hDll = LoadLibrary( szText );

    if ( hDll )
    {
        pFunc = (PF_NPPasswordChangeNotify) GetProcAddress( hDll,
                                                    "NPPasswordChangeNotify" );
        if ( pFunc )
        {
            err = pFunc(lpAuthentInfoType,
                        lpAuthentInfo,
                        lpPreviousAuthentInfoType,
                        lpPreviousAuthentInfo,
                        lpStationName,
                        StationHandle,
                        dwChangeInfo);


        }

        FreeLibrary( hDll );
    }

    return( err );

}


/***************************************************************************\
* WinMain
*
* History:
* 01-12-93 Davidc       Created.
\***************************************************************************/

int
WINAPI
WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow
    )
{
    DWORD Error;
    BOOL Result;

    ULONG LogonFlag;
    HWND hwndWinlogon;
    LPTSTR StationName;
    HWND StationHandle;
    LPTSTR Name;
    LPTSTR Domain;
    LPTSTR Password;
    LPTSTR OldPassword;
    LPTSTR LogonScripts;
    LPTSTR Desktop;
    PWSTR Provider;

    LUID LogonId;
    DWORD ChangeInfo;

    MSV1_0_INTERACTIVE_LOGON AuthenticationInfo;
    MSV1_0_INTERACTIVE_LOGON OldAuthenticationInfo;
    HDESK hDesk = NULL ;
    HDESK hWinlogon ;

    BOOL PassThrough = FALSE;


    //
    // Get information describing event from environment variables
    //

    Result = GetCommonNotifyVariables(
                &LogonFlag,
                &hwndWinlogon,
                &StationName,
                &StationHandle,
                &Name,
                &Domain,
                &Password,
                &OldPassword);
    if (!Result) {
        MPPrint(("Failed to get common notify variables"));
        return(0);
    }


    //
    // Debug info
    //

    VerbosePrint(("LogonFlag =      0x%x", LogonFlag));
    VerbosePrint(("hwndWinlogon =   0x%x", hwndWinlogon));
    VerbosePrint(("Station Name =   <%ws>", StationName));
    VerbosePrint(("Station Handle = 0x%x", StationHandle));
    VerbosePrint(("Name =           <%ws>", Name));
    VerbosePrint(("Domain =         <%ws>", Domain));
    VerbosePrint(("Password =       <%ws>", Password));
    VerbosePrint(("Old Password =   <%ws>", OldPassword));


    //
    // Get the notify type specific data
    //

    if (LogonFlag != 0) {
        Result = GetLogonNotifyVariables(&LogonId);
    } else {
        Result = GetChangePasswordNotifyVariables(&ChangeInfo, &PassThrough, &Provider);
    }

    if (!Result) {
        MPPrint(("Failed to get notify event type-specific variables"));
        return(0);
    }


    //
    // Debug info
    //

    if (LogonFlag != 0) {
        VerbosePrint(("LogonId     =      0x%x:%x", LogonId.HighPart, LogonId.LowPart));
    } else {
        VerbosePrint(("ChangeInfo  =      0x%x", ChangeInfo));
        VerbosePrint(("PassThrough =      0x%x", PassThrough));
    }

    Desktop = AllocAndGetEnvironmentVariable( MPR_DESKTOP_VARIABLE );

    if ( wcscmp( Desktop, WINLOGON_DESKTOP_NAME ) )
    {
        //
        // Not supposed to use winlogon desktop.  Switch ourselves to the
        // current one:
        //

        hWinlogon = GetThreadDesktop( GetCurrentThreadId() );

        if ( hWinlogon )
        {
            hDesk = OpenInputDesktop( 0, FALSE, MAXIMUM_ALLOWED );

            if ( hDesk )
            {
                SetThreadDesktop( hDesk );
            }
        }

    }


    //
    // Fill in the authentication info structures
    //

    RtlInitUnicodeString(&AuthenticationInfo.UserName, Name);
    RtlInitUnicodeString(&AuthenticationInfo.LogonDomainName, Domain);
    RtlInitUnicodeString(&AuthenticationInfo.Password, Password);


    RtlInitUnicodeString(&OldAuthenticationInfo.UserName, Name);
    RtlInitUnicodeString(&OldAuthenticationInfo.LogonDomainName, Domain);
    RtlInitUnicodeString(&OldAuthenticationInfo.Password, OldPassword);


    //
    // Call the appropriate notify api
    //

    if (LogonFlag != 0) {

        Error = WNetLogonNotify(
                        PRIMARY_AUTHENTICATOR,
                        &LogonId,
                        AUTHENTICATION_INFO_TYPE,
                        &AuthenticationInfo,
                        (OldPassword != NULL) ? AUTHENTICATION_INFO_TYPE : NULL,
                        (OldPassword != NULL) ? &OldAuthenticationInfo : NULL,
                        StationName,
                        StationHandle,
                        &LogonScripts
                        );
        if (Error != ERROR_SUCCESS) {
            LogonScripts = NULL;
        }

    } else {

        if (!PassThrough) {
            ChangeInfo |= WN_NT_PASSWORD_CHANGED;
        }

        if (Provider)
        {
            Error = NotifySpecificProvider(
                        Provider,
                        AUTHENTICATION_INFO_TYPE,
                        &AuthenticationInfo,
                        AUTHENTICATION_INFO_TYPE,
                        &OldAuthenticationInfo,
                        StationName,
                        StationHandle,
                        ChangeInfo
                        );

        }
        else
        {

            Error = WNetPasswordChangeNotify(
                            PRIMARY_AUTHENTICATOR,
                            AUTHENTICATION_INFO_TYPE,
                            &AuthenticationInfo,
                            AUTHENTICATION_INFO_TYPE,
                            &OldAuthenticationInfo,
                            StationName,
                            StationHandle,
                            ChangeInfo
                            );
        }

        LogonScripts = NULL;
    }


    if (Error != ERROR_SUCCESS) {
        MPPrint(("WNet%sNotify failed, error = %d", LogonFlag ? "Logon" : "PasswordChange", Error));
    }

    //
    // Switch back if necessary
    //

    if ( hDesk )
    {
        SetThreadDesktop( hWinlogon );
        CloseDesktop( hWinlogon );
        CloseDesktop( hDesk );
    }

    //
    // Notify winlogon we completed and pass the logon script data
    //

    NotifyWinlogon(hwndWinlogon, Error, LogonScripts);

    //
    // Free up allocated data
    //

    if (LogonScripts != NULL) {
        LocalFree(LogonScripts);
    }

    if (StationName != NULL) {
        Free(StationName);
    }
    if (Name != NULL) {
        Free(Name);
    }
    if (Domain != NULL) {
        Free(Domain);
    }
    if (Password != NULL) {
        Free(Password);
    }
    if (OldPassword != NULL) {
        Free(OldPassword);
    }


    //
    // We're finished
    //

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\mpnotify\mpnotify.h ===
/****************************** Module Header ******************************\
* Module Name: mpnotify.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Main header file for mpnotify
*
* History:
* 01-12-93 Davidc       Created.
\***************************************************************************/

#define UNICODE


#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>


//
// Memory macros
//

#define Alloc(c)        ((PVOID)LocalAlloc(LPTR, c))
#define ReAlloc(p, c)   ((PVOID)LocalReAlloc(p, c, LPTR | LMEM_MOVEABLE))
#define Free(p)         ((VOID)LocalFree(p))


//
// Define useful types
//

#define PLPTSTR     LPTSTR *
typedef HWND * PHWND;

//
// Define a debug print routine
//

#define MPPrint(s)  KdPrint(("MPNOTIFY: ")); \
                    KdPrint(s);            \
                    KdPrint(("\n"));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpresult\regview.c ===
//*************************************************************
//  File name: REGVIEW.C
//
//  Description: Routines to print out a registry.pol file
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//*************************************************************

#include "gpresult.h"

#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512

//
// Verison number for the registry file format
//

#define REGISTRY_FILE_VERSION       1


//
// File signature
//

#define REGFILE_SIGNATURE  0x67655250


//
// True policy keys
//

#define SOFTWARE_POLICIES           TEXT("Software\\Policies")
#define SOFTWARE_POLICIES_LEN       17

#define WINDOWS_POLICIES            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")
#define WINDOWS_POLICIES_LEN        46

//*************************************************************
//
//  DisplayRegistryData()
//
//  Purpose:    Displays the registry data
//
//  Parameters: lpRegistry  -   Path to registry.pol
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL DisplayRegistryData (LPTSTR lpRegistry)
{
    HANDLE hFile;
    BOOL bResult = FALSE;
    DWORD dwTemp, dwBytesRead, dwType, dwDataLength, dwIndex, dwCount;
    LPWSTR lpKeyName, lpValueName, lpTemp;
    LPBYTE lpData = NULL, lpIndex;
    WCHAR  chTemp;
    INT i;
    CHAR szString[20];
    BOOL bTruePolicy;


    //
    // Open the registry file
    //

    hFile = CreateFile (lpRegistry, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);


    if (hFile == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            return TRUE;
        }
        else
        {
            PrintString(IDS_CREATEFILE, GetLastError());
            return FALSE;
        }
    }


    //
    // Allocate buffers to hold the keyname, valuename, and data
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        PrintString(IDS_MEMALLOCFAILED, GetLastError());
        CloseHandle (hFile);
        return FALSE;
    }


    lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));

    if (!lpValueName)
    {
        PrintString(IDS_MEMALLOCFAILED, GetLastError());
        LocalFree (lpKeyName);
        CloseHandle (hFile);
        return FALSE;
    }


    //
    // Read the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {

        PrintString(IDS_INVALIDSIGNATURE1, GetLastError());
        goto Exit;
    }


    if (dwTemp != REGFILE_SIGNATURE)
    {
        PrintString(IDS_INVALIDSIGNATURE2);
        goto Exit;
    }


    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        PrintString(IDS_VERSIONNUMBER1, GetLastError());
        goto Exit;
    }

    if (dwTemp != REGISTRY_FILE_VERSION)
    {
        PrintString(IDS_VERSIONNUMBER2);
        goto Exit;
    }

    PrintString (IDS_NEWLINE);


    //
    // Read the data
    //

    while (TRUE)
    {

        //
        // Read the first character.  It will either be a [ or the end
        // of the file.
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                PrintString(IDS_FAILEDFIRSTCHAR, GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L'['))
        {
            break;
        }


        //
        // Read the keyname
        //

        lpTemp = lpKeyName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                PrintString(IDS_FAILEDKEYNAMECHAR, GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                PrintString(IDS_FAILEDSEMICOLON, GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the valuename
        //

        lpTemp = lpValueName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                PrintString(IDS_FAILEDVALUENAME, GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                PrintString(IDS_FAILEDSEMICOLON, GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the type
        //

        if (!ReadFile (hFile, &dwType, sizeof(DWORD), &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDTYPE, GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDSEMICOLON, GetLastError());
            goto Exit;
        }


        //
        // Read the data length
        //

        if (!ReadFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDDATALENGTH, GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDSEMICOLON, GetLastError());
            goto Exit;
        }


        //
        // Allocate memory for data
        //

        lpData = (LPBYTE) LocalAlloc (LPTR, dwDataLength);

        if (!lpData)
        {
            PrintString(IDS_MEMALLOCFAILED, GetLastError());
            goto Exit;
        }


        //
        // Read data
        //

        if (!ReadFile (hFile, lpData, dwDataLength, &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDDATA, GetLastError());
            goto Exit;
        }


        //
        // Skip closing bracket
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            PrintString(IDS_CLOSINGBRACKET1, GetLastError());
            goto Exit;
        }

        if (chTemp != L']')
        {
            PrintString(IDS_CLOSINGBRACKET2, chTemp);
            goto Exit;
        }


        //
        // Print out the entry
        //

        bTruePolicy = FALSE;

        if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                          lpKeyName, SOFTWARE_POLICIES_LEN,
                          SOFTWARE_POLICIES, SOFTWARE_POLICIES_LEN) == CSTR_EQUAL)
        {
            bTruePolicy = TRUE;
        }

        else if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                          lpKeyName, WINDOWS_POLICIES_LEN,
                          WINDOWS_POLICIES, WINDOWS_POLICIES_LEN) == CSTR_EQUAL)
        {
            bTruePolicy = TRUE;
        }

        if (!bTruePolicy)
        {
            PrintString (IDS_2NEWLINE);
            PrintString (IDS_REGVIEW_PREF1);
            PrintString (IDS_REGVIEW_PREF2);
            PrintString (IDS_REGVIEW_PREF3);
        }


        //
        // Check if this is comment holding the GPO name
        //

        if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                          lpValueName, 20, TEXT("**Comment:GPO Name: "), 20) == CSTR_EQUAL)
        {
            PrintString (IDS_REGVIEW_GPONAME, (lpValueName+20));
        }
        else
        {
            PrintString (IDS_REGVIEW_KEYNAME, lpKeyName);
            PrintString (IDS_REGVIEW_VALUENAME, lpValueName);


            switch (dwType) {

                case REG_DWORD:
                    PrintString (IDS_REGVIEW_DWORD);
                    PrintString (IDS_REGVIEW_DWORDDATA, *((LPDWORD)lpData));
                    break;

                case REG_SZ:
                    PrintString (IDS_REGVIEW_SZ);
                    PrintString (IDS_REGVIEW_SZDATA, (LPTSTR)lpData);
                    break;

                case REG_EXPAND_SZ:
                    PrintString (IDS_REGVIEW_EXPANDSZ);
                    PrintString (IDS_REGVIEW_SZDATA, (LPTSTR)lpData);
                    break;

                case REG_MULTI_SZ:
                    PrintString (IDS_REGVIEW_MULTISZ);
                    PrintString (IDS_REGVIEW_MULTIDATA1);
                    lpTemp = (LPWSTR) lpData;

                    while (*lpTemp) {
                        PrintString (IDS_REGVIEW_MULTIDATA2, lpTemp);
                        lpTemp += lstrlen(lpTemp) + 1;
                    }
                    break;

                case REG_BINARY:
                    PrintString (IDS_REGVIEW_BINARY);

                    if (g_bSuperVerbose)
                    {
                        PrintString (IDS_REGVIEW_BINARYDATA1);

                        dwIndex = 0;
                        dwCount = 0;
                        lpIndex = lpData;
                        ZeroMemory(szString, sizeof(szString));

                        while (dwIndex <= dwDataLength) {
                            PrintString (IDS_REGVIEW_BINARYFRMT, *lpIndex);

                            if ((*lpIndex > 32) && (*lpIndex < 127)) {
                                szString[dwCount] = *lpIndex;
                            } else {
                                szString[dwCount] = '.';
                            }

                            if (dwCount < 15) {
                                dwCount++;
                            } else {
                                PrintString (IDS_REGVIEW_STRING1, szString);
                                PrintString (IDS_REGVIEW_NEXTLINE);
                                ZeroMemory(szString, sizeof(szString));
                                dwCount = 0;
                            }

                            dwIndex++;
                            lpIndex++;
                        }

                        if (dwCount > 0) {
                            while (dwCount < 16) {
                                PrintString (IDS_REGVIEW_SPACE);
                                dwCount++;
                            }
                            PrintString (IDS_REGVIEW_STRING2, szString);
                        }

                        PrintString (IDS_NEWLINE);
                    } else {
                        PrintString (IDS_REGVIEW_VERBOSE);
                    }

                    break;

                case REG_NONE:
                    PrintString (IDS_REGVIEW_NONE);
                    PrintString (IDS_REGVIEW_NOVALUES, *lpData);
                    break;


                default:
                    PrintString (IDS_REGVIEW_UNKNOWN);
                    PrintString (IDS_REGVIEW_UNKNOWNSIZE, dwDataLength);
                    break;
            }
        }

        LocalFree (lpData);
        lpData = NULL;

    }

    bResult = TRUE;

Exit:

    //
    // Finished
    //

    if (lpData) {
        LocalFree (lpData);
    }
    CloseHandle (hFile);
    LocalFree (lpKeyName);
    LocalFree (lpValueName);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\authmon.h ===
typedef enum _AUTH_OPERATION {

    AuthOperLogon,
    AuthOperUnlock 	

} AUTH_OPERATION;

typedef enum _AUTH_TYPE {
 	
    AuthTypePassword,
    AuthTypeSmartCard

} AUTH_TYPE;

EXTERN_C HANDLE AuthMonitor(
    AUTH_OPERATION AuthOper,
	BOOL Console,
	PUNICODE_STRING UserName,
	PUNICODE_STRING Domain,
	PWSTR Card,
	PWSTR Reader,
	PKERB_SMART_CARD_PROFILE Profile,
	DWORD Timer,
    NTSTATUS Status
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\audit.c ===
/****************************** Module Header ******************************\
* Module Name: audit.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implementation of routines that access/manipulate the system audit log
*
* History:
* 12-09-91 Davidc       Created.
* 5-6-92   DaveHart     Fleshed out.
\***************************************************************************/

#include "msgina.h"

/***************************************************************************\
* GetAuditLogStatus
*
* Purpose : Fills the global data with audit log status information
*
* Returns:  TRUE on success, FALSE on failure
*
* History:
* 12-09-91 Davidc       Created.
* 5-6-92   DaveHart     Fleshed out.
\***************************************************************************/

BOOL
GetAuditLogStatus(
    PGLOBALS    pGlobals
    )
{
    EVENTLOG_FULL_INFORMATION EventLogFullInformation;
    DWORD dwBytesNeeded;
    HANDLE AuditLogHandle;



    //
    // Assume the log is not full. If we can't get to EventLog, tough.
    //

    pGlobals->AuditLogFull = FALSE;

    AuditLogHandle = OpenEventLog( NULL, TEXT("Security"));

    if (AuditLogHandle) {
        if (GetEventLogInformation(AuditLogHandle, 
                                   EVENTLOG_FULL_INFO, 
                                   &EventLogFullInformation, 
                                   sizeof(EventLogFullInformation), 
                                   &dwBytesNeeded )   ) {
            if (EventLogFullInformation.dwFull != FALSE) {
                pGlobals->AuditLogFull = TRUE;
            }
        }
        CloseEventLog(AuditLogHandle);
    }


    //
    // There's no way in the current event logger to tell how full the log
    // is, always indicate we're NOT near full.
    //

    pGlobals->AuditLogNearFull = FALSE;

    return TRUE;
}




/***************************************************************************\
* DisableAuditing
*
* Purpose : Disable auditing via LSA.
*
* Returns:  TRUE on success, FALSE on failure
*
* History:
* 5-6-92   DaveHart     Created.
\***************************************************************************/

BOOL
DisableAuditing()
{
    NTSTATUS                    Status, IgnoreStatus;
    PPOLICY_AUDIT_EVENTS_INFO   AuditInfo;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE                  PolicyHandle;

    //
    // Set up the Security Quality Of Service for connecting to the
    // LSA policy object.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_VIEW_AUDIT_INFORMATION | POLICY_SET_AUDIT_REQUIREMENTS,
                 &PolicyHandle
                 );
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to open LsaPolicyObject Status = 0x%lx", Status));
        return FALSE;
    }

    Status = LsaQueryInformationPolicy(
                 PolicyHandle,
                 PolicyAuditEventsInformation,
                 (PVOID *)&AuditInfo
                 );
    if (!NT_SUCCESS(Status)) {

        IgnoreStatus = LsaClose(PolicyHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        DebugLog((DEB_ERROR, "Failed to query audit event info Status = 0x%lx", Status));
        return FALSE;
    }

    if (AuditInfo->AuditingMode) {

        AuditInfo->AuditingMode = FALSE;

        Status = LsaSetInformationPolicy(
                     PolicyHandle,
                     PolicyAuditEventsInformation,
                     AuditInfo
                     );
    } else {
        Status = STATUS_SUCCESS;
    }


    IgnoreStatus = LsaFreeMemory(AuditInfo);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = LsaClose(PolicyHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to disable auditing Status = 0x%lx", Status));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\brand.h ===
#ifndef __util_h
#define __util_h

extern HPALETTE g_hpalBranding;

extern HBITMAP g_hbmOtherDlgBrand;
extern SIZE g_sizeOtherDlgBrand;
extern HBITMAP g_hbmLogonBrand;
extern SIZE g_sizeLogonBrand;
extern HBITMAP g_hbmBand;
extern SIZE g_sizeBand;

VOID MoveChildren(HWND hWnd, INT dx, INT dy);
VOID MoveControls(HWND hWnd, UINT* aID, INT cID, INT dx, INT dy, BOOL fSizeWnd);

VOID LoadBrandingImages(BOOL fNoPaletteChanges, 
                        BOOL* pfTextOnLarge, BOOL* pfTextOnSmall);

VOID SizeForBranding(HWND hWnd, BOOL fLargeBrand);

BOOL PaintBranding(HWND hWnd, HDC hDC, INT bandOffset, BOOL fBandOnly, BOOL fLargeBrand, int nBackground);
BOOL BrandingQueryNewPalete(HWND hDlg);
BOOL BrandingPaletteChanged(HWND hDlg, HWND hWndPalChg);

VOID CreateFonts(PGINAFONTS pGinaFonts);
VOID PaintBitmapText(PGINAFONTS pGinaFonts, BOOL fTextOnLarge, BOOL fTextOnSmall);

#define ShowDlgItem(h, i, f)    \
            ShowWindow(GetDlgItem(h, i), f ? SW_SHOW:SW_HIDE)

#define EnableDlgItem(h, i, f)  \
            EnableWindow(GetDlgItem(h, i), f)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\audit.h ===
/****************************** Module Header ******************************\
* Module Name: audit.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines utility routines that deal with the system audit log
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

//
// Exported function prototypes
//


BOOL
GetAuditLogStatus(
    PGLOBALS
    );

BOOL
DisableAuditing(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\authmon.cxx ===
#ifdef SMARTCARD_DOGFOOD
#include "msgina.h"
#include <stdio.h>
#include <Wincrypt.h>

#include "tchar.h"
#include "authmon.h"

#include "sql.h"
#include "sqlext.h"
#include "sqltypes.h"
#include "odbcss.h"

#define SQL_CALL_SUCCESS(status) (status == SQL_SUCCESS || status == SQL_SUCCESS_WITH_INFO)
                 
#if DBG || DEBUG
#define DebugPrint(a) _DebugPrint a
void
__cdecl
_DebugPrint(
    LPCTSTR szFormat,
    ...
    )
{
    TCHAR szBuffer[512];
    va_list ap;

    va_start(ap, szFormat);
    _vstprintf(szBuffer, szFormat, ap);
    OutputDebugString(szBuffer);
}

int debugLine = __LINE__;
#define DEBUG_MARKER debugLine = __LINE__

#else

#define DebugPrint(a)
#define DEBUG_MARKER

#endif

typedef struct _AUTH_DATA {

    HANDLE          hHeap;
    BOOL            bConsole;
    WCHAR           szUser[64];
    AUTH_OPERATION  AuthOperation;
    WCHAR           szReader[32];
    WCHAR           szCard[48];
    ULONG           StopWatch;
    NTSTATUS        Status;
    WCHAR           szDomain[32];
    WCHAR           szDC[32];
    BYTE            pCertBlob[4096];
    ULONG           uCertBlob;
    SQLWCHAR        szSQLServer[64];
    SQLWCHAR        szSQLUser[64];
    SQLWCHAR        szSQLPassword[64];
    SQLWCHAR        szSQLDatabase[64];

} AUTH_DATA, *PAUTH_DATA;


DWORD 
WINAPI
WriteLogonData(
    PAUTH_DATA pAuthData
    )
{
    SQLRETURN RetCode = SQL_SUCCESS;
    HSTMT hStmt = NULL;
    HENV hEnv = NULL, hDbc = NULL;
    BOOL bConnected = FALSE;
    SQLSMALLINT cbConnect = 0;
    static SQLWCHAR szConnect[256], szInConnect[256];

    __try {

        RetCode = SQLAllocHandle(
            SQL_HANDLE_ENV, 
            SQL_NULL_HANDLE,
            &hEnv
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        RetCode = SQLSetEnvAttr(
            hEnv,
            SQL_ATTR_ODBC_VERSION,
            (SQLPOINTER) SQL_OV_ODBC3,  
            SQL_IS_INTEGER
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        RetCode = SQLAllocHandle(
            SQL_HANDLE_DBC,
            hEnv,
            &hDbc
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        RetCode = SQLSetConnectAttr(
            hDbc, 
            SQL_ATTR_LOGIN_TIMEOUT, 
            (SQLPOINTER) 120,
            SQL_IS_UINTEGER
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        RetCode = SQLSetConnectAttr(
            hDbc, 
            SQL_COPT_SS_INTEGRATED_SECURITY, 
            (SQLPOINTER) SQL_IS_OFF,
            SQL_IS_INTEGER
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        _snwprintf(
            szInConnect,
            sizeof(szInConnect) / sizeof(SQLWCHAR),
            (const wchar_t *) L"DRIVER=SQL Server;Server=%s;UID=%s;PWD=%s;DATABASE=%s",
            pAuthData->szSQLServer,
            pAuthData->szSQLUser,
            pAuthData->szSQLPassword,
            pAuthData->szSQLDatabase
            );

        RetCode = SQLDriverConnect(
            hDbc,
            NULL,
            szInConnect,
            SQL_NTS,
            szConnect,
            sizeof(szConnect) / sizeof(szConnect[0]),
            &cbConnect,
            SQL_DRIVER_NOPROMPT
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        bConnected = TRUE;

        RetCode = SQLAllocHandle(
            SQL_HANDLE_STMT,
            hDbc, 
            &hStmt
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        static WCHAR szStatement[] = 
            L"INSERT INTO AuthMonitor ("
            L"BUILDLAB,"
            L"CARD,"
            L"CERTISSUER,"
            L"DC,"
            L"DOMAIN,"
            L"MACHINENAME,"
            L"READER,"
            L"SESSION,"
            L"STATUS,"
            L"STOPWATCH,"
            L"TIMESTAMP,"
            L"UNLOCK,"
            L"USERNAME"
            L") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)";

        RetCode = SQLPrepare(
            hStmt,
            szStatement, 
            SQL_NTS
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        SQLUSMALLINT iParamNo = 1;

        //
        // BUILDLAB
        //
        HKEY hKey;
        DWORD dwStatus = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &hKey
            );

        static WCHAR szBuild[MAX_PATH];
        DWORD cbBuild = sizeof(szBuild);
        wcscpy(szBuild, L"");

        if (dwStatus == ERROR_SUCCESS) {

            DWORD dwType = REG_SZ;
            dwStatus = RegQueryValueEx(
                hKey,
                L"BuildLab",
                0,
                &dwType,
                (LPBYTE) szBuild,
                &cbBuild
                );

            if (dwStatus != ERROR_SUCCESS) {

                dwStatus = RegQueryValueEx(
                    hKey,
                    L"CurrentBuildNumber",
                    0,
                    &dwType,
                    (LPBYTE) szBuild,
                    &cbBuild
                    );
            }

            RegCloseKey(hKey);
        }

        SQLLEN cbBuildLab = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            64,
            0,
            szBuild,
            0,
            &cbBuildLab
            );

        //
        // CARD
        //
        SQLLEN cbCard = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            48,
            0,
            pAuthData->szCard,
            0,
            &cbCard
            );

        //
        // CERTISSUER
        //
        PCERT_CONTEXT pCert = (PCERT_CONTEXT) CertCreateCertificateContext( 
            X509_ASN_ENCODING,
            pAuthData->pCertBlob,
            pAuthData->uCertBlob
            );

        WCHAR szIssuer[64] = L"";       
        if (pCert) {
        
            // intentionally ignore errors
            CertGetNameString(
                pCert,
                CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                szIssuer,
                sizeof(szIssuer) / sizeof(szIssuer[0])
                );

            CertFreeCertificateContext(pCert);
        }

        SQLLEN cbIssuer = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            64,
            0,
            szIssuer,
            0,
            &cbIssuer
            );

        //
        // DC
        //
        PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;

        dwStatus = DsGetDcName(
            NULL, 
            pAuthData->szDomain, 
            NULL, 
            NULL,
            DS_IS_FLAT_NAME | DS_RETURN_FLAT_NAME,
            &pDCInfo
            );

        static WCHAR szDC[MAX_PATH];
        wcscpy(szDC, L"");

        static WCHAR szDomain[sizeof(pAuthData->szDomain)];
        wcscpy(szDomain, L"");

        if (dwStatus == ERROR_SUCCESS) {

            wcscpy(szDC, pDCInfo->DomainControllerName);
            wcscpy(szDomain, pDCInfo->DomainName);
            NetApiBufferFree(pDCInfo);
        }

        SQLLEN cbDC = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            32,
            0,
            szDC,
            0,
            &cbDC
            );

        //
        // DOMAIN
        //
        if (pAuthData->szDomain[0] == L'\0') {

            PWCHAR pszPos;
            if (pszPos = wcschr(pAuthData->szUser, L'@')) {

                wcscpy(szDomain, pszPos + 1);

                if (pszPos = wcschr(szDomain, L'.')) {

                    *pszPos = L'\0';
                }
            }

        } else {

            wcscpy(szDomain, pAuthData->szDomain);
        }

        SQLLEN cbDomain = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            32,
            0,
            szDomain,
            0,
            &cbDomain
            );

        //
        // MACHINENAME
        //
        static WCHAR szMachineName[MAX_PATH];
        wcscpy(szMachineName, L"");

        DWORD dwMachineName = sizeof(szMachineName)/sizeof(szMachineName[0]);

        // intentionally ignore any failures
        GetComputerNameEx(
            ComputerNameDnsHostname, 
            szMachineName,         
            &dwMachineName    
            );

        SQLLEN cbMachineName = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            64,
            0,
            szMachineName,
            0,
            &cbMachineName
            );

        //
        // READER
        //
        SQLLEN cbReader = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            32,
            0,
            pAuthData->szReader,
            0,
            &cbReader
            );

        //
        // SESSION
        //
        SQLLEN cbSession = 0;
        BOOL bSession = !pAuthData->bConsole;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_SHORT,
            SQL_SMALLINT,
            0,
            0,
            &bSession,
            0,
            &cbSession
            );

        //
        // STATUS
        //
        SQLLEN cbStatus = 0;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_LONG,
            SQL_INTEGER,
            0,
            0,
            &pAuthData->Status,
            0,
            &cbStatus
            );

        //
        // STOPWATCH
        //
        SQLLEN cbStopWatch = 0;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_ULONG,
            SQL_INTEGER,
            0,
            0,
            &pAuthData->StopWatch,
            0,
            &cbStopWatch
            );

        //
        // TIMESTAMP
        //
        TIMESTAMP_STRUCT TimeStamp;
        SYSTEMTIME SystemTime;

        GetLocalTime(&SystemTime);

        TimeStamp.day = SystemTime.wDay;
        TimeStamp.month = SystemTime.wMonth;
        TimeStamp.year = SystemTime.wYear;
        TimeStamp.hour = SystemTime.wHour;
        TimeStamp.minute = SystemTime.wMinute;
        TimeStamp.second = SystemTime.wSecond;
        TimeStamp.fraction = 0;

        SQLLEN cbTimeStamp = 0;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_TIMESTAMP, 
            SQL_TIMESTAMP,
            19,
            0,
            &TimeStamp,
            0,
            &cbTimeStamp
            );

        //
        // UNLOCK
        //
        SQLLEN cbAuthOperation = 0;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_SHORT,
            SQL_SMALLINT,
            0,
            0,
            &pAuthData->AuthOperation,
            0,
            &cbAuthOperation
            );

        //
        // USERNAME
        //
        static WCHAR szUser[sizeof(pAuthData->szUser)];
        wcscpy(szUser, pAuthData->szUser);

        if (PWCHAR pszPos = wcschr(szUser, L'@')) {
            *pszPos = L'\0';
        }

        SQLLEN cbUserName = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            64,
            0,
            szUser,
            0,
            &cbUserName
            );

        RetCode = SQLExecute(hStmt);
        DEBUG_MARKER;
    }
    __finally {

    }

    if (!SQL_CALL_SUCCESS(RetCode)) {

        SDWORD      swError;
        static      SQLWCHAR    szErrorMsg[SQL_MAX_MESSAGE_LENGTH];
        SWORD       swErrorMsg;
        SQLWCHAR    szSQLState[50];

        SQLError(
            hEnv, 
            hDbc, 
            hStmt, 
            szSQLState,
            &swError, 
            szErrorMsg, 
            SQL_MAX_MESSAGE_LENGTH - 1, 
            &swErrorMsg
            );

        DebugPrint(
            (L"AuthMonitor: Error WriteLogonData (%d) - %s (%s)\n   [%s]", 
            debugLine,
            szErrorMsg,
            szSQLState,
            szInConnect)
            );
    }

    if (hStmt) {

        SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
        hStmt = NULL;
    }

    if (hDbc) {

        if (bConnected) {
            SQLDisconnect(hDbc);
            bConnected = FALSE;
        }
        SQLFreeHandle(SQL_HANDLE_DBC, hDbc);
        hDbc = NULL;
    }

    if (hEnv) {

        SQLFreeHandle(SQL_HANDLE_ENV, hEnv);
        hEnv = NULL;
    }

    HeapFree(pAuthData->hHeap, 0, pAuthData);

    DebugPrint(
        (L"AuthMonitor: WriteLogonData %s\n", 
        (SQL_CALL_SUCCESS(RetCode) ? L"succeeded" : L"failed"))
        );

    return 0;
}

EXTERN_C HANDLE AuthMonitor(
    AUTH_OPERATION AuthOper,
    BOOL Console,
    PUNICODE_STRING User,
    PUNICODE_STRING Domain,
    PWSTR Card,
    PWSTR Reader,
    PKERB_SMART_CARD_PROFILE Profile,
    DWORD Timer,
    NTSTATUS Status
    )   
{
    PAUTH_DATA pAuthData = NULL;
    HANDLE hHeap = NULL;
    HANDLE hThread = NULL;
    HKEY hKey = NULL;

    LONG lResult = RegOpenKeyEx(
      HKEY_LOCAL_MACHINE,
          TEXT("SOFTWARE\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
          0,
          KEY_READ,
          &hKey
          );

    if (lResult != ERROR_SUCCESS) {

        return NULL;
    }

    __try {

        DWORD dwSize, dwType, dwEnabled = 0;

        dwSize = sizeof(dwEnabled);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonEnabled"),
            0,
            &dwType,
            (PBYTE) &dwEnabled,
            &dwSize
            );
    
        if (lResult != ERROR_SUCCESS || dwType != REG_DWORD || dwEnabled == 0) {

            DEBUG_MARKER;
            __leave;
        }

        hHeap = GetProcessHeap();

        if (hHeap == NULL) {

            DEBUG_MARKER;
            __leave;
        }

        pAuthData = (PAUTH_DATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(AUTH_DATA));

        if (pAuthData == NULL) {

            DEBUG_MARKER;
            __leave;
        }

        dwSize = sizeof(pAuthData->szSQLServer);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonServer"),
            0,
            &dwType,
            (PBYTE) &pAuthData->szSQLServer,
            &dwSize
            );
    
        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {

            DEBUG_MARKER;
            __leave;
        }

        dwSize = sizeof(pAuthData->szSQLUser);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonUser"),
            0,
            &dwType,
            (PBYTE) &pAuthData->szSQLUser,
            &dwSize
            );
    
        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {

            DEBUG_MARKER;
            __leave;
        }

        dwSize = sizeof(pAuthData->szSQLPassword);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonPassword"),
            0,
            &dwType,
            (PBYTE) &pAuthData->szSQLPassword,
            &dwSize
            );
    
        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {

            DEBUG_MARKER;
            __leave;
        }

        dwSize = sizeof(pAuthData->szSQLDatabase);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonDatabase"),
            0,
            &dwType,
            (PBYTE) &pAuthData->szSQLDatabase,
            &dwSize
            );

        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {

            DEBUG_MARKER;
            __leave;
        }

        pAuthData->hHeap = hHeap;
        pAuthData->AuthOperation = AuthOper;
        pAuthData->bConsole = Console;
        memcpy(pAuthData->szDomain, Domain->Buffer, Domain->Length);
        memcpy(pAuthData->szUser, User->Buffer, User->Length);
        if (Card) {
            wcscpy(pAuthData->szCard, Card);
        }
        if (Reader) {
            wcscpy(pAuthData->szReader, Reader);
        }
        if (Profile && Profile->CertificateData && (Profile->CertificateSize < sizeof(pAuthData->pCertBlob))) {
            memcpy(
                pAuthData->pCertBlob, 
                Profile->CertificateData, 
                Profile->CertificateSize
                );
            pAuthData->uCertBlob = Profile->CertificateSize;
        }
        pAuthData->StopWatch = Timer;
        pAuthData->Status = Status;

        hThread = CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) WriteLogonData,
            pAuthData,
            0,
            NULL
            );
        DEBUG_MARKER;
    }
    __finally {

        if (hKey) {

            RegCloseKey(hKey);
        }

        if (hThread == NULL) {

            if (pAuthData) {

                HeapFree(hHeap, 0, pAuthData);
            }

            DebugPrint((L"AuthMonitor: Error line %d\n", debugLine));
        }
#ifndef TEST
        else
        {
            CloseHandle(hThread);
            hThread = NULL;
        }
#endif
    }

    return hThread;
}

#ifdef TEST
_cdecl main()
{
    UNICODE_STRING Domain, User;
    HANDLE hThread = NULL;

    RtlInitUnicodeString(
        &Domain,
        L""
        );

    RtlInitUnicodeString(
        &User,
        L"Klaus"
        );

    hThread = AuthMonitor(
        AuthOperLogon,
        0,
        &User,
        &Domain,
        L"Gemplus",
        L"Utimaco",
        NULL,
        10,
        0
        );

    if (hThread) {

        WaitForSingleObjectEx(hThread, INFINITE, FALSE);
    }
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\brand.c ===
/*----------------------------------------------------------------------------
/ Title;
/   util.c
/
/ Authors;
/   David De Vorchik (daviddv)
/
/   Modified by dsheldon
/
/ Notes;
/   Code for handling bitmap images placed in the dialogs
/----------------------------------------------------------------------------*/
#include "msgina.h"

#include <tchar.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <winbrand.h>


//
// Loaded resources for the branding images that we display
//

HPALETTE g_hpalBranding = NULL;           // palette the applies to all images

HBITMAP g_hbmOtherDlgBrand = NULL;
SIZE g_sizeOtherDlgBrand = { 0 };

HBITMAP g_hbmLogonBrand = NULL;
SIZE g_sizeLogonBrand = { 0 };

HBITMAP g_hbmBand = NULL;
SIZE g_sizeBand = { 0 };

HBRUSH g_hbrBackground = NULL;

BOOL g_fDeepImages = FALSE;
BOOL g_fNoPalleteChanges = FALSE;

VOID ReLoadBrandingImages(
    BOOL fDeepImages,
    BOOL* pfTextOnLarge, 
    BOOL* pfTextOnSmall);


/*-----------------------------------------------------------------------------
/ LoadImageGetSize
/ ----------------
/   Load the image returning the given HBITMAP, having done this we can
/   then get the size from it.
/
/ In:
/   hInstance,resid = object to be loaded.
/   pSize = filled with size information about the object
/
/ Out:
/   HBITMAP / == NULL if nothing loaded
/----------------------------------------------------------------------------*/
HBITMAP LoadBitmapGetSize(HINSTANCE hInstance, UINT resid, SIZE* pSize)
{
    HBITMAP hResult = NULL;
    DIBSECTION ds = {0};

    //
    // Load the image from the resource then lets get the DIBSECTION header
    // from the bitmap object we can then read the size from it and
    // return that to the caller.
    //

    hResult = LoadImage(hInstance, MAKEINTRESOURCE(resid),
                            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if ( hResult )
    {
        GetObject(hResult, sizeof(ds), &ds);

        pSize->cx = ds.dsBmih.biWidth;
        pSize->cy = ds.dsBmih.biHeight;

        //
        // pSize->cy -ve then make +ve, -ve indicates bits are vertically
        // flipped (bottom left, top left).
        //

        if ( pSize->cy < 0 )
            pSize->cy -= 0;
    }

    return hResult;
}



/*-----------------------------------------------------------------------------
/ MoveChildren
/ ------------
/   Move the controls in the given by the specified delta.

/ In:
/   hWnd = window to move
/   dx/dy = delta to be applied
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID MoveChildren(HWND hWnd, INT dx, INT dy)
{
    HWND hWndSibling;
    RECT rc;

    //
    // walk all the children in the dialog adjusting their positions
    // by the delta.
    //

    for ( hWndSibling = GetWindow(hWnd, GW_CHILD) ; hWndSibling ; hWndSibling = GetWindow(hWndSibling, GW_HWNDNEXT))
    {
        GetWindowRect(hWndSibling, &rc);
        MapWindowPoints(NULL, GetParent(hWndSibling), (LPPOINT)&rc, 2);
        OffsetRect(&rc, dx, dy);

        SetWindowPos(hWndSibling, NULL,
                     rc.left, rc.top, 0, 0,
                     SWP_NOZORDER|SWP_NOSIZE);
    }

    //
    // having done that then lets adjust the parent size accordingl.
    //

    GetWindowRect(hWnd, &rc);
    MapWindowPoints(NULL, GetParent(hWnd), (LPPOINT)&rc, 2);

    SetWindowPos(hWnd, NULL,
                 0, 0, (rc.right-rc.left)+dx, (rc.bottom-rc.top)+dy,
                 SWP_NOZORDER|SWP_NOMOVE);
}


/*-----------------------------------------------------------------------------
/ MoveControls
/ ------------
/   Load the image and add the control to the dialog.
/
/ In:
/   hWnd = window to move controls in
/   aID, cID = array of control ids to be moved
/   dx, dy = deltas to apply to controls
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID MoveControls(HWND hWnd, UINT* aID, INT cID, INT dx, INT dy, BOOL fSizeWnd)
{
    RECT rc;

    // if hWnd is mirrored then move the controls in the other direction.
    if (GetWindowLongPtr(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) 
    {
        dx = -dx;
    }

    while ( --cID >= 0 )
    {
        HWND hWndCtrl = GetDlgItem(hWnd, aID[cID]);

        if ( hWndCtrl )
        {
            GetWindowRect(hWndCtrl, &rc);
            MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);
            OffsetRect(&rc, dx, dy);
            SetWindowPos(hWndCtrl, NULL, rc.left, rc.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
        }
    }

    if ( fSizeWnd )
    {
        GetWindowRect(hWnd, &rc);
        MapWindowPoints(NULL, GetParent(hWnd), (LPPOINT)&rc, 2);
        SetWindowPos(hWnd, NULL,
                     0, 0, (rc.right-rc.left)+dx, (rc.bottom-rc.top)+dy,
                     SWP_NOZORDER|SWP_NOMOVE);
    }
}


/*-----------------------------------------------------------------------------
/ LoadBrandingImages
/ ------------------
/   Load the resources required to brand the gina.  This copes with
/   the depth changes.
/
/ In:
/ Out:
/   -
/----------------------------------------------------------------------------*/

#define REGSTR_CUSTOM_BRAND /*HKEY_LOCAL_MACHINE\*/ \
TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\CustomBrand\\")

// bitmap subkeys
#define REGSTR_OTHERDLG_4BIT TEXT("{F20B21BE-5E3D-11d2-8789-68CB20524153}")
#define REGSTR_OTHERDLG_8BIT TEXT("{F20B21BF-5E3D-11d2-8789-68CB20524153}")
#define REGSTR_LOGON_4BIT TEXT("{F20B21C0-5E3D-11d2-8789-68CB20524153}")
#define REGSTR_LOGON_8BIT TEXT("{F20B21C1-5E3D-11d2-8789-68CB20524153}")
#define REGSTR_BAND_4BIT TEXT("{F20B21C4-5E3D-11d2-8789-68CB20524153}")
// The palette is read from the 8-bit band if applicable
#define REGSTR_BAND_8BIT TEXT("{F20B21C5-5E3D-11d2-8789-68CB20524153}")

#define REGSTR_PAINTTEXT_VAL  TEXT("DontPaintText")  

// The default values of these subkeys should be of the form "<dllname>,-<resid>"
// Example: msgina.dll,-130
// The specified bitmap will be loaded from the dll & resid specified.


BOOL GetBrandingModuleAndResid(LPCTSTR szRegKeyRoot, LPCTSTR szRegKeyLeaf, UINT idDefault, 
                               HINSTANCE* phMod, UINT* pidRes, BOOL* pfPaintText)
{
    TCHAR szRegKey[256];
    BOOL fCustomBmpUsed = FALSE;
    HKEY hkey;
    LONG lResult;
    *phMod = NULL;
    *pidRes = 0;
    *pfPaintText = TRUE;

    _tcscpy(szRegKey, szRegKeyRoot);
    _tcscat(szRegKey, szRegKeyLeaf);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0 /*reserved*/,
        KEY_READ, &hkey);

    if (lResult == ERROR_SUCCESS)
    {
        TCHAR szUnexpanded[MAX_PATH + 1];
        TCHAR szModAndId[MAX_PATH + 1];
        DWORD dwType;
        DWORD cbData = sizeof(szUnexpanded);

        lResult = RegQueryValueEx(hkey, NULL /*default value*/, NULL /*reserved*/,
            &dwType, (LPBYTE) szUnexpanded, &cbData);

        if (lResult == ERROR_SUCCESS)
        {
            // expand any environment strings here
            if (ExpandEnvironmentStrings(szUnexpanded, szModAndId, 
                ARRAYSIZE(szModAndId)) != 0)
            {
                // Get the module name and id number
                LPTSTR pchComma;
                int NegResId;

                pchComma = _tcsrchr(szModAndId, TEXT(','));
                
                // Ensure that the resid is present
                if (pchComma)
                {
                    *pchComma = TEXT('\0');

                    // Now szModAndId is just the module string - get the resid
                    NegResId = _ttoi(pchComma + 1);

                    // Ensure this is a NEGATIVE number!
                    if (NegResId < 0)
                    {
                        BOOL fDontPaintText;

                        // We're good to go
                        *pidRes = 0 - NegResId;

                        // Now load the specified module
                        *phMod = LoadLibrary(szModAndId);

                        fCustomBmpUsed = (*phMod != NULL);

                        // Now see if we need to paint text on this bitmap
                        cbData = sizeof(BOOL);
                        RegQueryValueEx(hkey, REGSTR_PAINTTEXT_VAL, NULL,
                            &dwType, (LPBYTE) &fDontPaintText, &cbData);

                        *pfPaintText = !fDontPaintText;
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    // If we didn't get a custom bitmap, use the default
    if (!fCustomBmpUsed)
    {
        *pidRes = idDefault;
        *phMod = hDllInstance;
    }

    return fCustomBmpUsed;
}

void LoadBranding(BOOL fDeepImages, BOOL* pfTextOnLarge, BOOL* pfTextOnSmall)
{
    HINSTANCE hResourceDll;
    UINT idBitmap;
    LPTSTR pszRegkeyLeafLogonBmp;
    LPTSTR pszRegkeyLeafOtherDlgBmp;
    UINT idDefaultSmall;
    UINT idDefaultLarge;
    UINT uXpSpLevel = 0;
    HINSTANCE hWinBrandDll = NULL;

    pszRegkeyLeafOtherDlgBmp = fDeepImages ? REGSTR_OTHERDLG_8BIT : REGSTR_OTHERDLG_4BIT;
    pszRegkeyLeafLogonBmp = fDeepImages ? REGSTR_LOGON_8BIT : REGSTR_LOGON_4BIT;

    if (IsOS(OS_DATACENTER))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_DCS_8 : IDB_SMALL_DCS_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_DCS_8 : IDB_MEDIUM_DCS_4;
    }
    else if (IsOS(OS_ADVSERVER))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_ADV_8 : IDB_SMALL_ADV_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_ADV_8 : IDB_MEDIUM_ADV_4;
    }
    else if (IsOS(OS_SERVER))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_SRV_8 : IDB_SMALL_SRV_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_SRV_8 : IDB_MEDIUM_SRV_4;
    }
    else if (IsOS(OS_PERSONAL))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_PER_8 : IDB_SMALL_PER_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_PER_8 : IDB_MEDIUM_PER_4;
    }
    else
    {
        if (IsOS(OS_EMBEDDED))
        {
            idDefaultSmall = fDeepImages ? IDB_SMALL_PROEMB_8 : IDB_SMALL_PROEMB_4;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PROEMB_8 : IDB_MEDIUM_PROEMB_4;
        }
        else if (IsOS(OS_TABLETPC))
        {
            uXpSpLevel = 1;
            idDefaultSmall = fDeepImages ? IDB_SMALL_PROTAB_8_MSGINA_DLL : IDB_SMALL_PROTAB_4_MSGINA_DLL;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PROTAB_8_MSGINA_DLL : IDB_MEDIUM_PROTAB_4_MSGINA_DLL;
        }
        else if (IsOS(OS_MEDIACENTER))
        {
            uXpSpLevel = 1;
            idDefaultSmall = fDeepImages ? IDB_SMALL_PROMED_8_MSGINA_DLL : IDB_SMALL_PROMED_4_MSGINA_DLL;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PROMED_8_MSGINA_DLL : IDB_MEDIUM_PROMED_4_MSGINA_DLL;
        }
        else
        {
            idDefaultSmall = fDeepImages ? IDB_SMALL_PRO_8 : IDB_SMALL_PRO_4;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PRO_8 : IDB_MEDIUM_PRO_4;
        }
    }

    //
    // If this is a bitmap added to a Windows XP service pack, attempt to
    // load the special service pack resource DLL. If this fails to load,
    // just default to the Professional bitmaps.
    //

    if (uXpSpLevel > 0)
    {
        hWinBrandDll = LoadLibraryEx(TEXT("winbrand.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (hWinBrandDll == NULL)
        {
            idDefaultSmall = fDeepImages ? IDB_SMALL_PRO_8 : IDB_SMALL_PRO_4;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PRO_8 : IDB_MEDIUM_PRO_4;
        }
    }
    
    // Load the bitmap
    GetBrandingModuleAndResid(REGSTR_CUSTOM_BRAND, pszRegkeyLeafOtherDlgBmp, idDefaultSmall,
        &hResourceDll, &idBitmap, pfTextOnSmall);

    if ((hResourceDll == hDllInstance) && (hWinBrandDll != NULL))
    {
        hResourceDll = hWinBrandDll;
    }

    if (g_hbmOtherDlgBrand != NULL)
    {
        DeleteObject(g_hbmOtherDlgBrand);
        g_hbmOtherDlgBrand = NULL;
    }

    g_hbmOtherDlgBrand = LoadBitmapGetSize(hResourceDll, idBitmap, &g_sizeOtherDlgBrand);
    
    //
    // If this is the special service pack resource DLL, don't free it just
    // yet; we probably need it for the default large bitmap also.
    //
    
    if ((hResourceDll != hDllInstance) && (hWinBrandDll == NULL))
    {
        FreeLibrary(hResourceDll);
    }

    GetBrandingModuleAndResid(REGSTR_CUSTOM_BRAND, pszRegkeyLeafLogonBmp, idDefaultLarge,
        &hResourceDll, &idBitmap, pfTextOnLarge);

    if ((hResourceDll == hDllInstance) && (hWinBrandDll != NULL))
    {
        hResourceDll = hWinBrandDll;
    }

    if (g_hbmLogonBrand != NULL)
    {
        DeleteObject(g_hbmLogonBrand);
        g_hbmLogonBrand = NULL;
    }

    g_hbmLogonBrand = LoadBitmapGetSize(hResourceDll, idBitmap, &g_sizeLogonBrand);

    //
    // If this is the special service pack resource DLL, or a normal custom
    // bitmap DLL, free it now.
    //
    
    if ((hResourceDll != hDllInstance) || (hWinBrandDll != NULL))
    {
        FreeLibrary(hResourceDll);
    }
}

void LoadBand(BOOL fDeepImages)
{
    HINSTANCE hResourceDll;
    UINT idBitmap;
    BOOL fPaintText; // Ignored

    // Workstation bitmap load - see if we have custom bmp
    GetBrandingModuleAndResid(REGSTR_CUSTOM_BRAND,
        fDeepImages ? REGSTR_BAND_8BIT : REGSTR_BAND_4BIT,
        fDeepImages ? IDB_BAND_8 : IDB_BAND_4, &hResourceDll, &idBitmap, &fPaintText);

    if (g_hbmBand != NULL)
    {
        DeleteObject(g_hbmBand);
        g_hbmBand = NULL;
    }

    g_hbmBand = LoadBitmapGetSize(hResourceDll, idBitmap, &g_sizeBand);

    if (hResourceDll != hDllInstance)
    {
        FreeLibrary(hResourceDll);
    }
}

VOID ReLoadBrandingImages(
    BOOL fDeepImages,
    BOOL* pfTextOnLarge, 
    BOOL* pfTextOnSmall)
{
    HDC hDC;
    RGBQUAD rgb[256];
    LPLOGPALETTE pLogPalette;
    INT i;
    BOOL fTextOnLarge;
    BOOL fTextOnSmall;
    
    hDC = CreateCompatibleDC(NULL);

    if ( !hDC )
        return;

    //
    // Load the resources we need
    //

    LoadBranding(
        fDeepImages, 
        (pfTextOnLarge == NULL) ? &fTextOnLarge : pfTextOnLarge, 
        (pfTextOnSmall == NULL) ? &fTextOnSmall : pfTextOnSmall);
    LoadBand(fDeepImages);

    //
    // if we loaded the deep images then take the palette from the 'animated band' bitmap
    // and use that as the one for all the images we are creating.
    //

    if (g_hpalBranding != NULL)
    {
        DeleteObject(g_hpalBranding);
        g_hpalBranding = NULL;
    }

    if ( fDeepImages )
    {
        SelectObject(hDC, g_hbmBand);
        GetDIBColorTable(hDC, 0, 256, rgb);

        pLogPalette = (LPLOGPALETTE)LocalAlloc(LPTR, sizeof(LOGPALETTE)*(sizeof(PALETTEENTRY)*256));

        if ( pLogPalette )
        {
            pLogPalette->palVersion = 0x0300;
            pLogPalette->palNumEntries = 256;

            for ( i = 0 ; i < 256 ; i++ )
            {
                pLogPalette->palPalEntry[i].peRed = rgb[i].rgbRed;
                pLogPalette->palPalEntry[i].peGreen = rgb[i].rgbGreen;
                pLogPalette->palPalEntry[i].peBlue = rgb[i].rgbBlue;
                //pLogPalette->palPalEntry[i].peFlags = 0;
            }
            
            g_hpalBranding = CreatePalette(pLogPalette);
            LocalFree(pLogPalette);
        }
    }
    
    if (g_hbrBackground != NULL)
    {
        DeleteObject(g_hbrBackground);
        g_hbrBackground = NULL;
    }

    if (fDeepImages)
    {
        g_hbrBackground = CreateSolidBrush(RGB(90, 124, 223));
    }
    else
    {
        g_hbrBackground = CreateSolidBrush(RGB(0, 0, 128));
    }
    if (g_hbrBackground == NULL)
    {
        g_hbrBackground = GetStockObject(WHITE_BRUSH);
    }

    DeleteDC(hDC);
}


BOOL DeepImages(BOOL fNoPaletteChanges)
{
    BOOL fDeepImages = FALSE;
    HDC hDC;
    INT nDeviceBits;
    
    //
    // Should we load the "nice" 8 bit per pixel images, or the low res
    // 4 bit versions.
    //

    hDC = CreateCompatibleDC(NULL);

    if ( !hDC )
        return(FALSE);

    nDeviceBits = GetDeviceCaps(hDC, BITSPIXEL);

    if (nDeviceBits > 8)
    {
        fDeepImages = TRUE;
    }

    // If the caller doesn't want to deal with 256-color palette
    // changes, give them 4-bit images.
    if (fNoPaletteChanges && (nDeviceBits == 8))
    {
        fDeepImages = FALSE;
    }   

    DeleteDC(hDC);

    return(fDeepImages);
}

VOID LoadBrandingImages(BOOL fNoPaletteChanges, 
                        BOOL* pfTextOnLarge, BOOL* pfTextOnSmall)
{
    BOOL fDeepImages;

    fDeepImages = DeepImages(fNoPaletteChanges);
    
    ReLoadBrandingImages(fDeepImages, pfTextOnLarge, pfTextOnSmall);

    g_fDeepImages = fDeepImages;  
    g_fNoPalleteChanges = fNoPaletteChanges;  
}

/*-----------------------------------------------------------------------------
/ SizeForBranding
/ ---------------
/   Adjust the size of the dialog to allow for branding.
/
/ In:
/   hWnd = size the window to account for the branding images we are going to
/          add to it.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

VOID SizeForBranding(HWND hWnd, BOOL fLargeBrand)
{
    //
    // All windows have two branding imges, the banner and the band.
    // therefore lets adjust for those.
    //

    if (fLargeBrand)
    {
        MoveChildren(hWnd, 0, g_sizeLogonBrand.cy);
    }
    else
    {
        MoveChildren(hWnd, 0, g_sizeOtherDlgBrand.cy);
    }

    MoveChildren(hWnd, 0, g_sizeBand.cy);
}


/*-----------------------------------------------------------------------------
/ PaintFullBranding
/ -------------
/   Paints the full branding, which includes the copyright notice and
/   "Build on NT" into the given DC.  So here we must realize the palette
/   we want to show and then paint the images.  If fBandOnly is TRUE
/   then we only paint the band.  This is used by the animation code.
/
/ In:
/   hDC = DC to paint into
/   fBandOnly = paint the band only
/   nBackground = the system color index for the bkgnd.
/
/ Out:
/   -
/ dsheldon copied from PaintBranding and modified 11/16/98
/----------------------------------------------------------------------------*/
BOOL PaintBranding(HWND hWnd, HDC hDC, INT bandOffset, BOOL fBandOnly, BOOL fLargeBrand, int nBackground)
{
    HDC hdcBitmap;
    HPALETTE oldPalette = NULL;
    HBITMAP oldBitmap;
    RECT rc = { 0 };
    INT cxRect, cxBand;
    SIZE* psizeBrand;
    HBITMAP* phbmBrand;
    BOOL fTemp;

    fTemp = DeepImages(g_fNoPalleteChanges);
    if (g_fDeepImages != fTemp)
    {
        g_fDeepImages = fTemp;
        ReLoadBrandingImages(fTemp, NULL, NULL);
    }

    // See if we're working with the large or small branding
    if (fLargeBrand)
    {
        psizeBrand = &g_sizeLogonBrand;
        phbmBrand = &g_hbmLogonBrand;
    }
    else
    {
        psizeBrand = &g_sizeOtherDlgBrand;
        phbmBrand = &g_hbmOtherDlgBrand;
    }

    hdcBitmap = CreateCompatibleDC(hDC);

    if ( !hdcBitmap )
        return FALSE;

    GetClientRect(hWnd, &rc);

    if ( g_hpalBranding )
        oldPalette = SelectPalette(hDC, g_hpalBranding, FALSE);

    //
    // paint the band at its animation point (bandOffset)
    //

    oldBitmap = (HBITMAP)SelectObject(hdcBitmap, g_hbmBand);

    cxRect = rc.right-rc.left;
    cxBand = min(g_sizeBand.cx, cxRect);

    StretchBlt(hDC,
               bandOffset, psizeBrand->cy,
               cxRect, g_sizeBand.cy,
               hdcBitmap,
               (g_sizeBand.cx-cxBand)/2, 0,
               cxBand, g_sizeBand.cy,
               SRCCOPY);

    StretchBlt(hDC,
               (-cxRect)+bandOffset, psizeBrand->cy,
               cxRect, g_sizeBand.cy,
               hdcBitmap,
               (g_sizeBand.cx-cxBand)/2, 0,
               cxBand, g_sizeBand.cy,
               SRCCOPY);

    //
    // paint the branding clipped to the current dialog, if for some
    // reason the dialog is wider than the bitmap then lets
    // fill in with white space.
    //

    if ( !fBandOnly )
    {
        int iStretchedPixels;
        RECT rcBackground;

        SelectObject(hdcBitmap, *phbmBrand);

        iStretchedPixels = (cxRect - psizeBrand->cx) / 2;
        if (iStretchedPixels < 0)
        {
            iStretchedPixels = 0;
        }
        BitBlt(hDC, iStretchedPixels, 0, psizeBrand->cx, psizeBrand->cy, hdcBitmap, 0, 0, SRCCOPY);
        if (iStretchedPixels != 0)
        {
            SetRect(&rcBackground, 0, 0, iStretchedPixels, psizeBrand->cy);
            FillRect(hDC, &rcBackground, g_hbrBackground);
            SetRect(&rcBackground, cxRect - iStretchedPixels - 1, 0, cxRect, psizeBrand->cy);
            FillRect(hDC, &rcBackground, g_hbrBackground);
        }

        rc.top = psizeBrand->cy + g_sizeBand.cy;
        FillRect(hDC, &rc, (HBRUSH)IntToPtr(1+nBackground));
    }

    if ( oldBitmap )
        SelectObject(hdcBitmap, oldBitmap);

    if ( oldPalette )
        SelectPalette(hDC, oldPalette, TRUE);

    DeleteDC(hdcBitmap);

    return TRUE;
}


/*-----------------------------------------------------------------------------
/ BrandingQueryNewPalette / BrandingPaletteChanged
/ ------------------------------------------------
/   Handle palette change messages from the system so that we can work correctly
/   on <= 8 bit per pixel devices.
/
/ In:
/   -
/ Out:
/   -
/----------------------------------------------------------------------------*/

BOOL BrandingQueryNewPalete(HWND hDlg)
{
    HDC hDC;
    HPALETTE oldPalette;

    if ( !g_hpalBranding )
        return FALSE;

    hDC = GetDC(hDlg);

    if ( !hDC )
        return FALSE;

    oldPalette = SelectPalette(hDC, g_hpalBranding, FALSE);
    RealizePalette(hDC);
    UpdateColors(hDC);

    InvalidateRect(hDlg, NULL, TRUE);
    UpdateWindow(hDlg);

    if ( oldPalette )
        SelectPalette(hDC, oldPalette, FALSE);

    ReleaseDC(hDlg, hDC);
    return TRUE;
}

BOOL BrandingPaletteChanged(HWND hDlg, HWND hWndPalChg)
{
    HDC hDC;
    HPALETTE oldPalette;

    if ( !g_hpalBranding )
        return FALSE;

    if ( hDlg != hWndPalChg )
    {
        hDC = GetDC(hDlg);

        if ( !hDC )
            return FALSE;

        oldPalette = SelectPalette(hDC, g_hpalBranding, FALSE);
        RealizePalette(hDC);
        UpdateColors(hDC);

        if ( oldPalette )
            SelectPalette(hDC, oldPalette, FALSE);

        ReleaseDC(hDlg, hDC);
    }

    return FALSE;
}

// DrawTextAutoSize helper function:
/***************************************************************************\
* FUNCTION: DrawTextAutoSize
*
* PURPOSE:  Takes the same parameters and returns the same values as DrawText.
*           This function adjusts the bottom of the passed in rectangle as
*           necessary to fit all of the text.
*
*   05-06-98 dsheldon   Created.
\***************************************************************************/
LONG DrawTextAutoSize(HDC hdc, LPCTSTR szString, int cchString, LPRECT prc, UINT uFormat)
{
    LONG yHeight;
    LONG left, right;
    left = prc->left;
    right = prc->right;

    yHeight = DrawText(hdc, szString, cchString, prc, uFormat | DT_CALCRECT);
    if (yHeight != 0)
    {
        prc->left = left;
        prc->right = right;

        yHeight = DrawText(hdc, szString, cchString, prc, uFormat & (~DT_CALCRECT));
    }

    return yHeight;
}

/***************************************************************************\
* FUNCTION: MarkupTextOut
*
* PURPOSE:  Paints a line of marked-up text (with bolding, etc)
*
* IN:       hdc, x, y, text, flags (none so far)
*
* RETURNS:  FALSE == failure
*
* HISTORY:
*
*   11-10-98 dsheldon   Created.
*
\***************************************************************************/
BOOL MarkupTextOut(HDC hdc, int x, int y, LPWSTR szText, DWORD dwFlags)
{
    BOOL fSuccess = FALSE;
    HFONT hBoldFont = NULL;
    HFONT hNormalFont = NULL;
    
    // Get the normal and bold font
    hNormalFont = GetCurrentObject(hdc, OBJ_FONT);

    if (NULL != hNormalFont)
    {
        LOGFONT lf = {0};

        GetObject(hNormalFont, sizeof(lf), (LPVOID) &lf);

        lf.lfWeight = 1000;

        hBoldFont = CreateFontIndirect(&lf);
    }

    if ((NULL != hNormalFont) || (NULL != hBoldFont))
    {
        BOOL fLoop;
        WCHAR* pszStringPart;
        WCHAR* pszExamine;
        int cchStringPart;
        BOOL fBold;
        BOOL fOutputStringPart;

        // Reset current text point
        SetTextAlign(hdc, TA_UPDATECP);
        MoveToEx(hdc, x, y, NULL);

        fLoop = TRUE;
        pszStringPart = szText;
        pszExamine = szText;
        cchStringPart = 0;
        fBold = FALSE;
        while (fLoop)
        {
            // Assume we'll find the end of the current string part
            fOutputStringPart = TRUE;

            // See how long the current string part is; a '\0' or a
            // 'bold tag' may end the current string part
            if (L'\0' == *pszExamine)
            {
                // String is done; loop is over
                fLoop = FALSE;
                fSuccess = TRUE;
            }
            // See if this is a bold tag or an end bold tag
            else if (0 == _wcsnicmp(pszExamine, L"<B>", 3))
            {
                fBold = TRUE;
                pszExamine += 3;
            }
            else if (0 == _wcsnicmp(pszExamine, L"</B>", 4))
            {
                fBold = FALSE;
                pszExamine += 4;
            }
            // TODO: Look for other tags here if needed
            else
            {
                // No tag (same String Part)
                cchStringPart ++;
                pszExamine ++;
                fOutputStringPart = FALSE;
            }

            if (fOutputStringPart)
            {
                TextOut(hdc, 0, 0, pszStringPart, cchStringPart);
                
                // Next string part
                pszStringPart = pszExamine;
                cchStringPart = 0;

                if (fBold)
                {
                    SelectObject(hdc, hBoldFont);
                }
                else
                {
                    SelectObject(hdc, hNormalFont);
                }
            } //if
        } //while
    } //if

    SelectObject(hdc, hNormalFont);
    SetTextAlign(hdc, TA_NOUPDATECP);

    // Clean up bold font if necessary
    if (NULL != hBoldFont)
    {
        DeleteObject(hBoldFont);
    }

    return fSuccess;
}

/***************************************************************************\
* FUNCTION: PaintBitmapText
*
* PURPOSE:  Paints the copyright notice and release/version text on the
*           Splash and Logon bitmaps
*
* IN:       pGinaFonts - Uses the font handles in this structure
*           Also uses global bitmap handles
*
* RETURNS:  void; modifies global bitmaps
*
* HISTORY:
*
*   05-06-98 dsheldon   Created.
*
\***************************************************************************/
VOID PaintBitmapText(PGINAFONTS pGinaFonts, BOOL fTextOnLarge,
                     BOOL fTextOnSmall)
{
    // Various metrics used to draw the text

    // Horizontal Positioning of copyright
    static const int CopyrightRightMargin = 9;
    static const int CopyrightWidth = 134;

    // Vertical positioning of copyright
    static const int CopyrightTop = 21;

    // Vertical for the logon window Beta3 message
    static const int BetaTopNormal = 28;

    // Horizontal
    static const int BetaRightMargin = 13;
    static const int BetaWidth = 100;

    // If we're showing the copyright, draw the "beta3" here
    static const int BetaTopCopyright = 53;

    // Positioning of "Built on NT"
    static const int BuiltOnNtTop = 68;

    static const int BuiltOnNtTopTerminal = 91;

    static const int BuiltOnNtLeft = 186;

    HDC hdcBitmap;
    HBITMAP hbmOld;
    HFONT hfontOld;
    NT_PRODUCT_TYPE NtProductType;

    TCHAR szCopyright[128];
    TCHAR szBuiltOnNt[256];
    TCHAR szRelease[64];
    
    // Used for calculating text drawing areas
    RECT rc;

    BOOL fTemp;

    szCopyright[0] = 0;
    szBuiltOnNt[0] = 0;
    szRelease[0] = 0;

    // Get the product type
    RtlGetNtProductType(&NtProductType);

    // Load the strings that will be painted on the bitmaps
    LoadString(hDllInstance, IDS_RELEASE_TEXT, szRelease, ARRAYSIZE(szRelease));
    LoadString(hDllInstance, IDS_COPYRIGHT_TEXT, szCopyright, ARRAYSIZE(szCopyright));
    LoadString(hDllInstance, IDS_BUILTONNT_TEXT, szBuiltOnNt, ARRAYSIZE(szBuiltOnNt));

    fTemp = DeepImages(g_fNoPalleteChanges);
    if (g_fDeepImages != fTemp)
    {
        g_fDeepImages = fTemp;
        ReLoadBrandingImages(fTemp, NULL, NULL);
    }
    
    // Create a compatible DC for painting the copyright and release/version notices
    hdcBitmap = CreateCompatibleDC(NULL);

    if (hdcBitmap)
    {
        // Set text transparency and color (black)
        SetTextColor(hdcBitmap, RGB(0,0,0));
        SetBkMode(hdcBitmap, TRANSPARENT);
        SetMapMode(hdcBitmap, MM_TEXT);

        // Work with the splash bitmap
        if (fTextOnLarge && g_hbmLogonBrand)
        {
            hbmOld = SelectObject(hdcBitmap, g_hbmLogonBrand);
            hfontOld = SelectObject(hdcBitmap, pGinaFonts->hCopyrightFont);

            if (GetSystemMetrics(SM_REMOTESESSION))
            {
                // paint the copyright notice for remote sessions

                TEXTMETRIC  textMetric;

                (BOOL)GetTextMetrics(hdcBitmap, &textMetric);
                rc.top = g_sizeLogonBrand.cy - textMetric.tmHeight;
                rc.bottom = g_sizeLogonBrand.cy;
                rc.left = textMetric.tmAveCharWidth;
                rc.right = g_sizeLogonBrand.cx;
                DrawTextAutoSize(hdcBitmap, szCopyright, -1, &rc, 0);
            }

            // paint the release/version notice
            SelectObject(hdcBitmap, pGinaFonts->hBetaFont);

            rc.top = BetaTopNormal;
            rc.left = g_sizeLogonBrand.cx - BetaRightMargin - BetaWidth;
            rc.right = g_sizeLogonBrand.cx - BetaRightMargin;

            SetTextColor(hdcBitmap, RGB(128, 128, 128));
            DrawTextAutoSize(hdcBitmap, szRelease, -1, &rc, DT_RIGHT | DT_WORDBREAK);
            SetTextColor(hdcBitmap, RGB(0,0,0));

            // paint the built on NT message
            SelectObject(hdcBitmap, pGinaFonts->hBuiltOnNtFont);

            MarkupTextOut(hdcBitmap, BuiltOnNtLeft, BuiltOnNtTop, szBuiltOnNt, 0);
            
            SelectObject(hdcBitmap, hfontOld);

            SelectObject(hdcBitmap, hbmOld);
        }

        if (fTextOnSmall && g_hbmOtherDlgBrand)
        {
            hbmOld = SelectObject(hdcBitmap, g_hbmOtherDlgBrand);

            // paint the release notice

            hfontOld = SelectObject(hdcBitmap, pGinaFonts->hBetaFont);

            rc.top = BetaTopNormal;
            rc.left = g_sizeOtherDlgBrand.cx - BetaRightMargin - BetaWidth;
            rc.right = g_sizeOtherDlgBrand.cx - BetaRightMargin;

            SetTextColor(hdcBitmap, RGB(128, 128, 128));
            DrawTextAutoSize(hdcBitmap, szRelease, -1, &rc, DT_RIGHT | DT_WORDBREAK);
            SetTextColor(hdcBitmap, RGB(0, 0, 0));

            SelectObject(hdcBitmap, hfontOld);

            SelectObject(hdcBitmap, hbmOld);
        }

        DeleteDC(hdcBitmap);
    }
}



// Two helpers for CreateFonts

void SetFontFaceFromResource(PLOGFONT plf, UINT idFaceName)
// Sets the font face from a specified resource, or uses a default if string load fails
{
    // Read the face name and point size from the resource file
    if (LoadString(hDllInstance, idFaceName, plf->lfFaceName, LF_FACESIZE) == 0)
    {
        lstrcpy(plf->lfFaceName, TEXT("Tahoma"));
        OutputDebugString(TEXT("Could not read welcome font face from resource"));
    }
}

void SetFontSizeFromResource(PLOGFONT plf, UINT idSizeName)
// Sets the font size from a resource, or uses a default if the string load fails.
// Now uses pixel height instead of point size
{
    TCHAR szPixelSize[10];
    LONG nSize;
    HDC hdcScreen;

    if (LoadString(hDllInstance, idSizeName, szPixelSize, ARRAYSIZE(szPixelSize)) != 0)
    {
        nSize = _ttol(szPixelSize);
    }
    else
    {
        // Make it really obvious something is wrong
        nSize = 40;
    }

    plf->lfHeight = -nSize;

#if (1) //DSIE: Bug 262839  
    if (hdcScreen = GetDC(NULL))
    {         
        double dScaleY = GetDeviceCaps(hdcScreen, LOGPIXELSY) / 96.0f;
        plf->lfHeight = (int) (plf->lfHeight * dScaleY); // Scale the height based on the system DPI.
        ReleaseDC(NULL, hdcScreen);
    }
#endif
}


/***************************************************************************\
* FUNCTION: CreateFonts
*
* PURPOSE:  Creates the fonts for the welcome and logon screens
*
* IN/OUT:   pGinaFonts - Sets the font handles in this structure
*
* RETURNS:  void; also see IN/OUT above
*
* HISTORY:
*
*   05-05-98 dsheldon   Created.
*
\***************************************************************************/
void CreateFonts(PGINAFONTS pGinaFonts)
{
    LOGFONT lf = {0};
    CHARSETINFO csInfo;

    lf.lfWidth = 0;
    lf.lfWeight = FW_NORMAL;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH;

    // Set charset
    if (TranslateCharsetInfo((DWORD*)IntToPtr(GetACP()), &csInfo,
        TCI_SRCCODEPAGE) == 0)
    {
        csInfo.ciCharset = 0;
    }

    lf.lfCharSet = (UCHAR)csInfo.ciCharset;


    if (pGinaFonts->hWelcomeFont == NULL)
    {
        // Create the welcome font
        SetFontFaceFromResource(&lf, IDS_PRESSCAD_FACENAME);
        SetFontSizeFromResource(&lf, IDS_PRESSCAD_FACESIZE);

        pGinaFonts->hWelcomeFont = CreateFontIndirect(&lf);
    }

    if (pGinaFonts->hBetaFont == NULL)
    {
        // Create the release font for the welcome page
        SetFontFaceFromResource(&lf, IDS_RELEASE_FACENAME);
        SetFontSizeFromResource(&lf, IDS_RELEASE_FACESIZE);

        pGinaFonts->hBetaFont = CreateFontIndirect(&lf);
    }

    if (pGinaFonts->hCopyrightFont == NULL)
    {
        // Create the copyright font
        SetFontFaceFromResource(&lf, IDS_COPYRIGHT_FACENAME);
        SetFontSizeFromResource(&lf, IDS_COPYRIGHT_FACESIZE);

        pGinaFonts->hCopyrightFont = CreateFontIndirect(&lf);
    }

    if (pGinaFonts->hBuiltOnNtFont == NULL)
    {
        // Create the "Built on NT Technology" font
        SetFontFaceFromResource(&lf, IDS_BUILTONNT_FACENAME);
        SetFontSizeFromResource(&lf, IDS_BUILTONNT_FACESIZE);

        lf.lfWeight = FW_NORMAL;

        pGinaFonts->hBuiltOnNtFont = CreateFontIndirect(&lf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\chngepwd.h ===
/****************************** Module Header ******************************\
* Module Name: chngepwd.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis used to implement change password functionality of winlogon
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//

#define CHANGEPWD_OPTION_EDIT_DOMAIN    0x00000001      // Allow domain field to be changed
#define CHANGEPWD_OPTION_SHOW_DOMAIN    0x00000002      // Show domain field
#define CHANGEPWD_OPTION_SHOW_NETPROV   0x00000004      // Include network providers
#define CHANGEPWD_OPTION_KEEP_ARRAY     0x00000008      // Use existing domain cache array
#define CHANGEPWD_OPTION_NO_UPDATE      0x00000010      // don't update in-memory hash

#define CHANGEPWD_OPTION_ALL            0x00000007

INT_PTR
ChangePassword(
    IN HWND    hwnd,
    IN PGLOBALS pGlobals,
    IN PWCHAR   UserName,
    IN PWCHAR   Domain,
    IN ULONG    Options
    );

INT_PTR
ChangePasswordLogon(
    IN HWND    hwnd,
    IN PGLOBALS pGlobals,
    IN PWCHAR   UserName,
    IN PWCHAR   Domain,
    IN PWCHAR   OldPassword
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\dialogs.h ===
/****************************** Module Header ******************************\
* Module Name: dialogs.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define contants used by dialog edit when editting dialog.dlg
*
* NOTE - this file is maintained by dlgedit. Do not edit directly
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

//
// Hydra Dialogs
//
#define IDD_CONNECT                 2300
#define IDC_CONNECTBOX              2301
#define IDD_CALLBACK                2310
#define IDD_PHONENUMBER             2311
#define IDD_CALLBACK_WAIT           2320
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-94   RichardW   Created
//
//----------------------------------------------------------------------------


#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG

extern  DWORD   GINAInfoLevel;

#define DebugLog(x) LogEvent x


void    LogEvent(long, const char *, ...);
void    InitDebugSupport(void);

#define DEB_ERROR           0x00000001
#define DEB_WARN            0x00000002
#define DEB_TRACE           0x00000004
#define DEB_TRACE_DOMAIN    0x00000008
#define DEB_TRACE_CACHE     0x00000010


#else

#define DebugLog(x)

#endif



#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

//
//  For ease of debugging the SPMgr, all the debug support functions have
//  been stuck here.  Basically, we read info from win.ini, since that allows
//  us to configure the debug level via a text file (and DOS, for example).
//
//  Format is:
//
//  win.ini
//
//  [SPMgr]
//      DebugFlags=<Flag>[<,Flag>]*
//      Package=<int>
//      BreakFlags=<BreakFlag>[<,BreakFlags>]*
//
//  WHERE:
//      Flag is one of the following:
//          Error, Warning, Trace, Verbose, BreakOnError, Helpers,
//          RefMon, Locator, WAPI, Init, Audit, Db, Lsa
//
//      Package is the name of the dll implementing the package, e.g.
//          NTLM=3
//
//      BreakFlags will cause SPMgr to break, if BreakOnError is set in
//      DebugFlags:
//          InitBegin, InitEnd, Connect, Exception, Problem, Load
//
//

#if DBG         // NOTE:  This file not compiled for retail builds

#include "msgina.h"
#include <stdio.h>
#include <wchar.h>

FILE *  LogFile;
DWORD   BreakFlags = 0;
extern  DWORD   NoUnload;
DWORD   GINAInfoLevel = 3;



// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.

char   szSection[] = "MSGina";
char * DebLevel[] = {"GINA-Error",
                     "GINA-Warn",
                     "GINA-Trace",
                     "GINA-Domain",
                     "GINA-Cache"
                    };

typedef struct _DebugKeys {
    char *  Name;
    DWORD   Value;
} DebugKeys, *PDebugKeys;

DebugKeys   DebugKeyNames[] = {
                {"Error",       DEB_ERROR},
                {"Warning",     DEB_WARN},
                {"Trace",       DEB_TRACE},
                {"Domain",      DEB_TRACE_DOMAIN},
                {"Cache",       DEB_TRACE_CACHE}
                };

#define NUM_DEBUG_KEYS  sizeof(DebugKeyNames) / sizeof(DebugKeys)
#define NUM_BREAK_KEYS  sizeof(BreakKeyNames) / sizeof(DebugKeys)

//+---------------------------------------------------------------------------
//
//  Function:   LogEvent
//
//  Synopsis:   Logs an event to the console and, optionally, a file.
//
//  Effects:
//
//  Arguments:  [Mask]   --
//              [Format] --
//              [Format] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
LogEvent(   long            Mask,
            const char *    Format,
            ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    char    szOutString[256];


    if (Mask & GINAInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }
        if (Level >= (sizeof(DebLevel) / sizeof(char *)) )
        {
            Level = (sizeof(DebLevel) / sizeof(char *)) - 1;
        }


        //
        // Make the prefix first:  "Process.Thread> GINA-XXX"
        //

        PrefixSize = sprintf(szOutString, "%d.%d> %s: ",
                GetCurrentProcessId(), GetCurrentThreadId(), DebLevel[Level]);


        va_start(ArgList, Format);

        if (_vsnprintf(&szOutString[PrefixSize], sizeof(szOutString) - PrefixSize,
                            Format, ArgList) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("GINA!LogEvent:  Could not pack string into 256 bytes\n");

        }
        else
        {
            OutputDebugStringA(szOutString);
        }


        if (LogFile)
        {
            SYSTEMTIME  stTime;
            FILETIME    ftTime;
            FILETIME    localtime;

            NtQuerySystemTime((PLARGE_INTEGER) &ftTime);
            FileTimeToLocalFileTime(&ftTime, &localtime);
            FileTimeToSystemTime(&localtime, &stTime);
            fprintf(LogFile, "%02d:%02d:%02d.%03d: %s\n",
                    stTime.wHour, stTime.wMinute, stTime.wSecond,
                    stTime.wMilliseconds, szOutString);

            fflush(LogFile);
        }

    }

}

void
OpenLogFile(LPSTR   pszLogFile)
{
    LogFile = fopen(pszLogFile, "a");
    if (!LogFile)
    {
        OutputDebugStringA("GINA: Could not open logfile for append");
        OutputDebugStringA(pszLogFile);
    }
    DebugLog((DEB_TRACE, "Log file '%s' begins\n", pszLogFile));
}


DWORD
GetDebugKeyValue(
    PDebugKeys      KeyTable,
    int             cKeys,
    LPSTR           pszKey)
{
    int     i;

    for (i = 0; i < cKeys ; i++ )
    {
        if (_strcmpi(KeyTable[i].Name, pszKey) == 0)
        {
            return(KeyTable[i].Value);
        }
    }
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadDebugParameters
//
//  Synopsis:   Loads debug parameters from win.ini
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
LoadDebugParameters(void)
{
    char    szVal[128];
    char *  pszDebug;
    int     cbVal;

    cbVal = GetProfileStringA(szSection, "DebugFlags", "Error,Warning", szVal, ARRAYSIZE(szVal));

    pszDebug = strtok(szVal, ", \t");
    while (pszDebug)
    {
        GINAInfoLevel |= GetDebugKeyValue(DebugKeyNames, NUM_DEBUG_KEYS, pszDebug);
        pszDebug = strtok(NULL, ", \t");
    }

    cbVal = GetProfileStringA(szSection, "LogFile", "", szVal, ARRAYSIZE(szVal));
    if (cbVal)
    {
        OpenLogFile(szVal);
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the GINAgr
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
InitDebugSupport(void)
{
    LoadDebugParameters();

}



#else // DBG

#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\chngepwd.c ===
/****************************** Module Header ******************************\
* Module Name: chngpwd.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implementation of change-password functionality of winlogon
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

#include "msgina.h"
#include <stdio.h>
#include <wchar.h>
#include <align.h>
#include <keymgr.h>
#include <netlib.h>

typedef void (WINAPI *RUNDLLPROC)(HWND hWndStub,HINSTANCE hInstance,LPWSTR szCommandLine,int nShow);

// #define VERBOSE_UTILS

#ifdef VERBOSE_UTILS
#define VerbosePrint(s) WLPrint(s)
#else
#define VerbosePrint(s)
#endif

//
// Define the structure used to pass data into the change password dialog
//

typedef struct {
    PGLOBALS    pGlobals;
    PWCHAR      UserName;
    PWCHAR      Domain;
    PWCHAR      OldPassword;
    ULONG       Options ;
    BOOL        Impersonate;
    BOOL        AllowProviderOnly;
    WCHAR       UserNameBuffer[MAX_STRING_BYTES];
} CHANGE_PASSWORD_DATA;
typedef CHANGE_PASSWORD_DATA *PCHANGE_PASSWORD_DATA;



typedef 
NTSTATUS 
(WINAPI * GINA_CHANGEPW_FUNC)(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );

//
// Private prototypes
//

NTSTATUS
ProviderChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );

NTSTATUS
MitChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );

NTSTATUS
NtChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );


INT_PTR WINAPI ChangePasswordDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL ChangePasswordDlgInit(HWND, LPARAM);
INT_PTR AttemptPasswordChange(HWND);

BOOL IsAutologonUser(LPCTSTR szUser, LPCTSTR szDomain);
NTSTATUS SetAutologonPassword(LPCTSTR szPassword);

INT_PTR
HandleFailedChangePassword(
    HWND hDlg,
    PGLOBALS pGlobals,
    NTSTATUS Status,
    PWCHAR UserName,
    PWCHAR Domain,
    NTSTATUS SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );


//
// This table corresponds to the DOMAIN_ENTRY_TYPE from domain.h
//
GINA_CHANGEPW_FUNC
ChangePasswordWorkers[] = {
    NULL,                       // DomainInvalid
    NtChangePassword,           // DomainUPN
    NtChangePassword,           // DomainMachine
    NtChangePassword,           // DomainNt4
    NtChangePassword,           // DomainNt5
    MitChangePassword,          // DomainMitRealm
    MitChangePassword,          // DomainMitUntrusted
    ProviderChangePassword      // DomainNetworkProvider
};



// Control arrays for dynamically dorking with the dialog
static UINT ctrlNoDomain[] =
{
    IDD_CHANGEPWD_OLD_LABEL,
    IDD_CHANGEPWD_OLD,
    IDD_CHANGEPWD_NEW_LABEL,
    IDD_CHANGEPWD_NEW,
    IDD_CHANGEPWD_CONFIRM_LABEL,
    IDD_CHANGEPWD_CONFIRM,
    IDD_KBLAYOUT_ICON,
    IDC_BACKUP,
    IDOK,
    IDCANCEL
};


// Do not show the [Backup] button on the msgina dialog if:
//
//  1.  The default domain is not the local machine
//  2.  Over a terminal server session
//  3.  The user name is a UPN name (domain combo box also disabled but not by this fn)
//
BOOL ShowBackupButton(HWND hDlg, PGLOBALS pGlobals)
{
    INT_PTR iItem;
    LPARAM lp;
    int cchBuffer;
    TCHAR* pszLogonName = NULL;
    HWND hwU = GetDlgItem(hDlg,IDD_CHANGEPWD_NAME);
    HWND hwD = GetDlgItem(hDlg,IDD_CHANGEPWD_DOMAIN);
    HWND hwB = GetDlgItem(hDlg,IDC_BACKUP);
    BOOL fEnable = TRUE;
    
    cchBuffer = (int)SendMessage(hwU, WM_GETTEXTLENGTH, 0, 0) + 1;

    pszLogonName = (TCHAR*) Alloc(cchBuffer * sizeof(TCHAR));
    if (pszLogonName != NULL)
    {
        SendMessage(hwU, WM_GETTEXT, (WPARAM) cchBuffer, (LPARAM) pszLogonName);
        // turn off the button if the user is using a
        // UPN (if there is a "@") - ie foo@microsoft.com
        fEnable = (NULL == wcschr(pszLogonName, TEXT('@')));
        Free(pszLogonName);
    }
    
    if (fEnable) 
    {
        // turn off button if is remote session
        fEnable = (0 == GetSystemMetrics(SM_REMOTESESSION));
    }

    if (fEnable)
    {
        // turn off button if selected domain is not local machine
        if (hwD) 
        {
            iItem = SendMessage(hwD,CB_GETCURSEL,0,0);
            if (LB_ERR != iItem)
            {
                // now window active and something selected
                fEnable = FALSE;
                lp = SendMessage(hwD, CB_GETITEMDATA,iItem,0);
                if ((LB_ERR != lp) && (0 != lp))
                {
                    if (DomainMachine == ((PDOMAIN_CACHE_ENTRY)lp)->Type)
                    {
                        fEnable = TRUE;
                    }
                }
            }
        }
    }
    
    //EnableWindow(hwB,fEnable);
    if (fEnable) ShowWindow(hwB,SW_SHOWNORMAL);
    else ShowWindow(hwB,SW_HIDE);
    
    return fEnable;
}

BOOL 
NetworkProvidersPresent(
    VOID
    )
{
    HKEY ProviderKey;
    DWORD Error;
    DWORD ValueType;
    LPTSTR Value;
    BOOL NeedToNotify = TRUE;

#define NET_PROVIDER_ORDER_KEY TEXT("system\\CurrentControlSet\\Control\\NetworkProvider\\Order")
#define NET_PROVIDER_ORDER_VALUE  TEXT("ProviderOrder")
#define NET_ORDER_SEPARATOR  TEXT(',')


    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,     // hKey
                NET_PROVIDER_ORDER_KEY, // lpSubKey
                0,                      // Must be 0
                KEY_QUERY_VALUE,        // Desired access
                &ProviderKey            // Newly Opened Key Handle
                );

    if (Error == ERROR_SUCCESS) {

        Value = AllocAndRegQueryValueEx(
                    ProviderKey,            // Key
                    NET_PROVIDER_ORDER_VALUE,// Value name
                    NULL,                   // Must be NULL
                    &ValueType              // Type returned here
                    );

        if (Value != NULL) {
            if (ValueType == REG_SZ) {

                LPTSTR p = Value;
                while (*p) {
                    if (*p == NET_ORDER_SEPARATOR) {
                        break;
                    }
                    p = CharNext(p);
                }

                if (*p == 0) {

                    //
                    // We got to the end without finding a separator
                    // Only one provider is installed.
                    //

                    if (lstrcmpi(Value, SERVICE_WORKSTATION) == 0) {

                        //
                        // it's Lanman, don't notify
                        //

                        NeedToNotify = FALSE;


                    } else {

                        //
                        //  it isn't Lanman, notify
                        //

                        NeedToNotify = TRUE;
                    }
                }

            } else {
                DebugLog((DEB_ERROR, "NoNeedToNotify - provider order key unexpected type: %d, assuming notification is necessary", ValueType));
            }

            Free(Value);

        } else {
            DebugLog((DEB_ERROR, "NoNeedToNotify - failed to query provider order value, assuming notification is necessary\n"));
        }

        Error = RegCloseKey(ProviderKey);
        ASSERT(Error == ERROR_SUCCESS);
    }

    return NeedToNotify ;
}


BOOL
ShowDomain(
    VOID
    )
{
    return (SafeBootMode != SAFEBOOT_MINIMAL);
}


/***************************************************************************\
* FUNCTION: ChangePassword
*
* PURPOSE:  Attempts to change a user's password
*
* ARGUMENTS:
*
*   hwnd            - the most recent parent window
*   pGlobals        - pointer to global data for this instance.
*                     The password information of this data will be
*                     updated upon successful change of the primary
*                     authenticator's password information.
*   UserName        - the name of the user to change
*   Domain          - the domain name to change the password on
*   AnyDomain       - if TRUE the user may select any trusted domain, or
*                     enter the name of any other domain
*
* RETURNS:
*
*   MSGINA_DLG_SUCCESS     - the password was changed successfully.
*   MSGINA_DLG_FAILURE     - the user's password could not be changed.
*   DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
ChangePassword(
    HWND    hwnd,
    PGLOBALS pGlobals,
    PWCHAR   UserName,
    PWCHAR   Domain,
    ULONG    Options
    )
{
    CHANGE_PASSWORD_DATA    PasswordData;
    INT_PTR Result;
    HWND hwndOldFocus = GetFocus();
    ULONG LocalOptions = 0 ;

    PasswordData.pGlobals = pGlobals;


    PasswordData.UserName = UserName;
    PasswordData.Domain = Domain;
    PasswordData.OldPassword = NULL;
    PasswordData.Impersonate = TRUE;
    PasswordData.AllowProviderOnly = TRUE;

    if ( NetworkProvidersPresent() )
    {
        LocalOptions |= CHANGEPWD_OPTION_SHOW_NETPROV |
                        CHANGEPWD_OPTION_SHOW_DOMAIN ;

    }

    if ( ShowDomain() )
    {
        LocalOptions |= CHANGEPWD_OPTION_EDIT_DOMAIN |
                        CHANGEPWD_OPTION_SHOW_DOMAIN ;
    }

    if ( SafeBootMode == SAFEBOOT_MINIMAL )
    {
        LocalOptions = 0 ;
    }

    PasswordData.Options = (Options & LocalOptions);

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LOGON_TIMEOUT);

    Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                            hDllInstance,
                                            MAKEINTRESOURCE(IDD_CHANGEPWD_DIALOG),
                                            hwnd,
                                            ChangePasswordDlgProc,
                                            (LPARAM)&PasswordData);
    SetFocus(hwndOldFocus);
    return(Result);
}


/***************************************************************************\
* FUNCTION: ChangePasswordLogon
*
* PURPOSE:  Attempts to change a user's password during the logon process.
*           This is the same as a normal change password except that the user
*           does not have to enter the old password and can only change the
*           password in the specified domain. This routine is intended to be
*           called during logon when it is discovered that the user's
*           password has expired.
*
* ARGUMENTS:
*
*   hwnd            - the most recent parent window
*   pGlobals        - pointer to global data for this instance
*   UserName        - the name of the user to change
*   Domain          - the domain name to change the password on
*   OldPassword     - the old user password
*   NewPassword     - points to a buffer that the new password is written
*                     into if the password is changed successfully.
*   NewPasswordMaxBytes - the size of the newpassword buffer.
*
* RETURNS:
*
*   MSGINA_DLG_SUCCESS     - the password was changed successfully, NewPassword
*                     contains the new password text.
*   MSGINA_DLG_FAILURE     - the user's password could not be changed.
*   DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
ChangePasswordLogon(
    HWND    hwnd,
    PGLOBALS pGlobals,
    PWCHAR   UserName,
    PWCHAR   Domain,
    PWCHAR   OldPassword
    )
{
    CHANGE_PASSWORD_DATA PasswordData;
    INT_PTR Result;

    PasswordData.pGlobals = pGlobals;

    PasswordData.UserName = UserName;
    PasswordData.Domain = Domain;
    PasswordData.OldPassword = OldPassword;
    PasswordData.Options =  CHANGEPWD_OPTION_NO_UPDATE ;
    PasswordData.Impersonate = FALSE;
    PasswordData.AllowProviderOnly = FALSE;

    if ( ShowDomain() )
    {
        PasswordData.Options |= CHANGEPWD_OPTION_SHOW_DOMAIN |
                                CHANGEPWD_OPTION_KEEP_ARRAY ;
    }

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LOGON_TIMEOUT);

    Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                            hDllInstance,
                                            MAKEINTRESOURCE( IDD_CHANGEPWD_DIALOG ),
                                            hwnd,
                                            ChangePasswordDlgProc,
                                            (LPARAM)&PasswordData);

    return(Result);
}



/****************************************************************************\
*
* FUNCTION: ChangePasswordDlgProc
*
* PURPOSE:  Processes messages for ChangePassword dialog
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

INT_PTR WINAPI
ChangePasswordDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PCHANGE_PASSWORD_DATA pPasswordData = (PCHANGE_PASSWORD_DATA)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PGLOBALS pGlobals;
    INT_PTR Result;

    switch (message) {

        case WM_INITDIALOG:
            {
                if (!ChangePasswordDlgInit(hDlg, lParam)) {
                    EndDialog(hDlg, MSGINA_DLG_FAILURE);
                }

                return(SetPasswordFocus(hDlg));
            }

        case WM_DESTROY:

            pGlobals = pPasswordData->pGlobals ;

            if ( pGlobals->ActiveArray &&
                 ((pPasswordData->Options & CHANGEPWD_OPTION_KEEP_ARRAY) == 0 ) )
            {
                DCacheFreeArray( pGlobals->ActiveArray );
                pGlobals->ActiveArray = NULL ;
            }

            FreeLayoutInfo(LAYOUT_CUR_USER);

            return( TRUE );

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, FALSE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_SYSCOMMAND:
            if ( wParam == SC_CLOSE )
            {
                EndDialog( hDlg, MSGINA_DLG_FAILURE );
                return TRUE ;
            }
            break;

        case WM_COMMAND:
            {

            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                ShowBackupButton(hDlg,pPasswordData->pGlobals);
                return TRUE;
            }

            switch (LOWORD(wParam)) {
                case IDD_CHANGEPWD_NAME:

                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            // Ensure the domain box is enabled/disabled correctly
                            // in case of a UPN name
                            
                            if ( pPasswordData->Options & CHANGEPWD_OPTION_EDIT_DOMAIN )
                            {
                                EnableDomainForUPN((HWND) lParam, GetDlgItem(hDlg,IDD_CHANGEPWD_DOMAIN));
                                ShowBackupButton(hDlg,pPasswordData->pGlobals);
                            }

                            return TRUE;
                        default:
                            break;
                    }
                    break;
                    
                 case IDC_BACKUP:
                    {
                        BOOL fWrongDomain = TRUE;
                        PDOMAIN_CACHE_ENTRY Entry;
                        HWND hwndDomain = GetDlgItem(hDlg,IDD_CHANGEPWD_DOMAIN);
                        INT iDomainSelection = (INT)SendMessage(hwndDomain,CB_GETCURSEL,0,0);

                        // Get the user's input.  Decide if he has selected other than the local machine
                        if (pPasswordData->Options & CHANGEPWD_OPTION_EDIT_DOMAIN)
                        {
                            // see if selected domain is local machine
                            Entry = (PDOMAIN_CACHE_ENTRY)SendMessage(hwndDomain,CB_GETITEMDATA,iDomainSelection,0);
                            // warning.... Entry can turn out to be ffffffff  (CB_ERR)
                            if (CB_ERR == (ULONG_PTR) Entry)
                            {
                                fWrongDomain = TRUE;
                            }
                            else if (NULL != Entry)
                            {
                                if (Entry->Type == DomainMachine)
                                {
                                    fWrongDomain = FALSE;
                                }
                            }
                        }
                        else fWrongDomain = FALSE;

                        // Show UI or message box
                        if (fWrongDomain)
                        {
                            pGlobals = pPasswordData->pGlobals ;
                            if (NULL == pGlobals) return TRUE;
                            TimeoutMessageBox(hDlg, pGlobals, IDS_MBMWRONGDOMAIN,
                                                     IDS_MBTWRONGDOMAIN,
                                                     MB_OK | MB_ICONEXCLAMATION,
                                                     TIMEOUT_CURRENT);
                            return TRUE;
                        }
                        else 
                        {
                            // standalone case
                            // We use a single export from KEYMGR.DLL for this operation.  When this operation completes,
                            //  we don't use the DLL again without unlikely user intervention.  We could DELAYLOAD keymgr.dll,
                            //  but explicitly loading and unloading this DLL permits us to minimize the memory footprint of msgina.
                           RUNDLLPROC fptr;
                           HMODULE hDll;
                           //
                           hDll = LoadLibrary(L"keymgr.dll");
                           if (hDll) 
                           {
                               fptr = (RUNDLLPROC) GetProcAddress(hDll,(LPCSTR)"PRShowSaveFromMsginaW");
                               if (fptr) 
                               {
                                   WCHAR szUser[UNLEN+1];
                                   if (0 != SendMessage(GetDlgItem(hDlg,IDD_CHANGEPWD_NAME),WM_GETTEXT,UNLEN,(LPARAM)szUser))
                                       fptr(hDlg,NULL,szUser,0);
                               }
                               FreeLibrary(hDll);
                           }
                            return TRUE;
                        }
                        
                        // determine if this domain entered is not the local machine
                        //  if not, show a message box and bow out.
                    }
                
                
                 case IDOK:
                    {
                        pGlobals = pPasswordData->pGlobals;

                        //
                        // Deal with combo-box UI requirements
                        //

                        if (HandleComboBoxOK(hDlg, IDD_CHANGEPWD_DOMAIN)) {
                            return(TRUE);
                        }

                        Result = AttemptPasswordChange(hDlg);

                        if (Result == MSGINA_DLG_FAILURE) {
                            //
                            // Let the user try again
                            // We always make the user re-enter at least the new password.
                            //
                            SetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, NULL );
                            SetDlgItemText(hDlg, IDD_CHANGEPWD_NEW, NULL );
                            SetDlgItemText(hDlg, IDD_CHANGEPWD_CONFIRM, NULL );

                            SetPasswordFocus(hDlg);

                            //EndDialog(hDlg, Result);
                            return(TRUE);
                        }


                        //
                        // We're finished - either success or an interrupt
                        //

                        EndDialog(hDlg, Result);
                        return(TRUE);
                    }

                case IDCANCEL:
                    {
                        EndDialog(hDlg, MSGINA_DLG_FAILURE);
                        return(TRUE);
                    }

                break;
                }
            }

        case WLX_WM_SAS:
            {
                // Ignore it
                return(TRUE);
            }

        case WM_TIMER:
        {
            if (wParam == TIMER_MYLANGUAGECHECK)
            {
                LayoutCheckHandler(hDlg, LAYOUT_CUR_USER);
            }
            break;
        }

    }

    // We didn't process this message
    return FALSE;
}


/****************************************************************************\
*
* FUNCTION: ChangePasswordDlgInit
*
* PURPOSE:  Handles initialization of change password dialog
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

BOOL
ChangePasswordDlgInit(
    HWND    hDlg,
    LPARAM  lParam
    )
{
    PCHANGE_PASSWORD_DATA pPasswordData = (PCHANGE_PASSWORD_DATA)lParam;
    PGLOBALS pGlobals = pPasswordData->pGlobals;

    // Store our structure pointer
    SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

    // Size for the branding image we are going to add.
    SizeForBranding(hDlg, FALSE);

    // Set up the initial text field contents

    SetDlgItemText(hDlg, IDD_CHANGEPWD_NAME, pPasswordData->UserName);
    SetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, pPasswordData->OldPassword);

    // Limit the maximum password length to 127
    SendDlgItemMessage(hDlg, IDD_CHANGEPWD_OLD, EM_SETLIMITTEXT, (WPARAM) 127, 0);
    SendDlgItemMessage(hDlg, IDD_CHANGEPWD_NEW, EM_SETLIMITTEXT, (WPARAM) 127, 0);
    SendDlgItemMessage(hDlg, IDD_CHANGEPWD_CONFIRM, EM_SETLIMITTEXT, (WPARAM) 127, 0);

    // ShowBackupButton(hDlg,pPasswordData->pGlobals); moved to after populate domain list
    
    // If this is the domain case and we aren't force to hide the domain ui

    if (( pPasswordData->Options & CHANGEPWD_OPTION_SHOW_DOMAIN ) && 
        (!ForceNoDomainUI()))
    {
        // If the user can choose their domain, fill the domain combobox
        // with the known domains and the local machine name.  Otherwise
        // disable the domain combobox.

        if ( pPasswordData->Options & CHANGEPWD_OPTION_EDIT_DOMAIN ) {

            ASSERT( (pPasswordData->Options & CHANGEPWD_OPTION_KEEP_ARRAY) == 0 );


            if ( !DCacheValidateCache( pGlobals->Cache ) )
            {
                ASSERT( pGlobals->ActiveArray == NULL );

                DCacheUpdateFull( pGlobals->Cache, 
                                  pGlobals->Domain );

            }

            pGlobals->ActiveArray = DCacheCopyCacheArray( pGlobals->Cache );

            if ( pPasswordData->Options & CHANGEPWD_OPTION_SHOW_NETPROV )
            {
                DCacheAddNetworkProviders( pGlobals->ActiveArray );
            }

            if ( pGlobals->ActiveArray )
            {
                // Fill combo box list, set domain type item data
                DCachePopulateListBoxFromArray( pGlobals->ActiveArray,
                                                GetDlgItem( hDlg, IDD_CHANGEPWD_DOMAIN ),
                                                NULL );

            }
            else 
            {
                EndDialog( hDlg, MSGINA_DLG_FAILURE );
            }


            EnableDomainForUPN( GetDlgItem( hDlg, IDD_CHANGEPWD_NAME),
                                GetDlgItem(hDlg,IDD_CHANGEPWD_DOMAIN) );

        } else {

            SendDlgItemMessage(hDlg, IDD_CHANGEPWD_DOMAIN, CB_ADDSTRING, 0, (LPARAM)pPasswordData->Domain);
            SendDlgItemMessage(hDlg, IDD_CHANGEPWD_DOMAIN, CB_SETCURSEL, 0, 0);
            EnableDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN, FALSE);
        }
    }
    else // workgroup case or we're forced to hide the domain UI
    {
        RECT rcDomain, rcUsername;


        // Hide the domain box
        ShowWindow(GetDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN_LABEL), SW_HIDE);

        EnableDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN, FALSE);

        // Shorten the window since the domain box isn't used
        GetWindowRect(GetDlgItem(hDlg, IDD_CHANGEPWD_NAME), &rcUsername);
        GetWindowRect(GetDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN), &rcDomain);

        MoveControls(hDlg, ctrlNoDomain,
                     ARRAYSIZE(ctrlNoDomain),
                     0, -(rcDomain.bottom-rcUsername.bottom),
                     TRUE);        
    }
    
    ShowBackupButton(hDlg,pPasswordData->pGlobals);
    
    DisplayLanguageIcon(hDlg, LAYOUT_CUR_USER, GetKeyboardLayout(0));

    CentreWindow(hDlg);

    SetupSystemMenu(hDlg);

    return TRUE;
}

VOID
UpdateWithChangedPassword(
    PGLOBALS pGlobals,
    HWND    ActiveWindow,
    BOOL    Hash,
    PWSTR   UserName,
    PWSTR   Domain,
    PWSTR   Password,
    PWSTR   NewPassword,
   PMSV1_0_INTERACTIVE_PROFILE NewProfile
    )
{
    WLX_MPR_NOTIFY_INFO MprInfo;
    int MprResult;
    PDOMAIN_CACHE_ENTRY Entry ;
    UNICODE_STRING String ;
    DWORD ChangeInfo = 0;
    HWND hwndOwner;
    PMSV1_0_CHANGEPASSWORD_REQUEST Request = NULL;
    ULONG RequestSize = 0;
    ULONG PackageId = 0;
    PVOID Response = NULL;
    ULONG ResponseSize;
    NTSTATUS SubStatus = STATUS_SUCCESS, Status = STATUS_SUCCESS;
    PBYTE Where;
    STRING Name;
    DWORD MaxPasswordAge ;
    LARGE_INTEGER Now ;
    LARGE_INTEGER EndOfPassword ;
    HANDLE ImpHandle ;
    BOOL InteractiveUser ;


    if (pGlobals->AutoAdminLogon)
    {
        if (IsAutologonUser(UserName, Domain))
        {
            SetAutologonPassword(NewPassword);
        }
    }

    //
    // Determine if this is the interactive user
    //

    if ( (_wcsicmp( Domain, pGlobals->Domain ) == 0 ) &&
         (_wcsicmp( UserName, pGlobals->UserName ) == 0 ) )
    {
        InteractiveUser = TRUE ;
    }
    else if ( ( pGlobals->FlatDomain.Buffer ) &&
              ( _wcsicmp( Domain, pGlobals->FlatDomain.Buffer ) == 0 ) &&
              ( _wcsicmp( UserName, pGlobals->FlatUserName.Buffer ) == 0 ) )
    {
        InteractiveUser = TRUE ;
    }
    else 
    {
        InteractiveUser = FALSE ;
    }



    if ( InteractiveUser )
    {
        //
        // Update the in-memory copy of the password for unlock.
        //

        RtlInitUnicodeString( &String, NewPassword );

        if ( Hash )
        {
            HashPassword( &String, pGlobals->PasswordHash );
        }
        else 
        {
            //
            // Don't hash the password away.  This is only 
            // set when the password is changed during logon.
            //

            wcscpy( pGlobals->Password, NewPassword );

            RtlInitUnicodeString(
                &pGlobals->PasswordString,
                pGlobals->Password);


            HidePassword(
                &pGlobals->Seed,
                &pGlobals->PasswordString);
        }


       //
       // Update password expiration time
       //

        if ( pGlobals->Profile )
        {
           if ( NewProfile )
           {
               pGlobals->Profile->PasswordMustChange = NewProfile->PasswordMustChange;
           }
           else
           {
               if ( GetMaxPasswordAge( Domain, &MaxPasswordAge ) == 0 )
               {
                   GetSystemTimeAsFileTime( (PFILETIME)&Now );
                   EndOfPassword.QuadPart = Now.QuadPart + (LONGLONG)MaxPasswordAge * (LONGLONG)10000000 ;

                   //
                   // Make sure we're not shortening the expiration time
                   //
                   if ( pGlobals->Profile->PasswordMustChange.QuadPart < EndOfPassword.QuadPart )
                   {
                       pGlobals->Profile->PasswordMustChange.QuadPart = EndOfPassword.QuadPart;
                   }
               }
           }
        }


        //
        // Update the security packages:
        //

        RtlInitString(
            &Name,
            MSV1_0_PACKAGE_NAME
            );

        Status = LsaLookupAuthenticationPackage(
                    pGlobals->LsaHandle,
                    &Name,
                    &PackageId
                    );

        if ( NT_SUCCESS( Status ) )
        {
            RequestSize = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) +
                              (DWORD) (wcslen(UserName) +
                                       wcslen(Domain) +
                                       wcslen(NewPassword) + 3) * sizeof(WCHAR);

            Request = (PMSV1_0_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT,RequestSize);

            if ( Request )
            {
                Where = (PBYTE) (Request + 1);
                Request->MessageType = MsV1_0ChangeCachedPassword;
                wcscpy(
                    (LPWSTR) Where,
                    Domain
                    );
                RtlInitUnicodeString(
                    &Request->DomainName,
                    (LPWSTR) Where
                    );
                Where += Request->DomainName.MaximumLength;

                wcscpy(
                    (LPWSTR) Where,
                    UserName
                    );
                RtlInitUnicodeString(
                    &Request->AccountName,
                    (LPWSTR) Where
                    );
                Where += Request->AccountName.MaximumLength;

                wcscpy(
                    (LPWSTR) Where,
                    NewPassword
                    );
                RtlInitUnicodeString(
                    &Request->NewPassword,
                    (LPWSTR) Where
                    );
                Where += Request->NewPassword.MaximumLength;

                //
                // Make the call
                //

                ImpHandle = ImpersonateUser( &pGlobals->UserProcessData, NULL );

                if ( ImpHandle )
                {
                    Request->Impersonating = TRUE ;

                    Status = LsaCallAuthenticationPackage(
                                pGlobals->LsaHandle,
                                PackageId,
                                Request,
                                RequestSize,
                                &Response,
                                &ResponseSize,
                                &SubStatus
                                );

                    StopImpersonating( ImpHandle );
                }

                LocalFree( Request );

                if ( NT_SUCCESS( Status ) && ImpHandle )
                {
                    LsaFreeReturnBuffer( Response );
                }
            }
        }
    }

    //
    // Let other providers know about the change
    //

    //
    // If the domain is one from our combo-box
    // then it is valid for logons.
    //

    if ( pGlobals->ActiveArray )
    {
        RtlInitUnicodeString( &String, Domain );

        Entry = DCacheSearchArray( 
                    pGlobals->ActiveArray,
                    &String );

        if ( (Entry) && (Entry->Type != DomainNetworkProvider) )
        {
            ChangeInfo |= WN_VALID_LOGON_ACCOUNT ;   
        }
    }

    //
    // Hide this dialog and pass our parent as the owner
    // of any provider dialogs
    //

    ShowWindow(ActiveWindow, SW_HIDE);
    hwndOwner = GetParent( ActiveWindow );

    MprInfo.pszUserName = DupString(UserName);
    MprInfo.pszDomain = DupString(Domain);
    MprInfo.pszPassword = DupString(NewPassword);
    MprInfo.pszOldPassword = DupString(Password);

    MprResult = pWlxFuncs->WlxChangePasswordNotify(
                                       pGlobals->hGlobalWlx,
                                       &MprInfo,
                                       ChangeInfo | WN_NT_PASSWORD_CHANGED);

}


/****************************************************************************\
*
* FUNCTION: AttemptPasswordChange
*
* PURPOSE:  Tries to change the user's password using the current values in
*           the change-password dialog controls
*
* RETURNS:  MSGINA_DLG_SUCCESS if the password was changed successfully.
*           MSGINA_DLG_FAILURE if the change failed
*           DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* NOTES:    If the password change failed, this routine displays the necessary
*           dialogs explaining what failed and why before returning.
*           This routine also clears the fields that need re-entry before
*           returning so the calling routine can call SetPasswordFocus on
*           the dialog to put the focus in the appropriate place.
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

INT_PTR
AttemptPasswordChange(
    HWND    hDlg
    )
{
    PCHANGE_PASSWORD_DATA pPasswordData = (PCHANGE_PASSWORD_DATA)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PGLOBALS pGlobals = pPasswordData->pGlobals;
    TCHAR   UserName[MAX_STRING_BYTES];
    TCHAR   Domain[MAX_STRING_BYTES];
    TCHAR   Password[MAX_STRING_BYTES];
    TCHAR   NewPassword[MAX_STRING_BYTES];
    TCHAR   ConfirmNewPassword[MAX_STRING_BYTES];
    INT_PTR Result;
    INT_PTR ReturnResult = MSGINA_DLG_SUCCESS;
    NTSTATUS Status;
    NTSTATUS SubStatus ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PDOMAIN_CACHE_ENTRY Search ;
    UNICODE_STRING Domain_U ;
    ULONG Size ;
    HWND hwndDomain = GetDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN);
    INT iDomainSelection = (INT)SendMessage(hwndDomain, CB_GETCURSEL, 0, 0);
    DOMAIN_PASSWORD_INFORMATION DomainInfo ;
    PWSTR UpnSuffix ;
    BOOL RetryWithFlat = FALSE ;

    UserName[0] = TEXT('\0');
    Domain[0] = TEXT('\0');
    Password[0] = TEXT('\0');
    NewPassword[0] = TEXT('\0');
    ConfirmNewPassword[0] = TEXT('\0');
    ZeroMemory( &DomainInfo, sizeof( DomainInfo ) );

    GetDlgItemText(hDlg, IDD_CHANGEPWD_NAME, UserName, MAX_STRING_BYTES);

    //
    // The selected domain may really be a special entry: the local machine
    //

    if ( pPasswordData->Options & CHANGEPWD_OPTION_EDIT_DOMAIN )
    {
        Entry = (PDOMAIN_CACHE_ENTRY) SendMessage( hwndDomain, CB_GETITEMDATA, iDomainSelection, 0 );

        if ( CB_ERR == (ULONG_PTR) Entry )
        {
            Entry = NULL ;
        }

        if ( Entry == NULL )
        {
            //
            // User typed in a new string, so there is no entry for this string.  Create
            // an entry here, and use it later.  
            //

            GetDlgItemText( hDlg, IDD_CHANGEPWD_DOMAIN, Domain, MAX_STRING_BYTES );

            RtlInitUnicodeString( &Domain_U, Domain );

            Entry = DCacheCreateEntry( 
                        DomainNt4,
                        &Domain_U,
                        NULL,
                        NULL );


        }
        else 
        {
            //
            // Maybe DNS, maybe not:
            //

            if ( Entry->Type == DomainNt5 )
            {
                wcscpy( Domain, Entry->DnsName.Buffer );
                RetryWithFlat = TRUE ;
            }
            else 
            {
                wcscpy( Domain, Entry->FlatName.Buffer );
            }

            //
            // Reference it here.  The case above will create an entry with a reference
            // that we will need to deref when we're done.  So, bump it now to make it 
            // cleaner later.
            //

            DCacheReferenceEntry( Entry );
        }
    }
    else 
    {
        //
        // Standalone case.  Force the machine name entry
        //

        Size = MAX_STRING_BYTES ;

        GetDlgItemText( hDlg, IDD_CHANGEPWD_DOMAIN, Domain, MAX_STRING_BYTES );

        //
        // If nothing there, use the domain from the logon:
        //

        if ( Domain[0] == L'\0' )
        {
            wcscpy( Domain, pGlobals->Domain );
        }

        RtlInitUnicodeString( &Domain_U, Domain );

        Entry = DCacheCreateEntry( 
                    DomainMachine,
                    &Domain_U,
                    NULL,
                    NULL );
    }


    if ( !Entry )
    {
        return DLG_FAILURE ;
    }

    GetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, Password, MAX_STRING_BYTES);
    GetDlgItemText(hDlg, IDD_CHANGEPWD_NEW, NewPassword, MAX_STRING_BYTES);
    GetDlgItemText(hDlg, IDD_CHANGEPWD_CONFIRM, ConfirmNewPassword, MAX_STRING_BYTES);

    // If we are forcing a NoDomainUI, populate the domain with the local machine name now
    if (ForceNoDomainUI())
    {
        DWORD chSize = ARRAYSIZE(Domain);
        
        if (!GetComputerName(Domain, &chSize))
        {
            *Domain = 0;
        }
    }

    //
    // If there is a at-sign in the name, assume that means that a UPN
    // attempt is being made.  Set the domain to NULL.
    //

    if ( wcschr( UserName, L'@' ) )
    {
        Domain[0] = TEXT('\0');
    }

    //
    // Validate user entries:
    //
    // Check that new passwords match
    //
    if (lstrcmp(NewPassword, ConfirmNewPassword) != 0) {
        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_NO_PASSWORD_CONFIRM,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);
        if (DLG_INTERRUPTED(Result)) {
            Result = SetInterruptFlag( MSGINA_DLG_FAILURE );
        }
        else
        {
            Result = MSGINA_DLG_FAILURE ;
        }

        DCacheDereferenceEntry( Entry );

        return(Result);
    }

    if ( Domain[0] == L'\0' )
    {
        UpnSuffix = wcschr( UserName, L'@' );

        if ( UpnSuffix == NULL )
        {
            Result = TimeoutMessageBox( hDlg, pGlobals,
                                        IDS_NO_DOMAIN_AND_NO_UPN,
                                        IDS_CHANGE_PASSWORD,
                                        MB_OK | MB_ICONEXCLAMATION,
                                        TIMEOUT_CURRENT );

            if (DLG_INTERRUPTED(Result)) {
                Result = SetInterruptFlag( MSGINA_DLG_FAILURE );
            }
            else
            {
                Result = MSGINA_DLG_FAILURE ;
            }
            return(Result);
        }
        else
        {
            //
            // Ok, the UPN suffix is present.  Check if it is part of an
            // MIT domain.  MIT domains have the flat and DNS fields identical.
            //

            UpnSuffix++ ;
            Search = DCacheLocateEntry(
                        pGlobals->Cache,
                        UpnSuffix );

            if ( Search )
            {
                DCacheDereferenceEntry( Entry );
                Entry = Search ;
            }

        }
    }

    //
    // Check if the password exceeds the LM limit of 14 characters.
    //

    if ( ( lstrlen( NewPassword ) > LM20_PWLEN ) &&
         ( ( Entry->Type == DomainUPN ) ||
           ( Entry->Type == DomainMachine ) ||
           ( Entry->Type == DomainNt4 ) ||
           ( Entry->Type == DomainNt5 ) ) )
    {
        //
        // For long passwords, confirm with the user.
        //

        Result = TimeoutMessageBox(
                        hDlg, pGlobals,
                        IDS_LONG_PASSWORD_WARNING,
                        IDS_CHANGE_PASSWORD,
                        MB_OKCANCEL | MB_ICONEXCLAMATION,
                        TIMEOUT_CURRENT );


        if ( DLG_INTERRUPTED(Result) ) 
        {
            Result = SetInterruptFlag( MSGINA_DLG_FAILURE );
        }
        else
        {
            if ( Result == IDCANCEL )
            {
                Result = MSGINA_DLG_FAILURE ;
            }
        }

        if ( ResultNoFlags( Result ) == MSGINA_DLG_FAILURE )
        {
            DCacheDereferenceEntry( Entry );

            return(Result);
        }


                                
    }

    //
    // Call the Appropriate Change Password Engine: 
    //

    Status = ChangePasswordWorkers[ Entry->Type ](
                pPasswordData,
                UserName,
                Domain,
                Password,
                NewPassword,
                &SubStatus,
                &DomainInfo );

    if ( RetryWithFlat )
    {
        //
        // If we just used the DNS name, restore the flat name,
        // since all later comparisons on the name for stored
        // password update will be based on this
        //

        wcscpy( Domain, Entry->FlatName.Buffer );
    }

    if ( ( Status == STATUS_DOMAIN_CONTROLLER_NOT_FOUND ) ||
         ( Status == STATUS_CANT_ACCESS_DOMAIN_INFO ) ) 
    {

        Status = ChangePasswordWorkers[ Entry->Type ](
                    pPasswordData,
                    UserName,
                    Domain,
                    Password,
                    NewPassword,
                    &SubStatus,
                    &DomainInfo );

    }

    if ( NT_SUCCESS( Status ) )
    {

        Result = TimeoutMessageBox(hDlg,
                                   pGlobals,
                                   IDS_PASSWORD_CHANGED,
                                   IDS_CHANGE_PASSWORD,
                                   MB_OK | MB_ICONINFORMATION,
                                   TIMEOUT_CURRENT);


    } else {

         ReturnResult = MSGINA_DLG_FAILURE;

        //
        // Failure, explain it to the user
        //

        Result = HandleFailedChangePassword(hDlg,
                                            pGlobals,
                                            Status,
                                            UserName,
                                            Domain,
                                            SubStatus,
                                            &DomainInfo
                                            );
    }


    //
    // Only call other providers if the change password attempt succeeded.
    //

    if (NT_SUCCESS(Status)) {

        //
        // Update our own state:
        //

        UpdateWithChangedPassword(
                pGlobals,
                hDlg,
                (pPasswordData->Options & CHANGEPWD_OPTION_NO_UPDATE ? FALSE : TRUE ),          
                UserName,
                Domain,
                Password,
                NewPassword,
               NULL );

    }


    //
    // Find out what happened to the message box:
    //

    if ( Result != IDOK )
    {
        //
        // mbox was interrupted
        //

        ReturnResult = SetInterruptFlag( ReturnResult );
    }

    return(ReturnResult);
}


/****************************************************************************\
*
* FUNCTION: HandleFailedChangePassword
*
* PURPOSE:  Tells the user why their change-password attempt failed.
*
* RETURNS:  MSGINA_DLG_FAILURE - we told them what the problem was successfully.
*           DLG_INTERRUPTED() - a set of return values - see winlogon.h
*
* HISTORY:
*
*   21-Sep-92 Davidc       Created.
*
\****************************************************************************/

INT_PTR
HandleFailedChangePassword(
    HWND hDlg,
    PGLOBALS pGlobals,
    NTSTATUS Status,
    PWCHAR UserName,
    PWCHAR Domain,
    NTSTATUS SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    )
{
    INT_PTR Result;
    DWORD Win32Error ;
    TCHAR    Buffer1[MAX_STRING_BYTES];
    TCHAR    Buffer2[MAX_STRING_BYTES];
    TCHAR    Buffer3[MAX_STRING_BYTES];

    Buffer1[ 0 ] = L'\0';
    Buffer2[ 0 ] = L'\0';
    Buffer3[ 0 ] = L'\0';

    switch (Status) {

    case STATUS_CANT_ACCESS_DOMAIN_INFO:
    case STATUS_NO_SUCH_DOMAIN:

        LoadString(hDllInstance,
                   IDS_CHANGE_PWD_NO_DOMAIN,
                   Buffer1,
                   sizeof(Buffer1) / sizeof(TCHAR));

        _snwprintf(Buffer2, sizeof(Buffer2) / sizeof(TCHAR), Buffer1, Domain);

        LoadString(hDllInstance,
                   IDS_CHANGE_PASSWORD,
                   Buffer1,
                   sizeof(Buffer1) / sizeof(TCHAR));

        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer2,
                                              Buffer1,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TIMEOUT_CURRENT);
        break;


    case STATUS_NO_SUCH_USER:
    case STATUS_WRONG_PASSWORD_CORE:
    case STATUS_WRONG_PASSWORD:

        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_INCORRECT_NAME_OR_PWD_CHANGE,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);

        // Force re-entry of the old password
        if (GetWindowLong(GetDlgItem(hDlg, IDD_CHANGEPWD_OLD), GWL_STYLE) & WS_VISIBLE) {
            SetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, NULL);
        }

        break;


    case STATUS_ACCESS_DENIED:

        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_NO_PERMISSION_CHANGE_PWD,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);
        break;


    case STATUS_ACCOUNT_RESTRICTION:

        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_ACCOUNT_RESTRICTION_CHANGE,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);
        break;

    case STATUS_BACKUP_CONTROLLER:

        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_REQUIRES_PRIMARY_CONTROLLER,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);
        break;


    case STATUS_PASSWORD_RESTRICTION:


        if ( SubStatus == STATUS_UNSUCCESSFUL )
        {
            LoadString(hDllInstance, IDS_GENERAL_PASSWORD_SPEC, Buffer2, sizeof(Buffer2) / sizeof( TCHAR ));
        }
        else 
        {

            if ( SubStatus == STATUS_ILL_FORMED_PASSWORD )
            {
                LoadString(hDllInstance, IDS_COMPLEX_PASSWORD_SPEC, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
            } else {
                LoadString(hDllInstance, IDS_PASSWORD_SPEC, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
            }
            _snwprintf(Buffer2, sizeof(Buffer2) / sizeof( TCHAR ), Buffer1,
                DomainInfo->MinPasswordLength,
                DomainInfo->PasswordHistoryLength
                );
        }

        LoadString(hDllInstance, IDS_ENTER_PASSWORDS, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
        wcsncat(Buffer2, TEXT(" "), sizeof(Buffer2) - sizeof(TCHAR)*(lstrlen(Buffer2) - 1));
        wcsncat(Buffer2, Buffer1, sizeof(Buffer2) - sizeof(TCHAR)*(lstrlen(Buffer2) - 1));

        LoadString(hDllInstance, IDS_CHANGE_PASSWORD, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ) );

        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer2,
                                              Buffer1,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TIMEOUT_CURRENT);
        break;


#ifdef LATER
    //
    // LATER Check for minimum password age
    //
    if ( FALSE ) {
        int     PasswordAge = 0, RequiredAge = 0;
        TCHAR    Buffer1[MAX_STRING_BYTES];
        TCHAR    Buffer2[MAX_STRING_BYTES];

        LoadString(hDllInstance, IDS_PASSWORD_MINIMUM_AGE, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
        _snwprintf(Buffer2, sizeof(Buffer2) / sizeof( TCHAR ), Buffer1, PasswordAge, RequiredAge);

        LoadString(hDllInstance, IDS_NO_PERMISSION_CHANGE_PWD, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
        lstrcat(Buffer1, Buffer2);

        LoadString(hDllInstance, IDS_CHANGE_PASSWORD, Buffer2, sizeof(Buffer2) / sizeof( TCHAR ));

        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer1,
                                              Buffer2,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TIMEOUT_CURRENT);
    }
#endif


    default:

        DebugLog((DEB_ERROR, "Change password failure status = 0x%lx\n", Status));

        LoadString(hDllInstance, IDS_UNKNOWN_CHANGE_PWD_FAILURE, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));

        Win32Error = RtlNtStatusToDosError( Status );

        GetErrorDescription( Win32Error, Buffer3, sizeof( Buffer3 ) / sizeof(TCHAR) );

        _snwprintf(Buffer2, sizeof(Buffer2) / sizeof( TCHAR ), Buffer1, Win32Error, Buffer3 );

        LoadString(hDllInstance, IDS_CHANGE_PASSWORD, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));

        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer2,
                                              Buffer1,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TIMEOUT_CURRENT);
        break;
    }

    return(Result);

    UNREFERENCED_PARAMETER(UserName);
}

BOOL IsAutologonUser(LPCTSTR szUser, LPCTSTR szDomain)
{
    BOOL fIsUser = FALSE;
    HKEY hkey = NULL;
    TCHAR szAutologonUser[UNLEN + 1];
    TCHAR szAutologonDomain[DNLEN + 1];
    TCHAR szTempDomainBuffer[DNLEN + 1];
    DWORD cbBuffer;
    DWORD dwType;

    *szTempDomainBuffer = 0;

    // Domain may be a null string. If this is the case...
    if (0 == *szDomain)
    {
        DWORD cchBuffer;

        // We really mean the local machine name
        // Point to our local buffer
        szDomain = szTempDomainBuffer;
        cchBuffer = ARRAYSIZE(szTempDomainBuffer);

        GetComputerName(szTempDomainBuffer, &cchBuffer);
    }

    // See if the domain and user name
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ, &hkey))
    {
        // Check the user name
        cbBuffer = sizeof (szAutologonUser);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, DEFAULT_USER_NAME_KEY, 0, &dwType, (LPBYTE) szAutologonUser, &cbBuffer))
        {
            // Does it match?
            if (0 == lstrcmpi(szAutologonUser, szUser))
            {
                // Yes. Now check domain
                cbBuffer = sizeof(szAutologonDomain);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, DEFAULT_DOMAIN_NAME_KEY, 0, &dwType, (LPBYTE) szAutologonDomain, &cbBuffer))
                {
                    // Make sure domain matches
                    if (0 == lstrcmpi(szAutologonDomain, szDomain))
                    {
                        // Success - the users match
                        fIsUser = TRUE;
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    return fIsUser;
}

NTSTATUS SetAutologonPassword(LPCWSTR szPassword)
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING SecretName;
    UNICODE_STRING SecretValue;

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0L, (HANDLE)NULL, NULL);

    Status = LsaOpenPolicy(NULL, &ObjectAttributes, POLICY_CREATE_SECRET, &LsaHandle);
    if (!NT_SUCCESS(Status))
        return Status;

    RtlInitUnicodeString(&SecretName, DEFAULT_PASSWORD_KEY);
    RtlInitUnicodeString(&SecretValue, szPassword);

    Status = LsaStorePrivateData(LsaHandle, &SecretName, &SecretValue);
    LsaClose(LsaHandle);

    return Status;
}

NTSTATUS
NtChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    )
{
    NTSTATUS Status ;
    NTSTATUS ProtocolStatus = STATUS_SUCCESS;
    PGLOBALS    pGlobals = pChangePasswordData->pGlobals ;
    PMSV1_0_CHANGEPASSWORD_REQUEST pChangePasswordRequest = NULL;
    PMSV1_0_CHANGEPASSWORD_RESPONSE pChangePasswordResponse = NULL;
    PWCHAR DomainU;
    PWCHAR UserNameU;
    PWCHAR PasswordU;
    PWCHAR NewPasswordU;
    int Length;
    ULONG RequestBufferSize;
    ULONG ResponseBufferSize;
    HANDLE ImpersonationHandle = NULL;
    ULONG MsvPackage;
    STRING PackageName;


    //
    // Determine request buffer size needed, including room for
    // strings.  Set string pointers to offsets as we step through
    // sizing each one.
    //
    RequestBufferSize = sizeof(*pChangePasswordRequest);

    UserNameU = UIntToPtr(RequestBufferSize);
    RequestBufferSize += (lstrlen(UserName)+1) * sizeof(WCHAR);

    DomainU = UIntToPtr(RequestBufferSize);
    RequestBufferSize += (lstrlen(Domain)+1) * sizeof(WCHAR);

    PasswordU = UIntToPtr(RequestBufferSize);
    RequestBufferSize += (lstrlen(OldPassword)+1) * sizeof(WCHAR);

    NewPasswordU = UIntToPtr(RequestBufferSize);
    RequestBufferSize += (lstrlen(NewPassword)+1) * sizeof(WCHAR);

    //
    // Allocate request buffer
    //
    pChangePasswordRequest = Alloc(RequestBufferSize);
    if (NULL == pChangePasswordRequest) {
        DebugLog((DEB_ERROR, "cannot allocate change password request buffer (%ld bytes).", RequestBufferSize));
        return MSGINA_DLG_FAILURE;
    }

    //
    // Fixup string offsets to string pointers for request.
    //
    UserNameU    = (PVOID) ((PBYTE)pChangePasswordRequest + (ULONG_PTR)UserNameU);
    DomainU      = (PVOID) ((PBYTE)pChangePasswordRequest + (ULONG_PTR)DomainU);
    PasswordU    = (PVOID) ((PBYTE)pChangePasswordRequest + (ULONG_PTR)PasswordU);
    NewPasswordU = (PVOID) ((PBYTE)pChangePasswordRequest + (ULONG_PTR)NewPasswordU);

    //
    // Setup MSV1_0ChangePassword request.
    //
    pChangePasswordRequest->MessageType = MsV1_0ChangePassword;

    // strings are already unicode, just copy them // lhb tracks //REVIEW
    lstrcpy((LPTSTR)UserNameU,UserName);
    lstrcpy((LPTSTR)DomainU,Domain);
    lstrcpy((LPTSTR)PasswordU,OldPassword);
    lstrcpy((LPTSTR)NewPasswordU,NewPassword);

    Length = lstrlen(UserName);
    UserNameU[Length] = 0;
    RtlInitUnicodeString(
        &pChangePasswordRequest->AccountName,
        UserNameU
        );
    Length = lstrlen(Domain);
    DomainU[Length] = 0;
    RtlInitUnicodeString(
        &pChangePasswordRequest->DomainName,
        DomainU
        );
    Length = lstrlen(OldPassword);
    PasswordU[Length] = 0;
    RtlInitUnicodeString(
        &pChangePasswordRequest->OldPassword,
        PasswordU
        );
    Length = lstrlen(NewPassword);
    NewPasswordU[Length] = 0;
    RtlInitUnicodeString(
        &pChangePasswordRequest->NewPassword,
        NewPasswordU
        );


    //
    // Make sure the passwords are short enough that we can run-encode them.
    //

    if ((pChangePasswordRequest->OldPassword.Length > 127 * sizeof( WCHAR ) ) ||
        (pChangePasswordRequest->NewPassword.Length > 127 * sizeof( WCHAR ) )) {

        Status = STATUS_ILL_FORMED_PASSWORD;

    } else {

        HidePassword(NULL,&pChangePasswordRequest->OldPassword);
        HidePassword(NULL,&pChangePasswordRequest->NewPassword);

        Status = STATUS_SUCCESS ;
    }

    //
    // If that succeeded, try to change the password
    //

    if (NT_SUCCESS(Status)) {
        //
        // This could take some time, put up a wait cursor
        //

        SetupCursor(TRUE);

        //
        // We want to impersonate if and only if the user is actually logged
        // on.  Otherwise we'll be impersonating SYSTEM, which is bad.
        //

        if (pChangePasswordData->Impersonate) {

            ImpersonationHandle = ImpersonateUser(
                                      &pGlobals->UserProcessData,
                                      NULL
                                      );

            if (NULL == ImpersonationHandle) {
                DebugLog((DEB_ERROR, "cannot impersonate user"));
                Free(pChangePasswordRequest);
                return MSGINA_DLG_FAILURE;
            }
        }

        //
        // Tell msv1_0 whether or not we're impersonating.
        //

        pChangePasswordRequest->Impersonating = (UCHAR)pChangePasswordData->Impersonate;

        //
        // Call off to the authentication package (MSV/NTLM) to do the work,  This
        // is the NT change password function.  The Kerb one calls the kerb package.
        //

        RtlInitString(&PackageName, MSV1_0_PACKAGE_NAME );
        Status = LsaLookupAuthenticationPackage (
                    pGlobals->LsaHandle,
                    &PackageName,
                    &MsvPackage
                    );

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR, "Failed to find %s authentication package, status = 0x%lx",
                    PackageName.Buffer, Status));

            return( MSGINA_DLG_FAILURE );
        }


        Status = LsaCallAuthenticationPackage(
                     pGlobals->LsaHandle,
                     MsvPackage,
                     pChangePasswordRequest,
                     RequestBufferSize,
                     (PVOID)&pChangePasswordResponse,
                     &ResponseBufferSize,
                     &ProtocolStatus
                     );

        if (pChangePasswordData->Impersonate) {

            if (!StopImpersonating(ImpersonationHandle)) {

                DebugLog((DEB_ERROR, "AttemptPasswordChange: Failed to revert to self"));

                //
                // Blow up
                //

                ASSERT(FALSE);
            }
        }

        //
        // Restore the normal cursor
        //

        SetupCursor(FALSE);
    }

    //
    // Free up the request buffer
    //

    Free(pChangePasswordRequest);

    //
    // Get the most informative status code
    //

    if ( NT_SUCCESS(Status) ) {
        Status = ProtocolStatus;
    }
    else
    {
        DebugLog((DEB_TRACE, "FAILED in call to LsaCallAuthenticationPackage, status %x\n", Status ));

    }

    if (NT_SUCCESS(Status)) {

        //
        // Success
        //

        //
        // if they changed their logon password, update the
        // change time in their profile info so we don't keep
        // pestering them.
        //

        if ( (_wcsicmp( pGlobals->Domain, Domain ) == 0) &&
             (_wcsicmp( pGlobals->UserName, UserName ) == 0 ))
        {

            //
            // This is code to handle the disconnected (preferred) domain.  This
            // was to be devl-only code and removed eventually, but some customers
            // liked it so much, it stayed.
            //

            {
                HKEY Key ;
                int err ;
                PWSTR PreferredDomain ;
                DWORD Type ;
                DWORD Size ;
                NET_API_STATUS NetStatus ;

                err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TEXT("System\\CurrentControlSet\\Control\\Lsa\\MSV1_0"),
                                    0,
                                    KEY_READ,
                                    &Key );

                if ( err == 0 )
                {
                    Size = 0 ;

                    err = RegQueryValueEx( Key,
                                           TEXT("PreferredDomain" ),
                                           NULL,
                                           &Type,
                                           NULL,
                                           &Size );

                    if ( err == 0 )
                    {
                        PreferredDomain = LocalAlloc( LMEM_FIXED, Size );

                        if ( PreferredDomain )
                        {
                            err = RegQueryValueEx( Key,
                                                   TEXT("PreferredDomain"),
                                                   NULL,
                                                   &Type,
                                                   (PBYTE) PreferredDomain,
                                                   &Size );

                            if ( err == 0 )
                            {
                                //
                                // If we are logged on to our preferred domain, don't
                                // do the update magic.
                                //

                                if ( _wcsicmp( PreferredDomain, pGlobals->Domain ) == 0 )
                                {
                                    err = 2 ;
                                }
                            }

                            if ( err == 0 )
                            {
                                NetStatus = NetUserChangePassword(
                                                PreferredDomain,
                                                UserName,
                                                OldPassword,
                                                NewPassword );

                                if ( NetStatus )
                                {
                                    DebugLog((DEB_ERROR, "Could not update password on %ws, %x\n", PreferredDomain, NetStatus ));
                                }
                            }

                            LocalFree( PreferredDomain );
                        }

                    }

                    RegCloseKey( Key );

                }

            }
        }
    }
    else 
    {
        *SubStatus = STATUS_UNSUCCESSFUL ;

        if ( pChangePasswordResponse )
        {
            if ( pChangePasswordResponse->PasswordInfoValid )
            {
                *DomainInfo = pChangePasswordResponse->DomainPasswordInfo ;
            }
        }

        if ( Status == STATUS_PASSWORD_RESTRICTION )
        {
            *SubStatus = STATUS_PASSWORD_RESTRICTION ;

            if ( pChangePasswordResponse->PasswordInfoValid )
            {
                if ( pChangePasswordResponse->DomainPasswordInfo.PasswordProperties & DOMAIN_PASSWORD_COMPLEX )
                {
                    *SubStatus = STATUS_ILL_FORMED_PASSWORD ;
                }

            }
        }
    }

    //
    // Free up the return buffer
    //

    if (pChangePasswordResponse != NULL) {
        LsaFreeReturnBuffer(pChangePasswordResponse);
    }

    return Status ;
}

NTSTATUS
MitChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       DomainName,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   pSubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    )
{
    PGLOBALS pGlobals = pChangePasswordData->pGlobals ;
    NTSTATUS Status;
    STRING Name;
    ULONG PackageId;
    PVOID Response = NULL ;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User,Domain,OldPass,NewPass;

    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );

    Status = LsaLookupAuthenticationPackage(
                pGlobals->LsaHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    if ( ChangeRequest == NULL )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup ;
    }

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    //
    // We are running as the caller, so state we are impersonating
    //

    ChangeRequest->Impersonating = TRUE;

    Status = LsaCallAuthenticationPackage(
                pGlobals->LsaHandle,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
            *pSubStatus = STATUS_UNSUCCESSFUL ;
        } 
        else 
        {
            *pSubStatus = SubStatus;
        }
    }

Cleanup:
    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }

    if (ChangeRequest != NULL)
    {
        LocalFree(ChangeRequest);
    }
    return(Status);
}

NTSTATUS
ProviderChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    )
{
    WLX_MPR_NOTIFY_INFO MprInfo;
    DWORD Result ;
    PGLOBALS pGlobals = pChangePasswordData->pGlobals ;

    MprInfo.pszUserName = DupString( UserName );
    MprInfo.pszDomain = DupString( Domain );
    MprInfo.pszOldPassword = DupString( OldPassword );
    MprInfo.pszPassword = DupString( NewPassword );


    //
    // Hide this dialog and pass our parent as the owner
    // of any provider dialogs
    //


    Result = pWlxFuncs->WlxChangePasswordNotifyEx(
                                    pGlobals->hGlobalWlx,
                                    &MprInfo,
                                    0,
                                    Domain,
                                    NULL );



    return STATUS_SUCCESS ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\gina.h ===
// remove me
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\dirtydlg.c ===
#include "msgina.h"

// This gives me a yucky feeling, but we
// use CRT all over the place in gina.
#include <stdio.h>

#include <windowsx.h>
#include <regstr.h>
#include <help.h>

#include <Wtsapi32.h>

#include "shtdnp.h"


typedef struct _DIRTYDLGDATA
{
    REASONDATA ReasonData;
        
    DWORD dwFlags;
    BOOL fEndDialogOnActivate;
} DIRTYDLGDATA, *PDIRTYDLGDATA;

// Internal function prototypes
BOOL Dirty_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

BOOL Dirty_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

BOOL Dirty_OnEraseBkgnd(HWND hwnd, HDC hdc);

INT_PTR CALLBACK Dirty_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
INT_PTR DialogItemToGinaResult(DWORD dwDialogItem, BOOL fAutoPowerdown);


// Enable the OK button based on the selected reason code and the comments / bug id.
void Enable_OK( HWND hwnd, PDIRTYDLGDATA pdata ) {
    if( ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect )) {
        // See if we have a comment.
        if( pdata->ReasonData.cCommentLen == 0 ) {
            EnableWindow( GetDlgItem( hwnd, IDOK ), FALSE );
            return;
        }
    }
    if( ReasonCodeNeedsBugID( pdata->ReasonData.dwReasonSelect )) {
        // See if we have a BugID.
        if( pdata->ReasonData.cBugIDLen == 0 ) {
            EnableWindow( GetDlgItem( hwnd, IDOK ), FALSE );
            return;
        }
    }
    EnableWindow( GetDlgItem( hwnd, IDOK ), TRUE );
}

BOOL Dirty_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    PDIRTYDLGDATA pdata = (PDIRTYDLGDATA) lParam;
    HWND hwndCombo;
    int iOption;
    int iComboItem;
	int nComboItemCnt;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) lParam);

    if (!(pdata->dwFlags & SHTDN_NOBRANDINGBITMAP))
    {
        // Move all our controls down so the branding fits
        SizeForBranding(hwnd, FALSE);
    }

    // Set up the reason data.
    // Add the items specified to the combo box
    hwndCombo = GetDlgItem(hwnd, IDC_DIRTYREASONS_COMBO);

    for (iOption = 0; iOption < pdata->ReasonData.cReasons; iOption ++)
    {
        // Add the option
        iComboItem = ComboBox_AddString(hwndCombo,
            pdata->ReasonData.rgReasons[iOption]->szName);

        if (iComboItem != (int) CB_ERR)
        {
            // Store a pointer to the option
            ComboBox_SetItemData(hwndCombo, iComboItem,
                pdata->ReasonData.rgReasons[iOption]);

            // See if we should select this option
            if (pdata->ReasonData.rgReasons[iOption]->dwCode == pdata->ReasonData.dwReasonSelect)
            {
                ComboBox_SetCurSel(hwndCombo, iComboItem);
            }
        }
    }

	nComboItemCnt = ComboBox_GetCount(hwndCombo);
	if(nComboItemCnt > 0 && pdata->ReasonData.cCommentLen != 0)
	{
		int iItem;
		for(iItem = 0; iItem < nComboItemCnt; iItem++)
		{
			PREASON pReason = (PREASON) ComboBox_GetItemData(hwndCombo, iItem);
			if(pReason->dwCode ==  (UDIRTYUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_BLUESCREEN))
			{
				ComboBox_SetCurSel(hwndCombo, iItem);
				Edit_SetText(GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT), pdata->ReasonData.szComment);
				EnableWindow( GetDlgItem( hwnd, IDOK ), TRUE );
				break;
			}
		}
		SetReasonDescription(hwndCombo,
			GetDlgItem(hwnd, IDC_DIRTYREASONS_DESCRIPTION));
	}
	else
	{
		// If we don't have a selection in the combo, do a default selection
		if (ComboBox_GetCurSel(hwndCombo) == CB_ERR)
		{
			pdata->ReasonData.dwReasonSelect = pdata->ReasonData.rgReasons[ 0 ]->dwCode;
			ComboBox_SetCurSel(hwndCombo, 0);
		}

		SetReasonDescription(hwndCombo,
			GetDlgItem(hwnd, IDC_DIRTYREASONS_DESCRIPTION));

		// Enable the OK button
		Enable_OK( hwnd, pdata );
	}

	// Setup the comment box and BugId boxes
	// We must fix the maximum characters.
	SendMessage( GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT), EM_LIMITTEXT, (WPARAM)MAX_REASON_COMMENT_LEN, (LPARAM)0 );
	SendMessage( GetDlgItem(hwnd, IDC_DIRTYREASONS_BUGID), EM_LIMITTEXT, (WPARAM)MAX_REASON_BUGID_LEN, (LPARAM)0 );

    // If we get an activate message, dismiss the dialog, since we just lost
    // focus
    pdata->fEndDialogOnActivate = TRUE;

    CentreWindow(hwnd);

    return TRUE;
}


BOOL Dirty_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL fHandled = FALSE;
    DWORD dwDlgResult = TRUE;
    PDIRTYDLGDATA pdata = (PDIRTYDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (id)
    {
    case IDOK:
        if (codeNotify == BN_CLICKED)
        {
            pdata->ReasonData.dwReasonSelect = 0;

            pdata->ReasonData.dwReasonSelect = GetReasonSelection(GetDlgItem(hwnd, IDC_DIRTYREASONS_COMBO));
            if (pdata->ReasonData.dwReasonSelect == SHTDN_REASON_UNKNOWN ) {
                break;
            }
            // Fill the comment field with the Problem Id followed by the comment on a new line.
            pdata->ReasonData.cBugIDLen = GetWindowText( GetDlgItem(hwnd, IDC_DIRTYREASONS_BUGID), pdata->ReasonData.szComment, MAX_REASON_BUGID_LEN );
            lstrcat(pdata->ReasonData.szComment + pdata->ReasonData.cBugIDLen,L"\n");
            pdata->ReasonData.cBugIDLen += lstrlen(L"\n");
            pdata->ReasonData.cCommentLen = GetWindowText( GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT),
                                                            pdata->ReasonData.szComment + pdata->ReasonData.cBugIDLen,
                                                            MAX_REASON_COMMENT_LEN - pdata->ReasonData.cBugIDLen);
            pdata->ReasonData.cCommentLen +=  pdata->ReasonData.cBugIDLen ;

            pdata->fEndDialogOnActivate = FALSE;            
            fHandled = TRUE;
            EndDialog(hwnd, (int) dwDlgResult);
        }
        break;
    case IDC_DIRTYREASONS_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetReasonDescription(hwndCtl,
                GetDlgItem(hwnd, IDC_DIRTYREASONS_DESCRIPTION));
            pdata->ReasonData.dwReasonSelect = GetReasonSelection(hwndCtl);
            Enable_OK( hwnd, pdata );
        
            fHandled = TRUE;
        }
        break;
    case IDC_DIRTYREASONS_COMMENT:
        if( codeNotify == EN_CHANGE) 
        {
            pdata->ReasonData.cCommentLen = GetWindowTextLength( GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT));
            Enable_OK( hwnd, pdata );
            fHandled = TRUE;
        }
        break;
    case IDC_DIRTYREASONS_BUGID:
        if( codeNotify == EN_CHANGE) 
        {
            pdata->ReasonData.cBugIDLen = GetWindowTextLength( GetDlgItem(hwnd, IDC_DIRTYREASONS_BUGID));
            Enable_OK( hwnd, pdata );
            fHandled = TRUE;
        }
        break;
    case IDHELP:
        if (codeNotify == BN_CLICKED)
        {
            WinHelp(hwnd, TEXT("windows.hlp>proc4"), HELP_CONTEXT, (DWORD) IDH_TRAY_SHUTDOWN_HELP);
        }
        break;
    }
    return fHandled;
}

BOOL Dirty_OnEraseBkgnd(HWND hwnd, HDC hdc)
{
    BOOL fRet;
    PDIRTYDLGDATA pdata = (PDIRTYDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // Draw the branding bitmap
    if (!(pdata->dwFlags & SHTDN_NOBRANDINGBITMAP))
    {
        fRet = PaintBranding(hwnd, hdc, 0, FALSE, FALSE, COLOR_BTNFACE);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

INT_PTR CALLBACK Dirty_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Dirty_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Dirty_OnCommand);
        HANDLE_MSG(hwnd, WM_ERASEBKGND, Dirty_OnEraseBkgnd);
        case WLX_WM_SAS:
        {
            // If this is someone hitting C-A-D, swallow it.
            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
                return TRUE;
            // Other SAS's (like timeout), return FALSE and let winlogon
            // deal with it.
            return FALSE;
        }
        break;
        case WM_INITMENUPOPUP:
        {
            EnableMenuItem((HMENU)wParam, SC_MOVE, MF_BYCOMMAND|MF_GRAYED);
        }
        break;
        case WM_SYSCOMMAND:
            // Blow off moves (only really needed for 32bit land).
            if ((wParam & ~0x0F) == SC_MOVE)
                return TRUE;
            break;
    }

    return FALSE;
}

/****************************************************************************
 WinlogonDirtyDialog
 --------------

  Launches the shutdown dialog.

  If hWlx and pfnWlxDialogBoxParam are non-null, pfnWlxDialogBoxParam will
  be used to launch the dialog box so we can intelligently respond to WLX
  messages. Only if WinLogon is the caller should this be done.

  Other flags are listed in shtdndlg.h.
****************************************************************************/
INT_PTR
WinlogonDirtyDialog(
    HWND hwndParent,
    PGLOBALS pGlobals
    )
{
    // Array of shutdown options - the dialog data
    DIRTYDLGDATA data;
    DWORD dwResult = TRUE;

    HKEY            hKey = 0;
    DWORD           rc;
    DWORD           ShowReasonUI = 0x0;
    DWORD           DirtyShutdownHappened;
    DWORD           ShouldClearDirtyShutdownValue = TRUE;
    DWORD           ValueSize = sizeof (DWORD);
	DWORD			dwBugcheckStringSize = MAX_REASON_COMMENT_LEN * sizeof(WCHAR);
	BOOL			fFromPolicy = FALSE;

    // Set the initially selected item
    data.ReasonData.dwReasonSelect = 0;
    data.ReasonData.rgReasons = 0;
    data.ReasonData.cReasons = 0;
    data.ReasonData.cReasonCapacity = 0;

	//
    //	See if we need to show this dialog.
	//	We need to check the group policy first. If the group policy
	//	does not exist we will fall back on the reliabiltiy key.
	//
	rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RELIABILITY_POLICY_KEY, 0, KEY_ALL_ACCESS, &hKey);
	if(rc == ERROR_SUCCESS)
	{
		rc = RegQueryValueEx (hKey, RELIABILITY_POLICY_SHUTDOWNREASONUI, NULL, NULL, (UCHAR *)&ShowReasonUI, &ValueSize);
		RegCloseKey (hKey);
		hKey = 0;

		//
		//	Now check the sku to decide whether we should show the dialog
		//
		if(rc == ERROR_SUCCESS)
		{
			OSVERSIONINFOEX osVersionInfoEx;

			osVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

			if(ShowReasonUI == POLICY_SHOWREASONUI_NEVER || ShowReasonUI == POLICY_SHOWREASONUI_ALWAYS)
			{
				//do nothing.
			}
			else if(GetVersionEx( (LPOSVERSIONINFOW) &osVersionInfoEx ))
			{
				//
				//	if ShowReasonUI is anything other than 2 or 3, we think it is 0.
				//
				switch ( osVersionInfoEx.wProductType )
				{
					case VER_NT_WORKSTATION:
						if(ShowReasonUI == POLICY_SHOWREASONUI_WORKSTATIONONLY)
							ShowReasonUI = 1;
						else
							ShowReasonUI = 0;
						break;
					default:
						if(ShowReasonUI == POLICY_SHOWREASONUI_SERVERONLY)
							ShowReasonUI = 1;
						else
							ShowReasonUI = 0;
						break;
				}
			}
			else
			{
				//
				//	If we fail, assume not showing.
				//
				ShowReasonUI = 0;
			}
		}
	}
	if(rc != ERROR_SUCCESS) //we failed to get the policy
	{
		rc = RegCreateKeyEx (HKEY_LOCAL_MACHINE, REGSTR_PATH_RELIABILITY, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS, NULL, &hKey, NULL);

	}
	else
	{
		fFromPolicy = TRUE;
	}

    if (rc == ERROR_SUCCESS) {

        if(!fFromPolicy)
		{
			rc = RegQueryValueEx (hKey, REGSTR_VAL_SHOWREASONUI, NULL, NULL, (UCHAR *)&ShowReasonUI, &ValueSize);
		}
        if ( (rc == ERROR_SUCCESS) && (ShowReasonUI) ) {
      
			//
			//	We need to open the reliability key if we have not yet.
			//
			if(fFromPolicy)
			{
				rc = RegCreateKeyEx (HKEY_LOCAL_MACHINE, REGSTR_PATH_RELIABILITY, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS, NULL, &hKey, NULL);
			}

			ValueSize = sizeof(DWORD);
			if(rc == ERROR_SUCCESS)
			{
				rc = RegQueryValueEx (hKey, L"DirtyShutDown", NULL, NULL, (UCHAR *)&DirtyShutdownHappened, &ValueSize);
				if ( (rc == ERROR_SUCCESS) && (DirtyShutdownHappened) ) {

					// We do need to show the dialog.

					// Read in the strings for the shutdown option names and descriptions
					if( BuildReasonArray( &data.ReasonData, FALSE, TRUE ))
					{
						data.ReasonData.szBugID[ 0 ] = 0;
						data.ReasonData.cBugIDLen = 0;

						//If a bugcheck happenned, get the bugcheck string from registry.
						rc = RegQueryValueEx (hKey, L"BugcheckString", NULL, NULL, (LPBYTE)data.ReasonData.szComment, &dwBugcheckStringSize);
						if(rc != ERROR_SUCCESS)
						{
							data.ReasonData.szComment[ 0 ] = 0;
							data.ReasonData.cCommentLen = 0;
						}
						else
						{
							RegDeleteValue( hKey, L"BugcheckString");
							data.ReasonData.cCommentLen = dwBugcheckStringSize;
						}

						// Display the dialog and return the user's selection

						// Figure out what flags to pass
						// for sure no help button
						data.dwFlags = SHTDN_NOHELP;

						// On terminal server, no branding bitmap either
						if( GetSystemMetrics( SM_REMOTESESSION ))
						{
							data.dwFlags |= SHTDN_NOBRANDINGBITMAP;
						}

						dwResult = ( DWORD )pWlxFuncs->WlxDialogBoxParam( pGlobals->hGlobalWlx,
							hDllInstance, MAKEINTRESOURCE( IDD_DIRTY_DIALOG ),
							hwndParent, Dirty_DialogProc, ( LPARAM )&data );

						// If we timed out then log the user off.
						if( dwResult != TRUE )
						{
							DestroyReasons( &data.ReasonData );
							// If we log them out successfully, then we don't clear the dirty shutdown value.
							ShouldClearDirtyShutdownValue = FALSE ;
							dwResult = WLX_SAS_ACTION_LOGOFF;
						}
						else
						{
							// Record the event.
							SHUTDOWN_REASON sr;
							sr.cbSize = sizeof(SHUTDOWN_REASON);
							sr.uFlags = EWX_SHUTDOWN;
							sr.dwReasonCode = data.ReasonData.dwReasonSelect;
							sr.dwEventType = SR_EVENT_DIRTY;
							sr.lpszComment = data.ReasonData.szComment;
							RecordShutdownReason(&sr);

							// Destroy the allocated data.
							DestroyReasons( &data.ReasonData );
							dwResult = TRUE;
						}
					}
				}
				// See if we should be clearing the dirty shutdown value in the registry.
				if( ShouldClearDirtyShutdownValue )
				{
					RegDeleteValue( hKey, L"DirtyShutDown" );
				}
            }
		}
	}

	if(hKey)
		RegCloseKey (hKey);

	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\domain.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       domcache.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-29-96   RichardW   Created
//
//----------------------------------------------------------------------------


#ifdef DATA_TYPES_ONLY

//
// Domain specific types
//

//
// Define the structure that controls the trusted domain cache
//

typedef enum _DOMAIN_ENTRY_TYPE {
    DomainInvalid,                      // 0 never valid
    DomainUPN,                          // Special UPN domain
    DomainMachine,                      // Local machine domain
    DomainNt4,                          // An NT4 domain
    DomainNt5,                          // An NT5 domain
    DomainMitRealm,                     // An MIT realm
    DomainMitUntrusted,                 // An untrusted MIT realm
    DomainNetworkProvider,              // A fake entry 
    DomainTypeMax
} DOMAIN_ENTRY_TYPE ;


typedef struct _DOMAIN_CACHE_ENTRY {

    LONG RefCount ;                         // Ref Count

    ULONG Flags ;                           // Flags (below)

    DOMAIN_ENTRY_TYPE Type ;                // Type of entry

    UNICODE_STRING FlatName ;               // Flat name of object (OPTIONAL)

    UNICODE_STRING DnsName ;                // Dns name of object (OPTIONAL)

    UNICODE_STRING DisplayName ;            // Display Name
    
} DOMAIN_CACHE_ENTRY, * PDOMAIN_CACHE_ENTRY ;

#define DCE_DEFAULT_ENTRY   0x00000001      // This is displayed by default
#define DCE_REACHABLE_MIT   0x00000002      // This MIT realm is reachable

#define DCacheReferenceEntry( x )   InterlockedIncrement( &(x)->RefCount );

typedef struct _DOMAIN_CACHE_ARRAY {

    ULONG Count ;

    ULONG MaxCount ;

    BOOL Sorted ;

    PDOMAIN_CACHE_ENTRY * List ;

} DOMAIN_CACHE_ARRAY, * PDOMAIN_CACHE_ARRAY ;


//
// Keep these in order.  They're used to determine UI behavior
//
typedef enum _DOMAIN_CACHE_STATE {
    DomainCacheEmpty,               // got nothing
    DomainCacheDefaultOnly,         // default values only (machine and primary domain)
    DomainCacheRegistryCache,       // default + cached values
    DomainCacheReady                // Fully up-to-date.
} DOMAIN_CACHE_STATE ;

typedef struct _DOMAIN_CACHE {

    //
    // Critical section that protects the data in this structure
    //

    CRITICAL_SECTION CriticalSection;

    //
    // Fields protected by that critical section:
    //

    //
    // Task that gets invoked if the domain changes.
    //

    HANDLE Task ;

    //
    // Window to be notified when the update thread completes
    //

    HWND UpdateNotifyWindow;
    UINT Message;

    //
    // last update time
    //

    LARGE_INTEGER   CacheUpdateTime;
    LARGE_INTEGER   RegistryUpdateTime ;

    HANDLE Key ;
    DOMAIN_CACHE_STATE State ;

    //
    // Default domain.  Used only when there is an async thread running
    // so it can set the appropriate default name.
    //

    PWSTR   DefaultDomain ;

    //
    // Flag indicating if we are in a MIT or Safemode state, which means
    // we shouldn't pester netlogon about trusted domains.
    //

    ULONG Flags ;

#define DCACHE_MIT_MODE     0x00000001  // In MIT mode
#define DCACHE_READ_ONLY    0x00000002  // Read-only copy of cache
#define DCACHE_ASYNC_UPDATE 0x00000004  // Async thread running
#define DCACHE_MEMBER       0x00000008  // This is a domain member
#define DCACHE_NO_CACHE     0x00000010  // No cache was found
#define DCACHE_DEF_UNKNOWN  0x00000020  // The default domain could not be found


    //
    // This pointer may *only* be accessed under the critical 
    // section.  This array will get swapped in and out, and
    // only references to it while it is locked are safe.
    //

    PDOMAIN_CACHE_ARRAY Array ;

} DOMAIN_CACHE, *PDOMAIN_CACHE;

#define DCACHE_UPDATE_CONFLICT      3
#define DCACHE_UPDATE_COMBOBOX      2
#define DCACHE_UPDATE_SUCCESSFUL    1
#define DCACHE_UPDATE_FAILURE       0




#else // DATA_TYPES_ONLY


#define WM_CACHE_UPDATE_COMPLETE    WM_USER+256

//
// Exported function prototypes
//

BOOL
DCacheInitialize(
    VOID
    );


VOID
DCacheDereferenceEntry(
    PDOMAIN_CACHE_ENTRY Entry
    );


PDOMAIN_CACHE_ENTRY
DCacheSearchArray(
    PDOMAIN_CACHE_ARRAY Array,
    PUNICODE_STRING DomainName
    );

PDOMAIN_CACHE
DCacheCreate(
    VOID 
    );

PDOMAIN_CACHE_ENTRY
DCacheCreateEntry(
    DOMAIN_ENTRY_TYPE Type,
    PUNICODE_STRING FlatName OPTIONAL,
    PUNICODE_STRING DnsName OPTIONAL,
    PUNICODE_STRING DisplayName OPTIONAL
    );

BOOL
DCacheUpdateMinimal(
    PDOMAIN_CACHE Cache,
    PWSTR DefaultDomain OPTIONAL,
    BOOL CompleteAsync
    );

BOOL
DCacheUpdateFull(
    PDOMAIN_CACHE Cache,
    PWSTR Default OPTIONAL
    );

PDOMAIN_CACHE_ARRAY
DCacheCopyCacheArray(
    PDOMAIN_CACHE Cache
    );

VOID
DCacheFreeArray(
    PDOMAIN_CACHE_ARRAY Array
    );

BOOL
DCacheSetNotifyWindowIfNotReady(
    PDOMAIN_CACHE Cache,
    HWND Window,
    UINT Message
    );

BOOL
DCachePopulateListBoxFromArray(
    PDOMAIN_CACHE_ARRAY Array,
    HWND ComboBox,
    LPWSTR LastKey OPTIONAL
    );

BOOL
DCacheAddNetworkProviders(
    PDOMAIN_CACHE_ARRAY Array
    );

BOOL
DCacheValidateCache(
    PDOMAIN_CACHE Cache
    );

DOMAIN_CACHE_STATE
DCacheGetCacheState(
    PDOMAIN_CACHE Cache
    );

ULONG
DCacheGetFlags(
    PDOMAIN_CACHE Cache 
    );

BOOL
DCacheAddNetworkProviders(
    PDOMAIN_CACHE_ARRAY Array
    );

BOOL
DCacheSetDefaultEntry(
    PDOMAIN_CACHE Cache,
    PWSTR FlatName OPTIONAL,
    PWSTR DnsName OPTIONAL
    );

PDOMAIN_CACHE_ENTRY
DCacheLocateEntry(
    PDOMAIN_CACHE Cache,
    PWSTR Domain
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\domain.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       domcache.c
//
//  Contents:   Restructuring the Domain Cache to get away from direct LSA
//              calls whenever possible.
//
//  Classes:
//
//  Functions:
//
//  History:    3-29-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include <msgina.h>
#include <stdio.h>

#define LockDomainCache( x )    RtlEnterCriticalSection( &(x)->CriticalSection )
#define UnlockDomainCache( x )  RtlLeaveCriticalSection( &(x)->CriticalSection )

#define TWO_MINUTES ((LONGLONG) 0x47868C00)
#define TWO_WEEKS   ((LONGLONG) 0xB0051C88000I64)

WCHAR szCache[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\DomainCache");
WCHAR szCacheValue[] = TEXT("DCache");
WCHAR szCacheUpdate[] = TEXT("DCacheUpdate");
WCHAR szCacheInterval[] = TEXT("DCacheMinInterval");
WCHAR szCachePrimary[] = TEXT("CachePrimaryDomain");

LONGLONG CacheUpdateMin;
LONGLONG CacheUpdateMax;

BOOL CacheAppendDomainInfo = FALSE ;
BOOL CacheShowDnsNames = FALSE ;

#define DOMAIN_MOD_ALWAYS   0x00000001

typedef struct _DOMAIN_MODIFIER {
    ULONG StringId ;
    ULONG Flags ;
    UNICODE_STRING String ;
} DOMAIN_MODIFIER ;


DOMAIN_MODIFIER CacheDomainModifiers[ DomainTypeMax ] = {
    { 0 },                                              // Invalid
    { IDS_DTYPE_UPNDOMAIN, 0 },                         // UPN Domain
    { IDS_DTYPE_THISCOMPUTER, DOMAIN_MOD_ALWAYS },      // This computer
    { IDS_DTYPE_NT4DOMAIN, 0 },                         // NT4 domains
    { IDS_DTYPE_NT5DOMAIN, 0 },                         // NT5 domains
    { IDS_DTYPE_MITDOMAIN, DOMAIN_MOD_ALWAYS },         // MIT domains
    { IDS_DTYPE_MITXDOMAIN, DOMAIN_MOD_ALWAYS },        // Untrusted MIT domains
    { IDS_DTYPE_NETPROVIDER, DOMAIN_MOD_ALWAYS }        // Network provider
};


DWORD
DCacheUpdateThread(
    PDOMAIN_CACHE Cache
    );


VOID
DCacheDereferenceEntry(
    PDOMAIN_CACHE_ENTRY Entry
    )
{
    if ( InterlockedDecrement( &Entry->RefCount ) == 0 )
    {
        LocalFree( Entry );
    }
}


PDOMAIN_CACHE_ARRAY
DCacheCreateArray(
    ULONG Size,
    BOOL Sorted
    )
{
    PDOMAIN_CACHE_ARRAY Array ;

    Array = LocalAlloc( LMEM_FIXED, sizeof( DOMAIN_CACHE_ARRAY ) );

    if ( Array )
    {
        Array->List = LocalAlloc( LMEM_FIXED, sizeof( PDOMAIN_CACHE_ENTRY ) * Size );

        if ( Array->List )
        {

            Array->Count = 0 ;
            Array->MaxCount = Size ;
            Array->Sorted = Sorted ;

            return Array ;
        }

        LocalFree( Array );
    }

    return NULL ;
}

BOOL
DCachepExpandArray(
    PDOMAIN_CACHE_ARRAY Array,
    ULONG Size
    )
{
    PDOMAIN_CACHE_ENTRY * NewArray ;

    NewArray = LocalReAlloc( Array->List,
                             (Array->Count + Size) * sizeof( PDOMAIN_CACHE_ENTRY ),
                             0 );

    if ( NewArray )
    {
        Array->List = NewArray ;

        Array->MaxCount = Array->Count + Size ;

        return TRUE ;
    }

    return FALSE ;

}


BOOL
DCacheInsertArray(
    PDOMAIN_CACHE_ARRAY Array,
    PDOMAIN_CACHE_ENTRY Entry
    )
{
    ULONG i ;
    LONG Compare ;
    PDOMAIN_CACHE_ENTRY Scan ;

    if ( Array->Count == Array->MaxCount )
    {
        if ( !DCachepExpandArray( Array, 10 ) )
        {
            return FALSE ;
        }
    }

    DCacheReferenceEntry( Entry );


    if ( ( Array->Sorted == FALSE ) ||
         ( Array->Count == 0 ) )
    {
        Array->List[ Array->Count ] = Entry ;

        Array->Count++ ;

        return TRUE ;

    }
    else 
    {
        Scan = Array->List[ Array->Count - 1 ];

        Compare = RtlCompareUnicodeString( &Entry->FlatName,
                                           &Scan->FlatName,
                                           TRUE );

        //
        // Efficient check for sorted input:
        //

        if ( Compare > 0 )
        {
            Array->List[ Array->Count ] = Entry ;

            Array->Count ++ ;

            return TRUE ;

        }

        //
        // this is not a terribly efficient sort.
        // However, we're expecting
        // on the order of <100 objects in the array, so it
        // shouldn't be too bad.
        //

        for ( i = 0 ; i < Array->Count ; i++ )
        {
            Scan = Array->List[ i ];

            Compare = RtlCompareUnicodeString( & Entry->FlatName,
                                               & Scan->FlatName,
                                               TRUE );

            if ( Compare == 0 )
            {
                DCacheDereferenceEntry( Entry );

                return FALSE ;
            }

            if ( Compare < 0 )
            {
                break;
            }
            
        }

        RtlMoveMemory(
            &Array->List[ i + 1 ],
            &Array->List[ i ],
            (Array->Count - i) * sizeof( PVOID ) );

        Array->List[ i ] = Entry ;

        Array->Count++ ;

        return TRUE ;

    }

}

PDOMAIN_CACHE_ENTRY
DCacheSearchArray(
    PDOMAIN_CACHE_ARRAY Array,
    PUNICODE_STRING DomainName
    )
{
    ULONG i ;
    PDOMAIN_CACHE_ENTRY Scan = NULL ;
    LONG Compare ;


    for (i = 0 ; i < Array->Count ; i++ )
    {
        Scan = Array->List[ i ];

        if ( Scan->FlatName.Length == 0 )
        {
            Scan = NULL ;

            continue;
        }

        Compare = RtlCompareUnicodeString( &Scan->FlatName,
                                           DomainName,
                                           TRUE );

        if ( Compare == 0 )
        {
            break;
        }

        if ( ( Compare > 0 ) && 
             ( Array->Sorted ) )
        {
            Scan = NULL ;

            break;
        }
    }

    return Scan ;

}

PDOMAIN_CACHE_ENTRY
DCacheSearchArrayByDns(
    PDOMAIN_CACHE_ARRAY Array,
    PUNICODE_STRING DnsDomainName
    )
{
    ULONG i ;
    PDOMAIN_CACHE_ENTRY Scan = NULL ;


    for (i = 0 ; i < Array->Count ; i++ )
    {
        Scan = Array->List[ i ];

        if ( Scan->DnsName.Length )
        {
            if ( RtlEqualUnicodeString( &Scan->DnsName,
                                        DnsDomainName,
                                        TRUE ) )
            {
                break;
            }
        }

        Scan = NULL ;

    }

    return Scan ;

}

PDOMAIN_CACHE_ENTRY
DCacheFindDefaultEntry(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    ULONG i ;
    PDOMAIN_CACHE_ENTRY Scan = NULL ;


    for (i = 0 ; i < Array->Count ; i++ )
    {
        Scan = Array->List[ i ];

        if ( Scan->Flags & DCE_DEFAULT_ENTRY )
        {
            break;
        }

        Scan = NULL ;
    }

    return Scan ;

}

VOID
DCacheFreeArray(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    ULONG i ;

    for ( i = 0 ; i < Array->Count ; i++ )
    {
        DCacheDereferenceEntry( Array->List[ i ] );
    }

    LocalFree( Array->List );

    LocalFree( Array );

}

PDOMAIN_CACHE_ARRAY
DCacheCopyArray(
    PDOMAIN_CACHE_ARRAY Source
    )
{
    PDOMAIN_CACHE_ARRAY Array ;
    ULONG i ;

    Array = DCacheCreateArray( Source->MaxCount,
                               Source->Sorted );

    if ( Array )
    {
        for (i = 0 ; i < Source->Count ; i++ )
        {
            Array->List[ i ] = Source->List[ i ];

            DCacheReferenceEntry( Array->List[ i ] );
        }

        Array->Count = Source->Count ;
    }

    return Array ;
}



PDOMAIN_CACHE_ENTRY
DCacheCreateEntry(
    DOMAIN_ENTRY_TYPE Type,
    PUNICODE_STRING FlatName OPTIONAL,
    PUNICODE_STRING DnsName OPTIONAL,
    PUNICODE_STRING DisplayName OPTIONAL
    )
{
    ULONG Size ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PUNICODE_STRING DisplayBase = NULL ;
    PUNICODE_STRING Modifier = NULL ;
    PUCHAR Current ;

    //
    // Validation rules:
    //
    // Display Name is optional if either of FlatName or
    // DNS name is present.  If both are present, FlatName
    // is defaulted over Dns name
    //

    Size = sizeof( DOMAIN_CACHE_ENTRY );

    if ( FlatName )
    {
        Size += FlatName->Length + sizeof( WCHAR );
    }

    if ( DnsName )
    {
        Size += DnsName->Length + sizeof( WCHAR );
    }

    if ( DisplayName )
    {
        Size += DisplayName->Length + sizeof( WCHAR );

        DisplayBase = DisplayName ;
    }
    else 
    {
        if ( CacheShowDnsNames ||
             ( ( Type == DomainMitRealm ) ||
               ( Type == DomainMitUntrusted ) ) )
        {
            if ( DnsName )
            {
                DisplayBase = DnsName ;
            }
            else if ( FlatName )
            {
                DisplayBase = FlatName ;
            }
            else 
            {
                return NULL ;
            }
        }
        else 
        {
            if ( FlatName )
            {
                DisplayBase = FlatName ;
            }
            else if ( DnsName )
            {
                DisplayBase = DnsName ;
            }
            else 
            {
                return NULL ;
            }

        }

        Size += DisplayBase->Length + sizeof( WCHAR );

        if ( ( CacheAppendDomainInfo ) ||
             ( CacheDomainModifiers[ Type ].Flags & DOMAIN_MOD_ALWAYS ) )
        {
            Modifier = &CacheDomainModifiers[ Type ].String ;

            if ( Modifier->Length )
            {
                Size += CacheDomainModifiers[ Type ].String.Length;
            }
            else 
            {
                Modifier = NULL ;
            }
        }

    }

    Entry = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size );

    if ( !Entry )
    {
        return NULL ;
    }

    Entry->RefCount = 1 ;
    Entry->Flags = 0 ;
    Entry->Type = Type ;

    Current = (PUCHAR) ( Entry + 1 );

    //
    // Copy and pack the strings:
    //

    if ( FlatName )
    {
        Entry->FlatName.Buffer = (PWSTR) Current ;
        Entry->FlatName.Length = FlatName->Length ;
        Entry->FlatName.MaximumLength = FlatName->Length + sizeof( WCHAR );

        RtlCopyMemory(
            Current,
            FlatName->Buffer,
            FlatName->Length );

        Current += FlatName->Length ;

        *Current++ = '\0';
        *Current++ = '\0';

    }

    if ( DnsName )
    {
        Entry->DnsName.Buffer = (PWSTR) Current ;
        Entry->DnsName.Length = DnsName->Length ;
        Entry->DnsName.MaximumLength = DnsName->Length + sizeof( WCHAR );

        RtlCopyMemory(
            Current,
            DnsName->Buffer,
            DnsName->Length );

        Current += DnsName->Length ;

        *Current++ = '\0';
        *Current++ = '\0';
    }

    ASSERT( DisplayBase );

    Entry->DisplayName.Buffer = (PWSTR) Current ;
    Entry->DisplayName.Length = DisplayBase->Length ;
    if ( Modifier )
    {
        Entry->DisplayName.Length = Entry->DisplayName.Length + Modifier->Length ;
    }

    Entry->DisplayName.MaximumLength = Entry->DisplayName.Length + sizeof( WCHAR );

    RtlCopyMemory(
        Current,
        DisplayBase->Buffer,
        DisplayBase->Length );

    Current += DisplayBase->Length ;

    if ( Modifier )
    {
        RtlCopyMemory(
            Current,
            Modifier->Buffer,
            Modifier->Length );

        Current += Modifier->Length ;
    }

    *Current++ = '\0';
    *Current++ = '\0';

    return Entry ;

}

LONG 
DCacheGetTrustedDomains(
    PDOMAIN_CACHE_ARRAY * pArray
    )
{
    LONG NetStatus ;
    PDOMAIN_CACHE_ARRAY Array ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PDS_DOMAIN_TRUSTS Trusts ;
    ULONG TrustCount ;
    ULONG i ;
    UNICODE_STRING Flat ;
    UNICODE_STRING Dns ;
    DOMAIN_ENTRY_TYPE Type ;

    *pArray = NULL ;

    NetStatus = DsEnumerateDomainTrusts(
                    NULL,
                    DS_DOMAIN_IN_FOREST |
                        DS_DOMAIN_DIRECT_OUTBOUND,
                    &Trusts,
                    &TrustCount );

    if ( NetStatus != NERR_Success )
    {
        return NetStatus ;
    }

    Array = DCacheCreateArray( TrustCount + 5,
                               TRUE );

    if ( !Array )
    {
        NetApiBufferFree( Trusts );

        return ERROR_NOT_ENOUGH_MEMORY ;
    }

    for ( i = 0 ; i < TrustCount ; i++ )
    {

        if ( Trusts[ i ].NetbiosDomainName )
        {
            RtlInitUnicodeString( &Flat, Trusts[ i ].NetbiosDomainName );
        }
        else 
        {
            ZeroMemory( &Flat, sizeof( Flat ) );
        }

        if ( Trusts[ i ].DnsDomainName )
        {
            RtlInitUnicodeString( &Dns, Trusts[ i ].DnsDomainName );
        }
        else 
        {
            ZeroMemory( &Dns, sizeof( Dns ) );
        }

        switch ( Trusts[ i ].TrustType )
        {
            case TRUST_TYPE_DOWNLEVEL :
                Type = DomainNt4 ;
                break;

            case TRUST_TYPE_UPLEVEL:
                Type = DomainNt5 ;
                break;

            case TRUST_TYPE_MIT:
                Type = DomainMitRealm ;
                break;

            default:
                continue;
        }


        DebugLog(( DEB_TRACE_CACHE, "Processing domain (%d) %ws\n",
                   Type,
                   Trusts[ i ].NetbiosDomainName ));

        Entry = DCacheCreateEntry(
                    Type,
                    ( Flat.Buffer ? &Flat : NULL ),
                    ( Dns.Buffer ? &Dns : NULL ),
                    NULL );

        if ( Entry )
        {
            DCacheInsertArray( 
                Array, 
                Entry );

            DCacheDereferenceEntry( Entry );
        }

    }

    NetApiBufferFree( Trusts );

    *pArray = Array ;

    return 0 ;

}

BOOL
DCacheAddMitRealms(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    HKEY MitKey ;
    DWORD Index ;
    PWSTR Realms;
    DWORD RealmSize;
    int err ;
    DWORD NumRealms;
    DWORD MaxRealmLength ;
    FILETIME KeyTime ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PDOMAIN_CACHE_ENTRY TrustedDomain ;
    UNICODE_STRING DnsName ;

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains"),
                0,
                KEY_READ,
                &MitKey );

    if ( err == 0 )
    {
        err = RegQueryInfoKey( MitKey,
                               NULL,
                               NULL,
                               NULL,
                               &NumRealms,
                               &MaxRealmLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        MaxRealmLength++ ;

        MaxRealmLength *= sizeof( WCHAR );

        Realms = LocalAlloc( LMEM_FIXED, MaxRealmLength );


        if ( Realms)
        {

            for ( Index = 0 ; Index < NumRealms ; Index++ )
            {
                RealmSize = MaxRealmLength ;

                err = RegEnumKeyEx( MitKey,
                                  Index,
                                  Realms,
                                  &RealmSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &KeyTime );


                if ( err == 0 )
                {
                    DebugLog(( DEB_TRACE_CACHE, "Found realm %ws\n", Realms ));

                    RtlInitUnicodeString( &DnsName, Realms );

                    Entry = DCacheCreateEntry( 
                                DomainMitUntrusted,
                                &DnsName,
                                &DnsName,
                                NULL );

                    if ( Entry )
                    {
                        Entry->Flags |= DCE_REACHABLE_MIT ;

                        if ( !DCacheInsertArray( Array, Entry ) )
                        {
                            //
                            // If the insert failed, then there's already an entry
                            // in the list for this domain.  Locate it, and tag it
                            // so that it will be displayed
                            //

                            TrustedDomain = DCacheSearchArray( Array, &DnsName );

                            if ( TrustedDomain )
                            {
                                TrustedDomain->Flags |= DCE_REACHABLE_MIT ;
                            }

                        }

                        DCacheDereferenceEntry( Entry );
                    }
                    
                }

            }

            LocalFree( Realms );

        }

        RegCloseKey( MitKey );
    }

    return TRUE ;

}

BOOL
DCacheAddNetworkProviders(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    WCHAR   szProviderName[128];
    WCHAR   szKeyPath[MAX_PATH];
    PWSTR   pszProviders;
    PWSTR   pszScan;
    PWSTR   pszStart;
    WCHAR   Save;
    HKEY    hKey;
    DWORD   dwType;
    DWORD   dwLen;
    DWORD   Class;
    int     err;
    PDOMAIN_CACHE_ENTRY Entry ;
    UNICODE_STRING String ;


    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("System\\CurrentControlSet\\Control\\NetworkProvider\\Order"),
                      0,
                      KEY_READ,
                      &hKey );

    if ( err )
    {
        return FALSE ;
    }

    err = RegQueryValueEx(  hKey,
                            TEXT("ProviderOrder"),
                            NULL,
                            &dwType,
                            NULL,
                            &dwLen );

    if ( (err) || (dwType != REG_SZ) )
    {
        RegCloseKey( hKey );
        return FALSE ;
    }

    pszProviders = LocalAlloc( LMEM_FIXED, dwLen );

    if ( !pszProviders )
    {
        RegCloseKey( hKey );
        return FALSE ;
    }

    err = RegQueryValueEx(  hKey,
                            TEXT("ProviderOrder"),
                            NULL,
                            &dwType,
                            (PUCHAR) pszProviders,
                            &dwLen );

    RegCloseKey( hKey );

    if ( err )
    {
        LocalFree( pszProviders );
        return FALSE ;
    }

    //
    // Initialize things.
    //

    pszStart = pszProviders;


    szProviderName[0] = TEXT('<');
    szProviderName[1] = TEXT(' ');


    while ( *pszStart )
    {
        pszScan = pszStart;
        while ( (*pszScan) && (*pszScan != TEXT(',') ) )
        {
            pszScan++;
        }

        Save = *pszScan;

        *pszScan = TEXT('\0');

        wsprintf( szKeyPath,
                TEXT("System\\CurrentControlSet\\Services\\%s\\networkprovider"),
                pszStart );

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szKeyPath,
                          0,
                          KEY_READ,
                          &hKey );

        if ( err == 0 )
        {

            dwLen = sizeof(DWORD) ;

            err = RegQueryValueEx( hKey,
                                   TEXT("Class"),
                                   NULL,
                                   &dwType,
                                   (PUCHAR) &Class,
                                   &dwLen );

            if ( (err == 0) && (dwType == REG_DWORD) )
            {
                if ( Class & WN_CREDENTIAL_CLASS )
                {
                    
                    dwLen = 126 * sizeof(WCHAR);

                    err = RegQueryValueEx(  hKey,
                                            TEXT("Name"),
                                            NULL,
                                            &dwType,
                                            (PUCHAR) &szProviderName[2],
                                            &dwLen );

                    wcscpy( &szProviderName[ (dwLen / sizeof(WCHAR) ) + 2 ],
                            TEXT(" >") );

                    RtlInitUnicodeString( &String, szProviderName );

                    Entry = DCacheCreateEntry(
                                DomainNetworkProvider,
                                &String,
                                NULL,
                                NULL );

                    if ( Entry )
                    {
                        DCacheInsertArray( Array, Entry );

                        DCacheDereferenceEntry( Entry );
                    }

                }
            }

            RegCloseKey( hKey );

        }

        *pszScan = Save;
        if ( *pszScan )
        {
            pszStart = pszScan + 1;
        }
        else
        {
            pszStart = NULL;
            break;
        }

    }

    LocalFree( pszProviders );

    return TRUE ;

}

BOOL
DCacheGetDomainsFromCache(
    PDOMAIN_CACHE_ARRAY *pArray,
    PLARGE_INTEGER RegistryTime
    )
{
    HKEY Key ;
    int err ;
    DWORD NumDomains ;
    DWORD i ;
    WCHAR FlatName[ DNLEN + 2 ];
    WCHAR DnsDomain[ MAX_PATH ];
    DWORD dwType ;
    DWORD FlatNameSize ;
    DWORD DnsDomainSize ;
    UNICODE_STRING Flat ;
    UNICODE_STRING Dns ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PDOMAIN_CACHE_ARRAY Array ;
    DWORD dwSize ;
    PWSTR DomainBuffer ;
    PWSTR DomainBufferEnd ;
    PWSTR Scan ;
    ULONG Disp ;
    BOOL ReturnFalseAnyway = FALSE ;

    if ( SafeBootMode == SAFEBOOT_MINIMAL )
    {
        RegistryTime->QuadPart = 0 ;
        return FALSE ;
    }

    dwSize = 0 ;
    err = RegQueryValueEx(
                WinlogonKey,
                szCacheValue,
                NULL,
                &dwType,
                NULL,
                &dwSize );

    if ( ( err == ERROR_MORE_DATA ) ||
         ( err == ERROR_BUFFER_OVERFLOW ) ||
         ( err == 0 ) )
    {
        //
        // 

        DomainBuffer = LocalAlloc( LMEM_FIXED, dwSize );

        if ( DomainBuffer )
        {
            err = RegQueryValueEx(
                        WinlogonKey,
                        szCacheValue,
                        NULL,
                        &dwType,
                        (PUCHAR) DomainBuffer, 
                        &dwSize );

            if ( err == 0 )
            {
                DomainBufferEnd = (PWSTR)((PUCHAR) DomainBuffer + dwSize);

                Scan = DomainBuffer ;

                err = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            szCache,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &Key,
                            &Disp );

                if ( err == 0 )
                {
                    while ( Scan != DomainBufferEnd )
                    {
                        err = RegSetValueEx(
                                    Key,
                                    Scan,
                                    0,
                                    REG_SZ,
                                    (PUCHAR) TEXT(""),
                                    sizeof( WCHAR ) );

                        Scan += wcslen(Scan) ;

                        while ( (*Scan == L'\0' ) &&
                                (Scan != DomainBufferEnd ) )
                        {
                            Scan++ ;
                        }

                    }

                    RegCloseKey( Key );
                }

            }

            LocalFree( DomainBuffer );
        }

        RegDeleteValue( WinlogonKey, szCacheValue );

        ReturnFalseAnyway = TRUE ;
    }

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szCache,
                0,
                KEY_READ,
                &Key );

    if ( err )
    {
        return FALSE ;
    }

    err = RegQueryInfoKey( Key,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           &NumDomains,
                           NULL,
                           NULL,
                           NULL,
                           NULL );

    if ( *pArray )
    {
        Array = *pArray ;
    }
    else 
    {
        Array = DCacheCreateArray( NumDomains + 5, TRUE );
    }

    if ( Array )
    {
        for ( i = 0 ; i < NumDomains ; i++ )
        {
            FlatNameSize = DNLEN + 2 ;
            DnsDomainSize = MAX_PATH ;


            err = RegEnumValue(
                        Key,
                        i,
                        FlatName,
                        &FlatNameSize,
                        NULL,
                        &dwType,
                        (PUCHAR) DnsDomain,
                        &DnsDomainSize );

            if ( err == 0 )
            {
                RtlInitUnicodeString( &Flat, FlatName );

                RtlInitUnicodeString( &Dns, DnsDomain );

                Entry = DCacheCreateEntry(
                            ( Dns.Length ? DomainNt5 : DomainNt4),
                            &Flat,
                            ( Dns.Length ? &Dns : NULL ),
                            NULL );

                if ( Entry )
                {
                    DCacheInsertArray( Array, Entry );

                    DCacheDereferenceEntry( Entry );
                }


            }

        }
    }


    RegCloseKey( Key );

    if ( RegistryTime )
    {
        dwSize = sizeof( LARGE_INTEGER ) ;

        if ( RegQueryValueEx( WinlogonKey,
                              szCacheUpdate,
                              0,
                              &dwType,
                              (PUCHAR) RegistryTime,
                              &dwSize ) ||
             (dwType != REG_BINARY ) ||
             (dwSize != sizeof( LARGE_INTEGER ) ) )
        {
            RegistryTime->QuadPart = 0 ;
        }

    }


    *pArray = Array ;

    if ( ReturnFalseAnyway )
    {
        return FALSE ;
    }
    else 
    {
        return TRUE ;
    }
}


PDOMAIN_CACHE_ENTRY
DCacheEntryFromRegistry(
    PUNICODE_STRING FlatName
    )
{
    PDOMAIN_CACHE_ENTRY Entry = NULL ;
    HKEY Key ;
    int err ;
    DWORD dwType ;
    WCHAR DnsName[ MAX_PATH ];
    DWORD dwSize ;
    UNICODE_STRING Dns ;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        szCache,
                        0,
                        KEY_READ,
                        &Key );

    if ( err == 0 )
    {
        dwSize = MAX_PATH ;
        DnsName[ 0 ] = L'\0';

        err = RegQueryValueEx(
                    Key,
                    FlatName->Buffer,
                    NULL,
                    &dwType,
                    (PUCHAR) DnsName,
                    &dwSize );

        if ( err == 0 )
        {
            if ( dwType == REG_SZ )
            {
                RtlInitUnicodeString( &Dns, DnsName );

                Entry = DCacheCreateEntry(
                            ( Dns.Length ? DomainNt5 : DomainNt4 ),
                            FlatName,
                            ( Dns.Length ? &Dns : NULL ),
                            NULL );

            }
        }

        RegCloseKey( Key );

    }

    return Entry ;
}

VOID
DCacheWriteDomainsToCache(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    HKEY Key ;
    ULONG i ;
    ULONG Disp ;
    int err ;
    PDOMAIN_CACHE_ENTRY Entry ;
    LARGE_INTEGER Now ;


    //
    // Delete what's there.  Ignore the error, since we are
    // just going to rewrite all the values, anyway.
    //

    err = RegDeleteKey( HKEY_LOCAL_MACHINE,
                        szCache );


    err = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                szCache,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &Key,
                &Disp );

    if ( err )
    {
        return ;
    }

    for ( i = 0 ; i < Array->Count ; i++ )
    {
        Entry = Array->List[ i ];

        if ( ( Entry->Type == DomainNt5 ) )
        {
            if ( ( Entry->FlatName.Buffer == NULL ) ||
                 ( Entry->DnsName.Buffer == NULL ) )
            {
                DebugLog(( DEB_ERROR, "Corrupt uplevel domain cache entry at %p\n", Entry ));
                continue;
            }
            RegSetValueEx(
                Key,
                Entry->FlatName.Buffer,
                0,
                REG_SZ,
                (PUCHAR) Entry->DnsName.Buffer,
                Entry->DnsName.Length + sizeof(WCHAR) );
        }
        else if ( Entry->Type == DomainNt4 )
        {
            if ( Entry->FlatName.Buffer == NULL )
            {
                DebugLog(( DEB_ERROR, "Corrupt downlevel domain cache entry at %p\n", Entry ));
            }

            RegSetValueEx(
                Key,
                Entry->FlatName.Buffer,
                0,
                REG_SZ,
                (PUCHAR) TEXT(""),
                sizeof(WCHAR) );
        }
        else 
        {
            //
            // Other types don't get to live in the cache
            //

            NOTHING ;
        }

    }

    RegCloseKey( Key );

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    RegSetValueEx(
        WinlogonKey,
        szCacheUpdate,
        0,
        REG_BINARY,
        (PUCHAR) &Now,
        sizeof( LARGE_INTEGER ) );


}



BOOL
DCacheInitialize(
    VOID
    )
{
    DOMAIN_ENTRY_TYPE Types ;
    WCHAR StringBuffer[ MAX_PATH ];
    LONG Size ;
    int err ;
    DWORD dwSize ;
    DWORD dwType ;

    for (Types = 0 ; Types < DomainTypeMax ; Types++ )
    {
        if ( CacheDomainModifiers[ Types ].StringId )
        {
            Size = LoadString( hDllInstance,
                               CacheDomainModifiers[ Types ].StringId,
                               StringBuffer,
                               MAX_PATH );

            if ( Size )
            {
                RtlCreateUnicodeString( &CacheDomainModifiers[ Types ].String,
                                        StringBuffer );
            }
        }
    }

    dwSize = sizeof( CacheShowDnsNames );

    err = RegQueryValueEx(
                WinlogonKey,
                DCACHE_SHOW_DNS_NAMES,
                NULL,
                &dwType,
                (PUCHAR) &CacheShowDnsNames,
                &dwSize );

    dwSize = sizeof( CacheAppendDomainInfo );
    err = RegQueryValueEx(
                WinlogonKey,
                DCACHE_SHOW_DOMAIN_TAGS,
                NULL,
                &dwType,
                (PUCHAR) &CacheAppendDomainInfo,
                &dwSize );

    //
    // Convert and delete old cache:
    //


    return TRUE ;
}

BOOL
DCachepInitializeCache(
    PDOMAIN_CACHE pCache 
    )
{
    NTSTATUS Status ;

    ZeroMemory( pCache, sizeof(DOMAIN_CACHE) );

    Status = RtlInitializeCriticalSectionAndSpinCount( 
                        & pCache->CriticalSection, 
                        0x80000000 );

    return NT_SUCCESS( Status );
}



PDOMAIN_CACHE
DCacheCreate(
    VOID
    )
{
    PDOMAIN_CACHE Cache ;

    Cache = (PDOMAIN_CACHE) LocalAlloc( LMEM_FIXED, sizeof( DOMAIN_CACHE ) );

    if ( !Cache )
    {
        return NULL ;
    }

    if ( !DCachepInitializeCache( Cache ) )
    {
        LocalFree( Cache );

        return NULL ;

    }

    Cache->State = DomainCacheEmpty ;

    if ( !g_Console )
    {
        Cache->Flags |= DCACHE_READ_ONLY ;
    }

    if ( SafeBootMode == SAFEBOOT_MINIMAL ) 
    {
        Cache->Flags |= DCACHE_MIT_MODE ;
    }

    return Cache ;
}

BOOL
DCacheGetMinimalArray(
    PDOMAIN_CACHE_ARRAY Array,
    PWSTR DefaultDomain OPTIONAL,
    PBOOL DomainMember OPTIONAL,
    PBOOL NewDomain OPTIONAL
    )
{
    BOOL SidPresent = FALSE ;
    UNICODE_STRING String = { 0 } ;
    UNICODE_STRING DnsDomain = { 0 } ;
    PDOMAIN_CACHE_ENTRY Entry = NULL ;
    PDOMAIN_CACHE_ENTRY ComputerEntry = NULL ;
    PDOMAIN_CACHE_ENTRY OldDefault = NULL ;
    NT_PRODUCT_TYPE ProductType = NtProductWinNt;
    WCHAR ComputerName[ CNLEN + 1 ];
    ULONG Size ;
    ULONG Type ;
    WCHAR LastPrimary[ DNLEN + 1 ];
    UNICODE_STRING LastPrimary_U ;

    //
    // First, find out what we are
    //

    RtlGetNtProductType( &ProductType );

    if ( Array == NULL )
    {
        Array = DCacheCreateArray( 5, TRUE );
    }

    if ( Array == NULL )
    {
        return FALSE ;
    }

    if ( SafeBootMode != SAFEBOOT_MINIMAL )
    {
        if ( GetPrimaryDomainEx( &String, &DnsDomain, NULL, &SidPresent ) )
        {
            //
            // Ok, we are configured to be part of a domain.
            //

            if ( SidPresent )
            {

                //
                // Ok, this is an NT domain.
                //

                Entry = DCacheCreateEntry(
                            ( DnsDomain.Buffer ? DomainNt5 : DomainNt4 ),
                            &String,
                            &DnsDomain,
                            NULL );


                if ( Entry )
                {
                    if ( ProductType == NtProductLanManNt )
                    {
                        //
                        // We're a DC.  Until we know otherwise, tag this as the default
                        //

                        Entry->Flags |= DCE_DEFAULT_ENTRY ;
                    }

                    DCacheInsertArray( Array, Entry );

                    DCacheDereferenceEntry( Entry );

                    Entry = NULL ;
                }

                //
                // Check to see if we've changed domains:
                //

                if ( NewDomain )
                {
                    Size = sizeof( LastPrimary );

                    if ( RegQueryValueEx(
                            WinlogonKey,
                            szCachePrimary,
                            0,
                            &Type,
                            (PUCHAR) LastPrimary,
                            &Size ) == 0 )
                    {
                        RtlInitUnicodeString( &LastPrimary_U, LastPrimary );

                        *NewDomain = !RtlEqualUnicodeString( &LastPrimary_U,
                                                            &String,
                                                            TRUE );
                    }
                    else
                    {
                        //
                        // If the value can't be read for any reason, assume that it's
                        // missing and we're in a different domain than last time.
                        //

                        *NewDomain = TRUE ;
                    }
                }


                RegSetValueEx( 
                    WinlogonKey,
                    szCachePrimary,
                    0,
                    REG_SZ,
                    (PUCHAR) String.Buffer,
                    String.Length + sizeof(WCHAR));
            }
            else 
            {
                //
                // Part of an MIT realm, skip for now.  It will get added
                // below when all the MIT realms are added.
                //

                NOTHING ;
            }

            if ( String.Buffer )
            {
                LocalFree( String.Buffer );
            }

            if ( DnsDomain.Buffer )
            {
                LocalFree( DnsDomain.Buffer );
            }

        }
    }



    if ( ( ProductType != NtProductLanManNt ) ||
         ( SafeBootMode == SAFEBOOT_MINIMAL ) )
    {
        //
        // Do the machine name:
        //

        Size = CNLEN + 1;

        GetComputerName( ComputerName, &Size );

        RtlInitUnicodeString( &String, ComputerName );

        ComputerEntry = DCacheCreateEntry(
                    DomainMachine,
                    &String,
                    NULL,
                    NULL );

        if ( ComputerEntry )
        {
            DCacheInsertArray( Array, ComputerEntry );

            DCacheDereferenceEntry( ComputerEntry );
        }
    }

    DCacheAddMitRealms( Array );

    if ( DefaultDomain && (*DefaultDomain) )
    {
        RtlInitUnicodeString( &String, DefaultDomain );

        OldDefault = DCacheFindDefaultEntry( Array );

        if ( Entry )
        {
            Entry->Flags &= ~(DCE_DEFAULT_ENTRY);
        }

        Entry = DCacheSearchArray( Array, &String );

        if ( !Entry )
        {
            Entry = DCacheEntryFromRegistry( &String );

            if ( Entry )
            {
                DCacheInsertArray( Array, Entry );
            }
        }
        else 
        {
            DCacheReferenceEntry( Entry );
        }

        if ( Entry )
        {
            Entry->Flags |= DCE_DEFAULT_ENTRY ;

            DCacheDereferenceEntry( Entry );

            if ( OldDefault )
            {
                OldDefault->Flags &= ~(DCE_DEFAULT_ENTRY);
            }
        }
    }

    if ( DomainMember )
    {
        *DomainMember = SidPresent ;
    }

    return TRUE ;

}


BOOL
DCacheUpdateMinimal(
    PDOMAIN_CACHE Cache,
    PWSTR DefaultDomain OPTIONAL,
    BOOL CompleteAsync 
    )
{
    PDOMAIN_CACHE_ARRAY Array = NULL ;
    LARGE_INTEGER RegistryTime = { 0 };
    BOOL DomainMember = FALSE ;
    BOOL NewDomain = FALSE ;
    BOOL RetryDomain = FALSE ;
    BOOL NoCache = FALSE ;
    BOOL StartThread = FALSE ;
    HANDLE hThread ;
    DWORD tid ;
    WCHAR ComputerName[ 20 ];
    ULONG Size ;

    if ( !DCacheGetDomainsFromCache( &Array, &RegistryTime ) ||
         ( Array == NULL ) )
    {
        NoCache = TRUE ;
    }

    //
    // In rare events, we will leave a domain, and the cache
    // will still be in the registry.  This is caught later,
    // and deleted, and this is the retry point.
    //

ReloadWithoutCache: 

    if ( !Array )
    {
        Array = DCacheCreateArray( 5, TRUE );

        if ( !Array )
        {
            return FALSE ;
        }
    }
    

    if ( !DCacheGetMinimalArray( Array, 
                                 DefaultDomain,
                                 &DomainMember,
                                 &NewDomain ) )
    {
        DCacheFreeArray( Array );

        return FALSE ;
    }


    //
    // If we are no longer in the same domain, either in a workgroup, or
    // in a different domain, toss the cache.  If we just retried this
    // don't keep doing it...
    //

    if ( ( RetryDomain == FALSE ) &&
         ( ( ( NoCache == FALSE ) &&
             ( DomainMember == FALSE ) ) ||
           ( NewDomain == TRUE ) ) )
    {
        //
        // Cleanup.  The cache is still present, but we are no longer part of a domain
        //

        DCacheFreeArray( Array );

        RegDeleteKey( HKEY_LOCAL_MACHINE, szCache );

        RegDeleteValue( WinlogonKey, szCachePrimary );

        if ( DefaultDomain )
        {
            Size = 20 ;

            if ( GetComputerName( ComputerName, &Size ) )
            {
                if ( _wcsicmp( DefaultDomain, ComputerName ) )
                {
                    DefaultDomain = NULL ;

                    RegSetValueEx(
                            WinlogonKey,
                            DEFAULT_DOMAIN_NAME_KEY,
                            0,
                            REG_SZ,
                            (PUCHAR) ComputerName,
                            (Size + 1) * sizeof( WCHAR ) );
                }
            }
        }


        NoCache = TRUE ;

        Array = NULL ;

        RetryDomain = TRUE ;

        goto ReloadWithoutCache; 

    }

    LockDomainCache( Cache );

    if ( Cache->Array )
    {
        DCacheFreeArray( Cache->Array );
    }

    Cache->Array = Array ;

    Cache->RegistryUpdateTime = RegistryTime ;

    if ( NoCache )
    {
        Cache->Flags |= DCACHE_NO_CACHE ;
    }


    GetSystemTimeAsFileTime( (LPFILETIME) &Cache->CacheUpdateTime );

    if ( DomainMember )
    {
        if ( !NoCache )
        {
            if ( Cache->CacheUpdateTime.QuadPart - Cache->RegistryUpdateTime.QuadPart < TWO_WEEKS )
            {
                Cache->State = DomainCacheRegistryCache ;
            }
            else 
            {
                Cache->State = DomainCacheDefaultOnly ;
            }
        }
        else 
        {
            Cache->State = DomainCacheDefaultOnly ;
        }

        Cache->Flags |= DCACHE_MEMBER ;
    }
    else 
    {
        Cache->State = DomainCacheReady ;
    }

    if ( DCacheFindDefaultEntry( Array ) == NULL )
    {
        Cache->Flags |= DCACHE_DEF_UNKNOWN ;
    }


    if ( ( Cache->State != DomainCacheReady ) &&
         ( CompleteAsync ) )
    {
        StartThread = TRUE ;

        if ( DefaultDomain )
        {
            Cache->DefaultDomain = DupString( DefaultDomain );
        }
        else 
        {
            Cache->DefaultDomain = NULL ;
        }
    }

    UnlockDomainCache( Cache );

    if ( StartThread )
    {
        hThread = CreateThread( NULL,
                                0,
                                DCacheUpdateThread,
                                Cache,
                                0,
                                &tid );

        if ( hThread )
        {
            CloseHandle( hThread );
        }
        else 
        {
            LockDomainCache( Cache );

            Cache->State = DomainCacheReady ;

            UnlockDomainCache( Cache );
        }

    }

    return TRUE ;
}

BOOL
DCacheUpdateFull(
    PDOMAIN_CACHE Cache,
    PWSTR Default OPTIONAL
    )
{
    PDOMAIN_CACHE_ARRAY Array = NULL ;
    ULONG NetStatus = 0 ;
    ULONG RetryCount = 3 ;
    BOOL DomainMember = FALSE ;
    NT_PRODUCT_TYPE ProductType = NtProductWinNt;
    LARGE_INTEGER RegistryTime = { 0 };

    if ( ( Cache->Flags & DCACHE_MEMBER ) != 0 )
    {

        DomainMember = TRUE ;

        RtlGetNtProductType( &ProductType );

        if ( ProductType == NtProductLanManNt )
        {
            RetryCount = 3600 ;
        }
        //
        // now, call netlogon, and see if it has the list.
        //

        NetStatus = DCacheGetTrustedDomains( &Array );

        if ( NetStatus != 0 )
        {
            while ( RetryCount-- )
            {
                Sleep( 3000 );

                NetStatus = DCacheGetTrustedDomains( &Array );

                if ( NetStatus == 0 )
                {
                    break;
                }
            }

        }

        if ( NetStatus != 0 )
        {
            //
            // Try to read from the cache
            //

            DCacheGetDomainsFromCache( &Array, &RegistryTime );
        }

    }


    if ( Array )
    {
        DCacheGetMinimalArray( Array, Default, &DomainMember, NULL );
    }

    if ( Array )
    {
        LockDomainCache( Cache );

        if ( Cache->Array )
        {
            DCacheFreeArray( Cache->Array );
        }

        Cache->Array = Array ;

        if ( DomainMember )
        {
            Cache->Flags |= DCACHE_MEMBER ;
        }
        else 
        {
            Cache->Flags &= ~( DCACHE_MEMBER ) ;
        }

        if ( NetStatus == 0 )
        {
            Cache->State = DomainCacheReady ;

            if ( ( Cache->Flags & DCACHE_READ_ONLY ) == 0 )
            {
                DCacheWriteDomainsToCache( Array );
            }

            GetSystemTimeAsFileTime( (LPFILETIME) &Cache->RegistryUpdateTime );

            Cache->Flags &= ~(DCACHE_NO_CACHE);
        }
        else if ( (Cache->Flags & DCACHE_NO_CACHE) == 0 )
        {
            Cache->State = DomainCacheRegistryCache ;

            Cache->RegistryUpdateTime = RegistryTime ;
        }
        else 
        {
            Cache->State = DomainCacheDefaultOnly ;

            Cache->RegistryUpdateTime.QuadPart = 0 ;
        }


        if ( Cache->DefaultDomain )
        {
            DCacheSetDefaultEntry(  Cache, 
                                    Cache->DefaultDomain, 
                                    NULL );

            Free( Cache->DefaultDomain );

            Cache->DefaultDomain = NULL ;

        }

        UnlockDomainCache( Cache );

    }

    return ( Array != NULL ) ;


}

DWORD
DCacheUpdateThread(
    PDOMAIN_CACHE Cache
    )
{
    HWND Notify ;
    UINT Message ;

    LockDomainCache( Cache );

    if ( ( Cache->Flags & DCACHE_ASYNC_UPDATE ) != 0 )
    {
        //
        // Another thread is already doing this.
        //

        UnlockDomainCache( Cache );

        return 0 ;
    }

    Cache->Flags |= DCACHE_ASYNC_UPDATE ;

    UnlockDomainCache( Cache );

    DCacheUpdateFull( Cache, NULL );

    LockDomainCache( Cache );

    Notify = Cache->UpdateNotifyWindow ;
    Message = Cache->Message ;

    Cache->UpdateNotifyWindow = NULL ;
    Cache->Message = 0 ;

    Cache->Flags &= ~( DCACHE_ASYNC_UPDATE );

    UnlockDomainCache( Cache );

    if ( Notify )
    {
        DebugLog(( DEB_TRACE_CACHE, "Notifying window %x of cache complete\n" ));
        PostMessage( Notify, Message, 0, 0 );
    }

    return 0;

}


BOOL
DCachePopulateListBoxFromArray(
    PDOMAIN_CACHE_ARRAY Array,
    HWND ComboBox,
    LPWSTR LastKey OPTIONAL
    )
{
    ULONG i ;
    ULONG_PTR Index ;
    PDOMAIN_CACHE_ENTRY Default = NULL ;
    LRESULT Result ;

    //
    // Reset the combo box
    //

    DebugLog((DEB_TRACE_CACHE, "Flushing listbox\n" ));
    SendMessage( ComboBox, CB_RESETCONTENT, 0, 0);

    for ( i = 0 ; i < Array->Count ; i++ )
    {
        DebugLog(( DEB_TRACE_CACHE, "Adding domain %ws (%d) to listbox\n",
                   Array->List[ i ]->DisplayName.Buffer,
                   Array->List[ i ]->Type ));

        if ( Array->List[ i ]->Type == DomainMitRealm )
        {
            if ( (Array->List[ i ]->Flags & DCE_REACHABLE_MIT ) == 0 )
            {
                DebugLog(( DEB_TRACE_CACHE, "MIT Realm %ws is not reachable, skipping\n",
                            Array->List[ i ]->FlatName.Buffer ));

                continue;
            }
        }

        Index = SendMessage( ComboBox, 
                     CB_ADDSTRING,
                     0,
                     (LPARAM) Array->List[ i ]->DisplayName.Buffer );

        if ( Index != CB_ERR )
        {
            SendMessage( ComboBox,
                         CB_SETITEMDATA,
                         (WPARAM) Index,
                         (LPARAM) Array->List[ i ] );

        }

        if ( ( Array->List[ i ]->Type == DomainMachine ) &&
             ( Default == NULL ) )
        {
            Default = Array->List[ i ] ;
        }

        if ( Array->List[ i ]->Flags & DCE_DEFAULT_ENTRY )
        {
            Default = Array->List[ i ];
        }

    }

    //
    // Select the default entry:
    //

    if ( LastKey && (*LastKey) )
    {
        Result = SendMessage( ComboBox,
                     CB_SELECTSTRING,
                     (WPARAM) -1,
                     (LPARAM) LastKey );

#if DBG
        if ( Result != CB_ERR )
        {
            DebugLog(( DEB_TRACE_CACHE, "Selected first entry starting with %ws\n", LastKey ));
        }
        else 
        {
            DebugLog(( DEB_TRACE_CACHE, "No entry found starting with %ws.  Trying default\n", LastKey ));
        }
#endif 
    } 
    else 
    {
        Result = CB_ERR ;
    }

    if ( ( Result == CB_ERR ) && 
         ( Default != NULL ) )
    {
        SendMessage( ComboBox, 
                     CB_SELECTSTRING, 
                     (WPARAM) -1, 
                     (LPARAM) Default->DisplayName.Buffer );

        DebugLog(( DEB_TRACE_CACHE, "Selecting '%ws' as the default entry\n", 
                    Default->DisplayName.Buffer ));
    }


    return TRUE ;
}

BOOL
DCacheSetNotifyWindowIfNotReady(
    PDOMAIN_CACHE Cache,
    HWND Window,
    UINT Message
    )
{
    BOOL IsReady = FALSE ;
    HANDLE hThread ;
    DWORD tid ;

    LockDomainCache( Cache );

    IsReady = ( Cache->State == DomainCacheReady );

    if ( !IsReady )
    {
        Cache->UpdateNotifyWindow = Window ;
        Cache->Message = Message ;
    }
    else 
    {
        if ( ( Cache->Flags & DCACHE_ASYNC_UPDATE ) == 0 )
        {
            hThread = CreateThread( NULL,
                                    0,
                                    DCacheUpdateThread,
                                    Cache,
                                    0,
                                    &tid );

        }
    }

    UnlockDomainCache( Cache );

    return IsReady ;

}


PDOMAIN_CACHE_ARRAY
DCacheCopyCacheArray(
    PDOMAIN_CACHE Cache
    )
{
    PDOMAIN_CACHE_ARRAY Array = NULL ;

    LockDomainCache( Cache );

    if ( Cache->Array )
    {
        Array = DCacheCopyArray( Cache->Array );
    }

    UnlockDomainCache( Cache );

    return Array ;
}

BOOL
DCacheValidateCache(
    PDOMAIN_CACHE Cache
    )
{
    LARGE_INTEGER Now ;
    LARGE_INTEGER Diff ;

    LockDomainCache( Cache );

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    Diff.QuadPart = Now.QuadPart - Cache->CacheUpdateTime.QuadPart ;

    UnlockDomainCache( Cache );

    return (Diff.QuadPart < TWO_MINUTES );

}

DOMAIN_CACHE_STATE
DCacheGetCacheState(
    PDOMAIN_CACHE Cache
    )
{
    DOMAIN_CACHE_STATE State ;

    LockDomainCache( Cache );

    State = Cache->State ;

    UnlockDomainCache( Cache );

    return State ;
}

BOOL
DCacheSetDefaultEntry(
    PDOMAIN_CACHE Cache,
    PWSTR FlatName OPTIONAL,
    PWSTR DnsName OPTIONAL
    )
{
    UNICODE_STRING String ;
    PDOMAIN_CACHE_ENTRY Entry ;
    BOOL Result ;

    if ( ( FlatName == NULL ) &&
        ( DnsName == NULL ) )
    {
        return FALSE ;
    }

    LockDomainCache( Cache );

    Entry = DCacheFindDefaultEntry( Cache->Array );

    if ( Entry )
    {
        Entry->Flags &= ~(DCE_DEFAULT_ENTRY) ;
    }

    if ( FlatName )
    {
        RtlInitUnicodeString( &String, FlatName );

        Entry = DCacheSearchArray( Cache->Array,
                                   &String );

        
    }
    else 
    {         
        RtlInitUnicodeString( &String, DnsName );

        Entry = DCacheSearchArrayByDns( Cache->Array,
                                        &String );

    }

    if ( Entry )
    {
        Entry->Flags |= DCE_DEFAULT_ENTRY ;

        Result = TRUE ;

        DebugLog(( DEB_TRACE_CACHE, "Setting '%ws' to be the default\n", 
                   Entry->DisplayName.Buffer ));
    }
    else 
    {
        Result = FALSE ;
    }

    if ( Result )
    {
        Cache->Flags &= ~(DCACHE_DEF_UNKNOWN) ;
    }
    else 
    {
        Cache->Flags |= DCACHE_DEF_UNKNOWN ;
    }

    UnlockDomainCache( Cache );

    return Result ;
}

PDOMAIN_CACHE_ENTRY
DCacheLocateEntry(
    PDOMAIN_CACHE Cache,
    PWSTR Domain
    )
{
    PDOMAIN_CACHE_ENTRY Entry = NULL ;
    UNICODE_STRING String ;

    LockDomainCache( Cache );

    if ( Domain )
    {
        RtlInitUnicodeString( &String, Domain );

        Entry = DCacheSearchArray( Cache->Array,
                                   &String );

        if ( Entry )
        {
            DCacheReferenceEntry( Entry );
        }
    }

    UnlockDomainCache( Cache );

    return Entry ;
}


ULONG
DCacheGetFlags(
    PDOMAIN_CACHE Cache 
    )
{
    ULONG Flags ;

    LockDomainCache( Cache );

    Flags = Cache->Flags ;

    UnlockDomainCache( Cache );

    return Flags ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\langicon.c ===
#include "msgina.h"
#include <shellapi.h>

typedef struct
{
    HKL dwHkl;
    HICON hIcon;

} LAYOUTINFO, *PLAYOUTINFO;

typedef struct
{
    HKL hklLast;
    PLAYOUTINFO pLayoutInfo;
} USERLAYOUTINFO, *PUSERLAYOUTINFO;

HICON
CreateLangIdIcon(
    WORD LangId);
int
CreateIconList(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs); 

HICON
GetIconFromHkl(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs); 


USERLAYOUTINFO UserLayoutInfo[2];

typedef BOOL  (WINAPI *LPFNIMMGETIMEFILENAME)(HKL, LPTSTR, UINT);
LPFNIMMGETIMEFILENAME pfnImmGetImeFileName = NULL;
TCHAR szImm32DLL[] = TEXT("imm32.dll");

typedef UINT (WINAPI *PFNEXTRACTICONEXW)(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons);
 



/***************************************************************************\
* FUNCTION: CreateLangIdIcon
*
* PURPOSE:  Create an icon that displays the first two letters of the 
*           supplied language ID.
*
* RETURNS:  Icon that shows displays Language ID.
*
* HISTORY:
*
*   04-17-98  ShanXu       Borrowed from internat.exe
*
\***************************************************************************/

HICON
CreateLangIdIcon(
    WORD langID
    )
{
    HBITMAP hbmColour = NULL;
    HBITMAP hbmMono;
    HBITMAP hbmOld;
    HICON hicon = NULL;
    ICONINFO ii;
    RECT rc;
    DWORD rgbText;
    DWORD rgbBk = 0;
    HDC hdc = NULL;
    HDC hdcScreen;
    LOGFONT lf;
    HFONT hfont;
    HFONT hfontOld;
    TCHAR szData[20];
    UINT cxSmIcon, cySmIcon;
    

    cxSmIcon =  GetSystemMetrics(SM_CXSMICON);
    cySmIcon =  GetSystemMetrics(SM_CYSMICON);
    //
    //  Get the indicator by using the first 2 characters of the
    //  abbreviated language name.
    //
    if (GetLocaleInfo( MAKELCID(langID, SORT_DEFAULT),
                       LOCALE_SABBREVLANGNAME | LOCALE_NOUSEROVERRIDE,
                       szData,
                       sizeof(szData) / sizeof(szData[0]) ))
    {
        //
        //  Only use the first two characters.
        //
        szData[2] = TEXT('\0');
    }
    else
    {
        //
        //  Id wasn't found.  Use question marks.
        //
        szData[0] = TEXT('?');
        szData[1] = TEXT('?');
        szData[2] = TEXT('\0');
    }

    if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
    {
#if (1) //DSIE: Bug 351507
        if (hdcScreen = GetDC(NULL))
        {         
            double dScaleY = GetDeviceCaps(hdcScreen, LOGPIXELSY) / 96.0f;
            lf.lfHeight = (int) (lf.lfHeight * dScaleY); // Scale the height based on the system DPI.
            ReleaseDC(NULL, hdcScreen);
        }
#endif
        if ((hfont = CreateFontIndirect(&lf)))
        {
            hdcScreen = GetDC(NULL);
            if ( hdcScreen )
            {
                hdc = CreateCompatibleDC(hdcScreen);
                hbmColour = CreateCompatibleBitmap(hdcScreen, cxSmIcon, cySmIcon);
                ReleaseDC(NULL, hdcScreen);
            }

            if (hbmColour && hdc)
            {
                hbmMono = CreateBitmap(cxSmIcon, cySmIcon, 1, 1, NULL);
                if (hbmMono)
                {
                    hbmOld    = SelectObject(hdc, hbmColour);
                    rc.left   = 0;
                    rc.top    = 0;
                    rc.right  = cxSmIcon;
                    rc.bottom = cySmIcon;

                    rgbBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

                    ExtTextOut( hdc,
                                rc.left,
                                rc.top,
                                ETO_OPAQUE,
                                &rc,
                                TEXT(""),
                                0,
                                NULL );
                    SelectObject(hdc, GetStockObject(DEFAULT_GUI_FONT));
                    hfontOld = SelectObject(hdc, hfont);
                    DrawText( hdc,
                              szData,
                              2,
                              &rc,
                              DT_CENTER | DT_VCENTER | DT_SINGLELINE );
#ifdef USE_MIRRORING
                    {
                        DWORD dwLayout;

                        GetProcessDefaultLayout(&dwLayout);
                        if (dwLayout & LAYOUT_RTL)
                        {
                            MirrorBitmapInDC(hdc, hbmColour);
                        }
                    }
#endif
                    SelectObject(hdc, hbmMono);
                    PatBlt(hdc, 0, 0, cxSmIcon, cySmIcon, BLACKNESS);
                    SelectObject(hdc, hbmOld);

                    ii.fIcon    = TRUE;
                    ii.xHotspot = 0;
                    ii.yHotspot = 0;
                    ii.hbmColor = hbmColour;
                    ii.hbmMask  = hbmMono;
                    hicon       = CreateIconIndirect(&ii);

                    DeleteObject(hbmMono);
                    SelectObject(hdc, hfontOld);
                }
                DeleteObject(hbmColour);
                DeleteDC(hdc);
            }
            DeleteObject(hfont);
        }
    }

    return (hicon);
}

/***************************************************************************\
* FUNCTION: CreateIconList
*
* PURPOSE:  Create the table that contains the relationship between an hkl
*           and an icon.
*
* RETURNS:  Index of the current hkl in the table.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
int
CreateIconList(
    PLAYOUTINFO pLayoutInfo,
    HKL hklCur,
    UINT uLangs)
{
    HKL *pLanguages;
    UINT uCount;
    int nCurIndex = -1;

    pLanguages = (HKL *)LocalAlloc(LPTR, uLangs * sizeof(HKL));
    if (!pLanguages)
    {
        return -1;
    }
    GetKeyboardLayoutList(uLangs, (HKL *)pLanguages);


    for (uCount = 0; uCount < uLangs; uCount++)
    {
        pLayoutInfo[uCount].dwHkl = pLanguages[uCount];
        if (pLanguages[uCount] == hklCur)
        {
            nCurIndex = uCount;
        }
        if ((HIWORD(pLanguages[uCount]) & 0xf000) == 0xe000)
        {
            WCHAR szIMEFile[32];   // assume long filename up to 32 byte

            if (!pfnImmGetImeFileName)
            {
                HMODULE hMod;
                hMod = GetModuleHandle(szImm32DLL);
                if (hMod)
                {
                    pfnImmGetImeFileName = (LPFNIMMGETIMEFILENAME) 
                                            GetProcAddress(
                                                hMod, 
                                                "ImmGetIMEFileNameW");
                }
            }
            if (pfnImmGetImeFileName &&
                (*pfnImmGetImeFileName) (pLanguages[uCount],
                                         szIMEFile,
                                         sizeof(szIMEFile) ))
            {
                HINSTANCE hInstShell32;
                PFNEXTRACTICONEXW pfnExtractIconExW;

                hInstShell32 = LoadLibrary (TEXT("shell32.dll"));

                if (hInstShell32)
                {
                    pfnExtractIconExW = (PFNEXTRACTICONEXW) GetProcAddress (hInstShell32,
                                        "ExtractIconExW");

                    if (pfnExtractIconExW)
                    {

                        //
                        //  First one of the file.
                        //
                        pfnExtractIconExW(
                                szIMEFile,
                                0,
                                NULL,
                                &pLayoutInfo[uCount].hIcon,
                                1);
                    }

                    FreeLibrary (hInstShell32);
                }
                continue;
            }
        }

        //
        // for non-ime layout
        //
        pLayoutInfo[uCount].hIcon = CreateLangIdIcon(LOWORD(pLanguages[uCount]));
        
    }

    LocalFree(pLanguages);

    return nCurIndex;
}

/***************************************************************************\
* FUNCTION: GetIconFromHkl
*
* PURPOSE:  Find the icon in our table that has a matching hkl
*           with the supplied hkl. Create the table if it does not
*           exist.
*
* RETURNS:  Icon of the macthing hkl.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created 
*
\***************************************************************************/
HICON
GetIconFromHkl(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs)
{
    UINT uCount;
    int nIndex = -1;

    if (pLayoutInfo[0].dwHkl == 0)
    {
        //
        //  Icon/hkl list no exsists yet.  Create it.
        //
        nIndex = CreateIconList(pLayoutInfo, hkl, uLangs);
    }
    else
    {
        //  
        //  Find the icon with a matching hkl
        //
        for (uCount = 0; uCount < uLangs; uCount++)
        {
            if (pLayoutInfo[uCount].dwHkl == hkl)
            {
                nIndex = uCount;
                break;
            }
        }
    }

    if (nIndex == -1)
    {
        return NULL;
    }
    

    return ( pLayoutInfo[nIndex].hIcon);
}

/***************************************************************************\
* FUNCTION: DisplayLanguageIcon
*
* PURPOSE:  Displays the icon of the currently selected hkl in the
*           dlg window.
*
* RETURNS:  TRUE - The icon is displayed.
*           FALSE - No icon displayed.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
BOOL
DisplayLanguageIcon(
    HWND hwnd,
    LAYOUT_USER LayoutUser,
    HKL  hkl)

{
    HICON hIconLayout;
    UINT uLangs;
    PLAYOUTINFO pLayout;
    
    uLangs = GetKeyboardLayoutList(0, NULL);
    if (uLangs < 2)
    {
        return FALSE;
    }

    pLayout = UserLayoutInfo[LayoutUser].pLayoutInfo;

    if (!pLayout)
    {
        pLayout = (PLAYOUTINFO)LocalAlloc(LPTR, uLangs * sizeof(LAYOUTINFO));

        if (!pLayout)
        {
            return FALSE;
        }

        UserLayoutInfo[LayoutUser].pLayoutInfo = pLayout;
    }
        

    hIconLayout = GetIconFromHkl(
                        pLayout, 
                        hkl,    
                        uLangs);

    if (!hIconLayout)
    {
        return FALSE;
    }

    SendMessage( 
        GetDlgItem(hwnd, IDD_KBLAYOUT_ICON),
        STM_SETICON,
        (WPARAM)hIconLayout,
        0 );

    UserLayoutInfo[LayoutUser].hklLast = hkl;

    SetTimer(hwnd, TIMER_MYLANGUAGECHECK, 500, NULL);
    return TRUE;
    
}

/***************************************************************************\
* FUNCTION: FreeLayoutInfo
*
* PURPOSE:  Delete the icon/hkl table and destroy all icons.
*
* RETURNS:  -
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
void
FreeLayoutInfo(
    LAYOUT_USER LayoutUser)
{
    UINT uLangs;
    UINT uCount;

    PLAYOUTINFO pLayoutInfo;

    pLayoutInfo = UserLayoutInfo[LayoutUser].pLayoutInfo;

    if (!pLayoutInfo)
    {
        return;
    }

    uLangs = GetKeyboardLayoutList(0, NULL);
    for (uCount = 0; uCount < uLangs; uCount++)
    {
        DestroyIcon (pLayoutInfo[uCount].hIcon);
    }

    LocalFree(pLayoutInfo);
    UserLayoutInfo[LayoutUser].pLayoutInfo = NULL;

    return;
}

/***************************************************************************\
* FUNCTION: LayoutCheckHandler
*
* PURPOSE:  Handle layout check.  Set appropriate icon if there is
*           a change in keyboard layout.
*
* RETURNS:  -
*
* HISTORY:
*
*   04-22-98  ShanXu      Created
*
\***************************************************************************/
void
LayoutCheckHandler(
    HWND hwnd,
    LAYOUT_USER LayoutUser)
{
    HKL hklCurrent;

    KillTimer(hwnd, TIMER_MYLANGUAGECHECK);

    hklCurrent = GetKeyboardLayout(0);

    if (hklCurrent != UserLayoutInfo[LayoutUser].hklLast)
    {
        DisplayLanguageIcon(
            hwnd,
            LayoutUser,
            hklCurrent);

    }else{
        SetTimer(hwnd, TIMER_MYLANGUAGECHECK, 500, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\envvar.h ===
/****************************** Module Header ******************************\
* Module Name: envvar.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis in envvar.c
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

//
// Prototypes
//

BOOL
AppendNTPathWithAutoexecPath(
    PVOID *pEnv,
    LPTSTR lpPathVariable,
    LPTSTR lpAutoexecPath
    );

BOOL
SetUserEnvironmentVariable(
    PVOID *pEnv,
    LPTSTR lpVariable,
    LPTSTR lpValue,
    BOOL bOverwrite
    );

DWORD
ExpandUserEnvironmentStrings(
    PVOID pEnv,
    LPTSTR lpSrc,
    LPTSTR lpDst,
    DWORD nSize
    );

BOOL
SetEnvironmentVariables(
    PGLOBALS pGlobals,
    LPTSTR pEnvVarSubkey,
    PVOID *pEnv
    );

BOOL
SetHomeDirectoryEnvVars(
    PVOID *pEnv,
    LPTSTR lpHomeDirectory,
    LPTSTR lpHomeDrive,
    LPTSTR lpHomeShare,
    LPTSTR lpHomePath,
    BOOL * pfDeepShare
    );

BOOL
ProcessAutoexec(
    PVOID *pEnv,
    LPTSTR lpPathVariable
    );

VOID
ChangeToHomeDirectory(
    PGLOBALS pGlobals,
    PVOID  *pEnv,
    LPTSTR lpHomeDir,
    LPTSTR lpHomeDrive,
    LPTSTR lpHomeShare,
    LPTSTR lpHomePath,
    LPWSTR pszOldPath,
    BOOL   DeepShare
    );

BOOL
OpenHKeyCurrentUser(
    PGLOBALS pGlobals
    );

VOID
CloseHKeyCurrentUser(
    PGLOBALS pGlobals
    );

BOOL
InitHKeyCurrentUserSupport(
    );

VOID
CleanupHKeyCurrentUserSupport(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\glue.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: glue.cpp
//
//  Copyright (c) 2000-2001, Microsoft Corporation
//
//  C File containing "glue" functions that the shell depot component of
//  msgina uses.
//
//  History:    2001-01-03  vtan        created
//              2001-01-11  vtan        added stub functions for imp library
//  --------------------------------------------------------------------------

extern "C"
{
    #include "msgina.h"
    #include "shtdnp.h"
}

//  --------------------------------------------------------------------------
//  ::_Gina_SasNotify
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              dwSASType       =   SAS type.
//
//  Returns:    <none>
//
//  Purpose:    Notifies winlogon of a generated SAS.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _Gina_SasNotify (void *pWlxContext, DWORD dwSASType)

{
    pWlxFuncs->WlxSasNotify(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx, dwSASType);
}

//  --------------------------------------------------------------------------
//  ::_Gina_SetTimeout
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              dwTimeout       =   Timeout value.
//
//  Returns:    BOOL
//
//  Purpose:    Sets the internal msgina timeout value for dialogs.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL        _Gina_SetTimeout (void *pWlxContext, DWORD dwTimeout)

{
    return(pWlxFuncs->WlxSetTimeout(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx, dwTimeout));
}

//  --------------------------------------------------------------------------
//  ::_Gina_DialogBoxParam
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              See the platform SDK under DialogBoxParam.
//
//  Returns:    See the platform SDK under DialogBoxParam.
//
//  Purpose:    Calls winlogon's implementation of DialogBoxParam.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    INT_PTR     _Gina_DialogBoxParam (void *pWlxContext, HINSTANCE hInstance, LPCWSTR pszTemplate, HWND hwndParent, DLGPROC pfnDlgProc, LPARAM lParam)

{
    return(pWlxFuncs->WlxDialogBoxParam(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx,
                                        hInstance,
                                        const_cast<LPWSTR>(pszTemplate),
                                        hwndParent,
                                        pfnDlgProc,
                                        lParam));
}

//  --------------------------------------------------------------------------
//  ::_Gina_MessageBox
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              See the platform SDK under MessageBox.
//
//  Returns:    See the platform SDK under MessageBox.
//
//  Purpose:    Calls winlogon's implementation of MessageBox.
//
//  History:    2001-03-02  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    INT_PTR     _Gina_MessageBox (void *pWlxContext, HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uiType)

{
    return(pWlxFuncs->WlxMessageBox(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx,
                                    hwnd,
                                    const_cast<LPWSTR>(pszText),
                                    const_cast<LPWSTR>(pszCaption),
                                    uiType));
}

//  --------------------------------------------------------------------------
//  ::_Gina_SwitchDesktopToUser
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//
//  Returns:    int
//
//  Purpose:    Calls winlogon's implementation for SwitchDesktopToUser.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int         _Gina_SwitchDesktopToUser (void *pWlxContext)

{
    return(pWlxFuncs->WlxSwitchDesktopToUser(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx));
}

//  --------------------------------------------------------------------------
//  ::_Gina_ShutdownDialog
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              hwndParent      =   Parent HWND for dialog.
//              dwExcludeItems  =   Items to exclude from dialog.
//
//  Returns:    INT_PTR
//
//  Purpose:    Displays the shutdown that is hosted from winlogon not
//              explorer.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    INT_PTR     _Gina_ShutdownDialog (void *pWlxContext, HWND hwndParent, DWORD dwExcludeItems)

{
    return(static_cast<DWORD>(WinlogonShutdownDialog(hwndParent, static_cast<PGLOBALS>(pWlxContext), dwExcludeItems)));
}

//  --------------------------------------------------------------------------
//  ::_Gina_GetUserToken
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the user token handle. This handle must not be closed.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HANDLE      _Gina_GetUserToken (void *pWlxContext)

{
    return(static_cast<PGLOBALS>(pWlxContext)->UserProcessData.UserToken);
}

//  --------------------------------------------------------------------------
//  ::_Gina_GetUsername
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns the user name. Read only string.
//
//  History:    2001-03-28  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    const WCHAR*    _Gina_GetUsername (void *pWlxContext)

{
    return(static_cast<PGLOBALS>(pWlxContext)->UserName);
}

//  --------------------------------------------------------------------------
//  ::_Gina_GetDomain
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns the domain. Read only string.
//
//  History:    2001-03-28  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    const WCHAR*    _Gina_GetDomain (void *pWlxContext)

{
    return(static_cast<PGLOBALS>(pWlxContext)->Domain);
}

//  --------------------------------------------------------------------------
//  ::_Gina_SetTextFields
//
//  Arguments:  hwndDialog      =   HWND of the dialog.
//              pwszUsername    =   Username to set.
//              pwszDomain      =   Domain to set.
//              pwszPassword    =   Password to set.
//
//  Returns:    <none>
//
//  Purpose:    Sets the values of the msgina logon dialog to the given
//              values. This allows pass thru of credentials from the UI host
//              to msgina to do the work.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _Gina_SetTextFields (HWND hwndDialog, const WCHAR *pwszUsername, const WCHAR *pwszDomain, const WCHAR *pwszPassword)

{
    WCHAR   szDomain[DNLEN + sizeof('\0')];

    SetDlgItemText(hwndDialog, IDD_LOGON_NAME, pwszUsername);
    if ((pwszDomain == NULL) || (pwszDomain[0] == L'\0'))
    {
        DWORD   dwComputerNameSize;
        TCHAR   szComputerName[CNLEN + sizeof('\0')];

        dwComputerNameSize = ARRAYSIZE(szComputerName);
        if (GetComputerName(szComputerName, &dwComputerNameSize) != FALSE)
        {
            lstrcpyn(szDomain, szComputerName, ARRAYSIZE(szDomain));
        }
        pwszDomain = szDomain;
    }
    (LRESULT)SendMessage(GetDlgItem(hwndDialog, IDD_LOGON_DOMAIN),
                         CB_SELECTSTRING,
                         static_cast<WPARAM>(-1),
                         reinterpret_cast<LPARAM>(pwszDomain));
    SetDlgItemText(hwndDialog, IDD_LOGON_PASSWORD, pwszPassword);
}

//  --------------------------------------------------------------------------
//  ::_Gina_SetPasswordFocus
//
//  Arguments:  hwndDialog  =   HWND of dialog to set password focus.
//
//  Returns:    BOOL
//
//  Purpose:    Sets the focus to the password field in the dialog.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL        _Gina_SetPasswordFocus (HWND hwndDialog)

{
    return(SetPasswordFocus(hwndDialog));
}

//  --------------------------------------------------------------------------
//  ::ShellGetUserList
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    LONG    WINAPI  ShellGetUserList (BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList)

{
    return(_ShellGetUserList(fRemoveGuest, pdwUserCount, pUserList));
}

//  --------------------------------------------------------------------------
//  ::ShellIsSingleUserNoPassword
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain)

{
    return(_ShellIsSingleUserNoPassword(pwszUsername, pwszDomain));
}

//  --------------------------------------------------------------------------
//  ::ShellIsFriendlyUIActive
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsFriendlyUIActive (void)

{
    return(_ShellIsFriendlyUIActive());
}

//  --------------------------------------------------------------------------
//  ::ShellIsMultipleUsersEnabled
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsMultipleUsersEnabled (void)

{
    return(_ShellIsMultipleUsersEnabled());
}

//  --------------------------------------------------------------------------
//  ::ShellIsRemoteConnectionsEnabled
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsRemoteConnectionsEnabled (void)

{
    return(_ShellIsRemoteConnectionsEnabled());
}

//  --------------------------------------------------------------------------
//  ::ShellEnableFriendlyUI
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellEnableFriendlyUI (BOOL fEnable)

{
    return(_ShellEnableFriendlyUI(fEnable));
}

//  --------------------------------------------------------------------------
//  ::ShellEnableMultipleUsers
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellEnableMultipleUsers (BOOL fEnable)

{
    return(_ShellEnableMultipleUsers(fEnable));
}

//  --------------------------------------------------------------------------
//  ::ShellEnableRemoteConnections
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellEnableRemoteConnections (BOOL fEnable)

{
    return(_ShellEnableRemoteConnections(fEnable));
}

//  --------------------------------------------------------------------------
//  ::ShellTurnOffDialog
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ShellTurnOffDialog (HWND hwndParent)

{
    return(_ShellTurnOffDialog(hwndParent));
}

//  --------------------------------------------------------------------------
//  ::ShellACPIPowerButtonPressed
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int     WINAPI  ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked)

{
    return(_ShellACPIPowerButtonPressed(pWlxContext, uiEventType, fLocked));
}

//  --------------------------------------------------------------------------
//  ::ShellIsSuspendAllowed
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsSuspendAllowed (void)

{
    return(_ShellIsSuspendAllowed());
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostBegin
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostBegin (UINT uiStartType)

{
    _ShellStatusHostBegin(uiStartType);
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostEnd
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostEnd (UINT uiEndType)

{
    _ShellStatusHostEnd(uiEndType);
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostShuttingDown
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostShuttingDown (void)

{
    _ShellStatusHostShuttingDown();
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostPowerEvent
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostPowerEvent (void)

{
    _ShellStatusHostPowerEvent();
}

//  --------------------------------------------------------------------------
//  ::ShellSwitchWhenInteractiveReady
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext)

{
    return(_ShellSwitchWhenInteractiveReady(eSwitchType, pWlxContext));
}

//  --------------------------------------------------------------------------
//  ::ShellDimScreen
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed)

{
    return(_ShellDimScreen(ppIUnknown, phwndDimmed));
}

//  --------------------------------------------------------------------------
//  ::ShellInstallAccountFilterData
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellInstallAccountFilterData (void)

{
    _ShellInstallAccountFilterData();
}

//  --------------------------------------------------------------------------
//  ::ShellSwitchUser
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ShellSwitchUser (BOOL fWait)

{
    return(_ShellSwitchUser(fWait));
}

//  --------------------------------------------------------------------------
//  ::ShellIsUserInteractiveLogonAllowed
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int     WINAPI  ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername)

{
    return(_ShellIsUserInteractiveLogonAllowed(pwszUsername));
}

//  --------------------------------------------------------------------------
//  ::ShellNotifyThemeUserChange
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken)

{
    _ShellNotifyThemeUserChange(eUserLogType, hToken);
}

//  --------------------------------------------------------------------------
//  ::ShellReturnToWelcome
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ShellReturnToWelcome (BOOL fUnlock)

{
    return(_ShellReturnToWelcome(fUnlock));
}

//  --------------------------------------------------------------------------
//  ::ShellStartCredentialServer
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout)

{
    return(_ShellStartCredentialServer(pwszUsername, pwszDomain, pwszPassword, dwTimeout));
}

//  --------------------------------------------------------------------------
//  ::ShellAcquireLogonMutex
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellAcquireLogonMutex (void)

{
    _ShellAcquireLogonMutex();
}

//  --------------------------------------------------------------------------
//  ::ShellReleaseLogonMutex
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellReleaseLogonMutex (BOOL fSignalEvent)

{
    _ShellReleaseLogonMutex(fSignalEvent);
}

//  --------------------------------------------------------------------------
//  ::ShellSignalShutdown
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellSignalShutdown (void)

{
    _ShellSignalShutdown();
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostHide
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-12  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostHide (void)

{
    _ShellStatusHostHide();
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostShow
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-12  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostShow (void)

{
    _ShellStatusHostShow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\envvar.c ===
/****************************** Module Header ******************************\
* Module Name: envvar.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Sets environment variables.
*
* History:
* 2-25-92 JohanneC       Created -
*
\***************************************************************************/

#include "msgina.h"
#ifdef _X86_
#include "i386\oemhard.h"
#endif
#pragma hdrstop

BOOL ProcessCommand(LPTSTR lpStart, PVOID *pEnv);
BOOL ProcessSetCommand(LPTSTR lpStart, PVOID *pEnv);
LPTSTR ProcessAutoexecPath(PVOID *pEnv, LPTSTR lpValue, DWORD cb);
LONG  AddNetworkConnection(PGLOBALS pGlobals, LPNETRESOURCE lpNetResource);
BOOL UpdateUserEnvironmentVars(  PVOID *pEnv  );
#ifdef _X86_
BOOL IsPathIncludeRemovable(LPTSTR lpValue);
#endif
BOOL GetLUIDDeviceMapsEnabled( VOID );

#define KEY_NAME TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment")

//
// Max environment variable length
//

#define MAX_VALUE_LEN          1024

#define BSLASH  TEXT('\\')
#define COLON   TEXT(':')
    
//
// These two globals implement ref counting on
// pGlobals->UserProcessData->hCurrentUser (418628)
// managed by OpenHKeyCurrentUser/CloseHKeyCurrentUser below
//
RTL_CRITICAL_SECTION    g_csHKCU;
ULONG                   g_ulHKCURef;

BOOL
InitHKeyCurrentUserSupport(
    )
{
    NTSTATUS Status ;

    Status = RtlInitializeCriticalSection( &g_csHKCU );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog((DEB_ERROR, "InitHKeyCurrentUserSupport failed to init its lock, error = 0x%08X\n", Status));
        return FALSE;
    }

    g_ulHKCURef = 0;

    return TRUE;
}

VOID
CleanupHKeyCurrentUserSupport(
    )
{
    RtlDeleteCriticalSection( &g_csHKCU );
}

/***************************************************************************\
* OpenHKeyCurrentUser
*
* Opens HKeyCurrentUser to point at the current logged on user's profile.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 06-16-92  Davidc  Created
*
\***************************************************************************/
BOOL
OpenHKeyCurrentUser(
    PGLOBALS pGlobals
    )
{
    HANDLE ImpersonationHandle;
    BOOL Result;
    NTSTATUS Status ;


    //
    // Get in the correct context before we reference the registry
    //

    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);
    if (ImpersonationHandle == NULL) {
        DebugLog((DEB_ERROR, "OpenHKeyCurrentUser failed to impersonate user"));
        return(FALSE);
    }

    RtlEnterCriticalSection( &g_csHKCU );

    if (g_ulHKCURef == 0)
    {
        Status = RtlOpenCurrentUser(
                    MAXIMUM_ALLOWED,
                    &pGlobals->UserProcessData.hCurrentUser );
    }

    g_ulHKCURef++;

    RtlLeaveCriticalSection( &g_csHKCU );

    //
    // Return to our own context
    //

    Result = StopImpersonating(ImpersonationHandle);
    ASSERT(Result);


    return(TRUE);
}



/***************************************************************************\
* CloseHKeyCurrentUser
*
* Closes HKEY_CURRENT_USER.
* Any registry reference will automatically re-open it, so this is
* only a token gesture - but it allows the registry hive to be unloaded.
*
* Returns nothing
*
* History:
* 06-16-92  Davidc  Created
*
\***************************************************************************/
VOID
CloseHKeyCurrentUser(
    PGLOBALS pGlobals
    )
{
    RtlEnterCriticalSection( &g_csHKCU );

    if (g_ulHKCURef > 0)
    {
        if (--g_ulHKCURef == 0)
        {
            NtClose( pGlobals->UserProcessData.hCurrentUser );
            pGlobals->UserProcessData.hCurrentUser = NULL ;
        }
    }

    RtlLeaveCriticalSection( &g_csHKCU );
}



/***************************************************************************\
* SetUserEnvironmentVariable
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
SetUserEnvironmentVariable(
    PVOID *pEnv,
    LPTSTR lpVariable,
    LPTSTR lpValue,
    BOOL bOverwrite
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    DWORD cb;
    TCHAR szValue[1024];


    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpVariable);
    cb = 1024;
    Value.Buffer = Alloc(sizeof(TCHAR)*cb);
    if (Value.Buffer) {
        Value.Length = (USHORT)cb;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);

        Free(Value.Buffer);

        if ( NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }
    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!lstrcmpi(lpVariable, TEXT("TEMP"))) ||
            (!lstrcmpi(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, 1024)) {
                 lstrcpyn (szValue, lpValue, 1024);
             }
        } else {
            lstrcpyn (szValue, lpValue, 1024);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable(pEnv, &Name, NULL);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}


/***************************************************************************\
* ExpandUserEnvironmentStrings
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
DWORD
ExpandUserEnvironmentStrings(
    PVOID pEnv,
    LPTSTR lpSrc,
    LPTSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;

    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)nSize;
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( pEnv,
                                          (PUNICODE_STRING)&Source,
                                          (PUNICODE_STRING)&Destination,
                                          &Length
                                        );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length );
        }
    else {
        return( 0 );
        }
}


/***************************************************************************\
* BuildEnvironmentPath
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL BuildEnvironmentPath(PVOID *pEnv,
                          LPTSTR lpPathVariable,
                          LPTSTR lpPathValue)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    TCHAR lpTemp[1025];
    DWORD cb;


    if (!*pEnv) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpPathVariable);
    cb = 1024;
    Value.Buffer = Alloc(sizeof(TCHAR)*cb);
    if (!Value.Buffer) {
        return(FALSE);
    }
    Value.Length = (USHORT)(sizeof(TCHAR) * cb);
    Value.MaximumLength = (USHORT)(sizeof(TCHAR) * cb);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        Free(Value.Buffer);
        Value.Length = 0;
        *lpTemp = 0;
    }
    if (Value.Length) {
        lstrcpy(lpTemp, Value.Buffer);
        if ( *( lpTemp + lstrlen(lpTemp) - 1) != TEXT(';') ) {
            lstrcat(lpTemp, TEXT(";"));
        }
        Free(Value.Buffer);
    }
    if (lpPathValue && ((lstrlen(lpTemp) + lstrlen(lpPathValue) + 1) < (INT)cb)) {
        lstrcat(lpTemp, lpPathValue);

        RtlInitUnicodeString(&Value, lpTemp);

        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}


/***************************************************************************\
* SetEnvironmentVariables
*
* Reads the user-defined environment variables from the user registry
* and adds them to the environment block at pEnv.
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
SetEnvironmentVariables(
    PGLOBALS pGlobals,
    LPTSTR pEnvVarSubkey,
    PVOID *pEnv
    )
{
    TCHAR lpValueName[MAX_PATH];
    PWCH  lpDataBuffer;
    DWORD cbDataBuffer;
    PWCH  lpData;
    LPTSTR lpExpandedValue = NULL;
    DWORD cbValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;


    /*
     * Open registry key to access USER environment variables.
     */
    if (!OpenHKeyCurrentUser(pGlobals)) {
        DebugLog((DEB_ERROR, "SetEnvironmentVariables: Failed to open HKeyCurrentUser"));
        return(FALSE);
    }

    if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser, pEnvVarSubkey, 0, KEY_READ, &hkey)) {
        CloseHKeyCurrentUser(pGlobals);
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = Alloc(sizeof(TCHAR)*cbDataBuffer);
    if (lpDataBuffer == NULL) {
        DebugLog((DEB_ERROR, "SetEnvironmentVariables: Failed to allocate %d bytes", cbDataBuffer));
        CloseHKeyCurrentUser(pGlobals);
        RegCloseKey(hkey);
        return(FALSE);
    }
    lpData = lpDataBuffer;
    cbData = sizeof(TCHAR)*cbDataBuffer;
    bResult = TRUE;
    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         (LPBYTE)lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_SZ) {

                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, lpData);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //
                    SetUserEnvironmentVariable(pEnv, lpValueName, lpData, TRUE);
                }
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = cbDataBuffer;
    cbValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         (LPBYTE)lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) {
                DWORD cb, cbNeeded;

                cb = 1024;
                lpExpandedValue = Alloc(sizeof(TCHAR)*cb);
                if (lpExpandedValue) {
                    cbNeeded = ExpandUserEnvironmentStrings(*pEnv, lpData, lpExpandedValue, cb);
                    if (cbNeeded > cb) {
                        Free(lpExpandedValue);
                        cb = cbNeeded;
                        lpExpandedValue = Alloc(sizeof(TCHAR)*cb);
                        if (lpExpandedValue) {
                            ExpandUserEnvironmentStrings(*pEnv, lpData, lpExpandedValue, cb);
                        }
                    }
                }

                if (lpExpandedValue == NULL) {
                    bResult = FALSE;
                    break;
                }


                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, lpExpandedValue);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //
                    SetUserEnvironmentVariable(pEnv, lpValueName, lpExpandedValue, TRUE);
                }

                Free(lpExpandedValue);
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }


    Free(lpDataBuffer);
    RegCloseKey(hkey);
    CloseHKeyCurrentUser(pGlobals);

    return(bResult);
}

/***************************************************************************\
* IsUNCPath
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL IsUNCPath(LPTSTR lpPath)
{
    if (lpPath[0] == BSLASH && lpPath[1] == BSLASH) {
        return(TRUE);
    }
    return(FALSE);
}

/***************************************************************************\
* SetHomeDirectoryEnvVars
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
SetHomeDirectoryEnvVars(
    PVOID *pEnv,
    LPTSTR lpHomeDirectory,
    LPTSTR lpHomeDrive,
    LPTSTR lpHomeShare,
    LPTSTR lpHomePath,
    BOOL * pfDeepShare
    )
{
    TCHAR cTmp;
    LPTSTR lpHomeTmp;
    BOOL bFoundFirstBSlash = FALSE;

    if (!*lpHomeDirectory) {
        return(FALSE);
    }

    *pfDeepShare = FALSE;

    if (IsUNCPath(lpHomeDirectory)) {
        lpHomeTmp = lpHomeDirectory + 2;
        while (*lpHomeTmp) {
            if (*lpHomeTmp == BSLASH) {
                if (bFoundFirstBSlash) {
                    break;
                }
                bFoundFirstBSlash = TRUE;
            }
            lpHomeTmp++;
        }
        if (*lpHomeTmp) {
            lstrcpy(lpHomePath, lpHomeTmp);
            *pfDeepShare = TRUE;
        }
        else {
            *lpHomePath = BSLASH;
            *(lpHomePath+1) = 0;

        }

        cTmp = *lpHomeTmp;
        *lpHomeTmp = (TCHAR)0;
        lstrcpy(lpHomeShare, lpHomeDirectory);
        *lpHomeTmp = cTmp;

        //
        // If no home drive specified, than default to z:
        //
        if (!*lpHomeDrive) {
            lstrcpy(lpHomeDrive, TEXT("Z:"));
        }

    }
    else {  // local home directory

        *lpHomeShare = 0;   // no home share

        cTmp = lpHomeDirectory[2];
        lpHomeDirectory[2] = (TCHAR)0;
        lstrcpy(lpHomeDrive, lpHomeDirectory);
        lpHomeDirectory[2] = cTmp;

        lstrcpy(lpHomePath, lpHomeDirectory + 2);
    }

    SetUserEnvironmentVariable(pEnv, HOMEDRIVE_VARIABLE, lpHomeDrive, TRUE);
    SetUserEnvironmentVariable(pEnv, HOMESHARE_VARIABLE, lpHomeShare, TRUE);
    SetUserEnvironmentVariable(pEnv, HOMEPATH_VARIABLE, lpHomePath, TRUE);

    return TRUE;
}

/***************************************************************************\
* UpdateHomeVarsInVolatileEnv
*
* Sets the HOMEDRIVE, HOMEPATH and HOMESHARE variables in the user's home
* volatile environment so that SHGetFolderPath is able to expand these
* variables
*
* History:
* 6-5-2000	RahulTh		Created 
*
\***************************************************************************/
VOID
UpdateHomeVarsInVolatileEnv (
	PGLOBALS	pGlobals,
	LPTSTR		lpHomeDrive,
    LPTSTR		lpHomeShare,
    LPTSTR		lpHomePath
	)
{
	BOOL	bOpenedHKCU;
	HANDLE	ImpersonationHandle = NULL;
	HKEY	hUserVolatileEnv = NULL;
	LONG	lResult;
	
	bOpenedHKCU = OpenHKeyCurrentUser (pGlobals);
	
	ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

	if (ImpersonationHandle != NULL) {

		//
		// See the registry value to see whether we should really try to map
		// the whole directory or just map to the root..
		//

		if ((pGlobals->UserProcessData).hCurrentUser) {

			lResult = RegOpenKeyEx((pGlobals->UserProcessData).hCurrentUser, L"Volatile Environment", 0, KEY_READ | KEY_WRITE, &hUserVolatileEnv);

			if (lResult == ERROR_SUCCESS) {

				RegSetValueEx (hUserVolatileEnv,
							   HOMEDRIVE_VARIABLE,
							   0,
							   REG_SZ,
							   (LPBYTE) lpHomeDrive,
							   (lstrlen (lpHomeDrive) + 1) * sizeof (TCHAR));

				RegSetValueEx (hUserVolatileEnv,
							   HOMESHARE_VARIABLE,
							   0,
							   REG_SZ,
							   (LPBYTE) lpHomeShare,
							   (lstrlen (lpHomeShare) + 1) * sizeof (TCHAR));
			   
				RegSetValueEx (hUserVolatileEnv,
							   HOMEPATH_VARIABLE,
							   0,
							   REG_SZ,
							   (LPBYTE) lpHomePath,
							   (lstrlen (lpHomePath) + 1) * sizeof (TCHAR));
				
				RegCloseKey(hUserVolatileEnv);
			}
		}

		//
		// Revert to being 'ourself'
		//

		if (!StopImpersonating(ImpersonationHandle)) {
			DebugLog((DEB_ERROR, "UpdateHomeVarsInVolatileEnv : Failed to revert to self"));
		}

		//
		// Set it to NULL
		//

		ImpersonationHandle = NULL;
	}
	else {
		DebugLog((DEB_ERROR, "UpdateHomeVarsInVolatileEnv : Failed to impersonate user"));
	}

	if (bOpenedHKCU)
		CloseHKeyCurrentUser (pGlobals);
}


/***************************************************************************\
* ChangeToHomeDirectory
*
* Sets the current directory to the user's home directory. If this fails
* tries to set to the directory in the following order:
*    1. home directory
*    2. c:\users\default
*    3. c:\users
*    4. \ (root)
*    5. leaves directory as is i.e. the present current directory
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
VOID
ChangeToHomeDirectory(
    PGLOBALS pGlobals,
    PVOID  *pEnv,
    LPTSTR lpHomeDir,
    LPTSTR lpHomeDrive,
    LPTSTR lpHomeShare,
    LPTSTR lpHomePath,
    LPTSTR lpOldDir,
    BOOL   DeepShare
    )
{
    TCHAR lpCurDrive[4]; 
    BOOL bNoHomeDir = FALSE;
    BOOL bTSHomeDir = FALSE;
    HANDLE ImpersonationHandle = NULL;
    DWORD error = ERROR_SUCCESS, dwSize, dwType;
    HKEY hUserPolicy=NULL;
    DWORD dwConnectHomeDirToRoot;
    LONG lResult;

    if (GetCurrentDirectory(MAX_PATH, lpOldDir)) {
        lpCurDrive[0] = lpOldDir[0];
        lpCurDrive[1] = lpOldDir[1];
        lpCurDrive[2] = (TCHAR)0;
    }
    else
        lpCurDrive[0] = (TCHAR)0;

    if (!*lpHomeDir) {
        bNoHomeDir = TRUE;

DefaultDirectory:
        if (!bNoHomeDir) {
#if 0
            ReportWinlogonEvent(pGlobals,
                    EVENTLOG_ERROR_TYPE,
                    EVENT_SET_HOME_DIRECTORY_FAILED,
                    sizeof(error),
                    &error,
                    1,
                    lpHomeDir);
#endif
        }
        lstrcpy(lpHomeDir, lpCurDrive);

        if (g_IsTerminalServer) {
            TCHAR szProfileDir[MAX_PATH];
            DWORD cbufSize = MAX_PATH;

            if ( GetUserProfileDirectory(pGlobals->UserProcessData.UserToken, szProfileDir, &cbufSize) &&
                  SetCurrentDirectory(szProfileDir) ) {

                    lstrcpy(lpHomeDir, szProfileDir);
                    bTSHomeDir = TRUE;

            } else {
                    error = GetLastError();
                    DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to GetUserProfileDirectory '%ws', error = %d\n",
                                 lpHomeDir, error));
                    lstrcpy(lpHomeDir, NULL_STRING);
            }
        }

        if (!bTSHomeDir) {
#if 0
            if (SetCurrentDirectory(USERS_DEFAULT_DIRECTORY)) {
                lstrcat(lpHomeDir, USERS_DEFAULT_DIRECTORY);
            }
            else if (SetCurrentDirectory(USERS_DIRECTORY)) {
                lstrcat(lpHomeDir, USERS_DIRECTORY);
            }
            else
#endif
            if (SetCurrentDirectory(ROOT_DIRECTORY)) {
                lstrcat(lpHomeDir, ROOT_DIRECTORY);
            }
            else {
                lstrcpy(lpHomeDir, NULL_STRING);
            }

        }

        if (bNoHomeDir || bTSHomeDir) {
            // Update the homedrive variable to reflect the correct value
            lstrcpy (lpHomeDrive, lpCurDrive);
            SetUserEnvironmentVariable(pEnv, HOMEDRIVE_VARIABLE, lpCurDrive, TRUE);
            *lpHomeShare = 0; //  null string
            SetUserEnvironmentVariable(pEnv, HOMESHARE_VARIABLE, lpHomeShare, TRUE);
            if (*lpHomeDir) {
                lpHomeDir += 2;
            }
            // Update the homepath variable to reflect the correct value
            lstrcpy (lpHomePath, lpHomeDir);
            SetUserEnvironmentVariable(pEnv, HOMEPATH_VARIABLE, lpHomeDir, TRUE);
        }
		
	goto UpdateHomeVars;
    }
    /*
     * Test if homedir is a local directory.'?:\foo\bar'
     */
    if (IsUNCPath(lpHomeDir)) {
        NETRESOURCE NetResource;
        BOOL bOpenedHKCU;
        /*
         * lpHomeDir is a UNC path, use lpHomedrive.
         */

        //
        // First, try the (possibly) deep path:
        //

        ZeroMemory( &NetResource, sizeof( NetResource ) );

        NetResource.lpLocalName = lpHomeDrive;
        NetResource.lpRemoteName = lpHomeDir;
        NetResource.lpProvider = NULL;
        NetResource.dwType = RESOURCETYPE_DISK;


        dwConnectHomeDirToRoot = 0; // default

        bOpenedHKCU = OpenHKeyCurrentUser(pGlobals);

        //
        // Impersonate the user
        //

        ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

        if (ImpersonationHandle != NULL) {

            //
            // See the registry value to see whether we should really try to map
            // the whole directory or just map to the root..
            //

            if ((pGlobals->UserProcessData).hCurrentUser) {

                lResult = RegOpenKeyEx((pGlobals->UserProcessData).hCurrentUser, WINLOGON_POLICY_KEY, 0, KEY_READ, &hUserPolicy);

                if (lResult == ERROR_SUCCESS) {
                    dwSize = sizeof(DWORD);

                    RegQueryValueEx (hUserPolicy,
                                 TEXT("ConnectHomeDirToRoot"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwConnectHomeDirToRoot,
                                 &dwSize);

                   RegCloseKey(hUserPolicy);
                }
            }

            //
            // Revert to being 'ourself'
            //

            if (!StopImpersonating(ImpersonationHandle)) {
                DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to revert to self"));
            }

            //
            // Set it to NULL
            //

            ImpersonationHandle = NULL;
        }
        else {
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to impersonate user"));
        }

        if (bOpenedHKCU)
            CloseHKeyCurrentUser(pGlobals);


        if (!dwConnectHomeDirToRoot) {

            error = AddNetworkConnection( pGlobals, &NetResource );

            if (error == ERROR_SUCCESS) {

                //
                // (possibly) deep path worked!
                //

                if ( DeepShare )
                {
                    //
                    // Set homepath to just "\"
                    //
                    lstrcpy( lpHomePath, TEXT("\\") );

                    // Also update the value of homeshare to reflect the correct value
                    lstrcpy (lpHomeShare, lpHomeDir);

                    SetUserEnvironmentVariable(pEnv, HOMESHARE_VARIABLE, lpHomeShare, TRUE);
                    SetUserEnvironmentVariable(pEnv, HOMEPATH_VARIABLE, lpHomePath, TRUE);
                }
            }
            else {
                dwConnectHomeDirToRoot = TRUE;
            }
        }


        if (dwConnectHomeDirToRoot)  {


            NetResource.lpLocalName = lpHomeDrive;
            NetResource.lpRemoteName = lpHomeShare;
            NetResource.lpProvider = NULL;
            NetResource.dwType = RESOURCETYPE_DISK;

            error = AddNetworkConnection( pGlobals, &NetResource );

            if ( error )
            {
                goto DefaultDirectory;
            }
        }

        lstrcpy(lpHomeDir, lpHomeDrive);

        if ( lpHomePath &&
            (*lpHomePath != TEXT('\\')))
        {
            lstrcat(lpHomeDir, TEXT("\\"));
        }

        lstrcat(lpHomeDir, lpHomePath);

        //
        // Impersonate the user
        //

        ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

        if (ImpersonationHandle == NULL) {
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to impersonate user"));
        }

        if (!SetCurrentDirectory(lpHomeDir)) {
            error = GetLastError();
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to SetCurrentDirectory '%ws', error = %d\n",
                             lpHomeDir, error));
            //
            // Revert to being 'ourself'
            //

            if (ImpersonationHandle && !StopImpersonating(ImpersonationHandle)) {
                DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to revert to self"));
            }

            goto DefaultDirectory;
        }
    }
    else {
        /*
         * lpHomeDir is a local path or absolute local path.
         */

        //
        // Impersonate the user
        //

        ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

        if (ImpersonationHandle == NULL) {
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to impersonate user"));
        }

        if (!SetCurrentDirectory(lpHomeDir)) {
            error = GetLastError();
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to SetCurrentDirectory '%ws', error = %d",
                             lpHomeDir, error));
            //
            // Revert to being 'ourself'
            //

            if (ImpersonationHandle && !StopImpersonating(ImpersonationHandle)) {
                DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to revert to self"));
            }

            goto DefaultDirectory;
        }
    }

    //
    // Revert to being 'ourself'
    //

    if (ImpersonationHandle && !StopImpersonating(ImpersonationHandle)) {
        DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to revert to self"));
    }
	
	
UpdateHomeVars:
	//
	// Update the value of the home variables in the volatile environment
	// so that SHGetFolderPath expands these variables correctly
	//

    UpdateHomeVarsInVolatileEnv (pGlobals, lpHomeDrive, lpHomeShare, lpHomePath);

	return;
}

/***************************************************************************\
* ProcessAutoexec
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL
ProcessAutoexec(
    PVOID *pEnv,
    LPTSTR lpPathVariable
    )
{
    HANDLE fh;
    DWORD dwFileSize;
    DWORD dwBytesRead;
    CHAR *lpBuffer = NULL;
    CHAR *token;
    CHAR Seps[] = "&\n\r";   // Seperators for tokenizing autoexec.bat
    BOOL Status = FALSE;
    TCHAR szAutoExecBat [] = TEXT("c:\\autoexec.bat");
#ifdef _X86_
    TCHAR szTemp[3];
#endif
    UINT uiErrMode;


    uiErrMode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

#ifdef _X86_
    if (IsNEC_98) {
        if (GetEnvironmentVariable (TEXT("SystemDrive"), szTemp, 3)) {
            szAutoExecBat[0] = szTemp[0];
        }
    }
#endif

    fh = CreateFile (szAutoExecBat, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    SetErrorMode (uiErrMode);

    if (fh ==  INVALID_HANDLE_VALUE) {
        return(FALSE);  //could not open autoexec.bat file, we're done.
    }

    dwFileSize = GetFileSize(fh, NULL);
    if (dwFileSize == -1) {
        goto Exit;      // can't read the file size
    }

    lpBuffer = Alloc(dwFileSize+1);
    if (!lpBuffer) {
        goto Exit;
    }

    Status = ReadFile(fh, lpBuffer, dwFileSize, &dwBytesRead, NULL);
    if (!Status) {
        goto Exit;      // error reading file
    }

    //
    // Zero terminate the buffer so we don't walk off the end
    //

    ASSERT(dwBytesRead <= dwFileSize);
    lpBuffer[dwBytesRead] = 0;

    //
    // Search for SET and PATH commands
    //

    token = strtok(lpBuffer, Seps);
    while (token != NULL) {
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (*token == TEXT('@'))
            token++;
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (!_strnicmp(token, "PATH", 4)) {
            STRING String;
            UNICODE_STRING UniString;

            RtlInitString(&String, (LPSTR)token);
            RtlAnsiStringToUnicodeString(&UniString, &String, TRUE);

            ProcessCommand(UniString.Buffer, pEnv);
            //ProcessCommand(token, pEnv);

            RtlFreeUnicodeString(&UniString);
        }
        if (!_strnicmp(token, "SET", 3)) {
            STRING String;
            UNICODE_STRING UniString;

            RtlInitString(&String, (LPSTR)token);
            RtlAnsiStringToUnicodeString(&UniString, &String, TRUE);

            ProcessSetCommand(UniString.Buffer, pEnv);
            //ProcessSetCommand(token, pEnv);

            RtlFreeUnicodeString(&UniString);
        }
        token = strtok(NULL, Seps);
    }
Exit:
    CloseHandle(fh);
    if (lpBuffer) {
        Free(lpBuffer);
    }
    if (!Status) {
        DebugLog((DEB_ERROR, "Cannot process autoexec.bat."));
    }
    return(Status);
}

/***************************************************************************\
* ProcessCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessCommand(LPTSTR lpStart, PVOID *pEnv)
{
    LPTSTR lpt, lptt;
    LPTSTR lpVariable;
    LPTSTR lpValue;
    LPTSTR lpExpandedValue = NULL;
    TCHAR c;
    DWORD cb, cbNeeded;

    //
    // Find environment variable.
    //
    for (lpt = lpStart; *lpt && *lpt == TEXT(' '); lpt++) //skip spaces
        ;

    if (!*lpt)
       return(FALSE);

    lptt = lpt;
    for (; *lpt && *lpt != TEXT(' ') && *lpt != TEXT('='); lpt++) //find end of variable name
        ;

    c = *lpt;
    *lpt = 0;
    lpVariable = Alloc(sizeof(TCHAR)*(lstrlen(lptt) + 1));
    if (!lpVariable)
        return(FALSE);
    lstrcpy(lpVariable, lptt);
    *lpt = c;

    //
    // Find environment variable value.
    //
    for (; *lpt && (*lpt == TEXT(' ') || *lpt == TEXT('=')); lpt++)
        ;

    if (!*lpt) {
       // if we have a blank path statement in the autoexec file,
       // then we don't want to pass "PATH" as the environment
       // variable because it trashes the system's PATH.  Instead
       // we want to change the variable AutoexecPath.  This would have
       // be handled below if a value had been assigned to the
       // environment variable.
       if (lstrcmpi(lpVariable, PATH_VARIABLE) == 0)
          {
          SetUserEnvironmentVariable(pEnv, AUTOEXECPATH_VARIABLE, TEXT(""), TRUE);
          }
       else
          {
          SetUserEnvironmentVariable(pEnv, lpVariable, TEXT(""), TRUE);
          }
       Free(lpVariable);
       return(FALSE);
    }

    lptt = lpt;
    for (; *lpt; lpt++)  //find end of varaible value
        ;

    c = *lpt;
    *lpt = 0;
    lpValue = Alloc(sizeof(TCHAR)*(lstrlen(lptt) + 1));
    if (!lpValue) {
        Free(lpVariable);
        return(FALSE);
    }

    lstrcpy(lpValue, lptt);
    *lpt = c;

#ifdef _X86_
    // NEC98
    //
    // If the path includes removable drive,
    //  it is assumed that the drive assignment has changed from DOS.
    //
    if (IsNEC_98 && (lstrcmpi(lpVariable, PATH_VARIABLE) == 0) && IsPathIncludeRemovable(lpValue)) {
        LocalFree(lpVariable);
        LocalFree(lpValue);
        return(FALSE);
    }
#endif

    cb = 1024;
    lpExpandedValue = Alloc(sizeof(TCHAR)*cb);
    if (lpExpandedValue) {
        if (!lstrcmpi(lpVariable, PATH_VARIABLE)) {
            lpValue = ProcessAutoexecPath(pEnv, lpValue, lstrlen(lpValue)+1);
        }
        cbNeeded = ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cb);
        if (cbNeeded > cb) {
            Free(lpExpandedValue);
            cb = cbNeeded;
            lpExpandedValue = Alloc(sizeof(TCHAR)*cb);
            if (lpExpandedValue) {
                ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cb);
            }
        }
    }

    if (!lpExpandedValue) {
        lpExpandedValue = lpValue;
    }
    if (lstrcmpi(lpVariable, PATH_VARIABLE)) {
        SetUserEnvironmentVariable(pEnv, lpVariable, lpExpandedValue, FALSE);
    }
    else {
        SetUserEnvironmentVariable(pEnv, AUTOEXECPATH_VARIABLE, lpExpandedValue, TRUE);

    }

    if (lpExpandedValue != lpValue) {
        Free(lpExpandedValue);
    }
    Free(lpVariable);
    Free(lpValue);

    return(TRUE);
}

/***************************************************************************\
* ProcessSetCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessSetCommand(LPTSTR lpStart, PVOID *pEnv)
{
    LPTSTR lpt;

    //
    // Find environment variable.
    //
    for (lpt = lpStart; *lpt && *lpt != TEXT(' '); lpt++)
        ;

    if (!*lpt || !_wcsnicmp(lpt,TEXT("COMSPEC"), 7))
       return(FALSE);

    return (ProcessCommand(lpt, pEnv));

}

/***************************************************************************\
* ProcessAutoexecPath
*
* Creates AutoexecPath environment variable using autoexec.bat
* LpValue may be freed by this routine.
*
* History:
* 06-02-92  Johannec     Created.
*
\***************************************************************************/
LPTSTR ProcessAutoexecPath(PVOID *pEnv, LPTSTR lpValue, DWORD cb)
{
    LPTSTR lpt;
    LPTSTR lpStart;
    LPTSTR lpPath;
    DWORD cbt;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    BOOL bPrevAutoexecPath;
    WCHAR ch;
    DWORD dwTemp, dwCount = 0;

    cbt = 1024;
    lpt = Alloc(sizeof(TCHAR)*cbt);
    if (!lpt) {
        return(lpValue);
    }
    *lpt = 0;
    lpStart = lpValue;

    RtlInitUnicodeString(&Name, AUTOEXECPATH_VARIABLE);
    Value.Buffer = Alloc(sizeof(TCHAR)*cbt);
    if (!Value.Buffer) {
        goto Fail;
    }

    while (lpPath = wcsstr (lpValue, TEXT("%"))) {
        if (!_wcsnicmp(lpPath+1, TEXT("PATH%"), 5)) {
            //
            // check if we have an autoexecpath already set, if not just remove
            // the %path%
            //
            Value.Length = (USHORT)cbt;
            Value.MaximumLength = (USHORT)cbt;
            bPrevAutoexecPath = (BOOL)!RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);

            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < cbt) {
               lstrcat(lpt, lpValue);
               dwCount = dwTemp;
            }
            if (bPrevAutoexecPath) {
                dwTemp = dwCount + lstrlen (Value.Buffer);
                if (dwTemp < cbt) {
                    lstrcat(lpt, Value.Buffer);
                    dwCount = dwTemp;
                 }
            }

            *lpPath++ = TEXT('%');
            lpPath += 5;  // go passed %path%
            lpValue = lpPath;
        }
        else {
            lpPath = wcsstr(lpPath+1, TEXT("%"));
            if (!lpPath) {
                lpStart = NULL;
                goto Fail;
            }
            lpPath++;
            ch = *lpPath;
            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < cbt) {
                lstrcat(lpt, lpValue);
                dwCount = dwTemp;
            }
            *lpPath = ch;
            lpValue = lpPath;
        }
    }

    if (*lpValue) {
       dwTemp = dwCount + lstrlen (lpValue);
       if (dwTemp < cbt) {
           lstrcat(lpt, lpValue);
           dwCount = dwTemp;
       }
    }

    Free(lpStart);

    Free(Value.Buffer);

    return(lpt);
Fail:

    if ( Value.Buffer )
    {
        Free(Value.Buffer);
    }

    Free(lpt);
    return(lpStart);
}


/***************************************************************************\
* AppendNTPathWithAutoexecPath
*
* Gets the AutoexecPath created in ProcessAutoexec, and appends it to
* the NT path.
*
* History:
* 05-28-92  Johannec     Created.
*
\***************************************************************************/
BOOL
AppendNTPathWithAutoexecPath(
    PVOID *pEnv,
    LPTSTR lpPathVariable,
    LPTSTR lpAutoexecPath
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    TCHAR AutoexecPathValue[1024];
    DWORD cb;
    BOOL Success;

    if (!*pEnv) {
        return(FALSE);
    }

    RtlInitUnicodeString(&Name, lpAutoexecPath);
    cb = 1024;
    Value.Buffer = Alloc(sizeof(TCHAR)*cb);
    if (!Value.Buffer) {
        return(FALSE);
    }

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        Free(Value.Buffer);
        return(FALSE);
    }

    if (Value.Length) {
        lstrcpy(AutoexecPathValue, Value.Buffer);
    }

    Free(Value.Buffer);

    Success = BuildEnvironmentPath(pEnv, lpPathVariable, AutoexecPathValue);
    RtlSetEnvironmentVariable(pEnv, &Name, NULL);
    return(Success);
}


/***************************************************************************\
* AddNetworkConnection
*
* calls WNetAddConnection in the user's context.
*
* History:
* 6-26-92  Johannec     Created
*
\***************************************************************************/
LONG
AddNetworkConnection(PGLOBALS pGlobals, LPNETRESOURCE lpNetResource)
{
    HANDLE ImpersonationHandle;
    TCHAR szMprDll[] = TEXT("mpr.dll");
    CHAR szWNetAddConn[] = "WNetAddConnection2W";
    CHAR szWNetCancelConn[] = "WNetCancelConnection2W";
    DWORD (APIENTRY *lpfnWNetAddConn)(LPNETRESOURCE, LPTSTR, LPTSTR, DWORD);
    DWORD (APIENTRY *lpfnWNetCancelConn)(LPCTSTR, DWORD, BOOL);
    DWORD WNetResult;

    //
    // Impersonate the user
    //

    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

    if (ImpersonationHandle == NULL) {
        DebugLog((DEB_ERROR, "AddNetworkConnection : Failed to impersonate user"));
        return(ERROR_ACCESS_DENIED);
    }


    //
    // Call the add connection api in the users context
    //

    if (!pGlobals->hMPR) {
        // wasn't loaded, try to load it now.
        pGlobals->hMPR = LoadLibrary(szMprDll);
    }

    if (pGlobals->hMPR) {

        if (lpfnWNetAddConn = (DWORD (APIENTRY *)(LPNETRESOURCE, LPTSTR, LPTSTR, DWORD))
                GetProcAddress(pGlobals->hMPR, (LPSTR)szWNetAddConn)) {

            WNetResult = (*lpfnWNetAddConn)(lpNetResource,
                                            NULL,
                                            NULL,
                                            0);

            //
            // When LUID DosDevices are disabled,
            //     console users share the same DosDevices
            // With LUID DosDevices enabled,
            //     users each get their own DosDevices
            //

            if ( (WNetResult == ERROR_ALREADY_ASSIGNED) ||
                 (WNetResult == ERROR_DEVICE_ALREADY_REMEMBERED) )
            {
                // Drive is already assigned -- undo it and retry.  This is to prevent a
                // user from subst-ing a drive to another user's home drive so the other
                // user's home drive points somewhere inappropriate on next logon.

                if (lpfnWNetCancelConn = (DWORD (APIENTRY *)(LPCTSTR, DWORD, BOOL))
                        GetProcAddress(pGlobals->hMPR, (LPSTR)szWNetCancelConn)) {

                    WNetResult = lpfnWNetCancelConn(lpNetResource->lpLocalName,
                                                    0,
                                                    TRUE);
                }

                if ( (WNetResult != NO_ERROR) &&
                     (WNetResult == ERROR_ALREADY_ASSIGNED) && 
                     (GetLUIDDeviceMapsEnabled() == FALSE) )

                {

                    // WNet didn't work -- try DefineDosDevice (as the user)
                    // to undo any drive substitutions that aren't background
                    // admin-level symlinks

                    DefineDosDevice(DDD_REMOVE_DEFINITION,
                                    lpNetResource->lpLocalName,
                                    NULL);
                }
                
                // Retry the connection

                WNetResult = (*lpfnWNetAddConn)(lpNetResource,
                                                NULL,
                                                NULL,
                                                0);
            }

            if (WNetResult != ERROR_SUCCESS) {
                DebugLog((DEB_ERROR,
                          "WNetAddConnection2W to %ws failed, error = %d\n",
                          lpNetResource->lpRemoteName,
                          WNetResult));

                FreeLibrary(pGlobals->hMPR);
                pGlobals->hMPR = NULL;
                SetLastError( WNetResult );
            }

            if (!StopImpersonating(ImpersonationHandle)) {
                DebugLog((DEB_ERROR, "AddNetworkConnection : Failed to revert to self"));
            }

            return( WNetResult );


        } else {
            DebugLog((DEB_ERROR, "Failed to get address of WNetAddConnection2W from mpr.dll"));
        }

    } else {
        DebugLog((DEB_ERROR, "Winlogon failed to load mpr.dll for add connection"));
    }

    //
    // Unload mpr.dll.  Keeping it open messes up Novell and Banyan.
    //

    if ( pGlobals->hMPR ) {

        FreeLibrary(pGlobals->hMPR);
        pGlobals->hMPR = NULL;
    }

    //
    // Revert to being 'ourself'
    //

    if (!StopImpersonating(ImpersonationHandle)) {
        DebugLog((DEB_ERROR, "AddNetworkConnection : Failed to revert to self"));
    }

    //
    // This is the failure return.

    return( GetLastError() );
}


#ifdef _X86_
BOOL
IsPathIncludeRemovable(LPTSTR lpValue)
{
    LPTSTR      lpt, tmp;
    BOOL        ret = FALSE;
    WCHAR       c;

    tmp = LocalAlloc(LPTR, (lstrlen(lpValue) + 1) * sizeof(WCHAR));
    if (!tmp)
        DebugLog((DEB_ERROR, "IsPathIncludeRemovable : Failed to LocalAlloc (%d)", GetLastError()));
    else {
        lstrcpy(tmp, lpValue);

        lpt = tmp;
        while (*lpt) {
            // skip spaces
            for ( ; *lpt && *lpt == TEXT(' '); lpt++)
            ;

            // check if the drive is removable
            if (lpt[0] && lpt[1] && lpt[1] == TEXT(':') && lpt[2]) {        // ex) "A:\"
            c = lpt[3];
            lpt[3] = 0;
            if (GetDriveType(lpt) == DRIVE_REMOVABLE) {
                lpt[3] = c;
                ret = TRUE;
                break;
            }
            lpt[3] = c;
            }

            // skip to the next path
            for ( ; *lpt && *lpt != TEXT(';'); lpt++)
            ;
            if (*lpt)
            lpt++;
    }
    LocalFree(tmp);
    }
    return(ret);
}
#endif


/***************************************************************************\
* GetLUIDDeviceMapsEnabled
*
* This function calls NtQueryInformationProcess() to determine if
* LUID device maps are enabled
*
* Return Value:
*
*   TRUE - LUID device maps are enabled
*
*   FALSE - LUID device maps are disabled
*
\***************************************************************************/

BOOL
GetLUIDDeviceMapsEnabled( VOID )
{
    ULONG LUIDDeviceMapsEnabled;
    NTSTATUS Status;

    //
    // Check if LUID Device Maps are enabled
    //
    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
        return( FALSE );
    }
    else {
        return (LUIDDeviceMapsEnabled != 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\lockout.h ===
/****************************** Module Header ******************************\
* Module Name: lockout.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis and data types used to implement account lockout
*
* History:
* 05-27-92 Davidc       Created.
\***************************************************************************/


#ifdef DATA_TYPES_ONLY

//
// Lockout specific types
//


//
// FailedLogonTimes is an array holding the time of the previous
// consecutive failed logons.
// FailedLogonIndex points into the array at the last bad logon time.
//
// The following values in the array are valid at any particular time
//
// FailedLogonTime[FailedLogonIndex] // Most recent failed logon
// FailedLogonTime[FailedLogonIndex - 1]
// ...
// FailedLogonTime[FailedLogonIndex - ConsecutiveFailedLogons + 1]
//
// No values in the array are valid if ConsecutiveFailedLogons == 0
//

typedef struct _LOCKOUT_DATA {
    ULONG   ConsecutiveFailedLogons;
    ULONG   FailedLogonIndex;
    TIME    FailedLogonTimes[LOCKOUT_BAD_LOGON_COUNT];
} LOCKOUT_DATA;
typedef LOCKOUT_DATA *PLOCKOUT_DATA;




#else // DATA_TYPES_ONLY


//
// Exported function prototypes
//

BOOL
LockoutInitialize(
    PGLOBALS pGlobals
    );

BOOL
LockoutHandleFailedLogon(
    PGLOBALS pGlobals
    );

BOOL
LockoutHandleSuccessfulLogon(
    PGLOBALS pGlobals
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\lsa.c ===
/****************************************************************************

   PROGRAM: LSA.C

   PURPOSE: Utility routines that access the LSA.

****************************************************************************/

#include "msgina.h"



// #define DEBUG_LSA

#ifdef DEBUG_LSA
#define VerbosePrint(s) WLPrint(s)
#else
#define VerbosePrint(s)
#endif

NTSTATUS NtStatusGPDEx = 0;

/***************************************************************************\
* GetPrimaryDomainEx
*
* Purpose : Returns the primary domain name for authentication
*
* Returns : TRUE if primary domain exists and returned, otherwise FALSE
*
* The primary domain name should be freed using RtlFreeUnicodeString().
* The primary domain sid should be freed using Free()
*
* History:
* 02-13-92 Davidc       Created.
\***************************************************************************/
BOOL
GetPrimaryDomainEx(
    PUNICODE_STRING PrimaryDomainName OPTIONAL,
    PUNICODE_STRING PrimaryDomainDnsName OPTIONAL,
    PSID    *PrimaryDomainSid OPTIONAL,
    PBOOL SidPresent OPTIONAL
    )
{
    NTSTATUS IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;
    BOOL    PrimaryDomainPresent = FALSE;
    DWORD dwRetry = 10;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //
Retry:
    NtStatusGPDEx = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );

    if (!NT_SUCCESS(NtStatusGPDEx)) {
        DebugLog((DEB_ERROR, "Failed to open local LsaPolicyObject, Status = 0x%lx\n", NtStatusGPDEx));
        if ((NtStatusGPDEx == RPC_NT_SERVER_TOO_BUSY) && (--dwRetry))
        {
            Sleep(100);
            goto Retry;     // Likely to be too soon to call Lsa
        }
        return(FALSE);
    }

    //
    // Get the primary domain info
    //
    NtStatusGPDEx = LsaQueryInformationPolicy(LsaHandle,
                                       PolicyDnsDomainInformation,
                                       (PVOID *)&DnsDomainInfo);
    if (!NT_SUCCESS(NtStatusGPDEx)) {
        DebugLog((DEB_ERROR, "Failed to query primary domain from Lsa, Status = 0x%lx\n", NtStatusGPDEx));

        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(FALSE);
    }

    //
    // Copy the primary domain name into the return string
    //

    if ( SidPresent )
    {
        *SidPresent = ( DnsDomainInfo->Sid != NULL );
    }

    if (DnsDomainInfo->Sid != NULL) {

        PrimaryDomainPresent = TRUE;

        if (PrimaryDomainName)
        {

            if (DuplicateUnicodeString(PrimaryDomainName, &(DnsDomainInfo->Name))) {

                if (PrimaryDomainSid != NULL) {

                    ULONG SidLength = RtlLengthSid(DnsDomainInfo->Sid);

                    *PrimaryDomainSid = Alloc(SidLength);
                    if (*PrimaryDomainSid != NULL) {

                        NtStatusGPDEx = RtlCopySid(SidLength, *PrimaryDomainSid, DnsDomainInfo->Sid);
                        ASSERT(NT_SUCCESS(NtStatusGPDEx));

                    } else {
                        RtlFreeUnicodeString(PrimaryDomainName);
                        PrimaryDomainPresent = FALSE;
                    }
                }

            } else {
                PrimaryDomainPresent = FALSE;
            }
        }
    } else if (DnsDomainInfo->DnsDomainName.Length != 0) {
        PrimaryDomainPresent = TRUE;
        if (PrimaryDomainName) {
            if (DuplicateUnicodeString(
                    PrimaryDomainName,
                    &DnsDomainInfo->DnsDomainName)) {

                ASSERT(!ARGUMENT_PRESENT(PrimaryDomainSid));

            } else {
                PrimaryDomainPresent = FALSE;
            }

        }
    }

    if ( ( DnsDomainInfo->DnsDomainName.Length != 0 ) &&
         ( PrimaryDomainDnsName != NULL ) )
    {
        DuplicateUnicodeString( PrimaryDomainDnsName, 
                                &DnsDomainInfo->DnsDomainName );
    }

    //
    // We're finished with the Lsa
    //

    IgnoreStatus = LsaFreeMemory(DnsDomainInfo);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = LsaClose(LsaHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return(PrimaryDomainPresent);
}


//
// Since this isn't going to change without a reboot, we can easily cache the info
//
BOOL
IsMachineDomainMember(
    VOID
    )
{
    static BOOL s_bIsDomainMember = FALSE;
    static BOOL s_bDomainCached = FALSE;

    if (!s_bDomainCached)
    {
        s_bIsDomainMember = GetPrimaryDomainEx(NULL, NULL, NULL, NULL);
        if (NT_SUCCESS(NtStatusGPDEx))
            s_bDomainCached = TRUE;
    }

    return s_bIsDomainMember;
}

ULONG
GetMaxPasswordAge(
    LPWSTR Domain,
    PULONG MaxAge
    )
{
    DWORD Error;
    PUSER_MODALS_INFO_0 Modals;
    WCHAR ComputerName[ CNLEN+2 ];
    ULONG Length ;
    PDOMAIN_CONTROLLER_INFO DcInfo ;
    PWSTR DcNameBuffer ;

    Length = CNLEN + 2;

    GetComputerName( ComputerName, &Length );

    if (_wcsicmp( ComputerName, Domain ) == 0 )
    {
        DcNameBuffer = NULL ;
        DcInfo = NULL ;
    }
    else
    {

        Error = DsGetDcName( NULL,
                             Domain,
                             NULL,
                             NULL,
                             0,
                             &DcInfo );

        if ( Error )
        {
            return Error ;
        }

        DcNameBuffer = DcInfo->DomainControllerAddress ;
    }

    Error = NetUserModalsGet( DcNameBuffer,
                                  0,
                                  (PUCHAR *) &Modals );

    if ( Error == 0 )
    {
        *MaxAge = Modals->usrmod0_max_passwd_age ;

        NetApiBufferFree( Modals );
    }

    if ( DcInfo )
    {
        NetApiBufferFree( DcInfo );
    }

    return Error ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\langicon.h ===
/****************************** Module Header ******************************\
* Module Name: langicon.h
*
* Copyright (c) 1998, Microsoft Corporation
*
* Define apis in langicon.c
*
\***************************************************************************/

//
// Prototypes
//

typedef enum _LAYOUT_USER {
    LAYOUT_DEF_USER,
    LAYOUT_CUR_USER
} LAYOUT_USER;

#define TIMER_MYLANGUAGECHECK     1

BOOL
DisplayLanguageIcon(
    HWND hwnd,
    LAYOUT_USER LayoutUser,
    HKL  hkl);

void
FreeLayoutInfo(
    LAYOUT_USER LayoutUser);

void
LayoutCheckHandler(
    HWND hwnd,
    LAYOUT_USER LayoutUser);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\lsa.h ===
/****************************** Module Header ******************************\
* Module Name: lsa.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define utility routines that access the LSA
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//

BOOL
IsMachineDomainMember(
    VOID
    );

BOOL
GetPrimaryDomainEx(
    PUNICODE_STRING PrimaryDomainName,
    PUNICODE_STRING PrimaryDomainDnsName,
    PSID * PrimaryDomainSid OPTIONAL,
    PBOOL SidPresent OPTIONAL
    );

ULONG
GetMaxPasswordAge(
    LPWSTR Domain,
    PULONG MaxAge
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\makefile.inc ===
!if exist(..\$(TARGET_DIRECTORY).inc)
!include ..\$(TARGET_DIRECTORY).inc
!endif

STRING_FILES=strings.rc $(SHELL_INC_PATH)\ginastrs.rc
DIALOG_FILES=dialogs.rc $(SHELL_INC_PATH)\ginadlgs.rc
BITMAP_FILES=bitmaps.rc res\* $(SHELL_INC_PATH)\ginabmps.rc
ICON_FILES=nodc.ico

res.rc: $(STRING_FILES) $(DIALOG_FILES) $(BITMAP_FILES) $(ICON_FILES) $(O)\wlevents.rc

precomp.h: wlevents.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\lockout.c ===
/****************************** Module Header ******************************\
* Module Name: lockout.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implements account lockout support functions.
*
* History:
* 05-27-92 Davidc       Created.
\***************************************************************************/

#include "msgina.h"
#pragma hdrstop


#define INDEX_WRAP(i) ((i + LOCKOUT_BAD_LOGON_COUNT) % LOCKOUT_BAD_LOGON_COUNT)

#define TERMSERV_EVENTSOURCE        L"TermService"

// Also defined in icaevent.mc
#define EVENT_EXCEEDED_MAX_LOGON_ATTEMPTS 0x400003F4L


/***************************************************************************\
* FUNCTION: LockoutInitialize
*
* PURPOSE:  Initializes any data used by lockout functions
*
* RETURNS:  TRUE
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
LockoutInitialize(
    PGLOBALS pGlobals
    )
{
    PLOCKOUT_DATA pLockoutData = &pGlobals->LockoutData;

    pLockoutData->ConsecutiveFailedLogons = 0;
    pLockoutData->FailedLogonIndex = 0;

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: LockoutHandleFailedLogon
*
* PURPOSE:  Implements account lockout restrictions if failed logons
*           have exceeded a limit frequency.
*           Account lockout is implemented by imposing an additional delay
*           in a failed logon when the various failed logon conditions are met.
*
* RETURNS:  TRUE
*
* NOTES:    This routine may not return for some time. (typically 30 seconds)
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
LockoutHandleFailedLogon(
    PGLOBALS pGlobals
    )
{
    PLOCKOUT_DATA pLockoutData = &pGlobals->LockoutData;
    ULONG Index = pLockoutData->FailedLogonIndex;

    //
    // Up our bad logon count
    //

    pLockoutData->ConsecutiveFailedLogons ++;

    //
    // See if we have reached our bad logon limit.
    //

    if (pLockoutData->ConsecutiveFailedLogons > LOCKOUT_BAD_LOGON_COUNT) {

        ULONG ElapsedSecondsFirstFailure;
        ULONG ElapsedSecondsNow;
        BOOLEAN Result;

        if ((NtCurrentPeb()->SessionId != 0) && (!IsActiveConsoleSession())) {
           //
           // Forcibly terminate the remote session is we exceed the maximum
           // allowed failed logon attempts
           //

            HANDLE hEventLogSource= RegisterEventSource(NULL,TERMSERV_EVENTSOURCE);
            if (hEventLogSource != NULL)
            {
                PWSTR Strings[ 1 ];
                Strings[0] = pGlobals->MuGlobals.ClientName;

                ReportEvent(hEventLogSource,
                            EVENTLOG_INFORMATION_TYPE,
                            0,
                            EVENT_EXCEEDED_MAX_LOGON_ATTEMPTS,
                            NULL,
                            1,
                            0,
                            Strings,
                            NULL);

                DeregisterEventSource(hEventLogSource);
            }

            TerminateProcess( GetCurrentProcess(), 0 );
        }

        //
        // Limit the count so we don't have any wrap-round problems
        // (32-bits - that's a lot of failed logons I know)
        //

        pLockoutData->ConsecutiveFailedLogons = LOCKOUT_BAD_LOGON_COUNT + 1;

        //
        // If the first logon in our list occurred too recently, insert
        // the appropriate delay
        //

        Result = RtlTimeToSecondsSince1980(&pLockoutData->FailedLogonTimes[Index],
                                           &ElapsedSecondsFirstFailure);
        ASSERT(Result);

        Result = RtlTimeToSecondsSince1980(&pGlobals->LogonTime,
                                           &ElapsedSecondsNow);
        ASSERT(Result);


        if ((ElapsedSecondsNow - ElapsedSecondsFirstFailure) < LOCKOUT_BAD_LOGON_PERIOD) {

            SetupCursor(TRUE);

            Sleep(LOCKOUT_BAD_LOGON_DELAY * 1000);

            SetupCursor(FALSE);
        }
    }

    //
    // Add this failed logon to the array
    //

    pLockoutData->FailedLogonTimes[Index] = pGlobals->LogonTime;
    pLockoutData->FailedLogonIndex = INDEX_WRAP(pLockoutData->FailedLogonIndex+1);


    return(TRUE);
}


/***************************************************************************\
* FUNCTION: LockoutHandleSuccessfulLogon
*
* PURPOSE:  Resets account lockout statistics since a successful logon occurred.
*
* RETURNS:  TRUE
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
LockoutHandleSuccessfulLogon(
    PGLOBALS pGlobals
    )
{
    //
    // Reset our bad logon count
    //

    pGlobals->LockoutData.ConsecutiveFailedLogons = 0;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\lock.h ===
/****************************** Module Header ******************************\
* Module Name: lock.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis used to lock the workstation
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//


INT_PTR
CALLBACK
LockedDlgProc(HWND, UINT, WPARAM, LPARAM);


INT_PTR
CALLBACK
UnlockDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\msgina.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msgina.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------
#include "msgina.h"

// Link Window
#include "shlobj.h"
#include "shlobjp.h"

#ifdef _X86_
#include "i386\oemhard.h"
#endif

#include <accctrl.h>
#include <aclapi.h>


HINSTANCE                   hDllInstance;   // My instance, for resource loading
HINSTANCE                   hAppInstance;   // App instance, for dialogs, etc.
PWLX_DISPATCH_VERSION_1_4   pWlxFuncs;      // Ptr to table of functions
PWLX_DISPATCH_VERSION_1_4   pTrueTable ;    // Ptr to table in winlogon
DWORD                       SafeBootMode;


BOOL    g_IsTerminalServer;
BOOL    g_Console = TRUE;
BOOL    VersionMismatch ;
DWORD   InterfaceVersion ;
HKEY    WinlogonKey ;

int TSAuthenticatedLogon(PGLOBALS pGlobals);

BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls ( hInstance );
            hDllInstance = hInstance;
            g_IsTerminalServer = !!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));
#if DBG
            InitDebugSupport();
#endif
            InitializeSecurityGlobals();
#ifdef _X86_
            InitializeOEMId();
#endif
            _Shell_DllMain(hInstance, dwReason);
            return(TRUE);
        case DLL_PROCESS_DETACH:
            _Shell_DllMain(hInstance, dwReason);
            FreeSecurityGlobals();
            return(TRUE);
        default:
            return(TRUE);
    }
}

BOOL
WINAPI
WlxNegotiate(
    DWORD                   dwWinlogonVersion,
    DWORD                   *pdwDllVersion
    )
{
    InterfaceVersion = dwWinlogonVersion ;

    if (dwWinlogonVersion < WLX_CURRENT_VERSION)
    {
        DebugLog(( DEB_WARN, "Old WLX interface (%x)\n", dwWinlogonVersion ));

        if ( dwWinlogonVersion < WLX_VERSION_1_1 )
        {
            return FALSE ;
        }

        VersionMismatch = TRUE ;
    }

    *pdwDllVersion = WLX_CURRENT_VERSION;

    DebugLog((DEB_TRACE, "Negotiate:  successful!\n"));

    return(TRUE);

}

BOOL GetDefaultCADSetting(void)
{
    BOOL bDisableCad = FALSE;
    NT_PRODUCT_TYPE NtProductType;


    //
    // Servers and workstations in a domain will default to requiring CAD.
    // Workstations in a workgroup won't require CAD (by default).  Note,
    // the default CAD setting can be overwritten by either a machine
    // preference or machine policy.
    //

    RtlGetNtProductType(&NtProductType);

    if ( IsWorkstation(NtProductType) )
    {
        if ( !IsMachineDomainMember() )     // This function is doing some caching
        {                                   // so we don't need to be brighter here
            bDisableCad = TRUE;
        }
    }

    return bDisableCad;
}


BOOL GetDisableCad(PGLOBALS pGlobals)
// Returns whether or not the user should be required to press C-A-D before
// logging on. TRUE == Disable CAD, FALSE == Require CAD
{
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey;

    BOOL fDisableCad = GetDefaultCADSetting();

    dwSize = sizeof(fDisableCad);

    RegQueryValueEx (WinlogonKey, DISABLE_CAD, NULL, &dwType,
                        (LPBYTE) &fDisableCad , &dwSize);

    //
    // Check if C+A+D is disabled via policy
    //

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY, 0, KEY_READ,
                     &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(fDisableCad);

        RegQueryValueEx (hKey, DISABLE_CAD, NULL, &dwType,
                            (LPBYTE) &fDisableCad , &dwSize);

        RegCloseKey (hKey);
    }

    //
    // if s/c is present, force on c-a-d, since that's the only way to tell the
    // difference
    //

    if ( g_Console )
    {
        ULONG_PTR Value ;

        pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_SMART_CARD_PRESENT,
                             &Value);

        if ( Value )
        {
            fDisableCad = FALSE ;
        }
    }

    //
    // Check if C+A+D is disabled for remote Hydra clients and copy the client name
    //

    if (g_IsTerminalServer  ) {

        HANDLE          dllHandle;

        //
        // Load winsta.dll
        //
        dllHandle = LoadLibraryW(L"winsta.dll");

        if (dllHandle) {

            PWINSTATION_QUERY_INFORMATION pfnWinstationQueryInformation;

            pfnWinstationQueryInformation = (PWINSTATION_QUERY_INFORMATION) GetProcAddress(
                                                                   dllHandle,
                                                                   "WinStationQueryInformationW"
                                                                   );
            if (pfnWinstationQueryInformation) {


                WINSTATIONCLIENT ClientData;
                ULONG Length;


                //
                // Get the CAD disable data from the client
                //
                if ( pfnWinstationQueryInformation( SERVERNAME_CURRENT,
                                                  LOGONID_CURRENT,
                                                  WinStationClient,
                                                  &ClientData,
                                                  sizeof(ClientData),
                                                  &Length ) ) {


                    //
                    // Take the client settings only if the CAD is not globally disabled for the server,
                    // and, if this is not the console active session.
                    //
                    if (!fDisableCad && !IsActiveConsoleSession() ) 
                    {

                        fDisableCad = ClientData.fDisableCtrlAltDel;

                    }

                    //
                    // Copy the Client Name, even console has a client name now, due to PTS and console disconnect features.
                    //
                    //
                    lstrcpyn(pGlobals->MuGlobals.ClientName, ClientData.ClientName, CLIENTNAME_LENGTH);
                }
                else
                {
                    if (!IsActiveConsoleSession()) {
                       fDisableCad = TRUE;
                    }

                    // TS start could have been delayed until 60seconds post first console login.
                    // Hence, it is safe to assume that this is the console session, besides, 
                    // we are initing some benign env var.

                    lstrcpyn(pGlobals->MuGlobals.ClientName,L"Console", CLIENTNAME_LENGTH );
                }
            }

            FreeLibrary(dllHandle);
        }
    }

    // Friendly UI on -> ALWAYS disable CAD.

    if (ShellIsFriendlyUIActive())
    {
        fDisableCad = TRUE;
    }

    return fDisableCad;
}



BOOL
MsGinaSetOption(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR Value,
    ULONG_PTR * OldValue
    )
{
    return FALSE ;
}


BOOL
MsGinaGetOption(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR * Value
    )
{
    return FALSE ;
}


PWLX_DISPATCH_VERSION_1_4
GetFixedUpTable(
    PVOID FakeTable
    )
{
    int err ;
    PVOID p ;
    PWLX_DISPATCH_VERSION_1_4 pNewTable ;
    DWORD dwSize ;
    DWORD dwType ;

    pNewTable = LocalAlloc( LMEM_FIXED, sizeof( WLX_DISPATCH_VERSION_1_4 ) );

    if ( !pNewTable )
    {
        return NULL ;
    }

    dwSize = sizeof( PVOID );
    err = RegQueryValueEx(
                WinlogonKey,
                TEXT("Key"),
                NULL,
                &dwType,
                (PUCHAR) &p,
                &dwSize );

    if ( (err == 0) &&
         (dwType == REG_BINARY) &&
         (dwSize == sizeof( PVOID ) ) )
    {
        pTrueTable = p ;

        switch ( InterfaceVersion )
        {
            case WLX_VERSION_1_1:
                dwSize = sizeof( WLX_DISPATCH_VERSION_1_1 );
                break;

            case WLX_VERSION_1_2:
            case WLX_VERSION_1_3:
            case WLX_VERSION_1_4:
                dwSize = sizeof( WLX_DISPATCH_VERSION_1_2 );
                break;

        }

        RtlCopyMemory(
            pNewTable,
            FakeTable,
            dwSize );

        pNewTable->WlxGetOption = MsGinaGetOption ;
        pNewTable->WlxSetOption = MsGinaSetOption ;
        pNewTable->WlxCloseUserDesktop = pTrueTable->WlxCloseUserDesktop ;
        pNewTable->WlxWin31Migrate = pTrueTable->WlxWin31Migrate ;
        pNewTable->WlxQueryClientCredentials = pTrueTable->WlxQueryClientCredentials ;
        pNewTable->WlxQueryInetConnectorCredentials = pTrueTable->WlxQueryInetConnectorCredentials ;
        pNewTable->WlxDisconnect = pTrueTable->WlxDisconnect ;
        pNewTable->WlxQueryTerminalServicesData = pTrueTable->WlxQueryTerminalServicesData ;
        pNewTable->WlxQueryConsoleSwitchCredentials = pTrueTable->WlxQueryConsoleSwitchCredentials ;
        pNewTable->WlxQueryTsLogonCredentials = pTrueTable->WlxQueryTsLogonCredentials;
    }
    else
    {
        LocalFree( pNewTable );
        pNewTable = NULL ;
    }

    return pNewTable ;
}

extern DWORD g_dwMainThreadId;  // declared in status.c (used to "fix" a thread safety issue)

BOOL
WINAPI
WlxInitialize(
    LPWSTR                  lpWinsta,
    HANDLE                  hWlx,
    PVOID                   pvReserved,
    PVOID                   pWinlogonFunctions,
    PVOID                   *pWlxContext
    )
{
    PGLOBALS    pGlobals;
    HKEY        hKey;
    DWORD       dwSize, dwType;
    DWORD       dwStringMemory;
    DWORD       dwAutoLogonCount ;
    DWORD       dwNoLockWksta ;
    // Upon which bitmaps should our text be painted.
    BOOL        fTextOnLarge;
    BOOL        fTextOnSmall;
    ULONG_PTR   ProbeValue ;
    PWLX_GET_OPTION GetOptCall ;
    BOOL        DoFixup ;
    BOOL        DidFixup ;
    int err ;

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                WINLOGON_KEY,
                0,
                KEY_READ | KEY_WRITE,
                &WinlogonKey );
    if ( err != 0 )
    {
        return FALSE ;
    }

    DoFixup = TRUE ;
    DidFixup = FALSE ;

    if ( VersionMismatch )
    {
        pWlxFuncs = GetFixedUpTable( pWinlogonFunctions );
        if ( pWlxFuncs )
        {
            DidFixup = TRUE ;
        }
        else
        {
            pWlxFuncs = (PWLX_DISPATCH_VERSION_1_4) pWinlogonFunctions ;
            DidFixup = FALSE ;
        }
    }
    else
    {
        pWlxFuncs = (PWLX_DISPATCH_VERSION_1_4) pWinlogonFunctions ;
    }

    //
    // Probe the callback table to make sure we're ok:
    //
    try
    {
        GetOptCall = pWlxFuncs->WlxGetOption ;

        if ( GetOptCall( hWlx,
                         WLX_OPTION_DISPATCH_TABLE_SIZE,
                         &ProbeValue ) )
        {
            if ( ProbeValue == sizeof( WLX_DISPATCH_VERSION_1_4 ) )
            {
                DoFixup = FALSE ;
            }
        }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        NOTHING ;
    }

    if ( DoFixup && !DidFixup )
    {
        pWlxFuncs = GetFixedUpTable( pWinlogonFunctions );
    }

    if ( !pWlxFuncs )
    {
        return FALSE ;
    }

    pGlobals = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(GLOBALS));

    if ( !pGlobals )
    {
        return FALSE ;
    }

    if ( !NT_SUCCESS ( RtlInitializeCriticalSection( &pGlobals->csGlobals ) ) )
    {
        LocalFree( pGlobals );
        return FALSE ;
    }

    if ( !InitHKeyCurrentUserSupport() )
    {
        RtlDeleteCriticalSection( &pGlobals->csGlobals );
        LocalFree( pGlobals );
        return FALSE ;
    }

    // Reserve enough memory for 4 strings of length MAX_STRING_BYTES
    dwStringMemory = (MAX_STRING_BYTES * sizeof (WCHAR)) * 4;
    pGlobals->LockedMemory = VirtualAlloc(
            NULL,
            dwStringMemory,
            MEM_COMMIT,
            PAGE_READWRITE);
    if ( pGlobals->LockedMemory == NULL )
    {
        CleanupHKeyCurrentUserSupport();
        RtlDeleteCriticalSection( &pGlobals->csGlobals );
        LocalFree( pGlobals );
        return FALSE ;
    }

    VirtualLock( pGlobals->LockedMemory, dwStringMemory);

    memset( pGlobals->LockedMemory, 0, dwStringMemory );
    pGlobals->UserName = pGlobals->LockedMemory ;
    pGlobals->Domain = pGlobals->UserName + MAX_STRING_BYTES ;
    pGlobals->Password = pGlobals->Domain + MAX_STRING_BYTES ;
    pGlobals->OldPassword = pGlobals->Password + MAX_STRING_BYTES ;

    *pWlxContext = (PVOID) pGlobals;

    pGlobals->hGlobalWlx = hWlx;

    pWlxFuncs->WlxUseCtrlAltDel(hWlx);

    if ( DCacheInitialize() )
    {
        pGlobals->Cache = DCacheCreate();
    }
    else
    {
        pGlobals->Cache = NULL ;
    }

    if ( pGlobals->Cache == NULL )
    {
        CleanupHKeyCurrentUserSupport();
        RtlDeleteCriticalSection(&pGlobals->csGlobals);

        VirtualFree( pGlobals->LockedMemory, 0, MEM_RELEASE );

        LocalFree (pGlobals);

        DebugLog((DEB_ERROR, "Failed to init domain cache!\n"));

        return(FALSE);

    }



    dwSize = sizeof( dwNoLockWksta );
    if ( RegQueryValueEx(
            WinlogonKey,
            DISABLE_LOCK_WKSTA,
            0,
            &dwType,
            (PUCHAR) &dwNoLockWksta,
            &dwSize ) == 0 )
    {
        if ( dwNoLockWksta == 2 )
        {
            dwNoLockWksta = 0 ;

            RegSetValueEx(
                WinlogonKey,
                DISABLE_LOCK_WKSTA,
                0,
                REG_DWORD,
                (PUCHAR) &dwNoLockWksta,
                sizeof( DWORD ) );
        }
    }

    if (!InitializeAuthentication(pGlobals))
    {
        *pWlxContext = NULL;

        CleanupHKeyCurrentUserSupport();
        RtlDeleteCriticalSection(&pGlobals->csGlobals);

        VirtualFree( pGlobals->LockedMemory, 0, MEM_RELEASE );
        LocalFree (pGlobals);
        DebugLog((DEB_ERROR, "Failed to init authentication!\n"));
        return(FALSE);
    }

    //
    // Start by clearing the entire Multi-User Globals
    //
    RtlZeroMemory( &pGlobals->MuGlobals, sizeof(pGlobals->MuGlobals) );

    //
    // Get our SessionId and save in globals
    //

    pGlobals->MuGlobals.SessionId = NtCurrentPeb()->SessionId;
    if (pGlobals->MuGlobals.SessionId != 0) {
        g_Console = FALSE;
    }

    //
    // if this is a TS session, we can't run if there is a version
    // mismatch.  Fail out now.
    //
    if ( (!g_Console) &&
            (VersionMismatch ) )
    {
        *pWlxContext = NULL;
        CleanupHKeyCurrentUserSupport();
        RtlDeleteCriticalSection(&pGlobals->csGlobals);
        LocalFree (pGlobals);
        DebugLog((DEB_ERROR, "Failed to init authentication!\n"));
        return(FALSE);
    }

    // Check if CAD is disabled
    GetDisableCad(pGlobals);

    //
    // If this is auto admin logon, or ctrl+alt+del is disabled,
    // generate a fake SAS right now. Don't attempt AutoLogon unless on Console
    //
    if ((g_Console && GetProfileInt( APPLICATION_NAME, TEXT("AutoAdminLogon"), 0) ) ||
           GetDisableCad(pGlobals))
    {
        dwSize = sizeof( DWORD );
        if ( RegQueryValueEx( WinlogonKey, AUTOLOGONCOUNT_KEY, NULL,
                              &dwType, (LPBYTE) &dwAutoLogonCount,
                              &dwSize ) == 0 )
        {
            //
            // AutoLogonCount value was present.  Check the value:
            //
            if ( dwAutoLogonCount == 0 )
            {
                //
                // Went to zero.  Reset everything:
                //

                RegDeleteValue( WinlogonKey, AUTOLOGONCOUNT_KEY );
                RegDeleteValue( WinlogonKey, DEFAULT_PASSWORD_KEY );
                RegSetValueEx( WinlogonKey, AUTOADMINLOGON_KEY, 0,
                        REG_SZ, (LPBYTE) TEXT("0"), 2 * sizeof(WCHAR) );
            }
            else
            {
                //
                // Decrement the count, and try the logon:
                //
                dwAutoLogonCount-- ;

                RegSetValueEx( WinlogonKey, AUTOLOGONCOUNT_KEY,
                               0, REG_DWORD, (LPBYTE) &dwAutoLogonCount,
                               sizeof( DWORD ) );

                KdPrint(( "AutoAdminLogon = 1\n" ));
                pWlxFuncs->WlxSasNotify(pGlobals->hGlobalWlx, WLX_SAS_TYPE_CTRL_ALT_DEL);
            }
        }
        else
        {
            //
            // AutoLogonCount not present
            //

            KdPrint(( "AutoAdminLogon = 1\n" ));
            pWlxFuncs->WlxSasNotify( pGlobals->hGlobalWlx, WLX_SAS_TYPE_CTRL_ALT_DEL );
        }

    }

    //
    // get the safeboot mode
    //
    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("system\\currentcontrolset\\control\\safeboot\\option"),
            0,
            KEY_READ,
            & hKey
            ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        RegQueryValueEx (
                hKey,
                TEXT("OptionValue"),
                NULL,
                &dwType,
                (LPBYTE) &SafeBootMode,
                &dwSize
                );
        RegCloseKey( hKey );
    }

    //
    // Load branding images
    //
    LoadBrandingImages(FALSE, &fTextOnLarge, &fTextOnSmall);

    //
    // Create fonts
    //
    CreateFonts(&pGlobals->GinaFonts);

    //
    // Draw localized text on branding images
    //
    PaintBitmapText(&pGlobals->GinaFonts, fTextOnLarge, fTextOnSmall);

    //
    // Initialize consumer windows changes
    //
    _Shell_Initialize(pGlobals);

    //
    // Initialize this global that's used in status.c. We know that WlxInitialize is called
    // on the main thread of winlogon.
    //
    g_dwMainThreadId = GetCurrentThreadId();

    return(TRUE);
}


VOID
WINAPI
WlxDisplaySASNotice(PVOID   pContext)
{
    PGLOBALS pGlobals = (PGLOBALS)pContext;
    INITCOMMONCONTROLSEX icce;
    icce.dwSize = sizeof (icce);
    icce.dwICC = ICC_ANIMATE_CLASS;
    InitCommonControlsEx(&icce);

    // Need to register the link window
    LinkWindow_RegisterClass();

    pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                   hDllInstance,
                                   (LPTSTR) IDD_WELCOME_DIALOG,
                                   NULL,
                                   WelcomeDlgProc,
                                   (LPARAM) pContext );
}


PWSTR
AllocAndExpandProfilePath(
        PGLOBALS    pGlobals,
        LPWSTR      lpUserName)
{
    WCHAR szPath[MAX_PATH];
    WCHAR szFullPath[MAX_PATH];
    WCHAR szServerName[UNCLEN];
    WCHAR szUserName[100];
    DWORD cFullPath;
    PWSTR pszFullPath;
    DWORD dwPathLen=0;

    //
    // Set up the logon server environment variable:
    //
    szServerName[0] = L'\\';
    szServerName[1] = L'\\';
    CopyMemory( &szServerName[2],
                pGlobals->Profile->LogonServer.Buffer,
                pGlobals->Profile->LogonServer.Length );

    szServerName[pGlobals->Profile->LogonServer.Length / sizeof(WCHAR) + 2] = L'\0';

    SetEnvironmentVariable(LOGONSERVER_VARIABLE, szServerName);

    dwPathLen = lstrlen(pGlobals->MuGlobals.TSData.ProfilePath);

    if (!g_Console && (dwPathLen > 0)) {
        //
        // See if the user specified a Terminal Server profile path.
        // If so, we override the regular profile path
        //
        if (dwPathLen < MAX_PATH)
        {
            lstrcpy(szPath, pGlobals->MuGlobals.TSData.ProfilePath);
        }
        else
        {
            lstrcpy(szPath, NULL_STRING);
        }
    } else {

        dwPathLen = pGlobals->Profile->ProfilePath.Length;

        if (dwPathLen == 0)
        {
            return(NULL);
        }

        //
        // Copy the profile path locally
        //
        if (dwPathLen <= (MAX_PATH-1)*sizeof(WCHAR))
        {
            CopyMemory( szPath,
                        pGlobals->Profile->ProfilePath.Buffer,
                        dwPathLen);
            szPath[dwPathLen / sizeof(WCHAR)] = L'\0';
        }
        else
        {
            lstrcpy(szPath, NULL_STRING);
        }
    }

    if (lpUserName && *lpUserName) {
        szUserName[0] = TEXT('\0');
        GetEnvironmentVariableW (USERNAME_VARIABLE, szUserName, 100);
        SetEnvironmentVariableW (USERNAME_VARIABLE, lpUserName);
    }

    //
    // Expand the profile path using current settings:
    //
    cFullPath = ExpandEnvironmentStrings(szPath, szFullPath, MAX_PATH);
    if (cFullPath)
    {
        pszFullPath = LocalAlloc(LMEM_FIXED, cFullPath * sizeof(WCHAR));
        if (pszFullPath)
        {
            CopyMemory( pszFullPath, szFullPath, cFullPath * sizeof(WCHAR));
        }
    }
    else
    {
        pszFullPath = NULL;
    }

    if (lpUserName && *lpUserName) {
        if (szUserName[0] != TEXT('\0'))
            SetEnvironmentVariableW (USERNAME_VARIABLE, szUserName);
        else
            SetEnvironmentVariableW (USERNAME_VARIABLE, NULL);
    }

    return(pszFullPath);
}


PWSTR
AllocPolicyPath(
    PGLOBALS pGlobals)
{
    LPWSTR   pszPath;

    pszPath = LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));
    if ( pszPath )
    {
        pszPath[0] = L'\\';
        pszPath[1] = L'\\';
        CopyMemory( &pszPath[2],
                    pGlobals->Profile->LogonServer.Buffer,
                    pGlobals->Profile->LogonServer.Length );

        wcscpy( &pszPath[ pGlobals->Profile->LogonServer.Length / sizeof(WCHAR) + 2],
                L"\\netlogon\\ntconfig.pol" );
    }

    return(pszPath);
}


PWSTR
AllocNetDefUserProfilePath(
    PGLOBALS pGlobals)
{
    LPWSTR   pszPath;

    pszPath = LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));
    if ( pszPath )
    {
        //
        // Set up the logon server environment variable:
        //

        pszPath[0] = L'\\';
        pszPath[1] = L'\\';
        CopyMemory( &pszPath[2],
                    pGlobals->Profile->LogonServer.Buffer,
                    pGlobals->Profile->LogonServer.Length );

        wcscpy( &pszPath[ pGlobals->Profile->LogonServer.Length / sizeof(WCHAR) + 2],
                L"\\netlogon\\Default User" );
    }

    return(pszPath);
}


PWSTR
AllocServerName(
    PGLOBALS pGlobals)
{
    LPWSTR   pszPath;

    pszPath = LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));


    if ( pszPath )
    {
        //
        // Set up the logon server environment variable:
        //
        pszPath[0] = L'\\';
        pszPath[1] = L'\\';
        CopyMemory( &pszPath[2],
                    pGlobals->Profile->LogonServer.Buffer,
                    pGlobals->Profile->LogonServer.Length );

        pszPath[pGlobals->Profile->LogonServer.Length / sizeof(WCHAR) + 2] = L'\0';
    }

    return(pszPath);
}


VOID
DetermineDnsDomain(
    PGLOBALS pGlobals
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;

    pGlobals->DnsDomain = NULL;

    if ( ImpersonateLoggedOnUser( pGlobals->UserProcessData.UserToken ) )
    {

        ulUserNameSize = 75;    // Pick a default size. We'll expand if necessary

        lpUserName = LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

        if (!lpUserName)
        {
            dwError = GetLastError();
        }
        else
        {
            DWORD dwCount = 0;

            while (TRUE)
            {
                if (GetUserNameEx (NameDnsDomain, lpUserName, &ulUserNameSize))
                {
                    dwError = ERROR_SUCCESS;
                    break;
                }
                else
                {
                    dwError = GetLastError();

                    //
                    // If the call failed due to insufficient memory, realloc
                    // the buffer and try again.
                    //

                    if ((dwError == ERROR_INSUFFICIENT_BUFFER) || (dwError == ERROR_MORE_DATA))
                    {
                        LocalFree(lpUserName);
                        lpUserName = LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

                        if (!lpUserName) {
                            dwError = GetLastError();
                            break;      // Can't recover
                        }
                    }
                    else if (dwError == ERROR_NO_SUCH_DOMAIN)
                    {
                        // We just logged on so we know that the domain exists
                        // This is what happens with NT4 domain though since we try
                        // to query the DNS domain name and it doesn't exists
                        // Let's fall back to our old logic
                        break;
                    }
                    else if (dwError == ERROR_NONE_MAPPED)
                    {
                        // That's what's returned for local users.
                        break;
                    }
                    else
                    {
                        dwCount++;

                        if (dwCount > 3)
                        {
                            break;
                        }
                    }
                }
            }
        }

        RevertToSelf();
    }
    else
    {
        dwError = GetLastError();
    }

    if (dwError == ERROR_SUCCESS)
    {
        //
        // At this point lpUserName contains something like domain.company.com\someuser
        // We are only interested in the dns domain name
        lpTemp = lpUserName;

        while (*lpTemp && ((*lpTemp) != TEXT('\\')))
            lpTemp++;


        if (*lpTemp != TEXT('\\'))
        {
            DebugLog((DEB_ERROR, "DetermineDnsDomain: Failed to find slash in DNS style name\n"));
            dwError = ERROR_INVALID_DATA;
        }
        else
        {
            *lpTemp = TEXT('\0');
            pGlobals->DnsDomain = DupString(lpUserName);
        }
    }

    if (dwError != ERROR_SUCCESS)
    {
            //
            // If GetUserNameEx didn't yield a DNS name, fall back on the old code.
            //

        PDOMAIN_CACHE_ENTRY Entry ;

        Entry = DCacheLocateEntry(
                    pGlobals->Cache,
                    pGlobals->FlatDomain.Buffer );

        if ( Entry )
        {
            if ( Entry->Type == DomainNt5 )
            {
                pGlobals->DnsDomain = DupString( Entry->DnsName.Buffer );
            }
            else
            {
                //
                // For all intended purposes, this is good enough.
                // winlogon needs to know for sure for policy (419926)
                //
                pGlobals->DnsDomain = DupString( L"\\NT4" );
            }

            DCacheDereferenceEntry( Entry );
        }
        else
        {
            //
            // winlogon needs to know this as well. errors and not-found
            // were assumed NT5
            //
            pGlobals->DnsDomain = DupString( L"\\XFOREST" );
        }

    }

    if (lpUserName)
    {
        LocalFree(lpUserName);
    }

    //
    // Don't leave with pGlobals->DnsDomain set to NULL
    //
    if ( pGlobals->DnsDomain == NULL)
    {
        pGlobals->DnsDomain = DupString( L"" );
    }
}

PWSTR
AllocVolatileEnvironment(
    PGLOBALS    pGlobals)
{
    BOOL    DeepShare;
    LPWSTR  pszEnv;
    DWORD   dwSize;
    TCHAR   lpHomeShare[MAX_PATH] = TEXT("");
    TCHAR   lpHomePath[MAX_PATH] = TEXT("");
    TCHAR   lpHomeDrive[4] = TEXT("");
    TCHAR   lpHomeDirectory[MAX_PATH] = TEXT("");
    BOOL    TSHomeDir = FALSE;
    PVOID   lpEnvironment = NULL;       // Dummy environment


    //
    // Set the home directory environment variables
    // in a dummy environment block
    //

    if ( !g_Console ) {
        // See if the user specified a TerminalServer Home Directory.
        // If so, we override the regular directory
        if (lstrlen(pGlobals->MuGlobals.TSData.HomeDir) > 0) {
            lstrcpy(lpHomeDirectory, pGlobals->MuGlobals.TSData.HomeDir);
            TSHomeDir = TRUE;
        }
        if (lstrlen(pGlobals->MuGlobals.TSData.HomeDirDrive) > 0) {
            lstrcpy(lpHomeDrive, pGlobals->MuGlobals.TSData.HomeDirDrive);
            TSHomeDir = TRUE;
        }
    }

    if (!TSHomeDir) {
        if (pGlobals->Profile->HomeDirectoryDrive.Length &&
                (pGlobals->Profile->HomeDirectoryDrive.Length + 1) < (MAX_PATH*sizeof(TCHAR))) {
            lstrcpy(lpHomeDrive, pGlobals->Profile->HomeDirectoryDrive.Buffer);
        }

        if (pGlobals->Profile->HomeDirectory.Length &&
                (pGlobals->Profile->HomeDirectory.Length + 1) < (MAX_PATH*sizeof(TCHAR))) {
            lstrcpy(lpHomeDirectory, pGlobals->Profile->HomeDirectory.Buffer);
        }
    }

    //
    // Note : we are passing in a null environment because here we are only
    //        interested in parsing the homedirectory and set it in the volatile
    //        environment. We are not interested in setting it in the
    //        environment block here.
    //
    //        Also over here, we are only interested in setting up the
    //        HOMESHARE and HOMEPATH variables in such a way that 
    //        %HOMESHARE%%HOMEPATH% points to the homedir. This is done
    //        so that when folder redirection calls SHGetFolderPath, it will be
    //        able to expand the paths properly. Therefore, at this point
    //        it is not really necessary to pay attention to the
    //        ConnectHomeDirToRoot policy because that policy might get changed
    //        during policy processing anyway and will be picked up when the 
    //        shell starts up. Note: the values of HOMESHARE, HOMEPATH and 
    //        HOMEDRIVE will be updated correctly when the shell starts up
    //
    //        At this point we do not map the home directory for 2 reasons:
    //        (a) We are not aware of the ConnectHomeDirToRoot setting here.
    //        (b) We do not want to do the network mapping twice : once here
    //            and once when the shell starts up. 
    //
    SetHomeDirectoryEnvVars(&lpEnvironment,
                            lpHomeDirectory,
                            lpHomeDrive,
                            lpHomeShare,
                            lpHomePath,
                            &DeepShare);

    if ( pGlobals->DnsDomain == NULL )
    {
        DetermineDnsDomain( pGlobals );
    }

    dwSize = lstrlen (LOGONSERVER_VARIABLE) + 3
                + lstrlen (pGlobals->Profile->LogonServer.Buffer) + 3;

    if (L'\0' == lpHomeShare[0]) 
    {
        // Set the homedrive variable only if the home directory is not
        // a UNC path
        dwSize += lstrlen (HOMEDRIVE_VARIABLE) + 1 + lstrlen (lpHomeDrive) + 3;
    }
    else
    {
        // Set the homeshare variable only if the home directory is a UNC path
        dwSize += lstrlen (HOMESHARE_VARIABLE) + 1 + lstrlen (lpHomeShare) + 3;
    }
    dwSize += lstrlen (HOMEPATH_VARIABLE) + 1 + lstrlen (lpHomePath) + 3;

    if ( pGlobals->DnsDomain )
    {
        dwSize += (lstrlen( USERDNSDOMAIN_VARIABLE ) + 3 +
                   lstrlen( pGlobals->DnsDomain ) + 3 );
    }

    if (g_IsTerminalServer) {
        dwSize += lstrlen (CLIENTNAME_VARIABLE) + 1 + lstrlen (pGlobals->MuGlobals.ClientName) + 3;
    }

    pszEnv = LocalAlloc(LPTR, dwSize * sizeof(WCHAR));
    if ( pszEnv )
    {
        LPWSTR  pszEnvTmp;

        lstrcpy (pszEnv, LOGONSERVER_VARIABLE);
        lstrcat (pszEnv, L"=\\\\");
        lstrcat (pszEnv, pGlobals->Profile->LogonServer.Buffer);

        pszEnvTmp = pszEnv + (lstrlen( pszEnv ) + 1);

        if (L'\0' == lpHomeShare[0]) 
        {
            // Set the homedrive variable only if it is not a UNC path
            lstrcpy (pszEnvTmp, HOMEDRIVE_VARIABLE);
            lstrcat (pszEnvTmp, L"=");
            lstrcat (pszEnvTmp, lpHomeDrive);

            pszEnvTmp += (lstrlen(pszEnvTmp) + 1);
        }
        else
        {
            // Set the homeshare variable only if it is a UNC path
            lstrcpy (pszEnvTmp, HOMESHARE_VARIABLE);
            lstrcat (pszEnvTmp, L"=");
            lstrcat (pszEnvTmp, lpHomeShare);

            pszEnvTmp += (lstrlen(pszEnvTmp) + 1);
        }

        // Set the homepath variable
        lstrcpy (pszEnvTmp, HOMEPATH_VARIABLE);
        lstrcat (pszEnvTmp, L"=");
        lstrcat (pszEnvTmp, lpHomePath);

        pszEnvTmp += (lstrlen(pszEnvTmp) + 1);


        if (( pGlobals->DnsDomain ) && (*(pGlobals->DnsDomain)))
        {
            lstrcpy( pszEnvTmp, USERDNSDOMAIN_VARIABLE );
            lstrcat( pszEnvTmp, L"=" );
            lstrcat( pszEnvTmp, pGlobals->DnsDomain );

            pszEnvTmp += (lstrlen( pszEnvTmp ) + 1 );
        }

        if (g_IsTerminalServer) {
            lstrcpy (pszEnvTmp, CLIENTNAME_VARIABLE);
            lstrcat (pszEnvTmp, L"=");
            lstrcat (pszEnvTmp, pGlobals->MuGlobals.ClientName);

            pszEnvTmp += (lstrlen( pszEnvTmp ) + 1 );
        }

        *pszEnvTmp++ = L'\0';
    }

    return(pszEnv);
}


BOOL
ForceAutoLogon(
    VOID
    )
{
    HKEY hkey;
    BOOL fForceKeySet = FALSE;
    BOOL fHaveAutoLogonCount = FALSE;


    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ, &hkey))
    {
        DWORD dwValue;
        DWORD dwType;
        DWORD dwSize = sizeof (dwValue);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             AUTOLOGONCOUNT_KEY,
                                             NULL,
                                             &dwType,
                                             (LPBYTE) &dwValue,
                                             &dwSize ))
        {
            fHaveAutoLogonCount = TRUE;
        }

        dwSize = sizeof (dwValue);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             FORCEAUTOLOGON_KEY,
                                             NULL,
                                             &dwType,
                                             (LPBYTE) &dwValue,
                                             &dwSize ))
        {
            //
            // Check the value as a REG_SZ since all the other autologon values
            // are stored as REG_SZs.  Check it as a REG_DWORD for back-compat.
            //

            if (dwType == REG_DWORD)
            {
                if (0 != dwValue)
                {
                    fForceKeySet = TRUE;
                }
            }
            else if (dwType == REG_SZ)
            {
                //
                // Reread the value for consistency with the way other
                // autologon values are read/checked.
                //

                if (GetProfileInt(APPLICATION_NAME, FORCEAUTOLOGON_KEY, 0) != 0)
                {
                    fForceKeySet = TRUE;
                }
            }
        }

        RegCloseKey(hkey);
    }

    return (fHaveAutoLogonCount || fForceKeySet);
}


/****************************************************************************\
*
* FUNCTION: CreateFolderAndACLit_Worker
*
* PURPOSE:  Create a home-dir folder for the user, and set the proper security
*           such that only the user and the admin have access to the folder.
*
* PARAMS:   [in ] szPath      the full path, could be UNC or local
*           [in ] pUserSID    user SID
*           [out] pdwErr      error code if anything fails.
*
* RETURNS:  TRUE if all went ok
*           FALSE if a bad home dir path was specified.
*
* HISTORY:
*           TsUserEX ( Alhen's code which was based on EricB's DSPROP_CreateHomeDirectory )
*
*
\****************************************************************************/
#define ACE_COUNT   2
BOOLEAN CreateFolderAndACLit_Worker ( PWCHAR szPath , PSID pUserSID, PDWORD pdwErr , BOOLEAN pathIsLocal )
{
    SECURITY_ATTRIBUTES securityAttributes;
    BOOLEAN             rc;
    PSID                psidAdmins = NULL;

    *pdwErr = 0;
    ZeroMemory( &securityAttributes , sizeof( SECURITY_ATTRIBUTES ) );

    if ( !pathIsLocal  )
    {
        // build a DACL
        PSID pAceSid[ACE_COUNT];
        
        PACL pDacl;
        
        SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
        SECURITY_DESCRIPTOR securityDescriptor;
        PSECURITY_DESCRIPTOR pSecurityDescriptor = &securityDescriptor;
        int i;
        
        EXPLICIT_ACCESS rgAccessEntry[ACE_COUNT] = {0};
        OBJECTS_AND_SID rgObjectsAndSid[ACE_COUNT] = {0};
        
        if (!AllocateAndInitializeSid(&NtAuth,
                                                  2,
                                                  SECURITY_BUILTIN_DOMAIN_RID,
                                                  DOMAIN_ALIAS_RID_ADMINS,
                                                  0, 0, 0, 0, 0, 0,
                                                  &psidAdmins  ) )
        {               
            DebugLog(( DEB_ERROR, "AllocateAndInitializeSid failed\n" ));
            *pdwErr = GetLastError( );
            rc=FALSE;
            goto done;
        }

        pAceSid[0] = pUserSID;
        pAceSid[1] = psidAdmins;

        for ( i = 0 ; i < ACE_COUNT; i++)
        {
                rgAccessEntry[i].grfAccessPermissions = GENERIC_ALL;
                rgAccessEntry[i].grfAccessMode = GRANT_ACCESS;
                rgAccessEntry[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

                // build the trustee structs
                //
                BuildTrusteeWithObjectsAndSid(&(rgAccessEntry[i].Trustee),
                                                  &(rgObjectsAndSid[i]),
                                                      NULL,
                                                      NULL,
                                                      pAceSid[i]);
        }

        // add the entries to the ACL
        //
        *pdwErr = SetEntriesInAcl( ACE_COUNT, rgAccessEntry, NULL, &pDacl );

        if( *pdwErr != 0 )
        {
                DebugLog(( DEB_ERROR, "SetEntriesInAcl() failed\n"  ));
                rc = FALSE;
                goto done;
        }

        // build a security descriptor and initialize it
        // in absolute format
        if( !InitializeSecurityDescriptor( pSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) )
        {
            DebugLog(( DEB_ERROR, "InitializeSecurityDescriptor() failed\n" ) );

            *pdwErr = GetLastError( );
            rc=FALSE;
            goto done;
        }

        // add DACL to security descriptor (must be in absolute format)
        
        if( !SetSecurityDescriptorDacl( pSecurityDescriptor,
                                            TRUE, // bDaclPresent
                                            pDacl,
                                            FALSE // bDaclDefaulted
                                                       ) )
        {
            DebugLog(( DEB_ERROR,  "SetSecurityDescriptorDacl() failed\n"  ));

            *pdwErr = GetLastError( );
            rc=FALSE;
            goto done;
        }


        // set the owner of the directory
        if( !SetSecurityDescriptorOwner( pSecurityDescriptor ,
                                             pUserSID ,
                                                 FALSE // bOwnerDefaulted
                                                   ) )
        {
            DebugLog(( DEB_ERROR, "SetSecurityDescriptorOwner() failed\n"  ));
            *pdwErr = GetLastError( );
            rc= FALSE;
            goto done;
        }

        if ( ! IsValidSecurityDescriptor( pSecurityDescriptor ) )
        {
            DebugLog(( DEB_ERROR , "BAD security desc\n") );
        }

        // build a SECURITY_ATTRIBUTES struct as argument for
        // CreateDirectory()
        
        securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);

        securityAttributes.lpSecurityDescriptor = pSecurityDescriptor;

        securityAttributes.bInheritHandle = FALSE;

        if( !CreateDirectory( szPath , &securityAttributes ) )
        {
            *pdwErr = GetLastError( );
            rc = FALSE;
            goto done;
        }       
        else
        {
            rc = TRUE;
        }

    }
    else
    {   
        // For local paths we don't need to set security
        // This is the same behavior as exposed thru tsuserex.dll, w2k
        if( !CreateDirectory( szPath , 0) )
        {
            *pdwErr = GetLastError( );
            rc = FALSE;
            goto done;
        }       
        else
        {
            rc = TRUE;
        }
    }

done:
    if( psidAdmins != NULL )
    {
        FreeSid( psidAdmins );
    }

    return rc;
}

/****************************************************************************\
*
* FUNCTION: TermServ_CreateHomePathAndACLit
*
* PURPOSE:  create the TS specific user home folder and ACL it such that only
*           user and Admins have access to it.
*
* PARAMS:   PGLOABLS, from which TSData and userSid are used
*
* RETURNS:  TRUE if all went ok
*           FALSE if a bad home dir path was specified.
*
* HISTORY:
*
*
\****************************************************************************/
BOOLEAN TermServ_CreateHomePathAndACLit( PGLOBALS pG )
{
    BOOLEAN     rc;
    DWORD       dwErr = NO_ERROR;
    BOOLEAN     pathIsLocal;
    DWORD       dwFileAttribs;
    WLX_TERMINAL_SERVICES_DATA  *pTSData;

    pTSData =    & pG->MuGlobals.TSData;

    DebugLog((DEB_ERROR, "pTSData->HomeDir = %ws \n", pTSData->HomeDir ));

    if (pTSData->HomeDir[0] == L'\0')
    {
        // no TS specific path, we are done.
        return TRUE;
    }

    // check for empty strings, which means no TS specific path.

    // decide if this is a UNC path to home dir or a local path
    if( pTSData->HomeDir[1] == TEXT( ':' ) && pTSData->HomeDir[2] == TEXT( '\\' ) )
    {
        pathIsLocal = TRUE;   // we have a string starting with something like "D:\"
    }
    else if ( pTSData->HomeDir[0] == TEXT( '\\' ) && pTSData->HomeDir[1] == TEXT( '\\' ) ) 
    {
        pathIsLocal = FALSE;  // we have a string like "\\", which means a UNC path
    }
    else
    {
        // we seem to have a bad path, set it to empty so that  
        // the default paths will be used by userenv's code for settin up
        // stuff
        pTSData->HomeDirDrive[0] = pTSData->HomeDir[0] = TEXT('\0');
        DebugLog((DEB_ERROR, "Bad path for Terminal Services home folder" ));

        return FALSE;
    }

    dwFileAttribs = GetFileAttributes( pTSData->HomeDir );
    
    if (dwFileAttribs == - 1)
    {
        dwErr = GetLastError();
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            // We need to create the home DIR here, userenv does not create home folders.
            rc = CreateFolderAndACLit_Worker(  pTSData->HomeDir , pG->UserProcessData.UserSid , &dwErr , pathIsLocal );
        }
        else
        {
            rc = FALSE;
        }
    }
    else if ( dwFileAttribs & FILE_ATTRIBUTE_DIRECTORY  )
    {
        DebugLog((DEB_WARN , ("Homedir folder already exists\n")));
        rc = TRUE;
    }
    else
    {
        // there is a file there, so we can't create a dir...
        DebugLog((DEB_ERROR , "File with the same name already exists: %s\n", pTSData->HomeDir ));
        rc = FALSE;
    }


    if (!rc)
    {
        DebugLog((DEB_ERROR, "TerminalServerCreatedirWorker() returned error = %d\n",dwErr ));

        // we seem to have a bad path, set it to empty so that  
        // the default paths will be used by userenv's code for settin up
        // stuff
        pTSData->HomeDirDrive[0] = pTSData->HomeDir[0] = TEXT('\0');
    }

    return rc;   
}


int
WINAPI
WlxLoggedOutSAS(
        PVOID                pWlxContext,
        DWORD                dwSasType,
        PLUID                pAuthenticationId,
        PSID                 pLogonSid,
        PDWORD               pdwOptions,
        PHANDLE              phToken,
        PWLX_MPR_NOTIFY_INFO pMprNotifyInfo,
        PVOID *              pProfile
        )
{
    PGLOBALS pGlobals;
    INT_PTR  result = 0;
    PWLX_PROFILE_V2_0 pWlxProfile;
    PUNICODE_STRING FlatUser ;
    PUNICODE_STRING FlatDomain ;
    NTSTATUS Status ;
    DWORD dwNewSasType;

    pGlobals = (PGLOBALS) pWlxContext;
    pGlobals->LogonSid = pLogonSid;

    if (ForceAutoLogon())
    {
        pGlobals->IgnoreAutoAdminLogon = FALSE;
    }
    else
    {
        pGlobals->IgnoreAutoAdminLogon = (*pdwOptions) & WLX_OPTION_IGNORE_AUTO_LOGON;
    }

    // Clear out user process information
    ZeroMemory(&pGlobals->UserProcessData, sizeof(pGlobals->UserProcessData));

    if (dwSasType == WLX_SAS_TYPE_AUTHENTICATED) {

       pGlobals->IgnoreAutoAdminLogon = TRUE;

       result = TSAuthenticatedLogon(pGlobals);

    } else {

        do {

            if (result == MSGINA_DLG_SMARTCARD_INSERTED) {

                dwNewSasType = WLX_SAS_TYPE_SC_INSERT;

            } else {

                dwNewSasType = dwSasType;
            }

            result = Logon(pGlobals, dwNewSasType );          

        } while (result == MSGINA_DLG_SMARTCARD_INSERTED || result == MSGINA_DLG_SMARTCARD_REMOVED);
    }
    if (result == MSGINA_DLG_SUCCESS)
    {
        DebugLog((DEB_TRACE, "Successful Logon of %ws\\%ws\n", pGlobals->Domain, pGlobals->UserName));

        *phToken = pGlobals->UserProcessData.UserToken;
        *pAuthenticationId = pGlobals->LogonId;
        *pdwOptions = 0;

        //
        // Set up the flat/UPN stuff:
        //
        pGlobals->FlatUserName = pGlobals->UserNameString ;
        pGlobals->FlatDomain = pGlobals->DomainString ;

        //
        // Since win2k domains and later support multiple language sets, and map
        // similar names to the same account for accessibility from non-nls
        // systems (e.g., a user account named "User" can be used to log on
        // as both "User" and "U-with-an-umlaut-ser", we need to always do 
        // this lookup to get the "real" name
        //


        if ( ImpersonateLoggedOnUser( pGlobals->UserProcessData.UserToken ) )
        {
            Status = LsaGetUserName( &FlatUser, &FlatDomain );

            if ( NT_SUCCESS( Status ) )
            {
                DuplicateUnicodeString( &pGlobals->FlatUserName, FlatUser );
                DuplicateUnicodeString( &pGlobals->FlatDomain, FlatDomain );

                if ( pGlobals->UserName[0] == L'\0' )
                {
                    //
                    // Weird case of UPN/SC, no UPN could be found.  Use
                    // the flat name
                    //

                    wcscpy( pGlobals->UserName, FlatUser->Buffer );
                    RtlInitUnicodeString( &pGlobals->UserNameString,
                                          pGlobals->UserName );
                }

                LsaFreeMemory( FlatUser->Buffer );
                LsaFreeMemory( FlatUser );
                LsaFreeMemory( FlatDomain->Buffer );
                LsaFreeMemory( FlatDomain );
            }

            RevertToSelf();
        }

        // TS Specific - Send the credentials used for logging on to TermSrv
        // These credentials are used by TermSrv to send back notification to the client
        // Do this only for remote sessions as this is not relevant for sessions logged on from active console
        if (!IsActiveConsoleSession()) {
            _WinStationUpdateClientCachedCredentials( pGlobals->Domain, pGlobals->UserName);
        }

        pMprNotifyInfo->pszUserName = DupString( pGlobals->FlatUserName.Buffer );
        pMprNotifyInfo->pszDomain = DupString(pGlobals->FlatDomain.Buffer );

        RevealPassword( &pGlobals->PasswordString );
        pMprNotifyInfo->pszPassword = DupString(pGlobals->Password);
        HidePassword( &pGlobals->Seed, &pGlobals->PasswordString);

        if (pGlobals->OldPasswordPresent)
        {
            RevealPassword( &pGlobals->OldPasswordString );
            pMprNotifyInfo->pszOldPassword = DupString(pGlobals->OldPassword);
            HidePassword( &pGlobals->OldSeed, &pGlobals->OldPasswordString);
        }
        else
        {
            pMprNotifyInfo->pszOldPassword = NULL;
        }

        DisplayPostShellLogonMessages(pGlobals);

        if ( !g_Console ) 
        {
            if ( ImpersonateLoggedOnUser( pGlobals->UserProcessData.UserToken ) )
            {
                TermServ_CreateHomePathAndACLit( pGlobals ); 
                RevertToSelf();
            }
        }

        pWlxProfile = (PWLX_PROFILE_V2_0) LocalAlloc(LMEM_FIXED,
                sizeof(WLX_PROFILE_V2_0));
        if (pWlxProfile)
        {
            DWORD  dwSize;
            TCHAR  szComputerName[MAX_COMPUTERNAME_LENGTH+1];
            BOOL   bDomainLogon = TRUE;

            //
            // See if we logged on locally vs domain (vs cached)
            // Optimized logon uses cached logon, but it should be treated
            // as an ordinary domain logon.
            //
            if ((pGlobals->Profile->UserFlags & LOGON_CACHED_ACCOUNT) &&
                (pGlobals->OptimizedLogonStatus != OLS_LogonIsCached)) {
                bDomainLogon = FALSE;
            } else {
                dwSize = MAX_COMPUTERNAME_LENGTH+1;
                if (GetComputerName (szComputerName, &dwSize)) {
                    if (!lstrcmpi (pGlobals->Domain, szComputerName)) {
                        DebugLog((DEB_TRACE, "WlxLoggedOutSAS:  User logged on locally.\n"));
                        bDomainLogon = FALSE;
                    }
                }
            }

            pWlxProfile->dwType = WLX_PROFILE_TYPE_V2_0;
            pWlxProfile->pszProfile = AllocAndExpandProfilePath(pGlobals, pMprNotifyInfo->pszUserName);
            pWlxProfile->pszPolicy = (bDomainLogon ? AllocPolicyPath(pGlobals) : NULL);
            pWlxProfile->pszNetworkDefaultUserProfile =
                         (bDomainLogon ? AllocNetDefUserProfilePath(pGlobals) : NULL);
            pWlxProfile->pszServerName = (bDomainLogon ? AllocServerName(pGlobals) : NULL);
            pWlxProfile->pszEnvironment = AllocVolatileEnvironment(pGlobals);
        }

        *pProfile = (PVOID) pWlxProfile;
        return(WLX_SAS_ACTION_LOGON);
    }
    else if (DLG_SHUTDOWN(result))
    {
        if (result & MSGINA_DLG_REBOOT_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_REBOOT);
        }
        else if (result & MSGINA_DLG_POWEROFF_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_POWER_OFF);
        }
        else if (result & MSGINA_DLG_SLEEP_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_SLEEP);
        }
        else if (result & MSGINA_DLG_SLEEP2_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_SLEEP2);
        }
        else if (result & MSGINA_DLG_HIBERNATE_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_HIBERNATE);
        }
        else
            return(WLX_SAS_ACTION_SHUTDOWN);
    }
    else if ( result == MSGINA_DLG_USER_LOGOFF ) {
        return( WLX_SAS_ACTION_LOGOFF );
    }
    else if (result == MSGINA_DLG_SWITCH_CONSOLE)
    {
        return (WLX_SAS_ACTION_SWITCH_CONSOLE);
    }
    else
    {
        if ( pGlobals->RasUsed )
        {
            //
            // Shut down RAS connections on auth failure.
            //

            HangupRasConnections( pGlobals );

        }
        return(WLX_SAS_ACTION_NONE);
    }
}


int
WINAPI
WlxLoggedOnSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType,
    PVOID                   pReserved
    )
{
    PGLOBALS            pGlobals;
    INT_PTR             Result;
    DWORD               dwType ;
    DWORD               cbData ;
    DWORD               dwValue ;
    BOOL                OkToLock = TRUE ;
    HKEY                hkeyPolicy ;

    pGlobals = (PGLOBALS) pWlxContext;

    if ( pGlobals->SmartCardOption &&
         dwSasType == WLX_SAS_TYPE_SC_REMOVE &&
         pGlobals->SmartCardLogon )
    {

        dwValue = 0;
        cbData = sizeof(dwValue);
        RegQueryValueEx(
            WinlogonKey, DISABLE_LOCK_WKSTA,
            0, &dwType, (LPBYTE)&dwValue, &cbData);

        if (dwValue)
        {
            OkToLock = FALSE ;
        }


        if (OpenHKeyCurrentUser(pGlobals)) {

            if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser,
                             WINLOGON_POLICY_KEY,
                             0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
            {
                 dwValue = 0;
                 cbData = sizeof(dwValue);
                 RegQueryValueEx(hkeyPolicy, DISABLE_LOCK_WKSTA,
                                 0, &dwType, (LPBYTE)&dwValue, &cbData);

                 if (dwValue)
                 {
                     OkToLock = FALSE ;
                 }

                 RegCloseKey( hkeyPolicy );
            }

            CloseHKeyCurrentUser(pGlobals);
        }

        if ( OkToLock)
        {
            if ( pGlobals->SmartCardOption == 1 )
            {
                return WLX_SAS_ACTION_LOCK_WKSTA ;
            }
            else if ( pGlobals->SmartCardOption == 2 )
            {
                return WLX_SAS_ACTION_FORCE_LOGOFF ;
            }
        }
        else
        {
            return WLX_SAS_ACTION_NONE ;
        }

    }
    if ( dwSasType != WLX_SAS_TYPE_CTRL_ALT_DEL ) {

        return( WLX_SAS_ACTION_NONE );
    }

    Result = SecurityOptions(pGlobals);

    DebugLog((DEB_TRACE, "Result from SecurityOptions is %d (%#x)\n", Result, Result));

    switch (Result & ~MSGINA_DLG_FLAG_MASK)
    {
        case MSGINA_DLG_SUCCESS:
        case MSGINA_DLG_FAILURE:
        default:
            return(WLX_SAS_ACTION_NONE);

        case MSGINA_DLG_LOCK_WORKSTATION:
            return(WLX_SAS_ACTION_LOCK_WKSTA);

        case MSGINA_DLG_TASKLIST:
            return(WLX_SAS_ACTION_TASKLIST);

        case MSGINA_DLG_USER_LOGOFF:
            return(WLX_SAS_ACTION_LOGOFF);

        case MSGINA_DLG_FORCE_LOGOFF:
            return(WLX_SAS_ACTION_FORCE_LOGOFF);

        case MSGINA_DLG_SHUTDOWN:
            if (Result & MSGINA_DLG_REBOOT_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_REBOOT);
            }
            else if (Result & MSGINA_DLG_POWEROFF_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_POWER_OFF);
            }
            else if (Result & MSGINA_DLG_SLEEP_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_SLEEP);
            }
            else if (Result & MSGINA_DLG_SLEEP2_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_SLEEP2);
            }
            else if (Result & MSGINA_DLG_HIBERNATE_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_HIBERNATE);
            }
            else
                return(WLX_SAS_ACTION_SHUTDOWN);
    }


}

BOOL
WINAPI
WlxIsLockOk(
    PVOID                   pWlxContext
    )
{
    PGLOBALS pGlobals = (PGLOBALS) pWlxContext ;

        // Stop filtering SC events so SC unlock works
    pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_USE_SMART_CARD,
                             1,
                             NULL
                            );

    return(TRUE);
}

BOOL
WINAPI
WlxIsLogoffOk(
    PVOID                   pWlxContext
    )
{
    return(TRUE);
}


VOID
WINAPI
WlxLogoff(
    PVOID                   pWlxContext
    )
{
    PGLOBALS    pGlobals;

    pGlobals = (PGLOBALS) pWlxContext;

    pGlobals->UserName[0] = L'\0';

    pGlobals->UserProcessData.UserToken = NULL;
    if (pGlobals->UserProcessData.RestrictedToken != NULL)
    {
        NtClose(pGlobals->UserProcessData.RestrictedToken);
        pGlobals->UserProcessData.RestrictedToken = NULL;

    }

    if ( pGlobals->FlatUserName.Buffer != pGlobals->UserNameString.Buffer )
    {
        LocalFree( pGlobals->FlatUserName.Buffer );
    }

    if ( pGlobals->FlatDomain.Buffer != pGlobals->DomainString.Buffer )
    {
        LocalFree( pGlobals->FlatDomain.Buffer );
    }

    if (pGlobals->UserProcessData.UserSid != NULL)
    {
        LocalFree(pGlobals->UserProcessData.UserSid);
    }

    FreeSecurityDescriptor(pGlobals->UserProcessData.NewThreadTokenSD);
    pGlobals->UserProcessData.NewThreadTokenSD = NULL;

    if (pGlobals->UserProcessData.pEnvironment) {
        VirtualFree(pGlobals->UserProcessData.pEnvironment, 0, MEM_RELEASE);
        pGlobals->UserProcessData.pEnvironment = NULL;
    }

    pGlobals->UserProcessData.Flags = 0 ;

    if ( pGlobals->DnsDomain )
    {
        LocalFree( pGlobals->DnsDomain );

        pGlobals->DnsDomain = NULL ;
    }

    if (pGlobals->Profile)
    {
        LsaFreeReturnBuffer(pGlobals->Profile);
    }

    //
    // No need to zero/NULL pGlobals->OldPassword since it's hashed
    //

    pGlobals->OldPasswordPresent = 0;

    // reset transfered credentials flag.

    pGlobals->TransderedCredentials = FALSE;


    //
    // Only handle AutoAdminLogon if on the console
    //

    if (!g_Console)
    {
        return;
    }

    if (GetProfileInt( APPLICATION_NAME, TEXT("AutoAdminLogon"), 0))
    {
        //
        // If this is auto admin logon, generate a fake SAS right now.
        //

        pWlxFuncs->WlxSasNotify(pGlobals->hGlobalWlx, WLX_SAS_TYPE_CTRL_ALT_DEL);
    }

    return;
}


VOID
WINAPI
WlxShutdown(
    PVOID                   pWlxContext,
    DWORD                   ShutdownType
    )
{
    //
    // Initialize consumer windows changes
    //
    _Shell_Terminate();
    return;
}

BOOL
WINAPI
WlxScreenSaverNotify(
    PVOID                   pWlxContext,
    BOOL *                  fSecure)
{

    if (*fSecure)
    {       // If it is a secure screen saver,
            // this is equivalent to a lock
        *fSecure = WlxIsLockOk(pWlxContext);
    }

    return( TRUE );
}

BOOL
WINAPI
WlxNetworkProviderLoad(
    PVOID pWlxContext,
    PWLX_MPR_NOTIFY_INFO pMprNotifyInfo
    )
{
    PGLOBALS    pGlobals;

    pGlobals = (PGLOBALS) pWlxContext;

    pMprNotifyInfo->pszUserName = DupString(pGlobals->UserName);

    pMprNotifyInfo->pszDomain = DupString(pGlobals->Domain);

    RevealPassword( &pGlobals->PasswordString );
    pMprNotifyInfo->pszPassword = DupString(pGlobals->Password);
    HidePassword( &pGlobals->Seed, &pGlobals->PasswordString);

    if (pGlobals->OldPasswordPresent)
    {
        RevealPassword( &pGlobals->OldPasswordString );
        pMprNotifyInfo->pszOldPassword = DupString(pGlobals->OldPassword);
        HidePassword( &pGlobals->OldSeed, &pGlobals->OldPasswordString);
    }
    else
    {
        pMprNotifyInfo->pszOldPassword = NULL;
    }

    return TRUE ;
}

VOID
WINAPI
WlxReconnectNotify(
    PVOID                   pWlxContext)
{
    _Shell_Reconnect();
}

VOID
WINAPI
WlxDisconnectNotify(
    PVOID                   pWlxContext)
{
    _Shell_Disconnect();
}

//+---------------------------------------------------------------------------
//
//  Function:   GetErrorDescription
//
//  Synopsis:   Returns the message from ntdll corresponding to the status
//              code.
//
//  Arguments:  [ErrorCode]       --
//              [Description]     --
//              [DescriptionSize] --
//
//  History:    5-02-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
GetErrorDescription(
    DWORD   ErrorCode,
    LPWSTR  Description,
    DWORD   DescriptionSize
    )
{
    HMODULE Module ;
    //
    // First, try to determine what kind of error code it is:
    //

    //
    // Some people disguise win32 error codes in HRESULTs.  While
    // this is annoying, it can be handled.
    //

    if ( ( ErrorCode & 0xFFFF0000 ) == 0x80070000 )
    {
        ErrorCode = ErrorCode & 0x0000FFFF ;
    }

    if ( (ErrorCode > 0) && (ErrorCode < 0x00010000) )
    {
        //
        // Looks like a winerror:
        //

        Module = GetModuleHandle( TEXT("kernel32.dll") );
    }
    else if ( (0xC0000000 & ErrorCode ) == 0xC0000000 )
    {
        //
        // Looks like an NT status
        //

        Module = GetModuleHandle( TEXT("ntdll.dll" ) );
    }
    else
    {
        Module = GetModuleHandle( TEXT("kernel32.dll" ) );
    }

    return FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_HMODULE,
                          (LPCVOID) Module,
                          ErrorCode,
                          0,
                          Description,
                          DescriptionSize,
                          NULL );

}




/*=============================================================================
==   Local Procedures Defined
=============================================================================*/

/******************************************************************************
 *
 *  FreeAutoLogonInfo
 *
 *   Free WLX_CLIENT_CREDENTAILS_INFO and data strings returned
 *   from winlogon.
 *
 *  ENTRY:
 *     pGlobals (input)
 *        pointer to GLOBALS struct
 *
 *  EXIT:
 *     nothing
 *
 *****************************************************************************/

VOID
FreeAutoLogonInfo( PGLOBALS pGlobals )
{
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pAutoLogon;

    pAutoLogon = pGlobals->MuGlobals.pAutoLogon;

    if( pAutoLogon == NULL ) {
        return;
    }

    if ( pAutoLogon->pszUserName ) {
        LocalFree( pAutoLogon->pszUserName );
    }
    if ( pAutoLogon->pszDomain ) {
        LocalFree( pAutoLogon->pszDomain );
    }
    if ( pAutoLogon->pszPassword ) {
        LocalFree( pAutoLogon->pszPassword );
    }

    LocalFree( pAutoLogon );

    pGlobals->MuGlobals.pAutoLogon = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\mslogon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mslogon.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-24-94   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef _MSLOGONH_
#define _MSLOGONH_


INT_PTR
Logon(
    PGLOBALS pGlobals,
    DWORD SasType
    );

DWORD 
GetPasswordExpiryWarningPeriod (
    VOID
    );

BOOL
GetDaysToExpiry (
    IN PLARGE_INTEGER StartTime,
    IN PLARGE_INTEGER ExpiryTime,
    OUT PDWORD DaysToExpiry
    );

BOOL
ShouldPasswordExpiryWarningBeShown(
    PGLOBALS    pGlobals,
    BOOL        LogonCheck,
    PDWORD      pDaysToExpiry
    );

INT_PTR
CheckPasswordExpiry(
    PGLOBALS    pGlobals,
    BOOL        LogonCheck
    );

INT_PTR
DisplayPostShellLogonMessages(
    PGLOBALS    pGlobals
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\options.c ===
/****************************** Module Header ******************************\
* Module Name: options.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implementation of functions to support security options dialog.
*
* History:
* 12-05-91 Davidc       Created.
\***************************************************************************/

#include "msgina.h"
#include "shtdnp.h"

#include <stdio.h>
#include <wchar.h>

#pragma hdrstop

#define CTRL_TASKLIST_SHELL

#define LPTSTR  LPWSTR

#define BOOLIFY(expr)           (!!(expr))

//
// Private prototypes
//

INT_PTR WINAPI
OptionsDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL OptionsDlgInit(HWND);

INT_PTR WINAPI
EndWindowsSessionDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

/******************************************************************************
 *
 *  HandleFailedDisconnect
 *
 *   Tell the user why the disconnect from the current Logon failed.
 *
 *  ENTRY:
 *      hDlg (input)
 *          This dialog's window handle.
 *      SessionId (input)
 *          The user's current SessionId.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID
HandleFailedDisconnect( HWND hDlg,
                        ULONG SessionId,
                        PGLOBALS pGlobals )
{
    DWORD Error;
    TCHAR Buffer1[MAX_STRING_BYTES];
    TCHAR Buffer2[MAX_STRING_BYTES];
    TCHAR Buffer3[MAX_STRING_BYTES];

    Error = GetLastError();
    switch (Error) {

        default:
            LoadString( hDllInstance, IDS_MULTIUSER_UNEXPECTED_DISCONNECT_FAILURE,
                        Buffer1, MAX_STRING_BYTES );
            FormatMessage(
                   FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL, Error, 0, Buffer3, MAX_STRING_BYTES, NULL );

            _snwprintf(Buffer2, MAX_STRING_BYTES, Buffer1, SessionId, Buffer3);

            LoadString( hDllInstance, IDS_MULTIUSER_DISCONNECT_FAILED,
                        Buffer1, MAX_STRING_BYTES );

            TimeoutMessageBoxlpstr( hDlg, pGlobals,  Buffer2,
                                    Buffer1,
                                    MB_OK | MB_ICONEXCLAMATION,
                                    TIMEOUT_CURRENT );
            break;
    }
}


/***************************************************************************\
* SecurityOptions
*
* Show the user the security options dialog and do what they ask.
*
* Returns:
*     MSGINA_DLG_SUCCESS if everything went OK and the user wants to continue
*     DLG_LOCK_WORKSTAION if the user chooses to lock the workstation
*     DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*     MSGINA_DLG_FAILURE if the dialog cannot be brought up.
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

INT_PTR
SecurityOptions(
    PGLOBALS pGlobals)
{
    int Result;

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, OPTIONS_TIMEOUT);

    Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR)IDD_OPTIONS_DIALOG,
                                            NULL,
                                            OptionsDlgProc,
                                            (LPARAM) pGlobals);

    if (Result == WLX_DLG_INPUT_TIMEOUT)
    {
        Result = MSGINA_DLG_SUCCESS;
    }

    return(Result);
}



/***************************************************************************\
*
* FUNCTION: OptionsDlgProc
*
* PURPOSE:  Processes messages for Security options dialog
*
\***************************************************************************/

INT_PTR WINAPI
OptionsDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    INT_PTR Result;
    HANDLE  UserHandle;
    NTSTATUS Status;
    BOOL EnableResult;
    BOOL ControlKey;


    switch (message) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

            if (!OptionsDlgInit(hDlg))
            {
                EndDialog(hDlg, MSGINA_DLG_FAILURE);
            }
            return(TRUE);

        case WLX_WM_SAS:

            //
            // If this is someone hitting C-A-D, swallow it.
            //
            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
            {
                return(TRUE);
            }

            //
            // Other SAS's (like timeout), return FALSE and let winlogon
            // deal with it.
            //
            DebugLog((DEB_TRACE, "Received SAS event %d, which we're letting winlogon cope with\n", wParam));
            return(FALSE);

        case WM_COMMAND:

            ControlKey = (GetKeyState(VK_LCONTROL) < 0) ||
                         (GetKeyState(VK_RCONTROL) < 0) ;

            switch (LOWORD(wParam))
            {

                case IDCANCEL:
                    EndDialog(hDlg, MSGINA_DLG_SUCCESS);
                    return TRUE;

                case IDD_OPTIONS_CHANGEPWD:
                    Result = ChangePassword(hDlg,
                                            pGlobals,
                                            pGlobals->UserName,
                                            pGlobals->Domain,
                                            CHANGEPWD_OPTION_ALL );

                    if (DLG_INTERRUPTED(Result))
                    {
                        EndDialog(hDlg, Result);
                    }
                    return(TRUE);

                case IDD_OPTIONS_LOCK:
                    EndDialog(hDlg, MSGINA_DLG_LOCK_WORKSTATION);
                    return(TRUE);

                case IDD_OPTIONS_LOGOFF:

                    if (ControlKey)
                    {
                        Result = TimeoutMessageBox(hDlg,
                                           pGlobals,
                                           IDS_LOGOFF_LOSE_CHANGES,
                                           IDS_LOGOFF_TITLE,
                                           MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONSTOP,
                                           TIMEOUT_CURRENT);

                        if (Result == MSGINA_DLG_SUCCESS)
                        {
                            EndDialog(hDlg, MSGINA_DLG_FORCE_LOGOFF);
                        }
                    }
                    else
                    {

                        //
                        // Confirm the user really knows what they're doing.
                        //
                        Result = pWlxFuncs->WlxDialogBoxParam(
                                            pGlobals->hGlobalWlx,
                                            hDllInstance,
                                            MAKEINTRESOURCE(IDD_LOGOFFWINDOWS_DIALOG),
                                            hDlg,
                                            EndWindowsSessionDlgProc,
                                            (LPARAM)pGlobals);

                        if (Result == MSGINA_DLG_SUCCESS)
                        {
                            EndDialog(hDlg, MSGINA_DLG_USER_LOGOFF);
                        }
                    }

                    return(TRUE);

                case IDD_OPTIONS_SHUTDOWN:

                    //
                    // If they held down Ctrl while selecting shutdown - then
                    // we'll do a quick and dirty reboot.
                    // i.e. we skip the call to ExitWindows
                    //

                    if ( ControlKey && TestUserPrivilege(pGlobals->UserProcessData.UserToken, SE_SHUTDOWN_PRIVILEGE))
                    {
                        //
                        // Check they know what they're doing
                        //

                        Result = TimeoutMessageBox(hDlg,
                                           pGlobals,
                                           IDS_REBOOT_LOSE_CHANGES,
                                           IDS_EMERGENCY_SHUTDOWN,
                                           MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONSTOP,
                                           TIMEOUT_CURRENT);
                        if (Result == MSGINA_DLG_SUCCESS)
                        {
                            //
                            // Impersonate the user for the shutdown call
                            //

                            UserHandle = ImpersonateUser( &pGlobals->UserProcessData, NULL );
                            ASSERT(UserHandle != NULL);

                            if ( UserHandle )
                            {

                                //
                                // Enable the shutdown privilege
                                // This should always succeed - we are either system or a user who
                                // successfully passed the privilege check in ExitWindowsEx.
                                //

                                EnableResult = EnablePrivilege(SE_SHUTDOWN_PRIVILEGE, TRUE);
                                ASSERT(EnableResult);


                                //
                                // Do the final system shutdown pass (reboot).  Note, if
                                // the privilege was not enabled, the API will reject this
                                // call.
                                //

                                Status = NtShutdownSystem(ShutdownReboot);
                            }
                        }

                        if (Result != MSGINA_DLG_FAILURE)
                        {
                            EndDialog(hDlg, Result);
                        }

                        return(TRUE);
                    }
                             

                    //
                    // This is a normal shutdown request
                    //
                    // Check they know what they're doing and find
                    // out if they want to reboot too.
                    //

                    Result = WinlogonShutdownDialog(hDlg, pGlobals, 0);

                    // Pre-filter the Disconnect option and handle
                    // it now since it may fail
                    
                    if (Result == MSGINA_DLG_DISCONNECT)
                    {
                        if ( pWlxFuncs->WlxDisconnect() ) 
                        {
                            Result = MSGINA_DLG_SUCCESS;
                        } 
                        else 
                        {
                            HandleFailedDisconnect(hDlg, pGlobals->MuGlobals.SessionId, pGlobals);
                            Result = MSGINA_DLG_FAILURE;
                        }
                    }

                    if (Result != MSGINA_DLG_FAILURE)
                    {
                        EndDialog(hDlg, Result);
                    }

                    return(TRUE);


                case IDD_OPTIONS_TASKLIST:


                    EndDialog(hDlg, MSGINA_DLG_TASKLIST);

                    //
                    // Tickle the messenger so it will display any queue'd messages.
                    // (This call is a kind of NoOp).
                    //
                    NetMessageNameDel(NULL,L"");

                    return(TRUE);
                    break;

            }

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, FALSE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        }

    // We didn't process the message
    return(FALSE);
}


/****************************************************************************

FUNCTION: OptionsDlgInit

PURPOSE:  Handles initialization of security options dialog

RETURNS:  TRUE on success, FALSE on failure
****************************************************************************/

BOOL OptionsDlgInit(
    HWND    hDlg)
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    TCHAR    Buffer1[MAX_STRING_BYTES];
    TCHAR    Buffer2[MAX_STRING_BYTES];
    BOOL     Result;
    DWORD    dwValue, dwType;
    HKEY     hkeyPolicy;
    DWORD    cbData;
    HANDLE   hImpersonateUser = NULL;
    USHORT   Flags = FT_TIME|FT_DATE;
    LCID     locale;

    SetWelcomeCaption( hDlg );

    //
    // Set the logon info text
    //

    if (pGlobals->Domain[0] == TEXT('\0') )
    {

        //
        // there is no domain name
        //

        if ( lstrlen(pGlobals->UserFullName) == 0)
        {

            //
            // There is no full name
            //


            LoadString(hDllInstance, IDS_LOGON_EMAIL_NAME_NFN_INFO, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->UserName);


        }
        else
        {

            LoadString(hDllInstance, IDS_LOGON_EMAIL_NAME_INFO, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                          pGlobals->UserFullName,
                                                          pGlobals->UserName);

        }

    }
    else
    {
        if ( lstrlen(pGlobals->UserFullName) == 0)
        {

            //
            // There is no full name
            //

            LoadString(hDllInstance, IDS_LOGON_NAME_NFN_INFO, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                          pGlobals->UserName);

        }
        else
        {

            LoadString(hDllInstance, IDS_LOGON_NAME_INFO, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->UserFullName,
                                                          pGlobals->Domain,
                                                          pGlobals->UserName);

        }
    }

    SetDlgItemText(hDlg, IDD_OPTIONS_LOGON_NAME_INFO, Buffer2);

    //
    // Set the logon time/date - but do it as the logged on user
    //
    hImpersonateUser = ImpersonateUser(&pGlobals->UserProcessData, NULL);

    locale = GetUserDefaultLCID();

    if (((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC)
        || (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW)))
        {
            // Get the real item windows ExStyle.
            HWND hWnd = GetDlgItem(hDlg, IDD_OPTIONS_LOGON_DATE);
            DWORD dwExStyle = GetWindowLong(hWnd, GWL_EXSTYLE);
            
            if ((BOOLIFY(dwExStyle & WS_EX_RTLREADING)) != (BOOLIFY(dwExStyle & WS_EX_LAYOUTRTL)))
                Flags |= FT_RTL;
            else
                Flags |= FT_LTR;
        }

    Result = FormatTime(&pGlobals->LogonTime, Buffer1, sizeof(Buffer1) / sizeof(Buffer1[0]), Flags);
    if (hImpersonateUser)
    {
        StopImpersonating(hImpersonateUser);
    }

    ASSERT(Result);
    SetDlgItemText(hDlg, IDD_OPTIONS_LOGON_DATE, Buffer1);


    //
    // Check if DisableLockWorkstation is set for the entire machine
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY,
                     0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
    {
         dwValue = 0;
         cbData = sizeof(dwValue);
         RegQueryValueEx(hkeyPolicy, DISABLE_LOCK_WKSTA,
                         0, &dwType, (LPBYTE)&dwValue, &cbData);

         if (dwValue)
         {
            EnableDlgItem(hDlg, IDD_OPTIONS_LOCK, FALSE);
         }

        RegCloseKey(hkeyPolicy);
    }

    //
    //  Smart card only users can't change the password
    //
    if (pGlobals->Profile && (pGlobals->Profile->UserFlags & UF_SMARTCARD_REQUIRED))
    {
        EnableDlgItem(hDlg, IDD_OPTIONS_CHANGEPWD, FALSE);
    }

    //
    //  Check for policy and then disable corresponding options
    //

    if (OpenHKeyCurrentUser(pGlobals)) {

        if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser,
                         WINLOGON_POLICY_KEY,
                         0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
        {
             dwValue = 0;
             cbData = sizeof(dwValue);
             RegQueryValueEx(hkeyPolicy, DISABLE_LOCK_WKSTA,
                             0, &dwType, (LPBYTE)&dwValue, &cbData);

             if (dwValue)
             {
                EnableDlgItem(hDlg, IDD_OPTIONS_LOCK, FALSE);
             }


             dwValue = 0;
             cbData = sizeof(dwValue);
             RegQueryValueEx(hkeyPolicy, DISABLE_TASK_MGR,
                             0, &dwType, (LPBYTE)&dwValue, &cbData);

             if (dwValue)
             {
                EnableDlgItem(hDlg, IDD_OPTIONS_TASKLIST, FALSE);
                ShowDlgItem(hDlg, IDD_OPTIONS_TASKMGR_TEXT, FALSE);
             }


             dwValue = 0;
             cbData = sizeof(dwValue);
             RegQueryValueEx(hkeyPolicy, DISABLE_CHANGE_PASSWORD,
                             0, &dwType, (LPBYTE)&dwValue, &cbData);

             if (dwValue)
             {
                EnableDlgItem(hDlg, IDD_OPTIONS_CHANGEPWD, FALSE);
             }


             RegCloseKey(hkeyPolicy);
        }

        if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser, EXPLORER_POLICY_KEY,
                         0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
        {
             dwValue = 0;
             cbData = sizeof(dwValue);
             RegQueryValueEx(hkeyPolicy, NOLOGOFF,
                             0, &dwType, (LPBYTE)&dwValue, &cbData);

             if (dwValue)
             {
                EnableDlgItem(hDlg, IDD_OPTIONS_LOGOFF, FALSE);
             }

             dwValue = 0;
             cbData = sizeof(dwValue);

             RegQueryValueEx(hkeyPolicy, NOCLOSE,
                             0, &dwType, (LPBYTE)&dwValue, &cbData);

            //
            // If this is not the system console, check the appropriate key in registry
            //
            if ( !g_Console ) {
                if (!TestUserPrivilege(pGlobals->UserProcessData.UserToken, SE_SHUTDOWN_PRIVILEGE)) {
                    RegQueryValueEx(hkeyPolicy, NODISCONNECT,
                                     0, &dwType, (LPBYTE)&dwValue, &cbData);
                }
            }

             if (dwValue)
             {
                EnableDlgItem(hDlg, IDD_OPTIONS_SHUTDOWN, FALSE);
             }
             RegCloseKey(hkeyPolicy);
        }

        CloseHKeyCurrentUser(pGlobals);
    }

    // Position ourselves nicely
    SizeForBranding(hDlg, FALSE);
    CentreWindow(hDlg);

    return TRUE;
}

/***************************************************************************\
* FUNCTION: EndWindowsSessionDlgProc
*
* PURPOSE:  Processes messages for Logging off Windows Nt confirmation dialog
*
* RETURNS:  MSGINA_DLG_SUCCESS     - The user wants to logoff.
*           MSGINA_DLG_FAILURE     - The user doesn't want to logoff.
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* HISTORY:
*
*   05-17-92 Davidc       Created.
*
\***************************************************************************/

INT_PTR WINAPI
EndWindowsSessionDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    switch (message)
    {

        case WM_INITDIALOG:
            {
            HICON hIcon;

            SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

            // Load the 48 x 48 version of the logoff icon
            hIcon = LoadImage (hDllInstance, MAKEINTRESOURCE(IDI_STLOGOFF),
                               IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDD_LOGOFFICON, STM_SETICON, (WPARAM) hIcon, 0);
            }

            // Position ourselves nicely
            CentreWindow(hDlg);

            }
            return(TRUE);

        case WLX_WM_SAS:

            //
            // If this is someone hitting C-A-D, swallow it.
            //
            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
            {
                return(TRUE);
            }

            //
            // Other SAS's (like timeout), return FALSE and let winlogon
            // deal with it.
            //
            return(FALSE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {

                case IDOK:
                    EndDialog(hDlg, MSGINA_DLG_SUCCESS);
                    return(TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, MSGINA_DLG_FAILURE);
                    return(TRUE);
            }
            break;
    }

    // We didn't process the message
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\mslogon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mslogon.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include "shtdnp.h"
#include "authmon.h"
#include <stdio.h>
#include <wchar.h>
#include <wincrypt.h>
#include <sclogon.h>
#include "shlwapi.h"
#include "shlwapip.h"

#include "winsta.h"
#include "wtsapi32.h"
#include <keymgr.h>
#include <passrec.h>

typedef void (WINAPI *RUNDLLPROC)(HWND hWndStub,HINSTANCE hInstance,LPWSTR szCommandLine,int nShow);

typedef struct _MSGINA_LOGON_PARAMETERS {
    PGLOBALS pGlobals;
    DWORD SasType;
} MSGINA_LOGON_PARAMETERS, * PMSGINA_LOGON_PARAMETERS ;

#define WINSTATIONS_DISABLED    TEXT("WinStationsDisabled")

//
// Number of seconds we will display the legal notices
// before timing out.
//

#define LEGAL_NOTICE_TIMEOUT        120

#define LOGON_SLEEP_PERIOD          750

#define WM_LOGONPROMPT              WM_USER + 257
#define WM_LOGONCOMPLETE            WM_USER + 258

#define WM_HANDLEFAILEDLOGON        WM_USER + 259
#define WM_DCACHE_COMPLETE          WM_USER + 260

#define MAX_CAPTION_LENGTH  256

// Maximum size of a UPN name we allow at present
#define MAX_UPN_NAME_SIZE   520

typedef struct FAILEDLOGONINFO_t
{
    PGLOBALS pGlobals;
    NTSTATUS Status;
    NTSTATUS SubStatus;
    TCHAR   UserName[UNLEN + DNLEN + 2];
    TCHAR   Domain[DNLEN + 1];
} FAILEDLOGONINFO, *PFAILEDLOGONINFO;


typedef struct _LEGALINFO
{
    LPTSTR NoticeText;
    LPTSTR CaptionText;
} LEGALINFO, *PLEGALINFO;


// Also defined in wstrpc.c
#define INET_CONNECTOR_EVENT_NAME   L"Global\\TermSrvInetConnectorEvent"

#define TERMSERV_EVENTSOURCE        L"TermService"

// Also defined in icaevent.mc
#define EVENT_BAD_TSINTERNET_USER   1007

//
// Globals:
//
static WNDPROC OldCBWndProc;

HICON   hSteadyFlag;
HICON   hWavingFlag;
HICON   hAuditFull;

extern HICON   hLockedIcon;
BOOL    IsPswBackupAvailable;
BOOL    s_fAttemptedAutoLogon;

BOOL    g_fHelpAssistantLogon = FALSE;

//
// Prototypes:
//


INT_PTR
DisplayLegalNotices(
    PGLOBALS pGlobals
    );

BOOL
GetLegalNotices(
    LPTSTR lpSubKey,
    LPTSTR *NoticeText,
    LPTSTR *CaptionText
    );

INT_PTR WINAPI
LogonDlgCBProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

INT_PTR WINAPI
LogonDlgUsernameProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

INT_PTR WINAPI
LogonDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
LogonDlgInit(
    HWND    hDlg,
    BOOL    bAutoLogon,
    DWORD   SasType
    );

NTSTATUS
UpnFromCert(
    IN PCCERT_CONTEXT pCert,
    IN OUT DWORD       *pcUpn,
    IN OUT LPWSTR       pUPN
    );

BOOL
WINAPI
QuerySwitchConsoleCredentials(
    PGLOBALS pGlobals,
    HANDLE * phUserToken,
    PLUID    pLogonId);


// Global structure for a failed logon filled in by the worker thread to be consumed
// by the ui thread.
FAILEDLOGONINFO g_failinfo;

void PostFailedLogonMessage(HWND hDlg,
    PGLOBALS pGlobals,
    NTSTATUS Status,
    NTSTATUS SubStatus,
    PWCHAR UserName,
    PWCHAR Domain
    );

INT_PTR
HandleFailedLogon(
    HWND hDlg
    );

VOID
ReportBootGood(
    PGLOBALS pGlobals
    );

VOID LogonShowOptions(
    PGLOBALS pGlobals,
    HWND hDlg,
    BOOL fShow,
    BOOL fSticky);

VOID AttemptLogonSetControls(
    PGLOBALS pGlobals,
    HWND hDlg
    );

INT_PTR
AttemptLogon(
    HWND hDlg
    );

DWORD
AttemptLogonThread(
    PGLOBALS pGlobals
    );

BOOL
GetAndAllocateLogonSid(
    HANDLE hToken,
    PSID *pLogonSid
    );

BOOL GetSessionZeroUser(LPTSTR szUser);
BOOL FastUserSwitchingEnabled();


//
// control tables for showing/hiding options
//

static UINT ctrlNoShutdown[] =
{
    IDOK,
    IDCANCEL,
};

static UINT ctrlNoCancel[] =
{
    IDOK,
};

static UINT ctrlNoDomain[] =
{
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_LOGON_OPTIONS,
    IDD_LOGON_RASBOX,
    IDD_KBLAYOUT_ICON,
};

static UINT ctrlNoRAS[] =
{
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_LOGON_OPTIONS,
    IDD_KBLAYOUT_ICON,
};

static UINT ctrlNoOptions[] =
{
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_KBLAYOUT_ICON,
};

static UINT ctrlNoLegalBanner[] =
{
    IDD_LOGON_NAME_LABEL,
    IDD_LOGON_NAME,
    IDD_LOGON_PASSWORD_LABEL,
    IDD_LOGON_PASSWORD,
    IDD_LOGON_DOMAIN_LABEL,
    IDD_LOGON_DOMAIN,
    IDD_LOGON_RASBOX,
    IDD_KBLAYOUT_ICON,
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_LOGON_OPTIONS,
};

static UINT ctrlNoUserName[] =
{
    IDD_LOGON_PASSWORD_LABEL,
    IDD_LOGON_PASSWORD,
    IDD_LOGON_DOMAIN_LABEL,
    IDD_LOGON_DOMAIN,
    IDD_LOGON_RASBOX,
    IDD_KBLAYOUT_ICON,
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_LOGON_OPTIONS,
};


//  --------------------------------------------------------------------------
//  ::DisableEditSubClassProc
//
//  Arguments:  hwnd        =   See the platform SDK under WindowProc.
//              uMsg        =   See the platform SDK under WindowProc.
//              wParam      =   See the platform SDK under WindowProc.
//              lParam      =   See the platform SDK under WindowProc.
//              uiID        =   ID assigned at subclass time.
//              dwRefData   =   reference data assigned at subclass time.
//
//  Returns:    LRESULT
//
//  Purpose:    comctl32 subclass callback function. This allows us to not
//              process WM_CUT/WM_COPY/WM_PASTE/WM_CLEAR/WM_UNDO and any
//              other messages to be discarded.
//
//  History:    2001-02-18  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CALLBACK    DisableEditSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData)

{
    LRESULT     lResult;

    switch (uMsg)
    {
        case WM_CUT:
        case WM_COPY:
        case WM_PASTE:
        case WM_CLEAR:
        case WM_UNDO:
        case WM_CONTEXTMENU:
            lResult = FALSE;
            break;
        default:
            lResult = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            break;
    }
    return(lResult);
}


INT_PTR WINAPI
LegalDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            PLEGALINFO pLegalInfo;

            pLegalInfo = (PLEGALINFO) lParam;

            SetWindowText (hDlg, pLegalInfo->CaptionText);
            SetWindowText (GetDlgItem(hDlg, IDD_LEGALTEXT), pLegalInfo->NoticeText);

            CentreWindow(hDlg);

            // Ensure the window is topmost so it's not obscured by the welcome screen.
            SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

            return( TRUE );
        }

        case WM_COMMAND:
            {
                if (LOWORD(wParam) == IDOK)
                {
                    EndDialog(hDlg, IDOK);
                }
            }
            break;
    }

    return FALSE;
}

/***************************************************************************\
* FUNCTION: DisplayLegalNotices
*
* PURPOSE:  Puts up a dialog box containing legal notices, if any.
*
* RETURNS:  MSGINA_DLG_SUCCESS     - the dialog was shown and dismissed successfully.
*           MSGINA_DLG_FAILURE     - the dialog could not be shown
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* HISTORY:
*
*   Robertre  6-30-93  Created
*
\***************************************************************************/

INT_PTR
DisplayLegalNotices(
    PGLOBALS pGlobals
    )
{
    INT_PTR Result = MSGINA_DLG_SUCCESS;
    LPTSTR NoticeText;
    LPTSTR CaptionText;
    LEGALINFO LegalInfo;

    if (GetLegalNotices( WINLOGON_POLICY_KEY, &NoticeText, &CaptionText ))
    {

        LegalInfo.NoticeText = NoticeText;
        LegalInfo.CaptionText = CaptionText;

        _Shell_LogonStatus_Hide();

        pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LEGAL_NOTICE_TIMEOUT);

        Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                                hDllInstance,
                                                (LPTSTR) IDD_LEGALMSG,
                                                NULL,
                                                LegalDlgProc,
                                                (LPARAM) &LegalInfo );

        _Shell_LogonStatus_Show();

        Free( NoticeText );
        Free( CaptionText );
    }
    else if (GetLegalNotices( WINLOGON_KEY, &NoticeText, &CaptionText ))
    {

        LegalInfo.NoticeText = NoticeText;
        LegalInfo.CaptionText = CaptionText;

        _Shell_LogonStatus_Hide();

        pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LEGAL_NOTICE_TIMEOUT);

        Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                                hDllInstance,
                                                (LPTSTR) IDD_LEGALMSG,
                                                NULL,
                                                LegalDlgProc,
                                                (LPARAM) &LegalInfo );

        _Shell_LogonStatus_Show();

        Free( NoticeText );
        Free( CaptionText );
    }

    return( Result );
}

/***************************************************************************\
* FUNCTION: GetLegalNotices
*
* PURPOSE:  Get legal notice information out of the registry.
*
* RETURNS:  TRUE - Output parameters contain valid data
*           FALSE - No data returned.
*
* HISTORY:
*
*   Robertre 6-30-93 Created
*
\***************************************************************************/
BOOL
GetLegalNotices(
    LPTSTR lpSubKey,
    LPTSTR *NoticeText,
    LPTSTR *CaptionText
    )
{
    LPTSTR lpCaption, lpText;
    HKEY hKey;
    DWORD dwSize, dwType, dwMaxSize = 0;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpSubKey,
                     0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL, NULL, &dwMaxSize,
                         NULL, NULL);

        lpCaption = Alloc (dwMaxSize);

        if (!lpCaption) {
            RegCloseKey(hKey);
            return FALSE;
        }


        lpText = Alloc (dwMaxSize);

        if (!lpText) {
            Free(lpCaption);
            RegCloseKey(hKey);
            return FALSE;
        }


        dwSize = dwMaxSize;
        RegQueryValueEx(hKey, LEGAL_NOTICE_CAPTION_KEY,
                        0, &dwType, (LPBYTE)lpCaption, &dwSize);

        dwSize = dwMaxSize;
        RegQueryValueEx(hKey, LEGAL_NOTICE_TEXT_KEY,
                        0, &dwType, (LPBYTE)lpText, &dwSize);

        RegCloseKey(hKey);


        if (*lpCaption && *lpText) {
            *CaptionText = lpCaption;
            *NoticeText = lpText;
            return TRUE;
        }

        Free(lpCaption);
        Free(lpText);
    }

    return FALSE;
}


/***************************************************************************\
* FUNCTION: Logon
*
* PURPOSE:  Display the logon UI depending on the SAS type.
*
* RETURNS:  -
*
* NOTES:    If the logon is successful, the global structure is filled in
*           with the logon information.
*
* HISTORY:
*   12-09-91 daviddv    Comments.
*
\***************************************************************************/

INT_PTR
Logon(
    PGLOBALS pGlobals,
    DWORD SasType
    )
{
    INT_PTR Result;
    MSGINA_LOGON_PARAMETERS Parm ;

    if ( SasType == WLX_SAS_TYPE_SC_REMOVE )
    {
        return WLX_SAS_ACTION_NONE ;
    }

    if( !g_Console )
    {
        //
        // Check if current session is HelpAssistant Session, HelpAssisant
        // session can not be console session.
        //
        g_fHelpAssistantLogon = WinStationIsHelpAssistantSession(
                                                            SERVERNAME_CURRENT,
                                                            LOGONID_CURRENT
                                                        );
    }
        

    if ( SasType == WLX_SAS_TYPE_SC_INSERT )
    {
        PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

        pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                 WLX_OPTION_SMART_CARD_INFO,
                                 (ULONG_PTR *) &ScInfo );

        //
        // Validate the SC info against some common user
        // errors before the PIN dialog appears
        //

        if ( ScInfo )
        {
            if ( ( ScInfo->pszReader ) &&
                 ( ScInfo->pszCard == NULL ) )
            {
                //
                // The card could not be read.  Might not be
                // inserted correctly.
                //

                LocalFree(ScInfo);

                TimeoutMessageBox( NULL, pGlobals, IDS_CARD_NOT_RECOGNIZED,
                                        IDS_LOGON_MESSAGE,
                                        MB_OK | MB_ICONEXCLAMATION,
                                        LOGON_TIMEOUT );

                return WLX_SAS_ACTION_NONE;
            }

            if ( ( ScInfo->pszReader ) &&
                 ( ScInfo->pszCryptoProvider == NULL ) )
            {
                //
                // Got a card, but the CSP for it could not be
                // found.
                //

                LocalFree(ScInfo);

                TimeoutMessageBox( NULL, pGlobals, IDS_CARD_CSP_NOT_RECOGNIZED,
                                        IDS_LOGON_MESSAGE,
                                        MB_OK | MB_ICONEXCLAMATION,
                                        LOGON_TIMEOUT );

                return WLX_SAS_ACTION_NONE;
            }

            LocalFree(ScInfo);
        }
    }

    //
    // Asynchronously update domain cache if necessary.
    // We won't ask to wait so this routine will do no UI.
    // i.e. we can ignore the result.
    //
//  Result = UpdateDomainCache(pGlobals, NULL, FALSE);
//  ASSERT(!DLG_INTERRUPTED(Result));

    if( !g_fHelpAssistantLogon ) {
        //
        // See if there are legal notices in the registry.
        // If so, put them up in a message box
        //
        Result = DisplayLegalNotices( pGlobals );
        if ( Result != MSGINA_DLG_SUCCESS ) {
            return(WLX_SAS_ACTION_NONE);
        }
        //
        // Get the latest audit log status and store in our globals
        // If the audit log is full we show a different logon dialog.
        //
        GetAuditLogStatus(pGlobals);
    } else {
        //
        // fake it so audit log is not full, setting is from GetAuditLogStatus()
        //
        pGlobals->AuditLogFull = FALSE;
        pGlobals->AuditLogNearFull = FALSE;
    }

    Parm.pGlobals = pGlobals ;
    Parm.SasType = SasType ;

    //
    // Take their username and password and try to log them on
    //
    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx,
            ( (GetDisableCad(pGlobals) && IsActiveConsoleSession()) ? TIMEOUT_NONE : LOGON_TIMEOUT));

    Result = pWlxFuncs->WlxDialogBoxParam(pGlobals->hGlobalWlx,
                                          hDllInstance,
                                          MAKEINTRESOURCE(IDD_LOGON_DIALOG),
                                          NULL,
                                          LogonDlgProc,
                                          (LPARAM) &Parm );

    if ( Result == WLX_SAS_ACTION_LOGON )
    {
        if ( (pGlobals->SmartCardOption == 0) || (!pGlobals->SmartCardLogon) )
        {
                // As no action will be taken on SC removal, we can filter these events
            pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_USE_SMART_CARD,
                                     0,
                                     NULL );
        }
        else
        {
            //
            // Continue to monitor the s/c device
            //
            NOTHING ;
        }
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: LogonDlgCBProc
*
* PURPOSE:  Processes messages for Logon dialog combo box
*
* RETURNS:  Return value depends on message being sent.
*
* HISTORY:
*
*   05-21-93  RobertRe       Created.
*
\***************************************************************************/

INT_PTR WINAPI
LogonDlgCBProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    TCHAR KeyPressed;

//    DbgPrint("message = %X\n",message);

    switch (message) {
        case WM_CHAR:
            {
                KeyPressed = (TCHAR) wParam;
                SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG)KeyPressed);

                //
                // This fake CBN_SELCHANGE message will cause the
                // "Please wait..." dialog box to appear even if
                // the character pressed doesn't exist in the combobox yet.
                //

                PostMessage (GetParent(hwnd), WM_COMMAND,
                             MAKELONG(0, CBN_SELCHANGE), 0);
                break;
            }
    }

    return CallWindowProc(OldCBWndProc,hwnd,message,wParam,lParam);
}

INT_PTR
CALLBACK
DomainCacheDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PGLOBALS pGlobals ;

    DebugLog(( DEB_TRACE_DOMAIN, "DomainCacheDlgProc( %p, %x, %p, %p )\n",
                hDlg, Message, wParam, lParam ));

    switch ( Message )
    {
        case WM_INITDIALOG:

            pGlobals = (PGLOBALS) lParam ;

            if ( DCacheSetNotifyWindowIfNotReady(
                    pGlobals->Cache,
                    hDlg,
                    WM_DCACHE_COMPLETE ) )
            {
                EndDialog( hDlg, TRUE );
            }

            return TRUE ;

        case WM_DCACHE_COMPLETE:

            EndDialog( hDlg, TRUE );

            return TRUE ;

        default:

            return FALSE ;
    }
}

BOOL    IsAutoLogonUserInteractiveLogonRestricted (HWND hDlg)

{
    WCHAR   szUsername[UNLEN + 1];  // sizeof('\0')

    return((GetDlgItemText(hDlg, IDD_LOGON_NAME, szUsername, ARRAYSIZE(szUsername)) != 0) &&
           !ShellIsUserInteractiveLogonAllowed(szUsername));
}

BOOL    HasDefaultPassword (TCHAR *pszPassword, int cchPassword)

{
    DWORD   dwType, dwPasswordSize;

    dwType = REG_NONE;
    dwPasswordSize = cchPassword * sizeof(TCHAR);
    return(ERROR_SUCCESS == RegQueryValueEx(WinlogonKey,
                                            DEFAULT_PASSWORD_KEY,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)pszPassword,
                                            &dwPasswordSize) &&
          (REG_SZ == dwType));
    
}

// ==========================================================================================
// Logon dialog has 2 formats, one that looks like logon dialog box, another that looks like
// unlock desktop dialogbox. When user connects to session 0 from remote (tsclient) the
// dialog that appears at console // need to change to unlock computer. so if session 0 is in
// use, and if this session is created at active console. we change logon dialog to look like
// "unlock computer" dialog.
// This function SwitchLogonLocked does most of the stuff related to switching these
// dialog controls.
// Parameters:
// HWND hDlg - dialog window handle,
// BOOL bShowLocked - if true show locked dialog, if false show normal logon dialog.
// BOOL bInit - TRUE when this function is called for the first time.
// ==========================================================================================

static bLocked = TRUE;
BOOL IsthisUnlockWindowsDialog ()
{
    return bLocked;
}

BOOL SwitchLogonLocked(HWND hDlg, BOOL bShowLocked, BOOL bInit)
{
    UINT rgidLockControls[] = {IDC_GROUP_UNLOCK, IDD_UNLOCK_ICON, IDD_UNLOCK_MESSAGE, IDD_UNLOCK_NAME_INFO};
    static LockedControlHeight = 0;
    BOOL bShutdownWithoutLogon;
    

    int i;

    if (bShowLocked == bLocked && !bInit)
    {
        // nothing to do.
        return TRUE;
    }

    if (bInit)
    {
        
        {
            //
            // remember the reference rectangle height (groupbox) for control movements.
            //
            RECT rectLockedControls;
            HWND hWnd = GetDlgItem(hDlg, rgidLockControls[0]);
            GetWindowRect(hWnd, &rectLockedControls);
            LockedControlHeight =  rectLockedControls.bottom - rectLockedControls.top;

            //
            // this group box was only for reference, now hide it forever.
            //
            ShowWindow(hWnd, SW_HIDE);

        }

        bLocked = TRUE;
        
        if ( !hLockedIcon )
        {
            hLockedIcon = LoadImage( hDllInstance,
                                     MAKEINTRESOURCE( IDI_LOCKED),
                                     IMAGE_ICON,
                                     0, 0,
                                     LR_DEFAULTCOLOR );
        }

        SendMessage( GetDlgItem( hDlg, IDD_UNLOCK_ICON),
                     STM_SETICON,
                     (WPARAM)hLockedIcon,
                     0 );

    }


    // lets move controls arround, depending upon if lock controls are to be shown or not.
    if (bLocked != bShowLocked)
    {
        if (bShowLocked)
        {
            MoveChildren(hDlg, 0, LockedControlHeight);
            for ( i = 1; i < sizeof(rgidLockControls)/sizeof(rgidLockControls[0]); i++)
            {
                HWND hWnd = GetDlgItem(hDlg, rgidLockControls[i]);
                ASSERT(hWnd);
                EnableWindow(hWnd, TRUE);
                ShowWindow(hWnd, SW_SHOW);
            }

        }
        else
        {
            for ( i = 1; i < sizeof(rgidLockControls)/sizeof(rgidLockControls[0]); i++)
            {
                HWND hWnd = GetDlgItem(hDlg, rgidLockControls[i]);
                ASSERT(hWnd);
                ShowWindow(hWnd, SW_HIDE);
                EnableWindow(hWnd, FALSE);
            }
            MoveChildren(hDlg, 0, -LockedControlHeight);
        }
    }

    // some more processing
    
    {
        if (bShowLocked)
        {
            TCHAR szUser[USERNAME_LENGTH + DOMAIN_LENGTH + 2];
            TCHAR szMessage[MAX_STRING_BYTES];
            TCHAR szFinalMessage[MAX_STRING_BYTES];
            if (GetSessionZeroUser(szUser))
            {
                LoadString(hDllInstance, IDS_LOCKED_EMAIL_NFN_MESSAGE, szMessage, MAX_STRING_BYTES);
                _snwprintf(szFinalMessage, sizeof(szFinalMessage)/sizeof(TCHAR), szMessage, szUser );
            }
            else
            {
                //
                // for some reason we could not get the current session zero user.
                //
                LoadString(hDllInstance, IDS_LOCKED_NO_USER_MESSAGE, szFinalMessage, MAX_STRING_BYTES);
            }

            SetDlgItemText(hDlg, IDD_UNLOCK_NAME_INFO, szFinalMessage);
        }

        //
        // update the dialog box caption, accordingly
        //
        {
            TCHAR szCaption[MAX_CAPTION_LENGTH];
            LoadString(hDllInstance, bShowLocked ? IDS_CAPTION_UNLOCK_DIALOG : IDS_CAPTION_LOGON_DIALOG, szCaption, ARRAYSIZE(szCaption));
            if ( szCaption[0] != TEXT('\0') )
                SetWindowText( hDlg, szCaption );
        }
    }

    bLocked = bShowLocked;


    if ( SafeBootMode == SAFEBOOT_MINIMAL )
    {
        bShutdownWithoutLogon = TRUE ;
    }
    else if (IsthisUnlockWindowsDialog() || !IsActiveConsoleSession())
    {
        bShutdownWithoutLogon = FALSE ;
    }
    else
    {
        bShutdownWithoutLogon = ReadWinlogonBoolValue(SHUTDOWN_WITHOUT_LOGON_KEY, TRUE);
    }

    EnableDlgItem(hDlg, IDD_LOGON_SHUTDOWN, bShutdownWithoutLogon);

    InvalidateRect(hDlg, NULL, TRUE);

    return TRUE;
}

/***************************************************************************\
* FUNCTION: LogonDlgProc
*
* PURPOSE:  Processes messages for Logon dialog
*
* RETURNS:  MSGINA_DLG_SUCCESS     - the user was logged on successfully
*           MSGINA_DLG_FAILURE     - the logon failed,
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

#define WM_HIDEOURSELVES    (WM_USER + 1000)

INT_PTR WINAPI
LogonDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    INT_PTR Result;
    HWND CBHandle;
    BOOL fDisconnectOnTsAutoLogonFailure = FALSE;
    static BOOL bSessionZeroInUse = FALSE;
    static int iSessionRegistrationCount = 0;
    static BOOL bSmartCardInserted = FALSE;

    switch (message)
    {

        case WM_INITDIALOG:
        {
            TCHAR PasswordBuffer[127];
            BOOL bAutoLogon;
            PMSGINA_LOGON_PARAMETERS pParam ;

            pParam = (PMSGINA_LOGON_PARAMETERS) lParam ;
            pGlobals = pParam->pGlobals ;

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM)pGlobals);

            // Hide the keyboard accelerator keys to start
            SendMessage(hDlg, WM_CHANGEUISTATE, MAKELONG(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0);

            // Limit the maximum password length to 127
            
            SendDlgItemMessage(hDlg, IDD_LOGON_PASSWORD, EM_SETLIMITTEXT, (WPARAM) 127, 0);

            s_fAttemptedAutoLogon = FALSE;

            //
            // Check if auto logon is enabled.
            //

            pGlobals->AutoAdminLogon = GetProfileInt( APPLICATION_NAME, AUTO_ADMIN_LOGON_KEY, 0 ) != 0;
            bAutoLogon = !pGlobals->IgnoreAutoAdminLogon;

            if ( !pGlobals->AutoAdminLogon || (!g_Console) ||
                 ((GetAsyncKeyState(VK_SHIFT) < 0) && (GetProfileInt( APPLICATION_NAME, IGNORE_SHIFT_OVERRIDE_KEY, 0 ) == 0)) )
            {
                bAutoLogon = FALSE;
            }

            KdPrint(("AutoAdminLogon = %d, IgnoreAutoAdminLogon = %d, bAutoLogon = %d\n",
                     pGlobals->AutoAdminLogon,
                     pGlobals->IgnoreAutoAdminLogon,
                     bAutoLogon ));


            //
            // Subclass the domain list control so we can filter messages
            //

            CBHandle = GetDlgItem(hDlg,IDD_LOGON_DOMAIN);
            SetWindowLongPtr(CBHandle, GWLP_USERDATA, 0);
            OldCBWndProc = (WNDPROC) SetWindowLongPtr(CBHandle, GWLP_WNDPROC, (LONG_PTR)LogonDlgCBProc);

            //
            // Subclass the user name and password edit also so we can disable edits
            //

            SetWindowSubclass(GetDlgItem(hDlg, IDD_LOGON_NAME)    , DisableEditSubClassProc, IDD_LOGON_NAME    , 0);
            SetWindowSubclass(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), DisableEditSubClassProc, IDD_LOGON_PASSWORD, 0);

            ShellReleaseLogonMutex(FALSE);

            if (!LogonDlgInit(hDlg, bAutoLogon, pParam->SasType ))
            {
                bSmartCardInserted = FALSE;
                EndDialog(hDlg, MSGINA_DLG_FAILURE);
                return(TRUE);
            }


            //
            // If the default user for auto logon is present and the user is
            // restricted (interactive logon denied) then disable auto logon.
            //

            if (bAutoLogon && IsAutoLogonUserInteractiveLogonRestricted(hDlg))
            {
                bAutoLogon = FALSE;
            }


            //
            // If CAD is disabled, then gray out the Cancel button
            //

            if (GetDisableCad(pGlobals) && IsActiveConsoleSession())
                EnableDlgItem(hDlg, IDCANCEL, FALSE);



            //
            // this dialog has 2 formats, one that looks like logon dialog box,
            // another that looks like unlock desktop dialogbox. 
            // we choose locked one, if session 0 is in use, and if this session is created at 
            // active console.
            //
            if (g_IsTerminalServer && 
                IsActiveConsoleSession() && 
                NtCurrentPeb()->SessionId != 0 &&
                !FastUserSwitchingEnabled() &&
                !_ShellIsFriendlyUIActive())
            {
                TCHAR szUser[USERNAME_LENGTH + DOMAIN_LENGTH + 2];
                //
                // we are at temporary session created at console...
                //
                
                // check if a user is logged on at console session
                bSessionZeroInUse = GetSessionZeroUser(szUser);
                if (WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, hDlg, NOTIFY_FOR_ALL_SESSIONS))
                {
                    iSessionRegistrationCount++;
                }
                
            }
            else
            {
                //
                // this is not active console nonzero session. 
                //
                bSessionZeroInUse = FALSE;
            }

            //
            // 
            // now switch the control, accordigly to show logon or unlock dialog
            //
            SwitchLogonLocked(hDlg, bSessionZeroInUse, TRUE);

            if (g_IsTerminalServer) {
                BOOL    fForceUPN;
                BOOL    fPopulateFields = TRUE;
                BOOL    fResult = FALSE;
                PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pAutoLogon;
                
                //
                // Query network WinStation client credentials for
                // auto logon
                //

                pGlobals->MuGlobals.pAutoLogon =
                   LocalAlloc( LPTR, sizeof(WLX_CLIENT_CREDENTIALS_INFO_V2_0) );

                if (pGlobals->MuGlobals.pAutoLogon) {

                   pGlobals->MuGlobals.pAutoLogon->dwType = WLX_CREDENTIAL_TYPE_V2_0;


                   if (NtCurrentPeb()->SessionId != 0) {
                       fResult = pWlxFuncs->WlxQueryTsLogonCredentials(
                                     pGlobals->MuGlobals.pAutoLogon
                                     );
                   }

                   if ( fResult &&
                        (pGlobals->MuGlobals.pAutoLogon->pszUserName[0] || pGlobals->MuGlobals.pAutoLogon->pszDomain[0] )) {

                        pAutoLogon = pGlobals->MuGlobals.pAutoLogon;
                        fDisconnectOnTsAutoLogonFailure = pAutoLogon->fDisconnectOnLogonFailure;

                        SetupCursor(TRUE); // hourglass cursor

                        fForceUPN = GetProfileInt( APPLICATION_NAME, TEXT("TSForceUPN"), FALSE );
                        if (fForceUPN)
                        {
                            fPopulateFields = FALSE;    // never show old SAM style is UPN is forced
                        }

                        if (pAutoLogon->pszDomain[0] == TEXT('\0') && fForceUPN)
                        {
                            fForceUPN = FALSE;          // domain name not provided, can't apply policy
                        }

                        if (fForceUPN && pGlobals->MuGlobals.pAutoLogon->pszUserName[0] )
                        {
                            LRESULT             iDomain;
                            HWND                hwndDomain;
                            PDOMAIN_CACHE_ENTRY Entry ;
                            ULONG   nSize;

                            // Performance issue.  We don't want to perform a UPN conversion
                            // for local machine accounts (or unknown domains).  When this
                            // happens, the lookup will take a LONG time.

                            hwndDomain = GetDlgItem( hDlg, IDD_LOGON_DOMAIN );
                            iDomain = SendMessage( hwndDomain,
                                                   CB_FINDSTRING,
                                                   (WPARAM) -1,
                                                   (LPARAM) pAutoLogon->pszDomain );
                            fForceUPN = FALSE;  // don't do the conversion
                            if (iDomain != CB_ERR)
                            {
                                Entry = (PDOMAIN_CACHE_ENTRY) SendMessage( hwndDomain, CB_GETITEMDATA, (WPARAM)iDomain, 0);
                                if ( Entry != (PDOMAIN_CACHE_ENTRY) CB_ERR && Entry != NULL)
                                {
                                    switch (Entry->Type)
                                    {
                                    case DomainNt5:
                                        fForceUPN = TRUE;   // Attempt the conversion
                                        break;
                                    }
                                }
                            }


                            // Convert the domain\username into UPN format.
                            // and make sure the dialog is in UPN form.

                            //  2000/10/09 vtan: this function used to have two stack variables
                            //  szOldStyle and szUPNName that were TCHARs of MAX_UPN_NAME_SIZE size. The
                            //  fix for this makes these dynamically allocated to save stack space

                            {
                                TCHAR   *pszOldStyle;
                                TCHAR   *pszUPNName;

                                pszOldStyle = (TCHAR*)LocalAlloc(LMEM_FIXED, MAX_UPN_NAME_SIZE * sizeof(TCHAR));
                                pszUPNName = (TCHAR*)LocalAlloc(LMEM_FIXED, MAX_UPN_NAME_SIZE * sizeof(TCHAR));
                                if ((pszOldStyle != NULL) && (pszUPNName != NULL))
                                {
                                    wsprintf(pszOldStyle, TEXT("%s\\%s"), pAutoLogon->pszDomain, pAutoLogon->pszUserName);
                                    nSize = MAX_PATH;
                                    fResult = TranslateName(
                                                  pszOldStyle,
                                                  NameSamCompatible,
                                                  NameUserPrincipal,
                                                  pszUPNName,
                                                  &nSize
                                               );
                                    if (fResult)
                                    {
                                        // We now have the UPN form of the user account.
                                        SetDlgItemText( hDlg, IDD_LOGON_NAME, pszUPNName);
                                    }
                                }
                                if (pszOldStyle != NULL)
                                {
                                    LocalFree(pszOldStyle);
                                }
                                if (pszUPNName != NULL)
                                {
                                    LocalFree(pszUPNName);
                                }
                            }
                        }

                        if (fPopulateFields)
                        {
                            // display the old SAM style
                            SetDlgItemText( hDlg, IDD_LOGON_NAME, pAutoLogon->pszUserName );
                            SendMessage( GetDlgItem( hDlg, IDD_LOGON_DOMAIN ),
                                         CB_SELECTSTRING,
                                         (WPARAM) -1,
                                         (LPARAM) pAutoLogon->pszDomain );
                        }
                        else
                        {
                            // Enable or disable the domain box depending on whether a UPN name has been typed
                            EnableDomainForUPN(GetDlgItem(hDlg, IDD_LOGON_NAME), GetDlgItem(hDlg, IDD_LOGON_DOMAIN));

                            // Since we're forcing UPN, hide the options dialog, but don't make it sticky
                            LogonShowOptions(pGlobals, hDlg, FALSE, FALSE);
                        }

                        // See if the administrator always wants password prompting

                        if ( TRUE == g_fHelpAssistantLogon || !pAutoLogon->fPromptForPassword ) {
                           SetDlgItemText( hDlg, IDD_LOGON_PASSWORD, pAutoLogon->pszPassword );
                        }

                        DCacheSetDefaultEntry(
                            pGlobals->Cache,
                            pAutoLogon->pszDomain,
                            NULL );

                        if( TRUE == g_fHelpAssistantLogon || !pGlobals->MuGlobals.pAutoLogon->fPromptForPassword )
                        {
                            FreeAutoLogonInfo( pGlobals );

                            // Drop through as if Enter had been pressed...
                            wParam = IDOK;

                            goto go_logon;
                        }
                        else
                        {
                           FreeAutoLogonInfo( pGlobals );
                        }
                   }
                   else
                   {
                        FreeAutoLogonInfo( pGlobals );
                   }
               }
            }
            
            if (pGlobals->SmartCardLogon) {

                if ( GetProfileString(APPLICATION_NAME, TEXT("DefaultPIN"), TEXT(""), PasswordBuffer, ARRAYSIZE(PasswordBuffer)) != 0 )
                {
                    // Ensure we never write more than 127 chars into the password box
                    PasswordBuffer[126] = 0;
                    SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, PasswordBuffer);
                    goto go_logon;
                }
            }

            // save off the auto logon attempt.

            s_fAttemptedAutoLogon = (bAutoLogon != FALSE);

            if (bAutoLogon)
            {
                GetWindowRect(hDlg, &pGlobals->rcDialog);
                SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                PostMessage(hDlg, WM_HIDEOURSELVES, 0, 0);
            }
            else
            {
                switch (_Shell_LogonDialog_Init(hDlg, SHELL_LOGONDIALOG_LOGGEDOFF))
                {
                    case SHELL_LOGONDIALOG_NONE:
                    default:
                    {
                        //
                        // If auto logon isn't enabled, set the focus to the
                        // password edit control and leave.
                        //

                        return(SetPasswordFocus(hDlg));
                    }
                    case SHELL_LOGONDIALOG_LOGON:
                    {
                        GetWindowRect(hDlg, &pGlobals->rcDialog);
                        SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                        PostMessage(hDlg, WM_HIDEOURSELVES, 0, 0);
                        goto go_logon;
                    }
                    case SHELL_LOGONDIALOG_EXTERNALHOST:
                    {
                        return(TRUE);
                    }
                }
            }

            //
            // Attempt to auto logon.  If no default password
            // specified, then this is a one shot attempt, which handles
            // the case when auto logging on as Administrator.
            //

            if (HasDefaultPassword(PasswordBuffer, ARRAYSIZE(PasswordBuffer)) != FALSE)
            {
                // Ensure we never write more than 127 chars into the password box
                PasswordBuffer[126] = 0;
                SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, PasswordBuffer);
            }
            else
            {
                NTSTATUS Status = STATUS_SUCCESS;
                OBJECT_ATTRIBUTES ObjectAttributes;
                LSA_HANDLE LsaHandle = NULL;
                UNICODE_STRING SecretName;
                PUNICODE_STRING SecretValue = NULL;

                //
                // Set up the object attributes to open the Lsa policy object
                //

                InitializeObjectAttributes(&ObjectAttributes,
                                           NULL,
                                           0L,
                                           (HANDLE)NULL,
                                           NULL);

                //
                // Open the local LSA policy object
                //

                Status = LsaOpenPolicy( NULL,
                                        &ObjectAttributes,
                                        POLICY_VIEW_LOCAL_INFORMATION,
                                        &LsaHandle
                                      );
                if (NT_SUCCESS(Status)) {
                    RtlInitUnicodeString(
                        &SecretName,
                        DEFAULT_PASSWORD_KEY
                        );

                    Status = LsaRetrievePrivateData(
                                LsaHandle,
                                &SecretName,
                                &SecretValue
                                );
                    if (NT_SUCCESS(Status)) {

                        if ( SecretValue->Length > 0 ) {

                            //
                            // If the password fits in the buffer, copy it there
                            // and null terminate
                            //

                            if (SecretValue->Length < sizeof(PasswordBuffer) - sizeof(WCHAR)) {

                                RtlCopyMemory(
                                    PasswordBuffer,
                                    SecretValue->Buffer,
                                    SecretValue->Length
                                    );
                                PasswordBuffer[SecretValue->Length/sizeof(WCHAR)] = L'\0';
                                SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, PasswordBuffer);

                            } else {
                                Status = STATUS_INVALID_PARAMETER;
                            }
                        }

                        LsaFreeMemory(SecretValue);
                    }
                    LsaClose(LsaHandle);
                }

                if (!NT_SUCCESS(Status))
                {
                    WriteProfileString( APPLICATION_NAME, AUTO_ADMIN_LOGON_KEY, TEXT("0") );
                }

            }

go_logon:

            // Drop through as if Enter had been pressed...
            wParam = IDOK;
        }

        // nb: deliberate drop through from above

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {

                case CBN_DROPDOWN:
                case CBN_SELCHANGE:

                    DebugLog((DEB_TRACE, "Got CBN_DROPDOWN\n"));

                    if ( !pGlobals->ListPopulated )
                    {
                        WCHAR Buffer[ 2 ];

                        if ( DCacheGetCacheState( pGlobals->Cache ) < DomainCacheRegistryCache )
                        {
                            pWlxFuncs->WlxDialogBoxParam(
                                pGlobals->hGlobalWlx,
                                hDllInstance,
                                (LPTSTR) IDD_WAITDOMAINCACHEVALID_DIALOG,
                                hDlg,
                                DomainCacheDlgProc,
                                (LPARAM) pGlobals );



                        }

                        if ( DCacheGetCacheState( pGlobals->Cache ) == DomainCacheReady )
                        {
                            PDOMAIN_CACHE_ARRAY ActiveArrayBackup ;

                            ActiveArrayBackup = pGlobals->ActiveArray;

                            pGlobals->ActiveArray = DCacheCopyCacheArray( pGlobals->Cache );

                            if ( pGlobals->ActiveArray )
                            {
                                DCacheFreeArray( ActiveArrayBackup );   // Not needed anymore

                                Buffer[ 0 ] = (WCHAR) GetWindowLongPtr( GetDlgItem( hDlg, IDD_LOGON_DOMAIN ),
                                                                        GWLP_USERDATA );
                                Buffer[ 1 ] = L'\0';

                                DCachePopulateListBoxFromArray(
                                    pGlobals->ActiveArray,
                                    GetDlgItem( hDlg, IDD_LOGON_DOMAIN ),
                                    Buffer );

                                pGlobals->ListPopulated = TRUE ;
                            }
                            else
                            {
                                    //
                                    // Restore the old array, otherwise the pointers in the
                                    // combo items will point to freed memory
                                    //
                                pGlobals->ActiveArray = ActiveArrayBackup ;
                            }
                        }
                    }


                    break;

                default:

                    switch (LOWORD(wParam))
                    {

                        case IDD_LOGON_NAME:
                            {
                                switch(HIWORD(wParam))
                                {
                                case EN_CHANGE:
                                    {
                                        EnableDomainForUPN((HWND) lParam, GetDlgItem(hDlg, IDD_LOGON_DOMAIN));
                                        return TRUE;
                                    }
                                }
                            }
                            break;
                        case IDOK:

                            //
                            // Deal with combo-box UI requirements
                            //

                            if (HandleComboBoxOK(hDlg, IDD_LOGON_DOMAIN))
                            {
                                return(TRUE);
                            }

                            Result = AttemptLogon( hDlg );

                            if (Result == MSGINA_DLG_FAILURE)
                            {
                                if (!fDisconnectOnTsAutoLogonFailure &&
                                    !g_fHelpAssistantLogon ) {
                                    // Let the user try again

                                    // Clear the password field and set focus to it
                                    SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, NULL);
                                    SetPasswordFocus(hDlg);
                                } else {
                                    bSmartCardInserted = FALSE;
                                    EndDialog(hDlg, MSGINA_DLG_USER_LOGOFF);
                                }

                                return(TRUE);
                            }

                            return(TRUE);

                        case IDCANCEL:
                        {
                            if (!_Shell_LogonDialog_Cancel())
                            {
                                // If this is TS and the user hit ESC at the smart card pin prompt 
                                // we want to switch to the password dialog 
                                if (/*!g_Console && !IsActiveConsoleSession() && */pGlobals->SmartCardLogon) {
                                
                                    EndDialog(hDlg, bSmartCardInserted ? MSGINA_DLG_SMARTCARD_REMOVED : MSGINA_DLG_FAILURE);
                                    bSmartCardInserted = FALSE;
                                    return TRUE;
                                }

                                //
                                // Allow logon screen to go away if not at console
                                //

                                bSmartCardInserted = FALSE;
                                EndDialog(hDlg,  !g_Console ? MSGINA_DLG_USER_LOGOFF
                                                            : MSGINA_DLG_FAILURE);

                                if (g_Console && !IsActiveConsoleSession()) {

                                   pWlxFuncs->WlxDisconnect();
                                }
                            }
                            return(TRUE);
                        }

                        case IDD_LOGON_SHUTDOWN:
                            //
                            // This is a normal shutdown request
                            //
                            // Check they know what they're doing and find
                            // out if they want to reboot too.
                            //

                            // Note that we definitely don't want disconnect or logofff
                            // here since no one is logged on
                            Result = WinlogonShutdownDialog(hDlg, pGlobals, (SHTDN_DISCONNECT | SHTDN_LOGOFF));

                            if (DLG_SHUTDOWN(Result))
                            {
                                _Shell_LogonDialog_ShuttingDown();
                                bSmartCardInserted = FALSE;
                                EndDialog(hDlg, Result);
                            }
                            return(TRUE);

                        case IDD_LOGON_OPTIONS:
                            LogonShowOptions(pGlobals, hDlg, !pGlobals->LogonOptionsShown, TRUE);
                            return(TRUE);

                    }
                    break;

            }
            break;

        case WM_TIMER:
        {
            switch (wParam)
            {
                case 0:
                {
                    HDC hDC;

                    RtlEnterCriticalSection(&pGlobals->csGlobals);

                    if ( pGlobals->LogonInProgress )
                    {
                        if (pGlobals->cxBand != 0)
                        {
                            pGlobals->xBandOffset = (pGlobals->xBandOffset+5) % pGlobals->cxBand;
                        }
                    }
                    else
                    {
                        pGlobals->xBandOffset = 0;
                        KillTimer(hDlg, 0);
                    }

                    RtlLeaveCriticalSection(&pGlobals->csGlobals);

                    hDC = GetDC(hDlg);
                    if ( hDC )
                    {
                        PaintBranding(hDlg, hDC, pGlobals->xBandOffset, TRUE, TRUE, COLOR_BTNFACE);
                        ReleaseDC(hDlg, hDC);
                    }

                    return FALSE;
                }
                case TIMER_MYLANGUAGECHECK:
                {
                    LayoutCheckHandler(hDlg, LAYOUT_DEF_USER);
                    break;
                }
            }
            break;
        }

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, TRUE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_LOGONCOMPLETE:
        {
            _Shell_LogonDialog_LogonCompleted(lParam, pGlobals->UserName, pGlobals->Domain);
            Result = lParam;

            //
            // Discard the logon in progress dialog if one is displayed
            //

            RtlEnterCriticalSection(&pGlobals->csGlobals);
            pGlobals->LogonInProgress = FALSE;
            RtlLeaveCriticalSection(&pGlobals->csGlobals);

            AttemptLogonSetControls(pGlobals, hDlg);

            if (Result == MSGINA_DLG_FAILURE)
            {
                if (fDisconnectOnTsAutoLogonFailure || g_fHelpAssistantLogon)
                {
                    //
                    // If TermSrv Internet Connector is on
                    // don't allow a second chance at the logon dialog
                    //

                    //
                    // disconnect immediatly when fail to logon as helpassisant 
                    //
                    bSmartCardInserted = FALSE;
                    EndDialog(hDlg, MSGINA_DLG_USER_LOGOFF);
                    break;
                }

                if (s_fAttemptedAutoLogon != FALSE)
                {
                    s_fAttemptedAutoLogon = FALSE;
                    switch (_Shell_LogonDialog_Init(hDlg, SHELL_LOGONDIALOG_LOGGEDOFF))
                    {
                        case SHELL_LOGONDIALOG_LOGON:
                            goto go_logon;
                            break;
                        case SHELL_LOGONDIALOG_NONE:
                        case SHELL_LOGONDIALOG_EXTERNALHOST:
                        default:
                            break;
                    }
                }

                if (!_Shell_LogonDialog_UIHostActive())
                {
                    // Let the user try again - clear the password
                    SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, NULL);
                    SetPasswordFocus(hDlg);

                    // the logon failed, so lets ensure we show the options pane so they can update
                    // their domain selection if needed.

                    if ( !pGlobals->LogonOptionsShown )
                        LogonShowOptions(pGlobals, hDlg, TRUE, FALSE);
                }
                return(TRUE);
            }


            //
            // Initialize the TS Profile path and Home dir globals. Also get
            // all TS specific user-config data which is used in winlogon
            //
            if (!g_Console) //only do this for non-console sessions
            {
                HANDLE  ImpersonationHandle;
                BOOL    rc;

                // DbgPrint("Calling WlxQueryTerminalServicesData() for %ws %ws\n",pGlobals->UserName,pGlobals->Domain);

                ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);
                ASSERT(ImpersonationHandle);
                if (ImpersonationHandle != NULL) 
                {
                    //For WlxQueryTerminalServicesData() we need NT type names rather than
                    //UPN names, if we pass a UPN name it will try to resolve it
                    //(through ADS API) to NT name anyway. Besides, ADS API cannot 
                    //resolve some UPN names and takes a long time to execute.
                    //So let's pass in an NT user and domain names.
                    PUNICODE_STRING pFlatUser ;
                    PUNICODE_STRING pFlatDomain ;

                    LPWSTR wszFlatUserName, wszFlatDomainName;
                    
                    if(NT_SUCCESS(LsaGetUserName( &pFlatUser, &pFlatDomain )))
                    {
                        wszFlatUserName = (LPWSTR)LocalAlloc(LPTR,
                            pFlatUser->Length+sizeof(WCHAR));
                        wszFlatDomainName = (LPWSTR)LocalAlloc(LPTR,
                            pFlatDomain->Length+sizeof(WCHAR));

                        if(wszFlatUserName && wszFlatDomainName)
                        {
                            memcpy(wszFlatUserName, pFlatUser->Buffer, 
                                pFlatUser->Length);

                            memcpy(wszFlatDomainName, pFlatDomain->Buffer, 
                                pFlatDomain->Length);

                            pWlxFuncs->WlxQueryTerminalServicesData(pGlobals->hGlobalWlx,
                                &pGlobals->MuGlobals.TSData, wszFlatUserName, wszFlatDomainName);
                        }
                        else
                        {
                            pWlxFuncs->WlxQueryTerminalServicesData(pGlobals->hGlobalWlx,
                                &pGlobals->MuGlobals.TSData,pGlobals->UserName , pGlobals->Domain);
                        }

                        if(wszFlatUserName)
                        {
                            LocalFree(wszFlatUserName);
                        }
                        if(wszFlatDomainName)
                        {
                            LocalFree(wszFlatDomainName);
                        }

                        LsaFreeMemory( pFlatUser->Buffer );
                        LsaFreeMemory( pFlatUser );
                        LsaFreeMemory( pFlatDomain->Buffer );
                        LsaFreeMemory( pFlatDomain );
                    }
                    else
                    {
                        pWlxFuncs->WlxQueryTerminalServicesData(pGlobals->hGlobalWlx,
                            &pGlobals->MuGlobals.TSData,pGlobals->UserName , pGlobals->Domain);
                    }

                    rc = StopImpersonating(ImpersonationHandle);
                    ASSERT(rc);
                }
            }


            bSmartCardInserted = FALSE;
            EndDialog( hDlg, Result );
            break;
        }

        case WM_HANDLEFAILEDLOGON:
        {
            INT_PTR Result;

            if (_Shell_LogonDialog_LogonDisplayError(g_failinfo.Status, g_failinfo.SubStatus))
            {
                if (!IsWindowVisible(hDlg))
                {
                    //
                    // The dialog was hidden for automatic logon. An error occurred.
                    // Show the dialog so the error can be seen and the problem corrected.
                    //
                    SetWindowPos(hDlg, NULL, 0, 0, pGlobals->rcDialog.right - pGlobals->rcDialog.left, pGlobals->rcDialog.bottom - pGlobals->rcDialog.top, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                    ShowWindow(hDlg, SW_SHOW);
                }
                Result = HandleFailedLogon(hDlg);
            }
            else
            {
                Result = MSGINA_DLG_FAILURE;
            }
            SendMessage(hDlg, WM_LOGONCOMPLETE, 0, (LPARAM) Result);
            return TRUE;
        }
        case WLX_WM_SAS:

            // Give the consumer logon part a chance to handle the SAS
            // or to key off the fact that a SAS has occurred.
            (BOOL)_Shell_LogonDialog_DlgProc(hDlg, message, wParam, lParam);

            if ((wParam == WLX_SAS_TYPE_TIMEOUT) ||
                (wParam == WLX_SAS_TYPE_SCRNSVR_TIMEOUT) )
            {
                //
                // If this was a timeout, return false, and let winlogon
                // kill us later
                //

                bSmartCardInserted = FALSE;
                return(FALSE);
            }
            if ( wParam == WLX_SAS_TYPE_SC_INSERT ) {

                //
                // If a password logon is already taking place then ignore this sas
                //
                if (pGlobals->LogonInProgress && !pGlobals->SmartCardLogon)
                {
                    return(TRUE);   
                }

                bSmartCardInserted = TRUE;
                EndDialog( hDlg, MSGINA_DLG_SMARTCARD_INSERTED );

            } else if ( wParam == WLX_SAS_TYPE_SC_REMOVE ) {

                //
                // If a password logon is already taking place then ignore this sas
                //
                if (pGlobals->LogonInProgress && !pGlobals->SmartCardLogon)
                {
                    return(TRUE);   
                }

                if ( bSmartCardInserted ) {

                    bSmartCardInserted = FALSE;
                    EndDialog( hDlg, MSGINA_DLG_SMARTCARD_REMOVED );

                } else if ( pGlobals->SmartCardLogon ) {

                    // If this was a s/c initiated logon, then cancel
                    // the dialog.  Otherwise, ignore it.
                    bSmartCardInserted = FALSE;
                    EndDialog( hDlg, MSGINA_DLG_FAILURE );
                }

            } else if ( wParam == WLX_SAS_TYPE_AUTHENTICATED )
            {
                   bSmartCardInserted = FALSE;
                   _Shell_LogonDialog_LogonCompleted(MSGINA_DLG_SWITCH_CONSOLE, pGlobals->UserName, pGlobals->Domain);
                   EndDialog( hDlg, MSGINA_DLG_SWITCH_CONSOLE );
            }

            return(TRUE);

        case WM_WTSSESSION_CHANGE:
            ASSERT(iSessionRegistrationCount < 2);
            
            //
            // its possible, that we unregister for notification in wm_destroy and still receive this notification,
            // as the notification may already have been sent.
            //
            if (iSessionRegistrationCount == 1)
            {
                if (lParam == 0)
                {
                    //
                    // we are interested only in logon/logoff messages from session 0.
                    //

                    if (wParam == WTS_SESSION_LOGON || wParam == WTS_SESSION_LOGOFF)
                    {
                        bSessionZeroInUse = (wParam == WTS_SESSION_LOGON);
                        SwitchLogonLocked(hDlg, bSessionZeroInUse, FALSE);
                    }
                }
            }
            break;
            

        case WM_DESTROY:
            
            // if registered for notification unregister now.
            if (iSessionRegistrationCount)
            {
                WinStationUnRegisterConsoleNotification (SERVERNAME_CURRENT, hDlg);
                iSessionRegistrationCount--;
                ASSERT(iSessionRegistrationCount == 0);
            }
            _Shell_LogonDialog_Destroy();

            FreeLayoutInfo(LAYOUT_DEF_USER);
            if ( pGlobals->ActiveArray )
            {
                DCacheFreeArray( pGlobals->ActiveArray );
                pGlobals->ActiveArray = NULL ;
            }

            RemoveWindowSubclass(GetDlgItem(hDlg, IDD_LOGON_NAME),     DisableEditSubClassProc, IDD_LOGON_NAME);
            RemoveWindowSubclass(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), DisableEditSubClassProc, IDD_LOGON_PASSWORD);

            break;

        case WM_HIDEOURSELVES:
            ShowWindow(hDlg, SW_HIDE);
            break;

        default:
            if (_Shell_LogonDialog_DlgProc(hDlg, message, wParam, lParam) != FALSE)
            {
                return(TRUE);
            }
    }

    return(FALSE);
}



/***************************************************************************\
* FUNCTION: LogonDlgInit
*
* PURPOSE:  Handles initialization of logon dialog
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

BOOL
LogonDlgInit(
    HWND    hDlg,
    BOOL    bAutoLogon,
    DWORD   SasType
    )
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    LPTSTR String = NULL;
    TCHAR LogonMsg[MAX_PATH];
    BOOL RemoveLegalBanner;
    BOOL ShowOptions = FALSE;
    HKEY hKey;
    int err;
    DWORD RasDisable;
    DWORD RasForce;
    STRING Narrow;
    SECURITY_STATUS Status;
    RECT rc, rc2;
    BOOL bHasLangIcon = FALSE;
    ULONG CacheFlags ;

    //
    // Populate Security Package List:
    //

    RtlInitString( &Narrow, MICROSOFT_KERBEROS_NAME_A );

    Status = LsaLookupAuthenticationPackage(
                pGlobals->LsaHandle,
                &Narrow,
                &pGlobals->SmartCardLogonPackage );

    //
    // this (potential) failure is not critical.  If it fails, then s/c logons later
    // will fail.
    //

    RtlInitString( &Narrow, NEGOSSP_NAME_A );

    Status = LsaLookupAuthenticationPackage(
                pGlobals->LsaHandle,
                &Narrow,
                &pGlobals->PasswordLogonPackage );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    //
    // Update the caption for certain banks
    //

    SetWelcomeCaption(hDlg);


    //
    // Get username and domain last used to login
    //

    //
    // Ignore the default user name unless on the active console
    //
    if (IsActiveConsoleSession())
    {
        String = NULL;

        if ( pGlobals->AutoAdminLogon && pGlobals->IgnoreAutoAdminLogon)
        {
            String = AllocAndGetProfileString(APPLICATION_NAME, TEMP_DEFAULT_USER_NAME_KEY, TEXT(""));
        }

        if ( (!String) || (!String[0]) )
        {
            if ( String )
            {
                Free(String);
            }

            String = AllocAndGetProfileString(APPLICATION_NAME, DEFAULT_USER_NAME_KEY, TEXT(""));
        }

        if ( String )
        {
            if (!bAutoLogon && (ReadWinlogonBoolValue(DONT_DISPLAY_LAST_USER_KEY, FALSE) == TRUE))
            {
                String[0] = 0;
            }

            SetDlgItemText(hDlg, IDD_LOGON_NAME, String);
            Free(String);
        }
    }

    GetProfileString( APPLICATION_NAME,
                      DEFAULT_DOMAIN_NAME_KEY,
                      TEXT(""),
                      pGlobals->Domain,
                      MAX_STRING_BYTES );

    if ( !DCacheValidateCache( pGlobals->Cache ) )
    {
        ASSERT( pGlobals->ActiveArray == NULL );

        DCacheUpdateMinimal( pGlobals->Cache, pGlobals->Domain, TRUE );

    }
    else
    {
        //
        // Set the current default:
        //

        DCacheSetDefaultEntry( pGlobals->Cache,
                               pGlobals->Domain,
                               NULL );
    }

    CacheFlags = DCacheGetFlags( pGlobals->Cache );

    if ( ( CacheFlags & DCACHE_NO_CACHE ) &&
         ( SafeBootMode != SAFEBOOT_MINIMAL ) &&
         ( ( pGlobals->AutoAdminLogon ) ||
           ( CacheFlags & DCACHE_DEF_UNKNOWN ) ) )
    {
        //
        // Must wait for the cache to be populated
        //

        DCacheUpdateFull( pGlobals->Cache,
                          pGlobals->Domain );

        CacheFlags = DCacheGetFlags( pGlobals->Cache );
    }

    
    pGlobals->ListPopulated = FALSE ;

    pGlobals->ActiveArray = DCacheCopyCacheArray( pGlobals->Cache );

    if ( pGlobals->ActiveArray )
    {
        DCachePopulateListBoxFromArray( pGlobals->ActiveArray,
                                        GetDlgItem( hDlg, IDD_LOGON_DOMAIN ),
                                        NULL );
    }
    else
    {
        EndDialog( hDlg, MSGINA_DLG_FAILURE );
    }

    pGlobals->ShowRasBox = FALSE;

    if (g_Console) {

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\RAS"),
                            0,
                            KEY_READ,
                            & hKey );


        if ( err == 0 )
        {
            RegCloseKey( hKey );

            if ( GetRasDialOutProtocols() && 
                 ( ( CacheFlags & DCACHE_MEMBER ) != 0 ) )
            {
                pGlobals->ShowRasBox = TRUE;
            }

        }

    }

    //
    // If the audit log is full then display the banner, otherwise
    // load the text from the resource if that gives us a string
    // then set the control.
    //
    // Should neither of these apply then remove the control.
    // The log full info is only displayed at the console so we
    // don't disclose too much info in TS sessions.
    //

    RemoveLegalBanner = FALSE;

    if ( pGlobals->AuditLogFull && !GetSystemMetrics(SM_REMOTESESSION))
    {
        if ( LoadString( hDllInstance, IDS_LOGON_LOG_FULL, LogonMsg, MAX_PATH ) )
        {
            SetDlgItemText( hDlg, IDD_LOGON_ANNOUNCE, LogonMsg );
        }
        else
        {
            RemoveLegalBanner = TRUE;
        }
    }
    else
    {
        String = AllocAndGetProfileString(  APPLICATION_NAME,
                                            LOGON_MSG_KEY, TEXT("") );
        if ( String )
        {
            if ( *String )
            {
                SetDlgItemText( hDlg, IDD_LOGON_ANNOUNCE, String );
            }
            else
            {
                RemoveLegalBanner = TRUE;
            }

            Free( String );
        }
        else
        {
            RemoveLegalBanner = TRUE;
        }
    }

    if ( RemoveLegalBanner )
    {
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_ANNOUNCE), &rc);
        MoveControls(hDlg, ctrlNoLegalBanner,
                     sizeof(ctrlNoLegalBanner)/sizeof(ctrlNoLegalBanner[0]),
                     0, rc.top-rc.bottom,
                     TRUE);

        ShowDlgItem(hDlg, IDD_LOGON_ANNOUNCE, FALSE);
    }

    //
    // Smart Card Specific Stuff:
    //

    if ( SasType == WLX_SAS_TYPE_SC_INSERT )
    {
        //
        // remove the user name fields
        //

        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_NAME), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), &rc2);

        MoveControls(hDlg, ctrlNoUserName,
                     sizeof(ctrlNoUserName)/sizeof(ctrlNoUserName[0]),
                     0, -(rc2.top-rc.top),
                     TRUE);

        ShowDlgItem(hDlg, IDD_LOGON_NAME_LABEL, FALSE);
        EnableDlgItem(hDlg, IDD_LOGON_NAME_LABEL, FALSE);

        ShowDlgItem(hDlg, IDD_LOGON_NAME, FALSE);
        EnableDlgItem(hDlg, IDD_LOGON_NAME, FALSE);
        SetDlgItemText( hDlg, IDD_LOGON_NAME, TEXT(""));

        LoadString(hDllInstance, IDS_PIN, LogonMsg, MAX_PATH);
        SetDlgItemText( hDlg, IDD_LOGON_PASSWORD_LABEL, LogonMsg );

        pGlobals->SmartCardLogon = TRUE;

    }
    else
    {
        pGlobals->SmartCardLogon = FALSE;
    }

    //
    // If this is safe boot and/or we are not part of a domain then lets
    // remove the domain and nix out the RAS box.
    //

    if ((SafeBootMode == SAFEBOOT_MINIMAL)
            || (!IsMachineDomainMember())
            || (SasType == WLX_SAS_TYPE_SC_INSERT)
            || (ForceNoDomainUI()))
    {
        ShowDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL, FALSE);
        EnableDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL, FALSE);
        ShowDlgItem(hDlg, IDD_LOGON_DOMAIN, FALSE);
        EnableDlgItem(hDlg, IDD_LOGON_DOMAIN, FALSE);

        pGlobals->ShowDomainBox = FALSE;

        // Shorten the window since the domain box isn't used

        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_DOMAIN), &rc2);

        MoveControls(hDlg, ctrlNoDomain,
                     ARRAYSIZE(ctrlNoDomain),
                     0, -(rc2.bottom-rc.bottom),
                     TRUE);
    }
    else
    {
        pGlobals->ShowDomainBox = TRUE;
    }


    bHasLangIcon = DisplayLanguageIcon(hDlg, LAYOUT_DEF_USER, GetKeyboardLayout(0));

    //
    // Handle showing the RAS box if needed
    //

    if ( pGlobals->ShowRasBox )
    {
        RasDisable = GetProfileInt( APPLICATION_NAME, RAS_DISABLE, 0 );
        RasForce = GetProfileInt( APPLICATION_NAME, RAS_FORCE, 0 );

        if (RasForce)
        {
            CheckDlgButton( hDlg, IDD_LOGON_RASBOX, 1 );
        }
        else
        {
            CheckDlgButton( hDlg, IDD_LOGON_RASBOX, 0 );
        }

        // SM_CLEANBOOT tells us we are in safe mode. In this case, disable since tapisrv isn't started
        if (RasDisable || RasForce || GetSystemMetrics(SM_CLEANBOOT))
        {
            EnableDlgItem(hDlg, IDD_LOGON_RASBOX, FALSE);
        }
        else
        {
            EnableDlgItem(hDlg, IDD_LOGON_RASBOX, TRUE);
        }
    }
    else
    {
        // If the domain box is hidden, then we'll have to shorten the dialog by the distance
        // between the RAS box and the password box instead of the distance between the
        // RAS box and the domain box since the RAS and Domain boxes will be on top of each other
        BOOL fUsePassword = !pGlobals->ShowDomainBox;

        CheckDlgButton( hDlg, IDD_LOGON_RASBOX, 0 );
        EnableDlgItem(hDlg, IDD_LOGON_RASBOX, FALSE);
        ShowDlgItem(hDlg, IDD_LOGON_RASBOX, FALSE);


        GetWindowRect(GetDlgItem(hDlg, fUsePassword ? IDD_LOGON_PASSWORD : IDD_LOGON_DOMAIN), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_RASBOX), &rc2);
        if (!bHasLangIcon)
        {
            MoveControls(hDlg, ctrlNoRAS,
                     sizeof(ctrlNoRAS)/sizeof(ctrlNoRAS[0]),
                     0, -(rc2.bottom-rc.bottom),
                     TRUE);
        }

    }



    // Centre the window on the screen and bring it to the front

    pGlobals->xBandOffset = 0;          // band is not animated yet

    SizeForBranding(hDlg, TRUE);

    // Position the window at the same coords as the welcome window
    if ((pGlobals->rcWelcome.right - pGlobals->rcWelcome.left) != 0)
    {
        SetWindowPos(hDlg, NULL, pGlobals->rcWelcome.left, pGlobals->rcWelcome.top,
            0, 0, SWP_NOZORDER | SWP_NOSIZE);
    }
    else
    {
        CentreWindow(hDlg);
    }


    //
    // Handle showing and hiding the logon bits
    //

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                 &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType, dwSize = sizeof(ShowOptions);

        RegQueryValueEx (hKey, SHOW_LOGON_OPTIONS, NULL, &dwType,
                        (LPBYTE)&ShowOptions, &dwSize);

        RegCloseKey (hKey);
    }

    pGlobals->LogonOptionsShown = TRUE;

    LogonShowOptions(pGlobals, hDlg, ShowOptions, TRUE);

    // Success
    return TRUE;
}




/****************************************************************************\
*
* FUNCTION: LogonShowOptions
*
* PURPOSE: Hide the options part of the logon dialog
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   15-dec-97 daviddv - Created
*
\****************************************************************************/
VOID LogonShowOptions(PGLOBALS pGlobals, HWND hDlg, BOOL fShow, BOOL fSticky)
{
    HKEY hKey;
    RECT rc, rc2;
    INT dy = 0;
    INT dx = 0;
    TCHAR szBuffer[32];
    BOOL bHasLangIcon = TRUE;
    DWORD RasDisable;
    DWORD RasForce;

    if ( pGlobals->LogonOptionsShown != fShow )
    {
        BOOL bShutdownWithoutLogon;

        //
        // Show/hide domain if it is present in the dialog
        //
        if (pGlobals->ShowDomainBox)
        {
            GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), &rc);
            GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_DOMAIN), &rc2);
            dy += rc2.bottom-rc.bottom;
        }

        //
        // If RAS is present then lets ensure that we remove that.
        //

        if (GetKeyboardLayoutList(0,NULL) < 2)
        {
            bHasLangIcon = FALSE;
        }

        if ( pGlobals->ShowRasBox  || bHasLangIcon)
        {
            // Since the domain box may be hidden with the RAS box directly over
            // top of it, we may need to use the space between the RAS box and the password
            // box
            BOOL fUsePassword = !pGlobals->ShowDomainBox;

            GetWindowRect(GetDlgItem(hDlg, fUsePassword ? IDD_LOGON_PASSWORD : IDD_LOGON_DOMAIN), &rc);
            GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_RASBOX), &rc2);
            dy += rc2.bottom-rc.bottom;
        }

        MoveControls(hDlg, ctrlNoRAS,
                     sizeof(ctrlNoRAS)/sizeof(ctrlNoRAS[0]),
                     0, fShow ? dy:-dy,
                     TRUE);


        // Handle showing or hiding the shutdown button
        // and moving other controls.
        ShowDlgItem(hDlg, IDD_KBLAYOUT_ICON, fShow);
        EnableWindow(GetDlgItem(hDlg, IDD_KBLAYOUT_ICON), fShow);
        ShowDlgItem(hDlg, IDD_LOGON_SHUTDOWN, fShow);

        // Move the OK and Cancel buttons over if we are hiding shutdown
        // ..Calculate one "button space". Assumes shutdown will always be on the left of options
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_SHUTDOWN), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_OPTIONS), &rc2);

        dx = rc2.left - rc.left;

        // Move OK and Cancel left or right 1 button space
        MoveControls(hDlg, ctrlNoShutdown,
            sizeof(ctrlNoShutdown)/sizeof(ctrlNoShutdown[0]),
            fShow ? -dx:dx, 0,
            FALSE);

        //
        // if ShutdownWithoutLogon, use the proper 3 buttons: OK, Shutdown and Cancel
        // instead of the 2 buttons OK and Cancel
        //



        if ( SafeBootMode == SAFEBOOT_MINIMAL )
        {
            bShutdownWithoutLogon = TRUE ;
        }
        else if (IsthisUnlockWindowsDialog() || !IsActiveConsoleSession())
        {
            bShutdownWithoutLogon = FALSE ;
        }
        else
        {
            bShutdownWithoutLogon = ReadWinlogonBoolValue(SHUTDOWN_WITHOUT_LOGON_KEY, TRUE);
        }


        EnableDlgItem(hDlg, IDD_LOGON_SHUTDOWN, (fShow) &&
            (bShutdownWithoutLogon));


        if ( pGlobals->ShowRasBox )
        {
            ShowDlgItem(hDlg, IDD_LOGON_RASBOX, fShow);
            RasDisable = GetProfileInt(APPLICATION_NAME, RAS_DISABLE,0);
            RasForce = GetProfileInt(APPLICATION_NAME, RAS_FORCE, 0);

            // Never enable RAS for cleanboot
            if (!GetSystemMetrics(SM_CLEANBOOT) && !RasForce && !RasDisable)
            {
                EnableWindow(GetDlgItem(hDlg, IDD_LOGON_RASBOX), fShow);
            }
        }

        if ( pGlobals->ShowDomainBox )
        {
            ShowDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL, fShow);
            EnableWindow(GetDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL), fShow);
            ShowDlgItem(hDlg, IDD_LOGON_DOMAIN, fShow);
            EnableWindow(GetDlgItem(hDlg, IDD_LOGON_DOMAIN), fShow);
        }

        if ( fSticky )
        {
            if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(hKey, SHOW_LOGON_OPTIONS, 0, REG_DWORD,
                                        (LPBYTE)&fShow, sizeof(fShow));
                RegCloseKey (hKey);
            }
        }
    }

    //
    // Change the options button to reflect the open/close state
    //

    LoadString(hDllInstance, fShow ? IDS_LESSOPTIONS:IDS_MOREOPTIONS,
                            szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]));

    SetDlgItemText(hDlg, IDD_LOGON_OPTIONS, szBuffer);

    pGlobals->LogonOptionsShown = fShow;

    // Enable or disable the domain box depending on whether a UPN name has been typed
    EnableDomainForUPN(GetDlgItem(hDlg, IDD_LOGON_NAME), GetDlgItem(hDlg, IDD_LOGON_DOMAIN));
}


/***************************************************************************\
* FUNCTION: AttemptLogonSetControls
*
* PURPOSE:  Sets up the logon UI to animating and controls to the
*           correct state.
*
* HISTORY:
*
*   02-05-98 diz Created
*
\***************************************************************************/

VOID AttemptLogonSetControls(
    PGLOBALS pGlobals,
    HWND hDlg
    )
{
    DWORD RasDisable;
    static BOOL sbRasBoxOriginalyEnabled;
    static BOOL sbShutDownOriginallyEnabled;

    RtlEnterCriticalSection( &pGlobals->csGlobals );

    EnableDlgItem(hDlg, IDD_LOGON_NAME_LABEL, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_NAME, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_PASSWORD_LABEL, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_PASSWORD, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL, !pGlobals->LogonInProgress);

    EnableDlgItem(hDlg, IDD_LOGON_DOMAIN, !pGlobals->LogonInProgress);

    // If no logon is in progress, we want to enable domain box based on whether
    // a UPN has been typed
    if (!pGlobals->LogonInProgress)
    {
        EnableDomainForUPN(GetDlgItem(hDlg, IDD_LOGON_NAME), GetDlgItem(hDlg, IDD_LOGON_DOMAIN));
    }

    //
    // MakarP: we should not enable all these control when !pGlobals->LogonInProgress, they should really be reverted back to their original state.
    // but for now I am just looking after IDD_LOGON_RASBOX in remote connection cases to fix bug #267270
    //
    if (pGlobals->LogonInProgress)
    {
        sbRasBoxOriginalyEnabled = IsWindowEnabled(GetDlgItem(hDlg, IDD_LOGON_RASBOX));
        RasDisable = GetProfileInt(APPLICATION_NAME, RAS_DISABLE, 0);
        EnableDlgItem(hDlg, IDD_LOGON_RASBOX, !RasDisable && !pGlobals->LogonInProgress);

        sbShutDownOriginallyEnabled = IsWindowEnabled(GetDlgItem(hDlg, IDD_LOGON_SHUTDOWN));
        EnableDlgItem(hDlg, IDD_LOGON_SHUTDOWN, !pGlobals->LogonInProgress);
    }
    else
    {
        EnableDlgItem(hDlg, IDD_LOGON_RASBOX, sbRasBoxOriginalyEnabled);
        EnableDlgItem(hDlg, IDD_LOGON_SHUTDOWN, sbShutDownOriginallyEnabled);
    }



    EnableDlgItem(hDlg, IDD_KBLAYOUT_ICON, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_OPTIONS, !pGlobals->LogonInProgress);

    //
    // if ShutdownWithoutLogon, use the proper 3 buttons: OK, Shutdown and Cancel
    // instead of the 2 buttons OK and Cancel
    //


    EnableDlgItem(hDlg, IDOK, !pGlobals->LogonInProgress);

    if ( !GetDisableCad(pGlobals) )
        EnableDlgItem(hDlg, IDCANCEL, !pGlobals->LogonInProgress);


    RtlLeaveCriticalSection( &pGlobals->csGlobals );
}



/***************************************************************************\
* FUNCTION: AttemptLogon
*
* PURPOSE:  Tries to the log the user on using the current values in the
*           logon dialog controls
*
* RETURNS:  MSGINA_DLG_SUCCESS     - the user was logged on successfully
*           MSGINA_DLG_FAILURE     - the logon failed,
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* NOTES:    If the logon is successful, the global structure is filled in
*           with the logon information.
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
AttemptLogon(
    HWND    hDlg
)
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PWCHAR  UserName = pGlobals->UserName;
    PWCHAR  Domain = pGlobals->Domain;
    PWCHAR  Password = pGlobals->Password;
    PDOMAIN_CACHE_ENTRY Entry ;
    RECT    rc;
    HANDLE  hThread;
    DWORD   tid;
    BOOL    timeout;
    PUCHAR  Dummy;
    BOOL    RasBox;

    UserName[0] = TEXT('\0');
    Domain[0] = TEXT('\0');
    Password[0] = TEXT('\0');

    //
    // Hide the password so it doesn't make it to the pagefile in
    // cleartext.  Do this before getting the username and password
    // so that it can't easily be identified (by association with
    // the username and password) if we should crash or be rebooted
    // before getting a chance to encode it.
    //

    GetDlgItemText(hDlg, IDD_LOGON_PASSWORD, Password, MAX_STRING_BYTES);
    RtlInitUnicodeString(&pGlobals->PasswordString, Password);
    pGlobals->Seed = 0; // Causes the encode routine to assign a seed
    HidePassword( &pGlobals->Seed, &pGlobals->PasswordString );


    //
    // Now get the username and domain
    //

    if ( pGlobals->SmartCardLogon == FALSE )
    {
        HWND hwndDomain = GetDlgItem(hDlg, IDD_LOGON_DOMAIN);

        if (hwndDomain != NULL)
        {
            INT iDomainSel = (INT)SendMessage(hwndDomain, CB_GETCURSEL, 0, 0);

            GetDlgItemText(hDlg, IDD_LOGON_NAME, UserName, MAX_STRING_BYTES);

            //
            // is this the magical "this computer" entry???
            //

            Entry = (PDOMAIN_CACHE_ENTRY) SendMessage( hwndDomain, CB_GETITEMDATA, (WPARAM)iDomainSel, 0);
        }
        else
        {
            Entry = (PDOMAIN_CACHE_ENTRY) CB_ERR;
        }
        if ( Entry != (PDOMAIN_CACHE_ENTRY) CB_ERR )
        {
            wcscpy( Domain, Entry->FlatName.Buffer );
        }
        else
        {
            Domain[0] = L'\0';
        }

    }
    else
    {
        UserName[0] = TEXT('\0');
        Domain[0] = TEXT('\0') ;
    }

    // If we are forcing a NoDomainUI, populate the domain with the local machine name now
    if (ForceNoDomainUI())
    {
        DWORD chSize = MAX_STRING_BYTES;

        if (GetComputerName(Domain, &chSize))
        {
            NOTHING;
        }
        else
        {
            *Domain = 0;
        }
    }

    //
    // If there is a at-sign in the name, assume that means that a UPN logon
    // attempt is being made.  Set the domain to NULL.
    //

    if ( wcschr( UserName, L'@' ) )
    {
        Domain[0] = TEXT('\0');
    }

    RtlInitUnicodeString(&pGlobals->UserNameString, UserName);
    RtlInitUnicodeString(&pGlobals->DomainString, Domain);

    //
    // Ok, is the RASbox checked?
    //

    RasBox = IsDlgButtonChecked( hDlg, IDD_LOGON_RASBOX );
    pGlobals->RasUsed = FALSE;

    if ( RasBox == BST_CHECKED )
    {
        //
        // Reset the current timeout so that they neatly clean up before
        // winlogon up and blows them away.
        //

        pWlxFuncs->WlxSetTimeout( pGlobals->hGlobalWlx, 5 * 60 );

        if ( !PopupRasPhonebookDlg( hDlg, pGlobals, &timeout) )
        {
            return( MSGINA_DLG_FAILURE );
        }

        pGlobals->RasUsed = TRUE;

        //
        // Reinitialize strings in case they've changed
        //

        RtlInitUnicodeString( &pGlobals->UserNameString, UserName );

        //
        // Ping Netlogon to allow us to go out on the net again...
        //

        I_NetLogonControl2(NULL,
                            NETLOGON_CONTROL_TRANSPORT_NOTIFY,
                            1, (LPBYTE) &Dummy, &Dummy );

        Sleep ((DWORD) ReadWinlogonBoolValue(TEXT("RASSleepTime"), 3000));
        RefreshPolicy(TRUE);
    }

    //
    // Process arguments before kicking off the thread
    //
    pGlobals->hwndLogon = hDlg;

    RtlEnterCriticalSection( &pGlobals->csGlobals );
    pGlobals->LogonInProgress = TRUE ;
    RtlLeaveCriticalSection( &pGlobals->csGlobals );

    GetClientRect(hDlg, &rc);
    pGlobals->cxBand = rc.right-rc.left;

    SetTimer(hDlg, 0, 20, NULL);                // setup the progress timer


    //
    // Kick off real logon thread
    //

    // Set timeout to infinite while attempting to logon
    pWlxFuncs->WlxSetTimeout( pGlobals->hGlobalWlx, TIMEOUT_NONE );

    hThread = CreateThread( NULL, 0,
                            AttemptLogonThread,
                            pGlobals,
                            0, &tid );

    if (hThread)
    {
        CloseHandle( hThread );
    }
    else
    {
        //
        // CreateThread failed, likely because of low memory.
        // Inform the user.
        //

        PostFailedLogonMessage(pGlobals->hwndLogon,
                               pGlobals,
                               GetLastError(),
                               0,
                               NULL,
                               NULL);

        RtlEnterCriticalSection( &pGlobals->csGlobals );
        pGlobals->LogonInProgress = FALSE ;
        RtlLeaveCriticalSection( &pGlobals->csGlobals );
        return MSGINA_DLG_FAILURE ;
    }

    AttemptLogonSetControls(pGlobals, hDlg);

    return MSGINA_DLG_SUCCESS;
}

BOOL    ReplacedPossibleDisplayName (WCHAR *pszUsername)

{
    BOOL                fReplaced;
    DWORD               dwIndex, dwReturnedEntryCount;
    NET_API_STATUS      nasCode;
    NET_DISPLAY_USER    *pNDU;

    fReplaced = FALSE;
    dwIndex = 0;
    nasCode = NetQueryDisplayInformation(NULL,
                                         1,
                                         dwIndex,
                                         1,
                                         sizeof(NET_DISPLAY_USER),
                                         &dwReturnedEntryCount,
                                         (void**)&pNDU);
    while (!fReplaced &&
           (dwReturnedEntryCount > 0) &&
           (NERR_Success == nasCode) || (ERROR_MORE_DATA == nasCode))
    {
        fReplaced = (lstrcmpiW(pNDU->usri1_full_name, pszUsername) == 0);
        if (fReplaced)
        {
            lstrcpyW(pszUsername, pNDU->usri1_name);
        }
        nasCode = NetApiBufferFree(pNDU);
        if (!fReplaced)
        {
            nasCode = NetQueryDisplayInformation(NULL,
                                                 1,
                                                 ++dwIndex,
                                                 1,
                                                 sizeof(NET_DISPLAY_USER),
                                                 &dwReturnedEntryCount,
                                                 (void**)&pNDU);
        }
    }
    return(fReplaced);
}

BOOL    ReplacedLogonName (PGLOBALS pGlobals)

{
    BOOL    fReplaced;

    fReplaced = ReplacedPossibleDisplayName(pGlobals->UserName);
    if (fReplaced)
    {
        RtlInitUnicodeString(&pGlobals->UserNameString, pGlobals->UserName);
    }
    return(fReplaced);
}

DWORD
AttemptLogonThread(
    PGLOBALS pGlobals
    )
{
    STRING  PackageName;
    PSID    LogonSid;
    LUID    LogonId = { 0, 0 };
    HANDLE  UserToken = NULL;
    HANDLE  RestrictedToken;
    BOOL    PasswordExpired, ChangedLogonName;
    NTSTATUS FinalStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    INT_PTR Result = MSGINA_DLG_FAILURE;
    ULONG   LogonPackage;
    BYTE    GroupsBuffer[sizeof(TOKEN_GROUPS)+sizeof(SID_AND_ATTRIBUTES)];
    PTOKEN_GROUPS TokenGroups = (PTOKEN_GROUPS) GroupsBuffer;
    PVOID   AuthInfo ;
    ULONG   AuthInfoSize ;
    UCHAR   UserBuffer[ SID_MAX_SUB_AUTHORITIES * sizeof( DWORD ) + 8 + sizeof( TOKEN_USER ) ];
    PTOKEN_USER pTokenUser ;
    ULONG   TokenInfoSize ;
    PUCHAR  SmartCardInfo ;
    SECURITY_LOGON_TYPE     logonType;
    PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

#ifdef SMARTCARD_DOGFOOD
    DWORD StartTime = 0, EndTime = 0;
#endif

    //
    // Store the logon time
    // Do this before calling Lsa so we know if logon is successful that
    // the password-must-change time will be greater than this time.
    // If we grabbed this time after calling the lsa, this might not be true.
    //


    if ( IsActiveConsoleSession()  )
    {
        // this is the console logon;
        logonType = Interactive;
    }
    else
    {
        // remote sessions user must have the SeRemoteInteractiveLogonRight right which
        // is granted to a user due to their membership in the new Remote-Desktop Users group.
        logonType = RemoteInteractive;
    }

    GetSystemTimeAsFileTime( (LPFILETIME) &pGlobals->LogonTime );

    DebugLog((DEB_TRACE, "In Attempt Logon!\n"));

    if ( pGlobals->RasUsed )
    {
        if ( DCacheGetCacheState( pGlobals->Cache ) < DomainCacheRegistryCache )
        {
            //
            // We are using really stale data.  Poke the cache to get it to use the
            // now made RAS connection
            //

            DCacheUpdateMinimal( pGlobals->Cache, NULL, TRUE );
        }
    }

    //
    // Generate a unique sid for this logon
    //
    LogonSid = pGlobals->LogonSid;

    SetupCursor( TRUE );

    FinalStatus = STATUS_SUCCESS;

    if ( wcschr( pGlobals->UserName, L'\\' ) ||
         wcschr( pGlobals->UserName, L'/' ) )
    {
        FinalStatus = STATUS_LOGON_FAILURE ;
        Status = FinalStatus ;
    }

    // clear card and reader name
    pGlobals->Smartcard[0] = TEXT('\0');
    pGlobals->SmartcardReader[0] = TEXT('\0');

    if ( NT_SUCCESS( FinalStatus ) )
    {
        if ( pGlobals->SmartCardLogon )
        {
            pGlobals->AuthenticationPackage = pGlobals->SmartCardLogonPackage ;
        }
        else
        {
            pGlobals->AuthenticationPackage = pGlobals->PasswordLogonPackage ;

        }

        if ( pGlobals->SmartCardLogon )
        {
            pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_SMART_CARD_INFO,
                                     (ULONG_PTR *) &ScInfo );

            if ( !ScInfo )
            {
                goto exit;
            }


            SmartCardInfo = ScBuildLogonInfo(
                                ScInfo->pszCard,
                                ScInfo->pszReader,
                                ScInfo->pszContainer,
                                ScInfo->pszCryptoProvider );

            if(ScInfo->pszCard && ScInfo->pszReader) {

                wcsncpy(
                    pGlobals->Smartcard, 
                    ScInfo->pszCard, 
                    sizeof(pGlobals->Smartcard) / sizeof(TCHAR) - 1
                    );

                wcsncpy(
                    pGlobals->SmartcardReader, 
                    ScInfo->pszReader, 
                    sizeof(pGlobals->SmartcardReader) / sizeof(TCHAR) - 1
                    );
            }

#ifndef SMARTCARD_DOGFOOD
            LocalFree( ScInfo );
#endif

            AuthInfo = FormatSmartCardCredentials(
                            &pGlobals->PasswordString,
                            SmartCardInfo,
                            FALSE,
                            NULL,
                            &AuthInfoSize );

            LocalFree( SmartCardInfo );

        }
        else
        {
            AuthInfo = FormatPasswordCredentials(
                            &pGlobals->UserNameString,
                            &pGlobals->DomainString,
                            &pGlobals->PasswordString,
                            FALSE,
                            NULL,
                            &AuthInfoSize );

        }

        //
        // Actually try to logon the user
        //

#ifdef SMARTCARD_DOGFOOD
        StartTime = GetTickCount();
#endif

        FinalStatus = WinLogonUser(
                            pGlobals->LsaHandle,
                            pGlobals->AuthenticationPackage,
                            logonType,
                            AuthInfo,
                            AuthInfoSize,
                            LogonSid,
                            &LogonId,
                            &UserToken,
                            &pGlobals->UserProcessData.Quotas,
                            (PVOID *)&pGlobals->Profile,
                            &pGlobals->ProfileLength,
                            &SubStatus,
                            &pGlobals->OptimizedLogonStatus);

#ifdef SMARTCARD_DOGFOOD
        EndTime = GetTickCount();
#endif

        Status = FinalStatus;
    }

    SetupCursor( FALSE );

    RtlEnterCriticalSection( &pGlobals->csGlobals );
    pGlobals->LogonInProgress = FALSE;
    RtlLeaveCriticalSection( &pGlobals->csGlobals );

    DebugLog((DEB_TRACE, "WinLogonUser returned %#x\n", Status));

    PasswordExpired = (((Status == STATUS_ACCOUNT_RESTRICTION) && (SubStatus == STATUS_PASSWORD_EXPIRED)) ||
                           (Status == STATUS_PASSWORD_MUST_CHANGE));

    //
    // If the account has expired we let them change their password and
    // automatically retry the logon with the new password.
    //

    if (PasswordExpired)
    {
        _Shell_LogonDialog_HideUIHost();

        if (Status == STATUS_PASSWORD_MUST_CHANGE)
        {

            Result = TimeoutMessageBox(pGlobals->hwndLogon, pGlobals, IDS_PASSWORD_MUST_CHANGE,
                                             IDS_LOGON_MESSAGE,
                                             MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                                             TIMEOUT_CURRENT);

        }
        else
        {

            Result = TimeoutMessageBox(pGlobals->hwndLogon, pGlobals, IDS_PASSWORD_EXPIRED,
                                             IDS_LOGON_MESSAGE,
                                             MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                                             TIMEOUT_CURRENT);

        }

        if (DLG_INTERRUPTED(Result))
            goto exit;

        //
        // Copy the old password for mpr notification later
        //

        RevealPassword( &pGlobals->PasswordString  );
        wcsncpy(pGlobals->OldPassword, pGlobals->Password, MAX_STRING_BYTES);
        pGlobals->OldSeed = 0;
        RtlInitUnicodeString(&pGlobals->OldPasswordString, pGlobals->OldPassword);
        HidePassword( &pGlobals->OldSeed, &pGlobals->OldPasswordString);
        pGlobals->OldPasswordPresent = 1;

        //
        // Let the user change their password
        //

        LogonPackage = pGlobals->AuthenticationPackage ;

        RtlInitString(&PackageName, MSV1_0_PACKAGE_NAME );
        Status = LsaLookupAuthenticationPackage (
                    pGlobals->LsaHandle,
                    &PackageName,
                    &pGlobals->AuthenticationPackage
                    );

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR, "Failed to find %s authentication package, status = 0x%lx",
                    MSV1_0_PACKAGE_NAME, Status));

            Result = MSGINA_DLG_FAILURE;
            goto exit;
        }


        Result = ChangePasswordLogon(pGlobals->hwndLogon, pGlobals,
                                     pGlobals->UserName,
                                     pGlobals->Domain,
                                     pGlobals->Password);

        pGlobals->AuthenticationPackage = LogonPackage ;

        if (DLG_INTERRUPTED(Result))
            goto exit;

        if (Result == MSGINA_DLG_FAILURE)
        {
            // The user doesn't want to, or failed to change their password.
                goto exit;
        }
    }

    // Special handling for failed logon on personal or professional
    // machines that are NOT joined to a domain. In this case it's
    // probably a user who disabled friendly UI and only knows of
    // their "display name" not their real "logon name". This
    // transparently maps one to the other to allow logons using
    // the "display name".

    ChangedLogonName = ((FinalStatus == STATUS_LOGON_FAILURE) &&
                        (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL)) &&
                        !IsMachineDomainMember() &&
                        ReplacedLogonName(pGlobals));

    if (PasswordExpired || ChangedLogonName)
    {

        //
        // Retry the logon with the changed password
        //

        //
        // Generate a unique sid for this logon
        //
        LogonSid = pGlobals->LogonSid;

        AuthInfo = FormatPasswordCredentials(
                        &pGlobals->UserNameString,
                        &pGlobals->DomainString,
                        &pGlobals->PasswordString,
                        FALSE,
                        NULL,
                        &AuthInfoSize );


        Status = WinLogonUser(
                            pGlobals->LsaHandle,
                            pGlobals->AuthenticationPackage,
                            logonType,
                            AuthInfo,
                            AuthInfoSize,
                            LogonSid,
                            &LogonId,
                            &UserToken,
                            &pGlobals->UserProcessData.Quotas,
                            (PVOID *)&pGlobals->Profile,
                            &pGlobals->ProfileLength,
                            &SubStatus,
                            &pGlobals->OptimizedLogonStatus);

    }

    //
    // Deal with a terminally failed logon attempt
    //
    if (!NT_SUCCESS(Status))
    {
        //
        // Do lockout processing
        //

        LockoutHandleFailedLogon(pGlobals);

        Result = MSGINA_DLG_FAILEDMSGSENT;

        PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals, Status, SubStatus, pGlobals->UserName, pGlobals->Domain);

        goto exit;
    }


    //
    // The user logged on successfully
    //


    //
    // Do lockout processing
    //

    LockoutHandleSuccessfulLogon(pGlobals);



    //
    // If the audit log is full, check they're an admin
    //

    if (pGlobals->AuditLogFull)
    {

        //
        // The audit log is full, so only administrators are allowed to logon.
        //

        if (!UserToken || !TestTokenForAdmin(UserToken))
        {

            //
            // The user is not an administrator, boot 'em.
            //

            LsaFreeReturnBuffer(pGlobals->Profile);
            pGlobals->Profile = NULL;
            NtClose(UserToken);

            Result = MSGINA_DLG_FAILEDMSGSENT;

                // Post a specific substatus so we can display a meaningful error message
            PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals, STATUS_LOGON_FAILURE, IDS_LOGON_LOG_FULL, pGlobals->UserName, pGlobals->Domain);

            goto exit;
        }
        else
        {
            //
            // If we are in a session, we didn't display the log full onfo on the welcome
            // screen, so tell the admin
            //

            if (GetSystemMetrics(SM_REMOTESESSION))
            {
                TimeoutMessageBox(
                    pGlobals->hwndLogon,
                    pGlobals,
                    IDS_LOGON_LOG_FULL_ADMIN,
                    IDS_LOGON_MESSAGE,
                    MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                    TIMEOUT_CURRENT);
            }
        }
    }


    //
    // Hide ourselves before letting other credential managers put
    // up dialogs
    //

#if 0
    ShowWindow(hDlg, SW_HIDE);
#endif

    //
    // Create a filtered version of the token for running normal applications
    // if so indicated by a registry setting
    //


    if (GetProfileInt( APPLICATION_NAME, RESTRICT_SHELL, 0) != 0) {

        TokenGroups->Groups[0].Attributes = 0;
        TokenGroups->Groups[0].Sid = gAdminSid;
        TokenGroups->GroupCount = 1;

        Status = NtFilterToken(
                    UserToken,
                    DISABLE_MAX_PRIVILEGE,
                    TokenGroups,   // disable the administrators sid
                    NULL,           // no privileges
                    NULL,
                    &RestrictedToken
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to filter token: 0x%%x\n", Status));
            RestrictedToken = NULL;
        }

        //
        // Now set the default dacl for the token
        //

        {
            PACL Dacl = NULL;
            ULONG DaclLength = 0;
            TOKEN_DEFAULT_DACL DefaultDacl;

            DaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(LogonSid);
            Dacl = Alloc(DaclLength);
            Status = RtlCreateAcl(Dacl,DaclLength, ACL_REVISION);
            ASSERT(NT_SUCCESS(Status));
            Status = RtlAddAccessAllowedAce(
                        Dacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        LogonSid
                        );
            ASSERT(NT_SUCCESS(Status));
            DefaultDacl.DefaultDacl = Dacl;
            Status = NtSetInformationToken(
                        RestrictedToken,
                        TokenDefaultDacl,
                        &DefaultDacl,
                        sizeof(TOKEN_DEFAULT_DACL)
                        );
            ASSERT(NT_SUCCESS(Status));

            Free(Dacl);
        }


    } else {
        RestrictedToken = NULL;
    }

    //
    // Notify credential managers of the successful logon
    //

    pTokenUser = (PTOKEN_USER) UserBuffer ;
    Status = NtQueryInformationToken( UserToken,
                                      TokenUser,
                                      pTokenUser,
                                      sizeof( UserBuffer ),
                                      &TokenInfoSize );

    if ( NT_SUCCESS( Status ) )
    {
        pGlobals->UserProcessData.UserSid = LocalAlloc( LMEM_FIXED,
                                            RtlLengthSid( pTokenUser->User.Sid ) );

        if ( pGlobals->UserProcessData.UserSid )
        {
            RtlCopyMemory( pGlobals->UserProcessData.UserSid,
                           pTokenUser->User.Sid,
                           RtlLengthSid( pTokenUser->User.Sid ) );
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {

        LsaFreeReturnBuffer(pGlobals->Profile);
        pGlobals->Profile = NULL;
        NtClose(UserToken);

        Result = MSGINA_DLG_FAILEDMSGSENT;

        PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals, Status, 0, pGlobals->UserName, pGlobals->Domain);

        goto exit;
    }

    pGlobals->UserProcessData.RestrictedToken = RestrictedToken;
    pGlobals->UserProcessData.UserToken = UserToken;
    pGlobals->UserProcessData.NewThreadTokenSD = CreateUserThreadTokenSD(LogonSid, pWinlogonSid);

    pGlobals->MprLogonScripts = NULL;

    pGlobals->ExtraApps = NULL ;

    //
    // If we get here, the system works well enough for the user to have
    // actually logged on.  Profile failures aren't fixable by last known
    // good anyway.  Therefore, declare the boot good.
    //

    ReportBootGood(pGlobals);

    //
    // Set up the system for the new user
    //

    pGlobals->LogonId = LogonId;
    if ((pGlobals->Profile != NULL) && (pGlobals->Profile->FullName.Length > 0)) {
        if (pGlobals->Profile->FullName.Length > MAX_STRING_LENGTH) {
                wcsncpy(pGlobals->UserFullName, pGlobals->Profile->FullName.Buffer, MAX_STRING_LENGTH);
            *(pGlobals->UserFullName + MAX_STRING_LENGTH) = UNICODE_NULL;
        }
        else {
                lstrcpy(pGlobals->UserFullName, pGlobals->Profile->FullName.Buffer);
        }

    } else {

        //
        // No profile - set full name = NULL

        pGlobals->UserFullName[0] = 0;
        ASSERT( lstrlen(pGlobals->UserFullName) == 0);
    }

    if ( pGlobals->SmartCardLogon )
    {
        PCCERT_CONTEXT Cert ;
        PKERB_SMART_CARD_PROFILE ScProfile ;

        //
        // Need to fix up the user name with the name (UPN) from the
        // certificate, so that unlock, etc. work correctly.
        //

        ScProfile = (PKERB_SMART_CARD_PROFILE) pGlobals->Profile ;

        pGlobals->UserName[0] = 0 ;

        try
        {
            Cert = CertCreateCertificateContext( X509_ASN_ENCODING,
                                                 ScProfile->CertificateData,
                                                 ScProfile->CertificateSize );

            if ( Cert )
            {
                // Even though the name is MAX_STRING_BYTES, the way it is used
                // throughout the code, it is used as a character counter
                // (Grrr, crappy gina code)
                //
                DWORD  dwLen = MAX_STRING_BYTES;
                if(STATUS_SUCCESS == UpnFromCert(Cert, &dwLen, pGlobals->UserName))
                {
                    RtlInitUnicodeString( &pGlobals->UserNameString,
                                          pGlobals->UserName );
                }

                CertFreeCertificateContext( Cert );
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            pGlobals->UserName[0] = L'\0';
        }

        //
        // If this is still 0 on exit, the code that sets up the flat name
        // will copy the flat name into UserName, so the failure case is
        // easy.
        //

    }

    pGlobals->SmartCardOption = GetProfileInt( APPLICATION_NAME, SC_REMOVE_OPTION, 0 );

    //
    // WE SHOULD NOT WRITE INTO THE REGISTRY.
    // CLupu
    //

    //
    // Update our default username and domain ready for the next logon
    //

    //
    // Update the default username & domain only if on the console. Otherwise
    // we'll break AutoAdminLogon by changing the user name.
    //
    if ( g_Console )
    {
        if ( (!pGlobals->AutoAdminLogon) &&
             (SafeBootMode != SAFEBOOT_MINIMAL ) )
        {
            WriteProfileString(APPLICATION_NAME, DEFAULT_USER_NAME_KEY, pGlobals->UserName);
            WriteProfileString(APPLICATION_NAME, DEFAULT_DOMAIN_NAME_KEY, pGlobals->Domain);
        }

        WriteProfileString(APPLICATION_NAME, TEMP_DEFAULT_USER_NAME_KEY, pGlobals->UserName);
        WriteProfileString(APPLICATION_NAME, TEMP_DEFAULT_DOMAIN_NAME_KEY, pGlobals->Domain);

    }

    if ( pGlobals->Domain[0] )
    {
        DCacheSetDefaultEntry( pGlobals->Cache,
                               pGlobals->Domain,
                               NULL );
    }

    Result = MSGINA_DLG_SUCCESS;

exit:

#ifdef SMARTCARD_DOGFOOD

    if (pGlobals->SmartCardLogon) {

        switch (SubStatus)
        {
            case STATUS_SMARTCARD_WRONG_PIN:
            case STATUS_SMARTCARD_CARD_BLOCKED:
            case STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED:
            case STATUS_SMARTCARD_NO_CARD:
            case STATUS_SMARTCARD_NO_KEY_CONTAINER:
            case STATUS_SMARTCARD_NO_CERTIFICATE:
            case STATUS_SMARTCARD_NO_KEYSET:
            case STATUS_SMARTCARD_IO_ERROR:
            case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
            case STATUS_SMARTCARD_CERT_EXPIRED:
            case STATUS_SMARTCARD_CERT_REVOKED:
            case STATUS_ISSUING_CA_UNTRUSTED:
            case STATUS_REVOCATION_OFFLINE_C:
            case STATUS_PKINIT_CLIENT_FAILURE:
                FinalStatus = SubStatus;
                break;

            default:
                break; // do NOTHING
        }

        // write logon data to database
        AuthMonitor(
                AuthOperLogon,
                g_Console,
                &pGlobals->UserNameString,
                &pGlobals->DomainString,
                (ScInfo ? ScInfo->pszCard : NULL),
                (ScInfo ? ScInfo->pszReader : NULL),
                (PKERB_SMART_CARD_PROFILE) pGlobals->Profile,
                EndTime - StartTime,
                FinalStatus
                );
    }

    if (ScInfo)
    {
        LocalFree( ScInfo );
    }
#endif
    // Only send a logon complete message if we haven't sent a failed
    // message. The failed message will send a logon complete message
    // when its done.
    if (Result != MSGINA_DLG_FAILEDMSGSENT)
    {
        PostMessage(pGlobals->hwndLogon, WM_LOGONCOMPLETE, 0, Result);
    }

    return 0L;
}


/****************************************************************************\
*
* FUNCTION: PostFailedLogonMessage
*
* PURPOSE:  Posts a message to the UI thread telling it to display a dialog that
*           tells the user why their logon attempt failed.
*
*           The window on the UI thread must correctly handle WM_HANDLEFAILEDLOGON
*           by calling HandleFailedLogon and the Free'ing the structure
*
* RETURNS:  void
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/
void PostFailedLogonMessage(HWND hDlg,
    PGLOBALS pGlobals,
    NTSTATUS Status,
    NTSTATUS SubStatus,
    PWCHAR UserName,
    PWCHAR Domain
    )

{
    g_failinfo.pGlobals = pGlobals;
    g_failinfo.Status = Status;
    g_failinfo.SubStatus = SubStatus;
    if ( UserName )
    {
        lstrcpyn(g_failinfo.UserName, UserName, ARRAYSIZE(g_failinfo.UserName));
    }
    else
    {
        g_failinfo.UserName[0] = L'\0';
    }

    if ( Domain )
    {
        lstrcpyn(g_failinfo.Domain, Domain, ARRAYSIZE(g_failinfo.Domain));
    }
    else
    {
        g_failinfo.Domain[0] = L'\0' ;
    }


    PostMessage(hDlg, WM_HANDLEFAILEDLOGON, 0 , 0);
}

INT_PTR
CALLBACK
FailDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    RUNDLLPROC fptr;
    HMODULE hDll;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            CentreWindow(hDlg);
            return( TRUE );
        }

        case WM_COMMAND:
            {
                if (LOWORD(wParam) == IDOK)
                {
                    EndDialog(hDlg, IDOK);
                }
                if (LOWORD(wParam) == IDC_RECOVER)
                {
                    // Will eventually supply username to the recover wizard
                    // We use a single export from KEYMGR.DLL for this operation.  When this operation completes,
                    //  we don't use the DLL again without unlikely user intervention.  We could DELAYLOAD keymgr.dll,
                    //  but explicitly loading and unloading this DLL permits us to minimize the memory footprint of msgina.
                    hDll = LoadLibraryW(L"keymgr.dll");
                    if (hDll) 
                    {
                        fptr = (RUNDLLPROC) GetProcAddress(hDll,(LPCSTR)"PRShowRestoreFromMsginaW");
                        // next stmt will be removed eventually when we pass the username
                        if (fptr) 
                        {
                            fptr(hDlg,NULL,g_failinfo.UserName,0);
                        }
                        FreeLibrary(hDll);
                        EndDialog(hDlg,IDOK);
                    }
                }
            }
            break;
    }

    return FALSE;
}

/****************************************************************************\
*
* FUNCTION: HandleFailedLogon
*
* PURPOSE:  Tells the user why their logon attempt failed.
*
* RETURNS:  MSGINA_DLG_FAILURE - we told them what the problem was successfully.
*           DLG_INTERRUPTED() - a set of return values - see winlogon.h
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

INT_PTR
HandleFailedLogon(
    HWND hDlg
    )
{
    INT_PTR Result = 0xffffffff;
    DWORD Win32Error ;
    TCHAR    *Buffer1 = NULL;
    TCHAR    *Buffer2 = NULL;
    TCHAR    *Buffer3 = NULL;
    PGLOBALS pGlobals = g_failinfo.pGlobals;
    NTSTATUS Status = g_failinfo.Status;
    NTSTATUS SubStatus = g_failinfo.SubStatus;
    PWCHAR Domain = g_failinfo.Domain;
    DWORD BUStatus = 0xffffffff;

    UINT uiMsgId = 0xabab;     // abab is out of range value for default handler at the bottom of this
                            // routine.  0 indicates that the user has a psw reset disk
                            // -1 means that Buffer1 & 2 contain the message
                            // otherwise there is a corresponding resource message


    //
    // for remote sessions, we must set finite timeout value for messagebox.
    // so that the session does not remain there forever
    //
    DWORD TimeOut = IsActiveConsoleSession() ? TIMEOUT_CURRENT : 20;

    switch (Status)
    {

        case STATUS_LOGON_FAILURE:
        case STATUS_NAME_TOO_LONG: // Returned if username is too long

            if (SubStatus == IDS_LOGON_LOG_FULL)
            {
                uiMsgId = IDS_LOGON_LOG_FULL;
            }
            else if (pGlobals->SmartCardLogon)
            {
                switch(SubStatus)
                {
                    case STATUS_SMARTCARD_WRONG_PIN:
                        uiMsgId = IDS_STATUS_SMARTCARD_WRONG_PIN;
                        break;
                    case STATUS_SMARTCARD_CARD_BLOCKED:
                        uiMsgId = IDS_STATUS_SMARTCARD_CARD_BLOCKED;
                        break;
                    case STATUS_SMARTCARD_NO_CARD:
                        uiMsgId = IDS_STATUS_SMARTCARD_NO_CARD;
                        break;
                    case STATUS_SMARTCARD_NO_KEY_CONTAINER:
                        uiMsgId = IDS_STATUS_SMARTCARD_NO_KEY_CONTAINER;
                        break;
                    case STATUS_SMARTCARD_NO_CERTIFICATE:
                        uiMsgId = IDS_STATUS_SMARTCARD_NO_CERTIFICATE;
                        break;
                    case STATUS_SMARTCARD_NO_KEYSET:
                        uiMsgId = IDS_STATUS_SMARTCARD_NO_KEYSET;
                        break;
                    case STATUS_SMARTCARD_IO_ERROR:
                        uiMsgId = IDS_STATUS_SMARTCARD_IO_ERROR;
                        break;
                    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
                        uiMsgId = IDS_STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                        break;
                    case STATUS_SMARTCARD_CERT_REVOKED:
                        uiMsgId = IDS_STATUS_SMARTCARD_CERT_REVOKED;
                        break;
                    case STATUS_ISSUING_CA_UNTRUSTED:
                        uiMsgId = IDS_STATUS_ISSUING_CA_UNTRUSTED;
                        break;
                    case STATUS_REVOCATION_OFFLINE_C:
                        uiMsgId = IDS_STATUS_REVOCATION_OFFLINE_C;
                        break;
                    case STATUS_PKINIT_CLIENT_FAILURE:
                        uiMsgId = IDS_STATUS_PKINIT_CLIENT_FAILURE;
                        break;
                    case STATUS_SMARTCARD_CERT_EXPIRED:
                        uiMsgId = IDS_STATUS_SMARTCARD_CERT_EXPIRED;
                        break;
                    default:
                        uiMsgId = IDS_INCORRECT_NAME_OR_PWD_SC;
                }
            }
            else
            {
                // Non-smartcard logon case:
                // Find out if the user who attempted logon has a password backup disk
                //  that could be used to reset the password.  If so, present a dialog that
                //  offers that possibility.  Else simple message box. (see passrec.h)
                if ((0 == PRQueryStatus(NULL,g_failinfo.UserName,&BUStatus)) && (0 == GetSystemMetrics(SM_REMOTESESSION)))
                {
                    if (BUStatus == 0) 
                    {
                        uiMsgId = 0;
                        break;
                    }
                }
                // Else UI message is generic one
                uiMsgId = IDS_INCORRECT_NAME_OR_PWD;
            }
            break;

        case STATUS_NOT_SUPPORTED:
        case STATUS_PKINIT_NAME_MISMATCH:
        case STATUS_PKINIT_FAILURE:

            Buffer1 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));
            Buffer2 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));

            if ((Buffer1 == NULL) || (Buffer2 == NULL))
            {
                uiMsgId = IDS_STATUS_SERVER_SIDE_ERROR_NOINSERT;
            }
            else
            {
                LoadString(hDllInstance,
                           IDS_STATUS_SERVER_SIDE_ERROR,
                           Buffer1,
                           MAX_STRING_BYTES);

                _snwprintf(Buffer2, MAX_STRING_BYTES, Buffer1, Status );

                LoadString(hDllInstance,
                           IDS_LOGON_MESSAGE,
                           Buffer1,
                           MAX_STRING_BYTES);

                uiMsgId = (DWORD)-1;
            }

            break;

        case STATUS_ACCOUNT_RESTRICTION:

            switch (SubStatus)
            {
                case STATUS_INVALID_LOGON_HOURS:
                    uiMsgId = IDS_INVALID_LOGON_HOURS;
                    break;

                case STATUS_INVALID_WORKSTATION:
                    uiMsgId = IDS_INVALID_WORKSTATION;
                    break;

                case STATUS_ACCOUNT_DISABLED:
                    uiMsgId = IDS_ACCOUNT_DISABLED;
                    break;

                case STATUS_ACCOUNT_EXPIRED:
                    uiMsgId = IDS_ACCOUNT_EXPIRED2;
                    break;

                case STATUS_SMARTCARD_LOGON_REQUIRED:
                    uiMsgId = IDS_SMARTCARD_REQUIRED;
                    break;

                default:
                    uiMsgId = IDS_ACCOUNT_RESTRICTION;
                    break;
            }
            break;

        case STATUS_NO_LOGON_SERVERS:

            Buffer1 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));
            Buffer2 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));

            if ((Buffer1 == NULL) || (Buffer2 == NULL))
            {
                uiMsgId = IDS_LOGON_NO_DOMAIN_NOINSERT;
            }
            else
            {
                LoadString(hDllInstance, IDS_LOGON_NO_DOMAIN, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, MAX_STRING_BYTES, Buffer1, Domain);

                LoadString(hDllInstance, IDS_LOGON_MESSAGE, Buffer1, MAX_STRING_BYTES);

                uiMsgId = (DWORD)-1;
            }
            break;

        case STATUS_LOGON_TYPE_NOT_GRANTED:
            uiMsgId = IDS_LOGON_TYPE_NOT_GRANTED;
            break;

        case STATUS_NO_TRUST_LSA_SECRET:
            uiMsgId = IDS_NO_TRUST_LSA_SECRET;
            break;

        case STATUS_TRUSTED_DOMAIN_FAILURE:
            uiMsgId = IDS_TRUSTED_DOMAIN_FAILURE;
            break;

        case STATUS_TRUSTED_RELATIONSHIP_FAILURE:
            uiMsgId = IDS_TRUSTED_RELATIONSHIP_FAILURE;
            break;

        case STATUS_ACCOUNT_EXPIRED:
            uiMsgId = IDS_ACCOUNT_EXPIRED;
            break;

        case STATUS_NETLOGON_NOT_STARTED:
            uiMsgId = IDS_NETLOGON_NOT_STARTED;
            break;

        case STATUS_ACCOUNT_LOCKED_OUT:
            uiMsgId = IDS_ACCOUNT_LOCKED;
            break;

        case ERROR_CTX_LOGON_DISABLED:
            uiMsgId = IDS_MULTIUSER_LOGON_DISABLED;
            break;

        case ERROR_CTX_WINSTATION_ACCESS_DENIED:
            uiMsgId = IDS_MULTIUSER_WINSTATION_ACCESS_DENIED;
            break;

        case SCARD_E_NO_SMARTCARD:
        case SCARD_E_UNKNOWN_CARD:
            //
            // Card not recognized (although we should never get this far)
            //
            uiMsgId = IDS_CARD_NOT_RECOGNIZED;
            break;


        case NTE_PROV_DLL_NOT_FOUND:
            //
            // Card's CSP not found (although we should never get this far)
            //
            uiMsgId = IDS_CARD_CSP_NOT_RECOGNIZED;
            break;

        case STATUS_TIME_DIFFERENCE_AT_DC:
            uiMsgId = IDS_TIME_DIFFERENCE_AT_DC;
            break;

        default:

            WLPrint(("Logon failure status = 0x%lx, sub-status = 0x%lx", Status, SubStatus));

            Buffer1 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));
            Buffer2 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));
            Buffer3 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));

            if ((Buffer1 == NULL) || (Buffer2 == NULL) || (Buffer3 == NULL))
            {
                uiMsgId = IDS_UNKNOWN_LOGON_FAILURE_NOINSERT;
            }
            else
            {
                LoadString(hDllInstance,
                           IDS_UNKNOWN_LOGON_FAILURE,
                           Buffer1,
                           MAX_STRING_BYTES);

                if ( NT_ERROR( Status ) )
                {
                    Win32Error = RtlNtStatusToDosError( Status );
                }
                else
                {
                    //
                    // Probably an HRESULT:
                    //

                    Win32Error = Status ;
                }

                GetErrorDescription( Win32Error, Buffer3, MAX_STRING_BYTES);

                _snwprintf(Buffer2, MAX_STRING_BYTES, Buffer1, Buffer3 );

                LoadString(hDllInstance,
                           IDS_LOGON_MESSAGE,
                           Buffer1,
                           MAX_STRING_BYTES);

                uiMsgId = (DWORD)-1;
            }
            break;
    }

    _Shell_LogonDialog_HideUIHost();

    switch (uiMsgId)
    {
    case 0:
        // User has a password reset disk - present the option to use it along with the usual
        //  help message
        pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx,LOGON_TIMEOUT);
        Result = pWlxFuncs->WlxDialogBoxParam(pGlobals->hGlobalWlx,
                                          hDllInstance,
                                          (LPTSTR) IDD_FAILLOGONHELP_DIALOG,
                                          hDlg,
                                          FailDlgProc,
                                          0);
        break;

    case (DWORD)-1:
        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer2,
                                              Buffer1,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TimeOut);
        break;

    default:
        Result = TimeoutMessageBox(hDlg, pGlobals,
                                     uiMsgId,
                                     IDS_LOGON_MESSAGE,
                                     MB_OK | MB_ICONEXCLAMATION,
                                     TimeOut);
    }

    if (Buffer1 != NULL)
        LocalFree(Buffer1);
    if (Buffer2 != NULL)
        LocalFree(Buffer2);
    if (Buffer3 != NULL)
        LocalFree(Buffer3);

    if (!DLG_INTERRUPTED(Result))
    {
        Result = MSGINA_DLG_FAILURE;
    }

    return(Result);
}

VOID
ReportBootGoodThread (LPVOID lpDummy)
{
    HANDLE hInstDll;
//    PGLOBALS pGlobals = (PGLOBALS)lpDummy;

//    SetThreadDesktop(pGlobals->hdeskParent);

    hInstDll = LoadLibrary (TEXT("msgina.dll"));

    NotifyBootConfigStatus(TRUE);

    if (hInstDll) {
        FreeLibraryAndExitThread(hInstDll, TRUE);
    } else {
        ExitThread (TRUE);
    }
}


/****************************************************************************\
*
* FUNCTION: ReportBootGood
*
* PURPOSE:  Discover if reporting boot success is responsibility of
*           winlogon or not.
*           If it is, report boot success.
*           Otherwise, do nothing.
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   02-Feb-1993 bryanwi - created
*
\****************************************************************************/
VOID
ReportBootGood(PGLOBALS pGlobals)
{
    static DWORD fDoIt = (DWORD) -1;    // -1 == uninited
                                        // 0  == don't do it, or done
                                        // 1  == do it
    PWCH pchData;
    DWORD   cb, cbCopied;
    HANDLE hThread;
    DWORD dwThreadID;


    if (fDoIt == -1) {

        if ((pchData = Alloc(cb = sizeof(TCHAR)*128)) == NULL) {
            return;
        }

        pchData[0] = TEXT('0');
        cbCopied = GetProfileString(APPLICATION_NAME, REPORT_BOOT_OK_KEY, TEXT("0"),
                                    (LPTSTR)pchData, 128);

        fDoIt = 0;
        if (pchData[0] != TEXT('0')) {

            //
            // "ReportBootGood" is present, and has some value other than
            // '0', so report success.
            //
            fDoIt = 1;
        }

        Free((TCHAR *)pchData);
    }

    if (fDoIt == 1) {

        hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)ReportBootGoodThread,
                                pGlobals, CREATE_SUSPENDED, &dwThreadID);

        if (hThread) {
            SetThreadPriority (hThread, THREAD_PRIORITY_LOWEST);
            ResumeThread (hThread);
            CloseHandle (hThread);

        } else {
            NotifyBootConfigStatus(TRUE);
        }
        fDoIt = 0;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   UpnFromCert
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
UpnFromCert(
    IN PCCERT_CONTEXT pCert,
    IN OUT DWORD       *pcUpn,
    IN OUT LPWSTR      pUPN
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   ExtensionIndex = 0;
    PCERT_ALT_NAME_INFO AltName=NULL;
    PCERT_NAME_VALUE    PrincipalNameBlob = NULL;

    //
    // Get the client name from the cert
    //

    // See if cert has UPN in AltSubjectName->otherName
    for(ExtensionIndex = 0;
        ExtensionIndex < pCert->pCertInfo->cExtension;
        ExtensionIndex++)
    {
        if(strcmp(pCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                  szOID_SUBJECT_ALT_NAME2) == 0)
        {
            DWORD               AltNameStructSize = 0;
            ULONG               CertAltNameIndex = 0;
            if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                X509_ALTERNATE_NAME,
                                pCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                pCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                CRYPT_DECODE_ALLOC_FLAG,
                                NULL,
                                (PVOID)&AltName,
                                &AltNameStructSize))
            {

                for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                {
                    PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];
                    if((CERT_ALT_NAME_OTHER_NAME  == AltNameEntry->dwAltNameChoice) &&
                       (NULL != AltNameEntry->pOtherName) &&
                       (0 == strcmp(szOID_NT_PRINCIPAL_NAME, AltNameEntry->pOtherName->pszObjId)))
                    {
                        DWORD            PrincipalNameBlobSize = 0;

                        // We found a UPN!
                        if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameEntry->pOtherName->Value.pbData,
                                            AltNameEntry->pOtherName->Value.cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            NULL,
                                            (PVOID)&PrincipalNameBlob,
                                            &PrincipalNameBlobSize))
                        {
                            if(PrincipalNameBlob->Value.cbData + sizeof(WCHAR) > *pcUpn)
                            {
                                Status =  STATUS_BUFFER_OVERFLOW;
                            }
                            else
                            {
                                *pcUpn = PrincipalNameBlob->Value.cbData + sizeof(WCHAR);

                                CopyMemory(pUPN, PrincipalNameBlob->Value.pbData, PrincipalNameBlob->Value.cbData);
                                *(WCHAR *)((PBYTE)pUPN+PrincipalNameBlob->Value.cbData) = 0;
                            }

                            LocalFree(PrincipalNameBlob);
                            PrincipalNameBlob = NULL;
                            LocalFree(AltName);
                            AltName = NULL;

                            goto Finished;
                        }
                    }
                }
                LocalFree(AltName);
                AltName = NULL;
            }
        }
    }

    //
    // If the name was not found in the UPN, then
    // we grab it the old way.

    if ( !CertGetNameString( pCert,
                        CERT_NAME_ATTR_TYPE,
                        0,
                        szOID_COMMON_NAME,
                        pUPN,
                        *pcUpn ) )
    {
        Status = GetLastError();
    }

Finished:


    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:TSAuthenticatedLogon  
//
//  Notes: This routine gets called in response to WLX_SAS_TYPE_AUTHENTICATED  
//  in the context of the console session (sessionid 0) winlogon.
//  This type of logon is for Single Session Terminal Server. When a user
//  logs on from a remote TS session, we pass the credentials from the remote session
//  to the console session and do an auto-logon. This routine queries the credentials
//  logs on the user on the console sesion 
//
//
//----------------------------------------------------------------------------


INT_PTR TSAuthenticatedLogon(PGLOBALS pGlobals)
{
    PSID    LogonSid;
    LUID    LogonId;
    HANDLE  UserToken;
    HANDLE  RestrictedToken;
    INT_PTR Result = MSGINA_DLG_SUCCESS;
    UCHAR   UserBuffer[ SID_MAX_SUB_AUTHORITIES * sizeof( DWORD ) + 8 + sizeof( TOKEN_USER ) ];
    PTOKEN_USER pTokenUser ;
    ULONG   TokenInfoSize ;
    NTSTATUS Status;
    BYTE    GroupsBuffer[sizeof(TOKEN_GROUPS)+sizeof(SID_AND_ATTRIBUTES)];
    PTOKEN_GROUPS TokenGroups = (PTOKEN_GROUPS) GroupsBuffer;
 

    if (!QuerySwitchConsoleCredentials(pGlobals,&UserToken,&LogonId)) {
       Result = MSGINA_DLG_FAILEDMSGSENT;
       goto exit;
    }

    if (pGlobals->SmartCardLogon) {
        wcscpy(pGlobals->Password,L"");
        wcscpy(pGlobals->OldPassword,L"");
    
    }
    else
    {
        wcscpy(pGlobals->Password,L"");
        RtlInitUnicodeString(&pGlobals->PasswordString,pGlobals->Password);
        wcscpy(pGlobals->OldPassword,L"");
        RtlInitUnicodeString(&pGlobals->OldPasswordString,pGlobals->OldPassword);
    }

    RtlInitUnicodeString(&pGlobals->UserNameString, pGlobals->UserName);
    RtlInitUnicodeString(&pGlobals->DomainString, pGlobals->Domain);
    
    pGlobals->RasUsed = FALSE;

    pGlobals->hwndLogon = NULL;

    //
    // Generate a unique sid for this logon
    //
    if (!GetAndAllocateLogonSid(UserToken,&(pGlobals->LogonSid))) {
        Result = MSGINA_DLG_FAILEDMSGSENT;

        if (pGlobals->Profile) {
           VirtualFree(pGlobals->Profile, 0, MEM_RELEASE);
           pGlobals->Profile = NULL;
           pGlobals->ProfileLength = 0;
        }

        goto exit;
    }

    LogonSid = pGlobals->LogonSid;


    //
    // The user logged on successfully
    //


    //
    // Create a filtered version of the token for running normal applications
    // if so indicated by a registry setting
    //
   
   
    if (GetProfileInt( APPLICATION_NAME, RESTRICT_SHELL, 0) != 0) {
   
       TokenGroups->Groups[0].Attributes = 0;
       TokenGroups->Groups[0].Sid = gAdminSid;
       TokenGroups->GroupCount = 1;
   
       Status = NtFilterToken(
                   UserToken,
                   DISABLE_MAX_PRIVILEGE,
                   TokenGroups,   // disable the administrators sid
                   NULL,           // no privileges
                   NULL,
                   &RestrictedToken
                   );
       if (!NT_SUCCESS(Status))
       {
           DebugLog((DEB_ERROR, "Failed to filter token: 0x%%x\n", Status));
           RestrictedToken = NULL;
       }
   
       //
       // Now set the default dacl for the token
       //
   
       {
           PACL Dacl = NULL;
           ULONG DaclLength = 0;
           TOKEN_DEFAULT_DACL DefaultDacl;
   
           DaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(LogonSid);
           Dacl = Alloc(DaclLength);
           Status = RtlCreateAcl(Dacl,DaclLength, ACL_REVISION);
           ASSERT(NT_SUCCESS(Status));
           Status = RtlAddAccessAllowedAce(
                       Dacl,
                       ACL_REVISION,
                       GENERIC_ALL,
                       LogonSid
                       );
           ASSERT(NT_SUCCESS(Status));
           DefaultDacl.DefaultDacl = Dacl;
           Status = NtSetInformationToken(
                       RestrictedToken,
                       TokenDefaultDacl,
                       &DefaultDacl,
                       sizeof(TOKEN_DEFAULT_DACL)
                       );
           ASSERT(NT_SUCCESS(Status));
   
           Free(Dacl);
       }
   
   
    } else {
        RestrictedToken = NULL;
    }
    //
    // Notify credential managers of the successful logon
    //

    pTokenUser = (PTOKEN_USER) UserBuffer ;
    Status = NtQueryInformationToken( UserToken,
                                      TokenUser,
                                      pTokenUser,
                                      sizeof( UserBuffer ),
                                      &TokenInfoSize );

    if ( NT_SUCCESS( Status ) )
    {
        pGlobals->UserProcessData.UserSid = LocalAlloc( LMEM_FIXED,
                                            RtlLengthSid( pTokenUser->User.Sid ) );

        if ( pGlobals->UserProcessData.UserSid )
        {
            RtlCopyMemory( pGlobals->UserProcessData.UserSid,
                           pTokenUser->User.Sid,
                           RtlLengthSid( pTokenUser->User.Sid ) );
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {

        if (pGlobals->Profile) {
           VirtualFree(pGlobals->Profile, 0, MEM_RELEASE);
           pGlobals->Profile = NULL;
           pGlobals->ProfileLength = 0;
        }
        NtClose(UserToken);

        Result = MSGINA_DLG_FAILEDMSGSENT;

        goto exit;
    }

    pGlobals->UserProcessData.RestrictedToken = RestrictedToken;
    pGlobals->UserProcessData.UserToken = UserToken;
    pGlobals->UserProcessData.NewThreadTokenSD = CreateUserThreadTokenSD(LogonSid, pWinlogonSid);

    pGlobals->MprLogonScripts = NULL;

    pGlobals->ExtraApps = NULL ;

    //
    // If we get here, the system works well enough for the user to have
    // actually logged on.  Profile failures aren't fixable by last known
    // good anyway.  Therefore, declare the boot good.
    //

    ReportBootGood(pGlobals);

    //
    // Set up the system for the new user
    //

    pGlobals->LogonId = LogonId;
    if ((pGlobals->Profile != NULL) && (pGlobals->Profile->FullName.Length > 0)) {
        if (pGlobals->Profile->FullName.Length > MAX_STRING_LENGTH) {
                wcsncpy(pGlobals->UserFullName, pGlobals->Profile->FullName.Buffer, MAX_STRING_LENGTH);
            *(pGlobals->UserFullName + MAX_STRING_LENGTH) = UNICODE_NULL;
        }
        else {
                lstrcpy(pGlobals->UserFullName, pGlobals->Profile->FullName.Buffer);
        }

    } else {

        //
        // No profile - set full name = NULL

        pGlobals->UserFullName[0] = 0;
        ASSERT( lstrlen(pGlobals->UserFullName) == 0);
    }


    //
    // Update our default username and domain ready for the next logon
    //

    //
    // Update the default username & domain only if on the console. Otherwise
    // we'll break AutoAdminLogon by changing the user name.
    //
    if ( g_Console )
    {
        if ( (!pGlobals->AutoAdminLogon) &&
             (SafeBootMode != SAFEBOOT_MINIMAL ) )
        {
            WriteProfileString(APPLICATION_NAME, DEFAULT_USER_NAME_KEY, pGlobals->UserName);
            WriteProfileString(APPLICATION_NAME, DEFAULT_DOMAIN_NAME_KEY, pGlobals->Domain);
        }

        WriteProfileString(APPLICATION_NAME, TEMP_DEFAULT_USER_NAME_KEY, pGlobals->UserName);
        WriteProfileString(APPLICATION_NAME, TEMP_DEFAULT_DOMAIN_NAME_KEY, pGlobals->Domain);

    }

    if ( pGlobals->Domain[0] == '\0' )
    {

       GetProfileString( APPLICATION_NAME,
                         DEFAULT_DOMAIN_NAME_KEY,
                         TEXT(""),
                         pGlobals->Domain,
                         MAX_STRING_BYTES );
    }
   

    if ( !DCacheValidateCache( pGlobals->Cache ) )
    {
        ASSERT( pGlobals->ActiveArray == NULL );

        DCacheUpdateMinimal( pGlobals->Cache, pGlobals->Domain, TRUE );

    }
    else
    {
        //
        // Set the current default:
        //

        DCacheSetDefaultEntry( pGlobals->Cache,
                               pGlobals->Domain,
                               NULL );
    }

    Result = MSGINA_DLG_SUCCESS;

exit:

    return Result;

}


PWSTR
AllocAndDuplicateString(
    PWSTR   pszString,
    int     len)
{
    PWSTR   pszNewString;

    if (!pszString || !len)
    {
        return(NULL);
    }

    pszNewString = LocalAlloc(LMEM_FIXED, (len + 2)*sizeof(WCHAR));
    if (pszNewString)
    {
        wcsncpy(pszNewString, pszString, len);
        pszNewString[len] = UNICODE_NULL;
    }

    return(pszNewString);

}


BOOL
WINAPI
WlxGetConsoleSwitchCredentials (
   PVOID                pWlxContext,
   PVOID                pInfo
   )
{
    PGLOBALS pGlobals = (PGLOBALS) pWlxContext;
    PWLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 pReq = (PWLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0)pInfo;
    BOOL bReturn = FALSE;


    if (pReq->dwType != WLX_CONSOLESWITCHCREDENTIAL_TYPE_V1_0) {
       return FALSE;
    }

    //
    // Initialize allocated pointers.
    //

    pReq->UserName = NULL;
    pReq->Domain = NULL;
    pReq->LogonScript = NULL;
    pReq->HomeDirectory = NULL;
    pReq->FullName = NULL;
    pReq->ProfilePath = NULL;
    pReq->HomeDirectoryDrive = NULL;
    pReq->LogonServer = NULL;
    pReq->PrivateData = NULL;



    pReq->LogonId         = pGlobals->LogonId;
    pReq->UserToken       = pGlobals->UserProcessData.UserToken;
    pReq->LogonTime       = pGlobals->LogonTime;
    pReq->SmartCardLogon  = pGlobals->SmartCardLogon;

    pReq->UserName        = AllocAndDuplicateString(pGlobals->UserName,
                                                    (DWORD) wcslen(pGlobals->UserName));

    pReq->Domain          = AllocAndDuplicateString(pGlobals->Domain,
                                                    (DWORD) wcslen(pGlobals->Domain));
                                                                                                   
    //
    // Quota Information
    //
    pReq->Quotas.PagedPoolLimit         = pGlobals->UserProcessData.Quotas.PagedPoolLimit;
    pReq->Quotas.NonPagedPoolLimit      = pGlobals->UserProcessData.Quotas.NonPagedPoolLimit;
    pReq->Quotas.MinimumWorkingSetSize  = pGlobals->UserProcessData.Quotas.MinimumWorkingSetSize;
    pReq->Quotas.MaximumWorkingSetSize  = pGlobals->UserProcessData.Quotas.MaximumWorkingSetSize;
    pReq->Quotas.PagefileLimit          = pGlobals->UserProcessData.Quotas.PagefileLimit;
    pReq->Quotas.TimeLimit              = pGlobals->UserProcessData.Quotas.TimeLimit;
 
    //
    // Profile Information
    //
    pReq->ProfileLength              = pGlobals->ProfileLength;
    pReq->UserFlags                  = pGlobals->Profile->UserFlags;
    pReq->MessageType                = pGlobals->Profile->MessageType;
    pReq->LogonCount                 = pGlobals->Profile->LogonCount;
    pReq->BadPasswordCount           = pGlobals->Profile->BadPasswordCount;
    pReq->ProfileLogonTime           = pGlobals->Profile->LogonTime;
    pReq->LogoffTime                 = pGlobals->Profile->LogoffTime;
    pReq->KickOffTime                = pGlobals->Profile->KickOffTime;
    pReq->PasswordLastSet            = pGlobals->Profile->PasswordLastSet;
    pReq->PasswordCanChange          = pGlobals->Profile->PasswordCanChange;
    pReq->PasswordMustChange         = pGlobals->Profile->PasswordMustChange;

    pReq->LogonScript          = AllocAndDuplicateString(pGlobals->Profile->LogonScript.Buffer, pGlobals->Profile->LogonScript.Length/sizeof(WCHAR));
    pReq->HomeDirectory        = AllocAndDuplicateString(pGlobals->Profile->HomeDirectory.Buffer, pGlobals->Profile->HomeDirectory.Length/sizeof(WCHAR));
    pReq->FullName             = AllocAndDuplicateString(pGlobals->Profile->FullName.Buffer, pGlobals->Profile->FullName.Length/sizeof(WCHAR));

    pReq->ProfilePath          = AllocAndDuplicateString(pGlobals->Profile->ProfilePath.Buffer, pGlobals->Profile->ProfilePath.Length/sizeof(WCHAR));

    pReq->HomeDirectoryDrive   = AllocAndDuplicateString(pGlobals->Profile->HomeDirectoryDrive.Buffer, pGlobals->Profile->HomeDirectoryDrive.Length/sizeof(WCHAR));
    pReq->LogonServer          = AllocAndDuplicateString(pGlobals->Profile->LogonServer.Buffer, pGlobals->Profile->LogonServer.Length/sizeof(WCHAR));
    pReq->PrivateDataLen       = PASSWORD_HASH_SIZE;
    pReq->PrivateData          = (PBYTE)AllocAndDuplicateString((PWSTR)pGlobals->PasswordHash, PASSWORD_HASH_SIZE );
    if (pReq->PrivateData == NULL) {
        goto done;
    }

    memcpy(pReq->PrivateData, pGlobals->PasswordHash, PASSWORD_HASH_SIZE );

    bReturn = TRUE;
    
done:
    if (!bReturn) {
        if (pReq->UserName != NULL) {
            LocalFree(pReq->UserName);
        }
        if (pReq->Domain != NULL) {
            LocalFree(pReq->Domain);
        }
        if (pReq->LogonScript != NULL) {
            LocalFree(pReq->LogonScript);
        }
        if (pReq->HomeDirectory != NULL) {
            LocalFree(pReq->HomeDirectory);
        }
        if (pReq->FullName != NULL) {
            LocalFree(pReq->FullName);
        }
        if (pReq->ProfilePath != NULL) {
            LocalFree(pReq->ProfilePath);
        }
        if (pReq->HomeDirectoryDrive != NULL) {
            LocalFree(pReq->HomeDirectoryDrive);
        }
        if (pReq->LogonServer != NULL) {
            LocalFree(pReq->LogonServer);
        }
        if (pReq->PrivateData != NULL) {
            LocalFree(pReq->PrivateData);
        }
    }
    return bReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   QuerySwitchConsoleCredentials
//
//  Notes:
//
// Query credentials from session connecting to console to do switch console
//  This routine gets called in response to WLX_SAS_TYPE_AUTHENTICATED  
//  in the context of the console session (sessionid 0) winlogon.
//  This type of logon is for Single Session Terminal Server. When a user
//  logs on from a remote TS session, we pass the credentials from the remote session
//  to the console session and do an auto-logon. This routine queries the credentials,
//  logs on the user on the console sesion
//
//
//----------------------------------------------------------------------------

BOOL
WINAPI
QuerySwitchConsoleCredentials(PGLOBALS pGlobals, HANDLE * phUserToken, PLUID pLogonId)
{
    WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 CredInfo;

    RtlZeroMemory(&CredInfo,sizeof(CredInfo));

    CredInfo.dwType = WLX_CONSOLESWITCHCREDENTIAL_TYPE_V1_0;

    if (!pWlxFuncs->WlxQueryConsoleSwitchCredentials(&CredInfo)){
       return FALSE;
    }

    if (!CredInfo.UserToken || !CredInfo.UserName) {
       //return false if any of the critical information is missing
       return FALSE;
    }

    pGlobals->Profile = (PMSV1_0_INTERACTIVE_PROFILE) VirtualAlloc(NULL,
                                                                   sizeof(MSV1_0_INTERACTIVE_PROFILE),
                                                                   MEM_COMMIT,
                                                                   PAGE_READWRITE);
    

    if (pGlobals->Profile == NULL) {
       goto returnerror;
    }

    //
    // Token, LUID
    //
    *pLogonId           = CredInfo.LogonId;
    *phUserToken        = CredInfo.UserToken;
    pGlobals->LogonTime = CredInfo.LogonTime;
    pGlobals->SmartCardLogon = CredInfo.SmartCardLogon;

    pGlobals->SmartCardOption = GetProfileInt( APPLICATION_NAME, SC_REMOVE_OPTION, 0 );
 
    //
    // Quota Information
    //
    pGlobals->UserProcessData.Quotas.PagedPoolLimit         = CredInfo.Quotas.PagedPoolLimit ;
    pGlobals->UserProcessData.Quotas.NonPagedPoolLimit      = CredInfo.Quotas.NonPagedPoolLimit;
    pGlobals->UserProcessData.Quotas.MinimumWorkingSetSize  = CredInfo.Quotas.MinimumWorkingSetSize;
    pGlobals->UserProcessData.Quotas.MaximumWorkingSetSize  = CredInfo.Quotas.MaximumWorkingSetSize;
    pGlobals->UserProcessData.Quotas.PagefileLimit          = CredInfo.Quotas.PagefileLimit;
    pGlobals->UserProcessData.Quotas.TimeLimit              = CredInfo.Quotas.TimeLimit;
 
    //
    // Profile Information
    //
    pGlobals->ProfileLength               = CredInfo.ProfileLength;
    pGlobals->Profile->UserFlags          = CredInfo.UserFlags;
    pGlobals->Profile->MessageType        = CredInfo.MessageType;
    pGlobals->Profile->LogonCount         = CredInfo.LogonCount;
    pGlobals->Profile->BadPasswordCount   = CredInfo.BadPasswordCount;
    pGlobals->Profile->LogonTime          = CredInfo.ProfileLogonTime;
    pGlobals->Profile->LogoffTime         = CredInfo.LogoffTime;
    pGlobals->Profile->KickOffTime        = CredInfo.KickOffTime;
    pGlobals->Profile->PasswordLastSet    = CredInfo.PasswordLastSet;
    pGlobals->Profile->PasswordCanChange  = CredInfo.PasswordCanChange;
    pGlobals->Profile->PasswordMustChange = CredInfo.PasswordMustChange;
    
    
    RtlInitUnicodeString(&pGlobals->Profile->LogonScript, CredInfo.LogonScript);
    RtlInitUnicodeString(&pGlobals->Profile->HomeDirectory, CredInfo.HomeDirectory);
    RtlInitUnicodeString(&pGlobals->Profile->FullName, CredInfo.FullName);
    RtlInitUnicodeString(&pGlobals->Profile->ProfilePath, CredInfo.ProfilePath);
    RtlInitUnicodeString(&pGlobals->Profile->HomeDirectoryDrive, CredInfo.HomeDirectoryDrive);
    RtlInitUnicodeString(&pGlobals->Profile->LogonServer, CredInfo.LogonServer);


    if (CredInfo.UserName) {
       wcscpy(pGlobals->UserName,CredInfo.UserName);
       LocalFree(CredInfo.UserName);
    } else {
       wcscpy(pGlobals->UserName,L"");
    }

    if (CredInfo.Domain) {
       wcscpy(pGlobals->Domain,CredInfo.Domain);
       LocalFree(CredInfo.Domain);
    } else {
       wcscpy(pGlobals->Domain,L"");
    }

    if (CredInfo.PrivateDataLen) {
       RtlCopyMemory(pGlobals->PasswordHash,CredInfo.PrivateData, CredInfo.PrivateDataLen );
       LocalFree(CredInfo.PrivateData);
    } else {

       RtlZeroMemory(pGlobals->PasswordHash,PASSWORD_HASH_SIZE);
    }
    pGlobals->TransderedCredentials = TRUE;
   

   return TRUE;

returnerror:
        
       if (CredInfo.UserName) {
          LocalFree(CredInfo.UserName);
       }

       if (CredInfo.Domain) {
          LocalFree(CredInfo.Domain);
       }

       if (CredInfo.LogonScript) {
          LocalFree(CredInfo.LogonScript);
       }

       if (CredInfo.HomeDirectory) {
          LocalFree(CredInfo.HomeDirectory);
       }

       if (CredInfo.FullName) {
          LocalFree(CredInfo.FullName);
       }

       if (CredInfo.ProfilePath) {
          LocalFree(CredInfo.ProfilePath);
       }

       if (CredInfo.HomeDirectoryDrive) {
          LocalFree(CredInfo.HomeDirectoryDrive);
       }

       if (CredInfo.LogonServer) {
          LocalFree(CredInfo.LogonServer);
       }

       if (CredInfo.UserToken) {
         CloseHandle(CredInfo.UserToken);
       }
       if (pGlobals->Profile) {
          VirtualFree(pGlobals->Profile, 0, MEM_RELEASE);
          pGlobals->Profile = NULL;
          pGlobals->ProfileLength = 0;
       }
       return FALSE;

}


BOOL
GetAndAllocateLogonSid(
    HANDLE hToken,
    PSID *pLogonSid
    )
{
    PTOKEN_GROUPS ptgGroups = NULL;
    DWORD cbBuffer          = 512;  // allocation size
    DWORD dwSidLength;              // required size to hold Sid
    UINT i;                         // Sid index counter
    BOOL bSuccess           = FALSE; // assume this function will fail

    *pLogonSid = NULL; // invalidate pointer

    //
    // initial allocation attempts
    //
    ptgGroups=(PTOKEN_GROUPS)Alloc(cbBuffer);
    if(ptgGroups == NULL) return FALSE;

    __try {

    //
    // obtain token information.  reallocate memory if necessary
    //
    while(!GetTokenInformation(
                hToken, TokenGroups, ptgGroups, cbBuffer, &cbBuffer)) {

        //
        // if appropriate, reallocate memory, otherwise bail
        //
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // attempt to reallocate buffer
            //
            if((ptgGroups=(PTOKEN_GROUPS)ReAlloc(
                            ptgGroups, cbBuffer)) == NULL) __leave;
        }
        else __leave;
    }

    //
    // Get the logon Sid by looping through the Sids in the token
    //
    for(i = 0 ; i < ptgGroups->GroupCount ; i++) {
        if(ptgGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) {

            //
            // insure we are dealing with a valid Sid
            //
            if(!IsValidSid(ptgGroups->Groups[i].Sid)) __leave;

            //
            // get required allocation size to copy the Sid
            //
            dwSidLength=GetLengthSid(ptgGroups->Groups[i].Sid);

            //
            // allocate storage for the Logon Sid
            //
            if((*pLogonSid=(PSID *)Alloc(
                                    dwSidLength)) == NULL) __leave;

            //
            // copy the Logon Sid to the storage we just allocated
            //
            if(!CopySid(dwSidLength, *pLogonSid, ptgGroups->Groups[i].Sid)) __leave;

            bSuccess=TRUE; // indicate success...
            break;         // ...and get out
        }
    }

    } // try
    __finally {

    //
    // free allocated resources
    //
    if(ptgGroups != NULL) Free(ptgGroups);

    if(!bSuccess) {
        if(*pLogonSid != NULL) {
            Free(*pLogonSid);
            *pLogonSid = NULL;
        }
    }

    } // finally

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\pragma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    scpragma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let MSGINA compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\options.h ===
/****************************** Module Header ******************************\
* Module Name: options.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis used to implement security options dialog
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//


INT_PTR
SecurityOptions(
    PGLOBALS
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\mslock.c ===
//e+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mslock.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include <stdio.h>
#include <wchar.h>
#include "shlwapi.h"
#include "shlwapip.h"

#define WM_SMARTCARD_ASYNC_MESSAGE      (WM_USER + 201)
#define WM_SMARTCARD_ERROR_DISPLAY_1    (WM_USER + 202)
#define WM_SMARTCARD_ERROR_DISPLAY_2    (WM_USER + 203)

#define MSGINA_DLG_ASYNC_PROCESSING      122

static UINT ctrlNoDomain[] =
{
    IDOK,
    IDCANCEL,
    IDD_UNLOCK_OPTIONS,
    IDD_KBLAYOUT_ICON,
};

static UINT ctrlNoUserName[] =
{
    IDD_UNLOCK_DOMAIN,
    IDD_UNLOCK_DOMAIN_LABEL,
    IDD_UNLOCK_PASSWORD,
    IDC_UNLOCK_PASSWORD_LABEL,
    IDOK,
    IDCANCEL,
    IDD_UNLOCK_OPTIONS,
    IDD_KBLAYOUT_ICON,
};

//
// Define the structure used to pass data into the lock dialogs
//

typedef enum _LOCKED_STATE_DIALOGS {
    LockedDialog,
    PasswordDialog,
    PINDialog
} LOCKED_STATE_DIALOGS ;

typedef enum _ACTION_TAKEN {
    None,
    SmartCardInserted,
    SmartCardRemoved,
    CancelHit
} ACTION_TAKEN ;

typedef struct {
    PGLOBALS    pGlobals;
    TIME        LockTime;
} LOCK_DATA;
typedef LOCK_DATA *PLOCK_DATA;

typedef struct _UNLOCK_DLG_STATE {
    PGLOBALS        pGlobals ;
    DWORD           dwSasType ;
    ACTION_TAKEN    ActionTaken;
    BOOL            fKillTimer;
    BOOL            fUserBeingPrompted;                    
    BOOL            fCardRemoved;
} UNLOCK_DLG_STATE, * PUNLOCK_DLG_STATE ;

typedef struct _ASYNC_UNLOCK_DATA {
    PGLOBALS            pGlobals;
    HWND                hDlg;
    PUNLOCK_DLG_STATE   pUnlockDlgState;
    UNICODE_STRING      UserName;
    UNICODE_STRING      Domain;
    UNICODE_STRING      Password;
    DWORD               Reserved;
} ASYNC_UNLOCK_DATA, * PASYNC_UNLOCK_DATA;

typedef struct _UNLOCK_MESSAGE {
    NTSTATUS Status ;
    UINT Resource ;
} UNLOCK_MESSAGE, * PUNLOCK_MESSAGE ;

UNLOCK_MESSAGE UnlockMessages[] = {
    { STATUS_LOGON_FAILURE, IDS_UNLOCK_FAILED_BAD_PWD },
    { STATUS_INVALID_LOGON_HOURS, IDS_INVALID_LOGON_HOURS },
    { STATUS_INVALID_WORKSTATION, IDS_INVALID_WORKSTATION },
    { STATUS_ACCOUNT_DISABLED, IDS_ACCOUNT_DISABLED },
    { STATUS_NO_LOGON_SERVERS, IDS_LOGON_NO_DOMAIN },
    { STATUS_LOGON_TYPE_NOT_GRANTED, IDS_LOGON_TYPE_NOT_GRANTED },
    { STATUS_NO_TRUST_LSA_SECRET, IDS_NO_TRUST_LSA_SECRET },
    { STATUS_TRUSTED_DOMAIN_FAILURE, IDS_TRUSTED_DOMAIN_FAILURE },
    { STATUS_TRUSTED_RELATIONSHIP_FAILURE, IDS_TRUSTED_RELATIONSHIP_FAILURE },
    { STATUS_ACCOUNT_EXPIRED, IDS_ACCOUNT_EXPIRED },
    { STATUS_NETLOGON_NOT_STARTED, IDS_NETLOGON_NOT_STARTED },
    { STATUS_ACCOUNT_LOCKED_OUT, IDS_ACCOUNT_LOCKED },
    { STATUS_SMARTCARD_WRONG_PIN, IDS_STATUS_SMARTCARD_WRONG_PIN_UNLOCK },
    { STATUS_SMARTCARD_CARD_BLOCKED, IDS_STATUS_SMARTCARD_CARD_BLOCKED_UNLOCK },
    { STATUS_SMARTCARD_NO_CARD, IDS_STATUS_SMARTCARD_NO_CARD_UNLOCK },
    { STATUS_SMARTCARD_NO_KEY_CONTAINER, IDS_STATUS_SMARTCARD_NO_KEY_CONTAINER_UNLOCK },
    { STATUS_SMARTCARD_NO_CERTIFICATE, IDS_STATUS_SMARTCARD_NO_CERTIFICATE_UNLOCK },
    { STATUS_SMARTCARD_NO_KEYSET, IDS_STATUS_SMARTCARD_NO_KEYSET_UNLOCK },
    { STATUS_SMARTCARD_IO_ERROR, IDS_STATUS_SMARTCARD_IO_ERROR_UNLOCK },
    { STATUS_SMARTCARD_CERT_EXPIRED, IDS_STATUS_SMARTCARD_CERT_EXPIRED_UNLOCK },
    { STATUS_SMARTCARD_CERT_REVOKED, IDS_STATUS_SMARTCARD_CERT_REVOKED_UNLOCK },
    { STATUS_ISSUING_CA_UNTRUSTED, IDS_STATUS_ISSUING_CA_UNTRUSTED_UNLOCK },
    { STATUS_REVOCATION_OFFLINE_C, IDS_STATUS_REVOCATION_OFFLINE_C_UNLOCK },
    { STATUS_PKINIT_CLIENT_FAILURE, IDS_STATUS_PKINIT_CLIENT_FAILURE_UNLOCK }
    };
 

//
// Private prototypes
//
BOOL LockedDlgInit(HWND, PGLOBALS);
BOOL UnlockDlgInit(HWND, PGLOBALS, DWORD SasType);
INT_PTR AttemptUnlock(HWND, PGLOBALS, PUNLOCK_DLG_STATE);
BOOL WINAPI LogoffWaitDlgProc(HWND, UINT, DWORD, LONG);
VOID UnlockShowOptions(PGLOBALS pGlobals, HWND hDlg, BOOL fShow);
VOID DisplaySmartCardUnlockErrMessage(PGLOBALS pGlobals, HWND hDlg, DWORD dwErrorType, NTSTATUS Status, INT_PTR *pResult);
BOOL ValidateSC(PGLOBALS pGlobals);

HICON   hLockedIcon = NULL;
HICON   hUnlockIcon = NULL;

// declared in mslogon.c
LRESULT     CALLBACK    DisableEditSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData);
BOOL                    ReplacedPossibleDisplayName (WCHAR *pszUsername);

void
SetLockedInfo(
    PGLOBALS    pGlobals,
    HWND        hDlg,
    UINT        ControlId)
{
    TCHAR    Buffer1[MAX_STRING_BYTES];
    TCHAR    Buffer2[MAX_STRING_BYTES];


    //
    // Set the locked message
    //

    if ( pGlobals->Domain[0] == TEXT('\0') )
    {
        if (lstrlen(pGlobals->UserFullName) == 0) {

            //
            // There is no full name, so don't try to print one out
            //

            LoadString(hDllInstance, IDS_LOCKED_EMAIL_NFN_MESSAGE, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->UserName );

        } else {

            LoadString(hDllInstance, IDS_LOCKED_EMAIL_MESSAGE, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->UserName, pGlobals->UserFullName);
        }

    }
    else
    {
        if (lstrlen(pGlobals->UserFullName) == 0) {

            //
            // There is no full name, so don't try to print one out
            //

            LoadString(hDllInstance, IDS_LOCKED_NFN_MESSAGE, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain, pGlobals->UserName );

        } else {

            LoadString(hDllInstance, IDS_LOCKED_MESSAGE, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain, pGlobals->UserName, pGlobals->UserFullName);
        }
    }

    SetWindowText(GetDlgItem(hDlg, ControlId), Buffer2);

}


/***************************************************************************\
* FUNCTION: LockedDlgProc
*
* PURPOSE:  Processes messages for the workstation locked dialog
*
* RETURNS:
*   DLG_SUCCESS     - the user pressed Ctrl-Alt-Del
*   DLG_LOGOFF()    - the user was asynchronously logged off.
*   DLG_SCREEN_SAVER_TIMEOUT - the screen-saver should be started
*   DLG_FAILURE     - the dialog could not be displayed.
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
CALLBACK
LockedDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    PGLOBALS    pGlobals = (PGLOBALS) GetWindowLongPtr( hDlg, GWLP_USERDATA);

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

            pGlobals = (PGLOBALS) lParam ;

            if (GetDisableCad(pGlobals))
            {
                // Set our size to zero so we we don't appear
                SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE |
                                         SWP_NOREDRAW | SWP_NOZORDER);

                pWlxFuncs->WlxSasNotify( pGlobals->hGlobalWlx,
                                         WLX_SAS_TYPE_CTRL_ALT_DEL );
            }
            else
            {
                if (!LockedDlgInit(hDlg, pGlobals)) {
                    EndDialog(hDlg, DLG_FAILURE);
                }
            }
            return(TRUE);

        case WLX_WM_SAS:
            if ( wParam != WLX_SAS_TYPE_SC_REMOVE && 
                 wParam != WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED && 
                 wParam != WLX_SAS_TYPE_SC_LAST_READER_REMOVED )
            {
                EndDialog(hDlg, MSGINA_DLG_SUCCESS);
            }
            return(TRUE);

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, FALSE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);
    }

    // We didn't process this message
    return FALSE;
}


/***************************************************************************\
* FUNCTION: LockedDlgInit
*
* PURPOSE:  Handles initialization of locked workstation dialog
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

BOOL
LockedDlgInit(
    HWND        hDlg,
    PGLOBALS    pGlobals
    )
{

    ULONG_PTR Value;

    SetWelcomeCaption(hDlg);
    SetLockedInfo(pGlobals, hDlg, IDD_LOCKED_NAME_INFO);
    SetupSystemMenu(hDlg);

    // Size for the branding image we are going to add.
    SizeForBranding(hDlg, FALSE);

    if ( !hLockedIcon )
    {
        hLockedIcon = LoadImage( hDllInstance,
                                 MAKEINTRESOURCE( IDI_LOCKED),
                                 IMAGE_ICON,
                                 0, 0,
                                 LR_DEFAULTCOLOR );
    }

    SendMessage( GetDlgItem(hDlg, IDD_LOCKED_ICON),
                 STM_SETICON,
                 (WPARAM)hLockedIcon,
                 0 );

        // Stop filtering SC events so SC unlock works
    pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_USE_SMART_CARD,
                             1,
                             NULL
                            );

    //
    // is this a smartcard gina?
    //

    pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_SMART_CARD_PRESENT,
                             &Value
                           );

    if ( Value )
    {
        TCHAR szInsertCard[256];
        szInsertCard[0] = 0;

        // Also change unlock message to mention smartcard
        LoadString(hDllInstance, IDS_INSERTCARDORSAS_UNLOCK, szInsertCard, ARRAYSIZE(szInsertCard));

        SetDlgItemText(hDlg, IDD_LOCKED_INSTRUCTIONS, szInsertCard);
    }

    CentreWindow(hDlg);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxDisplayLockedNotice
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pWlxContext] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-16-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


VOID
WINAPI
WlxDisplayLockedNotice(
    PVOID   pWlxContext
    )
{
    PGLOBALS    pGlobals;

    pGlobals = (PGLOBALS) pWlxContext;

    GetSystemTimeAsFileTime( (LPFILETIME) &pGlobals->LockTime);

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LOGON_TIMEOUT);
    pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                   hDllInstance,
                                   (LPWSTR) MAKEINTRESOURCE(IDD_LOCKED_DIALOG),
                                   NULL,
                                   LockedDlgProc,
                                   (LPARAM) pGlobals );

}

BOOL
SmartCardInsterted(
    PGLOBALS    pGlobals)
{
    PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

    pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_SMART_CARD_INFO,
                             (ULONG_PTR *) &ScInfo );

    if ( ScInfo )
    {       
        LocalFree(ScInfo);
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
}



int
WINAPI
WlxWkstaLockedSAS(
    PVOID pWlxContext,
    DWORD dwSasType
    )
{
    PGLOBALS            pGlobals;
    DWORD               Result;
    UNLOCK_DLG_STATE    UnlockDlgState ;
    BOOL                fContinue = FALSE;
    
    LOCKED_STATE_DIALOGS PreviousState; 
    LOCKED_STATE_DIALOGS CurrentState;
    pGlobals = (PGLOBALS) pWlxContext;

    UnlockDlgState.pGlobals    = pGlobals ;
    UnlockDlgState.dwSasType   = dwSasType ;
    UnlockDlgState.ActionTaken = None ;
        
    //
    // Set the previous state based on whether CAD is disabled, and
    // the current SAS type
    //
    if (GetDisableCad(pGlobals))
    {
        PreviousState = PasswordDialog; 

        //
        // If the CAD is disabled, then go directly to the PIN dialog
        //
        if (SmartCardInsterted(pGlobals))
        {
            UnlockDlgState.dwSasType = WLX_SAS_TYPE_SC_INSERT;
            CurrentState = PINDialog;                   
        }
        else
        {
            CurrentState = PasswordDialog;
        }
    }
    else
    {
        PreviousState = LockedDialog;

        //
        // Set the current state based on the SAS we are receiving
        //
        if (dwSasType == WLX_SAS_TYPE_SC_INSERT)
        {
            CurrentState = PINDialog;       
        }
        else
        {
            CurrentState = PasswordDialog;
        }
    }
    
    do
    {
        UnlockDlgState.ActionTaken = None;
        fContinue = FALSE;

        Result = pWlxFuncs->WlxDialogBoxParam(
                                pGlobals->hGlobalWlx,
                                hDllInstance,
                                MAKEINTRESOURCE(IDD_UNLOCK_DIALOG),
                                NULL,
                                (DLGPROC) UnlockDlgProc,
                                (LPARAM) &UnlockDlgState );
                                    
        //
        // Make a transition based on the current dialog
        // (the one that has just ended)
        //
        switch (CurrentState)
        {
        
        case PasswordDialog:

            //
            // If the password dialog was just being displayed
            // and a smartcard was inserted, then loop back
            // and display the PIN dialog, otherwise, if the
            // password dialog was dismissed for any other reason,
            // then get out.
            //
            if (UnlockDlgState.ActionTaken == SmartCardInserted)
            {
                PreviousState = PasswordDialog;
                CurrentState = PINDialog;
                UnlockDlgState.dwSasType = WLX_SAS_TYPE_SC_INSERT; // go to PIN dlg
                fContinue = TRUE;
            }
            break;

        case PINDialog:

            //
            // If the PIN dialog was just being displayed
            // and a smartcard was removed or cancel was hit, AND
            // the dialog that was displayed before this was the 
            // password dialog, then loop back and display the 
            // password dialog again, otherwise, if the PIN dialog 
            // was dismissed for any other reason, then get out.
            //
            if ((UnlockDlgState.ActionTaken == SmartCardRemoved) ||
                (UnlockDlgState.ActionTaken == CancelHit))
            {
                if (PreviousState == PasswordDialog)
                {
                    CurrentState = PasswordDialog;
                    UnlockDlgState.dwSasType = WLX_SAS_TYPE_CTRL_ALT_DEL; // go to PWD Dlg
                    fContinue = TRUE;     
                }                               
            }
            
            break;
        }
   
    } while (fContinue);   

    switch (Result)
    {
        case MSGINA_DLG_SUCCESS:

            if ( (pGlobals->SmartCardOption == 0) ||
                 (!pGlobals->SmartCardLogon)
               )
            {
                // As no action will be taken on SC removal, we can filter these events
                pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                         WLX_OPTION_USE_SMART_CARD,
                                         0,
                                         NULL );
            }

            CheckPasswordExpiry( pGlobals, FALSE );
            return(WLX_SAS_ACTION_UNLOCK_WKSTA);

        case MSGINA_DLG_FAILURE:
        case WLX_DLG_INPUT_TIMEOUT:
        case WLX_DLG_SCREEN_SAVER_TIMEOUT:
            return(WLX_SAS_ACTION_NONE);

        case WLX_DLG_USER_LOGOFF: 
            return(WLX_SAS_ACTION_LOGOFF);

        case MSGINA_DLG_FORCE_LOGOFF:
            return(WLX_SAS_ACTION_FORCE_LOGOFF);

        default:
            DebugLog((DEB_WARN, "Unexpected return code from UnlockDlgProc, %d\n", Result));
            return(WLX_SAS_ACTION_NONE);

    }
}

BOOL
ValidateSC(
    PGLOBALS pGlobals)
{
    PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

    pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_SMART_CARD_INFO,
                             (ULONG_PTR *) &ScInfo );

    //
    // Validate the SC info against some common user
    // errors before the PIN dialog appears
    //

    if ( ScInfo )
    {
        if ( ( ScInfo->pszReader ) &&
             ( ScInfo->pszCard == NULL ) )
        {
            //
            // The card could not be read.  Might not be
            // inserted correctly.
            //

            LocalFree(ScInfo);

            TimeoutMessageBox( NULL, pGlobals, IDS_CARD_NOT_RECOGNIZED,
                                    IDS_LOGON_MESSAGE,
                                    MB_OK | MB_ICONEXCLAMATION,
                                    LOGON_TIMEOUT );

            return FALSE;
        }

        if ( ( ScInfo->pszReader ) &&
             ( ScInfo->pszCryptoProvider == NULL ) )
        {
            //
            // Got a card, but the CSP for it could not be
            // found.
            //

            LocalFree(ScInfo);

            TimeoutMessageBox( NULL, pGlobals, IDS_CARD_CSP_NOT_RECOGNIZED,
                                    IDS_LOGON_MESSAGE,
                                    MB_OK | MB_ICONEXCLAMATION,
                                    LOGON_TIMEOUT );

            return FALSE;
        }

        LocalFree(ScInfo);
    }

    return TRUE;

}

/***************************************************************************\
* FUNCTION: UnlockDlgProc
*
* PURPOSE:  Processes messages for the workstation unlock dialog
*
* RETURNS:
*   DLG_SUCCESS     - the user unlocked the workstation successfully.
*   DLG_FAILURE     - the user failed to unlock the workstation.
*   DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

static UINT ctrlNoCancel[] =
{
    IDOK,
};

INT_PTR
CALLBACK
UnlockDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PGLOBALS pGlobals = NULL;
    INT_PTR Result;
    PUNLOCK_DLG_STATE pUnlockDlgState;

    pUnlockDlgState = (PUNLOCK_DLG_STATE) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    if (message != WM_INITDIALOG)
    {
        pGlobals = pUnlockDlgState->pGlobals;                  
    }

    switch (message)
    {
        case WM_INITDIALOG:

            pUnlockDlgState = (PUNLOCK_DLG_STATE) lParam ;

            // Screen saver will run if set to expire >= 2 minutes

            pWlxFuncs->WlxSetTimeout(pUnlockDlgState->pGlobals->hGlobalWlx, 
                (GetDisableCad(pUnlockDlgState->pGlobals) ? TIMEOUT_NONE : LOGON_TIMEOUT) );


            // Limit the maximum password length to 127

            SendDlgItemMessage(hDlg, IDD_UNLOCK_PASSWORD, EM_SETLIMITTEXT, (WPARAM) 127, 0);

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (ULONG_PTR) pUnlockDlgState );

            //
            // If this is an sc insert, then make sure the card is inserted correctly.
            //
            if ( pUnlockDlgState->dwSasType == WLX_SAS_TYPE_SC_INSERT )
            {
                if (!ValidateSC( pUnlockDlgState->pGlobals ))
                {
                    EndDialog(hDlg, DLG_FAILURE);                
                }
            }

            if (!UnlockDlgInit(hDlg, pUnlockDlgState->pGlobals, pUnlockDlgState->dwSasType ))
            {
                EndDialog(hDlg, DLG_FAILURE);
            }

            // Disable edits in username / password box
            SetWindowSubclass(GetDlgItem(hDlg, IDD_UNLOCK_NAME)    , DisableEditSubClassProc, IDD_UNLOCK_NAME    , 0);
            SetWindowSubclass(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), DisableEditSubClassProc, IDD_UNLOCK_PASSWORD, 0);


            return(SetPasswordFocus(hDlg));

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, FALSE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDD_UNLOCK_NAME:
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            // Ensure the domain box is enabled/disabled correctly
                            // in case of a UPN name
                            EnableDomainForUPN((HWND) lParam, GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN));
                            return TRUE;
                        default:
                            break;
                    }
                    break;
               case IDCANCEL:

                   pUnlockDlgState->ActionTaken = CancelHit;
                   EndDialog(hDlg, DLG_FAILURE);
                        
                    return TRUE;

                case IDOK:

                    //
                    // Deal with combo-box UI requirements
                    //

                    if (HandleComboBoxOK(hDlg, IDD_UNLOCK_DOMAIN))
                    {
                        return(TRUE);
                    }


                    Result = AttemptUnlock(hDlg, pGlobals, pUnlockDlgState);

                    if (Result != MSGINA_DLG_ASYNC_PROCESSING)
                    {
                        //
                        // If they failed, let them try again, otherwise get out.
                        //
        
                        if (Result != DLG_FAILURE)
                        {
                            EndDialog(hDlg, Result);
                        }
        
                        // Clear the password field
                        SetDlgItemText(hDlg, IDD_UNLOCK_PASSWORD, NULL);
                        SetPasswordFocus(hDlg);   
                    }
                    else
                    {
                        //
                        // Let the async thread do the work, then it will send a 
                        // WM_SMARTCARD_ASYNC_MESSAGE message when it is done.
                        // Meanwhile, disable controls so they don't get mucked with
                        //
                        EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), FALSE );
                        EnableWindow( GetDlgItem(hDlg, IDOK), FALSE );
                        EnableWindow( GetDlgItem(hDlg, IDCANCEL), FALSE );
                        EnableWindow( GetDlgItem(hDlg, IDC_UNLOCK_PASSWORD_LABEL), FALSE );
                    }
                    
                    return TRUE;

                case IDD_UNLOCK_OPTIONS:
                    UnlockShowOptions(pGlobals, hDlg, !pGlobals->UnlockOptionsShown);
                    return TRUE;
            }
            break;

        case WM_SMARTCARD_ASYNC_MESSAGE:

            switch (wParam)
            {
            case MSGINA_DLG_SUCCESS:

                EndDialog(hDlg, MSGINA_DLG_SUCCESS);
                break;

            case MSGINA_DLG_FORCE_LOGOFF:
                
                EndDialog(hDlg, MSGINA_DLG_FORCE_LOGOFF);
                break;

            case MSGINA_DLG_FAILURE:

                EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), TRUE );
                EnableWindow( GetDlgItem(hDlg, IDOK), TRUE );
                EnableWindow( GetDlgItem(hDlg, IDCANCEL), TRUE );
                EnableWindow( GetDlgItem(hDlg, IDC_UNLOCK_PASSWORD_LABEL), TRUE );

                // Clear the password field
                SetDlgItemText(hDlg, IDD_UNLOCK_PASSWORD, NULL);
                SetPasswordFocus(hDlg);
    
                break;
            }
            
            break;

        case WM_SMARTCARD_ERROR_DISPLAY_1:

            DisplaySmartCardUnlockErrMessage(pGlobals, hDlg, 1, (NTSTATUS) wParam, (INT_PTR *) lParam);            
            return (TRUE);
            break;

        case WM_SMARTCARD_ERROR_DISPLAY_2:

            DisplaySmartCardUnlockErrMessage(pGlobals, hDlg, 2, (NTSTATUS) wParam, (INT_PTR *) lParam);            
            return (TRUE);           
            
            break;

        case WLX_WM_SAS:

            // Ignore it
            if ( wParam == WLX_SAS_TYPE_CTRL_ALT_DEL )
            {
                return( TRUE );
            }

            //
            // If we are in the middle of a smart card unlock then...
            //
            if ( pGlobals->LogonInProgress )
            {
                //
                // SC_REMOVE is really the only interesting SAS, if we get it,
                // kill the dialog.
                //
                if ( wParam == WLX_SAS_TYPE_SC_REMOVE ) 
                {
                    //
                    // If the card removal happened while the user is being 
                    // prompted for a yes/no question, then just note that
                    // we got the removal and deal with it after the questions
                    // is answered.  
                    //
                    // Otherwise, kill the dialog
                    //
                    if ( pUnlockDlgState->fUserBeingPrompted )
                    {
                        pUnlockDlgState->fCardRemoved = TRUE; 
                        ShowWindow(hDlg, SW_HIDE);
                    }
                    else
                    {
                        pUnlockDlgState->ActionTaken = SmartCardRemoved;
                        EndDialog(hDlg, DLG_FAILURE); 
                    }                    
                }
                 
                return( TRUE );
            }

            //
            // If this is an insert and we are in the password state, then
            // go to the PIN state
            //
            if ( ( wParam == WLX_SAS_TYPE_SC_INSERT ) &&
                 ( IsWindowVisible( GetDlgItem( hDlg, IDD_UNLOCK_OPTIONS ) ) == TRUE ) )
            {
                //
                // Check for some common SC problems before ending the dialog and
                // going to the PIN state
                //
                if ( !ValidateSC( pGlobals ) )
                {
                    return( TRUE );
                }

                pUnlockDlgState->ActionTaken = SmartCardInserted;
                EndDialog(hDlg, DLG_FAILURE);  
            }

            //
            // if this is a smart card unlock, if it is removed, kill the dialog.
            //
            if ( ( wParam == WLX_SAS_TYPE_SC_REMOVE ) &&
                 ( IsWindowVisible( GetDlgItem( hDlg, IDD_UNLOCK_OPTIONS ) ) == FALSE ) )
            {
                pUnlockDlgState->ActionTaken = SmartCardRemoved;
                EndDialog(hDlg, DLG_FAILURE);                     
            }
            else if(wParam == WLX_SAS_TYPE_SC_REMOVE)
            {
                // 
                // Already in the password dialog
                //
                return ( TRUE );
            }

            if ( wParam == WLX_SAS_TYPE_AUTHENTICATED ) {
               EndDialog( hDlg, MSGINA_DLG_SUCCESS );
               return TRUE;
            } else if ( wParam == WLX_SAS_TYPE_USER_LOGOFF ) {
               EndDialog( hDlg, MSGINA_DLG_USER_LOGOFF );
               return TRUE;
            }

            return( FALSE );

        case WM_CLOSE:
            break;

        case WM_DESTROY:

            FreeLayoutInfo (LAYOUT_CUR_USER);

            if ( pGlobals->ActiveArray )
            {
                DCacheFreeArray( pGlobals->ActiveArray );
                pGlobals->ActiveArray = NULL ;
            }

            RemoveWindowSubclass(GetDlgItem(hDlg, IDD_UNLOCK_NAME),     DisableEditSubClassProc, IDD_UNLOCK_NAME);
            RemoveWindowSubclass(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), DisableEditSubClassProc, IDD_UNLOCK_PASSWORD);

            break;

    case WM_TIMER:

            if ( wParam == 0 )
            {
                HDC hDC;

                RtlEnterCriticalSection(&pGlobals->csGlobals);

                if ( pGlobals->LogonInProgress )
                {
                    if (pGlobals->cxBand != 0)
                    {
                        pGlobals->xBandOffset = (pGlobals->xBandOffset+5) % pGlobals->cxBand;
                    }
                }
                
                if ( !pGlobals->LogonInProgress || pUnlockDlgState->fKillTimer )
                {
                
                    pGlobals->xBandOffset = 0;
                    KillTimer(hDlg, 0);

                    //
                    // Reset timeout to normal
                    //
                    pWlxFuncs->WlxSetTimeout(
                                    pGlobals->hGlobalWlx,
                                    (GetDisableCad(pGlobals) ? TIMEOUT_NONE : LOGON_TIMEOUT));

                }

                RtlLeaveCriticalSection(&pGlobals->csGlobals);

                hDC = GetDC(hDlg);
                if ( hDC )
                {
                    PaintBranding( hDlg, hDC, pGlobals->xBandOffset, TRUE, FALSE, COLOR_BTNFACE );
                    ReleaseDC( hDlg, hDC );
                }

                return FALSE;
            }
            else if ( wParam == TIMER_MYLANGUAGECHECK )
            {
                LayoutCheckHandler(hDlg, LAYOUT_CUR_USER);
            }

            break;
    }

    // We didn't process the message
    return(FALSE);
}


/***************************************************************************\
* FUNCTION: UnlockDlgInit
*
* PURPOSE:  Handles initialization of security options dialog
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

static UINT ctrlNoOptions[] =
{
    IDOK,
    IDCANCEL,
    IDD_KBLAYOUT_ICON,
};

BOOL
UnlockDlgInit(
    HWND        hDlg,
    PGLOBALS    pGlobals,
    DWORD       SasType
    )
{
    RECT rc, rc2;
    WCHAR Label[ MAX_PATH ];

    int err ;
    DWORD dwSize ;
    DWORD dwType ;
    DWORD dwValue ;

    dwSize = sizeof( DWORD );
    dwValue = 0 ;

    err = RegQueryValueEx( WinlogonKey,
                           FORCE_UNLOCK_LOGON,
                           0,
                           &dwType,
                           (PBYTE) &dwValue,
                           &dwSize );

    if ( err || ( dwType != REG_DWORD ) )
    {
        dwValue = 0 ;
    }

    if ( dwValue )
    {
        pGlobals->UnlockBehavior |= UNLOCK_FORCE_AUTHENTICATION ;
    }
    else
    {
        pGlobals->UnlockBehavior &= ~(UNLOCK_FORCE_AUTHENTICATION );
    }

    SetWelcomeCaption( hDlg );

    SetLockedInfo( pGlobals, hDlg, IDD_UNLOCK_NAME_INFO );

    if ( !hLockedIcon )
    {
        hLockedIcon = LoadImage( hDllInstance,
                                 MAKEINTRESOURCE( IDI_LOCKED),
                                 IMAGE_ICON,
                                 0, 0,
                                 LR_DEFAULTCOLOR );
    }

    SendMessage( GetDlgItem( hDlg, IDD_UNLOCK_ICON),
                 STM_SETICON,
                 (WPARAM)hLockedIcon,
                 0 );

    DisplayLanguageIcon (hDlg, LAYOUT_CUR_USER, GetKeyboardLayout(0));

    // Size for the branding image we are going to add.
    SizeForBranding(hDlg, FALSE);

    pGlobals->xBandOffset = 0;

    //
    // Fill in the username
    //

    if ( SasType == WLX_SAS_TYPE_SC_INSERT )
    {
        RECT rc = {0};
        RECT rc2 = {0};

        //
        // No username, hide the field and move other controls up
        //
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_MESSAGE), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), &rc2);

        MoveControls(hDlg, ctrlNoUserName,
                     sizeof(ctrlNoUserName)/sizeof(ctrlNoUserName[0]),
                     0, -(rc2.top-rc.top),
                     TRUE);

        // Hide the unnecessary text for SC insert
        ShowDlgItem( hDlg, IDD_UNLOCK_MESSAGE, FALSE);
        ShowDlgItem( hDlg, IDD_UNLOCK_NAME_INFO, FALSE);

        // Also remove the unlock icon; when the dialog gets this small, there
        // isn't room for this guy and the kblayout icon.
        ShowDlgItem( hDlg, IDD_UNLOCK_ICON, FALSE);


        ShowDlgItem( hDlg, IDD_UNLOCK_NAME, FALSE );
        EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_NAME), FALSE );
        ShowDlgItem( hDlg, IDC_UNLOCK_NAME_LABEL, FALSE );

        // Disable and hide domain
        ShowDlgItem( hDlg, IDD_UNLOCK_DOMAIN, FALSE );
        EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), FALSE);
        ShowDlgItem( hDlg, IDD_UNLOCK_DOMAIN_LABEL, FALSE);

        LoadString(hDllInstance, IDS_PIN, Label, MAX_PATH);
        SetDlgItemText( hDlg, IDC_UNLOCK_PASSWORD_LABEL, Label );

        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), &rc2);

        MoveControls(hDlg, ctrlNoDomain,
                     ARRAYSIZE(ctrlNoDomain),
                     0, -(rc2.bottom-rc.bottom),
                     TRUE);

        pGlobals->ShowDomainBox = FALSE;

        //
        // The options button is useless, remove it
        //

        GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_OPTIONS), &rc2);

        MoveControls(hDlg, ctrlNoOptions,
                     sizeof(ctrlNoOptions)/sizeof(ctrlNoOptions[0]),
                     rc2.right-rc.right, 0,
                     FALSE);

        ShowDlgItem(hDlg, IDD_UNLOCK_OPTIONS, FALSE);

        // Stop filtering SC events so SC unlock works
        pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                 WLX_OPTION_USE_SMART_CARD,
                                 1,
                                 NULL
                                );
    }
    else if (ForceNoDomainUI())
    {
        RECT rc = {0};
        RECT rc2 = {0};

        // Populate username
        SetDlgItemText(hDlg, IDD_UNLOCK_NAME, pGlobals->UserName);

        // Disable and hide domain
        ShowDlgItem( hDlg, IDD_UNLOCK_DOMAIN, FALSE );
        EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), FALSE);
        ShowDlgItem( hDlg, IDD_UNLOCK_DOMAIN_LABEL, FALSE);

        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), &rc2);

        MoveControls(hDlg, ctrlNoDomain,
                     ARRAYSIZE(ctrlNoDomain),
                     0, -(rc2.bottom-rc.bottom),
                     TRUE);

        pGlobals->ShowDomainBox = FALSE;
    }
    else
    {
        SetDlgItemText(hDlg, IDD_UNLOCK_NAME, pGlobals->UserName);

        pGlobals->ShowDomainBox = TRUE;

        // Stop filtering SC events so SC unlock works
        pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                 WLX_OPTION_USE_SMART_CARD,
                                 1,
                                 NULL
                                );
    }

    //
    // Get trusted domain list and select appropriate domain
    //

    if ( !DCacheValidateCache( pGlobals->Cache ) )
    {
        ASSERT( pGlobals->ActiveArray == NULL );

        DCacheUpdateMinimal( pGlobals->Cache, 
                             pGlobals->Domain, 
                             TRUE );

    }

    pGlobals->ActiveArray = DCacheCopyCacheArray( pGlobals->Cache );

    if ( pGlobals->ActiveArray )
    {
        DCachePopulateListBoxFromArray( pGlobals->ActiveArray,
                                        GetDlgItem( hDlg, IDD_UNLOCK_DOMAIN ),
                                        pGlobals->Domain );
    }
    else 
    {
        EndDialog( hDlg, MSGINA_DLG_FAILURE );
    }

#if 0
    //
    // Ensure that the domain the user logged on with is always in the
    // combo-box so even if the Lsa is in a bad way the user will always
    // be able to unlock the workstation. Don't do this if the user is logged
    // in locally or else we'll get TWO local machines in the list
    //

    cchComputer = ARRAYSIZE(szComputer);
    szComputer[0] = 0;
    GetComputerName(szComputer, &cchComputer);

    if ( pGlobals->Domain[0] && (0 != lstrcmpi(szComputer, pGlobals->Domain)))
    {
        HWND hwndDomain = GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN);
        if (SendMessage(hwndDomain, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pGlobals->Domain) == CB_ERR)
        {
            DebugLog((DEB_ERROR, "Domain combo-box doesn't contain logged on domain, adding it manually for unlock\n"));
            SendMessage(hwndDomain, CB_ADDSTRING, 0, (LPARAM)pGlobals->Domain);
        }
    }
#endif 

    //
    // If we are not part fo the domain then lets rip out the domain field,
    // and if we do that lets remove the options button.
    //

    if ( !IsMachineDomainMember() )
    {
        //
        // If we're not part of a domain, make sure to hide the domain field
        //

        GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_OPTIONS), &rc2);

        MoveControls(hDlg, ctrlNoOptions,
                     sizeof(ctrlNoOptions)/sizeof(ctrlNoOptions[0]),
                     rc2.right-rc.right, 0,
                     FALSE);

        ShowDlgItem(hDlg, IDD_UNLOCK_DOMAIN_LABEL, FALSE);
        ShowDlgItem(hDlg, IDD_UNLOCK_DOMAIN, FALSE);
        ShowDlgItem(hDlg, IDD_UNLOCK_OPTIONS, FALSE);
    }

    // remove the cancel button if no C-A-D required
    // NOTE: if we are going to the PIN dialog we always need a cancel button
    if ((GetDisableCad(pGlobals)) && (SasType != WLX_SAS_TYPE_SC_INSERT))
        EnableDlgItem(hDlg, IDCANCEL, FALSE);

    // Position window on screen
    CentreWindow(hDlg);

    // Hide the options pane
    pGlobals->UnlockOptionsShown = TRUE;
    UnlockShowOptions(pGlobals, hDlg, FALSE);

    return TRUE;
}

VOID
DisplaySmartCardUnlockErrMessage(
    PGLOBALS pGlobals,
    HWND hDlg,
    DWORD dwErrorType,
    NTSTATUS Status,
    INT_PTR *pResult)
{
    int     i;
    UINT    Resource = 0;
    TCHAR   Buffer1[MAX_STRING_BYTES];
    TCHAR   Buffer2[MAX_STRING_BYTES];
    BOOL    fStringFound = FALSE;

    if ( dwErrorType == 1 )
    {
        *pResult = TimeoutMessageBox(hDlg,
                                   pGlobals,
                                   IDS_FORCE_LOGOFF_WARNING,
                                   IDS_WINDOWS_MESSAGE,
                                   MB_OKCANCEL | MB_ICONEXCLAMATION | MB_DEFBUTTON2,
                                   TIMEOUT_CURRENT);

        return;         
    }
   
    //
    // At this point we need to display an error message, and the just
    // relinquish control back to the unlock dialog thread
    //
    
    for ( i = 0 ;
          i < sizeof( UnlockMessages ) / sizeof( UNLOCK_MESSAGE ) ;
          i++ )
    {
        if ( UnlockMessages[i].Status == Status )
        {
            if (Status == STATUS_LOGON_FAILURE)
            {
                Resource = IDS_UNLOCK_FAILED_BAD_PIN ;   
            }
            else
            {
                Resource = UnlockMessages[i].Resource ;
            }
            
            break;
        }
    }

    if ( Resource != 0 )
    {
        if( Resource == IDS_LOGON_NO_DOMAIN )
        {
            // Need to build the domain name into the string.
            LoadString(hDllInstance, Resource, Buffer1, MAX_STRING_BYTES);
            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain);
        }
        else
        {
            LoadString(hDllInstance, Resource, Buffer2, MAX_STRING_BYTES);
        }

        fStringFound = TRUE;  
    }   

    if ( !fStringFound )
    {            
        //
        // They're not the logged on user and they're not an admin.
        // Tell them they failed to unlock the workstation.
        //

        if ( lstrlen(pGlobals->UserFullName) == 0 ) 
        {
            if ( pGlobals->Domain[0] == L'\0' )
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_EMAIL_NFN, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                         pGlobals->UserName
                                                         );

            }
            else
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_NFN, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                             pGlobals->UserName
                                                             );
            }

        } 
        else 
        {
            if ( pGlobals->Domain[0] == L'\0' )
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_EMAIL, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                         pGlobals->UserName,
                                                         pGlobals->UserFullName
                                                         );

            }
            else
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                             pGlobals->UserName,
                                                             pGlobals->UserFullName
                                                             );
            }
        }
    }

    LoadString(hDllInstance, IDS_WORKSTATION_LOCKED, Buffer1, MAX_STRING_BYTES);

    *pResult = TimeoutMessageBoxlpstr(
                        hDlg,
                        pGlobals,
                        Buffer2,
                        Buffer1,
                        MB_OK | MB_ICONSTOP,
                        TIMEOUT_CURRENT);
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardUnlockLogonThread
//
//  Synopsis:   Does the logon call in an async thread so that a pulsing bar
//              can be shown in the UI.
//
//  Arguments:  [pData] --
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SmartCardUnlockLogonThread(
    PASYNC_UNLOCK_DATA  pData)
{
    INT_PTR     Result;
    BOOL        IsLoggedOnUser;
    BOOL        IsAdmin;
    NTSTATUS    Status;
    BOOL        Unlocked;
    PGLOBALS    pGlobals = pData->pGlobals;
    
    //
    // Kick off the call to the LSA
    //
    Unlocked = UnlockLogon(
                    pData->pGlobals,
                    TRUE,
                    pData->UserName.Buffer,
                    pData->Domain.Buffer,
                    &pData->Password,
                    &Status,
                    &IsAdmin,
                    &IsLoggedOnUser,
                    NULL,
                    NULL );

    //
    // Logon thread is done running, so stop showing the pulsing bar
    //
    pData->pUnlockDlgState->fKillTimer = TRUE;

    //
    // Get rid of the PIN
    //
    RtlZeroMemory( pData->Password.Buffer, pData->Password.Length );
    
    if ( Unlocked && IsLoggedOnUser )
    {
        pGlobals->SmartCardLogon = TRUE;  

        //
        // Logon succeeded, so tell the main thread that
        //
        PostMessage( pData->hDlg, WM_SMARTCARD_ASYNC_MESSAGE, MSGINA_DLG_SUCCESS, 0 );

        goto Return;
    }
    else if ( Unlocked && IsAdmin)
    {
        //
        // This is an admin trying to logon over another user, so send a message to the
        // main dialog so it can ask the user if they would like to continue
        //
        pData->pUnlockDlgState->fUserBeingPrompted = TRUE;                                           
        SendMessage( pData->hDlg, WM_SMARTCARD_ERROR_DISPLAY_1, Status, (LPARAM) &Result );
                
        //
        // If the smart card was removed while the user was being prompted, and
        // the user elected not to logoff the current user, then just go back
        // to the locked dialog
        //
        if ( (pData->pUnlockDlgState->fCardRemoved) && (Result != MSGINA_DLG_SUCCESS) )
        {
            //
            // Simulate the "card removed" SAS
            //
            pGlobals->LogonInProgress = FALSE;
            PostMessage( pData->hDlg, WLX_WM_SAS, WLX_SAS_TYPE_SC_REMOVE, (LPARAM) NULL );
        }
        else
        {
            //
            // Post the result of the prompt back to the main thread and then get out of this thread
            //
            PostMessage(
                    pData->hDlg, 
                    WM_SMARTCARD_ASYNC_MESSAGE, 
                    (Result == MSGINA_DLG_SUCCESS) ? MSGINA_DLG_FORCE_LOGOFF : MSGINA_DLG_FAILURE, 
                    Result );
        }
        

        goto Return;         
    }
   
    //
    // At this point an error occurred, so ask the main thread to display an error message, 
    //
    SendMessage( pData->hDlg, WM_SMARTCARD_ERROR_DISPLAY_2, Status, (LPARAM) &Result );
    
    if (DLG_INTERRUPTED(Result)) 
    {
        Result = SetInterruptFlag( MSGINA_DLG_FAILURE ) ;
    }

    //
    // Let the main thread know that this thread is exiting
    //
    PostMessage( pData->hDlg, WM_SMARTCARD_ASYNC_MESSAGE, MSGINA_DLG_FAILURE, Result );

Return:

    pGlobals->LogonInProgress = FALSE;

    LocalFree( pData );

    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   UnlockLogonThread
//
//  Synopsis:   Does the logon call in an async thread so that the user
//              unlock is faster.
//
//  Arguments:  [pData] --
//
//  History:    7-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
UnlockLogonThread(
    PASYNC_UNLOCK_DATA  pData)
{
    BOOL Ignored ;
    NTSTATUS Status ;
    //
    // Give everything a moment to switch back, restart, etc.
    //

    Sleep( 500 );

    //
    // Kick off the call to the LSA
    //

    UnlockLogon(
        pData->pGlobals,
        FALSE,
        pData->UserName.Buffer,
        pData->Domain.Buffer,
        &pData->Password,
        &Status,
        &Ignored,
        &Ignored,
        NULL,
        NULL );

    //
    // Get rid of the password, then free the parameters
    //

    RtlZeroMemory( pData->Password.Buffer, pData->Password.Length );

    LocalFree( pData );

    return( 0 );

}

//+---------------------------------------------------------------------------
//
//  Function:   UnlockLogonAsync
//
//  Synopsis:   Sets up the async thread so that
//
//  Effects:
//
//  Arguments:  [pGlobals]       --
//              [UserName]       --
//              [Domain]         --
//              [PasswordString] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    7-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


BOOL
UnlockLogonAsync(
    IN PGLOBALS pGlobals,
    IN PUNLOCK_DLG_STATE pUnlockDlgState,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString,
    IN HWND hDlg,
    IN BOOL SmartCardUnlock
    )
{
    DWORD   UserLength;
    DWORD   DomainLength;
    PASYNC_UNLOCK_DATA  pData;
    HANDLE  Thread;
    DWORD   Tid;


    UserLength = (DWORD) wcslen( UserName ) * sizeof(WCHAR);
    DomainLength = (DWORD) wcslen( Domain ) * sizeof(WCHAR);

    pData = LocalAlloc( LMEM_FIXED, sizeof( ASYNC_UNLOCK_DATA ) +
                                UserLength + DomainLength +
                                PasswordString->Length + 3 * sizeof(WCHAR) );

    if ( !pData )
    {
        return FALSE;
    }

    pData->pGlobals = pGlobals;
    pData->hDlg = hDlg;
    pData->pUnlockDlgState = pUnlockDlgState;
    pData->UserName.Length = (WORD)UserLength;
    pData->UserName.MaximumLength = (WORD)(UserLength + sizeof(WCHAR));
    pData->UserName.Buffer = (PWSTR) (pData + 1);
    CopyMemory( pData->UserName.Buffer, UserName, UserLength + sizeof(WCHAR) );

    pData->Domain.Length = (WORD)DomainLength;
    pData->Domain.MaximumLength = (WORD)(DomainLength + sizeof(WCHAR));
    pData->Domain.Buffer = pData->UserName.Buffer + (UserLength / 2) + 1;
    CopyMemory( pData->Domain.Buffer, Domain, DomainLength + sizeof(WCHAR) );

    pData->Password.Length = PasswordString->Length;
    pData->Password.MaximumLength = PasswordString->Length + sizeof(WCHAR) ;
    pData->Password.Buffer = pData->Domain.Buffer + (DomainLength / 2) + 1;
    CopyMemory( pData->Password.Buffer,
                PasswordString->Buffer,
                PasswordString->Length + 2);


    Thread = CreateThread(  NULL, 
                            0,
                            SmartCardUnlock ? SmartCardUnlockLogonThread: UnlockLogonThread, 
                            pData,
                            0, 
                            &Tid );

    if ( Thread )
    {
        CloseHandle( Thread );

    }
    else
    {
        ZeroMemory( pData->Password.Buffer, pData->Password.Length );

        LocalFree( pData );

        return ( FALSE );
    }

    return ( TRUE );
}



/***************************************************************************\
* FUNCTION: AttemptUnlock
*
* PURPOSE:  Tries to unlock the workstation using the current values in the
*           unlock dialog controls
*
* RETURNS:
*   DLG_SUCCESS     - the user unlocked the workstation successfully.
*   DLG_FAILURE     - the user failed to unlock the workstation.
*   DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
AttemptUnlock(
    HWND                hDlg,
    PGLOBALS            pGlobals,
    PUNLOCK_DLG_STATE   pUnlockDlgState)
{
    TCHAR    UserName[MAX_STRING_BYTES];
    TCHAR    Domain[MAX_STRING_BYTES];
    TCHAR    Password[MAX_STRING_BYTES];
    UCHAR   PasswordHash[ PASSWORD_HASH_SIZE ];
    BOOL    Unlocked;
    BOOL    DifferentAccount;
    INT_PTR Result;
    UNICODE_STRING PasswordString;
    TCHAR    Buffer1[MAX_STRING_BYTES];
    TCHAR    Buffer2[MAX_STRING_BYTES];
    UCHAR    IgnoreSeed;
    DWORD    StringSize;
    BOOL    SmartCardUnlock ;
    BOOL    IsAdmin = FALSE;
    BOOL    IsLoggedOnUser ;
    BOOL    AlreadyLogged ;
    BOOL    NewPassword ;
    NTSTATUS Status = STATUS_SUCCESS ;
    HWND hwndDomain = GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN);
    INT iDomainSelection;
    PDOMAIN_CACHE_ENTRY Entry ;
    BOOL PasswordExpiryWarning;
    PVOID ProfileBuffer;
    ULONG ProfileBufferLength;
    BOOL fStringFound = FALSE;
    RECT    rc;

    UserName[0] = TEXT('\0');
    Domain[0] = TEXT('\0');
    Password[0] = TEXT('\0');
    Buffer1[0] = TEXT('\0');
    Buffer2[0] = TEXT('\0');

    //
    // We need to do some things differently when a smart card is used.  The way to
    // tell is find out if the username field is active.
    //

    AlreadyLogged = FALSE ;
    NewPassword = FALSE ;
    Unlocked = FALSE;

    if ( !IsWindowEnabled( GetDlgItem( hDlg, IDD_UNLOCK_NAME ) ) )
    {
        SmartCardUnlock = TRUE ;

        DifferentAccount = TRUE ;
    }
    else
    {
        SmartCardUnlock = FALSE ;

        StringSize = GetDlgItemText(hDlg, IDD_UNLOCK_NAME, UserName, MAX_STRING_BYTES);
        if (StringSize == MAX_STRING_BYTES)
        {
            UserName[MAX_STRING_BYTES-1] = TEXT('\0');
        }

        //
        // check to see if this is the fancy "my computer" entry or the somewhat less fancy
        // "use the UPN" entry
        //

        iDomainSelection = (INT)SendMessage(hwndDomain, CB_GETCURSEL, 0, 0);
        Entry = (PDOMAIN_CACHE_ENTRY) SendMessage(hwndDomain, CB_GETITEMDATA, (WPARAM)iDomainSelection, 0);

        if ( Entry == (PDOMAIN_CACHE_ENTRY) CB_ERR )
        {
            //
            // Our list is hosed in some way.
            //

            GetDlgItemText( hDlg, IDD_UNLOCK_DOMAIN, Domain, MAX_STRING_BYTES );
        }
        else 
        {
            wcscpy( Domain, Entry->FlatName.Buffer );
        }

        // If we are forcing a NoDomainUI, populate the domain with the local machine name now
        if (ForceNoDomainUI())
        {
            DWORD chSize = ARRAYSIZE(Domain);
            
            if (!GetComputerName(Domain, &chSize))
            {
                *Domain = 0;
            }
        }


        if ( wcschr( UserName, TEXT('@') ) )
        {
            Domain[0] = TEXT('\0');
        }

        DifferentAccount = (lstrcmpi(UserName, pGlobals->UserName)) ||
                           (lstrcmpi(Domain, pGlobals->Domain)) ;
    }

    StringSize = GetDlgItemText(hDlg, IDD_UNLOCK_PASSWORD, Password, MAX_STRING_BYTES);
    if (StringSize == MAX_STRING_BYTES)
    {
        Password[MAX_STRING_BYTES-1] = TEXT('\0');
    }

    RtlInitUnicodeString( &PasswordString, Password );
    HashPassword(&PasswordString, PasswordHash );

    //
    // Check if this is the logged-on user.  Do it through the security package
    // if this was a smart card logon to begin with, if this is a smart card unlock,
    // or if we're supposed to under all circumstances.
    //

    //
    // Also check if password expiry warning will appear after unklocking.  If so, then
    // for a hit to the DC to update our profile info to make sure the user didn't
    // already change their password on another machine.
    //
    PasswordExpiryWarning = ShouldPasswordExpiryWarningBeShown(pGlobals, FALSE, NULL);

    if ( ( PasswordExpiryWarning ) ||
         ( pGlobals->UnlockBehavior & UNLOCK_FORCE_AUTHENTICATION ) ||
         ( SmartCardUnlock ) ||
         ( pGlobals->SmartCardLogon ) ||
         ( DifferentAccount ) )
    {
        //
        // Init profile buffer
        //
        ProfileBuffer = NULL;

        AlreadyLogged = TRUE ;

        if ( SmartCardUnlock )
        {
            // 
            // Use the LogonInProgress bool to signal the fact that SmartCardAsyncUnlock
            // is in progress
            //
            pGlobals->LogonInProgress = TRUE;

            GetClientRect( hDlg, &rc );
            pGlobals->cxBand = rc.right-rc.left;
        
            pUnlockDlgState->fKillTimer = FALSE;
            pUnlockDlgState->fUserBeingPrompted = FALSE;
            pUnlockDlgState->fCardRemoved = FALSE;            

            SetTimer(hDlg, 0, 20, NULL); 

            // Set timeout to infinite while attempting to logon
            pWlxFuncs->WlxSetTimeout( pGlobals->hGlobalWlx, TIMEOUT_NONE );
            
            //
            // Kick off the thread to do the unlock 
            //
            if (UnlockLogonAsync(  pGlobals,
                                   pUnlockDlgState,
                                   UserName,
                                   Domain,
                                   &PasswordString,
                                   hDlg,
                                   TRUE ))
            {
                HidePassword( &IgnoreSeed, &PasswordString );
                return ( MSGINA_DLG_ASYNC_PROCESSING );
            }
            else
            {
                //Status = STATUS_E_FAIL;  // SET THIS TO SOMETHING REASONABLE
                goto AsyncUnlockError;
            }           
        }
        
        Unlocked = UnlockLogon( pGlobals,
                                SmartCardUnlock,
                                UserName,
                                Domain,
                                &PasswordString,
                                &Status,
                                &IsAdmin,
                                &IsLoggedOnUser,
                                &ProfileBuffer,
                                &ProfileBufferLength );

        // Special handling for failed unlock on personal or professional
        // machines that are NOT joined to a domain. In this case it's
        // probably a user who disabled friendly UI and only knows of
        // their "display name" not their real "logon name". This
        // transparently maps one to the other to allow unlocks using
        // the "display name".

        if ((Status == STATUS_LOGON_FAILURE) &&
            (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL)) &&
            !IsMachineDomainMember())       // using our version to optimize caching
        {
            if (ReplacedPossibleDisplayName(UserName))
            {
                DifferentAccount = (lstrcmpi(UserName, pGlobals->UserName)) ||
                                   (lstrcmpi(Domain, pGlobals->Domain)) ;
                Unlocked = UnlockLogon( pGlobals,
                                        SmartCardUnlock,
                                        UserName,
                                        Domain,
                                        &PasswordString,
                                        &Status,
                                        &IsAdmin,
                                        &IsLoggedOnUser,
                                        &ProfileBuffer,
                                        &ProfileBufferLength );
            }
        }

        //
        // If this unlocked, and is the logged on user,
        // then check to see if we should update all the in-memory passwords
        //

        if ( ( Unlocked ) &&
             ( IsLoggedOnUser ) )
        {
            //
            // Could be a password update.  Check:
            //
            if (RtlEqualMemory( PasswordHash, pGlobals->PasswordHash, PASSWORD_HASH_SIZE ) == FALSE )
            {

                // RevealPassword( &pGlobals->PasswordString );

                UpdateWithChangedPassword(
                        pGlobals,
                        hDlg,
                        TRUE,
                        UserName,
                        Domain,
                        L"",
                        Password,
                        (PMSV1_0_INTERACTIVE_PROFILE)ProfileBuffer );

                //
                // Do not hide!  Update will rehide the global copy of the password.
                //
            }
        }

        //
        // Free profile buffer
        //
        if ( ProfileBuffer )
        {
            LsaFreeReturnBuffer(ProfileBuffer);
        }

        if ( Unlocked )
        {
            DifferentAccount = !IsLoggedOnUser ;
        }
    }

        //
        // Used to be just "else" here, ie:
        // !PasswordExpiryWarning && 
        // !( pGlobals->UnlockBehavior & UNLOCK_FORCE_AUTHENTICATION ) &&
        // !SmartCardUnlock && !pGlobals->SmartCardLogon
        // !DifferentAccount
        // but that's not enough if the user ignored all expiry warnings to date
        // and his password expired while locked (#404780)
        //
        // So the new logic is:
        // If we didn't enter the previous block (tested by means of AlreadyLogged) or
        // we entered it but it failed (and cached unlock is allowed and we didn't 
        // previously unlocked/logged on with a SC)
        //
    if ( ( AlreadyLogged == FALSE ) ||
         ( ( Unlocked == FALSE ) &&
           !( pGlobals->UnlockBehavior & UNLOCK_FORCE_AUTHENTICATION ) &&
           !( pGlobals->SmartCardLogon )
         )
       )
    {
        //
        // un-hide the original password text so that we can
        // do the compare.
        //
        // WARNING: We originally tried doing this comparison
        //          with old and new passwords hidden.  This is
        //          not a good idea because the hide routine
        //          will allow matches that shouldn't match.
        //

        // RevealPassword( &pGlobals->PasswordString );

        Unlocked = ( (lstrcmp(Domain, pGlobals->Domain) == 0) &&
                     (lstrcmpi(UserName, pGlobals->UserName) == 0) &&
                     (RtlEqualMemory( PasswordHash, pGlobals->PasswordHash, PASSWORD_HASH_SIZE ) == TRUE ) );

        //
        // re-hide the original password - use the same seed
        //

        // HidePassword( &pGlobals->Seed, &pGlobals->PasswordString );

        if  ( ( !Unlocked ) &&
              ( AlreadyLogged == FALSE ) ) // We already tried UnlockLogon otherwise
        {
            //
            // The password doesn't match what we have cached.  User
            // could have changed the password from another machine.
            // Let's do the logon, and it if works, we update everything.
            //

            //
            // Init profile buffer
            //
            ProfileBuffer = NULL;

            AlreadyLogged = TRUE ;

            Unlocked = UnlockLogon( pGlobals,
                                    FALSE,
                                    UserName,
                                    Domain,
                                    &PasswordString,
                                    &Status,
                                    &IsAdmin,
                                    &IsLoggedOnUser,
                                    &ProfileBuffer,
                                    &ProfileBufferLength );

            if ( ( Unlocked ) && ( IsLoggedOnUser ) )
            {
                //
                // This logon worked.  Must be a new password.
                //

                // RevealPassword( &pGlobals->PasswordString );

                UpdateWithChangedPassword(
                        pGlobals,
                        hDlg,
                        TRUE,
                        UserName,
                        Domain,
                        L"",
                        Password,
                        (PMSV1_0_INTERACTIVE_PROFILE)ProfileBuffer );

                //
                // Do not hide!  Update will rehide the global copy of the password.
                //
            }

            //
            // Free profile buffer
            //
            if ( ProfileBuffer )
            {
                LsaFreeReturnBuffer(ProfileBuffer);
            }

            if ( Unlocked )
            {
                DifferentAccount = !IsLoggedOnUser ;
            }
        }
    }


    if (Unlocked && !DifferentAccount ) {

        if ( (!AlreadyLogged) &&
             ( ( pGlobals->UnlockBehavior & UNLOCK_NO_NETWORK) == 0 ) )
        {
            UnlockLogonAsync( pGlobals,
                              NULL,
                              UserName,
                              Domain,
                              &PasswordString,
                              NULL,
                              FALSE );
        }

        //
        // Hide the new password to prevent it being paged cleartext.
        //

        HidePassword( &IgnoreSeed, &PasswordString );

        pGlobals->SmartCardLogon = SmartCardUnlock;

        return(MSGINA_DLG_SUCCESS);
    }


    //
    // Check for an admin logon and force the user off
    //

    if ( DifferentAccount )
    {
        if ( !AlreadyLogged )
        {
// PJM... Unreachable.

            IsAdmin = TestUserForAdmin( pGlobals,
                                        UserName,
                                        Domain,
                                        &PasswordString );
        }

        if ( IsAdmin ) {

            //
            // Hide the new password to prevent it being paged cleartext.
            //
            HidePassword( &IgnoreSeed, &PasswordString );

            Result = TimeoutMessageBox(hDlg,
                                       pGlobals,
                                       IDS_FORCE_LOGOFF_WARNING,
                                       IDS_WINDOWS_MESSAGE,
                                       MB_OKCANCEL | MB_ICONEXCLAMATION | MB_DEFBUTTON2,
                                       TIMEOUT_CURRENT);
            if (Result == MSGINA_DLG_SUCCESS) {

                return(MSGINA_DLG_FORCE_LOGOFF);
            }


            return(Result);
        }
    }
    else
    {

        //
        // Cheap way to force a logon attempt, and hit the lockout yada yada
        //

        if ( !AlreadyLogged )
        {
// PJM... Unreachable.

            UnlockLogon( pGlobals,
                         SmartCardUnlock,
                         UserName,
                         Domain,
                         &PasswordString,
                         &Status,
                         &IsAdmin,
                         &IsLoggedOnUser,
                         NULL,
                         NULL );

        }

    }

AsyncUnlockError:
            //
            // Hide the password to prevent it being paged cleartext.
            //
    HidePassword( &IgnoreSeed, &PasswordString );

    if ( !DifferentAccount )
    {
        int i ;
        UINT Resource = 0 ;

        for ( i = 0 ;
              i < sizeof( UnlockMessages ) / sizeof( UNLOCK_MESSAGE ) ;
              i++ )
        {
            if ( UnlockMessages[i].Status == Status )
            {
                Resource = UnlockMessages[i].Resource ;
                break;
            }
        }

        if ( Resource == 0 )
        {
            Resource = IDS_UNLOCK_FAILED_BAD_PWD ;            
        }

        if(Resource == IDS_LOGON_NO_DOMAIN)
        {
            // Need to build the domain name into the string.
            LoadString(hDllInstance, Resource, Buffer1, MAX_STRING_BYTES);
            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain);
        }
        else
        {
            LoadString(hDllInstance, Resource, Buffer2, MAX_STRING_BYTES);
        }
        
        fStringFound = TRUE;
    } 
    else 
    {            
        //
        // They're not the logged on user and they're not an admin.
        // Tell them they failed to unlock the workstation.
        //

        if ( lstrlen(pGlobals->UserFullName) == 0 ) {

            //
            // No full name.
            //

            if ( pGlobals->Domain[0] == L'\0' )
            {
                //
                // UPN logon:
                //

                LoadString(hDllInstance, IDS_UNLOCK_FAILED_EMAIL_NFN, Buffer1, MAX_STRING_BYTES);

                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                         pGlobals->UserName
                                                         );

            }
            else
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_NFN, Buffer1, MAX_STRING_BYTES);

                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                             pGlobals->UserName
                                                             );

            }

        } else {

            if ( pGlobals->Domain[0] == L'\0' )
            {
                //
                // UPN Logon:
                //
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_EMAIL, Buffer1, MAX_STRING_BYTES);

                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                         pGlobals->UserName,
                                                         pGlobals->UserFullName
                                                         );

            }
            else
            {

                LoadString(hDllInstance, IDS_UNLOCK_FAILED, Buffer1, MAX_STRING_BYTES);

                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                             pGlobals->UserName,
                                                             pGlobals->UserFullName
                                                             );
            }
        }
    }

    LoadString(hDllInstance, IDS_WORKSTATION_LOCKED, Buffer1, MAX_STRING_BYTES);

    Result = TimeoutMessageBoxlpstr(hDlg,
                                    pGlobals,
                                    Buffer2,
                                    Buffer1,
                                     MB_OK | MB_ICONSTOP,
                                     TIMEOUT_CURRENT);
    if (DLG_INTERRUPTED(Result)) {
        return( SetInterruptFlag( MSGINA_DLG_FAILURE ) );
    }

    return(MSGINA_DLG_FAILURE);
}


/****************************************************************************\
*
* FUNCTION: UnlockShowOptions
*
* PURPOSE: Hide the options part of the unlock dialog
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   15-dec-97 daviddv - Created
*
\****************************************************************************/

VOID UnlockShowOptions(PGLOBALS pGlobals, HWND hDlg, BOOL fShow)
{
    RECT rc, rc2;
    INT dy;
    TCHAR szBuffer[32];

    if ( pGlobals->UnlockOptionsShown != fShow )
    {
        //
        // Show hide optional fields in the dialog
        //

        if (pGlobals->ShowDomainBox)
        {
            GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), &rc);
            GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), &rc2);
            dy = rc2.bottom-rc.bottom;

            MoveControls(hDlg, ctrlNoDomain,
                         sizeof(ctrlNoDomain)/sizeof(ctrlNoDomain[0]),
                         0, fShow ? dy:-dy,
                         TRUE);

            ShowDlgItem(hDlg, IDD_UNLOCK_DOMAIN_LABEL, fShow);
            ShowDlgItem(hDlg, IDD_UNLOCK_DOMAIN, fShow);
        }

        ShowDlgItem(hDlg, IDD_KBLAYOUT_ICON, fShow);
        //
        // Change the options button to reflect the open/close state
        //

        LoadString(hDllInstance, fShow ? IDS_LESSOPTIONS:IDS_MOREOPTIONS,
                                szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]));

        SetDlgItemText(hDlg, IDD_UNLOCK_OPTIONS, szBuffer);
    }

    pGlobals->UnlockOptionsShown = fShow;

    // Enable or disable the domain box depending on whether a UPN name has been typed
    EnableDomainForUPN(GetDlgItem(hDlg, IDD_UNLOCK_NAME), GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\msgina.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msgina.h
//
//  Contents:   Main header file for MSGINA.DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "pragma.h"

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>

#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>
#include <secint.h>
#endif


#include <windows.h>
#include <windowsx.h>
#include <winuserp.h>
#include <winbasep.h>
#include <winwlx.h>
#include <rasdlg.h>
#include <dsgetdc.h>
#include <userenv.h>
#include <userenvp.h>

#include <winsta.h>
#include <safeboot.h>
#include <msginaexports.h>

#include "commctrl.h"

#ifndef RC_INVOKED

#include <lm.h>
#include <npapi.h>

//
// Handy Defines
//

#define AUTO_LOGON      // Enable automatic logon to configure netlogon stuff.

#define DLG_FAILURE IDCANCEL

typedef int TIMEOUT, * PTIMEOUT;


//
// Macro to determine if the current session is the active console session
//

#define IsActiveConsoleSession() (BOOLEAN)(USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)


#include "structs.h"
#include "strings.h"
#include "debug.h"

#include "welcome.h"
#include "winutil.h"
#include "wlsec.h"
//
//  Global Variables
//

extern  HINSTANCE                   hDllInstance;   // My instance, for resource loading
extern  HINSTANCE                   hAppInstance;   // App instance, for dialogs, etc.
extern  PWLX_DISPATCH_VERSION_1_4   pWlxFuncs;      // Ptr to table of functions
extern  PSID                        pWinlogonSid;
extern  DWORD                       SafeBootMode;

extern  HKEY                        WinlogonKey ;

//
// Terminal Server definitions
//
extern  BOOL                        g_IsTerminalServer;
extern  BOOL                        g_Console;

//
//
// GetProcAddr Prototype for winsta.dll function WinStationQueryInformationW
//

typedef BOOLEAN (*PWINSTATION_QUERY_INFORMATION) (
                    HANDLE hServer,
                    ULONG SessionId,
                    WINSTATIONINFOCLASS WinStationInformationClass,
                    PVOID  pWinStationInformation,
                    ULONG WinStationInformationLength,
                    PULONG  pReturnLength
                    );

//
// GetProcAddr Proto for regapi.dll function RegUserConfigQuery
//
typedef LONG ( * PREGUSERCONFIGQUERY) ( WCHAR *,
                                        WCHAR *,
                                        PUSERCONFIGW,
                                        ULONG,
                                        PULONG );

typedef LONG ( * PREGDEFAULTUSERCONFIGQUERY) ( WCHAR *,
                                               PUSERCONFIGW,
                                               ULONG,
                                               PULONG );

//
// tsnotify.dll export
//
typedef BOOL ( * PTERMSRVCREATETEMPDIR) (   PVOID *pEnv, 
                                            HANDLE UserToken,
                                            PSECURITY_DESCRIPTOR SD
                                        );


//
// Module header files:
//
#include "mslogon.h"
#include "audit.h"
#include "chngepwd.h"
#include "domain.h"
#include "lockout.h"
#include "lsa.h"
#include "lock.h"
#include "options.h"
#include "envvar.h"
#include "rasx.h"
#include "brand.h"
#include "langicon.h"


BOOL
GetErrorDescription(
    DWORD   ErrorCode,
    LPWSTR  Description,
    DWORD   DescriptionSize
    );

VOID FreeAutoLogonInfo( PGLOBALS pGlobals );

BOOL DisconnectLogon( HWND, PGLOBALS );

BOOL GetDisableCad(PGLOBALS);


VOID
UpdateWithChangedPassword(
    PGLOBALS pGlobals,
    HWND    ActiveWindow,
    BOOL    Hash,
    PWSTR   UserName,
    PWSTR   Domain,
    PWSTR   Password,
    PWSTR   NewPassword,
	PMSV1_0_INTERACTIVE_PROFILE	NewProfile
    );

#endif // not RC_INVOKED

//
// Include resource header files
//
#include "stringid.h"
#include "wlevents.h"
#include "resource.h"
#include "shutdown.h"

//
// Shutdown "reason" stuff.
//
DWORD GetReasonSelection(HWND hwndCombo);
void SetReasonDescription(HWND hwndCombo, HWND hwndStatic);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\ras.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ras.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-09-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include <wchar.h>
#include <wincrypt.h>
#include <sclogon.h>
#include <raserror.h>

#define NP_Nbf      0x1
#define NP_Ipx      0x2
#define NP_Ip       0x4

HANDLE  hRasApi ;

VOID WINAPI
MyRasCallback(
    IN DWORD_PTR  dwCallbackId,
    IN DWORD  dwEventCode,
    IN LPWSTR pszEntry,
    IN LPVOID pEventArgs )

    /* RasPhonebookDlg callback.  'DwCallbackId' is the ID provided in
    ** parameters to RasPhonebookDlg.  'DwEventCode' indicates the
    ** RASPBDEVENT_* event that has occurred.  'PszEntry' is the name of the
    ** entry on which the event occurred.  'PEventArgs' is the event-specific
    ** parameter block passed to us during RasPhonebookDlg callback.
    */
{
    RASNOUSERW* pInfo;
    PGLOBALS    pGlobals;

    DebugLog((DEB_TRACE, "RasCallback: %#x, %#x, %ws, %#x\n",
                dwCallbackId, dwEventCode, pszEntry, pEventArgs ));


    /* Fill in information about the not yet logged on user.
    */
    pInfo = (RASNOUSERW* )pEventArgs;
    pGlobals = (PGLOBALS) dwCallbackId;


    if (dwEventCode == RASPBDEVENT_NoUserEdit)
    {
        if (pInfo->szUserName[0])
        {
            wcscpy( pGlobals->UserName, pInfo->szUserName );
        }

        if (pInfo->szPassword[0])
        {
            wcscpy( pGlobals->Password, pInfo->szPassword );
            RtlInitUnicodeString( &pGlobals->PasswordString, pGlobals->Password );

            pGlobals->Seed = 0;

            HidePassword( &pGlobals->Seed, &pGlobals->PasswordString );
        }

    }
    else if (dwEventCode == RASPBDEVENT_NoUser)
            
    {

        ZeroMemory( pInfo, sizeof( RASNOUSERW ) );

        pInfo->dwTimeoutMs = 2 * 60 * 1000;
        pInfo->dwSize = sizeof( RASNOUSERW );
        wcsncpy( pInfo->szUserName, pGlobals->UserName, UNLEN );
        wcsncpy( pInfo->szDomain, pGlobals->Domain, DNLEN );

        RevealPassword( &pGlobals->PasswordString );
        wcsncpy( pInfo->szPassword, pGlobals->Password, PWLEN );

        HidePassword( &pGlobals->Seed, &pGlobals->PasswordString );
        
    }
    
    if(     pGlobals->SmartCardLogon
        &&  (NULL != pInfo))
    {
        pInfo->dwFlags |= RASNOUSER_SmartCard;
    }
}

DWORD
GetRasDialOutProtocols(
    void )

    /* Returns a bit field containing NP_<protocol> flags for the installed
    ** PPP protocols.  The term "installed" here includes enabling in RAS
    ** Setup.
    */
{

    //
    // Since after the connections checkin, RAS is always installed
    // and there is no way to uninstall it, all we need to check here
    // is if there are protocols installed that can be used by RAS to
    // dial out. By default any protocol installed is available for RAS
    // to dial out on. This can be overridden from the phonebook entry.
    //

    static const TCHAR c_szRegKeyIp[] =
            TEXT("SYSTEM\\CurrentControlSet\\Services\\Tcpip");

    static const TCHAR c_szRegKeyIpx[] =
            TEXT("SYSTEM\\CurrentControlSet\\Services\\NwlnkIpx");

    static const TCHAR c_szRegKeyNbf[] =
            TEXT("SYSTEM\\CurrentControlSet\\Services\\Nbf");

    struct PROTOCOL_INFO
    {
        DWORD dwFlag;
        LPCTSTR pszRegkey;
    };

    static const struct PROTOCOL_INFO c_aProtocolInfo[] =
        {
            {
                NP_Ip,
                c_szRegKeyIp,
            },

            {
                NP_Ipx,
                c_szRegKeyIpx,
            },

            {
                NP_Nbf,
                c_szRegKeyNbf,
            },
        };

    DWORD   dwfInstalledProtocols = 0;
    DWORD   dwNumProtocols = sizeof(c_aProtocolInfo)/sizeof(c_aProtocolInfo[0]);
    DWORD   i;
    HKEY    hkey;


    DebugLog(( DEB_TRACE, "GetRasDialOutProtocols...\n" ));

    for(i = 0; i < dwNumProtocols; i++)
    {
        if(0 == RegOpenKey(HKEY_LOCAL_MACHINE,
                           c_aProtocolInfo[i].pszRegkey,
                           &hkey))
        {
            dwfInstalledProtocols |= c_aProtocolInfo[i].dwFlag;
            RegCloseKey(hkey);
        }
    }

    DebugLog(( DEB_TRACE, "GetRasDialOutProtocols: dwfInstalledProtocols=0x%x\n",
             dwfInstalledProtocols));

    return dwfInstalledProtocols;
}


BOOL
PopupRasPhonebookDlg(
    IN  HWND        hwndOwner,
    IN  PGLOBALS    pGlobals,
    OUT BOOL*       pfTimedOut
    )

    /* Popup the RAS common phonebook dialog to let user establish connection.
    ** 'HwndOwner' is the window to own the RAS dialog or NULL if none.  '*PfTimedOut' is
    ** set TRUE if the dialog timed out, false otherwise.
    **
    ** Returns true if user made a connection, false if not, i.e. an error
    ** occurred, RAS is not installed or user could not or chose not to
    ** connect.
    */
{
    BOOL              fConnected;
    RASPBDLG          info;
    DWORD             Protocols;
    PUCHAR            pvScData = NULL;

    struct EAPINFO
    {
        DWORD dwSizeofEapInfo;
        PBYTE pbEapInfo;
        DWORD dwSizeofPINInfo;
        PBYTE pbPINInfo;
    };

    struct EAPINFO eapinfo;
    struct EAPINFO *pEapInfo = NULL;

    *pfTimedOut = FALSE;

    Protocols = GetRasDialOutProtocols();
    if (Protocols == 0)
    {
        return( FALSE );
    }

    if(pGlobals->SmartCardLogon)
    {
        PULONG pulScData;

        struct FLAT_UNICODE_STRING
        {
            USHORT Length;
            USHORT MaximumLength;
            BYTE   abdata[1];
        };

        struct FLAT_UNICODE_STRING *pFlatUnicodeString;
        PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

        //
        // Get the set of strings indicating the reader and CSP
        // to be used for the smart card. We will pass this info
        // down to RAS.
        //
        pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                 WLX_OPTION_SMART_CARD_INFO,
                                 (ULONG_PTR *) &ScInfo);

        if ( !ScInfo )
        {
            return FALSE;
        }

        //
        // Validate the SC info against some common user
        // errors
        //

        if ( ( ScInfo->pszReader ) &&
             ( ScInfo->pszCard == NULL ) )
        {
            //
            // The card could not be read.  Might not be
            // inserted correctly.
            //
            LocalFree(ScInfo);
            return FALSE;
        }

        if ( ( ScInfo->pszReader ) &&
             ( ScInfo->pszCryptoProvider == NULL ) )
        {
            //
            // Got a card, but the CSP for it could not be
            // found.
            //
            LocalFree(ScInfo);
            return FALSE;

        }

        pvScData = ScBuildLogonInfo(ScInfo->pszCard,
                                    ScInfo->pszReader,
                                    ScInfo->pszContainer,
                                    ScInfo->pszCryptoProvider );

        LocalFree(ScInfo);

        if ( ! pvScData )
        {
            return FALSE ;
        }


        pulScData = (PULONG) pvScData;

        ZeroMemory(&eapinfo, sizeof(struct EAPINFO));

        eapinfo.dwSizeofEapInfo = *pulScData;
        eapinfo.pbEapInfo = (BYTE *) pvScData;

        eapinfo.dwSizeofPINInfo = sizeof(UNICODE_STRING) +
                                  (sizeof(TCHAR) *
                                  (1 + lstrlen(pGlobals->PasswordString.Buffer)));

        //
        // Flatten out the unicode string.
        //
        pFlatUnicodeString = LocalAlloc(LPTR, eapinfo.dwSizeofPINInfo);

        if(NULL == pFlatUnicodeString)
        {
            if(NULL != pvScData)
            {
                LocalFree(pvScData);
            }
            return (FALSE);
        }

        pFlatUnicodeString->Length = pGlobals->PasswordString.Length;
        pFlatUnicodeString->MaximumLength = pGlobals->PasswordString.MaximumLength;

        lstrcpy((LPTSTR) pFlatUnicodeString->abdata,
                (LPTSTR) pGlobals->PasswordString.Buffer);


        eapinfo.pbPINInfo = (BYTE *) pFlatUnicodeString;
        pEapInfo = &eapinfo;
    }

    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = hwndOwner;
    info.dwFlags = RASPBDFLAG_NoUser;
    info.pCallback = MyRasCallback;
    info.dwCallbackId = (ULONG_PTR) pGlobals;
    info.reserved2 = (ULONG_PTR) pEapInfo;

    fConnected = RasPhonebookDlg( NULL, NULL, &info );
    if (info.dwError == STATUS_TIMEOUT)
        *pfTimedOut = TRUE;

    if(     (pEapInfo)
        &&  (pEapInfo->pbPINInfo))
    {
        LocalFree(pEapInfo->pbPINInfo);
    }

    if(NULL != pvScData)
    {
        LocalFree(pvScData);
    }

    return fConnected;
}


BOOL
IsRASServiceRunning()
{
    BOOL bRet = FALSE;  // assume the service is not running
    SC_HANDLE hServiceMgr;

    hServiceMgr = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hServiceMgr != NULL)
    {
        SC_HANDLE hService = OpenService(hServiceMgr, TEXT("RASMAN"), SERVICE_QUERY_STATUS);

        if (hService != NULL)
        {
            SERVICE_STATUS status;

            if (QueryServiceStatus(hService, &status) &&
                (status.dwCurrentState == SERVICE_RUNNING))
            {
                // the RAS service is running
                bRet = TRUE;
            }

            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hServiceMgr);
    }

    return bRet;
}


// we need to treat RAS connections made by the system luid as created by the user.
// this allows us to "do the right thing" when a connection is made from the C-A-D dialog
// before any user is logged in
__inline BOOL IsEqualOrSystemLuid(PLUID pLuid, PLUID pUserLuid)
{
    BOOL bRet = FALSE;
    static LUID luidSystem = SYSTEM_LUID;

    if (RtlEqualLuid(pLuid, pUserLuid) || RtlEqualLuid(pLuid, &luidSystem))
    {
        // return true if pLuid matches the users luid or the system luid 
        bRet = TRUE;
    }

    return bRet;
}


BOOL
HangupRasConnections(
    PGLOBALS    pGlobals
    )
{
    DWORD dwError;
    RASCONN rasconn;
    RASCONN* prc;
    DWORD cbSize;
    DWORD cConnections;
    HLOCAL pBuffToFree = NULL;

    if (!IsRASServiceRunning())
    {
        return TRUE;
    }

    prc = &rasconn;
    prc->dwSize = sizeof(RASCONN);
    cbSize = sizeof(RASCONN);

    dwError = RasEnumConnections(prc, &cbSize, &cConnections);

    if (dwError == ERROR_BUFFER_TOO_SMALL)
    {
        pBuffToFree = LocalAlloc(LPTR, cbSize);

        prc = (RASCONN*)pBuffToFree;
        if (prc)
        {
            prc->dwSize = sizeof(RASCONN);

            dwError = RasEnumConnections(prc, &cbSize, &cConnections);
        }
    }

    if (dwError == ERROR_SUCCESS)
    {
        UINT i;

        for (i = 0; i < cConnections; i++)
        {
            if (IsEqualOrSystemLuid(&prc[i].luid, &pGlobals->LogonId))
            {
                RasHangUp(prc[i].hrasconn);
            }
        }
    }

    if (pBuffToFree)
    {
        LocalFree(pBuffToFree);
    }

    return (dwError == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dialogs.rc
//
#define IDB_SMALL_PRO_8                 101
//#define IDB_LARGE_SRV_4                 102       // large BMPs no longer used
#define IDB_BAND_8                      103
#define IDD_WAITDOMAINCACHEVALID_DIALOG 104
#define IDB_MEDIUM_PRO_8                107
#define IDI_KEYBOARD                    109
#define IDD_WELCOMEHELP_DIALOG          109
#define IDI_SMARTCARD                   110
#define IDB_MEDIUM_PRO_4                111
#define IDB_MEDIUM_SRV_4                112
#define IDB_SMALL_PRO_4                 113
#define IDB_SMALL_SRV_4                 114
#define IDI_LOCKED                      115
#define IDI_UNLOCKED                    116
#define IDI_UNLOCK                      116
#define IDB_BAND_4                      117
#define IDB_SMALL_ADV_4                 118
#define IDB_MEDIUM_ADV_4                119
//#define IDB_LARGE_ADV_4                 120       // large BMPs no longer used
#define IDB_SMALL_DCS_4                 121
#define IDB_MEDIUM_DCS_4                122
//#define IDB_LARGE_DCS_4                 123       // large BMPs no longer used
//#define IDB_LARGE_PRO_4                 124       // large BMPs no longer used
#define IDB_SMALL_PER_4                 125
#define IDB_MEDIUM_PER_4                126
//#define IDB_LARGE_PER_4                 127       // large BMPs no longer used
#define IDB_SMALL_PER_8                 128
#define IDB_MEDIUM_PER_8                129
#define IDB_SMALL_SRV_8                 130
#define IDB_MEDIUM_SRV_8                131
#define IDB_SMALL_ADV_8                 132
#define IDB_MEDIUM_ADV_8                133
#define IDB_SMALL_DCS_8                 134
#define IDB_MEDIUM_DCS_8                135
#define IDB_SMALL_PROEMB_8              136
#define IDB_MEDIUM_PROEMB_8             137
#define IDB_MEDIUM_PROEMB_4             138
#define IDB_SMALL_PROEMB_4              139


#define IDD_WELCOME_DIALOG              1400
#define IDD_LOGON_DIALOG                1500
#define IDD_LOGON_SHUTDOWN              1501
#define IDD_LOGON_NAME                  1502
#define IDD_LOGON_PASSWORD              1503
#define IDD_LOGON_DOMAIN                1504
#define IDD_LOGON_RASBOX                1505
#define IDD_LOGON_NAME_LABEL            1506
#define IDD_LOGON_PASSWORD_LABEL        1507
#define IDD_LOGON_DOMAIN_LABEL          1508
#define IDD_LOGON_OPTIONS               1514
#define IDD_NODC_DIALOG                 1600
#define IDD_NODC_TEXT1                  1601
#define IDD_NODC_TEXT2                  1602
#define IDD_NODC_CHECK                  1603
#define IDD_NODC_FRAME                  1604
#define IDD_CHANGEPWD_DIALOG            1700
#define IDD_CHANGEPWD_NAME_LABEL        1701
#define IDD_CHANGEPWD_NAME              1702
#define IDD_CHANGEPWD_DOMAIN_LABEL      1703
#define IDD_CHANGEPWD_DOMAIN            1704
#define IDD_CHANGEPWD_OLD_LABEL         1705
#define IDD_CHANGEPWD_OLD               1706
#define IDD_CHANGEPWD_NEW_LABEL         1707
#define IDD_CHANGEPWD_NEW               1708
#define IDD_CHANGEPWD_CONFIRM_LABEL     1709
#define IDD_CHANGEPWD_CONFIRM           1710
#define IDD_LOCKED_LINE                 1752
#define IDD_LOCKED_INSTRUCTIONS         1754
#define IDD_OPTIONS_DIALOG              1800
#define IDD_OPTIONS_LOCK                1800
#define IDD_OPTIONS_LOGOFF              1801
#define IDD_OPTIONS_SHUTDOWN            1802
#define IDD_OPTIONS_CHANGEPWD           1803
#define IDD_OPTIONS_TASKLIST            1804
#define IDD_OPTIONS_TASKMGR_TEXT        1805
#define IDD_OPTIONS_LOGON_NAME_INFO     1806
#define IDD_OPTIONS_LOGON_DATE          1807
#define IDD_UNLOCK_MESSAGE              1852
#define IDC_UNLOCK_NAME_LABEL           1858
#define IDD_LOCKED_DIALOG               1900
#define IDD_LOCKED_NAME_INFO            1902
#define IDC_UNLOCK_PASSWORD_LABEL       1931
#define IDD_UNLOCK_DIALOG               1950
#define IDD_UNLOCK_NAME_INFO            1952
#define IDD_UNLOCK_NAME                 1953
#define IDD_UNLOCK_PASSWORD             1954
#define IDD_UNLOCK_DOMAIN               1956
#define IDD_UNLOCK_DOMAIN_LABEL         1957
#define IDD_PROGRESS_DIALOG             2000
#define IDD_EXITWINDOWS_DIALOG          2200
#define IDC_EXITOPTIONS_COMBO           2201
#define IDC_EXITOPTIONS_DESCRIPTION     2202
#define IDC_EXITREASONS_COMBO           2204
#define IDC_EXITREASONS_DESCRIPTION     2205
#define IDC_EXITREASONS_CHECK     	2206

#define IDD_DIRTY_DIALOG                2210
#define IDC_DIRTYREASONS_COMBO          2211
#define IDC_DIRTYREASONS_DESCRIPTION    2212
#define IDC_DIRTYREASONS_COMMENT        2213
#define IDC_DIRTYREASONS_BUGID          2214

#define IDD_LOGOFFWINDOWS_DIALOG        2250
#define IDD_LOGOFFICON                  2251
#define IDD_RESTART                     2302
#define IDD_SHUTDOWN                    2305
#define IDD_LOGON_ANNOUNCE              2400
#define IDD_UNLOCK_OPTIONS              2401
#define IDD_LOGON_ANIMATE               2402
#define IDD_LOCKED_ICON                 2403
#define IDD_UNLOCK_ICON                 2404
#define IDD_KBLAYOUT_ICON               2406
#define IDC_SMARTCARD                   2407
#define IDC_KEYBOARD                    2408
#define IDC_PRESSCAD                    2409
#define IDC_HELPLINK                    2410
#define IDC_HELPTEXT                    2411
#define IDC_ANIMATE                     2412
#define IDA_ANIMATE                     2413
#define IDC_HELPTITLE                   2414
#define IDC_CTRL                        2415
#define IDC_ALT                         2416
#define IDC_DEL                         2417
#define IDC_STATIC_WELCOMEGROUP         2418
#define IDC_STATIC_LOCKEDGROUP          2419
#define IDD_CTRL_DEL_MSG                2420
#define IDC_GROUP_UNLOCK                2421
#define IDD_STATUS_MESSAGE_DIALOG       2450
#define IDC_STATUS_MESSAGE_TEXT         2451
#define IDD_LEGALMSG                    2500
#define IDD_LEGALTEXT                   2501
#define IDC_EXITREASONS_COMMENT         2502
#define IDC_EXITREASONS_HEADER          2503
#define IDC_STATIC_REASON_COMMENT	    2504
#define IDC_STATIC_REASON_OPTION	    2505
#define IDC_RESTARTEVENTTRACKER_GRPBX	2506
#define IDD_FAILLOGONHELP_DIALOG        2507
#define IDC_RECOVER                     2508
#define IDC_BACKUP                     2509
#define IDC_STATIC                      -1


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        124
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2422
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\rasx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ras.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-09-96   RichardW   Created
//
//----------------------------------------------------------------------------


BOOL
PopupRasPhonebookDlg(
    HWND        hwndOwner,
    PGLOBALS    pGlobals,
    BOOL *      pfTimedOut
    );


DWORD
GetRasDialOutProtocols(
    void );

BOOL
HangupRasConnections(
    PGLOBALS    pGlobals
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\shtdnp.h ===
// include semi-private header
#include <shlobj.h>
#include <shlobjp.h>

/****************************************************
 Option flags (dwFlags)
 ----------------------
****************************************************/
#define SHTDN_NOHELP                            0x000000001
#define SHTDN_NOPALETTECHANGE                   0x000000002
#define SHTDN_NOBRANDINGBITMAP                  0x000000004

//
//	Policy flags
//
#define POLICY_SHOWREASONUI_NEVER				0
#define POLICY_SHOWREASONUI_ALWAYS				1
#define POLICY_SHOWREASONUI_WORKSTATIONONLY		2
#define POLICY_SHOWREASONUI_SERVERONLY			3

// Private function prototypes
DWORD ShutdownDialog(HWND hwndParent, DWORD dwItems, DWORD dwItemSelect, 
                     LPCTSTR szUsername, DWORD dwFlags, HANDLE hWlx, 
                     PWLX_DIALOG_BOX_PARAM pfnWlxDialogBoxParam);

INT_PTR WinlogonShutdownDialog( HWND hwndParent, PGLOBALS pGlobals, DWORD dwExcludeItems );
INT_PTR WinlogonDirtyDialog( HWND hwndParent, PGLOBALS pGlobals );

DWORD GetSessionCount();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\shutdown.h ===
//
//  The Shutdown Query dialog and Logoff Windows NT dialog
//  are shared by Progman (included in windows\shell\progman\progman.dlg),
//  and therefore changes to them or the filename should not be made
//  unless tested with Progman first.
//  This header file is included in windows\shell\progman\pmdlg.h
//
//  11/10/92  johannec
//

#define DLGSEL_LOGOFF                   0
#define DLGSEL_SHUTDOWN                 1
#define DLGSEL_SHUTDOWN_AND_RESTART     2
#define DLGSEL_SHUTDOWN_AND_RESTART_DOS 3
#define DLGSEL_SLEEP                    4
#define DLGSEL_SLEEP2                   5
#define DLGSEL_HIBERNATE                6


#define WINLOGON_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHUTDOWN_SETTING_KEY L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
#define SHUTDOWN_SETTING L"Shutdown Setting"
#define REASON_SETTING L"Reason Setting"
#define LOGON_USERNAME_SETTING L"Logon User Name"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\shell.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       shell.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include "shtdnp.h"
#include <stdio.h>
#include <wchar.h>
#include <regapi.h>
#include <ginacomn.h>

HICON   hNoDCIcon;

#if DBG
DWORD   DebugAllowNoShell = 1;
#else
DWORD   DebugAllowNoShell = 0;
#endif

//
// Parsing information for autoexec.bat
//
#define PARSE_AUTOEXEC_KEY     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define PARSE_AUTOEXEC_ENTRY   TEXT("ParseAutoexec")
#define PARSE_AUTOEXEC_DEFAULT TEXT("1")
#define MAX_PARSE_AUTOEXEC_BUFFER 2

BOOL
SetLogonScriptVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    );

BOOL
SetAutoEnrollVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    );

VOID
DeleteLogonScriptVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    );

void CtxCreateMigrateEnv( PVOID );
void CtxDeleteMigrateEnv( VOID );

BOOL
DoAutoexecStuff(
    PGLOBALS    pGlobals,
    PVOID *     ppEnvironment,
    LPTSTR      pszPathVar)
{
    HKEY  hKey;
    DWORD dwDisp, dwType, dwMaxBufferSize;
    TCHAR szParseAutoexec[MAX_PARSE_AUTOEXEC_BUFFER];


    //
    // Set the default case
    //

    lstrcpy (szParseAutoexec, PARSE_AUTOEXEC_DEFAULT);


    //
    // Impersonate the user, and check the registry
    //

    if (OpenHKeyCurrentUser(pGlobals)) {


        if (RegCreateKeyEx (pGlobals->UserProcessData.hCurrentUser, PARSE_AUTOEXEC_KEY, 0, 0,
                        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                        NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {


            //
            // Query the current value.  If it doesn't exist, then add
            // the entry for next time.
            //

            dwMaxBufferSize = sizeof (TCHAR) * MAX_PARSE_AUTOEXEC_BUFFER;
            if (RegQueryValueEx (hKey, PARSE_AUTOEXEC_ENTRY, NULL, &dwType,
                            (LPBYTE) szParseAutoexec, &dwMaxBufferSize)
                             != ERROR_SUCCESS) {

                //
                // Set the default value
                //

                RegSetValueEx (hKey, PARSE_AUTOEXEC_ENTRY, 0, REG_SZ,
                               (LPBYTE) szParseAutoexec,
                               sizeof (TCHAR) * (lstrlen (szParseAutoexec) + 1));
            }

            //
            // Close key
            //

            RegCloseKey (hKey);
         }

    //
    // Close HKCU
    //

    CloseHKeyCurrentUser(pGlobals);

    }


    //
    // Process the autoexec if appropriate
    //

    if (szParseAutoexec[0] == TEXT('1')) {
        ProcessAutoexec(ppEnvironment, PATH_VARIABLE);
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   UpdateUserEnvironment
//
//  Synopsis:
//
//  Arguments:  [pGlobals]      --
//              [ppEnvironment] --
//
//  History:    11-01-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
UpdateUserEnvironment(
    PGLOBALS    pGlobals,
    PVOID *     ppEnvironment,
    PWSTR       pszOldDir
    )
{
    BOOL  DeepShare;
    TCHAR lpHomeShare[MAX_PATH] = TEXT("");
    TCHAR lpHomePath[MAX_PATH] = TEXT("");
    TCHAR lpHomeDrive[4] = TEXT("");
    TCHAR lpHomeDirectory[MAX_PATH] = TEXT("");
    BOOL  TSHomeDir   = FALSE;
        TCHAR lpSmartcard[sizeof(pGlobals->Smartcard) + sizeof(pGlobals->SmartcardReader) + 1];

    /*
     * Initialize user's environment.
     */

    SetUserEnvironmentVariable(ppEnvironment, USERNAME_VARIABLE, (LPTSTR)pGlobals->FlatUserName.Buffer, TRUE);
    SetUserEnvironmentVariable(ppEnvironment, USERDOMAIN_VARIABLE, (LPTSTR)pGlobals->FlatDomain.Buffer, TRUE);

        if (pGlobals->Smartcard[0] && pGlobals->SmartcardReader[0]) {

        _snwprintf(
                lpSmartcard, 
                sizeof(lpSmartcard) / sizeof(TCHAR), 
                TEXT("%s;%s"), 
                pGlobals->Smartcard, 
                pGlobals->SmartcardReader
                );

            SetUserEnvironmentVariable(ppEnvironment, SMARTCARD_VARIABLE, lpSmartcard, TRUE);
        }

    if ( !g_Console ) {
        // See if the user specified a TerminalServer Home Directory.
        // If so, we override the regular directory
        if (lstrlen(pGlobals->MuGlobals.TSData.HomeDir) > 0) {
            lstrcpy(lpHomeDirectory, pGlobals->MuGlobals.TSData.HomeDir);
            TSHomeDir = TRUE;
        }
        if (lstrlen(pGlobals->MuGlobals.TSData.HomeDirDrive) > 0) {
            lstrcpy(lpHomeDrive, pGlobals->MuGlobals.TSData.HomeDirDrive);
            TSHomeDir = TRUE;
        }
    }

    if (!TSHomeDir && pGlobals->Profile) {
        if (pGlobals->Profile->HomeDirectoryDrive.Length &&
                (pGlobals->Profile->HomeDirectoryDrive.Length + 1) < (MAX_PATH*sizeof(TCHAR))) {
            lstrcpy(lpHomeDrive, pGlobals->Profile->HomeDirectoryDrive.Buffer);
        }

        if (pGlobals->Profile->HomeDirectory.Length &&
                (pGlobals->Profile->HomeDirectory.Length + 1) < (MAX_PATH*sizeof(TCHAR))) {
            lstrcpy(lpHomeDirectory, pGlobals->Profile->HomeDirectory.Buffer);
        }
    }

    SetHomeDirectoryEnvVars(ppEnvironment,
                            lpHomeDirectory,
                            lpHomeDrive,
                            lpHomeShare,
                            lpHomePath,
                            &DeepShare);

    ChangeToHomeDirectory(  pGlobals,
                            ppEnvironment,
                            lpHomeDirectory,
                            lpHomeDrive,
                            lpHomeShare,
                            lpHomePath,
                            pszOldDir,
                            DeepShare
                            );

    DoAutoexecStuff(pGlobals, ppEnvironment, PATH_VARIABLE);

    SetEnvironmentVariables(pGlobals, USER_ENV_SUBKEY, ppEnvironment);
    SetEnvironmentVariables(pGlobals, USER_VOLATILE_ENV_SUBKEY, ppEnvironment);

    AppendNTPathWithAutoexecPath(ppEnvironment,
                                 PATH_VARIABLE,
                                 AUTOEXECPATH_VARIABLE);

    if (!g_Console) {
        HKEY   Handle;
        DWORD  fPerSessionTempDir = 0;
        DWORD  dwValueData;

        /*
         *  Open registry value set thru TSCC
         */
        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           REG_CONTROL_TSERVER,
                           0,
                           KEY_READ,
                           &Handle ) == ERROR_SUCCESS )
        {
            DWORD ValueSize;
            DWORD ValueType;
            LONG   rc;

            ValueSize = sizeof(fPerSessionTempDir);

            /*
             *  Read registry value
             */
            rc = RegQueryValueExW( Handle,
                                   REG_TERMSRV_PERSESSIONTEMPDIR,
                                   NULL,
                                   &ValueType,
                                   (LPBYTE) &fPerSessionTempDir,
                                   &ValueSize );

            /*
             *  Close registry and key handle
             */
            RegCloseKey( Handle );
        }

        /*
         * Check the machine wide policy set thru Group Policy
         */

        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           TS_POLICY_SUB_TREE,
                           0,
                           KEY_READ,
                           &Handle ) == ERROR_SUCCESS )
        {
            DWORD ValueSize;
            DWORD ValueType;
            LONG   rc;

            ValueSize = sizeof(fPerSessionTempDir);

            /*
             *  Read registry value
             */
            rc = RegQueryValueExW( Handle,
                                   REG_TERMSRV_PERSESSIONTEMPDIR,
                                   NULL,
                                   &ValueType,
                                   (LPBYTE) &dwValueData,
                                   &ValueSize );

            if (rc == ERROR_SUCCESS )
            {
                fPerSessionTempDir = dwValueData;
            }

            /*
             *  Close registry and key handle
             */
            RegCloseKey( Handle );
        }


        if (fPerSessionTempDir) {
            PTERMSRVCREATETEMPDIR pfnTermsrvCreateTempDir;
            HANDLE dllHandle;

            dllHandle = LoadLibrary(TEXT("wlnotify.dll"));
            if (dllHandle) {
                pfnTermsrvCreateTempDir = (PTERMSRVCREATETEMPDIR) GetProcAddress(
                                                                       dllHandle,
                                                                       "TermsrvCreateTempDir"
                                                                       );
                if (pfnTermsrvCreateTempDir)  {
                    pfnTermsrvCreateTempDir( ppEnvironment,
                                             pGlobals->UserProcessData.UserToken,
                                             pGlobals->UserProcessData.NewThreadTokenSD);
                }

                FreeLibrary(dllHandle);
            }
        }
    }
}


BOOL
ExecApplication(
    IN LPTSTR    pch,
    IN LPTSTR    Desktop,
    IN PGLOBALS pGlobals,
    IN PVOID    pEnvironment,
    IN DWORD    Flags,
    IN DWORD    StartupFlags,
    IN BOOL     RestrictProcess,
    OUT PPROCESS_INFORMATION ProcessInformation
    )
{
    STARTUPINFO si;
    BOOL Result, IgnoreResult;
    HANDLE ImpersonationHandle;
    HANDLE ProcessToken;


    //
    // Initialize process startup info
    //
    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = pch;
    si.lpTitle = pch;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = StartupFlags;
    si.wShowWindow = SW_SHOW;   // at least let the guy see it
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;
    si.lpDesktop = Desktop;

    //
    // Impersonate the user so we get access checked correctly on
    // the file we're trying to execute
    //

    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);
    if (ImpersonationHandle == NULL) {
        WLPrint(("ExecApplication failed to impersonate user"));
        return(FALSE);
    }


    if (RestrictProcess &&
        (pGlobals->UserProcessData.RestrictedToken != NULL) )
    {
        ProcessToken = pGlobals->UserProcessData.RestrictedToken;
    }
    else
    {
        ProcessToken = pGlobals->UserProcessData.UserToken;
    }

    //
    // Create the app suspended
    //
    DebugLog((DEB_TRACE, "About to create process of %ws, on desktop %ws\n", pch, Desktop));
    Result = CreateProcessAsUser(
                      ProcessToken,
                      NULL,
                      pch,
                      NULL,
                      NULL,
                      FALSE,
                      Flags | CREATE_SUSPENDED | CREATE_UNICODE_ENVIRONMENT,
                      pEnvironment,
                      NULL,
                      &si,
                      ProcessInformation);


    IgnoreResult = StopImpersonating(ImpersonationHandle);
    ASSERT(IgnoreResult);

    return(Result);

}

BOOL
SetProcessQuotas(
    PGLOBALS pGlobals,
    PPROCESS_INFORMATION ProcessInformation,
    PUSER_PROCESS_DATA UserProcessData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL Result;
    QUOTA_LIMITS RequestedLimits;
    UINT MessageId ;


    RequestedLimits = UserProcessData->Quotas;
    RequestedLimits.MinimumWorkingSetSize = 0;
    RequestedLimits.MaximumWorkingSetSize = 0;

    if (UserProcessData->Quotas.PagedPoolLimit != 0) {

        Result = EnablePrivilege(SE_INCREASE_QUOTA_PRIVILEGE, TRUE);
        if (!Result) {
            WLPrint(("failed to enable increase_quota privilege"));
            return(FALSE);
        }

        Status = NtSetInformationProcess(
                    ProcessInformation->hProcess,
                    ProcessQuotaLimits,
                    (PVOID)&RequestedLimits,
                    (ULONG)sizeof(QUOTA_LIMITS)
                    );

        Result = EnablePrivilege(SE_INCREASE_QUOTA_PRIVILEGE, FALSE);
        if (!Result) {
            WLPrint(("failed to disable increase_quota privilege"));
        }
    }

    if (STATUS_QUOTA_EXCEEDED == Status)
    {

        if ( TestTokenForAdmin( UserProcessData->UserToken )  )
        {
            MessageId = IDS_QUOTAEXHAUSTED ;
            Status = STATUS_SUCCESS ;
        }
        else
        {
            MessageId = IDS_COULDNTSETQUOTAS ;
        }
        // Display a warning in this case
        TimeoutMessageBox(pGlobals->hwndLogon,
                          pGlobals,
                          MessageId,
                          IDS_LOGON_MESSAGE,
                          MB_OK | MB_ICONERROR,
                          TIMEOUT_NONE);
    }

#if DBG
    if (!NT_SUCCESS(Status)) {
        WLPrint(("SetProcessQuotas failed. Status: 0x%lx", Status));
    }
#endif //DBG

    return (NT_SUCCESS(Status));
}

DWORD
ExecProcesses(
    PVOID       pWlxContext,
    IN LPTSTR   Desktop,
    IN PWSTR    Processes,
    PVOID       *ppEnvironment,
    DWORD       Flags,
    DWORD       StartupFlags
    )
{
    PWCH pchData;
    PROCESS_INFORMATION ProcessInformation;
    DWORD dwExecuted = 0 ;
    PWSTR   pszTok;
    PGLOBALS pGlobals = (PGLOBALS) pWlxContext;
    WCHAR   szCurrentDir[MAX_PATH];

    pchData = Processes;

    szCurrentDir[0] = L'\0';

    if (*ppEnvironment) {
        UpdateUserEnvironment(pGlobals, ppEnvironment, szCurrentDir);
    }

    SetLogonScriptVariables(pGlobals, ppEnvironment);

    //we should not lauch autoenrollment in this case as it blocks the shell
    //SetAutoEnrollVariables( pGlobals, ppEnvironment );

    if (g_IsTerminalServer) {
        CtxCreateMigrateEnv( *ppEnvironment );
        pWlxFuncs->WlxWin31Migrate(pGlobals->hGlobalWlx);
        CtxDeleteMigrateEnv( );
    }

    pszTok = wcstok(pchData, TEXT(","));
    while (pszTok)
    {
        if (*pszTok == TEXT(' '))
        {
            while (*pszTok++ == TEXT(' '))
                ;
        }
        if (ExecApplication((LPTSTR)pszTok,
                             Desktop,
                             pGlobals,
                             *ppEnvironment,
                             Flags,
                             StartupFlags,
                             TRUE,              // restrict application
                             &ProcessInformation)) {
            dwExecuted++;

            if (SetProcessQuotas(pGlobals,
                                 &ProcessInformation,
                                 &pGlobals->UserProcessData))
            {
                ResumeThread(ProcessInformation.hThread);
            }
            else
            {

                TerminateProcess(ProcessInformation.hProcess,
                                ERROR_ACCESS_DENIED);
            }

            CloseHandle(ProcessInformation.hThread);
            CloseHandle(ProcessInformation.hProcess);

        } else {

            DebugLog((DEB_WARN, "Cannot start %ws on %ws, error %d.", pszTok, Desktop, GetLastError()));
        }

        pszTok = wcstok(NULL, TEXT(","));

    }

    DeleteLogonScriptVariables(pGlobals, ppEnvironment);

    if ( szCurrentDir[0] )
    {
        SetCurrentDirectory(szCurrentDir);
    }

    return dwExecuted ;
}


INT_PTR
NoDCDlgProc(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam )
{
    DWORD   Button;
    HWND    hwnd;

    switch (Message)
    {
        case WM_INITDIALOG:
            CentreWindow( hDlg );
            if ( !hNoDCIcon )
            {
                hNoDCIcon = LoadImage(  hDllInstance,
                                        MAKEINTRESOURCE( IDI_NODC_ICON ),
                                        IMAGE_ICON,
                                        64, 64,
                                        LR_DEFAULTCOLOR );
            }
            SendMessage(    GetDlgItem( hDlg, IDD_NODC_FRAME ),
                            STM_SETICON,
                            (WPARAM) hNoDCIcon,
                            0 );

            if ( GetProfileInt( WINLOGON, TEXT("AllowDisableDCNotify"), 0 ) )
            {
                hwnd = GetDlgItem( hDlg, IDD_NODC_TEXT2 );
                ShowWindow( hwnd, SW_HIDE );
                EnableWindow( hwnd, FALSE );
            }
            else
            {
                hwnd = GetDlgItem( hDlg, IDD_NODC_CHECK );
                CheckDlgButton( hDlg, IDD_NODC_CHECK, BST_UNCHECKED );
                ShowWindow( hwnd, SW_HIDE );
                EnableWindow( hwnd, FALSE );

            }

            return( TRUE );

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                Button = IsDlgButtonChecked( hDlg, IDD_NODC_CHECK );
                EndDialog( hDlg, Button );
                return( TRUE );
            }


    }

    return( FALSE );
}

VOID
DoNoDCDialog(
    PGLOBALS    pGlobals )
{
    HKEY    hKey;
    int     err;
    DWORD   disp;
    DWORD   Flag;
    DWORD   dwType;
    DWORD   cbData;
    BOOL    MappedHKey;
    PWSTR   ReportControllerMissing;

    Flag = 1;
    hKey = NULL ;

    if (OpenHKeyCurrentUser(pGlobals))
    {
        MappedHKey = TRUE;

        err = RegCreateKeyEx(   pGlobals->UserProcessData.hCurrentUser,
                                WINLOGON_USER_KEY,
                                0, NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &hKey,
                                &disp );
        if (err == 0)
        {
            cbData = sizeof(DWORD);

            err = RegQueryValueEx(    hKey,
                                NODCMESSAGE,
                                NULL,
                                &dwType,
                                (LPBYTE) &Flag,
                                &cbData );

            if (err != ERROR_SUCCESS || dwType != REG_DWORD)
            {
                Flag = 1;
            }

        }
        else
        {
            hKey = NULL;
        }


    }
    else
    {
        MappedHKey = FALSE;
    }

    if ( Flag )
    {
        ReportControllerMissing = AllocAndGetProfileString( APPLICATION_NAME,
                                                            REPORT_CONTROLLER_MISSING,
                                                            TEXT("FALSE")
                                                            );

        if ( ReportControllerMissing )
        {
            if ( lstrcmp( ReportControllerMissing, TEXT("TRUE")) == 0 )
            {
                Flag = 1;
            }
            else
            {
                Flag = 0;
            }

            Free( ReportControllerMissing );
        }
        else
        {
            Flag = 1;
        }

    }


    if (Flag)
    {
        pWlxFuncs->WlxSetTimeout( pGlobals->hGlobalWlx, 120 );

        Flag = pWlxFuncs->WlxDialogBoxParam(    pGlobals->hGlobalWlx,
                                                hDllInstance,
                                                (LPTSTR) IDD_NODC_DIALOG,
                                                NULL,
                                                NoDCDlgProc,
                                                0 );
    }
    else
    {
        Flag = BST_CHECKED;
    }

    if (hKey)
    {
        if (Flag == BST_CHECKED)
        {
            Flag = 0;
        }
        else
        {
            Flag = 1;
        }

        RegSetValueEx(  hKey,
                        NODCMESSAGE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &Flag,
                        sizeof(DWORD) );

        RegCloseKey( hKey );

    }

    if (MappedHKey)
    {
        CloseHKeyCurrentUser(pGlobals);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetPasswordExpiryWarningPeriod
//
//  Synopsis:   Returns the password expiry warning period in days: either
//              the value in the registry or the default value.
//
//  Arguments:  None
//
//  Returns:    Password expiry warning period in days.
//
//  History:    10-09-01 CenkE Copied from ShouldPasswordExpiryWarningBeShown
//
//----------------------------------------------------------------------------
DWORD 
GetPasswordExpiryWarningPeriod (
    VOID
    )
{
    HKEY    hKey;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   DaysToCheck;

    DaysToCheck = PASSWORD_EXPIRY_WARNING_DAYS;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, WINLOGON_USER_KEY, &hKey) == 0)
    {
        dwSize = sizeof(DWORD);

        if (RegQueryValueEx(hKey,
                            PASSWORD_EXPIRY_WARNING,
                            0,
                            &dwType,
                            (LPBYTE) &DaysToCheck,
                            &dwSize ) ||
            (dwType != REG_DWORD) )
        {
            DaysToCheck = PASSWORD_EXPIRY_WARNING_DAYS;
        }

        RegCloseKey(hKey);
    }
    
    return DaysToCheck;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDaysToExpiry
//
//  Synopsis:   If the passed in times can be converted to seconds since 1980,
//              returns how many days there are from CurrentTime to ExpiryTime
//
//  Arguments:  CurrentTime   -- This can be the current time or the time of a 
//                               logon etc. as FILETIME.
//              ExpiryTime    -- PasswordMustChange time from profile.
//              DaysToExpiry  -- If successful, days to password expiry is 
//                               returned here.
//
//  Returns:    TRUE - DaysToExpiry could be calculated.
//              FALSE - DaysToExpiry could not be calculated, or the password
//                      never expires.
//
//  History:    10-09-01 CenkE Copied from ShouldPasswordExpiryWarningBeShown
//
//----------------------------------------------------------------------------

#define SECONDS_PER_DAY (60*60*24)

BOOL
GetDaysToExpiry (
    IN PLARGE_INTEGER CurrentTime,
    IN PLARGE_INTEGER ExpiryTime,
    OUT PDWORD DaysToExpiry
    )
{
    ULONG ElapsedSecondsNow;
    ULONG ElapsedSecondsPasswordExpires;

    //
    // Convert the expiry time to seconds.
    //

    if (!RtlTimeToSecondsSince1980(ExpiryTime, &ElapsedSecondsPasswordExpires))
    {
        //
        // The time was not expressable in 32-bit seconds
        // Set seconds to password expiry based on whether the expiry
        // time is way in the past or way in the future.
        //

        // Never expires?
        if (ExpiryTime->QuadPart > CurrentTime->QuadPart)
        {
            return FALSE;
        }

        ElapsedSecondsPasswordExpires = 0; // Already expired
    }

    //
    // Convert the start time to seconds.
    //

    if (!RtlTimeToSecondsSince1980(CurrentTime, &ElapsedSecondsNow)) {
        return FALSE;
    }

    if (ElapsedSecondsPasswordExpires < ElapsedSecondsNow)
    {
        (*DaysToExpiry) = 0;
    }
    else
    {
        (*DaysToExpiry) = (ElapsedSecondsPasswordExpires - ElapsedSecondsNow)/SECONDS_PER_DAY;
    }

    return TRUE;
}
    
BOOL
ShouldPasswordExpiryWarningBeShown(
    IN  PGLOBALS    pGlobals,
    IN  BOOL        LogonCheck,
        OUT     PDWORD          pDaysToExpiry )
{
    ULONG   DaysToExpiry;
    DWORD   DaysToCheck;
    LARGE_INTEGER   Now;
    LARGE_INTEGER   Last;
    PLARGE_INTEGER  StartTime;

    if (pGlobals->TransderedCredentials) {

        // do not display password expiry in this case as it 
        // would otherwise display the password expiry twice
        return FALSE;
    }

    Last.LowPart = pGlobals->LastNotification.dwLowDateTime;
    Last.HighPart = pGlobals->LastNotification.dwHighDateTime;

    GetSystemTimeAsFileTime((FILETIME*) &Now);

    Last.QuadPart += (24 * 60 * 60 * 10000000I64);

    //
    // Only if last shown more than 24 hours ago
    //

    if (Now.QuadPart < Last.QuadPart)
    {
            return FALSE;
    }

    //
    // Get password expiry warning period
    //

    DaysToCheck = GetPasswordExpiryWarningPeriod();

    //
    // Go get parameters from our user's profile
    //

    if (!pGlobals->Profile)
    {
        return FALSE;
    }

    if ( LogonCheck )
    {
        StartTime = &pGlobals->LogonTime;
    }
    else
    {
        StartTime = &Now;
    }

    //
    // Determine number of days till the password expires.
    //

    if (!GetDaysToExpiry(StartTime, 
                         &(pGlobals->Profile->PasswordMustChange),
                         &DaysToExpiry)) 
    {
        return FALSE;                    
    }
                                   
    // Not within warning period?
    if (DaysToExpiry > DaysToCheck)
    {
        return FALSE;
    }

    // If return pointer... fill in
    if ( pDaysToExpiry )
    {
        *pDaysToExpiry = DaysToExpiry;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckPasswordExpiry
//
//  Synopsis:   Does the password expiration check on demand
//
//  Arguments:  [pGlobals]   --
//              [LogonCheck] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-13-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INT_PTR
CheckPasswordExpiry(
    PGLOBALS    pGlobals,
    BOOL        LogonCheck)
{
    LARGE_INTEGER           Now;
    ULONG                   DaysToExpiry;
    TCHAR                   Buffer1[MAX_STRING_BYTES];
    TCHAR                   Buffer2[MAX_STRING_BYTES];
    INT_PTR                 Result = IDOK;
    LPTSTR                  UserSidString;

        // Get current time
    GetSystemTimeAsFileTime((FILETIME*) &Now);

        if (ShouldPasswordExpiryWarningBeShown(pGlobals, LogonCheck, &DaysToExpiry))
        {
                //
                // Disable optimized logon for this user for next time if
                // we are entering the password expiry warning period, so 
                // password expiry warning dialogs will be shown if the user
                // does not change the password right now. Otherwise
                // for cached logons password expiry time is invented to be
                // forever in the future.
                //

                if (pGlobals->UserProcessData.UserToken) 
                {
                    UserSidString = GcGetSidString(pGlobals->UserProcessData.UserToken);

                    if (UserSidString) 
                    {
                        GcSetNextLogonCacheable(UserSidString, FALSE);
                        GcDeleteSidString(UserSidString);
                    }   
                }
                
                if (DaysToExpiry > 0)
                {
                        LoadString(hDllInstance, IDS_PASSWORD_WILL_EXPIRE, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
                        _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, DaysToExpiry);
                }
                else
                {
                        LoadString(hDllInstance, IDS_PASSWORD_EXPIRES_TODAY, Buffer2, sizeof(Buffer2) / sizeof( TCHAR ));
                }

                LoadString(hDllInstance, IDS_LOGON_MESSAGE, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ) );

                pGlobals->LastNotification.dwHighDateTime = Now.HighPart;
                pGlobals->LastNotification.dwLowDateTime = Now.LowPart;

                Result = TimeoutMessageBoxlpstr(NULL,
                                                                                pGlobals,
                                                                                Buffer2,
                                                                                Buffer1,
                                                                                MB_YESNO | MB_ICONEXCLAMATION,
                                                                                (LogonCheck ? LOGON_TIMEOUT : 60));
                if (Result == IDYES)
                {
                        //
                        // Let the user change their password now
                        //

                        if ( LogonCheck && pGlobals->SmartCardLogon )
                        {
                                LogonCheck = FALSE ;
                        }

                        if ( LogonCheck )
                        {
                                RevealPassword( &pGlobals->PasswordString );

                                Result = ChangePasswordLogon(NULL,
                                                           pGlobals,
                                                           pGlobals->UserName,
                                                           pGlobals->Domain,
                                                           pGlobals->Password);

                                if ( Result == IDCANCEL )
                                {
                                        //
                                        // If we got cancelled, then the string won't get
                                        // updated, so rehide it so that unlocks work later
                                        //

                                        HidePassword(   &pGlobals->Seed,
                                                                        &pGlobals->PasswordString );
                                }

                        }
                        else
                        {
                                Result = ChangePassword(
                                                                NULL,
                                                                pGlobals,
                                                                pGlobals->UserName,
                                                                pGlobals->Domain,
                                                                CHANGEPWD_OPTION_ALL );

                        }

                }

                if (DLG_INTERRUPTED(Result))
                {
                        return(Result);
                }
        }

        return MSGINA_DLG_SUCCESS;
}

/****************************************************************************\
*
* FUNCTION: DisplayPostShellLogonMessages
*
* PURPOSE:  Displays any security warnings to the user after a successful logon
*           The messages are displayed while the shell is starting up.
*
* RETURNS:  DLG_SUCCESS - the dialogs were displayed successfully.
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* NOTE:     Screen-saver timeouts are handled by our parent dialog so this
*           routine should never return DLG_SCREEN_SAVER_TIMEOUT
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

INT_PTR
DisplayPostShellLogonMessages(
    PGLOBALS    pGlobals
    )
{
    INT_PTR Result = IDOK;

    //
    // Check to see if the system time is properly set
    //

    {
        SYSTEMTIME Systime;

        GetSystemTime(&Systime);

        if ( Systime.wYear < 2000 ) {

            Result = TimeoutMessageBox(
                             NULL,
                             pGlobals,
                             IDS_INVALID_TIME_MSG,
                             IDS_INVALID_TIME,
                             MB_OK | MB_ICONSTOP,
                             TIMEOUT_NONE
                             );

            if (DLG_INTERRUPTED(Result)) {
                return(Result);
            }
        }
    }

    pGlobals->LastNotification.dwHighDateTime = 0;
    pGlobals->LastNotification.dwLowDateTime = 0;

    if (!pGlobals->TransderedCredentials) {

        // do not display password expiry in this case as it 
        // would otherwise display the password expiry twice
        Result = CheckPasswordExpiry( pGlobals, TRUE );
    }

    if (pGlobals->Profile != NULL) {

        //
        // Logon cache used
        //

        if (pGlobals->Profile->UserFlags & LOGON_CACHED_ACCOUNT)
        {

            //
            // Don't display any warning messages if we did an optimized logon.
            //

            if (pGlobals->OptimizedLogonStatus != OLS_LogonIsCached) {
                DoNoDCDialog( pGlobals );
            }
        }
    }

    //
    // Hash the password away, then destroy the text copy completely.
    //


    if (!pGlobals->TransderedCredentials) {
       RevealPassword( &pGlobals->PasswordString );
       if (pGlobals->SmartCardLogon)
       {
                // We don't want the SC PIN hash
                // (prevents password unlocks using the PIN)
           memset(pGlobals->PasswordHash, 0, sizeof(pGlobals->PasswordHash));
       }
       else
       {
           HashPassword( &pGlobals->PasswordString, pGlobals->PasswordHash );
       }
       ErasePassword( &pGlobals->PasswordString );
    }


    return(IDOK);
}




/***************************************************************************\
* FUNCTION: SetLogonScriptVariables
*
* PURPOSE:  Sets the appropriate environment variables in the user
*           process environment block so that the logon script information
*           can be passed into the userinit app.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   21-Aug-92 Davidc       Created.
*
\***************************************************************************/

BOOL
SetLogonScriptVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    )
{
    NTSTATUS Status;
    LPWSTR EncodedMultiSz;
    UNICODE_STRING Name, Value;

    //
    // Note whether we performed an optimized logon.
    //

    RtlInitUnicodeString(&Name,  OPTIMIZED_LOGON_VARIABLE);

    if (pGlobals->OptimizedLogonStatus == OLS_LogonIsCached) {
        RtlInitUnicodeString(&Value, L"1");
    } else {
        RtlInitUnicodeString(&Value, L"0");
    }

    Status = RtlSetEnvironmentVariable(pEnvironment, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        WLPrint(("Failed to set environment variable <%Z> to value <%Z>", &Name, &Value));
        goto CleanupAndExit;
    }

    //
    // Set our primary authenticator logon script variables
    //

    if (pGlobals->Profile != NULL) {

        //
        // Set the server name variable
        //

        RtlInitUnicodeString(&Name,  LOGON_SERVER_VARIABLE);
        Status = RtlSetEnvironmentVariable(pEnvironment, &Name, &pGlobals->Profile->LogonServer);
        if (!NT_SUCCESS(Status)) {
            WLPrint(("Failed to set environment variable <%Z> to value <%Z>", &Name, &pGlobals->Profile->LogonServer));
            goto CleanupAndExit;
        }

        //
        // Set the script name variable
        //

        RtlInitUnicodeString(&Name, LOGON_SCRIPT_VARIABLE);
        Status = RtlSetEnvironmentVariable(pEnvironment, &Name, &pGlobals->Profile->LogonScript);
        if (!NT_SUCCESS(Status)) {
            WLPrint(("Failed to set environment variable <%Z> to value <%Z>", &Name, &pGlobals->Profile->LogonScript));
            goto CleanupAndExit;
        }
    }

    //
    // Set the multiple provider script name variable
    //

    if (pGlobals->MprLogonScripts != NULL) {

        RtlInitUnicodeString(&Name, MPR_LOGON_SCRIPT_VARIABLE);

        EncodedMultiSz = EncodeMultiSzW(pGlobals->MprLogonScripts);
        if (EncodedMultiSz == NULL) {
            WLPrint(("Failed to encode MPR logon scripts into a string"));
            goto CleanupAndExit;
        }

        RtlInitUnicodeString(&Value, EncodedMultiSz);
        Status = RtlSetEnvironmentVariable(pEnvironment, &Name, &Value);
        Free(EncodedMultiSz);
        if (!NT_SUCCESS(Status)) {
            WLPrint(("Failed to set mpr scripts environment variable <%Z>", &Name));
            goto CleanupAndExit;
        }
    }


    return(TRUE);


CleanupAndExit:

    DeleteLogonScriptVariables(pGlobals, pEnvironment);
    return(FALSE);
}



BOOL
SetAutoEnrollVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    )
{
    BOOL Result = FALSE ;
    UNICODE_STRING Name, Value ;


    // we should check for safe boot, domain member, and policy flag in registry
    // but we will always spawn userinit, so instead of duplicationg code, let 
    // autoenrollment do those checks.

    /*
    if (OpenHKeyCurrentUser(pGlobals))
    {

        if ( RegOpenKeyEx( pGlobals->UserProcessData.hCurrentUser,
                           WINLOGON_POLICY_KEY,
                           0,
                           KEY_READ,
                           &hKey ) == 0 )
        {
            dwSize = sizeof( Result );

            RegQueryValueEx( hKey,
                             DISABLE_AUTOENROLLMENT,
                             0,
                             &dwType,
                             (PBYTE) &Result,
                             &dwSize );

            RegCloseKey( hKey );

        }

        CloseHKeyCurrentUser(pGlobals);
    }
    */
    //
    // If the Disable flag hasn't been turned on, add the env var
    //

    if ( !Result )
    {
        RtlInitUnicodeString( &Name, USER_INIT_AUTOENROLL );
        RtlInitUnicodeString( &Value, AUTOENROLL_NONEXCLUSIVE );
        RtlSetEnvironmentVariable(pEnvironment, &Name, &Value);

        RtlInitUnicodeString( &Name, USER_INIT_AUTOENROLLMODE );
        RtlInitUnicodeString( &Value, AUTOENROLL_STARTUP );
        RtlSetEnvironmentVariable(pEnvironment, &Name, &Value);
    }

    return TRUE ;
}

/***************************************************************************\
* FUNCTION: DeleteLogonScriptVariables
*
* PURPOSE:  Deletes the environment variables in the user process
*           environment block that we use to communicate logon script
*           information to the userinit app
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   21-Aug-92 Davidc       Created.
*
\***************************************************************************/

VOID
DeleteLogonScriptVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;

    RtlInitUnicodeString(&Name, OPTIMIZED_LOGON_VARIABLE);

    Status = RtlSetEnvironmentVariable(pEnvironment, &Name, NULL);
    if (!NT_SUCCESS(Status) && (Status != STATUS_UNSUCCESSFUL) ) {
        WLPrint(("Failed to delete environment variable <%Z>, status = 0x%lx", &Name, Status));
    }

    RtlInitUnicodeString(&Name, LOGON_SERVER_VARIABLE);

    Status = RtlSetEnvironmentVariable(pEnvironment, &Name, NULL);
    if (!NT_SUCCESS(Status) && (Status != STATUS_UNSUCCESSFUL) ) {
        WLPrint(("Failed to delete environment variable <%Z>, status = 0x%lx", &Name, Status));
    }

    RtlInitUnicodeString(&Name, LOGON_SCRIPT_VARIABLE);

    Status = RtlSetEnvironmentVariable(pEnvironment, &Name, NULL);
    if (!NT_SUCCESS(Status) && (Status != STATUS_UNSUCCESSFUL) ) {
        WLPrint(("Failed to delete environment variable <%Z>, status = 0x%lx", &Name, Status));
    }

    if (pGlobals->MprLogonScripts != NULL) {
        RtlInitUnicodeString(&Name, MPR_LOGON_SCRIPT_VARIABLE);

        Status = RtlSetEnvironmentVariable(pEnvironment, &Name, NULL);
        if (!NT_SUCCESS(Status) && (Status != STATUS_UNSUCCESSFUL) ) {
            WLPrint(("Failed to delete environment variable <%Z>, status = 0x%lx", &Name, Status));
        }
    }
}


BOOL
WINAPI
WlxActivateUserShell(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktop,
    PWSTR                   pszMprLogonScript,
    PVOID                   pEnvironment
    )
{
    BOOL        bExec;
    PGLOBALS    pGlobals;
    PWSTR       pchData;
    BOOL        fReturn = FALSE;

    _ShellReleaseLogonMutex(TRUE);
    pchData = AllocAndGetPrivateProfileString(APPLICATION_NAME,
                                              USERINIT_KEY,
                                              TEXT("%SystemRoot%\\system32\\userinit.exe"),
                                              NULL);

    if ( !pchData )
    {
        if (pszMprLogonScript) {
            LocalFree(pszMprLogonScript);
        }
        goto WlxAUSEnd;
    }

    pGlobals = (PGLOBALS) pWlxContext;

    if (pGlobals->MprLogonScripts) {
        LocalFree(pGlobals->MprLogonScripts);
    }

    pGlobals->MprLogonScripts = pszMprLogonScript;

    bExec = ExecProcesses(pWlxContext, pszDesktop, pchData, &pEnvironment, 0, 0);

    Free( pchData );

    if (!bExec && (DebugAllowNoShell == 0))
    {
        goto WlxAUSEnd;
    }

    if ( pGlobals->ExtraApps )
    {
        ExecProcesses( pWlxContext, pszDesktop, pGlobals->ExtraApps, &pEnvironment, 0, 0 );

        Free( pGlobals->ExtraApps );

        pGlobals->ExtraApps = NULL;
    }

    pGlobals->UserProcessData.pEnvironment = pEnvironment;

    // Write out the current user name to a place where shell logoff can read it
    if (OpenHKeyCurrentUser(pGlobals))
    {
        HKEY hkeyExplorer = NULL;
        if (ERROR_SUCCESS == RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser,
            SHUTDOWN_SETTING_KEY, 0, KEY_SET_VALUE, &hkeyExplorer))
        {
            RegSetValueEx(hkeyExplorer, LOGON_USERNAME_SETTING, 0, REG_SZ,
                (CONST BYTE *) pGlobals->UserName,
                ((lstrlen(pGlobals->UserName) + 1) * sizeof(WCHAR)));

            RegCloseKey(hkeyExplorer);
        }

        CloseHKeyCurrentUser(pGlobals);
    }

    // Run the dirty dialog box.
    if ( WinlogonDirtyDialog( NULL, pGlobals ) == WLX_SAS_ACTION_LOGOFF )
    {
        //
        // If this returns logoff, it means that the dialog timed out and
        // we need to force the user back off.  Not the best user experience,
        // but that's what the PMs want.
        //

    }
    else
    {
        fReturn = TRUE ;
    }

WlxAUSEnd:

    return fReturn;

}


BOOL
WINAPI
WlxStartApplication(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktop,
    PVOID                   pEnvironment,
    PWSTR                   pszCmdLine
    )
{
    PROCESS_INFORMATION ProcessInformation;
    BOOL        bExec;
    PGLOBALS    pGlobals = (PGLOBALS) pWlxContext;
    WCHAR       szCurrentDir[MAX_PATH];
    WCHAR       localApp[ MAX_PATH ];

    szCurrentDir[0] = L'\0';
    if (pEnvironment) {
        UpdateUserEnvironment(pGlobals, &pEnvironment, szCurrentDir);
    }

    if ( (_wcsicmp(pszCmdLine, L"explorer.exe" ) == 0 ) ||
         (_wcsicmp(pszCmdLine, L"explorer" ) == 0 )  ) {

        //
        // Avoid security problem since explorer is in SystemRoot,
        // not SystemRoot\system32
        //

        if ( ExpandEnvironmentStrings(
                    L"%SystemRoot%\\explorer.exe",
                    localApp,
                    MAX_PATH ) != 0 ) {

            pszCmdLine = localApp ;
        }
    }
    


    bExec = ExecApplication (pszCmdLine,
                             pszDesktop,
                             pGlobals,
                             pEnvironment,
                             0,
                             STARTF_USESHOWWINDOW,
                             _wcsicmp(pszCmdLine, TEXT("taskmgr.exe")),                     // don't restrict application
                             &ProcessInformation);

    if (pEnvironment)
    {       // We don't need it anymore
        VirtualFree(pEnvironment, 0, MEM_RELEASE);
    }


    if (!bExec) {
        if ( szCurrentDir[0] )
        {
            SetCurrentDirectory(szCurrentDir);
        }
        return(FALSE);
    }

    if (SetProcessQuotas(pGlobals,
                         &ProcessInformation,
                         &pGlobals->UserProcessData))
    {
        ResumeThread(ProcessInformation.hThread);
    }
    else
    {
        TerminateProcess(ProcessInformation.hProcess,
                        ERROR_ACCESS_DENIED);
    }

    CloseHandle(ProcessInformation.hThread);
    CloseHandle(ProcessInformation.hProcess);

    if ( szCurrentDir[0] )
    {
        SetCurrentDirectory(szCurrentDir);
    }

    return(TRUE);
}


void
CtxCreateMigrateEnv( PVOID pEnv )
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    DWORD cb;

    cb = 1024;
    Value.Buffer = Alloc(sizeof(TCHAR)*cb);

    if (!Value.Buffer)
        return;

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    RtlInitUnicodeString( &Name, HOMEDRIVE_VARIABLE );
    Status = RtlQueryEnvironmentVariable_U( pEnv, &Name, &Value );
    if ( NT_SUCCESS(Status) )
        SetEnvironmentVariable( HOMEDRIVE_VARIABLE, Value.Buffer );

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    RtlInitUnicodeString( &Name, HOMEPATH_VARIABLE );
    Status = RtlQueryEnvironmentVariable_U( pEnv, &Name, &Value );
    if ( NT_SUCCESS(Status) )
        SetEnvironmentVariable( HOMEPATH_VARIABLE, Value.Buffer );

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    RtlInitUnicodeString( &Name, INIDRIVE_VARIABLE );
    Status = RtlQueryEnvironmentVariable_U( pEnv, &Name, &Value );
    if ( NT_SUCCESS(Status) )
        SetEnvironmentVariable( INIDRIVE_VARIABLE, Value.Buffer );

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    RtlInitUnicodeString(&Name, INIPATH_VARIABLE);
    Status = RtlQueryEnvironmentVariable_U( pEnv, &Name, &Value );
    if ( NT_SUCCESS(Status) )
        SetEnvironmentVariable( INIPATH_VARIABLE, Value.Buffer );

    Free(Value.Buffer);
}


void
CtxDeleteMigrateEnv( )
{
    SetEnvironmentVariable( HOMEDRIVE_VARIABLE, NULL);
    SetEnvironmentVariable( HOMEPATH_VARIABLE, NULL);
    SetEnvironmentVariable( INIDRIVE_VARIABLE, NULL);
    SetEnvironmentVariable( INIPATH_VARIABLE, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\stringid.h ===
/****************************** Module Header ******************************\
* Module Name: stringid.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines resource ids for resources other than dialogs
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Strings
//
#define IDS_LOCKED_MESSAGE              1500
#define IDS_LOGON_MESSAGE               1501
#define IDS_INCORRECT_NAME_OR_PWD_CHANGE 1502
#define IDS_PASSWORD_WILL_EXPIRE        1503
#define IDS_PASSWORD_EXPIRES_TODAY      1504
#define IDS_INCORRECT_NAME_OR_PWD       1505
#define IDS_LOGON_NO_DOMAIN             1506
#define IDS_PASSWORD_EXPIRED            1507
#define IDS_GENERAL_PASSWORD_SPEC       1508
#define IDS_CHANGE_PASSWORD             1509
#define IDS_NO_PERMISSION_CHANGE_PWD    1510
#define IDS_PASSWORD_MINIMUM_AGE        1511
#define IDS_NO_PASSWORD_CONFIRM         1512
#define IDS_PASSWORD_SPEC               1513
#define IDS_ENTER_PASSWORDS             1514
#define IDS_PASSWORD_CHANGED            1515
#define IDS_CHANGE_PWD_NO_DOMAIN        1516
#define IDS_UNLOCK_FAILED               1517
#define IDS_WORKSTATION_LOCKED          1518
#define IDS_LOGON_NAME_INFO             1519
#define IDS_RESTART_SYSTEM              1520
#define IDS_ACCOUNT_RESTRICTION_CHANGE  1521
#define IDS_ACCOUNT_RESTRICTION         1522
#define IDS_UNKNOWN_LOGON_FAILURE       1523
#define IDS_WINDOWS_MESSAGE             1524
#define IDS_NO_PERMISSION_SHUTDOWN      1525
#define IDS_SAFE_TO_TURN_OFF            1526
#define IDS_SHUTDOWN_MESSAGE            1527
#define IDS_FORCE_LOGOFF_WARNING        1528

#define IDS_LOGON_TYPE_NOT_GRANTED      1529
#define IDS_INVALID_LOGON_HOURS         1530
#define IDS_INVALID_WORKSTATION         1531
#define IDS_ACCOUNT_DISABLED            1532

#define IDS_AUDITING_DISABLED           1533
#define IDS_AUDITING_NOT_DISABLED       1534
#define IDS_CARD_NOT_RECOGNIZED         1535
#define IDS_CARD_CSP_NOT_RECOGNIZED     1536

#define IDS_LOAD_PROFILE                1538
#define IDS_USE_DEFAULT_PROFILE         1539

#define IDS_EMERGENCY_SHUTDOWN          1540
#define IDS_REBOOT_LOSE_CHANGES         1541

#define IDS_NO_TRUST_LSA_SECRET         1542
#define IDS_TRUSTED_DOMAIN_FAILURE      1543
#define IDS_TRUSTED_RELATIONSHIP_FAILURE 1544

#define IDS_LOCKED_NFN_MESSAGE          1550
#define IDS_LOGON_NAME_NFN_INFO         1551
#define IDS_UNLOCK_FAILED_NFN           1552
#define IDS_UNLOCK_FAILED_BAD_PWD       1553

#define IDS_PASSWORD_MUST_CHANGE        1554
#define IDS_INCORRECT_NAME_OR_PWD_SC    1555
#define IDS_UNLOCK_FAILED_BAD_PIN       1556
#define IDS_NO_DOMAIN_AND_NO_UPN        1557
#define IDS_LONG_PASSWORD_WARNING       1558

#define IDS_MBTWRONGDOMAIN              1559
#define IDS_MBMWRONGDOMAIN              1560

#define IDS_SYSTEM_SCREEN_SAVER_NAME    1564


#define IDS_SOUND_DLL                   1570
#define IDS_WAVEOUTGETNUMDEVS           1571
#define IDS_PLAYSOUND                   1572

#define IDS_REQUIRES_PRIMARY_CONTROLLER 1579
#define IDS_NO_PAGING_FILE              1580
#define IDS_LIMITED_RESOURCES           1581

#define IDS_INVALID_TIME                1582
#define IDS_INVALID_TIME_MSG            1583

#define IDS_ACCOUNT_EXPIRED             1584
#define IDS_NETLOGON_NOT_STARTED        1585
#define IDS_UNKNOWN_CHANGE_PWD_FAILURE  1586
#define IDS_FORCE_LOGOFF_FAILURE        1587
#define IDS_CACHED_LOGON                1588
#define IDS_NO_TRUSTED_DOMAINS          1589

#define IDS_SETUP_INCOMPLETE            1590

#define IDS_MANDATORY_PROFILE_ERROR     1591
#define IDS_LOGON_NO_ACCESS_MAN_PROFILE_KEYS    1592
#define IDS_LOGON_NO_ACCESS_MAN_PROFILE         1593

#define IDS_LOGON_CANT_LOAD_PROFILE     1595
#define IDS_LOGON_UPDATE_CENTRAL        1598
#define IDS_LOGON_CACHED_PROFILE_USED   1599
#define IDS_LOGON_UPDATE_CENTRAL_FAILED 1600
#define IDS_LOGON_FAILED_DISK_FULL      1601
#define IDS_LOGON_FAILED_OUTOFMEMORY    1602
#define IDS_ACCOUNT_LOCKED              1603
#define IDS_LOGON_WITH_DISK_FULL        1604
#define IDS_LOGOFF_TITLE                1606
#define IDS_LOGOFF_LOSE_CHANGES         1607
#define IDS_WELCOME_CAPTION             1608
#define IDS_LOGON_BAD_SC                1609
#define IDS_TIME_DIFFERENCE_AT_DC       1621

#define IDS_STATUS_SMARTCARD_WRONG_PIN  1630
#define IDS_STATUS_SMARTCARD_CARD_BLOCKED   1631
#define IDS_STATUS_SMARTCARD_NO_CARD    1632
#define IDS_STATUS_SMARTCARD_NO_KEY_CONTAINER   1633
#define IDS_STATUS_SMARTCARD_NO_CERTIFICATE 1634
#define IDS_STATUS_SMARTCARD_NO_KEYSET  1635
#define IDS_STATUS_SMARTCARD_IO_ERROR   1636
#define IDS_STATUS_SMARTCARD_SUBSYSTEM_FAILURE  1637
#define IDS_STATUS_NO_TRUST_SAM_ACCOUNT 1638
#define IDS_STATUS_SERVER_SIDE_ERROR    1639
#define IDS_STATUS_SERVER_SIDE_ERROR_NOINSERT   1640
#define IDS_LOGON_NO_DOMAIN_NOINSERT    1641
#define IDS_UNKNOWN_LOGON_FAILURE_NOINSERT      1642
#define IDS_STATUS_SMARTCARD_CERT_REVOKED       1643
#define IDS_STATUS_ISSUING_CA_UNTRUSTED         1644
#define IDS_STATUS_REVOCATION_OFFLINE_C         1645
#define IDS_STATUS_PKINIT_CLIENT_FAILURE        1647
#define IDS_STATUS_SMARTCARD_CERT_EXPIRED       1648

#define IDS_STATUS_SMARTCARD_WRONG_PIN_UNLOCK           1650
#define IDS_STATUS_SMARTCARD_CARD_BLOCKED_UNLOCK        1651
#define IDS_STATUS_SMARTCARD_NO_CARD_UNLOCK             1652     
#define IDS_STATUS_SMARTCARD_NO_KEY_CONTAINER_UNLOCK    1653
#define IDS_STATUS_SMARTCARD_NO_CERTIFICATE_UNLOCK      1654
#define IDS_STATUS_SMARTCARD_NO_KEYSET_UNLOCK           1655
#define IDS_STATUS_SMARTCARD_IO_ERROR_UNLOCK            1656    
#define IDS_STATUS_SMARTCARD_CERT_EXPIRED_UNLOCK        1657
#define IDS_STATUS_SMARTCARD_CERT_REVOKED_UNLOCK        1658
#define IDS_STATUS_ISSUING_CA_UNTRUSTED_UNLOCK          1659
#define IDS_STATUS_REVOCATION_OFFLINE_C_UNLOCK          1660
#define IDS_STATUS_PKINIT_CLIENT_FAILURE_UNLOCK         1661

#define IDS_ADMIN_ACCOUNT_NAME          1700
#define IDS_LOGON_LOG_FULL_ADMIN        1701
#define IDS_LOGON_LOG_FULL              1702
#define IDS_DEFAULT_DESKTOP             1703

#define IDS_MOREOPTIONS                 1800
#define IDS_LESSOPTIONS                 1801
#define IDS_PIN                         1802

#define IDS_PRESSCAD                    1810
#define IDS_PRESSCADORSMARTCARD         1811

#define IDS_PRESSCAD_FACENAME           1812
#define IDS_PRESSCAD_FACESIZE           1813

#define IDS_RELEASE_TEXT                1814
#define IDS_RELEASE_FACENAME            1815
#define IDS_RELEASE_FACESIZE            1816

#define IDS_COPYRIGHT_TEXT              1818
#define IDS_COPYRIGHT_FACENAME          1819
#define IDS_COPYRIGHT_FACESIZE          1820

#define IDS_THISCOMPUTER                1821

#define IDS_COMPLEX_PASSWORD_SPEC       1824
#define IDS_PASSWORD_TOO_LONG           1825
#define IDS_ACCOUNT_EXPIRED2            1826
#define IDS_SMARTCARD_REQUIRED          1827

#define IDS_PRESSCAE                    1828
#define IDS_PRESSCAEORSMARTCARD         1829

//
// These are the domain modifiers.  Their order is dependent on
// the DOMAIN_CACHE_TYPE in domain.h.  Do not change the
// order without changing that header
//

#define IDS_DTYPE_UPNDOMAIN             1850
#define IDS_DTYPE_THISCOMPUTER          1851
#define IDS_DTYPE_NT4DOMAIN             1852
#define IDS_DTYPE_NT5DOMAIN             1853
#define IDS_DTYPE_MITDOMAIN             1854
#define IDS_DTYPE_MITXDOMAIN            1855
#define IDS_DTYPE_NETPROVIDER           1856

//
// Icons
//


#define IDI_NODC_ICON                   13
#define IDI_STLOGOFF                    21
#define IDI_SHUTDOWN                    22


//
// EMAIL logon support
//

#define IDS_LOCKED_EMAIL_MESSAGE        1610
#define IDS_LOCKED_EMAIL_NFN_MESSAGE    1611
#define IDS_UNLOCK_FAILED_EMAIL         1612
#define IDS_UNLOCK_FAILED_EMAIL_NFN     1613
#define IDS_LOGON_EMAIL_NAME_NFN_INFO   1614
#define IDS_LOGON_EMAIL_NAME_INFO       1615
#define IDS_LOCKED_NO_USER_MESSAGE      1620

// captions 
#define IDS_CAPTION_LOCKED_DIALOG       1616
#define IDS_CAPTION_WELCOME_DIALOG      1617
#define IDS_CAPTION_LOGON_DIALOG        1618
#define IDS_CAPTION_UNLOCK_DIALOG       1619


#define IDS_MULTIUSER_CONNECT_FAILED                   2000
#define IDS_MULTIUSER_CONNECT_NOT_SUPPORTED            2001
#define IDS_MULTIUSER_UNEXPECTED_CONNECT_FAILURE       2002
#define IDS_MULTIUSER_DISCONNECT_FAILED                2003
#define IDS_MULTIUSER_UNEXPECTED_DISCONNECT_FAILURE    2004
#define IDS_MULTIUSER_DISCONNECT_CAPTION               2005
#define IDS_MULTIUSER_DISCONNECT_TEXT                  2006
#define IDS_MULTIUSER_CALLBACK_ROVING_CAPTION          2007
#define IDS_MULTIUSER_CALLBACK_FIXED_CAPTION           2008
#define IDS_MULTIUSER_LOGON_DISABLED                   2009
#define IDS_MULTIUSER_NO_CALLBACK_NUMBER               2010
#define IDS_MULTIUSER_NO_CALLBACK_NUMBER_MESSAGE       2011
#define IDS_MULTIUSER_WINSTATION_ACCESS_DENIED         2012
#define IDS_MULTIUSER_ENCRYPTION_LEVEL_REQUIRED        2013
// #define IDS_MULTIUSER_DISCONNECT_OPTION                2014
#define IDS_MULTIUSER_INVALID_DOMAIN_ADMIN             2015
#define IDS_MULTIUSER_NFR_CAPTION                      2016
#define IDS_MULTIUSER_ADMINGROUP                       2017
#define IDS_MULTIUSER_SYSTEMGROUP                      2018

// Shutdown strings
#define IDS_SHUTDOWN_NAME                              8000
#define IDS_SHUTDOWN_DESC                              8001
#define IDS_RESTART_NAME                               8002
#define IDS_RESTART_DESC                               8003
#define IDS_SLEEP_NAME                                 8004
#define IDS_SLEEP_DESC                                 8005
#define IDS_SLEEP2_NAME                                8006
#define IDS_SLEEP2_DESC                                8007
#define IDS_HIBERNATE_NAME                             8008
#define IDS_HIBERNATE_DESC                             8009
#define IDS_LOGOFF_NAME                                8010
#define IDS_LOGOFF_DESC                                8011
#define IDS_RESTARTDOS_NAME                            8012
#define IDS_RESTARTDOS_DESC                            8013
#define IDS_DISCONNECT_NAME                            8014
#define IDS_DISCONNECT_DESC                            8015

// Build on NT message
#define IDS_BUILTONNT_TEXT                             8100
#define IDS_BUILTONNT_FACENAME                         8101
#define IDS_BUILTONNT_FACESIZE                         8102

// Welcome screen help messages
#define IDS_CADHELP                                    8200
#define IDS_CADSMARTCARDHELP                           8201

#define IDS_INSERTCARDORSAS_UNLOCK                     8202

// #define unused                                      8203
// #define unused                                      8204
// #define unused                                      8205
// #define unused                                      8206

#define IDS_COULDNTSETQUOTAS                           8207
#define IDS_QUOTAEXHAUSTED                             8208
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\shtdndlg.c ===
#include "msgina.h"

// This gives me a yucky feeling, but we
// use CRT all over the place in gina.
#include <stdio.h>

#include <windowsx.h>
#include <regstr.h>
#include <help.h>

#include <Wtsapi32.h>

#include "shtdnp.h"


#define MAX_SHTDN_OPTIONS               8

typedef struct _SHUTDOWNOPTION
{
    DWORD dwOption;
    TCHAR szName[MAX_REASON_NAME_LEN + 1];
    TCHAR szDesc[MAX_REASON_DESC_LEN + 1];
} SHUTDOWNOPTION, *PSHUTDOWNOPTION;


typedef struct _SHUTDOWNDLGDATA
{
    SHUTDOWNOPTION rgShutdownOptions[MAX_SHTDN_OPTIONS];
    int cShutdownOptions;
    DWORD dwItemSelect;

    REASONDATA ReasonData;
        
    BOOL fShowReasons;

    DWORD dwFlags;
    BOOL fEndDialogOnActivate;
} SHUTDOWNDLGDATA, *PSHUTDOWNDLGDATA;

// Internal function prototypes
void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic);

BOOL LoadShutdownOptionStrings(int idStringName, int idStringDesc,
                               PSHUTDOWNOPTION pOption);

BOOL BuildShutdownOptionArray(DWORD dwItems, LPCTSTR szUsername,
                              PSHUTDOWNDLGDATA pdata);

BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

DWORD GetOptionSelection(HWND hwndCombo);

void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic);

BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

BOOL Shutdown_OnEraseBkgnd(HWND hwnd, HDC hdc);

INT_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
INT_PTR DialogItemToGinaResult(DWORD dwDialogItem, BOOL fAutoPowerdown);


BOOL LoadShutdownOptionStrings(int idStringName, int idStringDesc,
                               PSHUTDOWNOPTION pOption)
{
    BOOL fSuccess = (LoadString(hDllInstance, idStringName, pOption->szName,
        ARRAYSIZE(pOption->szName)) != 0);

    fSuccess &= (LoadString(hDllInstance, idStringDesc, pOption->szDesc,
        ARRAYSIZE(pOption->szDesc)) != 0);

    return fSuccess;
}

BOOL BuildShutdownOptionArray(DWORD dwItems, LPCTSTR szUsername,
                              PSHUTDOWNDLGDATA pdata)
{
    BOOL fSuccess = TRUE;
    pdata->cShutdownOptions = 0;

    if (dwItems & SHTDN_LOGOFF)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_LOGOFF;

        // Note that logoff is a special case: format using a user name ala
        // "log off <username>".
        fSuccess &= LoadShutdownOptionStrings(IDS_LOGOFF_NAME,
            IDS_LOGOFF_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions]));

        if (fSuccess)
        {
            TCHAR szTemp[ARRAYSIZE(pdata->rgShutdownOptions[pdata->cShutdownOptions].szName)];
            BOOL fFormatSuccessful = FALSE;
    
            // If we have a username, format the "log off <username>" string
            if (szUsername != NULL)
            {
                fFormatSuccessful = (_snwprintf(szTemp, ARRAYSIZE(szTemp),
                    pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                    szUsername) > 0);
            }

            // If we didn't have a username or if the buffer got overrun, just use
            // "log off "
            if (!fFormatSuccessful)
            {
                fFormatSuccessful = (_snwprintf(szTemp, ARRAYSIZE(szTemp),
                    pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                    TEXT("")) > 0);
            }

            // Now we have the real logoff title in szTemp; copy is back
            if (fFormatSuccessful)
            {
                lstrcpy(pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                    szTemp);
            }
            else
            {
                // Should never happen! There should always be enough room in szTemp to hold
                // "log off ".
                ASSERT(FALSE);
            }

            // Success!
            pdata->cShutdownOptions ++;
        }

    }

    if (dwItems & SHTDN_SHUTDOWN)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SHUTDOWN;
        fSuccess &= LoadShutdownOptionStrings(IDS_SHUTDOWN_NAME,
            IDS_SHUTDOWN_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_RESTART)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_RESTART;
        fSuccess &= LoadShutdownOptionStrings(IDS_RESTART_NAME,
            IDS_RESTART_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_RESTART_DOS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_RESTART_DOS;
        fSuccess &= LoadShutdownOptionStrings(IDS_RESTARTDOS_NAME,
            IDS_RESTARTDOS_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_SLEEP)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SLEEP;
        fSuccess &= LoadShutdownOptionStrings(IDS_SLEEP_NAME,
            IDS_SLEEP_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_SLEEP2)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SLEEP2;
        fSuccess &= LoadShutdownOptionStrings(IDS_SLEEP2_NAME,
            IDS_SLEEP2_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_HIBERNATE)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_HIBERNATE;
        fSuccess &= LoadShutdownOptionStrings(IDS_HIBERNATE_NAME,
            IDS_HIBERNATE_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    if (dwItems & SHTDN_DISCONNECT)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_DISCONNECT;
        fSuccess &= LoadShutdownOptionStrings(IDS_DISCONNECT_NAME,
            IDS_DISCONNECT_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++]));
    }

    return fSuccess;
}


void DisableReasons( HWND hwnd, BOOL fEnable ) {
    EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_COMBO), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT), fEnable);
	EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_CHECK), fEnable);
}

BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) lParam;
    HWND hwndCombo;
    int iOption;
    int iComboItem;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) lParam);

    if (!(pdata->dwFlags & SHTDN_NOBRANDINGBITMAP))
    {
        // Move all our controls down so the branding fits
        SizeForBranding(hwnd, FALSE);
    }

    // Hide the help button and move over OK and Cancel if applicable
    if (pdata->dwFlags & SHTDN_NOHELP)
    {
        static UINT rgidNoHelp[] = {IDOK, IDCANCEL};
        RECT rc1, rc2;
        int dx;
        HWND hwndHelp = GetDlgItem(hwnd, IDHELP);

        EnableWindow(hwndHelp, FALSE);
        ShowWindow(hwndHelp, SW_HIDE);

        GetWindowRect(hwndHelp, &rc1);
        GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rc2);

        dx = rc1.left - rc2.left;

        MoveControls(hwnd, rgidNoHelp, ARRAYSIZE(rgidNoHelp), dx, 0, FALSE);
    }

    // Add the items specified to the combo box
    hwndCombo = GetDlgItem(hwnd, IDC_EXITOPTIONS_COMBO);

    for (iOption = 0; iOption < pdata->cShutdownOptions; iOption ++)
    {
        // Add the option
        iComboItem = ComboBox_AddString(hwndCombo,
            pdata->rgShutdownOptions[iOption].szName);

        if (iComboItem != (int) CB_ERR)
        {
            // Store a pointer to the option
            ComboBox_SetItemData(hwndCombo, iComboItem,
                &(pdata->rgShutdownOptions[iOption]));

            // See if we should select this option
            if (pdata->rgShutdownOptions[iOption].dwOption == pdata->dwItemSelect)
            {
                ComboBox_SetCurSel(hwndCombo, iComboItem);
            }
        }
    }

    // If we don't have a selection in the combo, do a default selection
    if (ComboBox_GetCurSel(hwndCombo) == CB_ERR)
    {
        ComboBox_SetCurSel(hwndCombo, 0);
    }

    SetShutdownOptionDescription(hwndCombo,
        GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION));


    // Set up the reason data.
    if( pdata->fShowReasons )
    {
		DWORD	iOption;
		DWORD	iComboItem;
		HWND	hwndCombo;
		HWND	hwndCheck;
		DWORD	dwCheckState = 0x0;
		
		//
		//	Get the window handles we need.
		//
		hwndCombo = GetDlgItem(hwnd, IDC_EXITREASONS_COMBO);
		hwndCheck = GetDlgItem(hwnd, IDC_EXITREASONS_CHECK);

		//
		//	Set the default to be planned.
		//
		CheckDlgButton(hwnd, IDC_EXITREASONS_CHECK, BST_CHECKED);
		dwCheckState = SHTDN_REASON_FLAG_PLANNED;

		//
		//	Now populate the combo according the current check state.
		//
		for (iOption = 0; iOption < (DWORD)pdata->ReasonData.cReasons; iOption++)
		{
			if(((pdata->ReasonData.rgReasons[iOption]->dwCode) & SHTDN_REASON_FLAG_PLANNED) == dwCheckState)
			{
				iComboItem = ComboBox_AddString(hwndCombo,
					pdata->ReasonData.rgReasons[iOption]->szName);

				if (iComboItem != (int) CB_ERR)
				{
					// Store a pointer to the option
					ComboBox_SetItemData(hwndCombo, iComboItem,
						pdata->ReasonData.rgReasons[iOption]);

					// See if we should select this option
					if (pdata->ReasonData.rgReasons[iOption]->dwCode == pdata->ReasonData.dwReasonSelect)
					{
						ComboBox_SetCurSel(hwndCombo, iComboItem);
					}
				}
			}
		}

		// If we don't have a selection in the combo, do a default selection
		if (ComboBox_GetCount(hwndCombo) && (ComboBox_GetCurSel(hwndCombo) == CB_ERR))
		{
			PREASON pr = (PREASON)ComboBox_GetItemData(hwndCombo, 0);
			if(pr != (PREASON)CB_ERR)
			{
				pdata->ReasonData.dwReasonSelect = pr->dwCode;
				ComboBox_SetCurSel(hwndCombo, 0);
			}
		}

        SetReasonDescription(hwndCombo,
            GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION));

        // Disable the reasons if applicable
	    DisableReasons( hwnd, pdata->dwItemSelect & (SHTDN_SHUTDOWN | SHTDN_RESTART));

        // Disable the ok button if a comment is required.
        EnableWindow(GetDlgItem(hwnd, IDOK), !( pdata->dwItemSelect & (SHTDN_SHUTDOWN | SHTDN_RESTART)) || !ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ));

        // Setup the comment box.
        // We must fix the maximum characters.
        SendMessage( GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT), EM_LIMITTEXT, (WPARAM)MAX_REASON_COMMENT_LEN, (LPARAM)0 );
    }
    else {
        // Hide the reasons, move the buttons up and shrink the dialog.
        HWND hwndCtl;

		hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_CHECK);
		EnableWindow(hwndCtl, FALSE);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_COMBO);
        EnableWindow(hwndCtl, FALSE);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT);
        EnableWindow(hwndCtl, FALSE);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_HEADER);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_STATIC_REASON_OPTION);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_STATIC_REASON_COMMENT);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_RESTARTEVENTTRACKER_GRPBX);
        ShowWindow(hwndCtl, SW_HIDE);

        // Move controls and shrink window
        {
            static UINT rgid[] = {IDOK, IDCANCEL, IDHELP};
            RECT rc, rc1, rc2;
            int dy;
            HWND hwndHelp = GetDlgItem(hwnd, IDHELP);

            GetWindowRect(hwndHelp, &rc1);
            GetWindowRect(GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION), &rc2);

            dy = rc1.top - rc2.bottom;

            MoveControls(hwnd, rgid, ARRAYSIZE(rgid), 0, -dy, FALSE);

            // Shrink
            GetWindowRect(hwnd, &rc);
            SetWindowPos(hwnd, NULL, 0, 0, rc.right - rc.left, ( rc.bottom - rc.top ) - dy, SWP_NOZORDER|SWP_NOMOVE);

        }
    }

    // If we get an activate message, dismiss the dialog, since we just lost
    // focus
    pdata->fEndDialogOnActivate = TRUE;

    CentreWindow(hwnd);

    return TRUE;
}

DWORD GetOptionSelection(HWND hwndCombo)
{
    DWORD dwResult;
    PSHUTDOWNOPTION pOption;
    int iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != (int) CB_ERR)
    {
        pOption = (PSHUTDOWNOPTION) ComboBox_GetItemData(hwndCombo, iItem);
        dwResult = pOption->dwOption;
    }
    else
    {
        dwResult = SHTDN_NONE;
    }

    return dwResult;
}

void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic)
{
    int iItem;
    PSHUTDOWNOPTION pOption;

    iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != CB_ERR)
    {
        pOption = (PSHUTDOWNOPTION) ComboBox_GetItemData(hwndCombo, iItem);

        SetWindowText(hwndStatic, pOption->szDesc);
    }
}

BOOL WillCauseShutdown(DWORD dwOption)
{
    switch (dwOption)
    {
    case SHTDN_SHUTDOWN:
    case SHTDN_RESTART:
    case SHTDN_RESTART_DOS:
    case SHTDN_HIBERNATE:
    case SHTDN_SLEEP:
    case SHTDN_SLEEP2:
        return TRUE;
        break;

    case SHTDN_LOGOFF:
    case SHTDN_DISCONNECT:
    default:
        break;
    }

    return FALSE;
}

BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL fHandled = FALSE;
    DWORD dwDlgResult;
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA)
        GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (id)
    {
    case IDOK:
        if (codeNotify == BN_CLICKED)
        {
            pdata->ReasonData.dwReasonSelect = 0;
            dwDlgResult = GetOptionSelection(GetDlgItem(hwnd, IDC_EXITOPTIONS_COMBO));

            // Are the reasons enabled?
            if( pdata->fShowReasons && ( dwDlgResult & (SHTDN_SHUTDOWN | SHTDN_RESTART))) {
                pdata->ReasonData.dwReasonSelect = GetReasonSelection(GetDlgItem(hwnd, IDC_EXITREASONS_COMBO));
                if (pdata->ReasonData.dwReasonSelect == SHTDN_REASON_UNKNOWN ) {
                    break;
                }
                // Fill the comment
                pdata->ReasonData.cCommentLen = GetWindowText( GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT), pdata->ReasonData.szComment, MAX_REASON_COMMENT_LEN );
            }
            
            if (dwDlgResult != SHTDN_NONE)
            {
                pdata->fEndDialogOnActivate = FALSE;            
                fHandled = TRUE;
                EndDialog(hwnd, (int) dwDlgResult);
            }
        }
        break;
    case IDCANCEL:
        if (codeNotify == BN_CLICKED)
        {
            pdata->fEndDialogOnActivate = FALSE;
            EndDialog(hwnd, (int) SHTDN_NONE);
            fHandled = TRUE;
        }
        break;
    case IDC_EXITOPTIONS_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetShutdownOptionDescription(hwndCtl,
                GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION));
            // Does this change the status of the reasons.            
            if( pdata->fShowReasons ) {
                BOOL fEnabled = GetOptionSelection(hwndCtl) & (SHTDN_SHUTDOWN | SHTDN_RESTART);
                DisableReasons( hwnd, fEnabled );
                
                // Make sure that we have a comment if we need one.
                if( fEnabled ) {    
                    EnableWindow(GetDlgItem(hwnd, IDOK), !(ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ) && ( pdata->ReasonData.cCommentLen == 0 )));
                }
                else {
                    EnableWindow(GetDlgItem(hwnd, IDOK), TRUE);
                }
            }
                
            fHandled = TRUE;
        }
        break;
	case IDC_EXITREASONS_CHECK:
		//
		//	We assume that if the user can click on the check button.
		//	we are required to show the shutdown reasons.
		//
		if (codeNotify == BN_CLICKED)
		{
			DWORD	iOption;
			DWORD	iComboItem;
			HWND	hwndCombo;
			HWND	hwndCheck;
			DWORD	dwCheckState = 0x0;
			
			//
			//	Get the window handles we need.
			//
			hwndCombo = GetDlgItem(hwnd, IDC_EXITREASONS_COMBO);
			hwndCheck = GetDlgItem(hwnd, IDC_EXITREASONS_CHECK);

			//
			//	Set the planned flag according to the check state.
			//
			if ( BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_EXITREASONS_CHECK) )
				dwCheckState = SHTDN_REASON_FLAG_PLANNED;

			//
			//	Remove all items from combo
			//
			while (ComboBox_GetCount(hwndCombo))
				ComboBox_DeleteString(hwndCombo, 0);

			//
			//	Now populate the combo according the current check state.
			//
			for (iOption = 0; iOption < (DWORD)pdata->ReasonData.cReasons; iOption ++)
			{
				if(((pdata->ReasonData.rgReasons[iOption]->dwCode) & SHTDN_REASON_FLAG_PLANNED) == dwCheckState)
				{
					iComboItem = ComboBox_AddString(hwndCombo,
						pdata->ReasonData.rgReasons[iOption]->szName);

					if (iComboItem != (int) CB_ERR)
					{
						// Store a pointer to the option
						ComboBox_SetItemData(hwndCombo, iComboItem,
							pdata->ReasonData.rgReasons[iOption]);

						// See if we should select this option
						if (pdata->ReasonData.rgReasons[iOption]->dwCode == pdata->ReasonData.dwReasonSelect)
						{
							ComboBox_SetCurSel(hwndCombo, iComboItem);
						}
					}
				}
			}

			// If we don't have a selection in the combo, do a default selection
			if (ComboBox_GetCount(hwndCombo) && (ComboBox_GetCurSel(hwndCombo) == CB_ERR))
			{
				PREASON pr = (PREASON)ComboBox_GetItemData(hwndCombo, 0);
				if(pr != (PREASON)CB_ERR)
				{
					pdata->ReasonData.dwReasonSelect = pr->dwCode;
					ComboBox_SetCurSel(hwndCombo, 0);
				}
			}

			SetReasonDescription(hwndCombo,
				GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION));

			// Disable the ok button if a comment is required.
			EnableWindow(GetDlgItem(hwnd, IDOK),  !(ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ) && ( pdata->ReasonData.cCommentLen == 0 )));
		}
		break;
    case IDC_EXITREASONS_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetReasonDescription(hwndCtl,
                GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION));
            pdata->ReasonData.dwReasonSelect = GetReasonSelection(hwndCtl);
            EnableWindow(GetDlgItem(hwnd, IDOK), !(ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ) && ( pdata->ReasonData.cCommentLen == 0 )));
        
            fHandled = TRUE;
        }
        break;
    case IDC_EXITREASONS_COMMENT:
        if( codeNotify == EN_CHANGE) 
        {
            pdata->ReasonData.cCommentLen = GetWindowTextLength( GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT));
            EnableWindow(GetDlgItem(hwnd, IDOK), !(ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ) && ( pdata->ReasonData.cCommentLen == 0 )));

            fHandled = TRUE;
        }
        break;
    case IDHELP:
        if (codeNotify == BN_CLICKED)
        {
            WinHelp(hwnd, TEXT("windows.hlp>proc4"), HELP_CONTEXT, (DWORD) IDH_TRAY_SHUTDOWN_HELP);
        }
        break;
    }
    return fHandled;
}

BOOL Shutdown_OnEraseBkgnd(HWND hwnd, HDC hdc)
{
    BOOL fRet;
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // Draw the branding bitmap
    if (!(pdata->dwFlags & SHTDN_NOBRANDINGBITMAP))
    {
        fRet = PaintBranding(hwnd, hdc, 0, FALSE, FALSE, COLOR_BTNFACE);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

INT_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Shutdown_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Shutdown_OnCommand);
        HANDLE_MSG(hwnd, WM_ERASEBKGND, Shutdown_OnEraseBkgnd);
        case WLX_WM_SAS:
        {
            // If this is someone hitting C-A-D, swallow it.
            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
                return TRUE;
            // Other SAS's (like timeout), return FALSE and let winlogon
            // deal with it.
            return FALSE;
        }
        break;
        case WM_INITMENUPOPUP:
        {
            EnableMenuItem((HMENU)wParam, SC_MOVE, MF_BYCOMMAND|MF_GRAYED);
        }
        break;
        case WM_SYSCOMMAND:
            // Blow off moves (only really needed for 32bit land).
            if ((wParam & ~0x0F) == SC_MOVE)
                return TRUE;
            break;
        case WM_ACTIVATE:
            // If we're loosing the activation for some other reason than
            // the user click OK/CANCEL then bail.
            if (LOWORD(wParam) == WA_INACTIVE)
            {
                PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

                if (pdata->fEndDialogOnActivate)
                {
                    pdata->fEndDialogOnActivate = FALSE;
                    EndDialog(hwnd, SHTDN_NONE);
                }
            }
            break;
    }

    return FALSE;
}

/****************************************************************************
 ShutdownDialogEx
 --------------

  Launches the shutdown dialog.

  If hWlx and pfnWlxDialogBoxParam are non-null, pfnWlxDialogBoxParam will
  be used to launch the dialog box so we can intelligently respond to WLX
  messages. Only if WinLogon is the caller should this be done.

  Other flags are listed in shtdndlg.h.
****************************************************************************/
DWORD ShutdownDialogEx(HWND hwndParent, DWORD dwItems, DWORD dwItemSelect,
                     LPCTSTR szUsername, DWORD dwFlags, HANDLE hWlx,
                     PWLX_DIALOG_BOX_PARAM pfnWlxDialogBoxParam,
                     DWORD dwReasonSelect, PDWORD pdwReasonResult )
{
    // Array of shutdown options - the dialog data
    PSHUTDOWNDLGDATA pData;
    DWORD dwResult;

    pData = (PSHUTDOWNDLGDATA)LocalAlloc(LMEM_FIXED, sizeof(*pData));
    if (pData == NULL)
    {
        return SHTDN_NONE;
    }

    // Set the flags
    pData->dwFlags = dwFlags;

    // Set the initially selected item
    pData->dwItemSelect = dwItemSelect;
    pData->ReasonData.dwReasonSelect = dwReasonSelect;
    pData->ReasonData.rgReasons = 0;
    pData->ReasonData.cReasons = 0;
    pData->ReasonData.cReasonCapacity = 0;

    // Read in the strings for the shutdown option names and descriptions
    if (BuildShutdownOptionArray(dwItems, szUsername, pData))
    {
        HKEY            hKey = 0;
        DWORD           rc;
        DWORD           ShowReasonUI = 0x0;
        DWORD           ValueSize = sizeof (DWORD);
		BOOL			fFromPolicy = FALSE;

        // See if we should display the shutdown reason dialog
        pData->fShowReasons = FALSE;
        pData->ReasonData.szComment[ 0 ] = 0;
        pData->ReasonData.cCommentLen = 0;

		rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RELIABILITY_POLICY_KEY, 0, KEY_ALL_ACCESS, &hKey);
		if(rc == ERROR_SUCCESS)
		{
			rc = RegQueryValueEx (hKey, RELIABILITY_POLICY_SHUTDOWNREASONUI, NULL, NULL, (UCHAR *)&ShowReasonUI, &ValueSize);
			RegCloseKey (hKey);
			hKey = 0;

			//
			//	Now check the sku to decide whether we should show the dialog
			//
			if(rc == ERROR_SUCCESS)
			{
				OSVERSIONINFOEX osVersionInfoEx;

				osVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

				if(ShowReasonUI == POLICY_SHOWREASONUI_NEVER || ShowReasonUI == POLICY_SHOWREASONUI_ALWAYS)
				{
					//do nothing.
				}
				else if(GetVersionEx( (LPOSVERSIONINFOW) &osVersionInfoEx ))
				{
					//
					//	if ShowReasonUI is anything other than 2 or 3, we think it is 0.
					//
					switch ( osVersionInfoEx.wProductType )
					{
						case VER_NT_WORKSTATION:
							if(ShowReasonUI == POLICY_SHOWREASONUI_WORKSTATIONONLY)
								ShowReasonUI = 1;
							else
								ShowReasonUI = 0;
							break;
						default:
							if(ShowReasonUI == POLICY_SHOWREASONUI_SERVERONLY)
								ShowReasonUI = 1;
							else
								ShowReasonUI = 0;
							break;
					}
				}
				else
				{
					//
					//	If we fail, assume not showing.
					//
					ShowReasonUI = 0;
				}
			}
		}

		if(rc != ERROR_SUCCESS)
		{
			rc = RegCreateKeyEx (HKEY_LOCAL_MACHINE, REGSTR_PATH_RELIABILITY, 0, NULL, REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS, NULL, &hKey, NULL);
		}
		else
		{
			fFromPolicy = TRUE;
		}

        if (rc == ERROR_SUCCESS) {
			if(!fFromPolicy)
				rc = RegQueryValueEx (hKey, REGSTR_VAL_SHOWREASONUI, NULL, NULL, (UCHAR *)&ShowReasonUI, &ValueSize);

            if ( (rc == ERROR_SUCCESS) && (ShowReasonUI) ) {
                // See if any of the shutdown options will cause an actual shutdown.  If not then don't show the reasons at all.
                int i;
                for( i = 0; i < pData->cShutdownOptions; ++i ) {
                    pData->fShowReasons |= pData->rgShutdownOptions[ i ].dwOption & SHTDN_RESTART;
                    pData->fShowReasons |= pData->rgShutdownOptions[ i ].dwOption & SHTDN_SHUTDOWN;
                }

                // Read in the strings for the shutdown option names and descriptions
                if( pData->fShowReasons && BuildReasonArray( &pData->ReasonData, TRUE, FALSE )) {
                    // Set the initial reason to display.
                    if( dwReasonSelect >= ( DWORD )pData->ReasonData.cReasons ) {
                        dwReasonSelect = 0;
                    }
                }
                else {
                    pData->fShowReasons = FALSE;
                }
            }
        }


        // Display the dialog and return the user's selection

       // ..if the caller wants, use a Wlx dialog box function
        if ((hWlx != NULL) && (pfnWlxDialogBoxParam != NULL))
        {
            // Caller must be winlogon - they want us to display the
            // shutdown dialog using a Wlx function
            dwResult = (DWORD) pfnWlxDialogBoxParam(hWlx,
                hDllInstance, MAKEINTRESOURCE(IDD_EXITWINDOWS_DIALOG),
                hwndParent, Shutdown_DialogProc, (LPARAM) pData);
        }
        else
        {
            // Use standard dialog box
            dwResult = (DWORD) DialogBoxParam(hDllInstance, MAKEINTRESOURCE(IDD_EXITWINDOWS_DIALOG), hwndParent,
                Shutdown_DialogProc, (LPARAM) pData);
        }

        // Record shutdown reasons
        if( dwResult & (SHTDN_SHUTDOWN | SHTDN_RESTART)) {

            if( pData->fShowReasons ) {
                SHUTDOWN_REASON sr;
                sr.cbSize = sizeof(SHUTDOWN_REASON);
                sr.uFlags = dwResult == SHTDN_SHUTDOWN ? EWX_SHUTDOWN : EWX_REBOOT;
                sr.dwReasonCode = pData->ReasonData.dwReasonSelect;
                sr.dwEventType = SR_EVENT_INITIATE_CLEAN; 
                sr.lpszComment = pData->ReasonData.szComment;
                RecordShutdownReason(&sr);
            }
        }
        if( hKey != 0 ) 
        {
            RegCloseKey (hKey);
        }
    }
    else
    {
        dwResult = SHTDN_NONE;
    }

    DestroyReasons( &pData->ReasonData );

    LocalFree(pData);

    return dwResult;
}

DWORD ShutdownDialog(HWND hwndParent, DWORD dwItems, DWORD dwItemSelect,
                     LPCTSTR szUsername, DWORD dwFlags, HANDLE hWlx,
                     PWLX_DIALOG_BOX_PARAM pfnWlxDialogBoxParam )
{
    DWORD dummy;
    return ShutdownDialogEx(hwndParent, dwItems, dwItemSelect,
                     szUsername, dwFlags, hWlx,
                     pfnWlxDialogBoxParam,
                     0, &dummy );
}

INT_PTR DialogItemToGinaResult(DWORD dwDialogItem, BOOL fAutoPowerdown)
{
    INT_PTR Result;

    // Map the return value from ShutdownDialog into
    // our internal shutdown values
    switch (dwDialogItem)
    {
    case SHTDN_LOGOFF:
        Result = MSGINA_DLG_USER_LOGOFF;
        break;
    case SHTDN_SHUTDOWN:
        if (fAutoPowerdown)
            Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_POWEROFF_FLAG;
        else
            Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SHUTDOWN_FLAG;
        break;
    case SHTDN_RESTART:
        Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_REBOOT_FLAG;
        break;
    case SHTDN_SLEEP:
        Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SLEEP_FLAG;
        break;
    case SHTDN_SLEEP2:
        Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SLEEP2_FLAG;
        break;
    case SHTDN_HIBERNATE:
        Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_HIBERNATE_FLAG;
        break;
    case SHTDN_DISCONNECT:
        Result = MSGINA_DLG_DISCONNECT;
        break;
    default:
        // Cancel click, or else invalid item was selected
        Result = MSGINA_DLG_FAILURE;
        break;
    }

    return Result;
}

BOOL GetBoolPolicy(HKEY hkeyCurrentUser, LPCTSTR pszPolicyKey, LPCTSTR pszPolicyValue, BOOL fDefault)
{
    HKEY hkeyMachinePolicy = NULL;
    HKEY hkeyUserPolicy = NULL;
    BOOL fPolicy = fDefault;
    BOOL fMachinePolicyRead = FALSE;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbData;
    LRESULT res;

    // Check machine policy first
    res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszPolicyKey, 0, KEY_READ, &hkeyMachinePolicy); 
    if (ERROR_SUCCESS == res)
    {
        cbData = sizeof(dwValue);
              
        res = RegQueryValueEx(hkeyMachinePolicy, pszPolicyValue, 0, &dwType, (LPBYTE)&dwValue, &cbData);
        
        if (ERROR_SUCCESS == res)
        {
            fPolicy = (dwValue != 0);
            fMachinePolicyRead = TRUE;
        }

        RegCloseKey(hkeyMachinePolicy);
    }

    if (!fMachinePolicyRead)
    {
        // Machine policy check failed, check user policy
        res = RegOpenKeyEx(hkeyCurrentUser, pszPolicyKey, 0, KEY_READ, &hkeyUserPolicy); 
        if (ERROR_SUCCESS == res)
        {
            cbData = sizeof(dwValue);
          
            res = RegQueryValueEx(hkeyUserPolicy, pszPolicyValue, 0, &dwType, (LPBYTE)&dwValue, &cbData);

            if (ERROR_SUCCESS == res)
            {
                fPolicy = (dwValue != 0);
            }

            RegCloseKey(hkeyUserPolicy);
        }
    }

    return fPolicy;
}

DWORD GetAllowedShutdownOptions(HKEY hkeyCurrentUser, HANDLE UserToken, BOOL fRemoteSession)
{
    DWORD dwItemsToAdd = 0;
    BOOL fNoDisconnect = TRUE;

    // Does computer automatically shut off on shutdown
    BOOL fAutoPowerdown = FALSE;
    SYSTEM_POWER_CAPABILITIES spc = {0};

    // See if we should add Logoff and/or disconnect to the dialog
    // - don't even try if we don't have a current user!

    BOOL fNoLogoff = GetBoolPolicy(hkeyCurrentUser, EXPLORER_POLICY_KEY, NOLOGOFF, FALSE);
    
    if (!fNoLogoff)
    {
        dwItemsToAdd |= SHTDN_LOGOFF;
    }

    // Do not allow disconnects by default. Allow disconnects when either this is
    // a remote session or terminal server is enabled on Workstation (PTS).

    {
        
      // The disconnect menu can be disabled by policy. Respect that. It should
      // also be removed in the friendly UI case WITHOUT multiple users.
        fNoDisconnect = ( IsActiveConsoleSession() || 
                          GetBoolPolicy(hkeyCurrentUser, EXPLORER_POLICY_KEY, NODISCONNECT, FALSE) ||
                          (ShellIsFriendlyUIActive() && !ShellIsMultipleUsersEnabled()) );  
    }
   
   
    if (!fNoDisconnect)
    {
       dwItemsToAdd |= SHTDN_DISCONNECT;
    }

    // All items besides logoff and disconnect require SE_SHUTDOWN
    if (TestUserPrivilege(UserToken, SE_SHUTDOWN_PRIVILEGE))
    {
        // Add shutdown and restart
        dwItemsToAdd |= SHTDN_RESTART | SHTDN_SHUTDOWN;

        NtPowerInformation (SystemPowerCapabilities,
                            NULL, 0, &spc, sizeof(spc));

        if (spc.SystemS5)
            fAutoPowerdown = TRUE;
        else
            fAutoPowerdown = GetProfileInt(APPLICATION_NAME, POWER_DOWN_AFTER_SHUTDOWN, 0);

        // Is hibernate option supported?
        //

        if ((spc.SystemS4 && spc.HiberFilePresent))
        {
            dwItemsToAdd |= SHTDN_HIBERNATE;
        }

        //
        // If one of the SystemS* values is true, then the machine
        // has ACPI suspend support.
        //

        if (spc.SystemS1 || spc.SystemS2 || spc.SystemS3)
        {
            HKEY hKey;
            DWORD dwAdvSuspend = 0;
            DWORD dwType, dwSize;

            // Check if we should offer advanced suspend options

            if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power"),
                              0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {
                dwSize = sizeof(dwAdvSuspend);
                RegQueryValueEx (hKey, TEXT("Shutdown"), NULL, &dwType,
                                     (LPBYTE) &dwAdvSuspend, &dwSize);

                RegCloseKey (hKey);
            }


            if (dwAdvSuspend != 0)
            {
                dwItemsToAdd |= SHTDN_SLEEP2 | SHTDN_SLEEP;
            }
            else
            {
                // Only basic suspend support
                dwItemsToAdd |= SHTDN_SLEEP;
            }
        }
    }

    return dwItemsToAdd;
}

// Helper function for calling ShutdownDialog within winlogon
// This function handles all the registry goop, power management
// settings goop, and translating of codes into MSGINA's system
// of shutdown codes and flags. Ack.
INT_PTR WinlogonShutdownDialog(HWND hwndParent, PGLOBALS pGlobals, DWORD dwExcludeItems)
{
    INT_PTR Result = MSGINA_DLG_FAILURE;
    DWORD dwDialogResult = IDCANCEL;
    DWORD dwReasonResult = SHTDN_REASON_UNKNOWN;
    DWORD dwItemsToAdd = 0;
    DWORD dwFlags = 0;

    // Items to add to the shutdown dialog

    if (OpenHKeyCurrentUser(pGlobals))
    {
        dwItemsToAdd = GetAllowedShutdownOptions(pGlobals->UserProcessData.hCurrentUser,
            pGlobals->UserProcessData.UserToken, !g_Console);

        CloseHKeyCurrentUser(pGlobals);
    }


    dwItemsToAdd &= (~dwExcludeItems);

    if (0 != dwItemsToAdd)
    {
        // Item to select
        DWORD dwItemToSelect = 0;

        DWORD dwReasonToSelect = 0;

        // Does computer automatically shut off on shutdown
        BOOL fAutoPowerdown = FALSE;
        SYSTEM_POWER_CAPABILITIES spc = {0};

        NtPowerInformation (SystemPowerCapabilities,
                            NULL, 0, &spc, sizeof(spc));

        if (spc.SystemS5)
            fAutoPowerdown = TRUE;
        else
            fAutoPowerdown = GetProfileInt(APPLICATION_NAME, POWER_DOWN_AFTER_SHUTDOWN, 0);

        // Get the default item from the registry
        if (OpenHKeyCurrentUser(pGlobals))
        {
            LONG lResult;
            HKEY hkeyShutdown;
            DWORD dwType = 0;

            //
            // Check the button which was the users last shutdown selection.
            //
            if (RegCreateKeyEx(pGlobals->UserProcessData.hCurrentUser,
                               SHUTDOWN_SETTING_KEY, 0, 0, 0,
                               KEY_READ | KEY_WRITE,
                               NULL, &hkeyShutdown, &dwType) == ERROR_SUCCESS)
            {
                DWORD cbData = sizeof(dwItemToSelect);

                lResult = RegQueryValueEx(hkeyShutdown,
                                          SHUTDOWN_SETTING,
                                          0,
                                          &dwType,
                                          (LPBYTE) &dwItemToSelect,
                                          &cbData);

                RegQueryValueEx(hkeyShutdown,
                                REASON_SETTING,
                                0,
                                &dwType,
                                (LPBYTE) &dwReasonToSelect,
                                &cbData);

                RegCloseKey(hkeyShutdown);
            }

            CloseHKeyCurrentUser(pGlobals);
        }

        // Figure out what flags to pass
        // for sure no help button
        dwFlags = SHTDN_NOHELP;

        // On terminal server, no branding bitmap either
        if (GetSystemMetrics(SM_REMOTESESSION))
        {
            dwFlags |= SHTDN_NOBRANDINGBITMAP;
        }

        // Call ShutdownDialog
        dwDialogResult = ShutdownDialogEx(hwndParent, dwItemsToAdd,
            dwItemToSelect, pGlobals->UserName, dwFlags, pGlobals->hGlobalWlx,
            pWlxFuncs->WlxDialogBoxParam,
            dwReasonToSelect, &dwReasonResult );

        Result = DialogItemToGinaResult(dwDialogResult, fAutoPowerdown);

        // If everything is okay so far, write the selection to the registry
        // for next time.
        if (Result != MSGINA_DLG_FAILURE)
        {
            HKEY hkeyShutdown;
            DWORD dwDisposition;

            //
            // Get in the correct context before we reference the registry
            //

            if (OpenHKeyCurrentUser(pGlobals))
            {
                if (RegCreateKeyEx(pGlobals->UserProcessData.hCurrentUser, SHUTDOWN_SETTING_KEY, 0, 0, 0,
                                KEY_READ | KEY_WRITE,
                                NULL, &hkeyShutdown, &dwDisposition) == ERROR_SUCCESS)
                {
                    RegSetValueEx(hkeyShutdown, SHUTDOWN_SETTING, 0, REG_DWORD, (LPBYTE)&dwDialogResult, sizeof(dwDialogResult));
                    RegSetValueEx(hkeyShutdown, REASON_SETTING, 0, REG_DWORD, (LPBYTE)&dwReasonResult, sizeof(dwDialogResult));
                    RegCloseKey(hkeyShutdown);
                }

                CloseHKeyCurrentUser(pGlobals);
            }
        }
    }

    return Result;
}

STDAPI_(DWORD) ShellShutdownDialog(HWND hwndParent, LPCTSTR szUnused, DWORD dwExcludeItems)
{
    DWORD dwSelect = 0;
    DWORD dwReasonToSelect = 0;
    DWORD dwDialogResult = 0;
    DWORD dwReasonResult = SHTDN_REASON_UNKNOWN;
    DWORD dwFlags = 0;
    BOOL fTextOnLarge;
    BOOL fTextOnSmall;
    GINAFONTS fonts = {0};

    HKEY hkeyShutdown;
    DWORD dwType;
    DWORD dwDisposition;
    LONG lResult;

    // De facto limit for usernames is 127 due to clunky gina 'encryption'
    TCHAR szUsername[127];
    DWORD dwItems = GetAllowedShutdownOptions(HKEY_CURRENT_USER,
        NULL, (BOOL) GetSystemMetrics(SM_REMOTESESSION));

    dwItems &= (~dwExcludeItems);

    // Create the bitmaps we need
    LoadBrandingImages(TRUE, &fTextOnLarge, &fTextOnSmall);

    CreateFonts(&fonts);
    PaintBitmapText(&fonts, fTextOnLarge, fTextOnSmall);

    // get the User's last selection.
    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, SHUTDOWN_SETTING_KEY,
                0, 0, 0, KEY_READ, NULL, &hkeyShutdown, &dwDisposition);

    if (lResult == ERROR_SUCCESS)
    {
        DWORD cbData = sizeof(dwSelect);
        lResult = RegQueryValueEx(hkeyShutdown, SHUTDOWN_SETTING,
            0, &dwType, (LPBYTE)&dwSelect, &cbData);

        RegQueryValueEx(hkeyShutdown, REASON_SETTING,
            0, &dwType, (LPBYTE)&dwReasonToSelect, &cbData);

        cbData = sizeof(szUsername);

        if (ERROR_SUCCESS != RegQueryValueEx(hkeyShutdown, LOGON_USERNAME_SETTING,
            0, &dwType, (LPBYTE)szUsername, &cbData))
        {
            // Default to "Log off" with no username if this fails.
            *szUsername = 0;
        }

        // Ensure null-termination
        szUsername[ARRAYSIZE(szUsername) - 1] = 0;

        RegCloseKey(hkeyShutdown);
    }

    if (dwSelect == SHTDN_NONE)
    {
        dwSelect = SHTDN_SHUTDOWN;
    }

    // Figure out what flags to pass
    // for sure we don't want any palette changes - this means
    // force 16-colors for 256 color displays.
    dwFlags = SHTDN_NOPALETTECHANGE;

    // On TS, don't show bitmap
    if (GetSystemMetrics(SM_REMOTESESSION))
    {
        dwFlags |= SHTDN_NOBRANDINGBITMAP;
    }

    dwDialogResult = ShutdownDialogEx(hwndParent, dwItems, dwSelect,
        szUsername, dwFlags, NULL, NULL,
        dwReasonToSelect, &dwReasonResult );

    if (dwDialogResult != SHTDN_NONE)
    {
        // Save back the user's choice to the registry
        if (RegCreateKeyEx(HKEY_CURRENT_USER, SHUTDOWN_SETTING_KEY,
            0, 0, 0, KEY_WRITE, NULL, &hkeyShutdown, &dwDisposition) == ERROR_SUCCESS)
        {
            RegSetValueEx(hkeyShutdown, SHUTDOWN_SETTING,
                0, REG_DWORD, (LPBYTE)&dwDialogResult, sizeof(dwDialogResult));

            RegSetValueEx(hkeyShutdown, REASON_SETTING,
                0, REG_DWORD, (LPBYTE)&dwReasonResult, sizeof(dwReasonResult));

            RegCloseKey(hkeyShutdown);
        }
    }

    // Clean up fonts and bitmaps we created
    if (g_hpalBranding)
    {
        DeleteObject(g_hpalBranding);
    }

    if (g_hbmOtherDlgBrand)
    {
        DeleteObject(g_hbmOtherDlgBrand);
    }

    if (g_hbmLogonBrand)
    {
        DeleteObject(g_hbmLogonBrand);
    }

    if (g_hbmBand)
    {
        DeleteObject(g_hbmBand);
    }

    if (fonts.hWelcomeFont)
    {
        DeleteObject(fonts.hWelcomeFont);
    }

    if (fonts.hCopyrightFont)
    {
        DeleteObject(fonts.hCopyrightFont);
    }

    if (fonts.hBuiltOnNtFont)
    {
        DeleteObject(fonts.hBuiltOnNtFont);
    }

    if (fonts.hBetaFont)
    {
        DeleteObject(fonts.hBetaFont);
    }

    return dwDialogResult;
}

/****************************************************************************

  Function: GetSessionCount

  Returns: The number of user sessions that are active
            on your terminal server. If this value is more than 1, then
            operations such as shutdown or restart will end these other
            sessions.

  History: dsheldon 04/23/99 - created
****************************************************************************/

// Termsrv dll delayload stuff
#define WTSDLLNAME  TEXT("WTSAPI32.DLL")
HINSTANCE g_hWTSDll = NULL;
typedef BOOL (WINAPI*WTSEnumerateSessionsW_t)(IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_SESSION_INFOW * ppSessionInfo,
    OUT DWORD * pCount
    );

WTSEnumerateSessionsW_t g_pfnWTSEnumerateSessions = NULL;

typedef VOID (WINAPI*WTSFreeMemory_t)(IN PVOID pMemory);
    
WTSFreeMemory_t g_pfnWTSFreeMemory = NULL;

typedef BOOL (WINAPI*WTSQuerySessionInformationW_t)(IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WtsInfoClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pCount
    );

WTSQuerySessionInformationW_t g_pfnWTSQuerySessionInformation = NULL;


DWORD GetSessionCount()
{
    BOOL fSessionsEnumerated;
    PWTS_SESSION_INFO pSessionInfo;
    DWORD cSessionInfo;

    // Return value
    DWORD nOtherSessions = 0;

    // Try to load termsrv dll if necessary
    if (NULL == g_hWTSDll)
    {
        g_hWTSDll = LoadLibrary(WTSDLLNAME);

        if (g_hWTSDll)
        {
            g_pfnWTSEnumerateSessions = (WTSEnumerateSessionsW_t) GetProcAddress(g_hWTSDll, "WTSEnumerateSessionsW");
            g_pfnWTSQuerySessionInformation = (WTSQuerySessionInformationW_t) GetProcAddress(g_hWTSDll, "WTSQuerySessionInformationW");
            g_pfnWTSFreeMemory = (WTSFreeMemory_t) GetProcAddress(g_hWTSDll, "WTSFreeMemory");
        }
    }

    // Continue only if we have the functions we need
    if (g_pfnWTSEnumerateSessions && g_pfnWTSFreeMemory && g_pfnWTSQuerySessionInformation)
    {
        // Enumerate all sessions on this machine
        pSessionInfo = NULL;
        cSessionInfo = 0;
        fSessionsEnumerated = g_pfnWTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &cSessionInfo);

        if (fSessionsEnumerated)
        {
            DWORD iSession;
        
            ASSERT((pSessionInfo != NULL) || (cSessionInfo == 0));

            // Check each session to see if it is one we should count
            for (iSession = 0; iSession < cSessionInfo; iSession ++)
            {
                switch (pSessionInfo[iSession].State)
                {
                // We count these cases:
                case WTSActive:
                case WTSShadow:
                    {
                        nOtherSessions ++;                   
                    }
                    break;

                case WTSDisconnected:
                    {
                        LPWSTR pUserName = NULL;
                        DWORD  cSize;
                        // Only count the disconnected sessions that have a user logged on
                        if (g_pfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, pSessionInfo[iSession].SessionId,
                                                            WTSUserName, &pUserName, &cSize)) {

                            if (pUserName && (pUserName[0] != L'\0')) {

                                nOtherSessions ++; 
                            }

                            if (pUserName != NULL)
                            {
                                g_pfnWTSFreeMemory(pUserName);
                            }

                        }
                    }
                    break;
                // And ignore the rest:
                default:
                    break;
                }
            }

            if (pSessionInfo != NULL)
            {
                g_pfnWTSFreeMemory(pSessionInfo);
            }
        }
    }

    return nOtherSessions;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\status.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       status.c
//
//  Contents:   Status UI
//
//  History:    11-19-98   EricFlo   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"

#define WM_HIDEOURSELVES    (WM_USER + 1000)

//*************************************************************
//
//  StatusMessageDlgProc()
//
//  Purpose:    Dialog box procedure for the status dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/19/98    EricFlo    Created
//
//*************************************************************

INT_PTR APIENTRY StatusMessageDlgProc (HWND hDlg, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam)
{

    switch (uMsg) {

        case WM_INITDIALOG:
            {
            RECT rc;
            PGLOBALS pGlobals = (PGLOBALS) lParam;

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pGlobals);

            SizeForBranding(hDlg, FALSE);
            CentreWindow (hDlg);

            pGlobals->xStatusBandOffset = 0;

            if (GetClientRect(hDlg, &rc)) {
                pGlobals->cxStatusBand = rc.right-rc.left;
            } else {
                pGlobals->cxStatusBand = 100;
            }

            if (_Shell_LogonStatus_Exists())
            {
                SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                PostMessage(hDlg, WM_HIDEOURSELVES, 0, 0);
            }

            if ((pGlobals->dwStatusOptions & STATUSMSG_OPTION_NOANIMATION) == 0) {
                SetTimer(hDlg, 0, 20, NULL);
            }
            }
            return TRUE;

        case WM_HIDEOURSELVES:
            ShowWindow(hDlg, SW_HIDE);
            break;

        case WM_TIMER:

            if (wParam == 0)
            {
                PGLOBALS pGlobals = (PGLOBALS) GetWindowLongPtr(hDlg, DWLP_USER);
                HDC hDC;

                if (pGlobals)
                {
                     pGlobals->xStatusBandOffset = (pGlobals->xStatusBandOffset+5) % pGlobals->cxStatusBand;
                     
                     hDC = GetDC(hDlg);
                     if ( hDC )
                     {
                         PaintBranding(hDlg, hDC, pGlobals->xStatusBandOffset, TRUE, FALSE, COLOR_BTNFACE);
                         ReleaseDC(hDlg, hDC);
                     }
                }
            }
            break;

        case WM_ERASEBKGND:
            {
            PGLOBALS pGlobals = (PGLOBALS) GetWindowLongPtr(hDlg, DWLP_USER);

            if (pGlobals) {
                return PaintBranding(hDlg, (HDC)wParam, pGlobals->xStatusBandOffset, FALSE, FALSE, COLOR_BTNFACE);
            }

            return 0;
            }

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_DESTROY:
            KillTimer (hDlg, 0);
            break;

        default:
            break;
    }

    return FALSE;
}

//*************************************************************
//
//  StatusMessageThread()
//
//  Purpose:    Status message thread
//
//  Parameters: hDesktop  - Desktop handle to put UI on
//
//  Return:     void
//
//  History:    Date        Author     Comment
//              11/19/98    EricFlo    Created
//
//*************************************************************

void StatusMessageThread (PGLOBALS pGlobals)
{
    HANDLE hInstDll;
    MSG msg;
    DWORD dwResult;
    HANDLE hObjects[2];


    hInstDll = LoadLibrary (TEXT("msgina.dll"));

    if (pGlobals->hStatusDesktop) {
        SetThreadDesktop (pGlobals->hStatusDesktop);
    }

    pGlobals->hStatusDlg = CreateDialogParam (hDllInstance,
                                              MAKEINTRESOURCE(IDD_STATUS_MESSAGE_DIALOG),
                                              NULL, StatusMessageDlgProc,
                                              (LPARAM) pGlobals);

    SetEvent (pGlobals->hStatusInitEvent);

    if (pGlobals->hStatusDlg) {

        hObjects[0] = pGlobals->hStatusTermEvent;

        while (TRUE) {
            dwResult = MsgWaitForMultipleObjectsEx (1, hObjects, INFINITE,
                                                   (QS_ALLPOSTMESSAGE | QS_ALLINPUT),
                                                   MWMO_INPUTAVAILABLE);

            if (dwResult == WAIT_FAILED) {
                break;
            }

            if (dwResult == WAIT_OBJECT_0) {
                break;
            }

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                if (!IsDialogMessage (pGlobals->hStatusDlg, &msg)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

                if (WaitForSingleObject (pGlobals->hStatusTermEvent, 0) == WAIT_OBJECT_0) {
                    goto ExitLoop;
                }
            }
        }

ExitLoop:
        DestroyWindow(pGlobals->hStatusDlg);
        pGlobals->hStatusDlg = NULL;
    }


    if (hInstDll) {
        FreeLibraryAndExitThread(hInstDll, TRUE);
    } else {
        ExitThread (TRUE);
    }
}


//
// Creates and displays the initial status message
//

        // Set in WlxInitialize
DWORD g_dwMainThreadId = 0;     // Creation or removal of the status dialog is not thread safe.
                                // It is kind of difficult to fix with a critsec because of
                                // the mix of objects and windows messages. one can't hold
                                // a critsec accross a window message call as it would introduce
                                // the possibility of deadlocks
                                

BOOL
WINAPI
WlxDisplayStatusMessage(PVOID pWlxContext,
                        HDESK hDesktop,
                        DWORD dwOptions,
                        PWSTR pTitle,
                        PWSTR pMessage)
{
    PGLOBALS  pGlobals = (PGLOBALS) pWlxContext;
    DWORD dwThreadId;


    if (!pGlobals) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (g_dwMainThreadId == GetCurrentThreadId())   // Denies creation/deletion on other threads
    {                                               // than the main thread of winlogon
        if (!pGlobals->hStatusDlg) {

            if (!ReadWinlogonBoolValue(DISABLE_STATUS_MESSAGES, FALSE)) {

                pGlobals->hStatusInitEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
                pGlobals->hStatusTermEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

                if (pGlobals->hStatusInitEvent && pGlobals->hStatusTermEvent) {

                    pGlobals->hStatusDesktop = hDesktop;

                    //
                    // Set the globals here so that StatusMessageDlgProc can look at them in WM_INITDIALOG.
                    //
                
                    pGlobals->dwStatusOptions = dwOptions;

                    pGlobals->hStatusThread = CreateThread (NULL,
                                                  0,
                                                  (LPTHREAD_START_ROUTINE) StatusMessageThread,
                                                  (LPVOID) pGlobals,
                                                  0,
                                                  &dwThreadId);
                    if (pGlobals->hStatusThread) {

                        DWORD   dwWaitResult;

                        do {

                            dwWaitResult = WaitForSingleObject(pGlobals->hStatusInitEvent, 0);
                            if (dwWaitResult != WAIT_OBJECT_0) {

                                dwWaitResult = MsgWaitForMultipleObjects(1,
                                                   &pGlobals->hStatusInitEvent,
                                                   FALSE,
                                                   INFINITE,
                                                   QS_ALLPOSTMESSAGE | QS_ALLINPUT);
                                if (dwWaitResult == WAIT_OBJECT_0 + 1) {

                                    MSG     msg;

                                    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                                        TranslateMessage(&msg);
                                        DispatchMessage(&msg);
                                    }
                                }
                             }
                        } while (dwWaitResult == WAIT_OBJECT_0 + 1);
                    }
                }
            }
        }
    }

    if (pGlobals->hStatusDlg) {

        if (pTitle) {
            SetWindowText (pGlobals->hStatusDlg, pTitle);
        }

        SetDlgItemText (pGlobals->hStatusDlg, IDC_STATUS_MESSAGE_TEXT, pMessage);

        _Shell_LogonStatus_ShowStatusMessage(pMessage);

        if (dwOptions & STATUSMSG_OPTION_SETFOREGROUND) {
            SetForegroundWindow (pGlobals->hStatusDlg);
        }
    }

    return TRUE;
}

//
// Gets the current status message
//

BOOL
WINAPI
WlxGetStatusMessage(PVOID pWlxContext,
                    DWORD *pdwOptions,
                    PWSTR pMessage,
                    DWORD dwBufferSize)
{
    PGLOBALS  pGlobals = (PGLOBALS) pWlxContext;
    DWORD dwLen;


    if (!pGlobals || !pMessage) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    dwLen = (DWORD) SendDlgItemMessage (pGlobals->hStatusDlg, IDC_STATUS_MESSAGE_TEXT,
                                        WM_GETTEXTLENGTH, 0, 0);

    if (dwBufferSize < dwLen) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    GetDlgItemText (pGlobals->hStatusDlg, IDC_STATUS_MESSAGE_TEXT,
                    pMessage, dwBufferSize);

    if (pdwOptions) {
        *pdwOptions = pGlobals->dwStatusOptions;
    }

    return TRUE;
}


//
// Removes the status dialog
//

BOOL
WINAPI
WlxRemoveStatusMessage(PVOID pWlxContext)
{
    PGLOBALS  pGlobals = (PGLOBALS) pWlxContext;


    if (!pGlobals) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (g_dwMainThreadId != GetCurrentThreadId()) { // Denies creation/deletion on other threads
        return FALSE;
    }

    if (pGlobals->hStatusTermEvent) {

        SetEvent(pGlobals->hStatusTermEvent);

        if (pGlobals->hStatusThread) {

            if (pGlobals->hStatusDlg) {

                DWORD   dwWaitResult;

                do {

                    dwWaitResult = WaitForSingleObject(pGlobals->hStatusThread, 0);
                    if (dwWaitResult != WAIT_OBJECT_0) {

                        dwWaitResult = MsgWaitForMultipleObjects(1,
                                           &pGlobals->hStatusThread,
                                           FALSE,
                                           10000,
                                           QS_ALLPOSTMESSAGE | QS_ALLINPUT);
                        if (dwWaitResult == WAIT_OBJECT_0 + 1) {

                            MSG     msg;

                            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                     }
                } while (dwWaitResult == WAIT_OBJECT_0 + 1);
            }

            CloseHandle (pGlobals->hStatusThread);
        }

        CloseHandle (pGlobals->hStatusTermEvent);
    }

    if (pGlobals->hStatusInitEvent) {
        CloseHandle (pGlobals->hStatusInitEvent);
    }

    pGlobals->hStatusInitEvent = NULL;
    pGlobals->hStatusTermEvent = NULL;
    pGlobals->hStatusThread = NULL;

    if (pGlobals->hStatusDesktop)
    {
        //
        // Close the desktop handle here.  Since the status thread
        // was using it, Winlogon was unable to close the handle
        // itself so we have to do it now.
        //
        CloseDesktop(pGlobals->hStatusDesktop);
        pGlobals->hStatusDesktop = NULL;
    }

    pGlobals->hStatusDlg = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\structs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       structs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-19-94   RichardW   Created
//
//----------------------------------------------------------------------------

//
// Arraysize macro
//

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))


//
// Define the input timeout delay for the security options dialog (seconds)
//

#define OPTIONS_TIMEOUT                     120


//
// Define the number of days warning we give the user before their password expires
//

#define PASSWORD_EXPIRY_WARNING_DAYS        14


//
// Define the maximum time we display the 'wait for user to be logged off'
// dialog. This dialog should be interrupted by the user being logged off.
// This timeout is a safety measure in case that doesn't happen because
// of some system error.
//

#define WAIT_FOR_USER_LOGOFF_DLG_TIMEOUT    120 // seconds


//
// Define the account lockout limits
//
// A delay of LOCKOUT_BAD_LOGON_DELAY seconds will be added to
// each failed logon if more than LOCKOUT_BAD_LOGON_COUNT failed logons
// have occurred in the last LOCKOUT_BAD_LOGON_PERIOD seconds.
//

#define LOCKOUT_BAD_LOGON_COUNT             5
#define LOCKOUT_BAD_LOGON_PERIOD            60 // seconds
#define LOCKOUT_BAD_LOGON_DELAY             30 // seconds



//
// Define the maximum length of strings we'll use in winlogon
//

#define MAX_STRING_LENGTH   511
#define MAX_STRING_BYTES    (MAX_STRING_LENGTH + 1)


//
// Define the typical length of a string
// This is used as an initial allocation size for most string routines.
// If this is insufficient, the block is reallocated larger and
// the operation retried. i.e. Make this big enough for most strings
// to fit first time.
//

#define TYPICAL_STRING_LENGTH   60
//
// Define the structure that contains information used when starting
// user processes.
// This structure should only be modified by SetUserProcessData()
//

typedef struct {
    HANDLE                  UserToken;  // NULL if no user logged on
    HANDLE                  RestrictedToken ;
    PSID                    UserSid;    // == WinlogonSid if no user logged on
    PSECURITY_DESCRIPTOR    NewThreadTokenSD;
    QUOTA_LIMITS            Quotas;
    PVOID                   pEnvironment;
    HKEY                    hCurrentUser ;
    ULONG                   Flags ;
} USER_PROCESS_DATA;
typedef USER_PROCESS_DATA *PUSER_PROCESS_DATA;

#define USER_FLAG_LOCAL     0x00000001


//
// Define the structure that contains information about the user's profile.
// This is used in SetupUserEnvironment and ResetEnvironment (in usrenv.c)
// This data is only valid while a user is logged on.
//

typedef struct {
    LPTSTR ProfilePath;
} USER_PROFILE_INFO;
typedef USER_PROFILE_INFO *PUSER_PROFILE_INFO;



//
// Get any data types defined in module headers and used in GLOBALS
//

#define DATA_TYPES_ONLY
#include "lockout.h"
#include "domain.h"
#undef DATA_TYPES_ONLY

//
// Multi User Global Structure
//

typedef struct _MUGLOBALS {

    //
    // Current SessionId
    //
    ULONG SessionId;

    //
    // Auto logon information
    //
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pAutoLogon;

    //
    // TS-specific data passed to us from WinLogon via WlxPassTerminalServicesData().
    //
    WLX_TERMINAL_SERVICES_DATA TSData;

    //
    // For CLIENTNAME environment variable
    //
    TCHAR ClientName[CLIENTNAME_LENGTH + 1];

} MUGLOBALS, *PMUGLOBALS;

//
// Non paged chunk for passwords and similar goodies
//

typedef struct _NP_GLOBALS {
    WCHAR                   UserName[MAX_STRING_BYTES];     // e.g. Justinm
    WCHAR                   Domain[MAX_STRING_BYTES];
    WCHAR                   Password[MAX_STRING_BYTES];
    WCHAR                   OldPassword[MAX_STRING_BYTES];
} NP_GLOBALS, * PNP_GLOBALS ;

//
// Reasons why we may not have performed an optimized - cached logon
// by default.
//

typedef enum _OPTIMIZED_LOGON_STATUS {
    OLS_LogonIsCached                                   = 0,
    OLS_Unspecified                                     = 1,
    OLS_UnsupportedSKU                                  = 2,
    OLS_LogonFailed                                     = 3,
    OLS_InsufficientResources                           = 4,
    OLS_NonCachedLogonType                              = 5,
    OLS_SyncUserPolicy                                  = 6,
    OLS_SyncMachinePolicy                               = 7,
    OLS_ProfileDisallows                                = 8,
    OLS_SyncLogonScripts                                = 9,
    OLS_NextLogonNotCacheable                           = 10,
    OLS_MachineIsNotDomainMember                        = 11,
} OPTIMIZED_LOGON_STATUS, *POPTIMIZED_LOGON_STATUS;

//
// Define the winlogon global structure.
//

typedef struct _GINAFONTS
{
    HFONT hWelcomeFont;                 // font used for painting the welcome text
    HFONT hCopyrightFont;               // used to paint copyright notice
    HFONT hBuiltOnNtFont;               // used to paint the "Built on NT" line
    HFONT hBetaFont;                    // used to paint the release notice on the welcome page
} GINAFONTS, *PGINAFONTS;

#define PASSWORD_HASH_SIZE      16

typedef struct _GLOBALS {
    struct _GLOBALS         *pNext;

    HANDLE                  hGlobalWlx;
    HDESK                   hdeskParent;

    RTL_CRITICAL_SECTION    csGlobals;

    // Filled in by InitializeGlobals at startup
    PSID                    WinlogonSid;

    //
    PSID                    LogonSid;
    PVOID                   LockedMemory ;

    HANDLE                  hEventLog;

    HANDLE                  hMPR;

    HWND                    hwndLogon;
    BOOL                    LogonInProgress;

    // Filled in during startup
    HANDLE                  LsaHandle; // Lsa authentication handle
    LSA_OPERATIONAL_MODE    SecurityMode;
    ULONG                   AuthenticationPackage;
    BOOL                    AuditLogFull;
    BOOL                    AuditLogNearFull;

    // Always valid, indicates if we have a user logged on
    BOOL                    UserLoggedOn;

    // Always valid - used to start new processes and screen-saver
    USER_PROCESS_DATA       UserProcessData;

    // Filled in by a successful logon
    TCHAR                   UserFullName[MAX_STRING_BYTES]; // e.g. Magaram, Justin
    UNICODE_STRING          UserNameString;
    LPWSTR                  UserName ;
    UNICODE_STRING          DomainString;
    LPWSTR                  Domain ;
    UNICODE_STRING          FlatUserName ;
    UNICODE_STRING          FlatDomain;
    LPWSTR                  DnsDomain ;
    UCHAR                   Seed;
    UCHAR                   OldSeed;
    UCHAR                   OldPasswordPresent;
    UCHAR                   Reserved;
    LUID                    LogonId;
    TIME                    LogonTime;
    TIME                    LockTime;
    PMSV1_0_INTERACTIVE_PROFILE Profile;
    ULONG                   ProfileLength;
    LPWSTR                  MprLogonScripts;
    UNICODE_STRING          PasswordString;   // Run-encoded for password privacy
                                              // (points to Password buffer below)

    LPWSTR                  Password ;
    UNICODE_STRING          OldPasswordString;
    LPWSTR                  OldPassword ;

    UCHAR                   PasswordHash[ PASSWORD_HASH_SIZE ]; // Hash of password

    // Filled in during SetupUserEnvironment, and used in ResetEnvironment.
    // Valid only when a user is logged on.
    USER_PROFILE_INFO       UserProfile;

    PWSTR                   ExtraApps;

    BOOL                    BlockForLogon;

    FILETIME                LastNotification;

    //
    // Advanced Logon Stuff:
    //

    ULONG                   PasswordLogonPackage ;
    ULONG                   SmartCardLogonPackage ;
    OPTIMIZED_LOGON_STATUS  OptimizedLogonStatus;

    //
    // Account lockout data
    //
    // Manipulated only by LockInitialize, LockoutHandleFailedLogon
    // and LockoutHandleSuccessfulLogon.
    //

    LOCKOUT_DATA            LockoutData;

    //
    // Flags controlling unlock behavior
    //

    DWORD                   UnlockBehavior ;

    //
    // Trusted domain cache
    //

    PDOMAIN_CACHE Cache ;
    PDOMAIN_CACHE_ARRAY ActiveArray ;
    BOOL ListPopulated ;

    //
    // Hydra specific part of winlogon globals struct
    //
    MUGLOBALS MuGlobals;

    //
    // Folding options state
    //
    BOOL ShowRasBox;
    BOOL RasUsed;
    BOOL SmartCardLogon;
    ULONG SmartCardOption ;
    BOOL LogonOptionsShown;
    BOOL UnlockOptionsShown;
    BOOL AutoAdminLogon;
    BOOL IgnoreAutoAdminLogon;

    INT xBandOffset;                    // used for animated band in dialog
    INT cxBand;                         // width of band being displayed, used for wrapping

    // fonts
    GINAFONTS GinaFonts;

    // Flag indicating whether we are showing the domain box
    BOOL ShowDomainBox;

    // Coordinates of upper-left hand corner of the Welcome screen
    // - We want to position the logon dialog here also!
    RECT rcWelcome;

    // Size of the original "Log On To Windows" dialog
    RECT rcDialog;

    // Status UI information
    HANDLE hStatusInitEvent;
    HANDLE hStatusTermEvent;
    HANDLE hStatusThread;
    HDESK  hStatusDesktop;
    HWND   hStatusDlg;
    INT    cxStatusBand;
    INT    xStatusBandOffset;
    DWORD  dwStatusOptions;
    // flag indicating if user credentials were passed on from an other session
    BOOL TransderedCredentials;

    TCHAR  Smartcard[64];
    TCHAR  SmartcardReader[64];

} GLOBALS, *PGLOBALS;

//
// Unlock behavior bits:
//

#define UNLOCK_FORCE_AUTHENTICATION     0x00000001
#define UNLOCK_NO_NETWORK               0x00000002


//
// Define a macro to determine if we're a workstation or not
// This allows easy changes as new product types are added.
//

#define IsDomainController(prodtype)    (((prodtype) == NtProductWinNt) \
                                            || ((prodtype) == NtProductServer))

#define IsWorkstation(prodtype)         ((prodtype) == NtProductWinNt)


// A WM_HANDLEFAILEDLOGON message was already sent - this message
// will in turn send a WM_LOGONCOMPLETE with the result.
#define MSGINA_DLG_FAILEDMSGSENT            0x10000001

//
// Define common return code groupings
//

#define DLG_TIMEOUT(Result)     ((Result == MSGINA_DLG_INPUT_TIMEOUT) || (Result == MSGINA_DLG_SCREEN_SAVER_TIMEOUT))
#define DLG_LOGOFF(Result)      ((Result & ~MSGINA_DLG_FLAG_MASK) == MSGINA_DLG_USER_LOGOFF)
#define DLG_SHUTDOWNEX(Result)  ((Result & ~MSGINA_DLG_FLAG_MASK) == MSGINA_DLG_SHUTDOWN)
// #define DLG_INTERRUPTED(Result) (DLG_TIMEOUT(Result) || DLG_LOGOFF(Result))
#define DLG_SHUTDOWN(Result)    ((DLG_LOGOFF(Result) || DLG_SHUTDOWNEX(Result)) && (Result & (MSGINA_DLG_SHUTDOWN_FLAG | MSGINA_DLG_REBOOT_FLAG | MSGINA_DLG_POWEROFF_FLAG | MSGINA_DLG_SLEEP_FLAG | MSGINA_DLG_SLEEP2_FLAG | MSGINA_DLG_HIBERNATE_FLAG)))

#define SetInterruptFlag(Result)    ((Result) | MSGINA_DLG_INTERRUPTED )
#define ClearInterruptFlag(Result)  ((Result) & (~MSGINA_DLG_INTERRUPTED ))
#define ResultNoFlags(Result)       ((Result) & (~MSGINA_DLG_INTERRUPTED ))

#define DLG_FAILED(Result)          (ResultNoFlags( Result ) == MSGINA_DLG_FAILURE)
#define DLG_SUCCEEDED(Result)       (ResultNoFlags( Result ) == MSGINA_DLG_SUCCESS)
#define DLG_INTERRUPTED( Result )   ((Result & MSGINA_DLG_INTERRUPTED) == (MSGINA_DLG_INTERRUPTED) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\strings.h ===
/****************************** Module Header ******************************\
* Module Name: strings.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines strings that do not need to be localized.
*
* History:
* 11-17-92 Davidc       Created.
\***************************************************************************/

//
// App name strings
//

#define WINLOGON_INI        TEXT("WINLOGON.INI")
#define WINLOGON            TEXT("WINLOGON")


//
// Define where we store the most recent logon information
//

#define APPLICATION_NAME                    TEXT("Winlogon")
#define DEFAULT_USER_NAME_KEY               TEXT("DefaultUserName")
#define TEMP_DEFAULT_USER_NAME_KEY          TEXT("AltDefaultUserName")
#define DEFAULT_DOMAIN_NAME_KEY             TEXT("DefaultDomainName")
#define TEMP_DEFAULT_DOMAIN_NAME_KEY        TEXT("AltDefaultDomainName")
#define LEGAL_NOTICE_CAPTION_KEY            TEXT("LegalNoticeCaption")
#define LEGAL_NOTICE_TEXT_KEY               TEXT("LegalNoticeText")
#define AUTO_ADMIN_LOGON_KEY                TEXT("AutoAdminLogon")
#define IGNORE_SHIFT_OVERRIDE_KEY           TEXT("IgnoreShiftOverride")
#define DEFAULT_PASSWORD_KEY                TEXT("DefaultPassword")
#define DONT_DISPLAY_LAST_USER_KEY          TEXT("DontDisplayLastUserName")
#define SHUTDOWN_WITHOUT_LOGON_KEY          TEXT("ShutdownWithoutLogon")
#define REPORT_BOOT_OK_KEY                  TEXT("ReportBootOk")
#define POWER_DOWN_AFTER_SHUTDOWN           TEXT("PowerdownAfterShutdown")

#define REPORT_CONTROLLER_MISSING           TEXT("ReportControllerMissing")
/* Value ReportControllerMissing

  A warning message indicating that a "domain controller could not be found and
  that cached user credentials will be used" will only be generated if:
  
    1. this REG_SZ value, in HKLM exists and contains the string "TRUE", 
       in uppercase, without quotes.

    - AND -

    2. the REG_DWORD value "ReportDC" in HKCU contains a non-zero value (or the value
       doesn't exist or is of the wrong type).

  Any other permutation of these two regvals will cause no message to be displayed and
  cached credentials to be used silently.

  "ReportControllerMissing" is the system-wide policy value, and "ReportDC" is the user's
  preference, which can be set by a checkbox on the warning dialog to force the message
  to be hidden even on systems with the "ReportControllerMissing" value set to "TRUE".

  - dsheldon 11/15/99
*/

#define USERINIT_KEY                        TEXT("Userinit")
#define AUTOADMINLOGON_KEY                  TEXT("AutoAdminLogon")
#define FORCEAUTOLOGON_KEY                  TEXT("ForceAutoLogon")
#define AUTOLOGONCOUNT_KEY                  TEXT("AutoLogonCount")
#define UNLOCKWORKSTATION_KEY               TEXT("ForceUnlockMode")
#define PASSWORD_WARNING_KEY                TEXT("PasswordExpiryWarning")
#define WELCOME_CAPTION_KEY                 TEXT("Welcome")
#define LOGON_MSG_KEY                       TEXT("LogonPrompt")
#define RAS_DISABLE                         TEXT("RasDisable")
#define RAS_FORCE                           TEXT("RasForce")
#define ENABLE_LOGON_HOURS                  TEXT("EnableLogonHours")
#define RESTRICT_SHELL                      TEXT("RestrictShell")

#define SC_REMOVE_OPTION                    TEXT("ScRemoveOption")
//
// Value ScRemoveOption
//
// Definition:  Controls workstation behavior when a smart card is
// used to log on, and then removed.  Range: 0, 1, 2.  Type:  REG_SZ
// 0 - no action
// 1 - lock workstation
// 2 - force logoff


#define FORCE_UNLOCK_LOGON                  TEXT("ForceUnlockLogon")
//
// Value - ForceUnlockLogon
//
// Definition:  Controls whether a full logon is performed during unlock.
// This will force a validation at the domain controller for the user 
// attempting to unlock.  Range:  0, 1.  Type:  REG_DWORD
//
// 0 - Do not force authentication inline (default)
// 1 - Require online authentication to unlock.
//

#define DCACHE_SHOW_DNS_NAMES               TEXT("DCacheShowDnsNames")
//
// do not document
//

#define DCACHE_SHOW_DOMAIN_TAGS             TEXT("DCacheShowDomainTags")
//
// do not document
//


//
// Environment variables that *we* set.
//
#define PATH_VARIABLE                       TEXT("PATH")
#define LIBPATH_VARIABLE                    TEXT("LibPath")
#define OS2LIBPATH_VARIABLE                 TEXT("Os2LibPath")
#define AUTOEXECPATH_VARIABLE               TEXT("AutoexecPath")
#define HOMEDRIVE_VARIABLE                  TEXT("HOMEDRIVE")
#define HOMESHARE_VARIABLE                  TEXT("HOMESHARE")
#define HOMEPATH_VARIABLE                   TEXT("HOMEPATH")
#define INIDRIVE_VARIABLE                   TEXT("INIDRIVE")
#define INIPATH_VARIABLE                    TEXT("INIPATH")
#define CLIENTNAME_VARIABLE                 TEXT("CLIENTNAME")
#define SMARTCARD_VARIABLE                  TEXT("SMARTCARD")

#define USERNAME_VARIABLE                   TEXT("USERNAME")
#define USERDOMAIN_VARIABLE                 TEXT("USERDOMAIN")
#define LOGONSERVER_VARIABLE                TEXT("LOGONSERVER")
#define USERDNSDOMAIN_VARIABLE              TEXT("USERDNSDOMAIN")

#define USER_ENV_SUBKEY                     TEXT("Environment")
#define USER_VOLATILE_ENV_SUBKEY            TEXT("Volatile Environment")

#define ROOT_DIRECTORY          TEXT("\\")
#define USERS_DIRECTORY         TEXT("\\users")
#define USERS_DEFAULT_DIRECTORY TEXT("\\users\\default")

#define NULL_STRING             TEXT("")
//
// Define where we get screen-saver information
//

#define SCREEN_SAVER_INI_FILE               TEXT("system.ini")
#define SCREEN_SAVER_INI_SECTION            TEXT("boot")
#define SCREEN_SAVER_FILENAME_KEY           TEXT("SCRNSAVE.EXE")
#define SCREEN_SAVER_SECURE_KEY             TEXT("ScreenSaverIsSecure")

#define WINDOWS_INI_SECTION                 TEXT("Windows")
#define SCREEN_SAVER_ENABLED_KEY            TEXT("ScreenSaveActive")

#define OPTIMIZED_LOGON_VARIABLE            TEXT("UserInitOptimizedLogon")
#define LOGON_SERVER_VARIABLE               TEXT("UserInitLogonServer")
#define LOGON_SCRIPT_VARIABLE               TEXT("UserInitLogonScript")
#define MPR_LOGON_SCRIPT_VARIABLE           TEXT("UserInitMprLogonScript")
#define USER_INIT_AUTOENROLL                TEXT("UserInitAutoEnroll")
#define AUTOENROLL_NONEXCLUSIVE             TEXT("1")
#define AUTOENROLL_EXCLUSIVE                TEXT("2")
#define USER_INIT_AUTOENROLLMODE            TEXT("UserInitAutoEnrollMode")
#define AUTOENROLL_STARTUP                  TEXT("1")
#define AUTOENROLL_WAKEUP                   TEXT("2")
#define WINLOGON_USER_KEY                   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")

#define NODCMESSAGE                         TEXT("ReportDC")
// ReportDC Value - see description for ReportControllerMissing above for usage

#define PASSWORD_EXPIRY_WARNING             TEXT("PasswordExpiryWarning")


//
// Policies
//

#define WINLOGON_POLICY_KEY                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System")
#define DISABLE_LOCK_WKSTA                  TEXT("DisableLockWorkstation")
#define DISABLE_TASK_MGR                    TEXT("DisableTaskMgr")
#define DISABLE_CHANGE_PASSWORD             TEXT("DisableChangePassword")
#define DISABLE_CAD                         TEXT("DisableCAD")
#define SHOW_LOGON_OPTIONS                  TEXT("ShowLogonOptions")
#define DISABLE_STATUS_MESSAGES             TEXT("DisableStatusMessages")

#define EXPLORER_POLICY_KEY                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")
#define NOLOGOFF                            TEXT("NoLogoff")
#define NOCLOSE                             TEXT("NoClose")
#define NODISCONNECT                        TEXT("NoDisconnect")

#define RELIABILITY_POLICY_KEY              TEXT("Software\\Policies\\Microsoft\\Windows NT\\Reliability")
#define RELIABILITY_POLICY_SHUTDOWNREASONUI TEXT("ShutdownReasonUI")
#define RELIABILITY_POLICY_SNAPSHOT         TEXT("Snapshot")
#define RELIABILITY_POLICY_REPORTSNAPSHOT   TEXT("ReportSnapshot")


//
// Things to control auto-enrollment.
//
#define AUTOENROLL_KEY                      TEXT("Software\\Microsoft\\Cryptography\\AutoEnrollment")
#define AUTOENROLL_FLAGS                    TEXT("Flags")

// HKLM\sw\ms\windows nt\currentversion\winlogon DWORD NoDomainUI
// Doesn't exist or 0x0: Show Domain combobox if appropriate
// Does exist and is non-0x0: Hide Domain box in all cases (force UPN or local login)
#define NODOMAINCOMBO                       TEXT("NoDomainUI")

#define ANY_LOGON_PROVIDER                  "<any>"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\win31mig.h ===
/****************************** Module Header ******************************\
* Module Name: win31mig.h
*
* Copyright (c) 1993, Microsoft Corporation
*
* Constants for the Windows 3.1 Migration dialog
*
* NOTE - this file is maintained by dlgedit. Do not edit directly
*
* History:
* 01-08-93 Stevewo      Created.
\***************************************************************************/

#ifndef RC_INVOKED
#if 0
BOOL
Windows31Migration(
    PGLOBALS pGlobals
    );
#endif
#endif  /* !RC_INVOKED */

#define IDD_WIN31MIG                801
#define IDD_WIN31MIG_INIFILES       802
#define IDD_WIN31MIG_GROUPS         803
#define IDD_WIN31MIG_STATUS         804
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\sysshut.h ===
#define IDD_SYSTEM_SHUTDOWN         1300
#define IDD_TIMER                   1303
#define IDD_MESSAGE                 1305
#define IDD_SYSTEM_MESSAGE          1306

BOOLEAN
ShutdownThread(
    VOID
    );

BOOL
InitializeShutdownModule(
    PGLOBALS pGlobals
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\winutil.h ===
/****************************** Module Header ******************************\
* Module Name: winutil.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define windows utility functions
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//

HWND
CreateAniOnControl(
    HWND        hDlg,
    DWORD       ControlId,
    DWORD       AniId);

VOID
SetupSystemMenu(
    HWND    hwnd
    );


VOID
CentreWindow(
    HWND    hwnd
    );

BOOL
SetPasswordFocus(
    HWND    hDlg
    );

VOID
SetupCursor(
    BOOL    fWait
    );

BOOL
FormatTime(
   IN PTIME Time,
   OUT PWCHAR Buffer,
   IN ULONG BufferLength,
   IN USHORT Flags
   );

//
// Define flags used by FormatTime routine
//
#define FT_TIME 1
#define FT_DATE 2
#define FT_LTR 4
#define FT_RTL 8

BOOL
DuplicateUnicodeString(
    PUNICODE_STRING OutString,
    PUNICODE_STRING InString
    );

LPTSTR
UnicodeStringToString(
    PUNICODE_STRING UnicodeString
    );

BOOL
StringToUnicodeString(
    PUNICODE_STRING UnicodeString,
    LPTSTR String
    );

BOOL
OpenIniFileUserMapping(
    PGLOBALS pGlobals
    );

VOID
CloseIniFileUserMapping(
    PGLOBALS pGlobals
    );

LPTSTR
AllocAndGetDlgItemText(
    HWND hDlg,
    int  iItem
    );

BOOL
ReadWinlogonBoolValue (
    LPTSTR lpValueName,
    BOOL bDefault);

BOOL
HandleComboBoxOK(
    HWND    hDlg,
    int     ComboBoxId
    );

LPTSTR
AllocAndGetPrivateProfileString(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    LPCTSTR lpDefault,
    LPCTSTR lpFileName
    );

#define AllocAndGetProfileString(App, Key, Def) \
            AllocAndGetPrivateProfileString(App, Key, Def, NULL)


BOOL
WritePrivateProfileInt(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    UINT Value,
    LPCTSTR lpFileName
    );

#define WriteProfileInt(App, Key, Value) \
            WritePrivateProfileInt(App, Key, Value, NULL)


LPTSTR
AllocAndExpandEnvironmentStrings(
    LPCTSTR lpszSrc
    );

LPTSTR
AllocAndRegEnumKey(
    HKEY hKey,
    DWORD iSubKey
    );

LPTSTR
AllocAndRegQueryValueEx(
    HKEY hKey,
    LPTSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType
    );

LPWSTR
EncodeMultiSzW(
    IN LPWSTR MultiSz
    );


//
// Memory macros
//

#define Alloc(c)        ((PVOID)LocalAlloc(LPTR, c))
#define ReAlloc(p, c)   ((PVOID)LocalReAlloc(p, c, LPTR | LMEM_MOVEABLE))
#define Free(p)         ((VOID)LocalFree(p))


//
// Define a winlogon debug print routine
//

#define WLPrint(s)  KdPrint(("WINLOGON: ")); \
                    KdPrint(s);            \
                    KdPrint(("\n"));

INT_PTR TimeoutMessageBox(
    HWND hwnd,
    PGLOBALS pGlobals,
    UINT IdText,
    UINT IdCaption,
    UINT wType,
    TIMEOUT Timeout);


INT_PTR TimeoutMessageBoxlpstr(
    HWND hwnd,
    PGLOBALS pGlobals,
    LPTSTR Text,
    LPTSTR Caption,
    UINT wType,
    TIMEOUT Timeout);

#define TIMEOUT_VALUE_MASK  (0x0fffffff)
#define TIMEOUT_NOTIFY_MASK (0x10000000)

#define TIMEOUT_VALUE(t)    (t & TIMEOUT_VALUE_MASK)
#define TIMEOUT_NOTIFY(t)   (t & TIMEOUT_NOTIFY_MASK)

#define TIMEOUT_SS_NOTIFY   (TIMEOUT_NOTIFY_MASK)
#define TIMEOUT_CURRENT     (TIMEOUT_VALUE_MASK)    // Use existing timeout
#define TIMEOUT_NONE        (0)                     // Disable input timeout


PWSTR
DupString(PWSTR pszString);

PWSTR
DupUnicodeString(PUNICODE_STRING pString);

// Utility function used by both logon and unlock code to enable or
// disable the domain combo box based on whether a UPN user name is
// typed into the username edit box
void EnableDomainForUPN(HWND hwndUsername, HWND hwndDomain);

BOOL ForceNoDomainUI();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\welcome.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       welcome.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-18-94   RichardW   Created
//
//----------------------------------------------------------------------------

INT_PTR WINAPI
WelcomeDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

VOID
SetWelcomeCaption(
    HWND    hDlg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\welcome.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       welcome.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include "wtsapi32.h"
#include <stdio.h>
#include <wchar.h>



extern HICON   hLockedIcon;


// Welcome help screen stuff --dsheldon (11/16/98)

// Display the help text for the Ctrl-Alt-Del help dlg --dsheldon
void ShowHelpText(HWND hDlg, BOOL fSmartcard)
{
    TCHAR szHelpText[2048];
    UINT idHelpText = fSmartcard ? IDS_CADSMARTCARDHELP : IDS_CADHELP;

    LoadString(hDllInstance, idHelpText, szHelpText, ARRAYSIZE(szHelpText));

    SetDlgItemText(hDlg, IDC_HELPTEXT, szHelpText);
}

// Help dialog wndproc --dsheldon
INT_PTR WINAPI
HelpDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HBRUSH hbrWindow = NULL;
    static HFONT hBoldFont = NULL;
    PGLOBALS pGlobals;
    INT_PTR fReturn = FALSE;
    ULONG_PTR Value = 0;

    switch(message)
    {
    case WM_INITDIALOG:
        {
            HWND hwndAnim;
            HWND hwndHelpTitle;
            HFONT hOld;

            hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            pGlobals = (PGLOBALS) lParam;

            pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_SMART_CARD_PRESENT,
                                     &Value
                                    );
        
            ShowHelpText(hDlg, (0 != Value));

            // Animate the press-cad puppy
            hwndAnim = GetDlgItem(hDlg, IDC_ANIMATE);
            Animate_OpenEx(hwndAnim, hDllInstance, MAKEINTRESOURCE(IDA_ANIMATE));
            Animate_Play(hwndAnim, 0, (UINT) -1, (UINT) -1);
            
            // Bold the help title and the Ctrl Alt Delete words
            hwndHelpTitle = GetDlgItem(hDlg, IDC_HELPTITLE);
            hOld = (HFONT) SendMessage(hwndHelpTitle, WM_GETFONT, 0, 0);

            if (hOld)
            {
                LOGFONT lf;
                if (GetObject(hOld, sizeof(lf), &lf))
                {
                    lf.lfHeight = -13;
                    lf.lfWeight = FW_BOLD;

                    hBoldFont = CreateFontIndirect(&lf);

                    if (hBoldFont)
                    {
                        SendMessage(hwndHelpTitle, WM_SETFONT, (WPARAM) hBoldFont, 0);
                        SendDlgItemMessage(hDlg, IDC_CTRL, WM_SETFONT, (WPARAM) hBoldFont, 0);
                        SendDlgItemMessage(hDlg, IDC_ALT, WM_SETFONT, (WPARAM) hBoldFont, 0);
                        SendDlgItemMessage(hDlg, IDC_DEL, WM_SETFONT, (WPARAM) hBoldFont, 0);
                    }
                }
            }

            // Set the dialog's position - but only do this if the help
            // dialog will be reasonably on-screen
            if (((pGlobals->rcWelcome.left + 70) < 600) && 
                ((pGlobals->rcWelcome.top + 20) < 350))
            {
                SetWindowPos(hDlg, NULL, pGlobals->rcWelcome.left + 70, 
                    pGlobals->rcWelcome.top + 20, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            }

            fReturn = TRUE;
        }
        break;
    case WM_DESTROY:
        {
            if (hbrWindow)
                DeleteObject(hbrWindow);

            if (hBoldFont)
                DeleteObject(hBoldFont);
        }
        break;
    case WM_COMMAND:
        {
            if ((HIWORD(wParam) == BN_CLICKED) &&
                ((LOWORD(wParam) == IDOK) || (LOWORD(wParam) == IDCANCEL)))
            {
                EndDialog(hDlg, IDOK);
            }
        }
        break;
    case WM_CTLCOLORSTATIC:
        {
            SetBkColor((HDC) wParam, GetSysColor(COLOR_WINDOW));
            SetTextColor((HDC) wParam, GetSysColor(COLOR_WINDOWTEXT));
            fReturn = (INT_PTR) hbrWindow;            
        }
        break;
    case WM_ERASEBKGND:
        {
            RECT rc = {0};
            GetClientRect(hDlg, &rc);
            FillRect((HDC) wParam, &rc, hbrWindow);
            fReturn = TRUE;
        }
        break;

    case WLX_WM_SAS:
        {
            // Post this to our parent (the c-a-d dialog) and exit
            PostMessage(GetParent(hDlg), message, wParam, lParam);
            EndDialog(hDlg, IDOK);
        }
        break;
    }
    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetWelcomeCaption
//
//  Synopsis:   Grabs the Welcome string from the registry, or the default
//              welcome from the resource section and slaps it into the
//              caption.
//
//  Arguments:  [hDlg] --
//
//  History:    10-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#define MAX_CAPTION_LENGTH  256

VOID
SetWelcomeCaption(
    HWND    hDlg)
{
    WCHAR   szCaption[MAX_CAPTION_LENGTH];
    WCHAR   szDefaultCaption[MAX_CAPTION_LENGTH];
    DWORD   Length;

    GetWindowText( hDlg, szDefaultCaption, MAX_CAPTION_LENGTH );

    szCaption[0] = TEXT('\0');

    GetProfileString(   APPLICATION_NAME,
                        WELCOME_CAPTION_KEY,
                        TEXT(""),
                        szCaption,
                        ARRAYSIZE(szCaption) );

    if ( szCaption[0] != TEXT('\0') )
    {
        Length = (DWORD) wcslen( szDefaultCaption );

        if (ExpandEnvironmentStrings(szCaption,
                                    &szDefaultCaption[Length + 1],
                                    MAX_CAPTION_LENGTH - Length - 1))
        {
            szDefaultCaption[Length] = L' ';
        }

        SetWindowText( hDlg, szDefaultCaption );
    }
}


void SetCadMessage(HWND hDlg, PGLOBALS pGlobals, BOOL fSmartcard)
{
    TCHAR szCadMessage[256];
    UINT idSzCad;
    RECT rcEdit;
    HWND hwndMessage;

    // Set the Press c-a-d message accordingly depending on
    // if we have a smartcard or not, if TS session or not

    if (!GetSystemMetrics(SM_REMOTESESSION))
    {
        idSzCad = fSmartcard ? IDS_PRESSCADORSMARTCARD : IDS_PRESSCAD;
    }
    else
    {
        idSzCad = fSmartcard ? IDS_PRESSCAEORSMARTCARD : IDS_PRESSCAE;
    }

    LoadString(hDllInstance, idSzCad, szCadMessage, ARRAYSIZE(szCadMessage));
    
    hwndMessage = GetDlgItem(hDlg, IDC_PRESSCAD);
    SetWindowText(hwndMessage, szCadMessage);
    SendMessage(hwndMessage, WM_SETFONT, (WPARAM) pGlobals->GinaFonts.hWelcomeFont, 0);

    // We now have to center the text beside the icons
    if (GetClientRect(hwndMessage, &rcEdit))
    {
        HDC hdcMessage;

        // Calculate the amount of vertical room needed for the text
        hdcMessage = GetDC(hwndMessage);

        if (hdcMessage)
        {
            HGDIOBJ hOldFont;
            long height;
            RECT rcTemp = rcEdit;

            // Make sure font is correct for sizing info.
            hOldFont = SelectObject(hdcMessage, (HGDIOBJ) pGlobals->GinaFonts.hWelcomeFont);

            height = (long) DrawTextEx(hdcMessage, szCadMessage, -1, &rcTemp, DT_EDITCONTROL | DT_CALCRECT | DT_WORDBREAK, NULL);

            SelectObject(hdcMessage, hOldFont);
            
            ReleaseDC(hwndMessage, hdcMessage);
            hdcMessage = NULL;

            if (0 < height)
            {
                rcEdit.top = (rcEdit.bottom / 2) - (height / 2);
                rcEdit.bottom = rcEdit.top + height;

                MapWindowPoints(hwndMessage, hDlg, (POINT*) &rcEdit, 2);

                SetWindowPos(hwndMessage, 0, rcEdit.left, rcEdit.top, rcEdit.right - rcEdit.left,
                    rcEdit.bottom - rcEdit.top, SWP_NOZORDER);
            }
        }
    }           
}

void SetIcons(HWND hDlg, BOOL fSmartcard)
{
    static UINT rgidNoSmartcard[] = {IDC_KEYBOARD, IDC_PRESSCAD};
	static INT iLeftRelPos;
	static INT iDistance;

	if (iDistance == 0) {

		// get the left relative position of the kbd icon
		// and the distance we would have to move it to the left
		// in case we have no reader installed
        RECT rcSC, rcKB, rcDlg;

		GetWindowRect(hDlg, &rcDlg);
        GetWindowRect(GetDlgItem(hDlg, IDC_KEYBOARD), &rcKB);
        GetWindowRect(GetDlgItem(hDlg, IDC_SMARTCARD), &rcSC);

		iDistance = rcSC.left - rcKB.left;
		iLeftRelPos = rcKB.left - rcDlg.left;
	}

    // Hide the smartcard icon if not required and move over the
    // keyboard icon and press c-a-d message
    if (!fSmartcard)
    {
        HWND hwndSmartcard = GetDlgItem(hDlg, IDC_SMARTCARD);

        // Hide the smartcard puppy
        EnableWindow(hwndSmartcard, FALSE);
        ShowWindow(hwndSmartcard, SW_HIDE);

		// move the kbd icon over to the left
        MoveControls(hDlg, rgidNoSmartcard, ARRAYSIZE(rgidNoSmartcard), 
            iDistance, 0, FALSE /*Don't size parent*/);
    } 
	else 
	{
        RECT rcKB, rcDlg;

		GetWindowRect(hDlg, &rcDlg);
        GetWindowRect(GetDlgItem(hDlg, IDC_KEYBOARD), &rcKB);

		if ((rcKB.left - rcDlg.left) != iLeftRelPos)
		{
			// the kbd icon needs to be moved to the right
	        HWND hwndSmartcard = GetDlgItem(hDlg, IDC_SMARTCARD);

			MoveControls(hDlg, rgidNoSmartcard, ARRAYSIZE(rgidNoSmartcard), 
				iDistance * (-1), 0, FALSE /*Don't size parent*/);
		
			EnableWindow(hwndSmartcard, TRUE);
			ShowWindow(hwndSmartcard, SW_SHOW);
		}
	}
}

BOOL FastUserSwitchingEnabled ()
{
	//
	// BUGBUG : isn't there any global variable or function which can provide this information?
	// fast user switching is enabled if multiple users are allowed, and if its not server.
	//

	OSVERSIONINFOEX OsVersion;
    ZeroMemory(&OsVersion, sizeof(OSVERSIONINFOEX));
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx( (LPOSVERSIONINFO ) &OsVersion);

	return (OsVersion.wProductType == VER_NT_WORKSTATION && ShellIsMultipleUsersEnabled());

}


BOOL GetSessionZeroUser(LPTSTR szUser)
{
	WINSTATIONINFORMATION WSInfo;
    ULONG Length;


	if (WinStationQueryInformation(
				SERVERNAME_CURRENT,
				0,
				WinStationInformation,
				&WSInfo,
				sizeof(WINSTATIONINFORMATION),
				&Length))
	{
		if ((WSInfo.ConnectState == State_Active ||  WSInfo.ConnectState == State_Disconnected) &&
			WSInfo.UserName[0] )
		{
			if (WSInfo.Domain[0])
			{
				lstrcpy(szUser, WSInfo.Domain);
				lstrcat(szUser, TEXT("\\"));
			}
			else
			{
				lstrcpy(szUser, TEXT(""));
			}

			lstrcat(szUser, WSInfo.UserName);
			return TRUE;
		}
	}

	return FALSE;
}

// ==========================================================================================
// welcome dialog has 2 formats, one that looks like logon normal welcome dialog , another 
// that looks like "Computer Locked" dialog. When user connects to session 0 from remote (tsclient) 
// the  dialog that appears at console need to change to "Computer Locked". so if session 0 is in 
// use, and if this session is created at active console. we change welcome dialog to look like 
// "Computer locked" dialog.
// This function ComputerInUseMessage does most of the stuff related to switching these 
// dialog controls.
// Parameters:
// HWND hDlg - dialog window handle, 
// BOOL bShowLocked - if true show locked dialog, if false show normal logon dialog. 
// BOOL bInit - TRUE when this function is called for the first time.
// ==========================================================================================

BOOL ComputerInUseMessage(PGLOBALS pGlobals, HWND hDlg, BOOL bShowLocked, BOOL bInit, BOOL bSmartCard)
{
	int i;
	LONG DlgHeight;
	RECT rc;

	// locked controls.
	UINT rgidLocked[] = {IDC_STATIC_LOCKEDGROUP, IDD_LOCKED_ICON, IDD_LOCKED_LINE, IDD_LOCKED_NAME_INFO, IDD_LOCKED_INSTRUCTIONS};
	UINT rgidWelcome[] = {IDC_STATIC_WELCOMEGROUP, IDC_SMARTCARD, IDC_KEYBOARD, IDC_PRESSCAD, IDD_CTRL_DEL_MSG, IDC_HELPLINK};
	int nLockedControls = sizeof(rgidLocked) / sizeof(rgidLocked[0]);
	int nWelcomeControls = sizeof(rgidWelcome) / sizeof(rgidWelcome[0]); 

	struct DlgControl
	{
		HWND hWnd;
		RECT rect;
	};

	static RECT  LockedControls[sizeof(rgidLocked) / sizeof(rgidLocked[0])];
	static RECT  WelcomeControls[sizeof(rgidWelcome) / sizeof(rgidWelcome[0])];
	static bCurrentlyLocked = FALSE;

	
	if (!bInit && bCurrentlyLocked == bShowLocked)
	{
		// nothing to do.
		return TRUE;
	}

	if (bInit)
	{
		// setup locked icon for the locked dialog box.
		if ( !hLockedIcon )
		{
			hLockedIcon = LoadImage( hDllInstance,
									 MAKEINTRESOURCE( IDI_LOCKED),
									 IMAGE_ICON,
									 0, 0,
									 LR_DEFAULTCOLOR );
		}

		SendMessage( GetDlgItem(hDlg, IDD_LOCKED_ICON),
					 STM_SETICON,
					 (WPARAM)hLockedIcon,
					 0 );


		//
		// when this function is called first time, all controls are visible.
		// remember their positions.
		//

		// remember positions Locked Dialog controls.
		for ( i = 0; i < nLockedControls; i++)
		{
			HWND hWnd = GetDlgItem(hDlg, rgidLocked[i]);
			ASSERT(hWnd);
			GetWindowRect(hWnd, &LockedControls[i] );
			MapWindowPoints(NULL, hDlg, (POINT*) &LockedControls[i], 2);
		}

		// remember positions for Welcome Dialog controls.
		for ( i = 0; i < nWelcomeControls; i++)
		{
			HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
			ASSERT(hWnd);
			GetWindowRect(hWnd, &WelcomeControls[i]);
			
			// in the dialog template welcome controls are placed below locked controls.
			// this is not where they will be placed when dialog is shown. 
			// calculate their actual target positions.
			OffsetRect(&WelcomeControls[i], 0, LockedControls[0].top - LockedControls[0].bottom);

			MapWindowPoints(NULL, hDlg, (POINT*) &WelcomeControls[i], 2);
		}

		// hide group box controls. They were their only for simplifing our control movement calculations.
		ShowWindow(GetDlgItem(hDlg, rgidLocked[0]), SW_HIDE);
		ShowWindow(GetDlgItem(hDlg, rgidWelcome[0]), SW_HIDE);

		// set the dialog right for the first use.
		if (bShowLocked)
		{
			// we want locked desktop dialog, so disable welcome controls.
			for ( i = 0; i < nWelcomeControls; i++)
			{
				
				HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
				ASSERT(hWnd);
				MoveWindow(hWnd, 0,  0, 0, 0, FALSE);
				ShowWindow(hWnd, SW_HIDE);
				EnableWindow(hWnd, FALSE);
			}
		}
		else
		{
			// we want to welcome dialog, so remove locked desktop controls.
			for ( i = 1; i < nLockedControls; i++)
			{
				HWND hWnd = GetDlgItem(hDlg, rgidLocked[i]);
				ASSERT(hWnd);
				MoveWindow(hWnd, 0,  0, 0, 0, FALSE);
				ShowWindow(hWnd, SW_HIDE);
				EnableWindow(hWnd, FALSE);
			}

			// and move welcome controls to their proper positions. (i.e move them up)
			for ( i = 1; i < nWelcomeControls; i++)
			{
				HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
				ASSERT(hWnd);
				EnableWindow(hWnd, TRUE);
				ShowWindow(hWnd, SW_SHOW);
				MoveWindow(hWnd, WelcomeControls[i].left,  WelcomeControls[i].top, WelcomeControls[i].right - WelcomeControls[i].left, WelcomeControls[i].bottom - WelcomeControls[i].top, FALSE);
			}

		}

		// set the right size for the dialog window.
		GetWindowRect(hDlg, &rc);
		MapWindowPoints(NULL, GetParent(hDlg), (LPPOINT)&rc, 2);
		DlgHeight = rc.bottom - rc.top;

		if (bShowLocked)
		{
			DlgHeight -= WelcomeControls[0].bottom - WelcomeControls[0].top;
		}
		else
		{
			DlgHeight -= LockedControls[0].bottom - LockedControls[0].top;
		}
		
		SetWindowPos(hDlg, NULL, 0, 0, rc.right - rc.left, DlgHeight, SWP_NOZORDER|SWP_NOMOVE);

	}
	else
	{
		if (bShowLocked)
		{
			for ( i = 1; i < nLockedControls; i++)
			{
				HWND hWnd = GetDlgItem(hDlg, rgidLocked[i]);
				ASSERT(hWnd);
				EnableWindow(hWnd, TRUE);
				ShowWindow(hWnd, SW_SHOW);
				MoveWindow(hWnd, LockedControls[i].left,  LockedControls[i].top, LockedControls[i].right - LockedControls[i].left, LockedControls[i].bottom - LockedControls[i].top, FALSE);
			}

			for ( i = 1; i < nWelcomeControls; i++)
			{
				
				HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
				ASSERT(hWnd);
				MoveWindow(hWnd, 0,  0, 0, 0, FALSE);
				ShowWindow(hWnd, SW_HIDE);
				EnableWindow(hWnd, FALSE);
			}

		}
		else
		{
			for ( i = 1; i < nLockedControls; i++)
			{
				
				HWND hWnd = GetDlgItem(hDlg, rgidLocked[i]);
				ASSERT(hWnd);
				MoveWindow(hWnd, 0,  0, 0, 0, FALSE);
				ShowWindow(hWnd, SW_HIDE);
				EnableWindow(hWnd, FALSE);
			}

			for ( i = 1; i < nWelcomeControls; i++)
			{
				
				HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
				ASSERT(hWnd);
				EnableWindow(hWnd, TRUE);
				ShowWindow(hWnd, SW_SHOW);
				MoveWindow(hWnd, WelcomeControls[i].left,  WelcomeControls[i].top, WelcomeControls[i].right - WelcomeControls[i].left, WelcomeControls[i].bottom - WelcomeControls[i].top, FALSE);
			}
		}

		GetWindowRect(hDlg, &rc);
		MapWindowPoints(NULL, GetParent(hDlg), (LPPOINT)&rc, 2);
		if (bShowLocked)
			DlgHeight = rc.bottom - rc.top - (WelcomeControls[0].bottom - WelcomeControls[0].top) + (LockedControls[0].bottom - LockedControls[0].top);
		else
			DlgHeight = rc.bottom - rc.top + (WelcomeControls[0].bottom - WelcomeControls[0].top) - (LockedControls[0].bottom - LockedControls[0].top);
			
		SetWindowPos(hDlg, NULL, 0, 0, rc.right - rc.left, DlgHeight, SWP_NOZORDER|SWP_NOMOVE);
	}

	if (!bShowLocked)
	{
		SetCadMessage(hDlg, pGlobals, bSmartCard);

		// let SetIcons hide SmartCard icon if required.
		SetIcons(hDlg, bSmartCard);
	}
	else
	{
		TCHAR szUser[USERNAME_LENGTH + DOMAIN_LENGTH + 2];
		TCHAR szMessage[MAX_STRING_BYTES];
		TCHAR szFinalMessage[MAX_STRING_BYTES];
		if (GetSessionZeroUser(szUser))
		{
			LoadString(hDllInstance, IDS_LOCKED_EMAIL_NFN_MESSAGE, szMessage, MAX_STRING_BYTES);
			_snwprintf(szFinalMessage, sizeof(szFinalMessage)/sizeof(TCHAR), szMessage, szUser );
		}
		else
		{
			//
			// for some reason we could not get the current session zero user.
			//
			LoadString(hDllInstance, IDS_LOCKED_NO_USER_MESSAGE, szFinalMessage, MAX_STRING_BYTES);
		}
		
		SetDlgItemText(hDlg, IDD_LOCKED_NAME_INFO, szFinalMessage);
	}

	//
	// update the dialog box caption, accordingly
	//
	{
			TCHAR szCaption[MAX_CAPTION_LENGTH];
			LoadString(hDllInstance, bShowLocked ? IDS_CAPTION_LOCKED_DIALOG : IDS_CAPTION_WELCOME_DIALOG, szCaption, ARRAYSIZE(szCaption));
			if ( szCaption[0] != TEXT('\0') )
				SetWindowText( hDlg, szCaption );
	}

	InvalidateRect(hDlg, NULL, TRUE);
	bCurrentlyLocked = bShowLocked;

	return TRUE;
}

/***************************************************************************\
* FUNCTION: WelcomeDlgProc
*
* PURPOSE:  Processes messages for welcome dialog
*
* RETURNS:  MSGINA_DLG_SUCCESS     - the user has pressed the SAS
*           DLG_SCREEN_SAVER_TIMEOUT - the screen-saver should be started
*           DLG_LOGOFF()    - a logoff/shutdown request was received
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR WINAPI
WelcomeDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HBRUSH hbrWindow = NULL;
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
	static BOOL bSmartCard = FALSE;
	static BOOL bSessionZeroInUse = FALSE;
	static int iSessionRegistrationCount = 0;

    switch (message) {

        case WM_INITDIALOG:
        {
			extern BOOL fEscape;
            ULONG_PTR Value ;

            pGlobals = (PGLOBALS) lParam ;
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pGlobals);

            hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));            

            //
            // The size of the welcome dialog defines the area that
            // we will paint into.
            //

            //
            // Size the window allowing for the caption and other stuff to
            // be dispalyed.
            //


            pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_SMART_CARD_PRESENT,
                                     &Value
                                    );

            if ( Value )
            {
                TCHAR szInsertCard[256];
                bSmartCard = TRUE;
			
                // Also change unlock message to mention smartcard
                LoadString(hDllInstance, IDS_INSERTCARDORSAS_UNLOCK, szInsertCard, ARRAYSIZE(szInsertCard));

                SetDlgItemText(hDlg, IDD_LOCKED_INSTRUCTIONS, szInsertCard);

            }
            else
            {
                bSmartCard = FALSE;
            }

                // Enable SC events (if there is no reader yet, no
                // events will be triggered anyway...)
            pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_USE_SMART_CARD,
                                     1,
                                     NULL
                                    );

            if (GetDisableCad(pGlobals))
            {
                // Set our size to zero so we don't appear
                SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE |
                                         SWP_NOREDRAW | SWP_NOZORDER);

                pWlxFuncs->WlxSasNotify( pGlobals->hGlobalWlx,
                                         WLX_SAS_TYPE_CTRL_ALT_DEL );
            }
            else
            {
                SizeForBranding(hDlg, TRUE);
            }


			if (IsActiveConsoleSession() && 
				NtCurrentPeb()->SessionId != 0 &&
				!FastUserSwitchingEnabled())
			{
				TCHAR szUser[USERNAME_LENGTH + DOMAIN_LENGTH + 2];
				//
				// we are at temporary session created at console...
				//
				
				// check if a user is logged on at console session
				bSessionZeroInUse = GetSessionZeroUser(szUser);
				if (WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, hDlg, NOTIFY_FOR_ALL_SESSIONS))
					iSessionRegistrationCount++;
				
			}
			else
			{
				//
				// this is not active console nonzero session. 
				//
				bSessionZeroInUse = FALSE;
			}

			ComputerInUseMessage(pGlobals, hDlg, bSessionZeroInUse, TRUE, bSmartCard);

            CentreWindow(hDlg); //Center?? :)

            return( TRUE );
        }

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, TRUE, bSessionZeroInUse? COLOR_BTNFACE : COLOR_WINDOW);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_NOTIFY:
        {
            LPNMHDR pnmhdr = (LPNMHDR) lParam;
            int id = (int) wParam;

            // See if this is a help-link click
            if (id == IDC_HELPLINK)
            {
                if ((pnmhdr->code == NM_CLICK) || (pnmhdr->code == NM_RETURN))
                {
                    // Save the coords of the welcome window so we can
                    // position the help window relative to it
                    GetWindowRect(hDlg, &pGlobals->rcWelcome);

                    pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                           hDllInstance, MAKEINTRESOURCE(IDD_WELCOMEHELP_DIALOG),
                           hDlg, HelpDlgProc, (LPARAM) pGlobals);
                }
            }
            return FALSE;
        }

        case WM_CTLCOLORSTATIC:
        {
			if (!bSessionZeroInUse)
			{
				SetBkColor((HDC) wParam, GetSysColor(COLOR_WINDOW));
				SetTextColor((HDC) wParam, GetSysColor(COLOR_WINDOWTEXT));
				return (INT_PTR) hbrWindow;
			}
        }
        break;

        case WM_DESTROY:
        {
			// if registered for console notification unregister now.
			if (iSessionRegistrationCount)
			{
				WinStationUnRegisterConsoleNotification (SERVERNAME_CURRENT, hDlg);
				iSessionRegistrationCount--;
				ASSERT(iSessionRegistrationCount == 0);
			}

            // Save the coords of the welcome window so we can
            // position the logon window at the same position
            GetWindowRect(hDlg, &pGlobals->rcWelcome);

            DeleteObject(hbrWindow);
            return FALSE;
        }
        break;

        case WLX_WM_SAS :
			if ( wParam == WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED ||
				 wParam == WLX_SAS_TYPE_SC_LAST_READER_REMOVED) 
			{
				bSmartCard = (wParam == WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED);

				SetCadMessage(hDlg, pGlobals, bSmartCard);
				SetIcons(hDlg, bSmartCard);
				ShowWindow(hDlg, SW_SHOW);
				return TRUE;
			}

            if ( wParam == WLX_SAS_TYPE_SC_REMOVE )
            {
                return TRUE ;
            }
            break;

		case WM_WTSSESSION_CHANGE:
			
			//
			// its possible, that we unregister for notification in wm_destroy and still receive this notification,
			// as the notification may already have been sent.
			//
			ASSERT(iSessionRegistrationCount < 2);
			if (iSessionRegistrationCount == 1)
			{
				if (lParam == 0)
				{
					//
					// we are interested only in logon/logoff messages from session 0.
					//
					if (wParam == WTS_SESSION_LOGON || wParam == WTS_SESSION_LOGOFF)
					{
						bSessionZeroInUse = (wParam == WTS_SESSION_LOGON);
						ComputerInUseMessage(pGlobals, hDlg, bSessionZeroInUse, FALSE, bSmartCard);

					}
				}
			}
			break;
    }

    // We didn't process this message
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\winutil.c ===
/****************************** Module Header ******************************\
* Module Name: winutil.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implements windows specific utility functions
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

#include "msgina.h"
#include <stdio.h>
#include <wchar.h>

//
// Define this if you want a verbose commentary from these routines
//

// #define VERBOSE_UTILS

#ifdef VERBOSE_UTILS
#define VerbosePrint(s) WLPrint(s)
#else
#define VerbosePrint(s)
#endif

#define LRM 0x200E // UNICODE Left-to-right mark control character
#define RLM 0x200F // UNICODE Left-to-right mark control character



/***************************************************************************\
* SetupSystemMenu
*
* Purpose : Does any manipulation required for a dialog system menu.
*           Should be called during WM_INITDIALOG processing for a dialog
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
VOID
SetupSystemMenu(
    HWND hDlg
    )
{
    // Remove the Close item from the system menu if we don't
    // have a CANCEL button

    if (GetDlgItem(hDlg, IDCANCEL) == NULL) {

        HMENU hMenu = GetSystemMenu(hDlg, FALSE);

        if (hMenu)
        {
            DeleteMenu(hMenu, SC_CLOSE, MF_BYCOMMAND);
        }
    }

}


/***************************************************************************\
* CentreWindow
*
* Purpose : Positions a window so that it is centred in its parent
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
VOID
CentreWindow(
    HWND    hwnd
    )
{
    RECT    rect;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    // Get window rect
    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    // Get parent rect
    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        // Return the desktop windows size (size of main screen)
        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        HWND    hwndParent;
        RECT    rectParent;

        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }

        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    // Centre the child in the parent
    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;

    // Move the child into position
    SetWindowPos(hwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);

    SetForegroundWindow(hwnd);
}


/***************************************************************************\
* SetPasswordFocus
*
* Sets the focus window in a dialog to the first empty control in
* the list IDD_LOGON_DOMAIN, IDD_NEW_PASSWORD
* This routine would normally be called during WM_INITDIALOG processing.
*
* Returns FALSE if the focus was set, otherwise TRUE - this value can
* be used as the return value to the WM_INITDIALOG message.
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
BOOL
SetPasswordFocus(
    HWND    hDlg
    )
{
    int     ids[] = {   IDD_LOGON_NAME,
                        IDD_LOGON_DOMAIN,
                        IDD_LOGON_PASSWORD,
                        IDD_UNLOCK_PASSWORD,
                        IDD_CHANGEPWD_OLD,
                        IDD_CHANGEPWD_NEW,
                        IDD_CHANGEPWD_CONFIRM,
                    };
    SHORT   Index;
    HWND    hwndFocus = NULL;

    // Set focus to first enabled, visible, empty field

    for (Index = 0; Index < sizeof(ids)/sizeof(*ids); Index ++) {

        int     idControl = ids[Index];
        HWND    hwndControl;

        hwndControl = GetDlgItem(hDlg, idControl);
        if (hwndControl != NULL) {

            if ( (GetWindowTextLength(hwndControl) == 0) &&
                 ((GetWindowLong(hwndControl, GWL_STYLE) &
                    (WS_VISIBLE | WS_DISABLED)) == WS_VISIBLE)) {

                hwndFocus = hwndControl;
                break;
            }
        }
    }

    if (hwndFocus != NULL) {
        SetFocus(hwndFocus);
    }

    return(hwndFocus == NULL);
}



//
// Globals used to store cursor handles for SetupCursor
//
static  HCURSOR hCursorArrow = NULL;
static  HCURSOR hCursorWait = NULL;


/***************************************************************************\
* SetupCursor
*
* Sets the cursor to an hourglass if fWait = TRUE, otherwise sets it
* to an arrow.
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
VOID
SetupCursor(
    BOOL    fWait
    )
{
    if (hCursorArrow == NULL) {
        hCursorArrow = LoadCursor(NULL, IDC_ARROW);
    }
    if (hCursorWait == NULL) {
        hCursorWait = LoadCursor(NULL, IDC_WAIT);
    }

    SetCursor(fWait ? hCursorWait : hCursorArrow);
}


/****************************************************************************

   FUNCTION: TimeFieldsToSystemTime

   PURPOSE: Converts a TIME_FIELDS structure into a SYSTEMTIME structure

   RETURNS : nothing

  History:
  05-15-93 RobertRe     Created.
****************************************************************************/

VOID
TimeFieldsToSystemTime(
    IN PTIME_FIELDS TimeFields,
    OUT LPSYSTEMTIME SystemTime
    )
{
    SystemTime->wYear         = TimeFields->Year        ;
    SystemTime->wMonth        = TimeFields->Month       ;
    SystemTime->wDayOfWeek    = TimeFields->Weekday     ;
    SystemTime->wDay          = TimeFields->Day         ;
    SystemTime->wHour         = TimeFields->Hour        ;
    SystemTime->wMinute       = TimeFields->Minute      ;
    SystemTime->wSecond       = TimeFields->Second      ;
    SystemTime->wMilliseconds = TimeFields->Milliseconds;

    return;
}


/****************************************************************************

   FUNCTION: FormatTime

   PURPOSE: Converts a system time into a readable string(in local time).
            if flags contains FT_TIME the time appears in the string
            if flags contains FT_DATE the date appears in the string.
            if both values appear, the string contains date then time.

   RETURNS : TRUE on success, FALSE on failure

****************************************************************************/
BOOL
FormatTime(
   IN PTIME Time,
   IN OUT PWCHAR Buffer,
   IN ULONG BufferLength,
   IN USHORT Flags
   )
{
    NTSTATUS Status;
    TIME_FIELDS TimeFields;
    TIME LocalTime;
    SYSTEMTIME SystemTime;
    DWORD dwDateFlags = DATE_SHORTDATE;

    //
    // Terminate the string in case they didn't pass any flags
    //

    if (BufferLength > 0) {
        Buffer[0] = 0;
    }

    //
    // Convert the system time to local time
    //

    Status = RtlSystemTimeToLocalTime(Time, &LocalTime);
    if (!NT_SUCCESS(Status)) {
        WLPrint(("Failed to convert system time to local time, status = 0x%lx", Status));
        return(FALSE);
    }

    //
    // Split the time into its components
    //

    RtlTimeToTimeFields(&LocalTime, &TimeFields);

    TimeFieldsToSystemTime( &TimeFields, &SystemTime );

    //
    // Format the string
    //

    if (Flags & FT_LTR)
       dwDateFlags |= DATE_LTRREADING;
    else if(Flags & FT_RTL)
        dwDateFlags |= DATE_RTLREADING;

    if (Flags & FT_DATE) {

        int Length;
        WCHAR DateString[256];

        Length = GetDateFormatW(GetUserDefaultLCID(),
                                dwDateFlags,
                                &SystemTime,
                                NULL,
                                DateString,
                                256
                                );

        Length = _snwprintf( Buffer,
                            BufferLength,
                            TEXT("%s"),
                            DateString
                            );

        Buffer += Length;
        BufferLength -= Length;
    }

    if (Flags & FT_TIME) {

        int Length;
        WCHAR TimeString[256];

        if (Flags & FT_DATE) {
            if (BufferLength > 0) {
                *Buffer++ = TEXT(' ');
                BufferLength --;
            }

            // [msadek]; need to insert strong a Unicode control character to simulate
            // a strong run in the opposite base direction to enforce
            // correct display of concatinated string in all cases.
            
            if((BufferLength > 0) && (Flags & FT_RTL)) {
                *Buffer++ = LRM; // simulate an opposite run
                *Buffer++ = RLM; // force RTL display of the time part.
                *Buffer = 0; // in case GetTimeFormat doesn't add anything
                BufferLength -= 2;
            }
            else if((BufferLength > 0) && (Flags & FT_LTR)) {
                *Buffer++ = RLM; // simulate an opposite run
                *Buffer++ = LRM; // force LTR display of the time part.
                *Buffer = 0; // in case GetTimeFormat doesn't add anything
                BufferLength -= 2;            
            }

        }

        Length = GetTimeFormatW(GetUserDefaultLCID(),
                                0,
                                &SystemTime,
                                NULL,
                                TimeString,
                                256
                                );

        _snwprintf(Buffer, BufferLength,
                  TEXT("%s"),
                  TimeString
                  );

    }

    return(TRUE);
}



/***************************************************************************\
* DuplicateUnicodeString
*
* Purpose : Allocates space for new string then copies new into old.
*           The new string is always 0 terminated
*           The new string should be free using RtlFreeUnicodeString()
*
* Returns : TRUE on success, FALSE on failure
*
* History:
* 11-04-92 Davidc       Created.
* 05-29-98 DSheldon     Modified so that no uni->ansi->uni translation occurs
\***************************************************************************/

BOOL
DuplicateUnicodeString(
    PUNICODE_STRING OutString,
    PUNICODE_STRING InString
    )
{
    *OutString = *InString ;

    OutString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, InString->Length + sizeof(WCHAR) );
    if ( OutString->Buffer )
    {
        RtlCopyMemory( OutString->Buffer,
                       InString->Buffer,
                       InString->Length );

        OutString->Buffer[ OutString->Length / sizeof( WCHAR ) ] = L'\0';
        OutString->MaximumLength = OutString->Length + sizeof( WCHAR );
    }


    return (OutString->Buffer != NULL);
}

/***************************************************************************\
* UnicodeStringToString
*
* Purpose : Converts a unicode string to it's local format and allocates
*           space for it. The returned NULL terminated string can be freed
*           using Free()
*
* Returns : Pointer to NULL terminated string or NULL on failure.
*
* History:
* 11-04-92 Davidc       Created.
\***************************************************************************/
LPTSTR
UnicodeStringToString(
    PUNICODE_STRING UnicodeString
    )
{
    LPTSTR String;
    ULONG BytesRequired = sizeof(TCHAR)*(UnicodeString->Length + 1);

    String = Alloc(BytesRequired);
    if (String != NULL) {

        if (UnicodeString->Length && UnicodeString->Buffer ) {
            lstrcpy(String, UnicodeString->Buffer);
        } else {
            Free(String);
            String = 0;
        }
    }

    return(String);
}


/***************************************************************************\
* FUNCTION: OpenIniFileUserMapping
*
* PURPOSE:  Forces the ini file mapping apis to reference the current user's
*           registry.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   24-Aug-92 Davidc       Created.
*
\***************************************************************************/

BOOL
OpenIniFileUserMapping(
    PGLOBALS pGlobals
    )
{
    BOOL Result;
    HANDLE ImpersonationHandle;

    //
    // Impersonate the user
    //

    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

    if (ImpersonationHandle == NULL) {
        DebugLog((DEB_ERROR, "OpenIniFileUserMapping failed to impersonate user"));
        return(FALSE);
    }

    Result = OpenProfileUserMapping();

    if (!Result) {
        DebugLog((DEB_ERROR, "OpenProfileUserMapping failed, error = %d", GetLastError()));
    }

    //
    // Revert to being 'ourself'
    //

    if (!StopImpersonating(ImpersonationHandle)) {
        DebugLog((DEB_ERROR, "OpenIniFileUserMapping failed to revert to self"));
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: CloseIniFileUserMapping
*
* PURPOSE:  Closes the ini file mapping to the user's registry such
*           that future use of the ini apis will fail if they reference
*           the user's registry.
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   24-Aug-92 Davidc       Created.
*
\***************************************************************************/

VOID
CloseIniFileUserMapping(
    PGLOBALS pGlobals
    )
{
    BOOL Result;

    Result = CloseProfileUserMapping();

    if (!Result) {
        DebugLog((DEB_ERROR, "CloseProfileUserMapping failed, error = %d", GetLastError()));
    }

    UNREFERENCED_PARAMETER(pGlobals);
}


/***************************************************************************\
* FUNCTION: AllocAndGetDlgItemText
*
* PURPOSE:  Allocates memory for and returns pointer to a copy of the text
*           in the specified dialog control.
*           The returned string should be freed using Free()
*
* RETURNS:  Pointer to copy of dlg item text, or NULL on failure.
*
* HISTORY:
*
*   9-Sep-92 Davidc       Created.
*
\***************************************************************************/

LPTSTR
AllocAndGetDlgItemText(
    HWND hDlg,
    int  iItem
    )
{
    HWND hwnd;
    LPTSTR String;
    LONG Length;
    LONG BytesRequired;
    LONG LengthCopied;

    //
    // Go find the window handle of the control
    //

    hwnd = GetDlgItem(hDlg, iItem);
    if (hwnd == NULL) {
        DebugLog((DEB_ERROR, "AllocAndGetDlgItemText : Couldn't find control %d in dialog 0x%lx", iItem, hDlg));
        ASSERT(hwnd != NULL);
        return(NULL);
    }

    //
    // Get the length of the control's text
    //

    Length = (LONG)SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);
    if (Length < 0) {
        DebugLog((DEB_ERROR, "AllocAndGetDlgItemText : Dialog control text length < 0 (%d)", Length));
        ASSERT(Length >= 0);
        return(NULL);
    }

    //
    // Calculate the bytes required for the string.
    // The length doesn't include the terminator
    //

    Length ++; // Add one for terminator
    BytesRequired = Length * sizeof(TCHAR);

    String = (LPTSTR)Alloc(BytesRequired);
    if (String == NULL) {
        DebugLog((DEB_ERROR, "AllocAndGetDlgItemText : Failed to allocate %d bytes for dialog control text", BytesRequired));
        return(NULL);
    }

    //
    // Fill in the allocated block with the text
    //

    LengthCopied = (LONG)SendMessage(hwnd, WM_GETTEXT, Length, (LPARAM)String);
    if (LengthCopied != (Length - 1)) {
        DebugLog((DEB_ERROR, "AllocAndGetDlgItemText : WM_GETTEXT for %d chars only copied %d chars", Length-1, LengthCopied));
        ASSERT(LengthCopied == (Length - 1));
        Free(String);
        return(NULL);
    }

    String[Length - 1] = TEXT('\0');
    return(String);
}


/***************************************************************************\
* FUNCTION: AllocAndGetPrivateProfileString
*
* PURPOSE:  Allocates memory for and returns pointer to a copy of the
*           specified profile string
*           The returned string should be freed using Free()
*
* RETURNS:  Pointer to copy of profile string or NULL on failure.
*
* HISTORY:
*
*  12-Nov-92 Davidc       Created.
*
\***************************************************************************/

LPTSTR
AllocAndGetPrivateProfileString(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    LPCTSTR lpDefault,
    LPCTSTR lpFileName
    )
{
    LPTSTR String;
    LPTSTR NewString ;
    LONG LengthAllocated;
    LONG LengthCopied;

    //
    // Pick a random buffer length, if it's not big enough reallocate
    // it and try again until it is.
    //

    LengthAllocated = TYPICAL_STRING_LENGTH;

    String = Alloc(LengthAllocated * sizeof(TCHAR));
    if (String == NULL) {
        DebugLog((DEB_ERROR, "AllocAndGetPrivateProfileString : Failed to allocate %d bytes for string", LengthAllocated * sizeof(TCHAR)));
        return(NULL);
    }

    while (TRUE) {

        LengthCopied = GetPrivateProfileString( lpAppName,
                                                lpKeyName,
                                                lpDefault,
                                                String,
                                                LengthAllocated,
                                                lpFileName
                                              );
        //
        // If the returned value is our passed size - 1 (weird way for error)
        // then our buffer is too small. Make it bigger and start over again.
        //

        if (LengthCopied == (LengthAllocated - 1)) {

            VerbosePrint(("AllocAndGetPrivateProfileString: Failed with buffer length = %d, reallocating and retrying", LengthAllocated));

            LengthAllocated *= 2;
            NewString = ReAlloc(String, LengthAllocated * sizeof(TCHAR));
            if (NewString == NULL) {
                Free( String );
                String = NULL ;
                DebugLog((DEB_ERROR, "AllocAndGetPrivateProfileString : Failed to reallocate %d bytes for string", LengthAllocated * sizeof(TCHAR)));
                break;
            }

            String = NewString ;

            //
            // Go back and try to read it again
            //

        } else {

            //
            // Success!
            //

            break;
        }

    }

    return(String);
}


/***************************************************************************\
* FUNCTION: WritePrivateProfileInt
*
* PURPOSE:  Writes out an integer to a profile file
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*  12-Nov-92 Davidc       Created.
*
\***************************************************************************/

BOOL
WritePrivateProfileInt(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    UINT Value,
    LPCTSTR lpFileName
    )
{
    NTSTATUS Status;
    TCHAR String[30];
    UNICODE_STRING UniString;

    UniString.MaximumLength = 30;
    UniString.Buffer = String;

    Status = RtlIntegerToUnicodeString(Value,10,&UniString);

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    return (WritePrivateProfileString(lpAppName, lpKeyName, UniString.Buffer, lpFileName));

}


/***************************************************************************\
* FUNCTION: AllocAndExpandEnvironmentStrings
*
* PURPOSE:  Allocates memory for and returns pointer to buffer containing
*           the passed string expanded to include environment strings
*           The returned buffer should be freed using Free()
*
* RETURNS:  Pointer to expanded string or NULL on failure.
*
* HISTORY:
*
*  21-Dec-92 Davidc       Created.
*
\***************************************************************************/

LPTSTR
AllocAndExpandEnvironmentStrings(
    LPCTSTR lpszSrc
    )
{
    LPTSTR String;
    LONG LengthAllocated;
    LONG LengthCopied;

    //
    // Pick a random buffer length, if it's not big enough reallocate
    // it and try again until it is.
    //

    LengthAllocated = lstrlen(lpszSrc) + TYPICAL_STRING_LENGTH;

    String = Alloc(LengthAllocated * sizeof(TCHAR));
    if (String == NULL) {
        DebugLog((DEB_ERROR, "AllocAndExpandEnvironmentStrings : Failed to allocate %d bytes for string", LengthAllocated * sizeof(TCHAR)));
        return(NULL);
    }

    while (TRUE) {

        LengthCopied = ExpandEnvironmentStrings( lpszSrc,
                                                 String,
                                                 LengthAllocated
                                               );
        if (LengthCopied == 0) {
            DebugLog((DEB_ERROR, "AllocAndExpandEnvironmentStrings : ExpandEnvironmentStrings failed, error = %d", GetLastError()));
            Free(String);
            String = NULL;
            break;
        }

        //
        // If the buffer was too small, make it bigger and try again
        //

        if (LengthCopied > LengthAllocated) {

            VerbosePrint(("AllocAndExpandEnvironmentStrings: Failed with buffer length = %d, reallocating to %d and retrying (retry should succeed)", LengthAllocated, LengthCopied));

            String = ReAlloc(String, LengthCopied * sizeof(TCHAR));
            if (String == NULL) {
                DebugLog((DEB_ERROR, "AllocAndExpandEnvironmentStrings : Failed to reallocate %d bytes for string", LengthAllocated * sizeof(TCHAR)));
                break;
            }

            //
            // Go back and try to expand the string again
            //

        } else {

            //
            // Success!
            //

            break;
        }

    }

    return(String);
}


/***************************************************************************\
* FUNCTION: AllocAndRegEnumKey
*
* PURPOSE:  Allocates memory for and returns pointer to buffer containing
*           the next registry sub-key name under the specified key
*           The returned buffer should be freed using Free()
*
* RETURNS:  Pointer to sub-key name or NULL on failure. The reason for the
*           error can be obtains using GetLastError()
*
* HISTORY:
*
*  21-Dec-92 Davidc       Created.
*
\***************************************************************************/

LPTSTR
AllocAndRegEnumKey(
    HKEY hKey,
    DWORD iSubKey
    )
{
    LPTSTR String;
    LONG LengthAllocated;

    //
    // Pick a random buffer length, if it's not big enough reallocate
    // it and try again until it is.
    //

    LengthAllocated = TYPICAL_STRING_LENGTH;

    String = Alloc(LengthAllocated * sizeof(TCHAR));
    if (String == NULL) {
        DebugLog((DEB_ERROR, "AllocAndRegEnumKey : Failed to allocate %d bytes for string", LengthAllocated * sizeof(TCHAR)));
        return(NULL);
    }

    while (TRUE) {

        DWORD Error = RegEnumKey(hKey, iSubKey, String, LengthAllocated);
        if (Error == ERROR_SUCCESS) {
            break;
        }

        if (Error != ERROR_MORE_DATA) {

            if (Error != ERROR_NO_MORE_ITEMS) {
                DebugLog((DEB_ERROR, "AllocAndRegEnumKey : RegEnumKey failed, error = %d", Error));
            }

            Free(String);
            String = NULL;
            SetLastError(Error);
            break;
        }

        //
        // The buffer was too small, make it bigger and try again
        //

        VerbosePrint(("AllocAndRegEnumKey: Failed with buffer length = %d, reallocating and retrying", LengthAllocated));

        LengthAllocated *= 2;
        String = ReAlloc(String, LengthAllocated * sizeof(TCHAR));
        if (String == NULL) {
            DebugLog((DEB_ERROR, "AllocAndRegEnumKey : Failed to reallocate %d bytes for string", LengthAllocated * sizeof(TCHAR)));
            break;
        }
    }

    return(String);
}


/***************************************************************************\
* FUNCTION: AllocAndRegQueryValueEx
*
* PURPOSE:  Version of RegQueryValueEx that returns value in allocated buffer.
*           The returned buffer should be freed using Free()
*
* RETURNS:  Pointer to key value or NULL on failure. The reason for the
*           error can be obtains using GetLastError()
*
* HISTORY:
*
*  15-Jan-93 Davidc       Created.
*
\***************************************************************************/

LPTSTR
AllocAndRegQueryValueEx(
    HKEY hKey,
    LPTSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType
    )
{
    LPTSTR String;
    DWORD BytesAllocated;

    //
    // Pick a random buffer length, if it's not big enough reallocate
    // it and try again until it is.
    //

    BytesAllocated = TYPICAL_STRING_LENGTH * sizeof(TCHAR);

    String = Alloc(BytesAllocated);
    if (String == NULL) {
        DebugLog((DEB_ERROR, "AllocAndRegQueryValueEx : Failed to allocate %d bytes for string", BytesAllocated));
        return(NULL);
    }

    while (TRUE) {

        DWORD Error;
        DWORD BytesReturned = BytesAllocated;

        Error = RegQueryValueEx(hKey,
                                lpValueName,
                                lpReserved,
                                lpType,
                                (LPBYTE)String,
                                &BytesReturned);
        if (Error == ERROR_SUCCESS) {
            break;
        }

        if (Error != ERROR_MORE_DATA) {

            DebugLog((DEB_ERROR, "AllocAndRegQueryValueEx : RegQueryValueEx failed, error = %d", Error));
            Free(String);
            String = NULL;
            SetLastError(Error);
            break;
        }

        //
        // The buffer was too small, make it bigger and try again
        //

        VerbosePrint(("AllocAndRegQueryValueEx: Failed with buffer length = %d bytes, reallocating and retrying", BytesAllocated));

        BytesAllocated *= 2;
        String = ReAlloc(String, BytesAllocated);
        if (String == NULL) {
            DebugLog((DEB_ERROR, "AllocAndRegQueryValueEx : Failed to reallocate %d bytes for string", BytesAllocated));
            break;
        }
    }

    return(String);
}

/***************************************************************************\
* FUNCTION: ReadWinlogonBoolValue
*
* PURPOSE:  Determines the correct BOOL value for the requested
*           value name by first looking up the machine preference
*           and then checking for policy
*
* RETURNS:  TRUE or FALSE
*
* HISTORY:
*
*   EricFlo 10-14-98 Created
*
\***************************************************************************/

BOOL
ReadWinlogonBoolValue (LPTSTR lpValueName, BOOL bDefault)
{
    BOOL bResult;
    HKEY hKey;
    DWORD dwSize, dwType;


    //
    // Get the machine preference first
    //

    bResult = GetProfileInt(APPLICATION_NAME, lpValueName, bDefault);


    //
    // Check for a machine policy
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY,
                     0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        dwSize = sizeof(bResult);
        RegQueryValueEx(hKey, lpValueName, 0, &dwType,
                        (LPBYTE)&bResult, &dwSize);

        RegCloseKey (hKey);
    }

    return bResult;
}

/***************************************************************************\
* HandleComboBoxOK
*
* Deals with UI requirements when OK is selected in a dialog when the
* focus is on or in a combo-box.
*
* This routine should be called from a dialog proc that contains a
* combo-box when a WM_COMMAND, IDOK is received.
*
* Returns TRUE if the message was dealt with and the caller should ignore it,
* FALSE if this routine did nothing with it and the caller should process it
* normally.
*
* History:
* 24-Sep-92 Davidc       Created.
\***************************************************************************/
BOOL
HandleComboBoxOK(
    HWND    hDlg,
    int     ComboBoxId
    )
{
    HWND hwndFocus = GetFocus();
    HWND hwndCB = GetDlgItem(hDlg, ComboBoxId);

    //
    // Hitting enter on a combo-box with the list showing should simply
    // hide the list.
    // We check for focus window being a child of the combo-box to
    // handle non-list style combo-boxes which have the focus on
    // the child edit control.
    //

    if ((hwndFocus == hwndCB) || IsChild(hwndCB, hwndFocus)) {

        if (SendMessage(hwndCB, CB_GETDROPPEDSTATE, 0, 0)) {

            //
            // Make the list-box disappear and we're done.
            //

            SendMessage(hwndCB, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0);
            return(TRUE);
        }
    }

    //
    // We didn't do anything
    //

    return(FALSE);
}


/***************************************************************************\
* FUNCTION: EncodeMultiSzW
*
* PURPOSE:  Converts a multi-sz string and encodes it to look like
*           a single string.
*
*           We replace the terminators between strings
*           with the TERMINATOR_REPLACEMENT character. We replace
*           existing occurrences of the replacement character with
*           two of them.
*
* RETURNS:  Pointer to encoded string or NULL on failure.
*           The returned buffer should be freed using Free()
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

#define TERMINATOR_REPLACEMENT  TEXT(',')

LPWSTR
EncodeMultiSzW(
    IN LPWSTR MultiSz
    )
{
    DWORD Length;
    DWORD NewLength;
    LPWSTR NewBuffer;
    LPWSTR p, q;
    DWORD ExtraCharacters;

    //
    // First calculate the length of the new string (with replacements)
    //

    p = MultiSz;
    ExtraCharacters = 0;

    while (*p) {
        while (*p) {
            if (*p == TERMINATOR_REPLACEMENT) {
                ExtraCharacters ++;
            }
            p ++;
        }
        p ++;
    }

    Length = (DWORD)(p - MultiSz); // p points at 'second' (final) null terminator
    NewLength = Length + ExtraCharacters;

    //
    // Allocate space for the new string
    //

    NewBuffer = Alloc((NewLength + 1) * sizeof(WCHAR));
    if (NewBuffer == NULL) {
        DebugLog((DEB_ERROR, "EncodeMultiSz: failed to allocate space for %d bytes", (NewLength + 1) * sizeof(WCHAR)));
        return(NULL);
    }

    //
    // Copy the string into the new buffer making replacements as we go
    //

    p = MultiSz;
    q = NewBuffer;

    while (*p) {
        while (*p) {

            *q = *p;

            if (*p == TERMINATOR_REPLACEMENT) {
                q ++;
                *q = TERMINATOR_REPLACEMENT;
            }

            p ++;
            q ++;
        }

        *q = TERMINATOR_REPLACEMENT;

        p ++;
        q ++;
    }

    ASSERT((DWORD)(q - NewBuffer) == NewLength);

    //
    // Add terminator
    //

    *q = 0;


    return(NewBuffer);
}


/***************************************************************************\
* TimeoutMessageBox
*
* Same as a normal message box, but times out if there is no user input
* for the specified number of seconds
* For convenience, this api takes string resource ids rather than string
* pointers as input. The resources are loaded from the .exe module
*
* 12-05-91 Davidc       Created.
\***************************************************************************/

INT_PTR
TimeoutMessageBox(
    HWND hwnd,
    PGLOBALS pGlobals,
    UINT IdText,
    UINT IdCaption,
    UINT wType,
    TIMEOUT Timeout
    )
{
    TCHAR    CaptionBuffer[MAX_STRING_BYTES];
    PTCHAR   Caption = CaptionBuffer;
    TCHAR    Text[MAX_STRING_BYTES];

    LoadString(hDllInstance, IdText, Text, MAX_STRING_LENGTH);

    if (IdCaption != 0) {
        LoadString(hDllInstance, IdCaption, Caption, MAX_STRING_LENGTH);
    } else {
        Caption = NULL;
    }

    return TimeoutMessageBoxlpstr(hwnd, pGlobals, Text, Caption, wType, Timeout);
}


/***************************************************************************\
* TimeoutMessageBoxlpstr
*
* Same as a normal message box, but times out if there is no user input
* for the specified number of seconds
*
* 12-05-91 Davidc       Created.
\***************************************************************************/

INT_PTR
TimeoutMessageBoxlpstr(
    HWND hwnd,
    PGLOBALS pGlobals,
    LPTSTR Text,
    LPTSTR Caption,
    UINT wType,
    TIMEOUT Timeout
    )
{
    INT_PTR DlgResult;
    BOOL    fStatusHostHidden;

    fStatusHostHidden = _Shell_LogonStatus_IsHidden();
    _Shell_LogonStatus_Hide();

    // Set up input timeout

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, Timeout);

    DlgResult = pWlxFuncs->WlxMessageBox(   pGlobals->hGlobalWlx,
                                            hwnd,
                                            Text,
                                            Caption,
                                            wType);

    if (!fStatusHostHidden)
    {
        _Shell_LogonStatus_Show();
    }

    return(DlgResult);
}

PWSTR
DupString(PWSTR pszString)
{
    DWORD   cbString;
    PWSTR   pszNewString;

    cbString = (DWORD) (wcslen(pszString) + 1) * sizeof(WCHAR);
    pszNewString = LocalAlloc(LMEM_FIXED, cbString);
    if (pszNewString)
    {
        CopyMemory(pszNewString, pszString, cbString);
    }
    return(pszNewString);
}

PWSTR
DupUnicodeString(PUNICODE_STRING    pString)
{
    PWSTR   pszNewString;

    if (pString->Length)
    {
        pszNewString = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, pString->Length + sizeof(WCHAR));
        if (pszNewString)
        {
            CopyMemory(pszNewString, pString->Buffer, pString->Length);
        }
    }
    else

        pszNewString = NULL;

    return(pszNewString);
}

/***************************************************************************\
* FUNCTION: EnableDomainForUPN
*
* PURPOSE:  Enables or disables the domain text box based on whether or not
*           a UPN-style name is typed into the username box.
*
* RETURNS:  none
*
* HISTORY:
*
*   04-17-1998 dsheldon created
*
\***************************************************************************/
void EnableDomainForUPN(HWND hwndUsername, HWND hwndDomain)
{
    BOOL fEnable;

    // Get the string the user is typing
    TCHAR* pszLogonName;
    int cchBuffer = (int)SendMessage(hwndUsername, WM_GETTEXTLENGTH, 0, 0) + 1;

    pszLogonName = (TCHAR*) Alloc(cchBuffer * sizeof(TCHAR));
    if (pszLogonName != NULL)
    {
        SendMessage(hwndUsername, WM_GETTEXT, (WPARAM) cchBuffer, (LPARAM) pszLogonName);

        // Disable the domain combo if the user is using a
        // UPN (if there is a "@") - ie foo@microsoft.com
        fEnable = (NULL == wcschr(pszLogonName, TEXT('@')));

        EnableWindow(hwndDomain, fEnable);

        Free(pszLogonName);
    }
}

// TRUE if we must always hide the domain box (local logon, UPN, smartcard only)
// FALSE if this policy isn't set or is set to 0x0
BOOL ForceNoDomainUI()
{
    DWORD dwPolicyVal = 0;
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_QUERY_VALUE, &hkey))
    {
        DWORD cbData = sizeof (dwPolicyVal);
        DWORD dwType;

        if (ERROR_SUCCESS != RegQueryValueEx(hkey, NODOMAINCOMBO, 0, &dwType, (LPBYTE) &dwPolicyVal, &cbData))
        {
            dwPolicyVal = 0;
        }

        RegCloseKey(hkey);
    }

    return (0 != dwPolicyVal);
}

DWORD GetReasonSelection(HWND hwndCombo)
{
    DWORD dwResult;
    PREASON pReason;
    int iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != (int) CB_ERR) {
        pReason = (PREASON) ComboBox_GetItemData(hwndCombo, iItem);
        dwResult = pReason->dwCode;
    } else {
        dwResult = SHTDN_REASON_UNKNOWN;
    }

    return dwResult;
}

VOID SetReasonDescription(HWND hwndCombo, HWND hwndStatic)
{
    PREASON pReason;
    int iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != CB_ERR) {
        pReason = (PREASON) ComboBox_GetItemData(hwndCombo, iItem);
        SetWindowText(hwndStatic, pReason->szDesc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\wlsec.h ===
/****************************** Module Header ******************************\
* Module Name: security.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define various winlogon security-related routines
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

extern PSID gLocalSid;     // Initialized in 'InitializeSecurityGlobals'
extern PSID gAdminSid;     // Initialized in 'InitializeSecurityGlobals'
extern PSID pWinlogonSid;  // Initialized in 'InitializeSecurityGlobals'

PVOID
FormatPasswordCredentials(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PUNICODE_STRING Password,
    IN BOOLEAN Unlock,
    IN OPTIONAL PLUID LogonId,
    OUT PULONG Size
    );

PVOID
FormatSmartCardCredentials(
    IN PUNICODE_STRING Pin,
    IN PVOID SmartCardInfo,
    IN BOOLEAN Unlock,
    IN OPTIONAL PLUID LogonId,
    OUT PULONG Size
    );


NTSTATUS
WinLogonUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthInfo,
    IN ULONG AuthInfoSize,
    IN PSID LogonSid,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PNTSTATUS SubStatus,
    OUT POPTIMIZED_LOGON_STATUS OptimizedLogonStatus
    );


BOOL
UnlockLogon(
    PGLOBALS pGlobals,
    IN BOOL SmartCardUnlock,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString,
    OUT PNTSTATUS Status,
    OUT PBOOL IsAdmin,
    OUT PBOOL IsLoggedOnUser,
    OUT PVOID *pProfileBuffer,
    OUT ULONG *pProfileBufferLength
    );


BOOL
EnablePrivilege(
    ULONG Privilege,
    BOOL Enable
    );


BOOL
TestTokenForAdmin(
    HANDLE Token
    );

BOOL
TestUserForAdmin(
    PGLOBALS pGlobals,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString
    );


BOOL
TestUserPrivilege(
    HANDLE UserToken,
    ULONG Privilege
    );

VOID
HidePassword(
    PUCHAR Seed OPTIONAL,
    PUNICODE_STRING Password
    );


VOID
RevealPassword(
    PUNICODE_STRING HiddenPassword
    );

VOID
ErasePassword(
    PUNICODE_STRING Password
    );

BOOL
InitializeAuthentication(
    IN PGLOBALS pGlobals
    );

HANDLE
ImpersonateUser(
    PUSER_PROCESS_DATA UserProcessData,
    HANDLE      ThreadHandle
    );


BOOL
StopImpersonating(
    HANDLE  ThreadHandle
    );


PSECURITY_DESCRIPTOR
CreateUserThreadTokenSD(
    PSID    UserSid,
    PSID    WinlogonSid
    );

VOID
FreeSecurityDescriptor(
    PSECURITY_DESCRIPTOR    SecurityDescriptor
    );

VOID
InitializeSecurityGlobals(
    VOID
    );

VOID
FreeSecurityGlobals(
    VOID
    );

VOID
HashPassword(
    PUNICODE_STRING Password,
    PUCHAR HashBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\i386\oemhard.h ===
VOID InitializeOEMId(VOID);
BOOL IsNEC_PC9800(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\i386\oemhard.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    OEMHard.c

Abstract:

Author:

Revision History:

--*/

#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#include "msgina.h"
#include "machinep.h"

#if defined(_X86_)

ULONG
RegGetMachineIdentifierValue(
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the machine identifier information and get the
    value.

Arguments:

    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    LONG   lRet;
    HKEY   hKey;
    DWORD  dwType;
    TCHAR  tchData[100];
    PTCHAR ptchData = tchData;
    DWORD  dwData = sizeof(tchData);
    int    cchCompareF, cchCompareN;
    LCID   lcid;

    //
    // Set default as PC/AT
    //

    *Value = MACHINEID_MS_PCAT;

    //
    // Open registry key
    //

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,       // hRootKey
                         REGISTRY_HARDWARE_SYSTEM, // SubKey
                         0,                        // Reserved
                         KEY_READ,                 // Read Op.
                         &hKey );                  // hKey

    if( lRet != ERROR_SUCCESS ) return( lRet );

    //
    // Read registry key
    //

ReTryRead:

    lRet = RegQueryValueEx( hKey,                        // kKey
                            REGISTRY_MACHINE_IDENTIFIER, // ValueName
                            NULL,                        // Reserved
                            &dwType,                     // Data Type
                            (LPBYTE)ptchData,            // Data buffer
                            &dwData );                   // Data buffer size

    if( lRet != ERROR_SUCCESS ) {

        if( lRet != ERROR_MORE_DATA ) goto Exit1;

        //
        // the Buffer is too small to store the data, we retry with
        // large buffer.
        //

        dwData += 2;

        ptchData = LocalAlloc( LMEM_FIXED , dwData );

        if( ptchData == NULL ) {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit1;
        }

        goto ReTryRead;
    }

    //
    // Determine platform.
    //

    lcid = MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
                     SORT_DEFAULT                                    );

    cchCompareF = lstrlen( FUJITSU_FMR_NAME );
    cchCompareN = lstrlen( NEC_PC98_NAME );

    if( CompareString( lcid,             // Locale id
                       NORM_IGNORECASE,  // Ignoare case
                       ptchData,         // String A.
                       cchCompareF,      // length of string A to compare
                       FUJITSU_FMR_NAME, // String B.
                       cchCompareF )     // length of string B to compare
        == 2                             // String A == String B
      ) {

        //
        // Fujitsu FMR Series.
        //

        *Value = MACHINEID_FUJITSU_FMR;

    } else if( CompareString( lcid,             // Locale id
                              NORM_IGNORECASE,  // Igonre case
                              ptchData,         // String A.
                              cchCompareN,      // length of string A to compare
                              NEC_PC98_NAME,    // String B.
                              cchCompareN )     // length of string B to compare
               == 2                             // String A == String B
             ) {

        //
        // NEC PC-9800 Seriss
        //

        *Value = MACHINEID_NEC_PC98;

    } else {

        //
        // Standard PC/AT comapatibles
        //

        *Value = MACHINEID_MS_PCAT;

    }

Exit1:

    RegCloseKey( hKey );

    return( lRet );
}

DWORD dwMachineId = MACHINEID_MS_PCAT;

VOID InitializeOEMId(VOID)
{
    RegGetMachineIdentifierValue(&dwMachineId);
}

BOOL IsNEC_PC9800(VOID)
{
    return((dwMachineId & PC_9800_COMPATIBLE) ? TRUE : FALSE);
}
#endif // defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\msgina\wlsec.c ===
/****************************** Module Header ******************************\
* Module Name: security.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Handles security aspects of winlogon operation.
*
* History:
* 12-05-91 Davidc       Created - mostly taken from old winlogon.c
\***************************************************************************/

#include "msgina.h"
#include "authmon.h"
#pragma hdrstop
#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>
#include <secint.h>
#include <wincrypt.h>
#include <sclogon.h>
#include <md5.h>
#include <align.h>
#include <ginacomn.h>

//
// 'Constants' used in this module only.
//
SID_IDENTIFIER_AUTHORITY gSystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY gLocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
PSID gLocalSid;     // Initialized in 'InitializeSecurityGlobals'
PSID gAdminSid;     // Initialized in 'InitializeSecurityGlobals'
PSID pWinlogonSid;  // Initialized in 'InitializeSecurityGlobals'

//
// This structure wraps parameters passed to the background logon thread.
// The background logon is queued to the thread pool after a fast-cached
// logon to update the cached credentials.
//

typedef struct _BACKGROUND_LOGON_PARAMETERS {
    ULONG AuthenticationPackage;
    ULONG AuthenticationInformationLength;
    PVOID AuthenticationInformation;
    PWCHAR UserSidString;
    HANDLE LsaHandle;
} BACKGROUND_LOGON_PARAMETERS, *PBACKGROUND_LOGON_PARAMETERS;

//
// Routines to check for & perform fast cached logon if policy allows it.
//

NTSTATUS 
AttemptCachedLogon(
    HANDLE LsaHandle,
    PLSA_STRING OriginName,
    SECURITY_LOGON_TYPE LogonType,
    ULONG AuthenticationPackage,
    PVOID AuthenticationInformation,
    ULONG AuthenticationInformationLength,
    PTOKEN_GROUPS LocalGroups,
    PTOKEN_SOURCE SourceContext,
    PVOID *ProfileBuffer,
    PULONG ProfileBufferLength,
    PLUID LogonId,
    PHANDLE UserToken,
    PQUOTA_LIMITS Quotas,
    PNTSTATUS SubStatus,
    POPTIMIZED_LOGON_STATUS OptimizedLogonStatus
    );

DWORD 
BackgroundLogonWorker(
    PBACKGROUND_LOGON_PARAMETERS LogonParameters
    );

#define PASSWORD_HASH_STRING    TEXT("Long string used by msgina inside of winlogon to hash out the password")

typedef LONG    ACEINDEX;
typedef ACEINDEX *PACEINDEX;

typedef struct _MYACE {
    PSID    Sid;
    ACCESS_MASK AccessMask;
    UCHAR   InheritFlags;
} MYACE;
typedef MYACE *PMYACE;

BOOL
InitializeWindowsSecurity(
    PGLOBALS pGlobals
    );

BOOL
InitializeAuthentication(
    IN PGLOBALS pGlobals
    );

/***************************************************************************\
* SetMyAce
*
* Helper routine that fills in a MYACE structure.
*
* History:
* 02-06-92 Davidc       Created
\***************************************************************************/
VOID
SetMyAce(
    PMYACE MyAce,
    PSID Sid,
    ACCESS_MASK Mask,
    UCHAR InheritFlags
    )
{
    MyAce->Sid = Sid;
    MyAce->AccessMask= Mask;
    MyAce->InheritFlags = InheritFlags;
}

/***************************************************************************\
* CreateAccessAllowedAce
*
* Allocates memory for an ACCESS_ALLOWED_ACE and fills it in.
* The memory should be freed by calling DestroyACE.
*
* Returns pointer to ACE on success, NULL on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PVOID
CreateAccessAllowedAce(
    PSID  Sid,
    ACCESS_MASK AccessMask,
    UCHAR AceFlags,
    UCHAR InheritFlags
    )
{
    ULONG   LengthSid = RtlLengthSid(Sid);
    ULONG   LengthACE = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + LengthSid;
    PACCESS_ALLOWED_ACE Ace;

    Ace = (PACCESS_ALLOWED_ACE)Alloc(LengthACE);
    if (Ace == NULL) {
        DebugLog((DEB_ERROR, "CreateAccessAllowedAce : Failed to allocate ace\n"));
        return NULL;
    }

    Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize = (UCHAR)LengthACE;
    Ace->Header.AceFlags = AceFlags | InheritFlags;
    Ace->Mask = AccessMask;
    RtlCopySid(LengthSid, (PSID)(&(Ace->SidStart)), Sid );

    return(Ace);
}


/***************************************************************************\
* DestroyAce
*
* Frees the memory allocate for an ACE
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
VOID
DestroyAce(
    PVOID   Ace
    )
{
    Free(Ace);
}

/***************************************************************************\
* CreateSecurityDescriptor
*
* Creates a security descriptor containing an ACL containing the specified ACEs
*
* A SD created with this routine should be destroyed using
* DeleteSecurityDescriptor
*
* Returns a pointer to the security descriptor or NULL on failure.
*
* 02-06-92 Davidc       Created.
\***************************************************************************/

PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    PMYACE  MyAce,
    ACEINDEX AceCount
    )
{
    NTSTATUS Status;
    ACEINDEX AceIndex;
    PACCESS_ALLOWED_ACE *Ace;
    PACL    Acl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG   LengthAces;
    ULONG   LengthAcl;
    ULONG   LengthSd;

    //
    // Allocate space for the ACE pointer array
    //

    Ace = (PACCESS_ALLOWED_ACE *)Alloc(sizeof(PACCESS_ALLOWED_ACE) * AceCount);
    if (Ace == NULL) {
        DebugLog((DEB_ERROR, "Failed to allocated ACE array\n"));
        return(NULL);
    }

    //
    // Create the ACEs and calculate total ACE size
    //

    LengthAces = 0;
    for (AceIndex=0; AceIndex < AceCount; AceIndex ++) {
        Ace[AceIndex] = CreateAccessAllowedAce(MyAce[AceIndex].Sid,
                                               MyAce[AceIndex].AccessMask,
                                               0,
                                               MyAce[AceIndex].InheritFlags);
        if (Ace[AceIndex] == NULL) {
            DebugLog((DEB_ERROR, "Failed to allocate ace\n"));
        } else {
            LengthAces += Ace[AceIndex]->Header.AceSize;
        }
    }

    //
    // Calculate ACL and SD sizes
    //

    LengthAcl = sizeof(ACL) + LengthAces;
    LengthSd  = SECURITY_DESCRIPTOR_MIN_LENGTH;

    //
    // Create the ACL
    //

    Acl = Alloc(LengthAcl);

    if (Acl != NULL) {

        Status = RtlCreateAcl(Acl, LengthAcl, ACL_REVISION);
        ASSERT(NT_SUCCESS(Status));

        //
        // Add the ACES to the ACL and destroy the ACEs
        //

        for (AceIndex = 0; AceIndex < AceCount; AceIndex ++) {

            if (Ace[AceIndex] != NULL) {

                Status = RtlAddAce(Acl, ACL_REVISION, 0, Ace[AceIndex],
                                   Ace[AceIndex]->Header.AceSize);

                if (!NT_SUCCESS(Status)) {
                    DebugLog((DEB_ERROR, "AddAce failed, status = 0x%lx", Status));
                }

                DestroyAce( Ace[AceIndex] );
            }
        }

    } else {
        DebugLog((DEB_ERROR, "Failed to allocate ACL\n"));

        for ( AceIndex = 0 ; AceIndex < AceCount ; AceIndex++ )
        {
            if ( Ace[AceIndex] )
            {
                DestroyAce( Ace[ AceIndex ] );
            }
        }
    }

    //
    // Free the ACE pointer array
    //
    Free(Ace);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = Alloc(LengthSd);

    if (SecurityDescriptor != NULL) {

        Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
        ASSERT(NT_SUCCESS(Status));

        //
        // Set the DACL on the security descriptor
        //
        Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, Acl, FALSE);
        if (!NT_SUCCESS(Status)) {
            DebugLog((DEB_ERROR, "SetDACLSD failed, status = 0x%lx", Status));
        }
    } else {

        DebugLog((DEB_ERROR, "Failed to allocate security descriptor\n"));

        Free( Acl );
    }

    //
    // Return with our spoils
    //
    return(SecurityDescriptor);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeSecurityDescriptor
//
//  Synopsis:   Frees security descriptors created by CreateSecurityDescriptor
//
//  Arguments:  [SecurityDescriptor] --
//
//  History:    5-09-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
FreeSecurityDescriptor(
    PSECURITY_DESCRIPTOR    SecurityDescriptor
    )
{
    PACL    Acl;
    BOOL    Present;
    BOOL    Defaulted;

    Acl = NULL;

    GetSecurityDescriptorDacl( SecurityDescriptor,
                             &Present,
                             &Acl,
                             &Defaulted );

    if ( Acl )
    {
        Free( Acl );
    }

    Free( SecurityDescriptor );

}
/***************************************************************************\
* CreateUserThreadTokenSD
*
* Creates a security descriptor to protect tokens on user threads
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PSECURITY_DESCRIPTOR
CreateUserThreadTokenSD(
    PSID    UserSid,
    PSID    WinlogonSid
    )
{
    MYACE   Ace[2];
    ACEINDEX AceCount = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    ASSERT(UserSid != NULL);    // should always have a non-null user sid

    //
    // Define the User ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             UserSid,
             TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS |
             TOKEN_ADJUST_DEFAULT | TOKEN_QUERY |
             TOKEN_DUPLICATE | TOKEN_IMPERSONATE | READ_CONTROL,
             0
             );

    //
    // Define the Winlogon ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             WinlogonSid,
             TOKEN_ALL_ACCESS,
             0
             );

    // Check we didn't goof
    ASSERT((sizeof(Ace) / sizeof(MYACE)) >= AceCount);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = CreateSecurityDescriptor(Ace, AceCount);
    if (SecurityDescriptor == NULL) {
        DebugLog((DEB_ERROR, "failed to create user process token security descriptor\n"));
    }

    return(SecurityDescriptor);

}


/***************************************************************************\
* InitializeSecurityGlobals
*
* Initializes the various global constants (mainly Sids used in this module.
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
VOID
InitializeSecurityGlobals(
    VOID
    )
{
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    ULONG   SidLength;

    //
    // Get our sid so it can be put on object ACLs
    //

    SidLength = RtlLengthRequiredSid(1);
    pWinlogonSid = (PSID)Alloc(SidLength);
    if (!pWinlogonSid)
    {
        //
        // We're dead.  Couldn't even allocate memory for a measly SID...
        //
        return;
    }

    RtlInitializeSid(pWinlogonSid,  &SystemSidAuthority, 1);
    *(RtlSubAuthoritySid(pWinlogonSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;

    //
    // Initialize the local sid for later
    //

    Status = RtlAllocateAndInitializeSid(
                    &gLocalSidAuthority,
                    1,
                    SECURITY_LOCAL_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &gLocalSid
                    );

    if (!NT_SUCCESS(Status)) {
        WLPrint(("Failed to initialize local sid, status = 0x%lx", Status));
    }

    //
    // Initialize the admin sid for later
    //

    Status = RtlAllocateAndInitializeSid(
                    &gSystemSidAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &gAdminSid
                    );
    if (!NT_SUCCESS(Status)) {
        WLPrint(("Failed to initialize admin alias sid, status = 0x%lx", Status));
    }

}

VOID
FreeSecurityGlobals(
    VOID
    )

{
    RtlFreeSid(gAdminSid);
    RtlFreeSid(gLocalSid);
    LocalFree(pWinlogonSid);
}

/***************************************************************************\
* InitializeAuthentication
*
* Initializes the authentication service. i.e. connects to the authentication
* package using the Lsa.
*
* On successful return, the following fields of our global structure are
* filled in :
*       LsaHandle
*       SecurityMode
*       AuthenticationPackage
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
BOOL
InitializeAuthentication(
    IN PGLOBALS pGlobals
    )
{
    NTSTATUS Status;
    STRING LogonProcessName;

    if (!EnablePrivilege(SE_TCB_PRIVILEGE, TRUE))
    {
        DebugLog((DEB_ERROR, "Failed to enable SeTcbPrivilege!\n"));
        return(FALSE);
    }

    //
    // Hookup to the LSA and locate our authentication package.
    //

    RtlInitString(&LogonProcessName, "Winlogon\\MSGina");
    Status = LsaRegisterLogonProcess(
                 &LogonProcessName,
                 &pGlobals->LsaHandle,
                 &pGlobals->SecurityMode
                 );

if (!NT_SUCCESS(Status)) {

        DebugLog((DEB_ERROR, "LsaRegisterLogonProcess failed:  %#x\n", Status));
        return(FALSE);
    }

    return TRUE;
}

PVOID
FormatPasswordCredentials(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PUNICODE_STRING Password,
    IN BOOLEAN Unlock,
    IN OPTIONAL PLUID LogonId,
    OUT PULONG Size
    )
{
    PKERB_INTERACTIVE_LOGON KerbAuthInfo;
    ULONG AuthInfoSize;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    PBYTE Where;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)(&Password->Length);
    Seed = SeedAndLength->Seed;


    //
    // Build the authentication information buffer
    //

    if (Seed != 0) {
        RevealPassword( Password );
    }

    AuthInfoSize = sizeof(KERB_INTERACTIVE_UNLOCK_LOGON) +
                    UserName->Length + 2 +
                    Domain->Length + 2 +
                    Password->Length + 2 ;



    KerbAuthInfo = Alloc(AuthInfoSize);
    if (KerbAuthInfo == NULL) {
        DebugLog((DEB_ERROR, "failed to allocate memory for authentication buffer\n"));
        return( NULL );
    }

    //
    // This authentication buffer will be used for a logon attempt
    //

    if (Unlock)
    {
        ASSERT(ARGUMENT_PRESENT(LogonId));
        KerbAuthInfo->MessageType = KerbWorkstationUnlockLogon ;
        ((PKERB_INTERACTIVE_UNLOCK_LOGON) KerbAuthInfo)->LogonId = *LogonId;
        Where = (PBYTE) (KerbAuthInfo) + sizeof(KERB_INTERACTIVE_UNLOCK_LOGON);
    }
    else
    {
        KerbAuthInfo->MessageType = KerbInteractiveLogon ;
        Where = (PBYTE) (KerbAuthInfo + 1);
    }

    //
    // Copy the user name into the authentication buffer
    //

    KerbAuthInfo->UserName.Length =
                (USHORT) sizeof(TCHAR) * (USHORT) lstrlen(UserName->Buffer);

    KerbAuthInfo->UserName.MaximumLength =
                KerbAuthInfo->UserName.Length + sizeof(TCHAR);

    KerbAuthInfo->UserName.Buffer = (PWSTR)Where;
    lstrcpy(KerbAuthInfo->UserName.Buffer, UserName->Buffer);


    //
    // Copy the domain name into the authentication buffer
    //

    KerbAuthInfo->LogonDomainName.Length =
                 (USHORT) sizeof(TCHAR) * (USHORT) lstrlen(Domain->Buffer);

    KerbAuthInfo->LogonDomainName.MaximumLength =
                 KerbAuthInfo->LogonDomainName.Length + sizeof(TCHAR);

    KerbAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                 ((PBYTE)(KerbAuthInfo->UserName.Buffer) +
                                 KerbAuthInfo->UserName.MaximumLength);

    lstrcpy(KerbAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

    //
    // Copy the password into the authentication buffer
    // Hide it once we have copied it.  Use the same seed value
    // that we used for the original password in pGlobals.
    //

    KerbAuthInfo->Password.Length =
                 (USHORT) sizeof(TCHAR) * (USHORT) lstrlen(Password->Buffer);

    KerbAuthInfo->Password.MaximumLength =
                 KerbAuthInfo->Password.Length + sizeof(TCHAR);

    KerbAuthInfo->Password.Buffer = (PWSTR)
                                 ((PBYTE)(KerbAuthInfo->LogonDomainName.Buffer) +
                                 KerbAuthInfo->LogonDomainName.MaximumLength);
    lstrcpy(KerbAuthInfo->Password.Buffer, Password->Buffer);

    if ( Seed != 0 )
    {
        HidePassword( &Seed, Password);
    }

    HidePassword( &Seed, (PUNICODE_STRING) &KerbAuthInfo->Password);

    *Size = AuthInfoSize ;

    return KerbAuthInfo ;
}

PVOID
FormatSmartCardCredentials(
    PUNICODE_STRING Pin,
    PVOID SmartCardInfo,
    IN BOOLEAN Unlock,
    IN OPTIONAL PLUID LogonId,
    OUT PULONG Size
    )
{
    PKERB_SMART_CARD_LOGON KerbAuthInfo;
    ULONG AuthInfoSize;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    PULONG ScInfo ;
    PUCHAR Where ;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)(&Pin->Length);
    Seed = SeedAndLength->Seed;


    //
    // Build the authentication information buffer
    //

    ScInfo = (PULONG) SmartCardInfo ;


    if (Seed != 0) {
        RevealPassword( Pin );
    }

    AuthInfoSize = sizeof( KERB_SMART_CARD_UNLOCK_LOGON ) +
                    ROUND_UP_COUNT(Pin->Length + 2, 8) + *ScInfo ;

    KerbAuthInfo = (PKERB_SMART_CARD_LOGON) LocalAlloc( LMEM_FIXED, AuthInfoSize );

    if ( !KerbAuthInfo )
    {
        return NULL ;
    }

    if (Unlock)
    {
        ASSERT(ARGUMENT_PRESENT(LogonId));
        KerbAuthInfo->MessageType = KerbSmartCardUnlockLogon ;
        ((PKERB_SMART_CARD_UNLOCK_LOGON) KerbAuthInfo)->LogonId = *LogonId;
        Where = (PUCHAR) (KerbAuthInfo) + sizeof(KERB_SMART_CARD_UNLOCK_LOGON) ;
    }
    else
    {
        KerbAuthInfo->MessageType = KerbSmartCardLogon ;
        Where = (PUCHAR) (KerbAuthInfo + 1) ;
    }


    KerbAuthInfo->Pin.Buffer = (PWSTR) Where ;
    KerbAuthInfo->Pin.Length = Pin->Length ;
    KerbAuthInfo->Pin.MaximumLength = Pin->Length + 2 ;

    RtlCopyMemory( Where, Pin->Buffer, Pin->Length + 2 );

    Where += ROUND_UP_COUNT(Pin->Length + 2, 8) ;

    if ( Seed != 0 )
    {
        HidePassword( &Seed, Pin );
    }


    KerbAuthInfo->CspDataLength = *ScInfo ;
    KerbAuthInfo->CspData = Where ;

    RtlCopyMemory( Where, SmartCardInfo, *ScInfo );

    *Size = AuthInfoSize ;

    return KerbAuthInfo ;

}

/***************************************************************************\
* LogonUser
*
* Calls the Lsa to logon the specified user.
*
* The LogonSid and a LocalSid is added to the user's groups on successful logon
*
* For this release, password lengths are restricted to 255 bytes in length.
* This allows us to use the upper byte of the String.Length field to
* carry a seed needed to decode the run-encoded password.  If the password
* is not run-encoded, the upper byte of the String.Length field should
* be zero.
*
* NOTE: This function will LocalFree the passed in AuthInfo buffer.
*
* On successful return, LogonToken is a handle to the user's token,
* the profile buffer contains user profile information.
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
NTSTATUS
WinLogonUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthInfo,
    IN ULONG AuthInfoSize,
    IN PSID LogonSid,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *pProfileBuffer,
    OUT PULONG pProfileBufferLength,
    OUT PNTSTATUS pSubStatus,
    OUT POPTIMIZED_LOGON_STATUS OptimizedLogonStatus
    )
{
    NTSTATUS Status;
    STRING OriginName;
    TOKEN_SOURCE SourceContext;
    PTOKEN_GROUPS TokenGroups = NULL;
    PMSV1_0_INTERACTIVE_PROFILE UserProfile;
    PWCHAR UserSidString;
    DWORD ErrorCode;
    DWORD LogonCacheable;
    DWORD DaysToCheck;
    DWORD DaysToExpiry;
    LARGE_INTEGER CurrentTime;

    BOOLEAN UserLoggedOnUsingCache;   

    DebugLog((DEB_TRACE, "  LsaHandle = %x\n", LsaHandle));
    DebugLog((DEB_TRACE, "  AuthenticationPackage = %d\n", AuthenticationPackage));
#if DBG
    if (!RtlValidSid(LogonSid))
    {
        DebugLog((DEB_ERROR, "LogonSid is invalid!\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }
#endif

    //
    // Initialize source context structure
    //

    strncpy(SourceContext.SourceName, "User32  ", sizeof(SourceContext.SourceName)); // LATER from res file
    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "failed to allocate locally unique id, status = 0x%lx", Status));
        goto cleanup;
    }

    //
    // Get any run-encoding information out of the way
    // and decode the password.  This creates a window
    // where the cleartext password will be in memory.
    // Keep it short.
    //
    // Save the seed so we can use the same one again.
    //



    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "Winlogon");

    //
    // Create logon token groups
    //

#define TOKEN_GROUP_COUNT   2 // We'll add the local SID and the logon SID

    TokenGroups = (PTOKEN_GROUPS)Alloc(sizeof(TOKEN_GROUPS) +
                  (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES));
    if (TokenGroups == NULL) {
        DebugLog((DEB_ERROR, "failed to allocate memory for token groups"));
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    //
    // Fill in the logon token group list
    //

    TokenGroups->GroupCount = TOKEN_GROUP_COUNT;
    TokenGroups->Groups[0].Sid = LogonSid;
    TokenGroups->Groups[0].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;
    TokenGroups->Groups[1].Sid = gLocalSid;
    TokenGroups->Groups[1].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT;


    //
    // If logging on Interactive to the console, try cached logon first.
    //

    UserLoggedOnUsingCache = FALSE;

    if (LogonType == Interactive) {

        //
        // Optimized logon that does not hit the network does not
        // make sense for local logins.
        //

        if (IsMachineDomainMember()) {

            Status = AttemptCachedLogon(LsaHandle,
                                        &OriginName,
                                        CachedInteractive,
                                        AuthenticationPackage,
                                        AuthInfo,
                                        AuthInfoSize,
                                        TokenGroups,
                                        &SourceContext,
                                        pProfileBuffer,
                                        pProfileBufferLength,
                                        LogonId,
                                        LogonToken,
                                        Quotas,
                                        pSubStatus,
                                        OptimizedLogonStatus);

            if (NT_SUCCESS(Status)) {

                UserLoggedOnUsingCache = TRUE;

                //
                // AttemptCachedLogon will take care of freeing AuthInfo.
                //

                AuthInfo = NULL;
            }

        } else {

            *OptimizedLogonStatus = OLS_MachineIsNotDomainMember;
        }
            
    } else {

        *OptimizedLogonStatus = OLS_NonCachedLogonType;
    }
    
    
    //
    // If we have not been able to log the user on using cached credentials,
    // fall back to real network logon.
    //

    if (!UserLoggedOnUsingCache) {

        Status = LsaLogonUser (
                     LsaHandle,
                     &OriginName,
                     LogonType,
                     AuthenticationPackage,
                     AuthInfo,
                     AuthInfoSize,
                     TokenGroups,
                     &SourceContext,
                     pProfileBuffer,
                     pProfileBufferLength,
                     LogonId,
                     LogonToken,
                     Quotas,
                     pSubStatus
                     );

    }

#if 0
    // If this failed it may be because we are doing a UPN logon. Try again
    // with no domain
    if (!NT_SUCCESS(Status))
    {
        *pfUpnLogon = TRUE;

        PKERB_INTERACTIVE_LOGON pinfo = (PKERB_INTERACTIVE_LOGON) AuthInfo;

        // Null out domain string
        pinfo->LogonDomainName.Length = 0;
        pinfo->LogonDomainName.Buffer[0] = 0;

        Status = LsaLogonUser (
                     LsaHandle,
                     &OriginName,
                     LogonType,
                     AuthenticationPackage,
                     AuthInfo,
                     AuthInfoSize,
                     TokenGroups,
                     &SourceContext,
                     pProfileBuffer,
                     pProfileBufferLength,
                     LogonId,
                     LogonToken,
                     Quotas,
                     pSubStatus
                     );
    }
#endif
    
    //
    // If this was a successful login perform tasks for optimized logon
    // maintenance.
    //
    
    if (NT_SUCCESS(Status)) {

        UserProfile = *pProfileBuffer;

        //
        // Get user's SID in string form.
        //

        UserSidString = GcGetSidString(*LogonToken);

        if (UserSidString) {

            //
            // Save whether we did an optimized logon or the reason why
            // we did not.
            //

            GcSetOptimizedLogonStatus(UserSidString, *OptimizedLogonStatus);

            //
            // Check if this was a cached logon.
            //

            if (!(UserProfile->UserFlags & LOGON_CACHED_ACCOUNT))
            {
                FgPolicyRefreshInfo UserPolicyRefreshInfo;

                //
                // If this is not a cached logon because user's profile
                // does not allow it, we have to force group policy to 
                // apply synchronously.
                //

                ErrorCode = GcCheckIfProfileAllowsCachedLogon(&UserProfile->HomeDirectory,
                                                              &UserProfile->ProfilePath,    
                                                              UserSidString,
                                                              &LogonCacheable);

                if (ErrorCode != ERROR_SUCCESS || !LogonCacheable) {

                    //
                    // If policy is already sync, leave it alone.
                    //

                    GetNextFgPolicyRefreshInfo( UserSidString, &UserPolicyRefreshInfo );
                    if ( UserPolicyRefreshInfo.mode == GP_ModeAsyncForeground )
                    {
                        UserPolicyRefreshInfo.reason = GP_ReasonNonCachedCredentials;
                        UserPolicyRefreshInfo.mode = GP_ModeSyncForeground;
                        SetNextFgPolicyRefreshInfo( UserSidString, UserPolicyRefreshInfo );
                    }
                }
		//
                // Determine if we should allow next logon to be optimized.
                // We may have disallowed optimizing next logon via this 
                // mechanism because
                // - Our background logon attempt failed e.g. password has
                //   changed, account has been disabled etc.
                // - We are entering the password expiry warning period.
                //   When we do an optimized logon warning dialogs don't show
                //   because cached logon invents password expiry time field.
                //
                // We will allow optimized logon again if this was a non 
                // cached logon and user got authenticated by the DC, unless
                // we are entering the password expiry warning period.
                //

                if (LogonType == Interactive) {

                    //
                    // Are we entering password expiry warning period?
                    //

                    GetSystemTimeAsFileTime((FILETIME*) &CurrentTime);

                    DaysToCheck = GetPasswordExpiryWarningPeriod();

                    if (GetDaysToExpiry(&CurrentTime,
                                        &UserProfile->PasswordMustChange,
                                        &DaysToExpiry)) {

                        if (DaysToExpiry > DaysToCheck) {                

                            //
                            // We passed this check too. We can allow optimized
                            // logon next time. Note that, even if we allow it,
                            // policy, profile, logon scripts etc. might still
                            // disallow it!
                            //

                            GcSetNextLogonCacheable(UserSidString, TRUE);
                        }
                    }
                }
            }

            GcDeleteSidString(UserSidString);
        }
    }

                
cleanup:

    if (AuthInfo) {
        LocalFree(AuthInfo);
    }

    if (TokenGroups) {
        Free(TokenGroups);
    }

    return(Status);
}

/***************************************************************************\
* EnablePrivilege
*
* Enables/disables the specified well-known privilege in the current thread
* token if there is one, otherwise the current process token.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
BOOL
EnablePrivilege(
    ULONG Privilege,
    BOOL Enable
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    //
    // Try the thread token first
    //

    Status = RtlAdjustPrivilege(Privilege,
                                (BOOLEAN)Enable,
                                TRUE,
                                &WasEnabled);

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege(Privilege,
                                    (BOOLEAN)Enable,
                                    FALSE,
                                    &WasEnabled);
    }


    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to %ws privilege : 0x%lx, status = 0x%lx", Enable ? TEXT("enable") : TEXT("disable"), Privilege, Status));
        return(FALSE);
    }

    return(TRUE);
}



/***************************************************************************\
* TestTokenForAdmin
*
* Returns TRUE if the token passed represents an admin user, otherwise FALSE
*
* The token handle passed must have TOKEN_QUERY access.
*
* History:
* 05-06-92 Davidc       Created
\***************************************************************************/
BOOL
TestTokenForAdmin(
    HANDLE Token
    )
{
    BOOL FoundAdmin ;
    TOKEN_TYPE Type ;
    NTSTATUS Status ;
    ULONG Actual ;
    HANDLE ImpToken ;

    Status = NtQueryInformationToken( Token,
                                      TokenType,
                                      (PVOID) &Type,
                                      sizeof( Type ),
                                      &Actual );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    if ( Type == TokenPrimary )
    {
        //
        // Need an impersonation token for this:
        //

        if ( DuplicateTokenEx( Token,
                               TOKEN_IMPERSONATE | TOKEN_READ,
                               NULL,
                               SecurityImpersonation,
                               TokenImpersonation,
                               &ImpToken ) )
        {
            if ( !CheckTokenMembership( ImpToken, gAdminSid, &FoundAdmin ) )
            {
                FoundAdmin = FALSE ;
            }

            CloseHandle( ImpToken );
        }
        else
        {
            FoundAdmin = FALSE ;
        }


    }
    else
    {
        if ( !CheckTokenMembership( Token, gAdminSid, &FoundAdmin ) )
        {
            FoundAdmin = FALSE ;
        }

    }

    return FoundAdmin ;
}


/***************************************************************************\
* TestUserForAdmin
*
* Returns TRUE if the named user is an admin. This is done by attempting to
* log the user on and examining their token.
*
* NOTE: The password will be erased upon return to prevent it from being
*       visually identifiable in a pagefile.
*
* History:
* 03-16-92 Davidc       Created
\***************************************************************************/
BOOL
TestUserForAdmin(
    PGLOBALS pGlobals,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString
    )
{
    NTSTATUS    Status, SubStatus, IgnoreStatus;
    UNICODE_STRING      UserNameString;
    UNICODE_STRING      DomainString;
    PVOID       ProfileBuffer;
    ULONG       ProfileBufferLength;
    QUOTA_LIMITS Quotas;
    HANDLE      Token;
    BOOL        UserIsAdmin;
    LUID        LogonId;
    PVOID       AuthInfo ;
    ULONG       AuthInfoSize ;

    RtlInitUnicodeString(&UserNameString, UserName);
    RtlInitUnicodeString(&DomainString, Domain);

    //
    // Temporarily log this new subject on and see if their groups
    // contain the appropriate admin group
    //

    AuthInfo = FormatPasswordCredentials(
                    &UserNameString,
                    &DomainString,
                    PasswordString,
                    FALSE,                      // no unlock
                    NULL,                       // no logon id
                    &AuthInfoSize );

    if ( !AuthInfo )
    {
        return FALSE ;
    }

    Status = WinLogonUser(
                pGlobals->LsaHandle,
                pGlobals->AuthenticationPackage,
                Interactive,
                AuthInfo,
                AuthInfoSize,
                pGlobals->LogonSid,  // any sid will do
                &LogonId,
                &Token,
                &Quotas,
                &ProfileBuffer,
                &ProfileBufferLength,
                &SubStatus,
                &pGlobals->OptimizedLogonStatus);

    RtlEraseUnicodeString( PasswordString );

    //
    // If we couldn't log them on, they're not an admin
    //

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Free up the profile buffer
    //

    IgnoreStatus = LsaFreeReturnBuffer(ProfileBuffer);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    //
    // See if the token represents an admin user
    //

    UserIsAdmin = TestTokenForAdmin(Token);

    //
    // We're finished with the token
    //

    IgnoreStatus = NtClose(Token);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return(UserIsAdmin);
}

BOOL
UnlockLogon(
    PGLOBALS pGlobals,
    IN BOOL SmartCardUnlock,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString,
    OUT PNTSTATUS pStatus,
    OUT PBOOL IsAdmin,
    OUT PBOOL IsLoggedOnUser,
    OUT PVOID *pProfileBuffer,
    OUT ULONG *pProfileBufferLength
    )
{
    NTSTATUS    Status, SubStatus, IgnoreStatus;
    UNICODE_STRING      UserNameString;
    UNICODE_STRING      DomainString;
    QUOTA_LIMITS Quotas;
    HANDLE      Token;
    HANDLE      ImpToken ;
    LUID        LogonId;
    PVOID       AuthInfo ;
    ULONG       AuthInfoSize ;
    ULONG       SidSize ;
    UCHAR       Buffer[ sizeof( TOKEN_USER ) + 8 + SID_MAX_SUB_AUTHORITIES * sizeof(DWORD) ];
    PTOKEN_USER User ;
    PUCHAR  SmartCardInfo ;
    PWLX_SC_NOTIFICATION_INFO ScInfo = NULL;
    PVOID       LocalProfileBuffer = NULL;
    ULONG       LocalProfileBufferLength;

#ifdef SMARTCARD_DOGFOOD
        DWORD StartTime, EndTime;
#endif
    //
    // Assume no admin
    //

    *IsAdmin = FALSE ;
    *IsLoggedOnUser = FALSE ;

    //
    // Bundle up the credentials for passing down to the auth pkgs:
    //

    if ( !SmartCardUnlock )
    {

        RtlInitUnicodeString(&UserNameString, UserName);
        RtlInitUnicodeString(&DomainString, Domain);

        AuthInfo = FormatPasswordCredentials(
                        &UserNameString,
                        &DomainString,
                        PasswordString,
                        TRUE,                   // unlock
                        &pGlobals->LogonId,
                        &AuthInfoSize );

    }
    else
    {
        if ( !pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                       WLX_OPTION_SMART_CARD_INFO,
                                       (PULONG_PTR) &ScInfo ) )
        {
            return FALSE ;
        }

        if ( ScInfo == NULL )
        {
            return FALSE ;
        }

        SmartCardInfo = ScBuildLogonInfo(
                            ScInfo->pszCard,
                            ScInfo->pszReader,
                            ScInfo->pszContainer,
                            ScInfo->pszCryptoProvider );

#ifndef SMARTCARD_DOGFOOD
        LocalFree(ScInfo);
#endif

        if ( SmartCardInfo == NULL )
        {
#ifdef SMARTCARD_DOGFOOD
            LocalFree(ScInfo);
#endif
            return FALSE ;
        }

        AuthInfo = FormatSmartCardCredentials(
                        PasswordString,
                        SmartCardInfo,
                        TRUE,                   // unlock
                        &pGlobals->LogonId,
                        &AuthInfoSize);

        LocalFree( SmartCardInfo );

    }

    //
    // Make sure that worked:
    //

    if ( !AuthInfo )
    {
#ifdef SMARTCARD_DOGFOOD
        if (ScInfo)
            LocalFree(ScInfo);
#endif
        return FALSE ;
    }

#ifdef SMARTCARD_DOGFOOD
        StartTime = GetTickCount();
#endif

    //
    // Initialize profile buffer
    //
    if ( !pProfileBuffer )
    {
        pProfileBuffer = &LocalProfileBuffer;
        pProfileBufferLength = &LocalProfileBufferLength;
    }

    SubStatus = 0;

    Status = WinLogonUser(
                pGlobals->LsaHandle,
                ( SmartCardUnlock ? pGlobals->SmartCardLogonPackage : pGlobals->PasswordLogonPackage ),
                Unlock,
                AuthInfo,
                AuthInfoSize,
                pGlobals->LogonSid,  // any sid will do
                &LogonId,
                &Token,
                &Quotas,
                pProfileBuffer,
                pProfileBufferLength,
                &SubStatus,
                &pGlobals->OptimizedLogonStatus);

     if (SmartCardUnlock) 
     {
        switch (SubStatus)
        {
            case STATUS_SMARTCARD_WRONG_PIN:
            case STATUS_SMARTCARD_CARD_BLOCKED:
            case STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED:
            case STATUS_SMARTCARD_NO_CARD:
            case STATUS_SMARTCARD_NO_KEY_CONTAINER:
            case STATUS_SMARTCARD_NO_CERTIFICATE:
            case STATUS_SMARTCARD_NO_KEYSET:
            case STATUS_SMARTCARD_IO_ERROR:
            case STATUS_SMARTCARD_CERT_EXPIRED:
            case STATUS_SMARTCARD_CERT_REVOKED:
            case STATUS_ISSUING_CA_UNTRUSTED:
            case STATUS_REVOCATION_OFFLINE_C:
            case STATUS_PKINIT_CLIENT_FAILURE:
                
                Status = SubStatus;
                break;
        }
     }

#ifdef SMARTCARD_DOGFOOD
    EndTime = GetTickCount();

    if (SmartCardUnlock) 
    {
        AuthMonitor(
                AuthOperUnlock,
                g_Console,
                &pGlobals->UserNameString,
                &pGlobals->DomainString,
                (ScInfo ? ScInfo->pszCard : NULL),
                (ScInfo ? ScInfo->pszReader : NULL),
                (PKERB_SMART_CARD_PROFILE) pGlobals->Profile,
                EndTime - StartTime,
                Status
                );
    }

    if (ScInfo)
        LocalFree(ScInfo);
#endif

    //
    // Do *NOT* erase the password string.
    //
    // RtlEraseUnicodeString( PasswordString );

    if ( !NT_SUCCESS( Status ) )
    {
        if ( Status == STATUS_ACCOUNT_RESTRICTION )
        {
            Status = SubStatus ;
        }
    }

    *pStatus = Status ;

    //
    // If we couldn't log them on, forget it.
    //

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // No error check - if we can't tell if the user is an admin, then
    // as far as we're concerned, he isn't.
    //

    *IsAdmin = TestTokenForAdmin( Token );

    //
    // Determine if this really is the logged on user:
    //

    User = (PTOKEN_USER) Buffer ;

    Status = NtQueryInformationToken(
                    Token,
                    TokenUser,
                    User,
                    sizeof( Buffer ),
                    &SidSize );

    if ( NT_SUCCESS( Status ) )
    {
        if ( pGlobals->UserProcessData.UserSid )
        {
            if ( DuplicateToken( Token,
                                 SecurityImpersonation,
                                 &ImpToken ) )
            {
                if ( !CheckTokenMembership(ImpToken,
                                           pGlobals->UserProcessData.UserSid,
                                           IsLoggedOnUser ) )
                {
                    *IsLoggedOnUser = FALSE ;
                }

                NtClose( ImpToken );
            }
            else 
            {
                if ( RtlEqualSid( User->User.Sid,
                                  pGlobals->UserProcessData.UserSid ) )
                {
                    *IsLoggedOnUser = TRUE ;
                }
                else 
                {
                    *IsLoggedOnUser = FALSE ;
                }
            }
        }
        else
        {
            *IsLoggedOnUser = FALSE ;
        }
    }

    //
    // If we're using our local buffer pointer, free up the profile buffer
    //
    if ( LocalProfileBuffer )
    {
        IgnoreStatus = LsaFreeReturnBuffer(LocalProfileBuffer);

        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // We're finished with the token
    //

    IgnoreStatus = NtClose(Token);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return( TRUE );
}


/***************************************************************************\
* FUNCTION: ImpersonateUser
*
* PURPOSE:  Impersonates the user by setting the users token
*           on the specified thread. If no thread is specified the token
*           is set on the current thread.
*
* RETURNS:  Handle to be used on call to StopImpersonating() or NULL on failure
*           If a non-null thread handle was passed in, the handle returned will
*           be the one passed in. (See note)
*
* NOTES:    Take care when passing in a thread handle and then calling
*           StopImpersonating() with the handle returned by this routine.
*           StopImpersonating() will close any thread handle passed to it -
*           even yours !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*
\***************************************************************************/

HANDLE
ImpersonateUser(
    PUSER_PROCESS_DATA UserProcessData,
    HANDLE      ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE  UserToken = UserProcessData->UserToken;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ImpersonationToken;
    BOOL ThreadHandleOpened = FALSE;

    if (ThreadHandle == NULL) {

        //
        // Get a handle to the current thread.
        // Once we have this handle, we can set the user's impersonation
        // token into the thread and remove it later even though we ARE
        // the user for the removal operation. This is because the handle
        // contains the access rights - the access is not re-evaluated
        // at token removal time.
        //

        Status = NtDuplicateObject( NtCurrentProcess(),     // Source process
                                    NtCurrentThread(),      // Source handle
                                    NtCurrentProcess(),     // Target process
                                    &ThreadHandle,          // Target handle
                                    THREAD_SET_THREAD_TOKEN,// Access
                                    0L,                     // Attributes
                                    DUPLICATE_SAME_ATTRIBUTES
                                  );
        if (!NT_SUCCESS(Status)) {
            DebugLog((DEB_ERROR, "ImpersonateUser : Failed to duplicate thread handle, status = 0x%lx", Status));
            return(NULL);
        }

        ThreadHandleOpened = TRUE;
    }


    //
    // If the usertoken is NULL, there's nothing to do
    //

    if (UserToken != NULL) {

        //
        // UserToken is a primary token - create an impersonation token version
        // of it so we can set it on our thread
        //

        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            UserProcessData->NewThreadTokenSD);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


        Status = NtDuplicateToken( UserToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES |
                                        TOKEN_QUERY,
                                   &ObjectAttributes,
                                   FALSE,
                                   TokenImpersonation,
                                   &ImpersonationToken
                                 );
        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR, "Failed to duplicate users token to create impersonation thread, status = 0x%lx", Status));

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }



        //
        // Set the impersonation token on this thread so we 'are' the user
        //

        Status = NtSetInformationThread( ThreadHandle,
                                         ThreadImpersonationToken,
                                         (PVOID)&ImpersonationToken,
                                         sizeof(ImpersonationToken)
                                       );
        //
        // We're finished with our handle to the impersonation token
        //

        IgnoreStatus = NtClose(ImpersonationToken);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Check we set the token on our thread ok
        //

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR, "Failed to set user impersonation token on winlogon thread, status = 0x%lx", Status));

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }
    }


    return(ThreadHandle);

}


/***************************************************************************\
* FUNCTION: StopImpersonating
*
* PURPOSE:  Stops impersonating the client by removing the token on the
*           current thread.
*
* PARAMETERS: ThreadHandle - handle returned by ImpersonateUser() call.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* NOTES: If a thread handle was passed in to ImpersonateUser() then the
*        handle returned was one and the same. If this is passed to
*        StopImpersonating() the handle will be closed. Take care !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*
\***************************************************************************/

BOOL
StopImpersonating(
    HANDLE  ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE ImpersonationToken;


    //
    // Remove the user's token from our thread so we are 'ourself' again
    //

    ImpersonationToken = NULL;

    Status = NtSetInformationThread( ThreadHandle,
                                     ThreadImpersonationToken,
                                     (PVOID)&ImpersonationToken,
                                     sizeof(ImpersonationToken)
                                   );
    //
    // We're finished with the thread handle
    //

    IgnoreStatus = NtClose(ThreadHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to remove user impersonation token from winlogon thread, status = 0x%lx", Status));
    }

    return(NT_SUCCESS(Status));
}


/***************************************************************************\
* TestUserPrivilege
*
* Looks at the user token to determine if they have the specified privilege
*
* Returns TRUE if the user has the privilege, otherwise FALSE
*
* History:
* 04-21-92 Davidc       Created
\***************************************************************************/
BOOL
TestUserPrivilege(
    HANDLE UserToken,
    ULONG Privilege
    )
{
    NTSTATUS Status;
    NTSTATUS IgnoreStatus;
    BOOL TokenOpened;
    LUID LuidPrivilege;
    LUID TokenPrivilege;
    PTOKEN_PRIVILEGES Privileges;
    ULONG BytesRequired;
    ULONG i;
    BOOL Found;

    TokenOpened = FALSE;


    //
    // If the token is NULL, get a token for the current process since
    // this is the token that will be inherited by new processes.
    //

    if (UserToken == NULL) {

        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_QUERY,
                     &UserToken
                     );
        if (!NT_SUCCESS(Status)) {
            DebugLog((DEB_ERROR, "Can't open own process token for token_query access"));
            return(FALSE);
        }

        TokenOpened = TRUE;
    }


    //
    // Find out how much memory we need to allocate
    //

    Status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenPrivileges,           // TokenInformationClass
                 NULL,                      // TokenInformation
                 0,                         // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        if (!NT_SUCCESS(Status)) {
            DebugLog((DEB_ERROR, "Failed to query privileges from user token, status = 0x%lx", Status));
        }

        if (TokenOpened) {
            IgnoreStatus = NtClose(UserToken);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        return(FALSE);
    }


    //
    // Allocate space for the privilege array
    //

    Privileges = Alloc(BytesRequired);
    if (Privileges == NULL) {

        DebugLog((DEB_ERROR, "Failed to allocate memory for user privileges"));

        if (TokenOpened) {
            IgnoreStatus = NtClose(UserToken);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        return(FALSE);
    }


    //
    // Read in the user privileges
    //

    Status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenPrivileges,           // TokenInformationClass
                 Privileges,                // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    //
    // We're finished with the token handle
    //

    if (TokenOpened) {
        IgnoreStatus = NtClose(UserToken);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // See if we got the privileges
    //

    if (!NT_SUCCESS(Status)) {

        DebugLog((DEB_ERROR, "Failed to query privileges from user token"));

        Free(Privileges);

        return(FALSE);
    }



    //
    // See if the user has the privilege we're looking for.
    //

    LuidPrivilege = RtlConvertLongToLuid(Privilege);
    Found = FALSE;

    for (i=0; i<Privileges->PrivilegeCount; i++) {

        TokenPrivilege = *((LUID UNALIGNED *) &Privileges->Privileges[i].Luid);
        if (RtlEqualLuid(&TokenPrivilege, &LuidPrivilege))
        {
            Found = TRUE;
            break;
        }

    }


    Free(Privileges);

    return(Found);
}

/***************************************************************************\
* FUNCTION: HidePassword
*
* PURPOSE:  Run-encodes the password so that it is not very visually
*           distinguishable.  This is so that if it makes it to a
*           paging file, it wont be obvious.
*
*           if pGlobals->Seed is zero, then we will allocate and assign
*           a seed value.  Otherwise, the existing seed value is used.
*
*           WARNING - This routine will use the upper portion of the
*           password's length field to store the seed used in encoding
*           password.  Be careful you don't pass such a string to
*           a routine that looks at the length (like and RPC routine).
*
*
* RETURNS:  (None)
*
* NOTES:
*
* HISTORY:
*
*   04-27-93 JimK         Created.
*
\***************************************************************************/
VOID
HidePassword(
    PUCHAR Seed OPTIONAL,
    PUNICODE_STRING Password
    )
{
    PSECURITY_SEED_AND_LENGTH
        SeedAndLength;

    UCHAR
        LocalSeed;

    //
    // If no seed address passed, use our own local seed buffer
    //

    if (Seed == NULL) {
        Seed = &LocalSeed;
        LocalSeed = 0;
    }

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)&Password->Length;
    //ASSERT(*((LPWCH)SeedAndLength+Password->Length) == 0);
    ASSERT((SeedAndLength->Seed) == 0);

    RtlRunEncodeUnicodeString(
        Seed,
        Password
        );

    SeedAndLength->Seed = (*Seed);
    return;
}


/***************************************************************************\
* FUNCTION: RevealPassword
*
* PURPOSE:  Reveals a previously hidden password so that it
*           is plain text once again.
*
* RETURNS:  (None)
*
* NOTES:
*
* HISTORY:
*
*   04-27-93 JimK         Created.
*
\***************************************************************************/
VOID
RevealPassword(
    PUNICODE_STRING HiddenPassword
    )
{
    PSECURITY_SEED_AND_LENGTH
        SeedAndLength;

    UCHAR
        Seed;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)&HiddenPassword->Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    RtlRunDecodeUnicodeString(
           Seed,
           HiddenPassword
           );

    return;
}


/***************************************************************************\
* FUNCTION: ErasePassword
*
* PURPOSE:  zeros a password that is no longer needed.
*
* RETURNS:  (None)
*
* NOTES:
*
* HISTORY:
*
*   04-27-93 JimK         Created.
*
\***************************************************************************/
VOID
ErasePassword(
    PUNICODE_STRING Password
    )
{
    PSECURITY_SEED_AND_LENGTH
        SeedAndLength;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)&Password->Length;
    SeedAndLength->Seed = 0;

    RtlEraseUnicodeString(
        Password
        );

    return;

}

VOID
HashPassword(
    PUNICODE_STRING Password,
    PUCHAR HashBuffer
    )
{
    MD5_CTX Context ;

    MD5Init( &Context );
    MD5Update( &Context, (PUCHAR) Password->Buffer, Password->Length );
    MD5Update( &Context, (PUCHAR) PASSWORD_HASH_STRING, sizeof( PASSWORD_HASH_STRING ) );
    MD5Final( &Context );

    RtlCopyMemory( HashBuffer, 
                   Context.digest, 
                   MD5DIGESTLEN );

}

/***************************************************************************\
* AttemptCachedLogon
*
* Checks to see if we are allowed to use cached credentials to log the user
* in fast, and does so.
*
* Parameters are the same list of parameters passed to LsaLogonUser.
*
* On successful return, LogonToken is a handle to the user's token,
* the profile buffer contains user profile information.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
NTSTATUS 
AttemptCachedLogon(
    HANDLE LsaHandle,
    PLSA_STRING OriginName,
    SECURITY_LOGON_TYPE LogonType,
    ULONG AuthenticationPackage,
    PVOID AuthenticationInformation,
    ULONG AuthenticationInformationLength,
    PTOKEN_GROUPS LocalGroups,
    PTOKEN_SOURCE SourceContext,
    PVOID *ProfileBuffer,
    PULONG ProfileBufferLength,
    PLUID LogonId,
    PHANDLE UserToken,
    PQUOTA_LIMITS Quotas,
    PNTSTATUS SubStatus,
    POPTIMIZED_LOGON_STATUS OptimizedLogonStatus
    )
{
    PWCHAR UserSidString;
    PMSV1_0_INTERACTIVE_PROFILE UserProfile;
    FgPolicyRefreshInfo UserPolicyRefreshInfo;
    PBACKGROUND_LOGON_PARAMETERS LogonParameters;
    OSVERSIONINFOEXW OsVersion;
    NTSTATUS Status;
    DWORD ErrorCode;
    BOOL Success;
    DWORD NextLogonCacheable;
    BOOLEAN UserLoggedOn;
    BOOL RunSynchronous;

    //
    // Initialize locals.
    //

    UserSidString = NULL;
    UserLoggedOn = FALSE;
    LogonParameters = NULL;
    *OptimizedLogonStatus = OLS_Unspecified;
    
    //
    // Verify parameters.
    //

    ASSERT(LogonType == CachedInteractive);

    //
    // Check if SKU allows cached interactive logons.
    //

    ZeroMemory(&OsVersion, sizeof(OsVersion));
    OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);
    Status = RtlGetVersion((POSVERSIONINFOW)&OsVersion);

    if (!NT_SUCCESS(Status)) {
        *OptimizedLogonStatus = OLS_UnsupportedSKU;
        goto cleanup;
    }

    if (OsVersion.wProductType != VER_NT_WORKSTATION) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_UnsupportedSKU;
        goto cleanup;
    }

    //
    // Attempt a cached logon.
    //

    Status = LsaLogonUser(LsaHandle,
                          OriginName,
                          LogonType,
                          AuthenticationPackage,
                          AuthenticationInformation,
                          AuthenticationInformationLength,
                          LocalGroups,
                          SourceContext,
                          ProfileBuffer,
                          ProfileBufferLength,
                          LogonId,
                          UserToken,
                          Quotas,
                          SubStatus);

    //
    // If cached logon was not successful we cannot continue.
    //

    if (!NT_SUCCESS(Status)) {
        *OptimizedLogonStatus = OLS_LogonFailed;
        goto cleanup;
    }

    UserLoggedOn = TRUE;

    //
    // Get user's SID.
    //

    UserSidString = GcGetSidString(*UserToken);

    if (!UserSidString) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        *OptimizedLogonStatus = OLS_InsufficientResources;
        goto cleanup;
    }

    //
    // Check if in last logon of this user we determined we cannot do
    // a cached logon this time.
    //

    ErrorCode = GcGetNextLogonCacheable(UserSidString, &NextLogonCacheable);

    if (ErrorCode == ERROR_SUCCESS && !NextLogonCacheable) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_NextLogonNotCacheable;
        goto cleanup;
    }  

    //
    // Does policy allow cached logons on this machine for the user?
    //

    if (IsSyncForegroundPolicyRefresh(FALSE, *UserToken)) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_SyncMachinePolicy;
        goto cleanup;
    }

    //
    // Check if policy allows cached logon for this user.
    //

    ErrorCode = GetNextFgPolicyRefreshInfo(UserSidString, 
                                           &UserPolicyRefreshInfo);

    if (ErrorCode != ERROR_SUCCESS ||
        UserPolicyRefreshInfo.mode != GP_ModeAsyncForeground) {

        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_SyncUserPolicy;
        goto cleanup;
    }

    //
    // Check if user profile does not support default cached logons.
    // e.g if the user has a remote home directory or a roaming profile etc.
    //

    UserProfile = *ProfileBuffer;

    ErrorCode = GcCheckIfProfileAllowsCachedLogon(&UserProfile->HomeDirectory,
                                                  &UserProfile->ProfilePath,    
                                                  UserSidString,
                                                  &NextLogonCacheable);

    if (ErrorCode != ERROR_SUCCESS || !NextLogonCacheable) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_ProfileDisallows;
        goto cleanup;
    }

    //
    // Check if logon scripts are set to run synchronously.
    //

    RunSynchronous = GcCheckIfLogonScriptsRunSync(UserSidString);

    if (RunSynchronous) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_SyncLogonScripts;
        goto cleanup;
    }

    //
    // We are fine to run with cached logon. We still need to launch a work 
    // item to do a real interactive logon that will update the cache.
    //

    LogonParameters = Alloc(sizeof(*LogonParameters));

    if (!LogonParameters) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        *OptimizedLogonStatus = OLS_InsufficientResources;
        goto cleanup;
    }

    //
    // Initialize the structure so we know what to cleanup.
    //

    ZeroMemory(LogonParameters, sizeof(*LogonParameters));

    LogonParameters->LsaHandle = LsaHandle;

    //
    // Hand over the allocated UserSidString to background logon to cleanup.
    //

    LogonParameters->UserSidString = UserSidString;
    UserSidString = NULL;

    //
    // Hand over AuthenticationInfo structure to background logon. 
    // The password is already hidden.
    //

    LogonParameters->AuthenticationPackage = AuthenticationPackage;
    LogonParameters->AuthenticationInformationLength = AuthenticationInformationLength;

    //
    // Background logon will use the authentication information and free it.
    //

    LogonParameters->AuthenticationInformation = AuthenticationInformation;

    //
    // Queue a work item to perform the background logon to update the cache.
    // This background "logon" has nothing to do with the current user 
    // successfully logging on, logging off etc. So we don't have to monitor
    // those. All it does is to update the cache.
    //

    Success = QueueUserWorkItem(BackgroundLogonWorker,
                                LogonParameters,
                                WT_EXECUTELONGFUNCTION);

    if (!Success) {

        //
        // We want to back out from the cached logon if we could not queue
        // an actual logon to update the cache for the next time.
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;
        *OptimizedLogonStatus = OLS_InsufficientResources;
        goto cleanup;
    }

    //
    // We are done.
    //

    Status = STATUS_SUCCESS;
    *OptimizedLogonStatus = OLS_LogonIsCached;

  cleanup:

    if (!NT_SUCCESS(Status)) {
        //
        // If we failed after logging on the user using cached credentials,
        // we have to cleanup.
        //

        if (UserLoggedOn) {

            //
            // Close the user's token.
            //

            CloseHandle(*UserToken);
        
            //
            // Free the profile buffer.
            //

            if (*ProfileBuffer) {
                LsaFreeReturnBuffer(*ProfileBuffer);
            }
        }

        if (LogonParameters) {

            if (LogonParameters->UserSidString) {
                GcDeleteSidString(LogonParameters->UserSidString);
            }

            Free(LogonParameters);
        }
    }

    if (UserSidString) {                                    
        GcDeleteSidString(UserSidString);
    }

    return Status;  
}


/***************************************************************************\
* BackgroundLogonWorker
*
* If the actual interactive logon was performed using cached credentials
* because of policy, this workitem is queued to perform an actual network
* logon to update the cached information in the security packages.
*
* Authentication information to perform the logon is passed in as the 
* parameter and must be freed when the thread is done.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD 
BackgroundLogonWorker(
    PBACKGROUND_LOGON_PARAMETERS LogonParameters
    )
{
    PMSV1_0_INTERACTIVE_PROFILE Profile;
    HANDLE UserToken;
    LSA_STRING OriginName;
    TOKEN_SOURCE SourceContext;
    QUOTA_LIMITS Quotas;
    PSECURITY_LOGON_SESSION_DATA LogonSessionData;
    LUID LogonId;
    NTSTATUS SubStatus;
    NTSTATUS Status;
    DWORD ErrorCode;
    ULONG ProfileBufferLength;
    ULONG NameBufferNumChars;
    static LONG LogonServicesStarted = 0;
    DWORD MaxWaitTime;
    BOOLEAN UserLoggedOn;
    BOOLEAN ImpersonatingUser;
    WCHAR NameBuffer[UNLEN + 1];
    DWORD DaysToCheck;

    DWORD DaysToExpiry;

    LARGE_INTEGER CurrentTime;
    //
    // Initialize locals.
    //

    Profile = NULL;
    RtlInitString(&OriginName, "Winlogon-Background");
    LogonSessionData = NULL;
    ZeroMemory(&SourceContext, sizeof(SourceContext));
    strncpy(SourceContext.SourceName, "GinaBkg", TOKEN_SOURCE_LENGTH);
    UserLoggedOn = FALSE;
    ImpersonatingUser = FALSE;
    NameBufferNumChars = sizeof(NameBuffer) / sizeof(NameBuffer[0]);

    //
    // Verify parameters.
    //

    ASSERT(LogonParameters);
    ASSERT(LogonParameters->AuthenticationInformation);
    ASSERT(LogonParameters->UserSidString);
    
    //
    // Make sure workstation and netlogon services have started.
    //

    if (!LogonServicesStarted) {

        MaxWaitTime = 120000; // 2 minutes.

        GcWaitForServiceToStart(SERVICE_WORKSTATION, MaxWaitTime);
        GcWaitForServiceToStart(SERVICE_NETLOGON, MaxWaitTime);

        LogonServicesStarted = 1;
    }

    //
    // Try to log the user in to initiate update of cached credentials.
    //

    Status = LsaLogonUser(LogonParameters->LsaHandle,
                          &OriginName,
                          Interactive,
                          LogonParameters->AuthenticationPackage,
                          LogonParameters->AuthenticationInformation,
                          LogonParameters->AuthenticationInformationLength,
                          NULL,
                          &SourceContext,
                          &(PVOID)Profile,
                          &ProfileBufferLength,
                          &LogonId,
                          &UserToken,
                          &Quotas,
                          &SubStatus);

    if (!NT_SUCCESS(Status)) {

        //
        // If the error is real we will force non-cached logon next time.
        //

        if (Status != STATUS_NO_LOGON_SERVERS) {
            GcSetNextLogonCacheable(LogonParameters->UserSidString, FALSE);
        }

        ErrorCode = LsaNtStatusToWinError(Status);
        goto cleanup;
    }

    UserLoggedOn = TRUE;

    //
    // Did we actually end up doing a cached logon?
    //

    if (Profile->UserFlags & LOGON_CACHED_ACCOUNT) {

        //
        // We are done, just cleanup.
        //

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // If we are entering the password expiry warning period, disable optimized
    // logon for next time so warning dialogs get shown. Otherwise for cached
    // logons password expiry date gets invented to be forever in future.
    //

    if (Profile) {

        GetSystemTimeAsFileTime((FILETIME*) &CurrentTime);

        DaysToCheck = GetPasswordExpiryWarningPeriod();

        if (GetDaysToExpiry(&CurrentTime,
                            &Profile->PasswordMustChange,
                            &DaysToExpiry)) {

            if (DaysToCheck >= DaysToExpiry) {                
                GcSetNextLogonCacheable(LogonParameters->UserSidString, FALSE);
            }
        }
    }

    //
    // Make a GetUserName call to update the user name cache. Ignore errors.
    //

    if (!ImpersonateLoggedOnUser(UserToken)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ImpersonatingUser = TRUE;

    GetUserNameEx(NameSamCompatible, NameBuffer, &NameBufferNumChars);

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

  cleanup:

    //
    // Stop impersonation.
    //

    if (ImpersonatingUser) {
        RevertToSelf();
    }

    //
    // Cleanup passed in LogonParameters.
    //

    LocalFree(LogonParameters->AuthenticationInformation);
    Free(LogonParameters->UserSidString);
    Free(LogonParameters);

    //
    // If the user logged on, cleanup.
    //

    if (UserLoggedOn) {
        CloseHandle(UserToken);
        if (Profile) {
            LsaFreeReturnBuffer(Profile);
        }
    }

    if (LogonSessionData) {
        LsaFreeReturnBuffer(LogonSessionData);
    }

    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\inc\choosusr.h ===
/*****************************************************************************\
*                                                                             *
* choosusr.h -   choose user dialog function, types, and definitions          *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1993, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CHOOSUSR
#define _INC_CHOOSUSR

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */


#define	MAX_BINS	3

// codes in CHOOSEUSER.dwError
#define	CUERR_NO_ERROR				0
#define	CUERR_BUF_TOO_SMALL			80
#define	CUERR_INVALID_PARAMETER 	81
#define	CUERR_PROVIDER_ERROR		82
#define	CUERR_NO_AB_PROVIDER		83
#define	CUERR_INVALID_AB_PROVIDER	84

// codes in CHOOSEUSER.Flags
#define	CUFLG_USR_ONLY				0x00000001
#define	CUFLG_GRP_ONLY				0x00000002

struct tagCHOOSEUSER
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE    hInstance;
    DWORD   Flags;
	UINT	nBins;
	LPSTR	lpszDialogTitle;
	LPSTR	lpszProvider;
	LPSTR	lpszReserved;
	LPSTR	lpszRemote;
	LPSTR	lpszHelpFile;
	LPSTR	lpszBinButtonText[MAX_BINS];
	DWORD	dwBinValue[MAX_BINS];
	DWORD	dwBinHelpID[MAX_BINS];
	LPBYTE	lpBuf;
	DWORD	cbBuf;
	DWORD	nEntries;	// OUT
	DWORD 	cbData;		// OUT
	DWORD	dwError;	// OUT
	DWORD	dwErrorDetails;	// OUT
};
typedef struct tagCHOOSEUSER CHOOSEUSER;
typedef struct tagCHOOSEUSER FAR *LPCHOOSEUSER;

// codes for CHOOSEUSERENTRY.dwEntryAttributes
#define	CUE_ATTR_USER		0x00000001
#define CUE_ATTR_GROUP		0x00000002
#define	CUE_ATTR_WORLD		0x00000004

struct tagCHOOSEUSERENTRY
{
	LPSTR lpszShortName;
	LPSTR lpszLongName;
	DWORD dwBinAttributes;
	DWORD dwEntryAttributes;
};

typedef struct tagCHOOSEUSERENTRY CHOOSEUSERENTRY;
typedef struct tagCHOOSEUSERENTRY FAR *LPCHOOSEUSERENTRY;

BOOL    WINAPI ChooseUser(CHOOSEUSER FAR*);
typedef BOOL (WINAPI *LPFNCU)(LPCHOOSEUSER);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_CHOOSUSR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\chkadm\chkadm.c ===
#include <windows.h>
#include <stdio.h>


#define KEYWORD_BUF_SIZE             100
#define STRINGS_BUF_SIZE            8096


typedef struct _ITEM {
    TCHAR szKeyword[KEYWORD_BUF_SIZE];
    struct _ITEM * pNext;
} ITEM, *LPITEM;



LPITEM g_KeywordList = NULL;


LPTSTR GetStringSection (LPCTSTR lpFileName)
{
    DWORD dwSize, dwRead;
    LPTSTR lpStrings;


    //
    // Read in the default strings section
    //

    dwSize = STRINGS_BUF_SIZE;
    lpStrings = (TCHAR *) GlobalAlloc (GPTR, dwSize * sizeof(TCHAR));

    if (!lpStrings)
    {
        printf("(1) Failed to allocate memory with %d\n", GetLastError());
        return NULL;
    }


    do {
        dwRead = GetPrivateProfileSection (TEXT("Strings"),
                                           lpStrings,
                                           dwSize, lpFileName);

        if (dwRead != (dwSize - 2))
        {
            break;
        }

        GlobalFree (lpStrings);

        dwSize *= 2;
        lpStrings = (TCHAR *) GlobalAlloc (GPTR, dwSize * sizeof(TCHAR));

        if (!lpStrings)
        {
            printf("(2) Failed to allocate memory with %d\n", GetLastError());
            return FALSE;
        }

     }  while (TRUE);


    if (dwRead == 0)
    {
        GlobalFree (lpStrings);
        lpStrings = NULL;
    }

    return lpStrings;
}

BOOL DoesKeywordExist (LPTSTR lpKeyword)
{
    LPITEM lpTemp;

    lpTemp = g_KeywordList;

    while (lpTemp) {

        if (!lstrcmpi(lpKeyword, lpTemp->szKeyword)) {
            return TRUE;
        }

        lpTemp = lpTemp->pNext;
    }

    return FALSE;
}

BOOL AddKeywordToList (LPTSTR lpKeyword)
{
    LPITEM lpTemp;


    lpTemp = LocalAlloc (LPTR, sizeof(ITEM));

    if (!lpTemp) {
        printf("(3) Failed to allocate memory with %d\n", GetLastError());
        return FALSE;
    }


    lstrcpyn (lpTemp->szKeyword, lpKeyword, KEYWORD_BUF_SIZE);
    lpTemp->pNext = g_KeywordList;

    g_KeywordList = lpTemp;

    return TRUE;
}


int __cdecl main( int argc, char *argv[])
{
    LPTSTR lpStrings, lpTemp, lpChar, lpEnd;
    TCHAR szKeyword [KEYWORD_BUF_SIZE];
    DWORD dwIndex;


    if (argc != 2) {
        printf("usage:  chkadm admfile\n");
        return 1;
    }


    lpStrings = GetStringSection(argv[1]);

    if (!lpStrings) {
        printf("No strings, or failure reading strings\n");
        return 1;
    }



    lpTemp = lpStrings;

    while (*lpTemp)
    {

        lpChar = szKeyword;
        dwIndex = 0;

        while (*lpTemp && (*lpTemp != TEXT('=')) && (*lpTemp != TEXT('\r'))
               && (*lpTemp != TEXT('\n')) && (dwIndex < (KEYWORD_BUF_SIZE - 1)) ) {
            *lpChar = *lpTemp;
            lpChar++;
            lpTemp++;
            dwIndex++;
        }

        *lpChar = TEXT('\0');


        if (*lpTemp == TEXT('=')) {

            if (DoesKeywordExist (szKeyword)) {
                printf(TEXT("Duplicate string name for:  %s\n"), szKeyword);
            } else {
                if (!AddKeywordToList(szKeyword)) {
                    return 1;
                }
            }

        } else {
            printf("==================\n");
            printf("\nThe following entry in the [Strings] section does not start with a variable name:\n\n%s\n\n", szKeyword);
            printf("==================\n");
        }


        lpEnd = lpTemp += lstrlen (lpTemp) - 1;
        lpTemp += lstrlen (lpTemp) + 1;

        while (*lpEnd == TEXT('\\')) {
            lpEnd = lpTemp += lstrlen (lpTemp) - 1;
            lpTemp += lstrlen (lpTemp) + 1;
        }
    }



    GlobalFree (lpStrings);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\perftest\gpolist\gpolist.c ===
//*************************************************************
//
//  Group Policy Performance test program
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
//  History:    11-Jan-99   SitaramR    Created
//
//*************************************************************

#include <windows.h>
#include <userenv.h>
#include <tchar.h>
#include <stdio.h>

int __cdecl main( int argc, char *argv[])
{
    HANDLE hToken;
    PGROUP_POLICY_OBJECT pGPOList;
    LARGE_INTEGER   Freq;
    LARGE_INTEGER   Start, Stop, Total;
    DWORD i;
    DWORD nIterations = 10;

    if ( !OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken) )
    {
        printf("Unable to get process token\n");
        return 0;
    }

    QueryPerformanceFrequency( &Freq );

    Total.QuadPart = 0;

    printf( "Starting %d iterations\n", nIterations );

    for ( i=0; i<nIterations; i++) {

        QueryPerformanceCounter( &Start );;

        if (GetGPOList (hToken, NULL, NULL, NULL, 0, &pGPOList))
        {

            QueryPerformanceCounter( &Stop );

            Total.QuadPart += Stop.QuadPart - Start.QuadPart;

            FreeGPOList (pGPOList);
        }
        else
        {
            printf( "GetGPOList failed\n" );
            return 0;
        }
    }

    CloseHandle (hToken);

    printf( "GetGPOList time = %f milliseconds per iteration\n",
            ((float)Total.QuadPart / (float)Freq.QuadPart) * 1000 / nIterations );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\perftest\gp\main.c ===
#include <windows.h>
#include <stdio.h>

DWORD DeleteGroupPolicyHistory( HKEY hkRoot );
LONG DeleteMachineUserPolicyHistoryKey(HANDLE hToken);

#define MACHINE_USER_GP_KEY L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy"

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;


LONG
RtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );

VOID
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

BOOL
ProcessGPOs( void* );

BOOL
RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);

void
ReadPerfParams  (
                DWORD*  pIterations,
                BOOL*   pbDeleteHistory,
                BOOL*   pbSkipFirstIteration,
                BOOL*   pbUser,
                BOOL*   pbMach,
                WCHAR*  szPath
                );

void
MeasurePerf( void* lpGPOInfo, HANDLE hToken, BOOL bMach )
{
    LARGE_INTEGER   Freq;
    LARGE_INTEGER   Start, Stop, Total;
    HKEY            hkRoot;
    DWORD           Iterations;
    BOOL            bDeleteHistory;
    BOOL            bSkipFirstIteration;
    BOOL            bDoMach;
    BOOL            bDoUser;
    WCHAR           szPath[MAX_PATH+1];

    ReadPerfParams  (
                    &Iterations,
                    &bDeleteHistory,
                    &bSkipFirstIteration,
                    &bDoUser,
                    &bDoMach,
                    szPath
                    );

    if ( ( bDoUser && !bMach ) || ( bDoMach && bMach ) )
    {
        FILE*   file;
        if ( bMach )
        {
            lstrcat( szPath, L"MachPerf.log" );
        }
        else
        {
            lstrcat( szPath, L"UserPerf.log" );
        }

        file = _wfopen( szPath, L"a+" );
        
        if ( file )
        {
            DWORD n;
            
            fwprintf( file, L"\n" );
            
            if ( RegOpenCurrentUser( KEY_READ, &hkRoot ) == ERROR_SUCCESS )
            {
                QueryPerformanceFrequency( &Freq );
                if ( !Freq.QuadPart )
                {
                    Freq.QuadPart = 1;
                }
                
                Total.QuadPart = 0;

                fprintf( file, "\nNew measurement: %d iterations\n\n", Iterations );

                for ( n = 1; n <= Iterations; n++ )
                {
                    if ( bDeleteHistory )
                    {
                        DeleteGroupPolicyHistory( hkRoot );
                        DeleteMachineUserPolicyHistoryKey(hToken);
                    }

                    QueryPerformanceCounter( &Start );
                    ProcessGPOs(lpGPOInfo);
                    QueryPerformanceCounter( &Stop );

                    if ( bSkipFirstIteration && (1 == n) )
                    {
                        bSkipFirstIteration = FALSE;
                        n--;
                    }
                    else
                    {
                        Total.QuadPart += Stop.QuadPart - Start.QuadPart;
                    }
                    fwprintf(
                            file,
                            L"%d\t%f\t%f\n",
                            n,
                            ((double)Start.QuadPart / (double)Freq.QuadPart) * (double) 1000.0,
                            ((double)Stop.QuadPart / (double)Freq.QuadPart) * (double) 1000.0
                            );
                }
                fprintf(
                        file,
                        "Time = %f milliseconds per iteration\n\n",
                        ((double)Total.QuadPart / (double)Freq.QuadPart) / (double)Iterations * (double) 1000.0
                        );
                RegCloseKey( hkRoot );
            }

            fclose( file );
        }
    }
}

DWORD DeleteGroupPolicyHistory( HKEY hkRoot )
{
    BOOL bOk = RegDelnode( hkRoot, L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History" );

    return bOk ? ERROR_SUCCESS : E_FAIL;
}

LONG DeleteMachineUserPolicyHistoryKey(HANDLE hToken)
{
    UNICODE_STRING SidString;
    BOOL           bStatus;
    DWORD          Size;
    UCHAR          Buffer[sizeof(TOKEN_USER) + sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES-1) * sizeof(ULONG))];
    LONG           Status;
    HKEY           hKeyGP;
    HKEY           hKeyUserGP;
    PTOKEN_USER    pTokenUser;

    hKeyGP = NULL;
    hKeyUserGP = NULL;

    Size = sizeof(Buffer);

    pTokenUser = (PTOKEN_USER) Buffer;

    bStatus = GetTokenInformation(
        hToken,
        TokenUser,
        pTokenUser,
        Size,
        &Size );

    if ( ! bStatus )
    {
        return GetLastError();
    }

    Status = RtlConvertSidToUnicodeString(
        &SidString,
        pTokenUser->User.Sid,
        TRUE );

    if (ERROR_SUCCESS != Status) {
        return Status;
    }

    Status = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        MACHINE_USER_GP_KEY,
        0,
        KEY_READ,
        &hKeyGP);

    if (ERROR_SUCCESS != Status) {
        goto cleanup;
    }

    Status = RegOpenKeyEx (
        hKeyGP,
        SidString.Buffer,
        0,
        KEY_ALL_ACCESS,
        &hKeyUserGP );

    if (ERROR_SUCCESS != Status) {
        goto cleanup;
    }

    bStatus = RegDelnode(
        hKeyUserGP,
        L"History");

    if (! bStatus ) {
        Status = GetLastError();
    }

cleanup:

    if (hKeyGP) {
        RegCloseKey(hKeyGP);
    }

    if (hKeyUserGP) {
        RegCloseKey(hKeyUserGP);
    }

    RtlFreeUnicodeString( &SidString );

    return Status;

}

void
ReadPerfParams  (
                DWORD*  pIterations,
                BOOL*   pbDeleteHistory,
                BOOL*   pbSkipFirstIteration,
                BOOL*   pbUser,
                BOOL*   pbMach,
                WCHAR*  szPath
                )
{
    HKEY    hKey;

    *pIterations = 5;
    *pbDeleteHistory = TRUE;
    *pbSkipFirstIteration = TRUE;
    *pbUser = TRUE;
    *pbMach = TRUE;
    lstrcpy( szPath, L"C:\\" );
    
    if ( RegOpenKeyEx   (
                        HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPPerf",
                        0,
                        KEY_READ,
                        &hKey
                        ) == ERROR_SUCCESS )
    {
        DWORD   dwType = 0;
        DWORD   dwData = 0;
        DWORD   cb = sizeof( DWORD );
        
        if ( RegQueryValueEx( hKey, L"Iterations", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pIterations = dwData;
        }
        cb = sizeof( DWORD );
        if ( RegQueryValueEx( hKey, L"DeleteHistory", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pbDeleteHistory = dwData;
        }
        cb = sizeof( DWORD );
        if ( RegQueryValueEx( hKey, L"SkipFirst", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pbSkipFirstIteration = dwData;
        }
        cb = sizeof( DWORD );
        if ( RegQueryValueEx( hKey, L"User", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pbUser = dwData;
        }
        cb = sizeof( DWORD );
        if ( RegQueryValueEx( hKey, L"Machine", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pbMach = dwData;
        }
        cb = MAX_PATH;
        if ( !( RegQueryValueEx( hKey, L"Path", 0, &dwType, (BYTE*)szPath, &cb ) == ERROR_SUCCESS && dwType == REG_SZ ) )
        {
            lstrcpy( szPath, L"C:\\" );
        }
        
        RegCloseKey( hKey );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\inc\sec32api.h ===
/*****************************************************************/
/**                      Microsoft Windows                      **/
/**             Copyright (C) Microsoft Corp., 1993-5           **/
/*****************************************************************/

/*
    SEC32API.H

    This header file contains declarations for the internal versions
    of the 32-bit Access API, as exported by FILESEC.386.  It also
    contains constant definitions used by securty components

    This file relies, in part, on NETVXD.H and VXDCALL.H.

    This file must be H2INC-able.

    FILE HISTORY:
        dannygl 09/25/93    Initial version
        dannygl 09/29/93    Add NetAccessSetInfo
        dannygl 10/04/93    Add security-related string constants
        dannygl 01/17/94    Replace Win32 services with IOCtls
        dannygl 02/10/94    Add NetAccess arg count constants
        dannygl 02/16/94    Update registry string constants
        dannygl 11/17/94    Add Logon2 API (supported by MSSP only)
*/


// Registry string constants
// Security provider information (in HKEY_LOCAL_MACHINE)
#define REGKEY_SP_CONFIG        "Security\\Provider"

#define REGVAL_SP_PLATFORM  "Platform_Type"
#define REGVAL_SP_CONTAINER "Container"
#define REGVAL_SP_ABSERVER  "Address_Server"
#define REGVAL_SP_ONEOFFABSERVER  "One_Off_Address_Server"
#define REGVAL_SP_ABPROVIDER    "Address_Book"
#define	REGVAL_SP_NO_SORT	"NoSort"

// Obsolescent definition -- will be deleted soon
//#define REGVAL_SP_PTPROVIDER    "Pass_Through"

// Definitions for the IOControl interface that FILESEC uses for Win32 API
// support

#define FSIOC_API_Base      100

/*XLATOFF*/

typedef enum
{
    FSIOC_AccessAddAPI = FSIOC_API_Base,
    FSIOC_AccessCheckAPI,
    FSIOC_AccessDelAPI,
    FSIOC_AccessEnumAPI,
    FSIOC_AccessGetInfoAPI,
    FSIOC_AccessGetUserPermsAPI,
    FSIOC_AccessSetInfoAPI
} FSIOC_Ordinal;

/*XLATON*/

// Important: We define this constant separately because we need it
// to be H2INC'able.  It must match the above enumerated type.
#define FSIOC_API_Count     7

// Arg counts for Access functions
//
// Note: These constants are defined for readability purposes and should not
// be modified independently.
#define Argc_AccessAdd          3
#define Argc_AccessCheck        4
#define Argc_AccessDel          1
#define Argc_AccessEnum         7
#define Argc_AccessGetInfo      5
#define Argc_AccessGetUserPerms 3
#define Argc_AccessSetInfo      5

// Definitions used by the Security Provider VxDs to expose interfaces
// to Win32 code via IOCtls

#define SPIOC_API_Base      100

/*XLATOFF*/

typedef enum
{
    SPIOC_PreLogonAPI = SPIOC_API_Base,
    SPIOC_LogonAPI,
    SPIOC_LogoffAPI,
    SPIOC_GetFlagsAPI,
    SPIOC_GetContainerAPI,
    SPIOC_NW_GetUserObjectId,   // NWSP only
    SPIOC_Logon2API,            // Currently MSSP only
    SPIOC_DiscoverDC            // MSSP only
} SPIOC_Ordinal;

/*XLATON*/

// Important: We define this constant separately because we need it
// to be H2INC'able.  It must match the above enumerated type.
#define SPIOC_API_Count     8

/*XLATOFF*/

typedef struct
{
    unsigned char *pbChallenge;
    unsigned long *pcbChallenge;
} AUTHPRELOGONINFO, *PAUTHPRELOGONINFO;

typedef struct
{
    const char *pszContainer;
    const char *pszUserName;
    const char *pszClientName;
    const unsigned char *pbResponse;
    unsigned long cbResponse;
    const unsigned char *pbChallenge;
    unsigned long cbChallenge;
    unsigned long fResponseType;
    unsigned long *pfResult;
} AUTHLOGONINFO, *PAUTHLOGONINFO;

typedef struct
{
    const char *pszContainer;
    char *pszContainerValidated;
    const char *pszUserName;
    char *pszUserValidated;
    const char *pszClientName;
    const unsigned char *pbResponse;
    unsigned long cbResponse;
    const unsigned char *pbResponse2;
    unsigned long cbResponse2;
    const unsigned char *pbChallenge;
    unsigned long cbChallenge;
    unsigned long *pfFlags;
    unsigned long *pfResult;
} AUTHLOGON2INFO, *PAUTHLOGON2INFO;

typedef struct
{
    const char *pszContainer;
    const char *pszUserName;
    const char *pszClientName;
} AUTHLOGOFFINFO, *PAUTHLOGOFFINFO;

typedef struct
{
    unsigned long *pdwFlags;
    unsigned long *pdwSecurity;
} AUTHGETFLAGS, *PAUTHGETFLAGS;

typedef struct
{
    char *pszContainer;
    unsigned long *pcbContainer;
} AUTHGETCONTAINER, *PAUTHGETCONTAINER;

typedef struct
{
    char *pszUserName;
    unsigned long dwObjectId;
} AUTHNWGETUSEROBJECTID, *PAUTHNWGETUSEROBJECTID;

typedef struct
{
    const char *pszDomain;
    char *pszDCs;   // Concatenated strings, ended with an extra null
    unsigned long *pcbDCs;
} AUTHDISCOVERDC, *PAUTHDISCOVERDC;

/*XLATON*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\perftest\polcreate\main.cxx ===
//*************************************************************
//
//  Group Policy Performance test program
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
//  History:    10-Dec-98   SitaramR    Created from DKays version
//
//*************************************************************

#define UNICODE

#include <windows.h>
#define SECURITY_WIN32
#include <security.h>
#include <stdio.h>
#include <ole2.h>
#include <prsht.h>
#include <initguid.h>
#include <gpedit.h>
#include <iads.h>
#include <adshlp.h>

const MAX_BUF_LEN = 2056;  // Static buffer size
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

void PrintHelp();
BOOL CreateTest2GPOs( WCHAR *pwszDomain );
BOOL CreateTest3GPOs( WCHAR *pwszDomain );
BOOL CreateTest4GPOs( WCHAR *pwszDomain );
BOOL CreateTest5GPOs( WCHAR *pwszDomain );

GUID guidExtensions[] = {  // List of GP client side extension guids
                           { 0x25537BA6, 0x77A8, 0x11D2, {0x9B, 0x6C, 0x00, 0x00, 0xF8, 0x08, 0x08, 0x61}},
                           { 0x35378EAC, 0x683F, 0x11D2, {0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2}},
                           { 0x3610eda5, 0x77ef, 0x11d2, {0x8d, 0xc5, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x66}},
                           { 0x42B5FAAE, 0x6536, 0x11d2, {0xAE, 0x5A, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xE3}},
                           { 0x827d319e, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a}},
                           { 0xb1be8d72, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a}},
                           { 0xc6dc5466, 0x785a, 0x11d2, {0x84, 0xd0, 0x00, 0xc0, 0x4f, 0xb1, 0x69, 0xf7}},
                        };
GUID guidSnapin = { 0xdd7f2e0f, 0x9089, 0x11d2, {0xb2, 0x81, 0x00, 0xc0, 0x4f, 0xbb, 0xcf, 0xa2 }};


int __cdecl main( int argc, char **argv )
{
    for ( int n = 1; n < argc; n++ )
    {
        if ( lstrcmpA(argv[n], "-help") == 0
             || lstrcmpA(argv[n], "/help") == 0
             || lstrcmpA(argv[n], "-?") == 0
             || lstrcmpA(argv[n], "/?") == 0 )
        {
            PrintHelp();
            return 0;
        }

        printf( "Usage: polcreat or polcreat /? to see help info" );
        return 0;
    }

    WCHAR wszUser[MAX_BUF_LEN];
    ULONG ulSize = ARRAYSIZE(wszUser);
    BOOL bOk =  GetUserNameEx( NameFullyQualifiedDN, wszUser, &ulSize  );

    if ( !bOk )
    {
        printf( "GetUserNameEx failed with 0x%x\n", GetLastError() );
        return 0;
    }

    //
    // Get domain path
    //

    WCHAR wszDomain[MAX_BUF_LEN];

    lstrcpy( wszDomain, L"LDAP://" );

    BOOL bFound = FALSE;
    WCHAR *pchCur = wszUser;

    while ( pchCur && *pchCur != 0 && lstrlen(pchCur) > 3 )
    {
        if ( CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                            pchCur, 3, TEXT("DC="), 3) == CSTR_EQUAL)
        {
            bFound = TRUE;
            lstrcat( wszDomain, pchCur );
            break;
        }

        pchCur++;
    }

    if ( !bFound )
    {
        printf( "Unable to create domain path from user path %ws\n", wszUser );
        return 0;
    }

    printf( "Using Domain path, %ws\n", wszDomain );

    CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

    printf( "Creating Test2 GPOs\n" );
    bOk = CreateTest2GPOs( wszDomain );
    if ( !bOk )
    {
        printf( "Failed to create test2 GPOs\n" );
        return 0;
    }

    printf( "Creating Test3 GPOs\n" );
    bOk = CreateTest3GPOs( wszDomain );
    if ( !bOk )
    {
        printf( "Failed to create test3 GPOs\n" );
        return 0;
    }

    printf( "Creating Test4 GPOs\n" );
    bOk = CreateTest4GPOs( wszDomain );
    if ( !bOk )
    {
        printf( "Failed to create test4 GPOs\n" );
        return 0;
    }

    printf( "Creating Test5 GPOs\n" );
    bOk = CreateTest5GPOs( wszDomain );
    if ( !bOk )
    {
        printf( "Failed to create test5 GPOs\n" );
        return 0;
    }

    printf( "Successfully created all OUs and GPOs" );

    return 0;
}

BOOL CreateOU( WCHAR *pwszParent, WCHAR *pwszOU )
{
    //
    // Bind to the parent container and create OU
    //
    IADsContainer *pContainer;
    IDispatch *pIDispatch;
    IADs *pADs;

    HRESULT hr = ADsGetObject( pwszParent,
                               IID_IADsContainer,
                               (void**)&pContainer);
    if ( hr != S_OK )
    {
        printf( "Failed to bind to parent container %ws with 0x%x\n", pwszParent, hr );
        return FALSE;
    }

    hr = pContainer->Create(L"organizationalUnit",
                            pwszOU,          // L"OU=OU1",
                            &pIDispatch );
    if ( hr != S_OK )
    {
        printf( "Failed to bind to create %ws with 0x%x\n", pwszOU, hr );
        return FALSE;
    }

    hr = pIDispatch->QueryInterface( IID_IADs, (void **)&pADs);
    if ( hr != S_OK )
    {
        printf( "Failed to QI %ws with 0x%x\n", pwszOU, hr );
        return FALSE;
    }

    hr = pADs->SetInfo();
    if ( hr != S_OK )
    {
        printf( "Failed to SetInfo %ws with 0x%x\n", pwszOU, hr );
        return FALSE;
    }

    return TRUE;
}


BOOL CreatePolicies( WCHAR *pwszDomain, WCHAR *pwszOUPath, WCHAR *pwszOUName, ULONG cPolicies )
{
    //
    // cPolicies must be a multiple of 7 because there are 7 client side
    // extensions.
    //

    ULONG cPols = cPolicies / 7;
    WCHAR wszGPOName[MAX_BUF_LEN];
    WCHAR wszGPOPath[MAX_BUF_LEN];
    WCHAR wszNum[20];
    LPGROUPPOLICYOBJECT pGPO;

    for ( ULONG i=0; i<cPols; i++ )
    {
        for ( ULONG j=0; j<7; j++ )
        {
            HRESULT hr = CoCreateInstance( CLSID_GroupPolicyObject,
                                           NULL,
                                           CLSCTX_SERVER,
                                           IID_IGroupPolicyObject,
                                           (void**)&pGPO );
            if ( hr != S_OK )
            {
                printf( "CoCreateInstance of pGPO failed 0x%x\n", hr );
                return FALSE;
            }

            wcscpy( wszGPOName, pwszOUName );
            wsprintf( wszNum, L"%d%d", i, j );
            wcscat( wszGPOName, wszNum );

            hr = pGPO->New( pwszDomain, wszGPOName, FALSE );
            if ( hr != S_OK )
            {
                printf( "Creating new GPO %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            hr = pGPO->GetPath( wszGPOPath, ARRAYSIZE(wszGPOPath) );
            if ( hr != S_OK )
            {
                printf( "Getting GPO path of %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            hr = pGPO->Save( TRUE, TRUE, &guidExtensions[j], &guidSnapin ); // machine policy
            if ( hr != S_OK )
            {
                printf( "Saving GPO %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            hr = pGPO->Save( FALSE, TRUE, &guidExtensions[j], &guidSnapin ); // user policy
            if ( hr != S_OK )
            {
                printf( "Saving GPO %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            hr = CreateGPOLink( wszGPOPath, pwszOUPath, FALSE );
            if ( hr != S_OK )
            {
                printf( "Linking GPO %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            pGPO->Release();
        }   // for j
    }   // for i

    return TRUE;
}


BOOL MakeLdapPath( WCHAR *pwszParent, WCHAR *pwszOU, WCHAR *pwszChild )
{
    //
    // Make ldap path to child by prepending OU to parent path
    //

    wcscpy( pwszChild, L"LDAP://" );
    wcscat( pwszChild, pwszOU );
    wcscat( pwszChild, L"," );
    wcscat( pwszChild, &pwszParent[7] );

    return TRUE;
}

BOOL CreateTest2GPOs( WCHAR *pwszDomain )
{
    WCHAR wszParent[MAX_BUF_LEN];
    WCHAR wszChild[MAX_BUF_LEN];

    wcscpy( wszParent, pwszDomain );

    // OU_L1_P7_T2
    BOOL bOk = CreateOU( wszParent, L"OU=OU_L1_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L1_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L1_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L1_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L1_P0_T2");
    if ( !bOk )
        return FALSE;

    // OU_L2_P7_T2
    MakeLdapPath( wszParent, L"OU=OU_L1_P0_T2", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L2_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L2_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L2_P0_T2");
    if ( !bOk )
        return FALSE;

    // OU_L3_P7_T2
    MakeLdapPath( wszParent, L"OU=OU_L2_P0_T2", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L3_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L3_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L3_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L3_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L3_P0_T2");
    if ( !bOk )
        return FALSE;

    // OU_L4_P7_T2
    MakeLdapPath( wszParent, L"OU=OU_L3_P0_T2", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L4_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L4_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L4_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L4_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L4_P0_T2");
    if ( !bOk )
        return FALSE;

    // OU_L5_P7_T2
    MakeLdapPath( wszParent, L"OU=OU_L4_P0_T2", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L5_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L5_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L5_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L5_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L5_P0_T2");
    if ( !bOk )
        return FALSE;

    return TRUE;
}

BOOL CreateTest3GPOs( WCHAR *pwszDomain )
{
    WCHAR wszParent[MAX_BUF_LEN];
    WCHAR wszChild[MAX_BUF_LEN];

    wcscpy( wszParent, pwszDomain );

    // OU_L1_P0_T3
    BOOL bOk = CreateOU( wszParent, L"OU=OU_L1_P0_T3");
    if ( !bOk )
        return FALSE;

    // OU_L2_P14_T3
    MakeLdapPath( wszParent, L"OU=OU_L1_P0_T3", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L2_P14_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P14_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P14_T3_GP", 14 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P28_T3
    bOk = CreateOU( wszParent, L"OU=OU_L2_P28_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P28_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P28_T3_GP", 28 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P56_T3
    bOk = CreateOU( wszParent, L"OU=OU_L2_P56_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P56_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P56_T3_GP", 56 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P70_T3
    bOk = CreateOU( wszParent, L"OU=OU_L2_P70_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P70_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P70_T3_GP", 70 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P98_T3
    bOk = CreateOU( wszParent, L"OU=OU_L2_P98_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P98_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P98_T3_GP", 98 );
    if ( !bOk )
        return FALSE;

    return TRUE;
}


BOOL CreateTest4GPOs( WCHAR *pwszDomain )
{
    WCHAR wszParent[MAX_BUF_LEN];
    WCHAR wszChild[MAX_BUF_LEN];

    wcscpy( wszParent, pwszDomain );

    // OU_L1_P7_T4
    BOOL bOk = CreateOU( wszParent, L"OU=OU_L1_P7_T4");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L1_P7_T4", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L1_P7_T4_GP", 7 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P7_T4
    MakeLdapPath( wszParent, L"OU=OU_L1_P7_T4", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L2_P7_T4");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P7_T4", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P7_T4_GP", 7 );
    if ( !bOk )
        return FALSE;

    // OU_L1_P14_T4
    wcscpy( wszParent, pwszDomain );
    bOk = CreateOU( wszParent, L"OU=OU_L1_P14_T4");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L1_P14_T4", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L1_P14_T4_GP", 14 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P14_T4
    MakeLdapPath( wszParent, L"OU=OU_L1_P14_T4", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L2_P14_T4");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P14_T4", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P14_T4_GP", 14 );
    if ( !bOk )
        return FALSE;

    return TRUE;
}

BOOL CreateTest5GPOs( WCHAR *pwszDomain )
{
    WCHAR wszParent[MAX_BUF_LEN*10];
    WCHAR wszChild[MAX_BUF_LEN*10];
    WCHAR wszOUString[MAX_BUF_LEN];

    wcscpy( wszParent, pwszDomain );
    for ( unsigned i=1; i<60; i++ )
    {
        wsprintf( wszOUString, L"OU=OU_L%d_P0_T5", i );
        BOOL bOk = CreateOU( wszParent, wszOUString );
        if ( !bOk )
            return FALSE;
        
        MakeLdapPath( wszParent, wszOUString, wszChild );
        wcscpy( wszParent, wszChild );
    }

    return TRUE;
}


void PrintHelp()
{
    printf( "Usage: polcreat to create OUs and GPOs or,\n       polcreat /? to get performance test cases\n\n" );\

    printf("   TEST SCENARIOS (Naming covention is: OU_Level#_P#GPOs_T#test)\n");
    printf("\nTest 1:\n");
    printf("   1. User at Domain level\n\n\n");

    printf("Test 2:\n");
    printf("   1. User at OU_L1_P7_T2\n");
    printf("   2. User at OU_L1_P0_T2, OU_L2_P7_T2\n");
    printf("   3. User at OU_L1_P0_T2, OU_L2_P0_T2, OU_L3_P7_T2\n");
    printf("   4. User at OU_L1_P0_T2, OU_L2_P0_T2, OU_L3_P0_T2, OU_L4_P7_T2\n");
    printf("   5. User at OU_L1_P0_T2, OU_L2_P0_T2, OU_L3_P0_T2, OU_L4_P0_T2, OU_L5_P7_T2\n");
    printf("   5. User at OU_L1_P0_T2, OU_L2_P0_T2, OU_L3_P0_T2, OU_L4_P0_T2, OU_L5_P0_T2\n\n\n");

    printf("Test 3:\n");
    printf("   1. User at OU_L1_P0_T3, OU_L2_P14_T3\n");
    printf("   2. User at OU_L1_P0_T3, OU_L2_P28_T3\n");
    printf("   3. User at OU_L1_P0_T3, OU_L2_P70_T3\n\n\n");

    printf("Test 4:\n");
    printf("   1. User at OU_L1_P7_T4, OU_L2_P7_T4\n");
    printf("   2. User at OU_L1_P14_T4, OU_L2_P14_T4\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\add.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"
#include <choosusr.h>
#include <lmerr.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <getuser.h>

//
// Help ID's
//

#define IDH_ADD_USERS     1
#define IDH_ADD_GROUPS    2


typedef struct tagADDINFO {
	DWORD dwType;
	DWORD dwPlatformType;
} ADDINFO;

INT_PTR CALLBACK AddThingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam);
BOOL ProcessAddThingDlg(HWND hDlg);
BOOL OnBrowse(HWND hDlg);

DWORD dwPlatform=0;

#ifndef SV_SECURITY_SHARE
// from dev\inc\svrapi.h
#define SV_SECURITY_SHARE       0       /* Share-level */
#endif

//
// Function typedefs for User Browser on NT
//

typedef HUSERBROW (WINAPI *LPFNOPENUSERBROWSER)(LPUSERBROWSER lpUserParms);
typedef BOOL (WINAPI *LPFNENUMUSERBROWSERSELECTION)( HUSERBROW hHandle,
                                                     LPUSERDETAILS lpUser,
                                                     DWORD *plBufferSize );
typedef BOOL (WINAPI *LPFNCLOSEUSERBROWSER)(HUSERBROW hHandle);



BOOL DoAddUserDlg(HWND hwndApp,HWND hwndList)
{
	ADDINFO AddInfo;

	AddInfo.dwType = UT_USER;

	DialogBoxParam(ghInst,MAKEINTRESOURCE(DLG_ADDUSER),hwndApp,
		AddThingDlgProc,(LPARAM) &AddInfo);

	return TRUE;
}

#ifdef INCL_GROUP_SUPPORT
BOOL DoAddGroupDlg(HWND hwndApp,HWND hwndList)
{
	ADDINFO AddInfo;

	AddInfo.dwType = UT_USER | UF_GROUP;

	DialogBoxParam(ghInst,MAKEINTRESOURCE(DLG_ADDUSER),hwndApp,
		AddThingDlgProc,(LPARAM) &AddInfo);

	return TRUE;
}
#endif

BOOL DoAddComputerDlg(HWND hwndApp,HWND hwndList)
{
	ADDINFO AddInfo;

	AddInfo.dwType = UT_MACHINE;

	DialogBoxParam(ghInst,MAKEINTRESOURCE(DLG_ADDWORKSTATION),hwndApp,
		AddThingDlgProc,(LPARAM) &AddInfo);

	return TRUE;
}

INT_PTR CALLBACK AddThingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	switch (uMsg) {

	        case WM_INITDIALOG:
		        {
			ADDINFO * pAddInfo = (ADDINFO *) lParam;

			// limit edit field length
			SendDlgItemMessage(hDlg,IDD_NAME,EM_LIMITTEXT,USERNAMELEN,0L);

                        if (!g_bWinnt) {

                            // get the platform type to see if pass-through security
                            // is enabled
                            pAddInfo->dwPlatformType = SV_SECURITY_SHARE;
                            ReadRegistryDWordValue(HKEY_LOCAL_MACHINE,(TCHAR *) szProviderKey,
                                    (TCHAR *) szValuePlatform,&pAddInfo->dwPlatformType);
                        }

			// if no network installed, or this is an "add user" dialog
			// and user-level security is not enabled (e.g. can't call
			// ChooseUser), then hide "browse" button
			if (!fNetworkInstalled ||
			    (!g_bWinnt &&
                            (pAddInfo->dwType & UT_USER) &&
			    (pAddInfo->dwPlatformType == SV_SECURITY_SHARE)) ) {

			   ShowWindow(GetDlgItem(hDlg,IDD_BROWSE),SW_HIDE);
                        }

			// if this is a group dialog, change the text to say
			// "enter the name of the group" (rather than "user")
			if (pAddInfo->dwType == (UT_USER | UF_GROUP)) {
				TCHAR szTxt[255];
				SetWindowText(hDlg,LoadSz(IDS_GROUPDLGTITLE,
					szTxt,ARRAYSIZE(szTxt)));
				SetDlgItemText(hDlg,IDD_TX2,LoadSz(IDS_GROUPDLGTXT,
					szTxt,ARRAYSIZE(szTxt)));
			}

			// store away pointer to ADDINFO
			SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) pAddInfo);

			}
			return TRUE;

		case WM_COMMAND:

			switch (wParam) {
				
				case IDOK:

					if (ProcessAddThingDlg(hDlg))
						EndDialog(hDlg,TRUE);
					return TRUE;
					break;

				case IDCANCEL:

					EndDialog(hDlg,FALSE);
					return TRUE;
					break;

				case IDD_BROWSE:
					if (OnBrowse(hDlg))
						EndDialog(hDlg,TRUE);
					break;
			}

			break;

		default:
			return FALSE;

	}

	return FALSE;

}

BOOL ProcessAddThingDlg(HWND hDlg)
{
	TCHAR szName[USERNAMELEN+1];
	ADDINFO * pAddInfo;

	// fetch the pointer to ADDINFO struct out of window data
	pAddInfo = (ADDINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
	if (!pAddInfo) return FALSE;

	// make sure there's an entry, check for duplicates
	if (!GetDlgItemText(hDlg,IDD_NAME,szName,ARRAYSIZE(szName))) {
		MsgBox(hDlg,(pAddInfo->dwType == UT_USER ?
			IDS_NEEDUSERNAME : IDS_NEEDWORKSTANAME),MB_ICONEXCLAMATION,
			MB_OK);
		SetFocus(GetDlgItem(hDlg,IDD_NAME));
		SendDlgItemMessage(hDlg,IDD_NAME,EM_SETSEL,0,(LPARAM) -1);
			return FALSE;
	}

	if (FindUser(hwndUser,szName,pAddInfo->dwType)) {
		UINT uID = 0;

		switch (pAddInfo->dwType) {
			case UT_USER:
				uID = IDS_DUPLICATEUSER;
				break;
			case UT_USER | UF_GROUP:
				uID = IDS_DUPLICATEGROUP;
				break;
			case UT_MACHINE:
				uID = IDS_DUPLICATEWORKSTA;
				break;
		}
		
		MsgBox(hDlg,uID,MB_ICONEXCLAMATION,MB_OK);
		SetFocus(GetDlgItem(hDlg,IDD_NAME));
		SendDlgItemMessage(hDlg,IDD_NAME,EM_SETSEL,0,(LPARAM) -1);
			return FALSE;
	}

	if (AddUser(hwndUser,szName,pAddInfo->dwType)) {
		dwAppState |= AS_FILEDIRTY;

		if (pAddInfo->dwType == (UT_USER | UF_GROUP))
			AddGroupPriEntry(szName);

		EnableMenuItems(hwndMain,dwAppState);
		SetStatusItemCount(hwndUser);
	} else {
		MsgBox(hwndMain,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	return TRUE;
}

HGLOBAL FindUser(HWND hwndList,TCHAR * pszName,DWORD dwType)
{
	int iStart = -1;
	LV_FINDINFO lvfi;
	BOOL fFound = FALSE;
	HGLOBAL hUser;
	USERDATA * pUserData;

	lvfi.flags = LVFI_STRING | LVFI_NOCASE;
	lvfi.psz = pszName;
	
	// try to find specified user name in policy file.  If it's there, use it
	while (!fFound && (iStart=ListView_FindItem(hwndUser,iStart,&lvfi)) >= 0) {
                hUser=(HGLOBAL) LongToHandle(ListView_GetItemParm(hwndUser,iStart));
		if (hUser && (pUserData = (USERDATA *) GlobalLock(hUser))) {
			if (pUserData->hdr.dwType == dwType)
				fFound = TRUE;
			GlobalUnlock(hUser);
		}
	}

	if (fFound)
		return hUser;
	else return NULL;
}

#define USERBUFSIZE 8192		// 8K buffer to receive names
BOOL OnBrowse(HWND hDlg)
{
	HGLOBAL hMem;
	UINT nIndex;
	HINSTANCE hinstDll=NULL;
	LPFNCU lpChooseUser=NULL;
	ADDINFO * pAddInfo;
	BOOL fError=FALSE,fAdded=FALSE;
#ifndef INCL_GROUP_SUPPORT
	BOOL fFoundGroup=FALSE;
#endif

	CHOOSEUSER ChooseUserStruct;
	LPCHOOSEUSERENTRY lpCUE;
	DWORD err;
	TCHAR szBtnText[REGBUFLEN];
	HKEY hkey=NULL;

	// fetch the pointer to ADDINFO struct out of window data
	pAddInfo = (ADDINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
	if (!pAddInfo) return FALSE;

	// if this is an "add computer" dialog, browse for computer
	if (pAddInfo->dwType & UT_MACHINE) {
	    BROWSEINFO BrowseInfo;
	    LPITEMIDLIST pidlComputer;
	    TCHAR szRemoteName[MAX_PATH];

	    BrowseInfo.hwndOwner = hDlg;
	    BrowseInfo.pidlRoot = (LPITEMIDLIST) MAKEINTRESOURCE(CSIDL_NETWORK);
	    BrowseInfo.pszDisplayName = szRemoteName;
	    BrowseInfo.lpszTitle = LoadSz(IDS_COMPUTERBROWSETITLE,szSmallBuf,ARRAYSIZE(szSmallBuf));
	    BrowseInfo.ulFlags = BIF_BROWSEFORCOMPUTER;
	    BrowseInfo.lpfn = NULL;

	    if ((pidlComputer = SHBrowseForFolder(&BrowseInfo)) != NULL) {
	        SHFree(pidlComputer);

			if (!AddUser(hwndUser,szRemoteName,UT_MACHINE)) {
				MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
				return FALSE;
			}

			return TRUE;
	    }
		return FALSE;
	}



        //
        // This is an "Add User" dialog.  If we are on NT, then
        // we can use the User Browser.  For Windows will use
        // ChooseUser function.
        //

        if (g_bWinnt) {

            LPFNOPENUSERBROWSER lpOpenUserBrowser;
            LPFNENUMUSERBROWSERSELECTION lpEnumUserBrowserSelection;
            LPFNCLOSEUSERBROWSER lpCloseUserBrowser;
            USERBROWSER UserParms;
            HUSERBROW hBrowse;
            LPUSERDETAILS lpUserDetails;
            DWORD dwSize = 1024;
            WCHAR szTitle[100];
            TCHAR szUserName[200];


            hinstDll = LoadLibrary (TEXT("netui2.dll"));

            if (!hinstDll) {
                MsgBox(hDlg,IDS_CANTLOADNETUI2,MB_ICONEXCLAMATION,MB_OK);
                return FALSE;
            }

            lpOpenUserBrowser = (LPFNOPENUSERBROWSER) GetProcAddress(hinstDll,
                                                           "OpenUserBrowser");

            lpEnumUserBrowserSelection = (LPFNENUMUSERBROWSERSELECTION) GetProcAddress(hinstDll,
                                                    "EnumUserBrowserSelection");

            lpCloseUserBrowser = (LPFNCLOSEUSERBROWSER) GetProcAddress(hinstDll,
                                                           "CloseUserBrowser");

            if (!lpOpenUserBrowser || !lpEnumUserBrowserSelection ||
                !lpCloseUserBrowser) {
                return FALSE;
            }

            lpUserDetails = GlobalAlloc (GPTR, dwSize);

            if (!lpUserDetails) {
                return FALSE;
            }


            UserParms.ulStructSize = sizeof(USERBROWSER);
            UserParms.fExpandNames = FALSE;
            UserParms.hwndOwner = hDlg;
            UserParms.pszTitle = szTitle;
            UserParms.pszInitialDomain = NULL;
            UserParms.pszHelpFileName = L"POLEDIT.CHM";

            if (pAddInfo->dwType & UF_GROUP) {
                LoadStringW(ghInst, IDS_ADDGROUPS, szTitle, 100);
                UserParms.Flags = USRBROWS_SHOW_GROUPS;
                UserParms.ulHelpContext = IDH_ADD_GROUPS;
            } else {
                LoadStringW(ghInst, IDS_ADDUSERS, szTitle, 100);
                UserParms.Flags = USRBROWS_SHOW_USERS;
                UserParms.ulHelpContext = IDH_ADD_USERS;
            }


            //
            // Display the dialog box
            //

            hBrowse = lpOpenUserBrowser (&UserParms);

            if (!hBrowse) {
                GlobalFree (lpUserDetails);
                return FALSE;
            }


            //
            // Get the user's selection
            //

            while (lpEnumUserBrowserSelection (hBrowse, lpUserDetails, &dwSize)) {

#ifdef UNICODE
                lstrcpy (szUserName, lpUserDetails->pszAccountName);
#else
                WideCharToMultiByte(CP_ACP, 0, lpUserDetails->pszAccountName,
                                    -1, szUserName, 200, NULL, NULL);
#endif

                //
                // Now add the user or group
                //

                if (pAddInfo->dwType & UF_GROUP) {

                    if (AddUser(hwndUser, szUserName, UT_USER | UF_GROUP)) {

                        fError = TRUE;
                        AddGroupPriEntry(szUserName);

                    } else {

                        MsgBox(hDlg,IDS_ERRORADDINGUSERS,MB_ICONEXCLAMATION,MB_OK);
                    }

                } else {

                    if (AddUser(hwndUser, szUserName, UT_USER)) {

                         fError = TRUE;

                    } else {

                         MsgBox(hDlg,IDS_ERRORADDINGUSERS,MB_ICONEXCLAMATION,MB_OK);
                    }
                }
            }

            //
            // Cleanup
            //

            lpCloseUserBrowser (hBrowse);

            GlobalFree (lpUserDetails);

            return fError;
        }




	// this an "add user" dialog, call ChooseUser
 	
	hMem = GlobalAlloc(GPTR,USERBUFSIZE);

	if (!hMem) {
		MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONSTOP,MB_OK);
		return FALSE;
	}

	LoadSz(IDS_ADDBUTTON,szBtnText,ARRAYSIZE(szBtnText));

	memset(&ChooseUserStruct,0,sizeof(ChooseUserStruct));
	ChooseUserStruct.lStructSize = sizeof(ChooseUserStruct);
	ChooseUserStruct.hwndOwner = hDlg;
	ChooseUserStruct.hInstance = ghInst;
	ChooseUserStruct.Flags = 0;
	ChooseUserStruct.nBins = 1;
	ChooseUserStruct.lpszDialogTitle = NULL;
	ChooseUserStruct.lpszProvider = NULL;
	ChooseUserStruct.lpszBinButtonText[0] = szBtnText;
	ChooseUserStruct.dwBinValue[0] = 1;
	ChooseUserStruct.lpBuf = hMem;
	ChooseUserStruct.cbBuf = USERBUFSIZE;

	hinstDll = LoadLibrary(LoadSz(IDS_CHOOSUSRDLL,szSmallBuf,ARRAYSIZE(szSmallBuf)));

	if (hinstDll) {
		lpChooseUser = (LPFNCU) GetProcAddress(hinstDll,"ChooseUser");
	}

	if (!hinstDll || !lpChooseUser) {
		MsgBox(hDlg,IDS_CANTLOADCHOOSUSR,MB_ICONEXCLAMATION,MB_OK);
		if (hinstDll) FreeLibrary(hinstDll);
		return FALSE;
	}

	lpChooseUser(&ChooseUserStruct);

	FreeLibrary(hinstDll);

	if ( (err = ChooseUserStruct.dwError) != NERR_Success) {
		UINT uMsg;
		
		switch (err) {

			case CUERR_NO_AB_PROVIDER:
				uMsg = IDS_NOPROVIDER;
				break;

			case CUERR_INVALID_AB_PROVIDER:
				uMsg = IDS_INVALIDPROVIDER;
				break;

			case CUERR_PROVIDER_ERROR:
			default:
				uMsg = IDS_PROVIDERERROR;
				break;
		}

		MsgBox(hDlg,uMsg,MB_ICONSTOP,MB_OK);
		return FALSE;
	}

	lpCUE = (LPCHOOSEUSERENTRY) hMem;

	for (nIndex = 0;nIndex<ChooseUserStruct.nEntries;nIndex++) {

		// see if user is already in listbox
		if (lpCUE->lpszShortName &&
			!FindUser(hwndUser,lpCUE->lpszShortName,pAddInfo->dwType)) {
			// add user to list control.  If error, keep going and try to
			// add others, report error later
  			LPTSTR lpszName = lpCUE->lpszShortName;
			BOOL fFoundSlash = FALSE;

#ifndef INCL_GROUP_SUPPORT
			if (lpCUE->dwEntryAttributes & (CUE_ATTR_GROUP | CUE_ATTR_WORLD)) {
				// user tried to add group, not supported
				fFoundGroup = TRUE;
				lpCUE++;
				continue;
			}
#endif
			// names come back container-qualified from choosusr--
			// e.g. <domain>\<user name>.  Strip out the container
			// qualification
			while (*lpszName && !fFoundSlash) {
				if (*lpszName == TEXT('\\')) {
					fFoundSlash = TRUE;
				}
				lpszName = CharNext(lpszName);
			}
			if (!fFoundSlash)
				lpszName = lpCUE->lpszShortName;

			if (!AddUser(hwndUser,lpszName,(lpCUE->dwEntryAttributes &
				(CUE_ATTR_GROUP | CUE_ATTR_WORLD) ? UT_USER | UF_GROUP :
				UT_USER) ))
				fError = TRUE;
			else {
				fAdded = TRUE;
#ifdef INCL_GROUP_SUPPORT
				if (lpCUE->dwEntryAttributes & (CUE_ATTR_GROUP |
					CUE_ATTR_WORLD))
					AddGroupPriEntry(lpszName);
#endif

			}
		}
			
		lpCUE++;
	}

	GlobalFree(hMem);

	if (fError) {
		MsgBox(hDlg,IDS_ERRORADDINGUSERS,MB_ICONEXCLAMATION,MB_OK);
	}
#ifndef INCL_GROUP_SUPPORT
	else if (fFoundGroup) {
		MsgBox(hDlg,IDS_GROUPSNOTADDED,MB_ICONINFORMATION,MB_OK);
	}
#endif

	if (fAdded) {
		dwAppState |= AS_FILEDIRTY;
		EnableMenuItems(hwndMain,dwAppState);
		SetStatusItemCount(hwndUser);
	}

	return fAdded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\dlgids.h ===
#define IDUNUSED		-1
#define DLG_POLICIES 		100

#define IDD_TXPOLICIES 		110
#define IDD_TVPOLICIES 		111
#define IDD_TXSETTINGS 		112
#define IDD_TVSETTINGS 		113

#define DLG_ADDWORKSTATION	200
#define DLG_ADDUSER             201
#define IDD_TX1			202
#define IDD_TX2			203
#define IDD_NAME		204
#define IDD_BROWSE		205

#define DLG_TEMPLATEOPT		300
#define IDD_TEMPLATELIST        301
#define IDD_OPENTEMPLATE	302
#define IDD_TXTEMPLATE		303
#define IDD_CLOSETEMPLATE       304

#define DLG_CONNECT		400
#define IDD_COMPUTERNAME	401

#define DLG_LBADD		500
#define DLG_LBADD2		501
#define IDD_VALUENAME		502
#define IDD_VALUEDATA		503

#define DLG_SHOWLISTBOX		600
#define IDD_LISTBOX		601
#define IDD_TITLE		602
#define IDD_ADD			603
#define IDD_REMOVE		604
#define IDD_LISTBOX1		605

#define DLG_GROUPPRIORITY	700
#define IDD_GROUPORDER		701
#define IDD_MOVEUP		702
#define IDD_MOVEDOWN		703

#define IDD_SETTINGCTRL         1000

#define DLG_CHOOSEUSER          800
#define IDD_USER                801
#define IDD_LIST                802
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\copy.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

HGLOBAL AllocateUser(TCHAR * szName,DWORD dwType);
HGLOBAL hClipboardUser = NULL;

BOOL OnCopy(HWND hwndApp,HWND hwndList)
{
	int iSel;
	HGLOBAL hUser;
	USERDATA * pUserData;
	DWORD dwType;

	// make sure we can copy... shouldn't get called otherwise, but safety first
	if (!CanCopy(hwndList))
		return FALSE;

	iSel = ListView_GetNextItem(hwndList,-1,LVNI_SELECTED);
	if (iSel < 0)
		return FALSE;

        hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,iSel));

	if (!hUser || !(pUserData = (USERDATA *) GlobalLock(hUser)))
		return FALSE;
	dwType = (pUserData->hdr.dwType & UT_MASK);	
	GlobalUnlock(hUser);

	// free clipboard user if already allocated
	if (hClipboardUser) {
		GlobalFree(hClipboardUser);
		hClipboardUser = NULL;
	}

	// allocate a clipboard user handle
	hClipboardUser = AllocateUser(TEXT(""),dwType);
	if (!hClipboardUser) {
		MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	if (!CopyUser(hUser,hClipboardUser)) {
		MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	EnableMenuItems(hwndApp,dwAppState);

	return TRUE;
}

BOOL OnPaste(HWND hwndApp,HWND hwndList)
{
	int iItem = -1,iSelItem;
	DWORD dwClipboardUserType;
	HGLOBAL hUser;
	UINT nSelItems=0;

	// make sure we can paste... shouldn't get called otherwise, but safety first
	if (!CanPaste(hwndList))
		return FALSE;

	// find out how many items are selected
	while ((iItem=ListView_GetNextItem(hwndList,iItem,LVNI_SELECTED))
		>=0) {
		iSelItem = iItem;
		nSelItems++;		
	}
	dwClipboardUserType = GetClipboardUserType();

	// display appropriate confirmation message depending on whether 1 user,
	// 1 computer, or multiple items selected
	if (nSelItems == 1) {
		HGLOBAL hUser;
		USERDATA *pUserData;
		UINT uMsg;
		int nRet;
		
                if (!(hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,iSelItem))) ||
			!(pUserData = (USERDATA *) GlobalLock(hUser)))
			return FALSE;

		uMsg = pUserData->hdr.dwType & UT_USER ? IDS_QUERYPASTE_USER
			: IDS_QUERYPASTE_WORKSTA;
	
		nRet=MsgBoxParam(hwndApp,uMsg,pUserData->hdr.szName,MB_ICONQUESTION,
			MB_YESNO);

		GlobalUnlock(hUser);

		if (nRet != IDYES)
			return FALSE;
	} else {
		if (MsgBox(hwndApp,IDS_QUERYPASTE_MULTIPLE,MB_ICONQUESTION,MB_YESNO)
			!= IDYES)
			return FALSE;
	}

	iItem = -1;
	while ((iItem=ListView_GetNextItem(hwndList,iItem,LVNI_SELECTED)) > -1) {
                if ((hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,iItem)))) {
			if (!CopyUser(hClipboardUser,hUser)) {
				MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
				return FALSE;
			}
		} 
	}

	return TRUE;
}

// returns the type of user (user or computer) pasted to the "clipboard"
UINT GetClipboardUserType(VOID)
{
	USERDATA * pUserData;
	DWORD dwType;

	if (!hClipboardUser || !(pUserData = (USERDATA *) GlobalLock(hClipboardUser)))
		return 0;

	dwType = (pUserData->hdr.dwType & UT_MASK);	
	
	GlobalUnlock(hClipboardUser);

	return dwType;
}

// returns TRUE if the copy menu item should be enabled.  This will
// happen if in policy file mode and exactly one item selected in listview
BOOL CanCopy(HWND hwndList)
{
	int iItem=-1;
	UINT nCount = 0;
	
	if (dwAppState & AS_POLICYFILE) {
		while ((iItem=ListView_GetNextItem(hwndList,iItem,LVNI_SELECTED)) > -1)
			nCount ++;	
	}

	return (nCount == 1);
}

// returns TRUE if the paste menu item should be enabled.  This will happen
// if in policy file mode, have a user on the clipboard, there is at least one
// selected item and all the selected items are the same type (user or computer)
// as the item on the clipboard
BOOL CanPaste(HWND hwndList)
{
	int iItem = -1;
	DWORD dwClipboardUserType;
	UINT nCount = 0;
	HGLOBAL hUser;
	USERDATA * pUserData;
	BOOL fMatch;

	if (!(dwAppState & AS_POLICYFILE) || !(hClipboardUser))
		return FALSE;

	dwClipboardUserType = GetClipboardUserType();
	
	while ((iItem=ListView_GetNextItem(hwndList,iItem,LVNI_SELECTED)) > -1) {
		nCount ++;
                if ((hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,iItem)))) {
			if (!(pUserData = (USERDATA *) GlobalLock(hUser)))
				return FALSE;			

			// is this user the same type as the one on the clipboard?
			fMatch = (pUserData->hdr.dwType & dwClipboardUserType);
			GlobalUnlock(hUser);


			if (!fMatch)
				return FALSE;
		}
	}

	if (!nCount)
		return FALSE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\grouppri.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#ifdef INCL_GROUP_SUPPORT

typedef struct tagGROUPPRIENTRY {
	TCHAR * pszGroupName;
	struct tagGROUPPRIENTRY * pNext;
	struct tagGROUPPRIENTRY * pPrev;
} GROUPPRIENTRY;

#endif // INCL_GROUP_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\dlgcodes.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#define AD_SUCCESS		0x0000	// no error
#define AD_ADMNOTFOUND		0x0001  // template file not found
#define AD_ADMLOADERR		0x0002  // template file can't be loaded or parsed
#define AD_POLLOADERR		0x0003  // policy file can't be loaded or created
#define AD_POLSAVEERR		0x0004  // policy file can't be saved
#define AD_OUTOFMEMORY		0x0005  // out of memory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\connect.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

INT_PTR CALLBACK ConnectDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
    LPARAM lParam);
BOOL InitConnectDlg(HWND hDlg);
BOOL ProcessConnectDlg(HWND hDlg);

TCHAR szRemoteName[COMPUTERNAMELEN+1];

#define MAX_KEY_NAME 200

typedef struct _KEYNODE {
    LPTSTR  lpUserName;
    struct _KEYNODE *pNext;
} KEYNODE, * LPKEYNODE;


BOOL AddKeyNode (LPKEYNODE *lpList, LPTSTR lpUserName);
BOOL FreeKeyList (LPKEYNODE lpList);

typedef struct _USERINFO {
    LPTSTR    lpComputerName;
    LPKEYNODE lpList;
    LPKEYNODE lpSelectedItem;
    HKEY      hkeyRemoteHLM;
} USERINFO, * LPUSERINFO;


// HKEYs to remote registry
HKEY hkeyRemoteHLM = NULL;	// remote HKEY_LOCAL_MACHINE
HKEY hkeyRemoteHCU = NULL;	// remote HKEY_CURRENT_USER

HKEY hkeyVirtHLM = HKEY_LOCAL_MACHINE;	// virtual HKEY_LOCAL_MACHINE
HKEY hkeyVirtHCU = HKEY_CURRENT_USER;	// virtual HKEY_CURRENT_USER

BOOL OnConnect(HWND hwndApp,HWND hwndList)
{
	if (dwAppState & AS_FILEDIRTY) {
		if (!QueryForSave(hwndApp,hwndList)) return TRUE;	// user cancelled
	}

	if (DialogBox(ghInst,MAKEINTRESOURCE(DLG_CONNECT),hwndApp,
		ConnectDlgProc)) {

		if (dwAppState & AS_FILELOADED) {
			// Free dirty file and free users
			RemoveAllUsers(hwndList);
		}

		if (!LoadFromRegistry(hwndApp,hwndList,TRUE)) {
			OnDisconnect(hwndApp);
			return FALSE;
		}

		lstrcpy(szDatFilename,szNull);

		dwAppState |= AS_FILELOADED | AS_FILEHASNAME | AS_REMOTEREGISTRY;
	 	dwAppState &= (~AS_CANOPENTEMPLATE & ~AS_LOCALREGISTRY & ~AS_POLICYFILE);
		EnableMenuItems(hwndApp,dwAppState);
		SetTitleBar(hwndApp,szRemoteName);
		EnableWindow(hwndList,TRUE);
	}
	return TRUE;
}

INT_PTR CALLBACK ConnectDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

	switch (uMsg) {

		case WM_INITDIALOG:

		    if (!InitConnectDlg(hDlg)) {
		        EndDialog(hDlg,0);
		        return FALSE;
                    }
		    return TRUE;

		case WM_COMMAND:

		    switch (LOWORD(wParam)) {

                        case IDOK:

			if (ProcessConnectDlg(hDlg))
			    EndDialog(hDlg,TRUE);
			    return TRUE;
			break;

			case IDCANCEL:
        	
                            EndDialog(hDlg,FALSE);
                            return TRUE;
                        break;
		    }

	    break;

	}

    return FALSE;
}

BOOL ProcessConnectDlg(HWND hDlg)
{
	TCHAR szComputerName[COMPUTERNAMELEN+1];

	hkeyRemoteHLM=NULL;

	// get computer name from dialog
	if (!GetDlgItemText(hDlg,IDD_COMPUTERNAME,szComputerName,
		ARRAYSIZE(szComputerName))) {
		SetFocus(GetDlgItem(hDlg,IDD_COMPUTERNAME));
		MsgBox(hDlg,IDS_NEEDCOMPUTERNAME,MB_OK,MB_ICONINFORMATION);
		return FALSE;
	}

	// make the connection
	if (RemoteConnect(hDlg,szComputerName,TRUE)) {
		HKEY hkeyState;

		// save this name to fill in UI as default in future connect dlgs
 		if (RegCreateKey(HKEY_CURRENT_USER,szAPPREGKEY,&hkeyState) ==
			ERROR_SUCCESS) {
			RegSetValueEx(hkeyState,szLASTCONNECTION,0,REG_SZ,szComputerName,(lstrlen(szComputerName)+1) * sizeof(TCHAR));
			RegCloseKey(hkeyState);
		}
		return TRUE;

	} else return FALSE;
}


void GetRealUserName (HKEY hRemoteHLM, LPTSTR lpRemoteMachine,
                      LPTSTR lpInput, LPTSTR lpOutput)
{
    TCHAR szName [MAX_PATH];
    TCHAR szDomainName [MAX_PATH];
    LONG lResult;
    HKEY hKey;
    DWORD dwSize, dwType, dwDomainSize;
    PSID pSid;
    SID_NAME_USE SidNameUse;


    //
    // Initialize the output with the default name
    //

    lstrcpy (lpOutput, lpInput);


    //
    // If the remote machine is NT, then this registry call will
    // succeed and we can get the real sid to look up with.
    // If the remote machine is Windows, then this call will fail
    // and we'll go with the default input name (which is ok because
    // Windows uses the user name in HKEY_USERS rather than a SID.
    //

    wsprintf (szName, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s"),
              lpInput);

    lResult = RegOpenKeyEx (hRemoteHLM,
                            szName,
                            0,
                            KEY_READ,
                            &hKey);


    if (lResult != ERROR_SUCCESS) {
        return;
    }


    //
    // Query the size of the SID (binary)
    //

    lResult = RegQueryValueEx (hKey,
                               TEXT("Sid"),
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        return;
    }


    //
    // Allocate space for the SID
    //

    pSid = GlobalAlloc (GPTR, dwSize);

    if (!pSid) {
        RegCloseKey (hKey);
        return;
    }


    lResult = RegQueryValueEx (hKey,
                               TEXT("Sid"),
                               NULL,
                               &dwType,
                               pSid,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        GlobalFree (pSid);
        RegCloseKey (hKey);
        return;
    }


    //
    // Lookup the account name
    //

    dwSize = MAX_PATH;
    dwDomainSize = MAX_PATH;

    if (LookupAccountSid (lpRemoteMachine,
                          pSid,
                          szName,
                          &dwSize,
                          szDomainName,
                          &dwDomainSize,
                          &SidNameUse) ) {

       lstrcpy (lpOutput, szDomainName);
       lstrcat (lpOutput, TEXT("\\"));
       lstrcat (lpOutput, szName);

    } else {

       LoadSz(IDS_ACCOUNTUNKNOWN, lpOutput, MAX_KEY_NAME);
    }



    //
    // Clean up
    //

    GlobalFree (pSid);

    RegCloseKey (hKey);

}


LRESULT CALLBACK ChooseUserDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message) {

       case WM_INITDIALOG:
          {
          LPUSERINFO lpInfo = (LPUSERINFO) lParam;
          LPKEYNODE lpItem;
          TCHAR szMsg[60+COMPUTERNAMELEN],szFmt[60];
          TCHAR szUserName[MAX_KEY_NAME];
          INT iResult;

          //
          // Store the LPUSERINFO pointer in the extra words
          //

          SetWindowLongPtr (hDlg, GWLP_USERDATA, (LONG_PTR) lpInfo);


          //
          // Fill in the title
          //

          LoadSz(IDS_CHOOSEUSER_TITLE, szFmt, ARRAYSIZE(szFmt));
          wsprintf(szMsg,szFmt,lpInfo->lpComputerName);

          SendDlgItemMessage (hDlg, IDD_USER, WM_SETTEXT, 0, (LPARAM) szMsg);


          lpItem = lpInfo->lpList;

          while (lpItem) {

                //
                // If the user name is not .Default, add it to
                // the list.
                //

                if (lstrcmpi(lpItem->lpUserName, TEXT(".Default")) != 0) {

                    //
                    // Get the user name to display
                    //

                    GetRealUserName (lpInfo->hkeyRemoteHLM, lpInfo->lpComputerName,
                                     lpItem->lpUserName, szUserName);



                    iResult = (INT)SendDlgItemMessage (hDlg, IDD_LIST, LB_INSERTSTRING,
                                                  (WPARAM) -1, (LPARAM) szUserName);

                    if (iResult != LB_ERR) {

                        SendDlgItemMessage (hDlg, IDD_LIST, LB_SETITEMDATA,
                                            iResult, (LPARAM) lpItem);
                    }
                }

                lpItem = lpItem->pNext;
          }


          //
          // Select the first item, or disable the Ok button if no
          // one is logged on.
          //

          iResult = (INT)SendDlgItemMessage (hDlg, IDD_LIST, LB_GETCOUNT, 0, 0);

          if (iResult == 0) {
             EnableWindow (GetDlgItem (hDlg, IDOK), FALSE);

          } else {

             SendDlgItemMessage (hDlg, IDD_LIST, LB_SETCURSEL, 0,  0);
          }

          }
          break;


       case WM_COMMAND:

          if ((LOWORD(wParam) == IDOK) ||
             ((LOWORD(wParam) == IDD_LIST) && (HIWORD(wParam) == LBN_DBLCLK))){
             LPUSERINFO lpInfo = (LPUSERINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);
             INT iResult;


             if (!lpInfo) {
                return TRUE;
             }

             //
             // Find the selected item
             //

             iResult = (INT)SendDlgItemMessage (hDlg, IDD_LIST, LB_GETCURSEL, 0, 0);

             if (iResult != LB_ERR) {

                 //
                 // Save the item pointer
                 //

                 iResult = (INT)SendDlgItemMessage (hDlg, IDD_LIST, LB_GETITEMDATA,
                                              (WPARAM) iResult, 0);

                 if (iResult != LB_ERR) {
                    lpInfo->lpSelectedItem = (LPKEYNODE) IntToPtr(iResult);
                 } else {
                    lpInfo->lpSelectedItem = NULL;
                 }

                 EndDialog(hDlg, TRUE);
             }
             return TRUE;
          }

          if (LOWORD(wParam) == IDCANCEL) {
             EndDialog(hDlg, FALSE);
             return TRUE;
          }

          break;
    }


    return FALSE;
}


BOOL RemoteConnectHCU (HWND hwndOwner, TCHAR * pszComputerName,
                       HKEY hkeyRemoteHLM, HKEY * hkeyRemoteHCU,
                       BOOL fDisplayError)
{
    USERINFO UserInfo;
    HKEY hkeyRemoteHU;
    LONG lResult;
    DWORD dwSubKeys;
    TCHAR szUserName[MAX_KEY_NAME];
    LPKEYNODE lpList = NULL, lpItem;
    DWORD dwSize;
    UINT Index = 0;
    FILETIME ftWrite;
    BOOL bRetVal = FALSE;


    //
    // Connect to HKEY_USERS on the remote machine to see
    // how many people are logged on.
    //

    lResult = RegConnectRegistry(pszComputerName,HKEY_USERS,
                                 &hkeyRemoteHU);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    //
    // Enumerate the subkeys
    //

    dwSize = MAX_KEY_NAME;
    lResult = RegEnumKeyEx(hkeyRemoteHU, Index, szUserName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            //
            // Add the node
            //

            if (!AddKeyNode (&lpList, szUserName)) {
                break;
            }

            Index++;
            dwSize = MAX_KEY_NAME;

            lResult = RegEnumKeyEx(hkeyRemoteHU, Index, szUserName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);

    } else {

        RegCloseKey(hkeyRemoteHU);
        return FALSE;
    }


    UserInfo.lpComputerName = pszComputerName;
    UserInfo.lpList = lpList;
    UserInfo.hkeyRemoteHLM = hkeyRemoteHLM;

    if (DialogBoxParam (ghInst, MAKEINTRESOURCE(DLG_CHOOSEUSER), hwndOwner,
                        ChooseUserDlgProc, (LPARAM)&UserInfo)) {

        if (UserInfo.lpSelectedItem) {

            lResult = RegOpenKeyEx (hkeyRemoteHU,
                                    UserInfo.lpSelectedItem->lpUserName,
                                    0,
                                    KEY_ALL_ACCESS,
                                    hkeyRemoteHCU);

            if (lResult == ERROR_SUCCESS) {
                bRetVal = TRUE;

            } else {

                SetFocus(GetDlgItem(hwndOwner,IDD_COMPUTERNAME));
                SendDlgItemMessage(hwndOwner,IDD_COMPUTERNAME,EM_SETSEL,0,-1);

                if (fDisplayError) {
                    TCHAR szMsg[MEDIUMBUF+COMPUTERNAMELEN+COMPUTERNAMELEN];
                    TCHAR szFmt[MEDIUMBUF];

                    LoadSz(IDS_CANTCONNECT,szFmt,ARRAYSIZE(szFmt));
                    wsprintf(szMsg,szFmt,pszComputerName,pszComputerName);
                    MsgBoxSz(hwndOwner,szMsg,MB_OK,MB_ICONINFORMATION);
                }
            }
        }
    }


    //
    // Free the link list
    //

    FreeKeyList (lpList);


    //
    // Close HKEY_USERS on the remote machine
    //

    RegCloseKey (hkeyRemoteHU);

    return bRetVal;
}



BOOL RemoteConnect(HWND hwndOwner,TCHAR * pszComputerName,BOOL fDisplayError)
{
	UINT uRet;
        HCURSOR hOldCursor;

#ifdef DEBUG
	wsprintf(szDebugOut,TEXT("ADMINCFG: connecting to %s\r\n"),pszComputerName);
	OutputDebugString(szDebugOut);
#endif

	hkeyRemoteHLM = hkeyRemoteHCU = NULL;

        hOldCursor=SetCursor(LoadCursor(NULL,IDC_WAIT));

        //
        // try to connect to remote registry HKEY_LOCAL_MACHINE
        //

	uRet = RegConnectRegistry(pszComputerName,HKEY_LOCAL_MACHINE,
		&hkeyRemoteHLM);

        SetCursor(hOldCursor);

        if (uRet != ERROR_SUCCESS) {

            SetFocus(GetDlgItem(hwndOwner,IDD_COMPUTERNAME));
            SendDlgItemMessage(hwndOwner,IDD_COMPUTERNAME,EM_SETSEL,0,-1);

            if (fDisplayError) {
                    TCHAR szMsg[MEDIUMBUF+COMPUTERNAMELEN+COMPUTERNAMELEN];
                    TCHAR szFmt[MEDIUMBUF];

                    LoadSz(IDS_CANTCONNECT,szFmt,ARRAYSIZE(szFmt));
                    wsprintf(szMsg,szFmt,pszComputerName,pszComputerName);
                    MsgBoxSz(hwndOwner,szMsg,MB_OK,MB_ICONINFORMATION);
            }
            return FALSE;
        }

        //
	// try to connect to remote registry HKEY_CURRENT_USER
        //

	uRet = RemoteConnectHCU (hwndOwner, pszComputerName, hkeyRemoteHLM,
	                         &hkeyRemoteHCU, fDisplayError);

	if (!uRet) {
            RegCloseKey(hkeyRemoteHLM);
            hkeyRemoteHLM = NULL;

            return FALSE;
	}


	hkeyVirtHLM = hkeyRemoteHLM;
	hkeyVirtHCU = hkeyRemoteHCU;

	// change "connect..." menu item to "disconnect"
	ReplaceMenuItem(hwndMain,IDM_CONNECT,IDM_DISCONNECT,IDS_DISCONNECT);
	
	lstrcpy(szRemoteName,pszComputerName);

	return TRUE;
}

BOOL OnDisconnect(HWND hwndOwner)
{
#ifdef DEBUG
        OutputDebugString(TEXT("ADMINCFG: Disconnecting.\r\n"));
#endif

	if (hkeyRemoteHLM) {
		RegCloseKey(hkeyRemoteHLM);
		hkeyRemoteHLM = NULL;
	}
	if (hkeyRemoteHCU) {
		RegCloseKey(hkeyRemoteHCU);
	 	hkeyRemoteHCU = NULL;
	}
	
	// point virtual HLM, HCU keys at local machine
	hkeyVirtHLM = HKEY_LOCAL_MACHINE;
	hkeyVirtHCU = HKEY_CURRENT_USER;

	// change "disconnect" menu item to "connect..."
	ReplaceMenuItem(hwndMain,IDM_DISCONNECT,IDM_CONNECT,IDS_CONNECT);
	SetTitleBar(hwndMain,NULL);
	
	return TRUE;
}

BOOL InitConnectDlg(HWND hDlg)
{				
 	HKEY hkeyState;
	TCHAR szComputerName[COMPUTERNAMELEN+1];
	DWORD dwSize = ARRAYSIZE(szComputerName);

	SetFocus(GetDlgItem(hDlg,IDD_COMPUTERNAME));
	SendDlgItemMessage(hDlg,IDD_COMPUTERNAME,EM_SETLIMITTEXT,
		COMPUTERNAMELEN,0L);

	if (RegOpenKey(HKEY_CURRENT_USER,szAPPREGKEY,&hkeyState) ==
		ERROR_SUCCESS) {
		if (RegQueryValueEx(hkeyState,szLASTCONNECTION,NULL,NULL,szComputerName,&dwSize)
			==ERROR_SUCCESS) {

			SetDlgItemText(hDlg,IDD_COMPUTERNAME,szComputerName);
			SendDlgItemMessage(hDlg,IDD_COMPUTERNAME,EM_SETSEL,0,-1);
		}
		RegCloseKey(hkeyState);
	}

	return TRUE;
}

//*************************************************************
//
//  AddKEYNODE()
//
//  Purpose:    Adds a key node to the link listed
//
//  Parameters: lpList         -   Link list of nodes
//              lpUserName     -   User Name
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/16/96     ericflo    Created
//
//*************************************************************

BOOL AddKeyNode (LPKEYNODE *lpList, LPTSTR lpUserName)
{
    LPKEYNODE lpNewItem;


    if (!lpUserName || !*lpUserName) {
        return TRUE;
    }


    //
    // Setup the new node
    //

    lpNewItem = (LPKEYNODE) LocalAlloc(LPTR, sizeof(KEYNODE) +
                 ((lstrlen(lpUserName) + 1) * sizeof(TCHAR)));

    if (!lpNewItem) {
        return FALSE;
    }

    lpNewItem->lpUserName = (LPTSTR)((LPBYTE)lpNewItem + sizeof(KEYNODE));
    lstrcpy (lpNewItem->lpUserName, lpUserName);
    lpNewItem->pNext = *lpList;

    *lpList = lpNewItem;

    return TRUE;
}


//*************************************************************
//
//  FreeKeyList()
//
//  Purpose:    Free's a KEYNODE link list
//
//  Parameters: lpList  -   List to be freed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/16/96     ericflo    Created
//
//*************************************************************

BOOL FreeKeyList (LPKEYNODE lpList)
{
    LPKEYNODE lpNext;


    if (!lpList) {
        return TRUE;
    }


    lpNext = lpList->pNext;

    while (lpList) {
        LocalFree (lpList);
        lpList = lpNext;

        if (lpList) {
            lpNext = lpList->pNext;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\grouppri.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"
#include "grouppri.h"

#ifdef INCL_GROUP_SUPPORT

GROUPPRIENTRY * pGroupPriEntryFirst = NULL;	// head of linked list
INT_PTR CALLBACK GroupPriorityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam);
extern HIMAGELIST hImageListSmall;
VOID EnableDlgButtons(HWND hDlg);

GROUPPRIENTRY * FindGroupPriEntry(TCHAR * pszGroupName)
{
	GROUPPRIENTRY * pGroupPriEntry = pGroupPriEntryFirst;

	while (pGroupPriEntry) {
		if (!lstrcmpi(pszGroupName,pGroupPriEntry->pszGroupName))
			return pGroupPriEntry;
		pGroupPriEntry = pGroupPriEntry->pNext;
	}

	return NULL;
}

BOOL AddGroupPriEntry(TCHAR * pszGroupName)
{
	GROUPPRIENTRY * pGroupPriEntryNew;

	if (FindGroupPriEntry(pszGroupName))
		return TRUE;	// already in list

	pGroupPriEntryNew = (GROUPPRIENTRY * ) GlobalAlloc(GPTR,sizeof(GROUPPRIENTRY)
		+ ((lstrlen(pszGroupName) + 1) * sizeof(TCHAR)));

	if (!pGroupPriEntryNew)
		return FALSE;	// out of memory

	pGroupPriEntryNew->pNext = NULL;
	pGroupPriEntryNew->pszGroupName = ((LPBYTE) pGroupPriEntryNew)
		+ sizeof(GROUPPRIENTRY);
	lstrcpy(pGroupPriEntryNew->pszGroupName,pszGroupName);

	if (!pGroupPriEntryFirst) {
		pGroupPriEntryFirst = pGroupPriEntryNew;
		pGroupPriEntryNew->pPrev = NULL;
	} else {
		// attach to end of linked list
		GROUPPRIENTRY * pGroupPriEntryLast = pGroupPriEntryFirst;
		while (pGroupPriEntryLast->pNext)
			pGroupPriEntryLast=pGroupPriEntryLast->pNext;

		pGroupPriEntryLast->pNext = pGroupPriEntryNew;
		pGroupPriEntryNew->pPrev = pGroupPriEntryLast;
	}

	return TRUE;
}

BOOL RemoveGroupPriEntry(TCHAR * pszGroupName)
{
	GROUPPRIENTRY * pGroupPriEntry;

	if (!(pGroupPriEntry=FindGroupPriEntry(pszGroupName)))
		return FALSE;

	// fix up linked list
	if (pGroupPriEntry == pGroupPriEntryFirst)
		pGroupPriEntryFirst = pGroupPriEntry->pNext;

	if (pGroupPriEntry->pPrev)
		(pGroupPriEntry->pPrev)->pNext = pGroupPriEntry->pNext;

	if (pGroupPriEntry->pNext)
		(pGroupPriEntry->pNext)->pPrev = pGroupPriEntry->pPrev;

	GlobalFree(pGroupPriEntry);

	return TRUE;
}

VOID FreeGroupPriorityList( VOID )
{
	GROUPPRIENTRY * pGroupPriEntry=pGroupPriEntryFirst,* pGroupPriEntryNext;

	while (pGroupPriEntry) {
		pGroupPriEntryNext = pGroupPriEntry->pNext;
		GlobalFree(pGroupPriEntry);
		pGroupPriEntry = pGroupPriEntryNext;
	}

	pGroupPriEntryFirst = NULL;
}

UINT LoadGroupPriorityList(HKEY hkeyPriority,HKEY hkeyGroup)
{
	TCHAR szValueName[10],szGroupName[USERNAMELEN+1];
	UINT uGroupIndex=1,uErr = ERROR_SUCCESS;
	DWORD dwSize;

	FreeGroupPriorityList();

	while (uErr == ERROR_SUCCESS) {
		wsprintf(szValueName,TEXT("%lu"),uGroupIndex);
		dwSize = ARRAYSIZE(szGroupName) * sizeof(TCHAR);
		uErr = RegQueryValueEx(hkeyPriority,szValueName,NULL,NULL,szGroupName,
			&dwSize);
		if (uErr == ERROR_SUCCESS) {
			HKEY hkeyTmp;

			// as sanity check: only add group priority entry if we find an
			// entry for group in policy file
			if (RegOpenKey(hkeyGroup,szGroupName,&hkeyTmp) == ERROR_SUCCESS) {
				RegCloseKey(hkeyTmp);

				if (!AddGroupPriEntry(szGroupName))
					return ERROR_NOT_ENOUGH_MEMORY;
			}
		}
		uGroupIndex++;
	}

	return ERROR_SUCCESS;
}

UINT SaveGroupPriorityList(HKEY hKey)
{
	GROUPPRIENTRY * pGroupPriEntry = pGroupPriEntryFirst;
	UINT uRet;
	DWORD cbValueName;
	TCHAR szValueName[MAX_PATH+1];
	UINT uGroupIndex=1;
	
	// erase all values for this key, first off
	while (TRUE) {
		cbValueName=ARRAYSIZE(szValueName);
		uRet=RegEnumValue(hKey,0,szValueName,&cbValueName,NULL,
			NULL,NULL,NULL);
		// stop if we're out of items
		if (uRet != ERROR_SUCCESS && uRet != ERROR_MORE_DATA)
			break;
		RegDeleteValue(hKey,szValueName);
	}
	uRet = ERROR_SUCCESS;

	while (pGroupPriEntry) {
                wsprintf(szValueName,TEXT("%lu"),uGroupIndex);

		uRet = RegSetValueEx(hKey,szValueName,0,REG_SZ,pGroupPriEntry->pszGroupName,
			((lstrlen(pGroupPriEntry->pszGroupName)+1) * sizeof(TCHAR)));
		if (uRet != ERROR_SUCCESS) {
			return uRet;
		}
		uGroupIndex++;
		pGroupPriEntry = pGroupPriEntry->pNext;
	}

        return uRet;
}

BOOL OnGroupPriority(HWND hWnd)
{
	return (BOOL)DialogBox(ghInst,MAKEINTRESOURCE(DLG_GROUPPRIORITY),hWnd,
		GroupPriorityDlgProc);
}

BOOL InitGroupPriorityDlg(HWND hDlg)
{
	GROUPPRIENTRY * pGroupPriEntry = pGroupPriEntryFirst;
	LV_ITEM lvi;
	HWND hwndList = GetDlgItem(hDlg,IDD_GROUPORDER);
	LV_COLUMN lvc;

	lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
	lvc.fmt = LVCFMT_LEFT;
	lvc.cx = 150;
	lvc.pszText = (LPTSTR) szNull;
	lvc.cchTextMax = 1;
	lvc.iSubItem = 0;
	ListView_InsertColumn(hwndList,0,&lvc);

	SetWindowLong(hwndList,GWL_EXSTYLE,WS_EX_CLIENTEDGE);
	SetScrollRange(hwndList,SB_VERT,0,100,TRUE);
	SetScrollRange(hwndList,SB_VERT,0,0,TRUE);
	ListView_SetImageList(hwndList,hImageListSmall,LVSIL_SMALL);

	lvi.iItem =lvi.iSubItem=0;
	lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	lvi.iImage = IMG_USERS;

	// insert members of group list into listbox in current priority order
	while (pGroupPriEntry) {
		lvi.pszText = pGroupPriEntry->pszGroupName;
		lvi.cchTextMax = lstrlen(lvi.pszText) + 1;
		lvi.lParam = (LPARAM) pGroupPriEntry;	// save pointer to node in lparam

		ListView_InsertItem(hwndList,&lvi);

		lvi.iItem ++;
		pGroupPriEntry = pGroupPriEntry->pNext;
	}

	EnableDlgButtons(hDlg);

	return TRUE;
}

VOID EnableDlgButtons(HWND hDlg)
{
	HWND hwndList = GetDlgItem(hDlg,IDD_GROUPORDER);
	int nItem;
	BOOL fMoveUpOK=FALSE,fMoveDownOK=FALSE;

	// if item is selected, enable up/down buttons appropriately
	nItem=ListView_GetNextItem(hwndList,-1,LVNI_SELECTED);
	
	if (nItem >=0) {
		if (nItem > 0)
			fMoveUpOK = TRUE;
	
		if (nItem < ListView_GetItemCount(hwndList) -1)
			fMoveDownOK = TRUE;
	}

	EnableDlgItem(hDlg,IDD_MOVEUP,fMoveUpOK);	
	EnableDlgItem(hDlg,IDD_MOVEDOWN,fMoveDownOK);	
}

VOID MoveGroupItem(HWND hDlg,int iDelta)
{
	HWND hwndList = GetDlgItem(hDlg,IDD_GROUPORDER);
	LV_ITEM lvi;
	TCHAR szText[MAX_PATH+1];

	lvi.iItem=ListView_GetNextItem(hwndList,-1,LVNI_SELECTED);

	if (lvi.iItem <0)
		return;

	lvi.iSubItem = 0;
	lvi.mask = LVIF_ALL;
	lvi.pszText = szText;
	lvi.cchTextMax = ARRAYSIZE(szText)+1;
	if (ListView_GetItem(hwndList,&lvi)) {
		ListView_DeleteItem(hwndList,lvi.iItem);
		lvi.iItem += iDelta;
		lvi.state = LVIS_SELECTED;
		lvi.stateMask = LVIS_SELECTED;
		ListView_InsertItem(hwndList,&lvi);
	}

	SetFocus(hwndList);
}

BOOL ProcessGroupPriorityDlg(HWND hDlg)
{
	HWND hwndList = GetDlgItem(hDlg,IDD_GROUPORDER);
	int iMax = ListView_GetItemCount(hwndList),iItem;
	GROUPPRIENTRY * pGroupPriEntry;
	GROUPPRIENTRY * pGroupPriEntryLast;

	// relink the list in the order the entries now appear in the listbox
	for (iItem = 0;iItem < iMax;iItem ++) {
		pGroupPriEntry = (GROUPPRIENTRY *)
                        IntToPtr(ListView_GetItemParm(hwndList,iItem));

		if (iItem == 0) {
			pGroupPriEntryFirst=pGroupPriEntryLast = pGroupPriEntry;
			pGroupPriEntry->pPrev = pGroupPriEntry->pNext = NULL;
		} else {
			pGroupPriEntryLast->pNext = pGroupPriEntry;
			pGroupPriEntry->pPrev = pGroupPriEntryLast;
			pGroupPriEntry->pNext = NULL;
			pGroupPriEntryLast = pGroupPriEntry;
		}
	}

	dwAppState |= AS_FILEDIRTY;

	return TRUE;
}

INT_PTR CALLBACK GroupPriorityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	switch (uMsg) {

		case WM_INITDIALOG:
			InitGroupPriorityDlg(hDlg);
			break;

		case WM_COMMAND:

			switch (wParam) {
				
				case IDOK:

					if (ProcessGroupPriorityDlg(hDlg))
						EndDialog(hDlg,TRUE);
					return TRUE;
					break;

				case IDCANCEL:

					EndDialog(hDlg,FALSE);
					return TRUE;
					break;

				case IDD_MOVEUP:
					MoveGroupItem(hDlg,-1);
					break;

				case IDD_MOVEDOWN:
					MoveGroupItem(hDlg,1);
					break;
			}

			break;

		case WM_NOTIFY:

			if ( ((LPNMHDR) lParam)->hwndFrom == GetDlgItem(hDlg,IDD_GROUPORDER))
				EnableDlgButtons(hDlg);
			break;

		default:
			return FALSE;

	}

	return FALSE;

}

#endif // INCL_GROUP_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\filecmd.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

extern TCHAR szRemoteName[];

BOOL OnOpen(HWND hwndApp,HWND hwndList)
{
	OPENFILENAME ofn;
	TCHAR szFilter[SMALLBUF];
	TCHAR szOpenTitle[SMALLBUF];
	TCHAR szFilename[MAX_PATH+1]=TEXT("");
	TCHAR szDefExt[SMALLBUF];

	if (dwAppState & AS_FILEDIRTY) {
		if (!QueryForSave(hwndApp,hwndList)) return TRUE;	// user cancelled
	}

	// have to load the openfile filter in 2 stages, because the string
	// contains a terminating character and LoadString won't load the
	// whole thing in one go
	memset(szFilter,0,ARRAYSIZE(szFilter) * sizeof(TCHAR));
	LoadSz(IDS_FILEFILTER1,szFilter,ARRAYSIZE(szFilter));
	LoadSz(IDS_FILEFILTER2,szFilter+lstrlen(szFilter)+1,ARRAYSIZE(szFilter)-
		(lstrlen(szFilter)-1));

	LoadSz(IDS_OPENTITLE,szOpenTitle,ARRAYSIZE(szOpenTitle));
	LoadSz(IDS_FILEFILTER2,szDefExt,ARRAYSIZE(szDefExt));

	memset(&ofn,0,sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hwndApp;
	ofn.hInstance = ghInst;
	ofn.lpstrFilter = szFilter;
	ofn.lpstrFile =	szFilename;
	ofn.nMaxFile = ARRAYSIZE(szFilename);
	ofn.lpstrTitle = szOpenTitle;
	ofn.lpstrDefExt = szDefExt;
	ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST
		| OFN_SHAREAWARE | OFN_HIDEREADONLY;

	if (!GetOpenFileName(&ofn)) return TRUE;

	return OnOpen_W(hwndApp,hwndList,szFilename);
}


BOOL OnOpen_W(HWND hwndApp,HWND hwndList,TCHAR * pszFilename)
{
	BOOL fRet;
	TCHAR szStatusText[SMALLBUF+MAX_PATH+1];

	if (dwAppState & AS_FILELOADED) {
		// Free dirty file and free users
		RemoveAllUsers(hwndList);
	}
	
	// make status text a la "loading <filename>..."
	wsprintf(szStatusText,LoadSz(IDS_LOADING,szSmallBuf,ARRAYSIZE(szSmallBuf)),
		pszFilename);
	SetStatusText(szStatusText);
	dwAppState |= AS_POLICYFILE;
	fRet=LoadFile(pszFilename,hwndApp,hwndList,TRUE);
	SetStatusText(NULL);

	if (!fRet) {
		dwAppState &= ~AS_POLICYFILE;
		return FALSE;
	}

	lstrcpy(szDatFilename,pszFilename);

	dwAppState |= AS_FILELOADED | AS_FILEHASNAME | AS_POLICYFILE;
 	dwAppState &= (~AS_CANOPENTEMPLATE & ~AS_LOCALREGISTRY & ~AS_REMOTEREGISTRY);
	EnableMenuItems(hwndApp,dwAppState);
	SetTitleBar(hwndApp,szDatFilename);
	ListView_SetItemState(hwndList,0,LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
	AddFileShortcut(GetSubMenu(GetMenu(hwndApp),0),pszFilename);
	SetStatusItemCount(hwndList);
        EnableWindow(hwndList, TRUE);
        SetFocus (hwndList);

	return TRUE;
}

BOOL OnSave(HWND hwndApp,HWND hwndList)
{
	BOOL fRet;
	TCHAR szStatusText[SMALLBUF+MAX_PATH+1];
	TCHAR szStatusTextOld[255];

	if (!(dwAppState & AS_FILEHASNAME))
		return OnSaveAs(hwndApp,hwndList);
	
	GetStatusText(szStatusTextOld,ARRAYSIZE(szStatusTextOld));
	if (dwAppState & (AS_LOCALREGISTRY | AS_REMOTEREGISTRY)) {
		SetStatusText(LoadSz(IDS_SAVINGREGISTRY,szSmallBuf,ARRAYSIZE(szSmallBuf)));
		fRet = SaveToRegistry(hwndApp,hwndList);
	} else {
		// make status text a la "saving <filename>..."
		wsprintf(szStatusText,LoadSz(IDS_SAVING,szSmallBuf,ARRAYSIZE(szSmallBuf)),
			szDatFilename);
		SetStatusText(szStatusText);
		fRet = SaveFile(szDatFilename,hwndApp,hwndList);
	}
	SetStatusText(szStatusTextOld);

	if (!fRet)
		return FALSE;

	dwAppState &= ~AS_FILEDIRTY;
	EnableMenuItems(hwndApp,dwAppState);
        if (szDatFilename[0] != TEXT('\0')) {
	    SetTitleBar(hwndApp,szDatFilename);
        }
	return TRUE;
}

BOOL OnSaveAs(HWND hwndApp,HWND hwndList)
{
	OPENFILENAME ofn;
	OFSTRUCT ofs;
	TCHAR szFilter[SMALLBUF];
	TCHAR szFilename[MAX_PATH+1]=TEXT("");
	TCHAR szStatusText[SMALLBUF+MAX_PATH+1];
	TCHAR szStatusTextOld[255];
	TCHAR szDefExt[SMALLBUF];
	UINT uRet;

	// should never get here if editing a registry (makes no sense
	// to "save as"), but check just for safety's sake
	if (dwAppState & (AS_LOCALREGISTRY | AS_REMOTEREGISTRY))
		return FALSE;

	// have to load the openfile filter in 2 stages, because the string
	// contains a terminating character and LoadString won't load the
	// whole thing in one go
        memset(szFilter,0,ARRAYSIZE(szFilter) * sizeof(TCHAR));
	LoadSz(IDS_FILEFILTER1,szFilter,ARRAYSIZE(szFilter));
        LoadSz(IDS_FILEFILTER2,szFilter+lstrlen(szFilter)+1,ARRAYSIZE(szFilter)-
                (lstrlen(szFilter)-1));
        LoadSz(IDS_FILEFILTER2,szDefExt,ARRAYSIZE(szDefExt));
	
	memset(&ofn,0,sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hwndApp;
	ofn.hInstance = ghInst;
	ofn.lpstrFilter = szFilter;
	ofn.lpstrFile =	szFilename;
	ofn.nMaxFile = ARRAYSIZE(szFilename);
	ofn.lpstrDefExt = szDefExt;
	ofn.lpstrTitle = NULL;
	ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT
		| OFN_SHAREAWARE | OFN_HIDEREADONLY;

	if (!GetSaveFileName(&ofn)) {
		return FALSE;
	}

	// delete the file if it already exists
	OpenFile(szFilename,&ofs,OF_DELETE);
	
	if ((uRet=CreateHiveFile(szFilename)) != ERROR_SUCCESS) {
		MsgBox(hwndApp,IDS_ErrREGERR_CANTSAVE,MB_OK,MB_ICONSTOP);
		return FALSE;
	}

	GetStatusText(szStatusTextOld,ARRAYSIZE(szStatusTextOld));
	// make status text a la "saving <filename>..."
	wsprintf(szStatusText,LoadSz(IDS_SAVING,szSmallBuf,ARRAYSIZE(szSmallBuf)),
		szDatFilename);
	SetStatusText(szStatusText);
	if (!SaveFile(szFilename,hwndApp,hwndList)) {
		return FALSE;
	}
	SetStatusText(szStatusTextOld);

	lstrcpy(szDatFilename,szFilename);
	dwAppState |= AS_FILEHASNAME;
	dwAppState &= ~AS_FILEDIRTY;
	EnableMenuItems(hwndApp,dwAppState);
	SetTitleBar(hwndApp,szDatFilename);
	AddFileShortcut(GetSubMenu(GetMenu(hwndApp),0),szFilename);

	return TRUE;	
}

BOOL OnNew(HWND hwndApp,HWND hwndList)
{
	if (dwAppState & AS_FILEDIRTY) {
		if (!QueryForSave(hwndApp,hwndList)) return TRUE;	// user cancelled
	}

	if (dwAppState & AS_FILELOADED) {
		// Free dirty file and free users
		RemoveAllUsers(hwndList);
	}

	dwAppState |= AS_FILELOADED | AS_FILEDIRTY | AS_POLICYFILE;
 	dwAppState &= (~AS_CANOPENTEMPLATE & ~AS_LOCALREGISTRY & ~AS_REMOTEREGISTRY
		& ~AS_FILEHASNAME);

	if (!AddDefaultUsers(hwndList)) {
		MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		dwAppState |= AS_CANOPENTEMPLATE;
		dwAppState &= (~AS_FILELOADED & ~AS_FILEDIRTY & ~AS_POLICYFILE);
		return FALSE;
	}

	EnableMenuItems(hwndApp,dwAppState);
	lstrcpy(szDatFilename,szNull);

	SetTitleBar(hwndApp,szDatFilename);
        ListView_SetItemState(hwndList, 0,LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

	SetStatusItemCount(hwndList);

        EnableWindow(hwndList, TRUE);
        SetFocus (hwndList);

	return TRUE;
}

BOOL OnOpenRegistry(HWND hwndApp,HWND hwndList,BOOL fDisplayErrors)
{
	BOOL fRet;

	if (dwAppState & AS_FILEDIRTY) {
		if (!QueryForSave(hwndApp,hwndList)) return TRUE;	// user cancelled
	}

	if (dwAppState & AS_FILELOADED) {
		// Free dirty file and free users
		RemoveAllUsers(hwndList);
	}

	dwAppState |= AS_LOCALREGISTRY;
	SetStatusText(LoadSz(IDS_READINGREGISTRY,szSmallBuf,ARRAYSIZE(szSmallBuf)));
	fRet=LoadFromRegistry(hwndApp,hwndList,fDisplayErrors);
	SetStatusText(NULL);

	if (!fRet) {
		dwAppState &= ~AS_LOCALREGISTRY;
		return FALSE;
	}

	lstrcpy(szDatFilename,szNull);

	dwAppState |= AS_FILELOADED | AS_FILEHASNAME | AS_LOCALREGISTRY;
 	dwAppState &= (~AS_CANOPENTEMPLATE & ~AS_POLICYFILE & ~AS_REMOTEREGISTRY);
	EnableMenuItems(hwndApp,dwAppState);
	SetTitleBar(hwndApp,NULL);
        ListView_SetItemState(hwndList,0,LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

        EnableWindow(hwndList, TRUE);
        SetFocus (hwndList);

	return TRUE;
}

BOOL OnClose(HWND hwndApp,HWND hwndList)
{
	if (!(dwAppState & AS_FILELOADED))
		return FALSE;

	if (dwAppState & AS_FILEDIRTY) {
		if (!QueryForSave(hwndApp,hwndList)) return TRUE;	// user cancelled
	}

	// disconnect if closing remote registry
	if (dwAppState & AS_REMOTEREGISTRY)
		OnDisconnect(hwndApp);

	RemoveAllUsers(hwndList);

	lstrcpy(szDatFilename,szNull);

	dwAppState &= (~AS_FILELOADED & ~AS_FILEHASNAME & ~AS_FILEDIRTY
		& ~AS_LOCALREGISTRY & ~AS_REMOTEREGISTRY & ~AS_POLICYFILE);
 	dwAppState |= AS_CANOPENTEMPLATE;
	EnableMenuItems(hwndApp,dwAppState);
	SetTitleBar(hwndApp,NULL);
	SetStatusText(NULL);

        EnableWindow(hwndList, FALSE);

	return TRUE;
}

BOOL QueryForSave(HWND hwndApp,HWND hwndList)
{
	TCHAR szTmpFilename[MAX_PATH+1];
	UINT uRet;

	if (dwAppState & AS_LOCALREGISTRY) {
		uRet = (UINT) MsgBox(hwndApp,IDS_QUERYSAVEREGISTRY,
			MB_ICONINFORMATION,MB_YESNOCANCEL);
	} else if (dwAppState & AS_REMOTEREGISTRY) {
		uRet = (UINT) MsgBoxParam(hwndApp,IDS_QUERYSAVEREMOTEREGISTRY,
			szRemoteName,MB_ICONINFORMATION,MB_YESNOCANCEL);
	} else {
		if (lstrlen(szDatFilename)) 
			lstrcpy(szTmpFilename,szDatFilename);
		else lstrcpy(szTmpFilename,LoadSz(IDS_UNTITLED,szSmallBuf,
			ARRAYSIZE(szSmallBuf)));

		uRet = (UINT) MsgBoxParam(hwndApp,IDS_QUERYSAVE,szTmpFilename,
			MB_ICONINFORMATION,MB_YESNOCANCEL);
	}
	
	switch (uRet) {

		case IDCANCEL:
			return FALSE;

		case IDNO:
			return TRUE;

		case IDYES:
                default:
			return OnSave(hwndApp,hwndList);
	}
}

UINT CreateHiveFile(TCHAR * pszFilename)
{
	UINT uRet;
	HKEY hkeyHive=NULL,hkeyUsers=NULL,hkeyWorkstations=NULL;

	MyRegDeleteKey(HKEY_CURRENT_USER,TEXT("AdminConfigData"));

	if ( (uRet=RegCreateKey(HKEY_CURRENT_USER,TEXT("AdminConfigData"),&hkeyHive)) !=
		ERROR_SUCCESS ||
		(uRet=RegCreateKey(hkeyHive,szUSERS,&hkeyUsers)) !=
		ERROR_SUCCESS ||
		(uRet=RegCreateKey(hkeyHive,szWORKSTATIONS,&hkeyWorkstations)) !=
		ERROR_SUCCESS) {
		if (hkeyWorkstations) RegCloseKey(hkeyWorkstations);
		if (hkeyUsers) RegCloseKey(hkeyUsers);
		if (hkeyHive) RegCloseKey(hkeyHive);
		return uRet;

 	}
	RegCloseKey(hkeyUsers);
	RegCloseKey(hkeyWorkstations);

	uRet=MyRegSaveKey(hkeyHive,pszFilename);

	RegCloseKey(hkeyHive);
	MyRegDeleteKey(HKEY_CURRENT_USER,TEXT("AdminConfigData"));
	if (uRet == ERROR_SUCCESS) {
		RegFlushKey(HKEY_CURRENT_USER);
		SetFileAttributes(pszFilename,FILE_ATTRIBUTE_ARCHIVE);
	}

	return uRet;
}

BOOL OnOpenTemplate(HWND hwndOwner,HWND hwndApp)
{
	BOOL fRet;

	if (fRet=GetATemplateFile(hwndOwner)) {
		dwAppState |= AS_CANHAVEDOCUMENT;
	}

	EnableMenuItems(hwndApp,dwAppState);

	return fRet;
}

// adds the special prefixes "**del." and "**soft." if writing to a policy file,
// and VF_DELETE/VF_SOFT flags are set
VOID PrependValueName(TCHAR * pszValueName,DWORD dwFlags,TCHAR * pszNewValueName,
	UINT cbNewValueName)
{
	UINT nValueNameLen = lstrlen(pszValueName);

	lstrcpy(pszNewValueName,szNull);

	if (cbNewValueName < nValueNameLen)	// check length of buffer, just in case
		return;

	// prepend special prefixes for "delete" or "soft" values, if
	// we're writing to a policy file
	if ((dwAppState & AS_POLICYFILE) && !(dwCmdLineFlags & CLF_DIALOGMODE)) {
		if ((dwFlags & VF_DELETE) && (cbNewValueName > nValueNameLen +
			ARRAYSIZE(szDELETEPREFIX))) {
			lstrcpy(pszNewValueName,szDELETEPREFIX);
		} else if ((dwFlags & VF_SOFT) && (cbNewValueName > nValueNameLen +
			ARRAYSIZE(szSOFTPREFIX))) {
			lstrcpy(pszNewValueName,szSOFTPREFIX);
		} 
	} 

	lstrcat(pszNewValueName,pszValueName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\admincfg.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1992                    **
//*********************************************************************

#define STRICT                      // Use strict handle types

//
// NT uses DBG=1 for its debug builds.
// Do the appropriate mapping here.
//

#if DBG
#define DEBUG 1
#endif


#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>                // Windows 3.1 (internal)
#include <commctrl.h>
#include <comctrlp.h>
#include <prsht.h>
#include <commdlg.h>
#include <shellapi.h>
#include <regstr.h>
#include <sec32api.h>
#include <htmlhelp.h>

#include "memory.h"
#include "user.h"
#include "treeview.h"
#include "policy.h"
#include "view.h"
#include "strings.h"
#include "dlgcodes.h"
#include "strids.h"
#include "dlgids.h"

#pragma intrinsic (memset)
#pragma intrinsic (memcpy)

//  Defines
#define REGBUFLEN	255
#define MAXSTRLEN       2048
#define SMALLBUF	48
#define USERNAMELEN	260	// big enough for netware
#define MEDIUMBUF   1024  // random buffer size
#define HELPBUFSIZE     4096

#define FILEHISTORY_COUNT	4	// # of last files remembered on file menu

#define WM_FINISHINIT	WM_USER	+ 0x00

extern HINSTANCE 	ghInst;			// app instance
extern HWND			hwndMain;		// main window
extern HWND			hwndUser;		// user listbox
extern CLASSLIST 	gClassList;
extern TCHAR 		szSmallBuf[SMALLBUF]; // global small buffer for general use
extern TCHAR szDatFilename[MAX_PATH+1]; // name of active .DAT file
extern TCHAR szDlgModeUserName[USERNAMELEN+1]; // user name for dialog mode operation
extern TCHAR *pbufTemplates; //Buffer containing list of all active template files
extern HGLOBAL		hBufTemplates;
extern DWORD		dwBufTemplates;


extern BOOL fNetworkInstalled;
extern BOOL g_bWinnt;

#define ERROR_ALREADY_DISPLAYED	0xFFFF

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//  Functions in POLEDIT.C
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK About  (HWND, UINT, WPARAM, LPARAM);

//  Functions in MAIN.C
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

//	Functions in MEMORY.C
BOOL FreeTable(TABLEENTRY * pTableEntry);
BOOL InitializeRootTables(VOID);
VOID FreeRootTables(VOID);

//  Functions in PARSE.C
UINT ParseTemplateFile(HWND hWnd,HANDLE hFile,LPTSTR pszFileName);

//  Functions in TREEVIEW.C
BOOL RefreshTreeView(POLICYDLGINFO * pdi,HWND hwndTree,TABLEENTRY * pTableEntry,
	HGLOBAL hUser);
BOOL InitImageLists(VOID);
VOID FreeImageLists(VOID);
UINT GetImageIndex(DWORD dwType,BOOL fExpanded,BOOL fEnabled);
BOOL SetTreeRootItem(HWND hwndPolicy,USERHDR * pUserHdr);
VOID SetStatusText(TCHAR * pszText);
VOID GetStatusText(TCHAR * pszText,UINT cbText);
BOOL IsSelectedItemChecked(HWND hwndTree);

//  Functions in TREECTRL.C
BOOL OnTreeNotify(HWND hwndParent,HWND hwndTree,NM_TREEVIEW *pntv);

//  Functions in LISTCTRL.C
BOOL OnListNotify(HWND hwndParent,HWND hwndList,NM_LISTVIEW *pnlv);
HWND CreateListControl(HWND hwndApp);
VOID DestroyListControl(HWND hwndList);
VOID UpdateListControlPlacement(HWND hwndApp,HWND hwndList);
BOOL OnProperties(HWND hwndParent,HWND hwndList);

//  Functions in POLICY.C
BOOL DoPolicyDlg(HWND hwndOwner,HGLOBAL hUser);
BOOL SetPolicyState(HWND hDlg,TABLEENTRY * pTableEntry,UINT uState);

//  Functions in SETTINGS.c
LRESULT CALLBACK ClipWndProc(HWND hWnd,UINT message,WPARAM wParam,
	LPARAM lParam);
BOOL CreateSettingsControls(HWND hwndParent,SETTINGS * pSettings,BOOL fEnabled);
BOOL ProcessSettingsControls(HWND hwndOwner,DWORD dwValidate);
VOID FreeSettingsControls(HWND hwndOwner);
BOOL EnableSettingsControls(HWND hDlg,BOOL fEnable);
BOOL SetVariableLengthData(HGLOBAL hUser,UINT nDataIndex,TCHAR * pchData,
	DWORD cbData);
// dwValidate values for ProcessSettingsControls
#define PSC_NOVALIDATE		0
#define PSC_VALIDATESILENT	1
#define PSC_VALIDATENOISY	2

//  Functions in USER.C
HGLOBAL AddUser(HWND hwndList,TCHAR * szName,DWORD dwType);
BOOL CloneUser(HGLOBAL hUser);
BOOL CopyUser(HGLOBAL hUserSrc,HGLOBAL hUserDst);
BOOL RemoveUser(HWND hwndList,UINT nIndex,BOOL fMarkDeleted);
BOOL FreeUser(HGLOBAL hUser);
BOOL RemoveAllUsers(HWND hwndList);
BOOL AddDefaultUsers(HWND hwndList);
BOOL GetUserHeader(HGLOBAL hUser,USERHDR * pUserHdr);
UINT GetUserImageIndex(DWORD dwUserType);
BOOL AllocTemplateTable(VOID);
VOID FreeTemplateTable(VOID);
BOOL AddDeletedUser(USERHDR * pUserHdr);
USERHDR * GetDeletedUser(UINT nIndex);
VOID ClearDeletedUserList(VOID);
VOID MapUserName(TCHAR * szUserName,TCHAR * szMappedName);
VOID UnmapUserName(TCHAR * szMappedName,TCHAR * szUserName,BOOL fUser);

//  Functions in ADD.C
BOOL DoAddUserDlg(HWND hwndApp,HWND hwndList);
BOOL DoAddGroupDlg(HWND hwndApp,HWND hwndList);
BOOL DoAddComputerDlg(HWND hwndApp,HWND hwndList);
HGLOBAL FindUser(HWND hwndList,TCHAR * pszName,DWORD dwType);

//  Functions in REMOVE.C
BOOL OnRemove(HWND hwndApp,HWND hwndList);

//	Functions in LOAD.C
BOOL LoadFile(TCHAR * pszFilename,HWND hwndApp,HWND hwndList,BOOL fDisplayErrors);
BOOL LoadFromRegistry(HWND hwndApp,HWND hwndList,BOOL fDisplayErrors);

//  Functions in SAVE.C
BOOL SaveFile(TCHAR * pszFilename,HWND hwndApp,HWND hwndList);
BOOL SaveToRegistry(HWND hwndApp,HWND hwndList);

//	Functions in FILECMD.C
BOOL OnOpen(HWND hwndApp,HWND hwndList);
BOOL OnOpen_W(HWND hwndApp,HWND hwndList,TCHAR * pszFilename);
BOOL OnNew(HWND hwndApp,HWND hwndList);
BOOL OnSave(HWND hwndApp,HWND hwndList);
BOOL OnSaveAs(HWND hwndApp,HWND hwndList);
BOOL OnClose(HWND hwndApp,HWND hwndList);
BOOL QueryForSave(HWND hwndApp,HWND hwndList);
UINT CreateHiveFile(TCHAR * pszFilename);
BOOL OnOpenTemplate(HWND hwndOwner,HWND hwndApp);
BOOL OnOpenRegistry(HWND hwndApp,HWND hwndList,BOOL fDisplayErrors);
VOID PrependValueName(TCHAR * pszValueName,DWORD dwFlags,TCHAR * pszNewValueName,
	UINT cbNewValueName);

//  Functions in REGISTRY.C
BOOL RestoreStateFromRegistry(HWND hWnd);
BOOL SaveStateToRegistry(HWND hWnd);
VOID LoadFileMenuShortcuts(HMENU hMenu);
VOID SaveFileMenuShortcuts(HMENU hMenu);

//  Functions in INFMGR.C
BOOL GetATemplateFile(HWND hWnd);
UINT LoadTemplates(HWND hWnd);
UINT LoadTemplateFile(HWND hWnd,TCHAR * szFilename);
UINT LoadTemplatesFromDlg(HWND hWnd);
UINT PrepareToLoadTemplates();
VOID UnloadTemplates(VOID);
DWORD GetDefaultTemplateFilename(HWND hWnd,TCHAR * szFilename,UINT cbFilename);

//  Functions in VIEW.C
VOID EnableMenuItems(HWND hwndApp,DWORD dwState);
VOID SetTitleBar(HWND hwndApp,TCHAR * szFilename);
BOOL ReplaceMenuItem(HWND hWnd,UINT idOld,UINT idNew,UINT idResourceTxt);
VOID AddFileShortcut(HMENU hMenu,TCHAR * pszNewFilename);
VOID SetStatusItemCount(HWND hwndList);
VOID SetViewType(HWND hwndList,DWORD dwView);
VOID CheckViewItem(HWND hwndApp,DWORD dwView);
VOID SetNewView(HWND hwndApp,HWND hwndList,DWORD dwNewView);

//  Functions in REGUTIL.C
UINT WriteRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
	DWORD dwValue);
UINT ReadRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
	DWORD * pdwValue);
UINT WriteRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
	TCHAR * pszValue, BOOL bExpandable);
UINT ReadRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
	TCHAR * pszValue,UINT cbValue);
UINT DeleteRegistryValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName);
LONG MyRegDeleteKey(HKEY hkeyRoot,LPTSTR pszSubkey);
LONG MyRegLoadKey(HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpFile);
LONG MyRegUnLoadKey(HKEY hKey, LPCTSTR lpSubKey);
LONG MyRegSaveKey(HKEY hKey, LPCTSTR lpSubKey);

//  Functions in OPTIONS.C
BOOL OnTemplateOptions(HWND hwndApp);

//	Functions in COPY.C
BOOL OnCopy(HWND hwndApp,HWND hwndList);
BOOL OnPaste(HWND hwndApp,HWND hwndList);
BOOL CanCopy(HWND hwndList);
BOOL CanPaste(HWND hwndList);
UINT GetClipboardUserType(VOID);

//  Functions in CONNECT.C
BOOL OnConnect(HWND hwndOwner,HWND hwndList);
BOOL OnDisconnect(HWND hwndOwner);
BOOL RemoteConnect(HWND hwndOwner,TCHAR * pszComputerName,BOOL fDisplayError);

//	Functions in LISTBOX.C
VOID ShowListbox(HWND hParent,HGLOBAL hUser,SETTINGS * pSettings,UINT uDataIndex);

// 	Functions in GROUPPRI.C
BOOL AddGroupPriEntry(TCHAR * pszGroupName);
BOOL RemoveGroupPriEntry(TCHAR * pszGroupName);
UINT LoadGroupPriorityList(HKEY hKeyPriority,HKEY hkeyGroup);
UINT SaveGroupPriorityList(HKEY hKey);
VOID FreeGroupPriorityList( VOID );
BOOL OnGroupPriority(HWND hWnd);


//  Functions in UTIL.C
BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable);
BOOL IsDlgItemEnabled(HWND hDlg,UINT uID);
int MsgBox(HWND hWnd,UINT nResource,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
int MsgBoxParam(HWND hWnd,UINT nResource,TCHAR * szReplaceText,UINT uIcon,UINT uButtons);
LONG AddListboxItem(HWND hDlg,int idControl,TCHAR * szItem);
LONG GetListboxItemText(HWND hDlg,int idControl,UINT nIndex,TCHAR * szText);
LONG SetListboxItemData(HWND hDlg,int idControl,UINT nIndex,LPARAM dwData);
LONG GetListboxItemData(HWND hDlg,int idControl,UINT nIndex);
LONG SetListboxSelection(HWND hDlg,int idControl,UINT nIndex);
LONG GetListboxSelection(HWND hDlg,int idControl);
TCHAR * ResizeBuffer(TCHAR *pBuf,HGLOBAL hBuf,DWORD dwNeeded,DWORD * pdwCurSize);
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);
DWORD RoundToDWord(DWORD dwSize);
DWORD ListView_GetItemParm( HWND hwnd, int i );
BOOL StringToNum(TCHAR *szStr,UINT * pnVal);
VOID DisplayStandardError(HWND hwndOwner,TCHAR * pszParam,UINT uMsgID,UINT uErr);

extern DWORD dwAppState;
extern DWORD dwCmdLineFlags;
extern DWORD dwDlgRetCode;
extern TCHAR szAppName[];

// App state bits in dwAppState
#define AS_FILELOADED		0x0001
#define AS_FILEDIRTY		0x0002
#define AS_FILEHASNAME		0x0004
#define AS_CANREMOVE		0x0008
#define AS_CANOPENTEMPLATE	0x0010
#define AS_CANHAVEDOCUMENT	0x0020
#define AS_POLICYFILE		0x0040
#define AS_LOCALREGISTRY	0x0080
#define AS_REMOTEREGISTRY	0x0100

// command line flags
#define CLF_DIALOGMODE	   	 	0x0001
#define CLF_USETEMPLATENAME		0x0002
#define CLF_USEPOLICYFILENAME	0x0004
#define CLF_USEWORKSTATIONNAME	0x0008
#define CLF_USEUSERNAME			0x0010

#define COMPUTERNAMELEN	20	//	big enough for 20-digit SPX address
extern HKEY hkeyVirtHLM;	// virtual HKEY_LOCAL_MACHINE
extern HKEY hkeyVirtHCU;	// virtual HKEY_CURRENT_USER
extern UINT nDeletedUsers;

// Useful macros

#define GETNAMEPTR(x) 			((TCHAR *) x + x->uOffsetName)
#define GETKEYNAMEPTR(x) 		((TCHAR *) x + x->uOffsetKeyName)
#define GETVALUENAMEPTR(x) 		((TCHAR *) x + x->uOffsetValueName)
#define GETOBJECTDATAPTR(x)		((TCHAR *) x + x->uOffsetObjectData)

#ifdef DEBUG
extern CHAR szDebugOut[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\listctrl.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

BOOL OnSelection(HWND hwndParent,HWND hwndList,NM_LISTVIEW *pnlv);
BOOL OnDoubleClick(HWND hwndParent,HWND hwndList);
extern HIMAGELIST hImageListSmall,hImageListLarge;

BOOL OnListNotify(HWND hwndParent,HWND hwndList,NM_LISTVIEW *pnlv)
{
	switch (pnlv->hdr.code) {

		case LVN_ITEMCHANGED:			

			return OnSelection(hwndParent,hwndList,pnlv);

			return FALSE;
			break;

		case LVN_KEYDOWN:

			switch (((LV_KEYDOWN *) pnlv)->wVKey) {
				case VK_RETURN:
					OnProperties(hwndParent,hwndList);
					return FALSE;
					break;

				case VK_DELETE:
					if ((dwAppState & AS_CANREMOVE) &&
						(dwAppState & AS_POLICYFILE))
						OnRemove(hwndParent,hwndList);
					return FALSE;
					break;
			}
			break;

		case NM_DBLCLK:

			OnDoubleClick(hwndParent,hwndList);

			return FALSE;
			break;
	}

	return FALSE;
}

BOOL OnDoubleClick(HWND hwndParent,HWND hwndList)
{
	HGLOBAL hUser;
	LV_HITTESTINFO ht;

	GetCursorPos(&ht.pt);
	ScreenToClient(hwndList,&ht.pt);

	if (ListView_HitTest(hwndList,&ht)<0) return FALSE;

        if (!(hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,ht.iItem))))
		return FALSE;

	DoPolicyDlg(hwndParent,hUser);

	return FALSE;
}

BOOL OnProperties(HWND hwndParent,HWND hwndList)
{
	HGLOBAL hUser;
	int iItem;

	iItem = ListView_GetNextItem(hwndList,-1,LVNI_SELECTED);
	if (iItem<0)
		return FALSE;

        if (!(hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,iItem))))
		return FALSE;

	DoPolicyDlg(hwndParent,hUser);

	
	return TRUE;
}

/*******************************************************************

	NAME:		CreateListControl

	SYNOPSIS:	Creates list control for main window

********************************************************************/
HWND CreateListControl(HWND hWnd)
{
	HWND hwndList;
	LV_COLUMN lvc;
	int iRet;

	if (!(hwndList = CreateWindowEx(WS_EX_CLIENTEDGE,
		szLISTVIEW,szNull,WS_CHILD | WS_VISIBLE | LVS_REPORT |
		LVS_SORTASCENDING | LVS_SHAREIMAGELISTS,
		0,0,0,0,hWnd,NULL,ghInst,NULL)))
		return NULL;

	lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
	lvc.fmt = LVCFMT_LEFT;
	lvc.cx = 150;
	lvc.pszText = LoadSz(IDS_COLUMNTITLE,szSmallBuf,ARRAYSIZE(szSmallBuf));
	lvc.cchTextMax = lstrlen(lvc.pszText) + 1;
	lvc.iSubItem = 0;
	iRet=ListView_InsertColumn(hwndList,0,&lvc);

	ListView_SetImageList(hwndList,hImageListSmall,LVSIL_SMALL);
	ListView_SetImageList(hwndList,hImageListLarge,LVSIL_NORMAL);

	return hwndList;
}

/*******************************************************************

	NAME:		DestroyListControl

	SYNOPSIS:	Destroys main window list control

********************************************************************/
VOID DestroyListControl(HWND hwndList)
{
	if (hwndList) {
		DestroyWindow(hwndList);
	}
}


/*******************************************************************

	NAME:		UpdateListControlPlacement

	SYNOPSIS:	Fits list control to fill client area in app window,
				making room for toolbar/status bar as appropriate

	NOTES:		Called in response to WM_SIZE

********************************************************************/
VOID UpdateListControlPlacement(HWND hwndApp,HWND hwndList)
{
	RECT rcClient;
	UINT yHeight,yStart=0;
//	LV_COLUMN lvc;

	if (!hwndList) return;

	GetClientRect(hwndApp,&rcClient);
	yHeight = rcClient.bottom-rcClient.top;		

	if (ViewInfo.fToolbar) {
		yStart = ViewInfo.dyToolbar + 1;
		yHeight -= (ViewInfo.dyToolbar + 1);
	}
	if (ViewInfo.fStatusBar) {
		yHeight -= (ViewInfo.dyStatusBar + 1);
	}

	SetWindowPos(hwndList,NULL,0,yStart,rcClient.right,
		yHeight,SWP_NOZORDER);
}

/*******************************************************************

	NAME:		OnSelection

	SYNOPSIS:	Selection notification handler for list control in
				app window

********************************************************************/
BOOL OnSelection(HWND hwndParent,HWND hwndList,NM_LISTVIEW *pnlv)
{
	// if item is selected, make sure "remove" menu item is enabled
	if ((pnlv->uNewState & TVIS_SELECTED)) 
		dwAppState |= AS_CANREMOVE;
	else dwAppState &= ~AS_CANREMOVE;

	// reenable menu items on every selection change, because copy/paste
	// menu items depend on how many & which items are selected
	EnableMenuItems(hwndParent,dwAppState);

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\infmgr.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

BOOL fInfLoaded = FALSE;

BOOL OpenTemplateDlg(HWND hWnd,TCHAR * szFilename,UINT cbFileName);

BOOL GetATemplateFile(HWND hWnd)
{
	TCHAR szTmpFilename[MAX_PATH+1];

	// user cancelled or didn't select a file
	if (!OpenTemplateDlg(hWnd,szTmpFilename,ARRAYSIZE(szTmpFilename)))
		return FALSE;

	SendDlgItemMessage(hWnd,IDD_TEMPLATELIST,LB_ADDSTRING,0,(LPARAM) szTmpFilename);

	return TRUE;
}

UINT LoadTemplatesFromDlg(HWND hWnd)
{
	UINT uRet;
	TCHAR szFilename[MAX_PATH+1];
	UINT i=0;
    DWORD dwUsed, dwSize;

	UnloadTemplates();	// unload previous files, if any
	PrepareToLoadTemplates();

    while (LB_ERR != SendDlgItemMessage(hWnd,IDD_TEMPLATELIST,LB_GETTEXT,
	         i,(LPARAM) szFilename))
	{

		uRet = LoadTemplateFile(hWnd,szFilename);

		if (uRet != ERROR_SUCCESS) {
			if (uRet != ERROR_ALREADY_DISPLAYED) {
				DisplayStandardError(hWnd,szFilename,IDS_ErrOPENTEMPLATE,uRet);
			}

			return uRet;
		}

		i++;
    }


    // Fill up the template file buffer.
    i=0;
    dwUsed = 0;
    while (LB_ERR != SendDlgItemMessage(hWnd,IDD_TEMPLATELIST,LB_GETTEXT,
	         i,(LPARAM) szFilename))
    {
        dwSize = lstrlen(szFilename)+1;
		if (!(pbufTemplates=ResizeBuffer(pbufTemplates,hBufTemplates,dwUsed+dwSize+4,&dwBufTemplates)))
				return ERROR_NOT_ENOUGH_MEMORY;

		lstrcpy(pbufTemplates+dwUsed,szFilename);
		dwUsed += dwSize;
		i++;
	}

	// doubly null-terminate the buffer... safe to do this because we
	// tacked on the extra "+4" in the ResizeBuffer calls above
	*(pbufTemplates+dwUsed) = TEXT('\0');

	return ERROR_SUCCESS;
}

UINT LoadTemplates(HWND hWnd)
{
	UINT uRet;
    TCHAR *szFilename;
	UINT i=0;

	if (!(*pbufTemplates))
	   return ERROR_FILE_NOT_FOUND;  //Nothing to load.
	
	UnloadTemplates();	// unload previous file, if any
	PrepareToLoadTemplates();

    szFilename = pbufTemplates;
	while (*szFilename)
	{
		uRet = LoadTemplateFile(hWnd,szFilename);

		if (uRet != ERROR_SUCCESS) {
			if (uRet != ERROR_ALREADY_DISPLAYED) {
				DisplayStandardError(hWnd,szFilename,IDS_ErrOPENTEMPLATE,uRet);
			}

			return uRet;
		}
		szFilename += lstrlen(szFilename)+1;
	}

	return ERROR_SUCCESS;
}




BOOL OpenTemplateDlg(HWND hWnd,TCHAR * szFilename,UINT cbFilename)
{
	OPENFILENAME ofn;
	TCHAR szFilter[SMALLBUF];
	TCHAR szOpenInfTitle[SMALLBUF];
	
	lstrcpy(szFilename,szNull);
	LoadSz(IDS_InfOPENTITLE,szOpenInfTitle,ARRAYSIZE(szOpenInfTitle));

	// have to load the openfile filter in 2 stages, because the string
	// contains a terminating character and LoadString won't load the
	// whole thing in one go
	memset(szFilter,0,(ARRAYSIZE(szFilter) * sizeof(TCHAR)));
	LoadSz(IDS_InfOPENFILTER1,szFilter,ARRAYSIZE(szFilter));
	LoadSz(IDS_InfOPENFILTER2,szFilter+lstrlen(szFilter)+1,ARRAYSIZE(szFilter)-
		(lstrlen(szFilter)-1));
	
	memset(&ofn,0,sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.hInstance = ghInst;
	ofn.lpstrFilter = szFilter;
	ofn.lpstrFile =	szFilename;
	ofn.nMaxFile = cbFilename;
	ofn.lpstrTitle = szOpenInfTitle;
	ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST
		| OFN_SHAREAWARE | OFN_HIDEREADONLY;

	return GetOpenFileName(&ofn);
}


UINT PrepareToLoadTemplates()
{
	gClassList.nUserDataItems = 0;
	gClassList.nMachineDataItems = 0;

	if (!InitializeRootTables()) 
		return ERROR_NOT_ENOUGH_MEMORY;

        return ERROR_SUCCESS;
}

UINT LoadTemplateFile(HWND hWnd,TCHAR * szFilename)
{
	HANDLE hFile;
	UINT uRet;
	TCHAR szStatusTextOld[255];
	TCHAR szStatusText[SMALLBUF+MAX_PATH+1];

	// open the specified file
	if ((hFile = CreateFile(szFilename,GENERIC_READ,FILE_SHARE_READ,
		NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)) == INVALID_HANDLE_VALUE) {
#ifdef DEBUG
		wsprintf(szDebugOut,TEXT("LoadTemplateFile: CreateFile returned %lu\r\n"),
			GetLastError());
		OutputDebugString(szDebugOut);
#endif
		return (UINT) GetLastError();
	}

	// save old status bar text
	GetStatusText(szStatusTextOld,ARRAYSIZE(szStatusTextOld));

	// set status bar text a la "loading template file <name>..."
	wsprintf(szStatusText,LoadSz(IDS_LOADINGTEMPLATE,szSmallBuf,
		ARRAYSIZE(szSmallBuf)),szFilename);
	SetStatusText(szStatusText);

	uRet=ParseTemplateFile(hWnd,hFile,szFilename);
	
	SetStatusText(szStatusTextOld);
	CloseHandle(hFile);

	if (uRet != ERROR_SUCCESS)
		FreeRootTables();
	else {
		fInfLoaded = TRUE;
		dwAppState |= AS_CANHAVEDOCUMENT;
	}
	return uRet;
}

VOID UnloadTemplates(VOID)
{
	if (fInfLoaded) {
		FreeRootTables();
		fInfLoaded = FALSE;
		dwAppState &= ~AS_CANHAVEDOCUMENT;
	}
}	


VOID EnableMainMenuItems(HWND hwndApp,BOOL fEnable)
{
	HMENU hMenu = GetMenu(hwndApp);
	UINT uFlags = MF_BYCOMMAND | (fEnable ? MF_ENABLED : MF_DISABLED);

	EnableMenuItem(GetMenu(hwndMain),IDM_NEW,uFlags);
	EnableMenuItem(GetMenu(hwndMain),IDM_OPEN,uFlags);

}

/*******************************************************************

	NAME:		GetDefaultTemplateFilename

	SYNOPSIS:	Builds a default .adm path and filename to look for

	NOTES:		Fills szFilename with "<windows dir>\INF\ADMINCFG.ADF".
				Text is loaded from resources since file and directory
				names are localizable.

********************************************************************/
DWORD GetDefaultTemplateFilename(HWND hWnd,TCHAR * pszFilename,UINT cbFileName)
{
        TCHAR szFileName[MAX_PATH] = {0};
        UINT cchFileName;
        LPTSTR lpEnd;


        //
        // Load the common adm file
        //

        if (!GetWindowsDirectory(szFileName,MAX_PATH)) {
            return 0;
        }



        if (lstrlen (szFileName) > (MAX_PATH - 20)) {
            *pszFilename = TEXT('\0');
            return 0;
        }

        lstrcat(szFileName,szSlash);
        lstrcat(szFileName,LoadSz(IDS_INFDIR,szSmallBuf,ARRAYSIZE(szSmallBuf)));
        lstrcat(szFileName,szSlash);
        lstrcat(szFileName,LoadSz(IDS_DEF_COMMONNAME,szSmallBuf,ARRAYSIZE(szSmallBuf)));

        cchFileName = lstrlen (szFileName) + 1;

        if (cchFileName <= cbFileName) {
            lstrcpy (pszFilename, szFileName);
            lpEnd = pszFilename + lstrlen (pszFilename) + 1;
        } else {
            *pszFilename = TEXT('\0');
            return 0;
        }


        //
        // Add on the base adm filename
        //

        if (!GetWindowsDirectory(szFileName,MAX_PATH)) {
            return 0;
        }

        lstrcat(szFileName,szSlash);
        lstrcat(szFileName,LoadSz(IDS_INFDIR,szSmallBuf,ARRAYSIZE(szSmallBuf)));
        lstrcat(szFileName,szSlash);

        if (g_bWinnt) {
            lstrcat(szFileName,LoadSz(IDS_DEF_NT_INFNAME,szSmallBuf,ARRAYSIZE(szSmallBuf)));
        } else {
            lstrcat(szFileName,LoadSz(IDS_DEF_INFNAME,szSmallBuf,ARRAYSIZE(szSmallBuf)));
        }

        cchFileName += lstrlen (szFileName) + 1;

        if (cchFileName < cbFileName) {
            lstrcat (lpEnd, szFileName);
        }

        return (cchFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\listbox.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"

typedef struct tagLISTBOXDLGINFO {
	HGLOBAL hUser;
	SETTINGS * pSettings;
	UINT uDataIndex;
} LISTBOXDLGINFO;

typedef struct tagADDITEMINFO {
	BOOL fExplicitValName;
	BOOL fValPrefix;
	HWND hwndListbox;
	TCHAR szValueName[MAX_PATH+1];	// only used if fExplicitValName is ser
	TCHAR szValueData[MAX_PATH+1];
} ADDITEMINFO;

INT_PTR CALLBACK ShowListboxDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam);
INT_PTR CALLBACK ListboxAddDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam);
BOOL InitShowlistboxDlg(HWND hDlg,LISTBOXDLGINFO * pListboxDlgInfo);
BOOL ProcessShowlistboxDlg(HWND hDlg);
VOID EnableShowListboxButtons(HWND hDlg);

UINT uListboxID;

VOID ShowListbox(HWND hParent,HGLOBAL hUser,SETTINGS * pSettings,UINT uDataIndex)
{
	LISTBOXDLGINFO ListboxDlgInfo;

	ListboxDlgInfo.hUser = hUser;
	ListboxDlgInfo.pSettings = pSettings;
	ListboxDlgInfo.uDataIndex = uDataIndex;

	DialogBoxParam(ghInst,MAKEINTRESOURCE(DLG_SHOWLISTBOX),hParent,
		ShowListboxDlgProc,(LPARAM) &ListboxDlgInfo);
}

VOID ListboxAdd(HWND hwndListbox, BOOL fExplicitValName,BOOL fValuePrefix)
{
	ADDITEMINFO AddItemInfo;
 	LV_ITEM lvi;

	memset(&AddItemInfo,0,sizeof(AddItemInfo));

	AddItemInfo.fExplicitValName = fExplicitValName;
	AddItemInfo.fValPrefix = fValuePrefix;
	AddItemInfo.hwndListbox = hwndListbox;

	// bring up the appropriate add dialog-- one edit field ("type the thing
	// to add") normally, two edit fields ("type the name of the thing, type
	// the value of the thing") if the explicit value style is used
	if (!DialogBoxParam(ghInst,MAKEINTRESOURCE((fExplicitValName ? DLG_LBADD2 :
		DLG_LBADD)),hwndListbox,ListboxAddDlgProc,(LPARAM) &AddItemInfo))
		return;	// user cancelled	

	// add the item to the listbox
	lvi.mask = LVIF_TEXT;
	lvi.iItem=lvi.iSubItem=0;
	lvi.pszText=(fExplicitValName ? AddItemInfo.szValueName :
		AddItemInfo.szValueData);
	lvi.cchTextMax = lstrlen(lvi.pszText)+1;
	if ((lvi.iItem=ListView_InsertItem(hwndListbox,&lvi))<0) {
		// if add fails, display out of memory error
		MsgBox(hwndListbox,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return;
	}

	if (fExplicitValName) {
		lvi.iSubItem=1;
		lvi.pszText=AddItemInfo.szValueData;
		lvi.cchTextMax = lstrlen(lvi.pszText)+1;
		if (ListView_SetItem(hwndListbox,&lvi) < 0) {
			MsgBox(hwndListbox,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
			return;
		}
	}
}

VOID ListboxRemove(HWND hDlg,HWND hwndListbox)
{
	int nItem;

	while ( (nItem=ListView_GetNextItem(hwndListbox,-1,LVNI_SELECTED))
		>= 0) {
	 	ListView_DeleteItem(hwndListbox,nItem);
	}

	EnableShowListboxButtons(hDlg);
}

INT_PTR CALLBACK ShowListboxDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	switch (uMsg) {

		case WM_INITDIALOG:
			// store away pointer to ListboxDlgInfo in window data
			SetWindowLongPtr(hDlg,DWLP_USER,lParam);
			if (!InitShowlistboxDlg(hDlg,(LISTBOXDLGINFO *) lParam)) {
				MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
				EndDialog(hDlg,FALSE);
			}
			return TRUE;
			break;

		case WM_COMMAND:

			switch (wParam) {

				case IDOK:
					if (!ProcessShowlistboxDlg(hDlg)) {
						MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
						return FALSE;
					}
					EndDialog(hDlg,TRUE);

					break;

				case IDCANCEL:
					EndDialog(hDlg,FALSE);
					break;

				case IDD_ADD:
					{
						LISTBOXDLGINFO * pListboxDlgInfo =
							(LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
						ListboxAdd(GetDlgItem(hDlg,uListboxID), (BOOL)
							pListboxDlgInfo->pSettings->dwFlags & DF_EXPLICITVALNAME,
							(BOOL)( ((LISTBOXINFO *)
							GETOBJECTDATAPTR(pListboxDlgInfo->pSettings))->
							uOffsetPrefix));
					}
					break;

				case IDD_REMOVE:
					ListboxRemove(hDlg,GetDlgItem(hDlg,uListboxID));
					break;

			}		

			case WM_NOTIFY:
				
				if (wParam == uListboxID) {
                                    if (((NMHDR FAR*)lParam)->code == LVN_ITEMCHANGED) {
					EnableShowListboxButtons(hDlg);
                                    }
                                }

				break;

			break;
	}

	return FALSE;
}

BOOL InitShowlistboxDlg(HWND hDlg,LISTBOXDLGINFO * pListboxDlgInfo)
{
	HGLOBAL hUser = pListboxDlgInfo->hUser;
	SETTINGS * pSettings = pListboxDlgInfo->pSettings;
	LV_COLUMN lvc;
	RECT rcListbox;
	UINT uColWidth,uOffsetData;
	HWND hwndListbox;
	USERDATA * pUserData;
	BOOL fSuccess=TRUE;

	// there are 2 listview controls in dialog, 1 with header bar
	// and one without; hide the control we aren't going to use
	if (pSettings->dwFlags & DF_EXPLICITVALNAME) {
		uListboxID = IDD_LISTBOX;
		ShowWindow(GetDlgItem(hDlg,IDD_LISTBOX1),SW_HIDE);
	} else {
		uListboxID = IDD_LISTBOX1;
		ShowWindow(GetDlgItem(hDlg,IDD_LISTBOX),SW_HIDE);
	}

	hwndListbox = GetDlgItem(hDlg,uListboxID);

	// set the setting title in the dialog
	SetDlgItemText(hDlg,IDD_TITLE,GETNAMEPTR(pSettings));

	GetClientRect(hwndListbox,&rcListbox);
	uColWidth = rcListbox.right-rcListbox.left;

	if (pSettings->dwFlags & DF_EXPLICITVALNAME)
		uColWidth /= 2;

	if (pSettings->dwFlags & DF_EXPLICITVALNAME) {
		// add a 2nd column to the listview control
		lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
		lvc.fmt = LVCFMT_LEFT;
		lvc.cx = uColWidth-1;
		lvc.pszText = LoadSz(IDS_VALUENAME,szSmallBuf,ARRAYSIZE(szSmallBuf));
		lvc.cchTextMax = lstrlen(lvc.pszText)+1;
		lvc.iSubItem = 0;
		ListView_InsertColumn(hwndListbox,0,&lvc);

	}

	// add a column to the listview control
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvc.fmt = LVCFMT_LEFT;
	lvc.cx = uColWidth;
	lvc.pszText = LoadSz(IDS_VALUE,szSmallBuf,ARRAYSIZE(szSmallBuf));
	lvc.cchTextMax = lstrlen(lvc.pszText)+1;
	lvc.iSubItem = (pSettings->dwFlags & DF_EXPLICITVALNAME ? 1 : 0);
	ListView_InsertColumn(hwndListbox,lvc.iSubItem,&lvc);

	SetWindowLong(hwndListbox,GWL_EXSTYLE,WS_EX_CLIENTEDGE);

	SetScrollRange(hwndListbox,SB_VERT,0,100,TRUE);
	SetScrollRange(hwndListbox,SB_VERT,0,0,TRUE);

	EnableShowListboxButtons(hDlg);

	// insert the items from user's data buffer into the listbox
	if (!(pUserData = (USERDATA *) GlobalLock(hUser)))
		return FALSE;

	uOffsetData=pUserData->SettingData[pListboxDlgInfo->uDataIndex].uOffsetData;
	if (uOffsetData) {
		TCHAR * pszData =((STRDATA *)((LPBYTE) pUserData + uOffsetData))->szData;

		while (*pszData && fSuccess) {
			LV_ITEM lvi;

			lvi.pszText=pszData;
			lvi.mask = LVIF_TEXT;
			lvi.iItem=-1;
			lvi.iSubItem=0;
 			lvi.cchTextMax = lstrlen(pszData)+1;

			// if explicit valuename flag set, entries are stored
			// <value name>\0<value>\0....<value name>\0<value>\0\0
			// otherwise, entries are stored
			// <value>\0<value>\0....<value>\0

			if (pSettings->dwFlags & DF_EXPLICITVALNAME) {
				fSuccess=((lvi.iItem=ListView_InsertItem(hwndListbox,&lvi)) >= 0);

				pszData += lstrlen(pszData) +1;	

				if (fSuccess && *pszData) {
					lvi.iSubItem=1;
					lvi.pszText=pszData;
		 			lvi.cchTextMax = lstrlen(pszData)+1;
					fSuccess=(ListView_SetItem(hwndListbox,&lvi) >= 0);
					pszData += lstrlen(pszData) +1;	
				}
			} else {
				fSuccess=((lvi.iItem=ListView_InsertItem(hwndListbox,&lvi)) >= 0);
				pszData += lstrlen(pszData) +1;
			}
		}
	}

	GlobalUnlock(hUser);

	return fSuccess;
}

BOOL ProcessShowlistboxDlg(HWND hDlg)
{
	LISTBOXDLGINFO * pListboxDlgInfo = (LISTBOXDLGINFO *)
		GetWindowLongPtr(hDlg,DWLP_USER);	// get pointer to struct from window data
	DWORD dwAlloc=1024,dwUsed=0;
	HGLOBAL hBuf;
	TCHAR * pBuf;
	HWND hwndListbox = GetDlgItem(hDlg,uListboxID);
	LV_ITEM lvi;
	UINT nLen;
	int nCount;
	BOOL fSuccess;
	TCHAR pszText[MAX_PATH+1];

	// allocate a temp buffer to read entries into
	if (!(hBuf = GlobalAlloc(GHND,dwAlloc * sizeof(TCHAR))) ||
		!(pBuf = (TCHAR *) GlobalLock(hBuf))) {
	 	if (hBuf)
			GlobalFree(hBuf);
		return FALSE;
	}

	lvi.mask = LVIF_TEXT;
	lvi.iItem=0;
	lvi.pszText = pszText;
	lvi.cchTextMax = ARRAYSIZE(pszText);
	nCount = ListView_GetItemCount(hwndListbox);

	// retrieve the items out of listbox, pack into temp buffer
	for (;lvi.iItem<nCount;lvi.iItem ++) {
		lvi.iSubItem = 0;
		if (ListView_GetItem(hwndListbox,&lvi)) {
			nLen = lstrlen(lvi.pszText) + 1;
			if (!(pBuf=ResizeBuffer(pBuf,hBuf,dwUsed+nLen+4,&dwAlloc)))
				return ERROR_NOT_ENOUGH_MEMORY;
			lstrcpy(pBuf+dwUsed,lvi.pszText);
			dwUsed += nLen;
		}

		if (pListboxDlgInfo->pSettings->dwFlags & DF_EXPLICITVALNAME) {
			lvi.iSubItem = 1;
			if (ListView_GetItem(hwndListbox,&lvi)) {
				nLen = lstrlen(lvi.pszText) + 1;
				if (!(pBuf=ResizeBuffer(pBuf,hBuf,dwUsed+nLen+4,&dwAlloc)))
					return ERROR_NOT_ENOUGH_MEMORY;
				lstrcpy(pBuf+dwUsed,lvi.pszText);
				dwUsed += nLen;
			}
		}
	}
	// doubly null-terminate the buffer... safe to do this because we
	// tacked on the extra "+4" in the ResizeBuffer calls above
	*(pBuf+dwUsed) = TEXT('\0');
	dwUsed ++;

	fSuccess=SetVariableLengthData(pListboxDlgInfo->hUser,
		pListboxDlgInfo->uDataIndex,pBuf,dwUsed);
		
	GlobalUnlock(hBuf);
	GlobalFree(hBuf);

	return fSuccess;
}

VOID EnableShowListboxButtons(HWND hDlg)
{
	BOOL fEnable;

	// enable Remove button if there are any items selected
	fEnable = (ListView_GetNextItem(GetDlgItem(hDlg,uListboxID),
		-1,LVNI_SELECTED) >= 0);

	EnableDlgItem(hDlg,IDD_REMOVE,fEnable);
}

INT_PTR CALLBACK ListboxAddDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	switch (uMsg) {

		case WM_INITDIALOG:
                        {
                        ADDITEMINFO * pAddItemInfo = (ADDITEMINFO *)lParam;

			// store away pointer to additeminfo in window data
			SetWindowLongPtr(hDlg,DWLP_USER,lParam);
			SendDlgItemMessage(hDlg,IDD_VALUENAME,EM_LIMITTEXT,MAX_PATH,0L);
			SendDlgItemMessage(hDlg,IDD_VALUEDATA,EM_LIMITTEXT,MAX_PATH,0L);

                        if (!pAddItemInfo->fExplicitValName) {
                            ShowWindow (GetDlgItem (hDlg, IDD_VALUENAME), SW_HIDE);
                        }
                        }
			break;

		case WM_COMMAND:

			switch (wParam) {

				case IDOK:
					{
						ADDITEMINFO * pAddItemInfo = (ADDITEMINFO *)
						GetWindowLongPtr(hDlg,DWLP_USER);
	
						GetDlgItemText(hDlg,IDD_VALUENAME,
							pAddItemInfo->szValueName,
							ARRAYSIZE(pAddItemInfo->szValueName));

						GetDlgItemText(hDlg,IDD_VALUEDATA,
							pAddItemInfo->szValueData,
							ARRAYSIZE(pAddItemInfo->szValueData));

						// if explicit value names used, value name must
						// not be empty, and it must be unique
						if (pAddItemInfo->fExplicitValName) {
							LV_FINDINFO lvfi;
							int iSel;

							if (!lstrlen(pAddItemInfo->szValueName)) {
								// can't be empty
								MsgBox(hDlg,IDS_EMPTYVALUENAME,
									MB_ICONINFORMATION,MB_OK);
								SetFocus(GetDlgItem(hDlg,IDD_VALUENAME));
								return FALSE;
							}

							lvfi.flags = LVFI_STRING | LVFI_NOCASE;
							lvfi.psz = pAddItemInfo->szValueName;

							iSel=ListView_FindItem(pAddItemInfo->hwndListbox,
								-1,&lvfi);

							if (iSel >= 0) {
								// value name already used
								MsgBox(hDlg,IDS_VALUENAMENOTUNIQUE,
									MB_ICONINFORMATION,MB_OK);
								SetFocus(GetDlgItem(hDlg,IDD_VALUENAME));
								SendDlgItemMessage(hDlg,IDD_VALUENAME,
									EM_SETSEL,0,-1);
								return FALSE;
							}
						} else if (!pAddItemInfo->fValPrefix) {
							// if value name == value data, then value data
							// must be unique
						
							LV_FINDINFO lvfi;
							int iSel;

							if (!lstrlen(pAddItemInfo->szValueData)) {
								// can't be empty
								MsgBox(hDlg,IDS_EMPTYVALUEDATA,
									MB_ICONINFORMATION,MB_OK);
								SetFocus(GetDlgItem(hDlg,IDD_VALUEDATA));
								return FALSE;
							}

							lvfi.flags = LVFI_STRING | LVFI_NOCASE;
							lvfi.psz = pAddItemInfo->szValueData;

							iSel=ListView_FindItem(pAddItemInfo->hwndListbox,
								-1,&lvfi);

							if (iSel >= 0) {
								// value name already used
								MsgBox(hDlg,IDS_VALUEDATANOTUNIQUE,
									MB_ICONINFORMATION,MB_OK);
								SetFocus(GetDlgItem(hDlg,IDD_VALUEDATA));
								SendDlgItemMessage(hDlg,IDD_VALUEDATA,
									EM_SETSEL,0,-1);
								return FALSE;
							}

						}
						EndDialog(hDlg,TRUE);
					}

					break;

				case IDCANCEL:
					EndDialog(hDlg,FALSE);
					break;
			}

			break;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\memory.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

CLASSLIST gClassList;

/*******************************************************************

	Memory Management Strategy:

	Information about categories, policies and settings are stored in
	tables.  Each table has one global handle and is moveable (so it
	must be locked before use).

	Tables contain a table header, a TABLEHDR struct, followed by
	zero or more variable-length table entries.	 The TABLEHDR contains
	the size in bytes and the number of entries in the table.

	Entries in a table contain information such as the name of the entry,
	and a handle to a sub-table.  For instance, a category entry will
	have the name of the category and a handle to a table of policies for
	that category.  When that category is selected, the policies in its
	sub-table will be displayed.  Similarly, each policy has a handle
	to a sub-table which is a table of settings.  (Settings do not have
	any subcomponents, so they always have a NULL subtable.)

	A graphic representation is:


	(category table)

	+-----------------+
	|    TABLEHDR     |
	+-----------------+
	| CATEGORY 0	  |	
	| Subtable Handle------------------> +-----------------+
	| other data      |					 |    TABLEHDR     |
	+-----------------+       			 +-----------------+
	| CATEGORY 1	  |		  			 | POLICY 0        |
	| Subtable Handle-------> +-----------------+le Handle--->etc.
	| other data      |		  |    TABLEHDR     | data     |
	+-----------------+		  +-----------------+----------+
	| CATEGORY 2	  |		  | POLICY 0        |		   |
	| Subtable Handle-->etc.  | Subtable Handle------>  +----------------+
	| other data      |		  | Other data      |		|    TABLEHDR    |
    |				  |		  +-----------------+		+----------------+
							  | POLICY 1        |       | SETTING 0      |
							  |	Subtable Handle-->etc.  | Data           |
	                          | Other data      |       +----------------+
														|                |
				
********************************************************************/


/*******************************************************************

	NAME:		FreeTable

	SYNOPSIS:	Frees the specified table and all sub-tables of that
				table.

	NOTES:		Walks through the table entries and calls itself to
				recursively free sub-tables.

	EXIT:		Returns TRUE if successful, FALSE if a memory error
				occurs.

********************************************************************/
BOOL FreeTable(TABLEENTRY * pTableEntry)
{
	TABLEENTRY * pNext = pTableEntry->pNext;

	// free all children
	if (pTableEntry->pChild)
		FreeTable(pTableEntry->pChild);

	GlobalFree(pTableEntry);

	if (pNext) FreeTable(pNext);

	return TRUE;
}

BOOL InitializeRootTables( VOID )
{
	memset(&gClassList,0,sizeof(gClassList));

	gClassList.pMachineCategoryList = (TABLEENTRY *)
		GlobalAlloc(GPTR,sizeof(TABLEENTRY));
	gClassList.pUserCategoryList = (TABLEENTRY *)
		GlobalAlloc(GPTR,sizeof(TABLEENTRY));

	if (!gClassList.pMachineCategoryList || !gClassList.pUserCategoryList) {
		if (gClassList.pMachineCategoryList)
			GlobalFree(gClassList.pMachineCategoryList);
		if (gClassList.pUserCategoryList)
			GlobalFree(gClassList.pUserCategoryList);

		return FALSE;
	}

	gClassList.pMachineCategoryList->dwSize = gClassList.pUserCategoryList->dwSize =
		sizeof(TABLEENTRY);

	gClassList.pMachineCategoryList->dwType = gClassList.pUserCategoryList->dwType =
		ETYPE_ROOT;
	
	return TRUE;
}

VOID FreeRootTables( VOID )
{
 	if (gClassList.pMachineCategoryList) {
		FreeTable(gClassList.pMachineCategoryList);
	 	gClassList.pMachineCategoryList = NULL;
	}
 	if (gClassList.pUserCategoryList) {
		FreeTable(gClassList.pUserCategoryList);
	 	gClassList.pUserCategoryList = NULL;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\main.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

HWND hwndMain=NULL;
HWND hwndUser=NULL;

BOOL OnCreate(HWND hWnd);
BOOL OnInit(HWND hWnd);
VOID OnDestroy(HWND hWnd);

VOID ProcessMouseDown(HWND hwndParent,HWND hwndTree);
VOID ProcessMouseUp(HWND hwndParent,HWND hwndTree);
VOID ProcessMouseMove(HWND hwndParent,HWND hwndTree);
VOID CheckMenuItems(HWND hwndApp);

DWORD dwAppState = 0;
BOOL fNetworkInstalled = 0;
TCHAR szDatFilename[MAX_PATH+1]=TEXT("");
TCHAR szDlgModeUserName[USERNAMELEN+1];
extern HGLOBAL hClipboardUser;
/*******************************************************************

	NAME:		WndProc

	SYNOPSIS:	Window proc for main window

********************************************************************/
LRESULT CALLBACK WndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	int wmId, wmEvent;

	switch (message) {

		case WM_COMMAND:  // message: command from application menu

			wmId    = LOWORD(wParam);
			wmEvent = HIWORD(wParam);

			if (wmId >= IDM_FILEHISTORY && wmId < IDM_FILEHISTORY +
				FILEHISTORY_COUNT) {
				MENUITEMINFO mii;
				TCHAR szFilename[MAX_PATH+1];
				mii.dwTypeData = szFilename;
				mii.cch = ARRAYSIZE(szFilename);

				// this is a file menu shortcut with a filename, try
				// to open
				if (!(dwAppState & AS_CANHAVEDOCUMENT))
					return FALSE;

				mii.cbSize = sizeof(mii);
				mii.fMask = MIIM_TYPE;
				mii.wID = wmId;
	
				if (GetMenuItemInfo(GetSubMenu(GetMenu(hWnd),0),
					wmId,FALSE,&mii)) {
					if (!lstrlen(szFilename))
						return FALSE;

					if (dwAppState & AS_FILEDIRTY) {
						if (!QueryForSave(hWnd,hwndUser))
						return TRUE;	// user cancelled
					}

					// open the file
					OnOpen_W(hWnd,hwndUser,szFilename);
					return TRUE;
				} 
			}
			switch (wmId) {

				case IDM_ABOUT:
					ShellAboutA ( hWnd, szAppName, szNull,
						LoadIcon( ghInst, MAKEINTRESOURCE(IDI_APPICON)) );
					break;

				case IDM_EXIT:
					if (dwAppState & AS_FILEDIRTY) {
						if (!QueryForSave(hWnd,hwndUser)) return TRUE;	// user cancelled
			        }
					DestroyWindow(hWnd);
					break;

				case IDM_NEW:
					OnNew(hWnd,hwndUser);
					break;

				case IDM_OPEN:
					OnOpen(hWnd,hwndUser);
					break;

				case IDM_OPENREGISTRY:
					OnOpenRegistry(hWnd,hwndUser,TRUE);
					break;

				case IDM_TEMPLATEOPT:
					OnTemplateOptions(hWnd);
					break;

#ifdef INCL_GROUP_SUPPORT
				case IDM_GROUPPRIORITY:
					OnGroupPriority(hWnd);
					break;
#endif

				case IDM_SAVE:
					OnSave(hWnd,hwndUser);
					break;

				case IDM_SAVEAS:
					OnSaveAs(hWnd,hwndUser);
					break;

				case IDM_CLOSE:
					OnClose(hWnd,hwndUser);
					break;

				case IDM_COPY:
					OnCopy(hWnd,hwndUser);
					break;

				case IDM_PASTE:
					OnPaste(hWnd,hwndUser);
					break;

				case IDM_CONNECT:
					OnConnect(hWnd,hwndUser);
					break;

				case IDM_DISCONNECT:
					OnClose(hWnd,hwndUser);
					break;

				case IDM_ADDUSER:
					DoAddUserDlg(hWnd,hwndUser);
					break;

#ifdef INCL_GROUP_SUPPORT
				case IDM_ADDGROUP:
					DoAddGroupDlg(hWnd,hwndUser);
					break;
#endif

				case IDM_REMOVE:
					OnRemove(hWnd,hwndUser);
					break;

				case IDM_ADDWORKSTATION:
					DoAddComputerDlg(hWnd,hwndUser);
					break;

				case IDM_PROPERTIES:
					OnProperties(hWnd,hwndUser);
					break;

				case IDM_SMALLICONS:
					SetNewView(hWnd,hwndUser,VT_SMALLICONS);
					break;

				case IDM_LARGEICONS:
					SetNewView(hWnd,hwndUser,VT_LARGEICONS);
					break;

				case IDM_LIST:
					SetNewView(hWnd,hwndUser,VT_LIST);
					break;

				case IDM_DETAILS:
					SetNewView(hWnd,hwndUser,VT_REPORT);
					break;
			
	
				case IDM_TOOLBAR:
					ViewInfo.fToolbar = !ViewInfo.fToolbar;
					ShowWindow(hwndToolbar,(ViewInfo.fToolbar ? SW_SHOW : SW_HIDE));
					UpdateListControlPlacement(hWnd,hwndUser);
					CheckMenuItems(hWnd);
					break;
				
				case IDM_STATUSBAR:
					ViewInfo.fStatusBar = !ViewInfo.fStatusBar;
					ShowWindow(hwndStatusBar,(ViewInfo.fStatusBar ? SW_SHOW : SW_HIDE));
					UpdateListControlPlacement(hWnd,hwndUser);			
					CheckMenuItems(hWnd);
					break;

				case IDM_HELPCONTENTS:
					HtmlHelp(hWnd,LoadSz(IDS_HELPFILE,szSmallBuf,ARRAYSIZE(szSmallBuf)),
                                                HH_HELP_FINDER,0);
						

					break;

				default:
					return (DefWindowProc(hWnd, message, wParam, lParam));
			}
			break;

		case WM_CREATE:
			if (!OnCreate(hWnd)) {
				return (-1);  // fail creation
			}

			return 0;
			break;

		case WM_FINISHINIT:
			OnInit(hWnd);	// finish doing init stuff
			break;

		case WM_SETFOCUS:
			if (hwndUser) SetFocus(hwndUser);
			break;

		case WM_PAINT:
			{
				PAINTSTRUCT ps;
				BeginPaint(hWnd,&ps);
				EndPaint(hWnd,&ps);
			}
			break;

		case WM_QUERYENDSESSION:
		case WM_CLOSE:
			if (dwAppState & AS_FILEDIRTY) {
				if (!QueryForSave(hWnd,hwndUser)) return TRUE;	// user cancelled
	        }
			goto defproc;
			break;

		case WM_DESTROY:
			OnDestroy(hWnd);
			break;

		case WM_SIZE:

			if (hwndStatusBar)
				SendMessage( hwndStatusBar, WM_SIZE, wParam, lParam );
			if (hwndToolbar)
				SendMessage( hwndToolbar, WM_SIZE, wParam, lParam );
			UpdateListControlPlacement(hWnd,hwndUser);			

			break;

		case WM_NOTIFY:

			if (((NMHDR *) lParam)->hwndFrom == hwndUser) {
				return OnListNotify(hWnd,hwndUser,(NM_LISTVIEW *) lParam);
			}

			{
				NMHDR * pnmhdr = (NMHDR *) lParam;
				if (pnmhdr->code == TTN_NEEDTEXT &&
					pnmhdr->hwndFrom == (HWND)
					SendMessage(hwndToolbar,TB_GETTOOLTIPS,0,0L))
				return (ProcessTooltips((TOOLTIPTEXT *) lParam));
			}

			break;

		default:          // Passes it on if unproccessed
defproc:
			return (DefWindowProc(hWnd, message, wParam, lParam));
	}
	return (0);
}

BOOL OnCreate(HWND hWnd)
{
	hwndMain=hWnd;
	InitCommonControls();
	RestoreStateFromRegistry(hWnd);
	dwAppState = AS_CANOPENTEMPLATE;

	if (!InitImageLists() || !(hwndUser=CreateListControl(hWnd)) ||
		(!InitToolbar(hWnd))) {
		MsgBox(hWnd,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		FreeImageLists();
		DestroyListControl(hwndUser);
		hwndUser=NULL;
		DeInitToolbar();
		return FALSE;
	}

        EnableWindow(hwndUser, FALSE);

	LoadFileMenuShortcuts(GetSubMenu(GetMenu(hWnd),0));
	SetNewView(hWnd,hwndUser,ViewInfo.dwView);
	UpdateListControlPlacement(hWnd,hwndUser);
	SetFocus(hwndUser);

	// send a WM_FINISHINIT message to ourselves to load template file
	// and data file.  Do this after WM_CREATE returns so that status
	// bar can display text, etc
	PostMessage(hWnd,WM_FINISHINIT,0,0L);

	return TRUE;
}

BOOL OnInit(HWND hWnd)
{
	HKEY hKey;

	// check to see if we have a network installed
        if (GetSystemMetrics(SM_NETWORK) & 0x1) {
            fNetworkInstalled = TRUE;
        }

	if (fNetworkInstalled) {
		// add a "connect" menu item
		MENUITEMINFO mii;
		HMENU hMenu = GetSubMenu(GetMenu(hWnd),0);

		mii.cbSize = sizeof(mii);
	
		mii.fMask = MIIM_TYPE;
		mii.fType = MFT_SEPARATOR;
		InsertMenuItem(hMenu,6,TRUE,&mii);

		mii.fMask = MIIM_TYPE | MIIM_ID;
		mii.wID = IDM_CONNECT;
		mii.fType = MFT_STRING;
		mii.dwTypeData = szSmallBuf;
		LoadSz(IDS_CONNECT,szSmallBuf,ARRAYSIZE(szSmallBuf));
		InsertMenuItem(hMenu,7,TRUE,&mii);
	}

	if (!(dwCmdLineFlags & CLF_DIALOGMODE)) {
		if ((LoadTemplates(hWnd) == ERROR_SUCCESS) 
		      || (GetATemplateFile(hWnd) && (LoadTemplates(hWnd) == ERROR_SUCCESS))) {
				dwAppState |= AS_CANHAVEDOCUMENT;
		}
	}

	// if filename specified on command line, try to load it
	if (!(dwCmdLineFlags & CLF_DIALOGMODE) && szDatFilename[0]) {
		OnOpen_W(hWnd,hwndUser,szDatFilename);
	}

	EnableMenuItems(hWnd,dwAppState);
	CheckMenuItems(hWnd);

	return TRUE;
}

VOID RunDialogMode(HWND hWnd,HWND hwndUser)
{
	int iStart = 0;
	HGLOBAL hUser=NULL;
	UINT uRet;
	extern DWORD dwDlgRetCode;

	// load the template file
	if (uRet = LoadTemplates(hWnd) != ERROR_SUCCESS) {
		switch (uRet) {
			case ERROR_FILE_NOT_FOUND:
				dwDlgRetCode = AD_ADMNOTFOUND;
				break;

			case ERROR_NOT_ENOUGH_MEMORY:
				dwDlgRetCode = AD_OUTOFMEMORY;
				break;

			default:
				dwDlgRetCode = AD_ADMLOADERR;
				break;
		}
		return;
	}
	// try to load the data file
	if (!LoadFile(szDatFilename,hWnd,hwndUser,FALSE)) {
		// if we can't load it, try creating it
		if (CreateHiveFile(szDatFilename) != ERROR_SUCCESS ||
			!LoadFile(szDatFilename,hWnd,hwndUser,TRUE)) {
			dwDlgRetCode = AD_POLLOADERR;
			return;
		}
	}
	
	dwAppState = AS_FILELOADED | AS_FILEHASNAME | AS_LOCALREGISTRY;

	hUser = FindUser(hwndUser,szDlgModeUserName,(dwCmdLineFlags & CLF_USEWORKSTATIONNAME
				? UT_MACHINE : UT_USER));

	// if user is not in policy file, create a new one
	if (!hUser) {
		hUser = AddUser(hwndUser,szDlgModeUserName,(dwCmdLineFlags &
			CLF_USEWORKSTATIONNAME ? UT_MACHINE : UT_USER));
	}

	if (!hUser) {
		MsgBox(hWnd,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		dwDlgRetCode = AD_OUTOFMEMORY;
		return;
	}

	// run properties dialog
	if (DoPolicyDlg(hWnd,hUser)) {
		// save changes if user OK's the dialog
		dwAppState = AS_FILELOADED | AS_FILEHASNAME | AS_POLICYFILE | AS_FILEDIRTY;
		if (!SaveFile(szDatFilename,hWnd,hwndUser))
			dwDlgRetCode = AD_POLSAVEERR;
	}
}

VOID OnDestroy(HWND hWnd)
{
	UnloadTemplates();

#ifdef INCL_GROUP_SUPPORT
	FreeGroupPriorityList();
#endif

	SaveStateToRegistry(hWnd);
	SaveFileMenuShortcuts(GetSubMenu(GetMenu(hWnd),0));
	if (hwndUser)
		RemoveAllUsers(hwndUser);
	if (hClipboardUser)
		GlobalFree(hClipboardUser);
	DestroyListControl(hwndUser);
	hwndUser=NULL;
	DeInitToolbar();
	FreeImageLists();

    if (pbufTemplates)
    {
        GlobalUnlock(hBufTemplates);
        GlobalFree(hBufTemplates);
    }    


	PostQuitMessage(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\memory.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#ifndef _MEMORY_H_
#define _MEMORY_H_

#define DEFAULT_ENUM_BUF_SIZE 256

//	Entry type ID's
#define ETYPE_CATEGORY		0x0001
#define ETYPE_POLICY		0x0002
#define ETYPE_SETTING		0x0004
#define ETYPE_ROOT			0x0008

#define ETYPE_MASK			0x000F

//  Setting type ID's
#define STYPE_TEXT			0x0010
#define STYPE_CHECKBOX		0x0020
#define STYPE_ENUM			0x0040
#define STYPE_EDITTEXT		0x0080
#define STYPE_NUMERIC		0x0100
#define STYPE_COMBOBOX		0x0200
#define STYPE_DROPDOWNLIST	0x0400
#define STYPE_LISTBOX		0x0800

#define STYPE_MASK			0xFFF0

//  Flags
#define DF_REQUIRED		0x0001	// text or numeric field required to have entry
#define DF_USEDEFAULT           0x0002  // use specified text or numeric value
#define DF_DEFCHECKED           0x0004  // initialize checkbox or radio button as checked
#define DF_TXTCONVERT           0x0008  // save numeric values as text rather than binary
#define DF_ADDITIVE		0x0010	// listbox is additive, rather than destructive
#define DF_EXPLICITVALNAME      0x0020  // listbox value names need to be specified for each entry
#define DF_NOSORT               0x0040  // listbox is not sorted alphabetically.  Uses order in ADM.
#define DF_EXPANDABLETEXT       0x0080  // write REG_EXPAND_SZ text value
#define VF_ISNUMERIC            0x0100  // value is numeric (rather than text)
#define VF_DELETE		0x0200	// value should be deleted
#define VF_SOFT			0x0400	// value is soft (only propagated if doesn't exist on destination)

// generic table entry
typedef struct tagTABLEENTRY {
	DWORD	dwSize;
	DWORD	dwType;
	struct  tagTABLEENTRY * pNext;	// ptr to next sibling in node
	struct  tagTABLEENTRY * pChild;	// ptr to child node
	UINT 	uOffsetName;			// offset from beginning of struct to name
	UINT	uOffsetKeyName;			// offset from beginning of struct to key name
	// table entry information here
} TABLEENTRY;

typedef struct tagACTION {
	DWORD	dwFlags;			// can be VF_ISNUMERIC, VF_DELETE, VF_SOFT
	UINT	uOffsetKeyName;
	UINT	uOffsetValueName;
	union {
		UINT	uOffsetValue;	// offset to value, if text
		DWORD	dwValue;		// value, if numeric
	};
	UINT	uOffsetNextAction;
	// key name, value name, value stored here
} ACTION;

typedef struct tagACTIONLIST {
	UINT	nActionItems;	
	ACTION	Action[];
} ACTIONLIST;

typedef struct tagSTATEVALUE {
	DWORD dwFlags;				// can be VF_ISNUMERIC, VF_DELETE, VF_SOFT
	union {
		TCHAR	szValue[];		// value, if text
		DWORD	dwValue;		// value, if numeric
	};
} STATEVALUE;

// specialized nodes -- CATEGORY, POLICY and SETTING can all be cast to TABLEENTRY
typedef struct tagCATEGORY {
	DWORD 	dwSize;				// size of this struct (including variable-length name)
	DWORD	dwType;
	struct  tagTABLEENTRY * pNext;	// ptr to next sibling in node
	struct  tagTABLEENTRY * pChild;	// ptr to child node
	UINT 	uOffsetName;			// offset from beginning of struct to name
	UINT	uOffsetKeyName;			// offset from beginning of struct to key name
	// category name stored here
	// category registry key name stored here
} CATEGORY;

typedef struct tagPOLICY {
	DWORD 	dwSize;				// size of this struct (including variable-length name)
	DWORD   dwType;
	struct  tagTABLEENTRY * pNext;	// ptr to next sibling in node
	struct  tagTABLEENTRY * pChild;	// ptr to child node
	UINT 	uOffsetName;			// offset from beginning of struct to name
	UINT	uOffsetKeyName;			// offset from beginning of struct to key name
	UINT	uOffsetValueName;		// offset from beginning of struct to value name
	UINT	uDataIndex;				// index into user's data buffer for this setting
	UINT	uOffsetValue_On; 		// offset to STATEVALUE for ON state
	UINT	uOffsetValue_Off;		// offset to STATEVALUE for OFF state
	UINT	uOffsetActionList_On; 	// offset to ACTIONLIST for ON state
	UINT	uOffsetActionList_Off;  // offset to ACTIONLIST for OFF state
	// name stored here
	// policy registry key name stored here
} POLICY;

typedef struct tagSETTINGS {
	DWORD 	dwSize;				// size of this struct (including variable-length data)
	DWORD   dwType;
	struct  tagTABLEENTRY * pNext;	// ptr to next sibling in node
	struct  tagTABLEENTRY * pChild;	// ptr to child node
	UINT 	uOffsetName;			// offset from beginning of struct to name
	UINT	uOffsetKeyName;			// offset from beginning of struct to key name
	UINT	uOffsetValueName;		// offset from beginning of struct to value name
	UINT	uDataIndex;			// index into user's data buffer for this setting
	UINT	uOffsetObjectData;		// offset to object data
	DWORD   dwFlags;				// can be DF_REQUIRED, DF_USEDEFAULT, DF_DEFCHECKED,
									// VF_SOFT, DF_NO_SORT
	// settings registry value name stored here
	// object-dependent data stored here  (a CHECKBOXINFO,
	// RADIOBTNINFO, EDITTEXTINFO, or NUMERICINFO struct)
} SETTINGS;

typedef struct tagCHECKBOXINFO {
	UINT	uOffsetValue_On; 		// offset to STATEVALUE for ON state
	UINT	uOffsetValue_Off;		// offset to STATEVALUE for OFF state
	UINT	uOffsetActionList_On; 	// offset to ACTIONLIST for ON state
	UINT	uOffsetActionList_Off;  // offset to ACTIONLIST for OFF state
} CHECKBOXINFO;

typedef struct tagEDITTEXTINFO {
	UINT	uOffsetDefText;
	UINT	nMaxLen;			// max len of edit field
} EDITTEXTINFO;

typedef struct tagPOLICYCOMBOBOXINFO {
	UINT	uOffsetDefText;
	UINT	nMaxLen;			// max len of edit field
	UINT	uOffsetSuggestions;
} POLICYCOMBOBOXINFO;

typedef struct tagNUMERICINFO {
	UINT	uDefValue;			// default value
	UINT	uMaxValue;			// minimum value
	UINT	uMinValue;			// maximum value
	UINT	uSpinIncrement;		// if 0, spin box is not displayed.
} NUMERICINFO;

typedef struct tagCLASSLIST {
	TABLEENTRY * pMachineCategoryList;		// per-machine category list
	UINT	nMachineDataItems;
	TABLEENTRY * pUserCategoryList;			// per-user category table
	UINT	nUserDataItems;
} CLASSLIST;

typedef struct tagDROPDOWNINFO {
	UINT	uOffsetItemName;
	UINT	uDefaultItemIndex;	// only used in 1st DROPDOWNINFO struct in list
	DWORD	dwFlags;
	union {
		UINT uOffsetValue;
		DWORD dwValue;
	};
	UINT	uOffsetActionList;
	UINT	uOffsetNextDropdowninfo;
} DROPDOWNINFO;

typedef struct tagLISTBOXINFO {
	UINT uOffsetPrefix;	// offset to prefix to use for value names (e.g
						// "stuff" -> "stuff1", "stuff2", etc

	UINT uOffsetValue;	// offset to STATEVALUE to use for value data for each entry
						// (can't have both a data value and a prefix)
} LISTBOXINFO;

#endif // _MEMORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\load.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"
UINT LoadUsersFromKey(HWND hwndList,HKEY hkeyRoot,TABLEENTRY * pTableEntry,
	DWORD dwType);
UINT LoadOneEntry(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser,DWORD *pdwFoundSettings);
UINT LoadUserData(USERDATA ** ppUserData,HGLOBAL hTable,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser,DWORD *pdwFoundSettings);
UINT LoadPolicy(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser);
UINT LoadSettings(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser,DWORD *pdwFoundSettings);
UINT LoadListboxData(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser,DWORD * pdwFound);
BOOL ReadStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
	TABLEENTRY * pTableEntry,DWORD * pdwData,DWORD * pdwFound);
BOOL ReadCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
	TCHAR * pszValue,UINT cbValue,DWORD * pdwValue,DWORD * pdwFlags);
BOOL CompareCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        STATEVALUE * pStateValue,DWORD * pdwFound);

// flags for detected settings
#define FS_PRESENT	0x0001
#define FS_DELETED	0x0002

/*******************************************************************

	NAME:		LoadFile

	SYNOPSIS:	Loads the specified policy file

********************************************************************/
BOOL LoadFile(TCHAR * pszFilename,HWND hwndApp,HWND hwndList,BOOL fDisplayErrors)
{
	HKEY hkeyMain=NULL,hkeyUser=NULL,hkeyWorkstation=NULL,hkeyGroup=NULL,hkeyGroupPriority=NULL;
	UINT uRet;
	OFSTRUCT of;
	HCURSOR hOldCursor;
        HFILE hFile;
	of.cBytes = sizeof(of);

	hOldCursor=SetCursor(LoadCursor(NULL,IDC_WAIT));

	// RegLoadKey returns totally coarse error codes, so first do
	// an open file on the file to get a sane error message if there's
	// a problem
    
	hFile = OpenFile(pszFilename,&of,OF_EXIST);

	if (hFile == HFILE_ERROR) {
		SetCursor(hOldCursor);
		if (fDisplayErrors)
			DisplayStandardError(hwndApp,pszFilename,IDS_ErrREGERR_LOADKEY1,
				of.nErrCode);
		return FALSE;
	}

// Not needed. This will raise an exception.
//	_lclose (hFile);

	// load the hive file
	if ((uRet = MyRegLoadKey(HKEY_LOCAL_MACHINE,szTMPDATA,pszFilename))
		!= ERROR_SUCCESS) {
		SetCursor(hOldCursor);
		if (fDisplayErrors) 
			DisplayStandardError(hwndApp,pszFilename,IDS_ErrREGERR_LOADKEY1,uRet);
		return FALSE;
	}

	// read information from local registry
	if ( (RegOpenKey(HKEY_LOCAL_MACHINE,szTMPDATA,&hkeyMain) !=
		ERROR_SUCCESS) ||
		(RegOpenKey(hkeyMain,szUSERS,&hkeyUser) != ERROR_SUCCESS) ||
		(RegOpenKey(hkeyMain,szWORKSTATIONS,&hkeyWorkstation)
		!= ERROR_SUCCESS)) {
		SetCursor(hOldCursor);

			if (fDisplayErrors)
				MsgBoxParam(hwndApp,IDS_ErrINVALIDPOLICYFILE,pszFilename,
					MB_ICONEXCLAMATION,MB_OK);

			if (hkeyWorkstation) RegCloseKey(hkeyWorkstation);
			if (hkeyUser) RegCloseKey(hkeyUser);
			if (hkeyMain) RegCloseKey(hkeyMain);
			MyRegUnLoadKey(HKEY_LOCAL_MACHINE,szTMPDATA);

		return FALSE;
	}

	// if we fail to open these two keys no big deal, these are optional keys.
	// HKEYs are checked below before we use them
	RegOpenKey(hkeyMain,szUSERGROUPS,&hkeyGroup);
	RegOpenKey(hkeyMain,szUSERGROUPDATA,&hkeyGroupPriority);

	// load users
	if ((uRet = LoadUsersFromKey(hwndList,hkeyUser,gClassList.pUserCategoryList,
		UT_USER)) != ERROR_SUCCESS)
		goto cleanup;
	// load workstations
	if ((uRet = LoadUsersFromKey(hwndList,hkeyWorkstation,gClassList.pMachineCategoryList,
		UT_MACHINE))
		!= ERROR_SUCCESS)
		goto cleanup;

#ifdef INCL_GROUP_SUPPORT
	// load groups
	if (hkeyGroupPriority && hkeyGroup) {
		if ((uRet = LoadGroupPriorityList(hkeyGroupPriority,hkeyGroup)) != ERROR_SUCCESS)
			goto cleanup;

		if (uRet = LoadUsersFromKey(hwndList,hkeyGroup,gClassList.pUserCategoryList,
			UT_USER | UF_GROUP)
			!= ERROR_SUCCESS)
			goto cleanup;
	}
#endif

	uRet = ERROR_SUCCESS;
cleanup:
	RegCloseKey(hkeyUser);
	RegCloseKey(hkeyWorkstation);
	RegCloseKey(hkeyMain);
	if (hkeyGroup)
		RegCloseKey(hkeyGroup);
	if (hkeyGroupPriority)
		RegCloseKey(hkeyGroupPriority);
	MyRegUnLoadKey(HKEY_LOCAL_MACHINE,szTMPDATA);
	SetFileAttributes(pszFilename,FILE_ATTRIBUTE_ARCHIVE);
	ClearDeletedUserList();
	SetCursor(hOldCursor);

	if (uRet != ERROR_SUCCESS && fDisplayErrors) {
		if (uRet == ERROR_NOT_ENOUGH_MEMORY) {
			MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		} else {
			TCHAR szFmt[REGBUFLEN],szMsg[REGBUFLEN+MAX_PATH+1];
			LoadSz(IDS_ErrREGERR_LOADKEY,szFmt,ARRAYSIZE(szFmt));
			wsprintf(szMsg,szFmt,pszFilename,uRet);
			MsgBoxSz(hwndApp,szMsg,MB_ICONEXCLAMATION,MB_OK);
		}
		// remove any users that might have gotten loaded
		RemoveAllUsers(hwndList);
	}

	return (uRet == ERROR_SUCCESS);
}


/*******************************************************************

	NAME:		LoadFromRegistry

	SYNOPSIS:	Loads policies from the registry

	NOTES:		Errors will be displayed if fDisplayErrors is TRUE.

********************************************************************/
BOOL LoadFromRegistry(HWND hwndApp,HWND hwndList,BOOL fDisplayErrors)
{
	HKEY hkeyUser=NULL,hkeyWorkstation=NULL;
	UINT uRet = ERROR_SUCCESS;
	HGLOBAL hUser,hWorkstation;
	USERDATA * pUserData=NULL,* pWorkstationData=NULL;
	HCURSOR hOldCursor;

	if ((RegOpenKeyEx(hkeyVirtHCU,NULL,0,KEY_ALL_ACCESS,&hkeyUser) != ERROR_SUCCESS) ||
                (RegOpenKeyEx(hkeyVirtHLM,NULL,0,KEY_ALL_ACCESS,&hkeyWorkstation) != ERROR_SUCCESS)) {
		if (fDisplayErrors)
			MsgBox(hwndApp,IDS_ErrCANTOPENREGISTRY,MB_ICONEXCLAMATION,MB_OK);
		if (hkeyUser) RegCloseKey(hkeyUser);
		if (hkeyWorkstation) RegCloseKey(hkeyWorkstation);
		return FALSE;
	}

	hUser = AddUser(hwndList,LoadSz(IDS_LOCALUSER,szSmallBuf,ARRAYSIZE(szSmallBuf))
		,UT_USER);
	hWorkstation = AddUser(hwndList,LoadSz(IDS_LOCALCOMPUTER,szSmallBuf,
		ARRAYSIZE(szSmallBuf)),UT_MACHINE);

	if (!hUser || !hWorkstation || !(pUserData = (USERDATA *) GlobalLock(hUser)) ||
		!(pWorkstationData = (USERDATA *) GlobalLock(hWorkstation)) ) {
		uRet = ERROR_NOT_ENOUGH_MEMORY;
	}

	hOldCursor=SetCursor(LoadCursor(NULL,IDC_WAIT));

	if (uRet == ERROR_SUCCESS)
		uRet = LoadUserData(&pUserData,gClassList.pUserCategoryList,hkeyUser,NULL,
			hUser,NULL);
	if (uRet == ERROR_SUCCESS)
		uRet = LoadUserData(&pWorkstationData,gClassList.pMachineCategoryList,
			hkeyWorkstation,NULL,hWorkstation,NULL);

	RegCloseKey(hkeyUser);
	RegCloseKey(hkeyWorkstation);
	GlobalUnlock(hUser);
	GlobalUnlock(hWorkstation);

	SetCursor(hOldCursor);

	if (uRet != ERROR_SUCCESS) {
		if (uRet == ERROR_NOT_ENOUGH_MEMORY) {
			if (fDisplayErrors)
				MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		} else {
			TCHAR szMsg[REGBUFLEN+1];
			wsprintf(szMsg,TEXT("%lu"),uRet);
			if (fDisplayErrors)
				MsgBoxParam(hwndApp,IDS_ErrREGERR_LOAD,szMsg,MB_ICONEXCLAMATION,MB_OK);
		}

		RemoveAllUsers(hwndList);
		return FALSE;
	}
	ClearDeletedUserList();

	return TRUE;
}

UINT LoadUsersFromKey(HWND hwndList,HKEY hkeyRoot,TABLEENTRY * pTableEntry,
	DWORD dwType)
{
	TCHAR szKeyName[MAX_PATH+1];
	UINT uRet,nIndex=0;
	HGLOBAL hUser;
	USERDATA * pUserData;
	HKEY hKey;
	TCHAR szUnmappedName[MAXNAMELEN+1];

	do {
		// enumerate the subkeys, which will be user/workstation names
		if ((uRet=RegEnumKey(hkeyRoot,nIndex,szKeyName,ARRAYSIZE(szKeyName)))
			== ERROR_SUCCESS) {

			// open the subkey
			if ((uRet = RegOpenKey(hkeyRoot,szKeyName,&hKey)) != ERROR_SUCCESS)
				return uRet;

			// allocate this user and add to list control
			UnmapUserName(szKeyName,szUnmappedName,(BOOL) (dwType & UT_USER));
			hUser = AddUser(hwndList,szUnmappedName,dwType);
			if ( !hUser || !(pUserData = (USERDATA *) GlobalLock(hUser))) {
				RegCloseKey(hKey);
				return ERROR_NOT_ENOUGH_MEMORY;
			}

			// load user data into user's buffer
			uRet=LoadUserData(&pUserData,pTableEntry,hKey,NULL,hUser,NULL);

#ifdef INCL_GROUP_SUPPORT
			// add group name to bottom of priority list.  The group name
			// should already be somewhere on priority list because we loaded
			// the list earlier, but this will add the group name to the bottom
			// of the list if it's not on the list already.  Adds extra robustness
			// in the face of god-knows-whose-app creating flaky policy files.
			if (dwType == (UT_USER | UF_GROUP))
				AddGroupPriEntry(szUnmappedName);
#endif			

			RegCloseKey(hKey);
			GlobalUnlock(hUser);

			// make a copy of the initial state of each user, so on
			// a save we only have to save the deltas.  We need to only
			// save the deltas, because saves have to be non-destructive--
			// we can't clean the user's tree out and start over because
			// there might be stuff in there we don't know about.
			CloneUser(hUser);

			if (uRet != ERROR_SUCCESS) return uRet;
		}

		nIndex++;
	} while (uRet == ERROR_SUCCESS);

	// end of enum will report ERROR_NO_MORE_ITEMS, don't report this as error
	if (uRet == ERROR_NO_MORE_ITEMS) uRet = ERROR_SUCCESS;

	return uRet;
}

UINT LoadUserData(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser,DWORD *pdwFoundSettings)
{
	UINT uRet=ERROR_SUCCESS;

	while (pTableEntry && (uRet == ERROR_SUCCESS)) {

		uRet = LoadOneEntry(ppUserData,pTableEntry,hkeyRoot,
			pszCurrentKeyName,hUser,pdwFoundSettings);

		pTableEntry = pTableEntry->pNext;
	}

	return uRet;
}

UINT LoadOneEntry(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser,DWORD *pdwFoundSettings)
{
	UINT uRet;

#if 0
	wsprintf(szDebugOut,TEXT("LoadOneEntry: %s\r\n"),GETNAMEPTR(pTableEntry));
	OutputDebugString(szDebugOut);
#endif

	// if there is a key name for this entry, it becomes the "current"
	// key name-- it will be overridden if child entries specify their
	// own keys, otherwise it's the default key for children to use
	if (pTableEntry->uOffsetKeyName) {
		pszCurrentKeyName = GETKEYNAMEPTR(pTableEntry);
	}

	if ((pTableEntry->dwType == ETYPE_CATEGORY || pTableEntry->dwType
		== ETYPE_ROOT) &&
		(pTableEntry->pChild)) {

	    // if entry is a category, recusively process sub-categories and policies

		if ((uRet=LoadUserData(ppUserData,pTableEntry->pChild,
			hkeyRoot,pszCurrentKeyName,hUser,pdwFoundSettings)) != ERROR_SUCCESS) {
			return uRet;
		}
	} else if (pTableEntry->dwType == ETYPE_POLICY) {

		if ((uRet = LoadPolicy(ppUserData,pTableEntry,hkeyRoot,
			pszCurrentKeyName,hUser)) != ERROR_SUCCESS) {
			return uRet;
		}

	} else if ( (pTableEntry->dwType & ETYPE_MASK) == ETYPE_SETTING
		&& !(pTableEntry->dwType & STYPE_TEXT)) {

		if ((uRet = LoadSettings(ppUserData,pTableEntry,hkeyRoot,
			pszCurrentKeyName,hUser,pdwFoundSettings)) != ERROR_SUCCESS) {
			return uRet;
		}
	}

	return ERROR_SUCCESS;
}

UINT LoadPolicy(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser)
{
	DWORD dwData=0;
	UINT uRet;
	TCHAR * pszValueName;
	DWORD dwFoundSettings=0;
	BOOL fHasPolicySwitch=FALSE;
	BOOL fFound=FALSE,fCustomOn=FALSE,fCustomOff=FALSE;

	// get the name of the value to read, if any
	if (((POLICY *) pTableEntry)->uOffsetValueName) {
		fHasPolicySwitch = TRUE;

		pszValueName = GETVALUENAMEPTR(((POLICY *) pTableEntry));

		// first look for custom on/off values
		if (((POLICY *) pTableEntry)->uOffsetValue_On) {
			fCustomOn = TRUE;
			if (CompareCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
				(STATEVALUE *) ((TCHAR *) pTableEntry + ((POLICY *)
                                pTableEntry)->uOffsetValue_On),&dwFoundSettings)) {
					dwData = 1;
					fFound = TRUE;
			}
		}

		if (!fFound && ((POLICY *) pTableEntry)->uOffsetValue_Off) {
			fCustomOff = TRUE;
			if (CompareCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
				(STATEVALUE *) ((TCHAR *) pTableEntry + ((POLICY *)
                                pTableEntry)->uOffsetValue_Off),&dwFoundSettings)) {
					dwData = 0;
					fFound = TRUE;
			}
		}

		// look for standard values if custom values have not been specified
		if (!fCustomOn && !fCustomOff &&
			ReadStandardValue(hkeyRoot,pszCurrentKeyName,pszValueName,
			pTableEntry,&dwData,&dwFoundSettings)) {
			fFound = TRUE;
		}

		if (fFound) {
			// store data in user's buffer
			(*ppUserData)->SettingData[((POLICY *) pTableEntry)->uDataIndex].uData =
				(dwData ? IMG_CHECKED : IMG_UNCHECKED);
		}
	}

	dwFoundSettings = 0;
	// process settings underneath this policy (if any)
	if (pTableEntry->pChild && (dwData || !fHasPolicySwitch)) {
		if ((uRet=LoadUserData(ppUserData,pTableEntry->pChild,hkeyRoot,
			pszCurrentKeyName,hUser,&dwFoundSettings)) !=ERROR_SUCCESS) {
			return uRet;
		}
	}

	if (!fHasPolicySwitch) {
		// store data in user's buffer
		if (dwFoundSettings) {
			(*ppUserData)->SettingData[((POLICY *) pTableEntry)->uDataIndex].uData =
				(dwFoundSettings & FS_PRESENT ? IMG_CHECKED : IMG_UNCHECKED);
		}
	}

	return ERROR_SUCCESS;
}


UINT LoadSettings(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser,DWORD * pdwFound)
{
	UINT uRet = ERROR_SUCCESS;
	TCHAR * pszValueName = NULL;
	DWORD dwData,dwFlags,dwFoundSettings=0;
	TCHAR szData[MAXSTRLEN];
	BOOL fCustomOn=FALSE,fCustomOff=FALSE,fFound=FALSE;
	TCHAR * pObjectData = GETOBJECTDATAPTR(((SETTINGS *)pTableEntry));
	TCHAR szNewValueName[MAX_PATH+1];

	// get the name of the value to read
	if (((SETTINGS *) pTableEntry)->uOffsetValueName) {
		pszValueName = GETVALUENAMEPTR(((SETTINGS *) pTableEntry));
	}
	else return ERROR_NOT_ENOUGH_MEMORY;

	switch (pTableEntry->dwType & STYPE_MASK) {

		case STYPE_EDITTEXT:
		case STYPE_COMBOBOX:

			dwFlags = ( (SETTINGS *) pTableEntry)->dwFlags;

			// add prefixes if appropriate
			PrependValueName(pszValueName,dwFlags,
				szNewValueName,ARRAYSIZE(szNewValueName));

			if ((uRet = ReadRegistryStringValue(hkeyRoot,pszCurrentKeyName,
				szNewValueName,szData,ARRAYSIZE(szData) * sizeof(TCHAR))) == ERROR_SUCCESS) {

				GlobalUnlock(hUser);
				if (!SetVariableLengthData(hUser,((SETTINGS *)
					pTableEntry)->uDataIndex,szData,lstrlen(szData)+1)) {
				 	return ERROR_NOT_ENOUGH_MEMORY;
				}
				if (!((*ppUserData) = (USERDATA *) GlobalLock(hUser)))
					return ERROR_NOT_ENOUGH_MEMORY;

				// set flag that we found setting in registry/policy file
				if (pdwFound)
					*pdwFound |= FS_PRESENT;
			} else if ((dwAppState & AS_POLICYFILE) && !(dwFlags & VF_DELETE)) {
				
				// see if this key is marked as deleted
				PrependValueName(pszValueName,VF_DELETE,
					szNewValueName,ARRAYSIZE(szNewValueName));
				if ((uRet = ReadRegistryStringValue(hkeyRoot,pszCurrentKeyName,
					szNewValueName,szData,ARRAYSIZE(szData) * sizeof(TCHAR))) == ERROR_SUCCESS) {
					
					// set flag that we found setting marked as deleted in
					// policy file
					if (pdwFound)
						*pdwFound |= FS_DELETED;
				}
			}

			return ERROR_SUCCESS;				
			break;

		case STYPE_CHECKBOX:

			// first look for custom on/off values
			if (((CHECKBOXINFO *) pObjectData)->uOffsetValue_On) {
				fCustomOn = TRUE;
				if (CompareCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
					(STATEVALUE *) ((TCHAR *) pTableEntry + ((CHECKBOXINFO *)
                                        pObjectData)->uOffsetValue_On),&dwFoundSettings)) {
						dwData = 1;
						fFound = TRUE;
				}
			}

			if (!fFound && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_Off) {
				fCustomOff = TRUE;
				if (CompareCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
					(STATEVALUE *) ((TCHAR *) pTableEntry + ((CHECKBOXINFO *)
                                        pObjectData)->uOffsetValue_Off),&dwFoundSettings)) {
						dwData = 0;
						fFound = TRUE;
				}
			}

			// look for standard values if custom values have not been specified
			if (!fFound &&
				ReadStandardValue(hkeyRoot,pszCurrentKeyName,pszValueName,
				pTableEntry,&dwData,&dwFoundSettings)) {
				fFound = TRUE;
			}

			if (fFound) {
				(*ppUserData)->SettingData[((SETTINGS *)
					pTableEntry)->uDataIndex].uData = dwData;

				// set flag that we found setting in registry
				if (pdwFound)
					*pdwFound |= dwFoundSettings;
			} 

			return ERROR_SUCCESS;
			break;

		case STYPE_NUMERIC:

			if (ReadStandardValue(hkeyRoot,pszCurrentKeyName,pszValueName,
				pTableEntry,&dwData,&dwFoundSettings)) {

				(*ppUserData)->SettingData[((SETTINGS *)
					pTableEntry)->uDataIndex].uData = dwData;

				// set flag that we found setting in registry
				if (pdwFound)
					*pdwFound |= dwFoundSettings;
			}
			break;

		case STYPE_DROPDOWNLIST:

			if (ReadCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
				szData,ARRAYSIZE(szData) * sizeof(TCHAR),&dwData,&dwFlags)) {
				BOOL fMatch = FALSE;

				if ((dwAppState & AS_POLICYFILE) &&
					(dwFlags & VF_DELETE)) {
					// set flag that we found setting marked as deleted
					// in policy file
					if (pdwFound)
						*pdwFound |= FS_DELETED;
					return ERROR_SUCCESS;
				}

				// walk the list of DROPDOWNINFO structs (one for each state),
				// and see if the value we found matches the value for the state

				if ( ((SETTINGS *) pTableEntry)->uOffsetObjectData) {
					DROPDOWNINFO * pddi = (DROPDOWNINFO *)
						GETOBJECTDATAPTR( ((SETTINGS *) pTableEntry));
					UINT nIndex = 0;
					
					do {
						if (dwFlags == pddi->dwFlags) {
						
							if (pddi->dwFlags & VF_ISNUMERIC) {
								if (dwData == pddi->dwValue)
									fMatch = TRUE;
							} else if (!pddi->dwFlags) {
								if (!lstrcmpi(szData,(TCHAR *) pTableEntry +
									pddi->uOffsetValue))
									fMatch = TRUE;
							}
						}

						if (!pddi->uOffsetNextDropdowninfo || fMatch) 
							break;							

						pddi = (DROPDOWNINFO *) ( (TCHAR *) pTableEntry +
							pddi->uOffsetNextDropdowninfo);
						nIndex++;

					} while (!fMatch);

					if (fMatch) {
						(*ppUserData)->SettingData[((SETTINGS *)
							pTableEntry)->uDataIndex].uData = nIndex;

						// set flag that we found setting in registry
						if (pdwFound)
							*pdwFound |= FS_PRESENT;
					}
				}
			}

			break;

		case STYPE_LISTBOX:

			return LoadListboxData(ppUserData,pTableEntry,hkeyRoot,
				pszCurrentKeyName,hUser,pdwFound);

			break;
	}

	return ERROR_SUCCESS;
}

/*******************************************************************

	NAME:		ReadCustomValue

	SYNOPSIS:	For specified keyname and value name, retrieve the
				value (if there is one).

	NOTES:		fills in pszValue if value is REG_SZ, fills in *pdwValue
				if value is REG_DWORD (and sets VF_ISNUMERIC).  Sets
				VF_DELETE if value is marked for deletion.

********************************************************************/
BOOL ReadCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
	TCHAR * pszValue,UINT cbValue,DWORD * pdwValue,DWORD * pdwFlags)
{
	HKEY hKey;
	DWORD dwType,dwSize=cbValue * sizeof(TCHAR);
	BOOL fSuccess = FALSE;
	TCHAR szNewValueName[MAX_PATH+1];

	*( (DWORD *)pszValue) = *pdwValue=0;

	if (RegOpenKey(hkeyRoot,pszKeyName,&hKey) == ERROR_SUCCESS) {
		if (RegQueryValueEx(hKey,pszValueName,NULL,&dwType,(LPBYTE) pszValue,
			&dwSize) == ERROR_SUCCESS) {

			if (dwType == REG_SZ) {
				// value returned in pszValueName
				*pdwFlags = 0;
				fSuccess = TRUE;
			} else if (dwType == REG_DWORD || dwType == REG_BINARY) {
				// copy value to *pdwValue
				memcpy(pdwValue,pszValue,sizeof(DWORD));
				*pdwFlags = VF_ISNUMERIC;
				fSuccess = TRUE;
			}

		} else {
			// see if this is a value that's marked for deletion 
			// (valuename is prepended with "**del."
			PrependValueName(pszValueName,VF_DELETE,
				szNewValueName,ARRAYSIZE(szNewValueName));

			if (RegQueryValueEx(hKey,szNewValueName,NULL,&dwType,(LPBYTE) pszValue,
				&dwSize) == ERROR_SUCCESS) {
				fSuccess=TRUE;
				*pdwFlags = VF_DELETE;
			} else {
				// see if this is a soft value
				// (valuename is prepended with "**soft."
				PrependValueName(pszValueName,VF_SOFT,
					szNewValueName,ARRAYSIZE(szNewValueName));

				if (RegQueryValueEx(hKey,szNewValueName,NULL,&dwType,(LPBYTE) pszValue,
					&dwSize) == ERROR_SUCCESS) {
					fSuccess=TRUE;
					*pdwFlags = VF_SOFT;
				}
			}
		}

		RegCloseKey(hKey);
	}

	return fSuccess;
}

BOOL CompareCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        STATEVALUE * pStateValue,DWORD * pdwFound)
{
	TCHAR szValue[MAXSTRLEN];
	DWORD dwValue;
	TCHAR szNewValueName[MAX_PATH+1];

	// add prefixes if appropriate
	PrependValueName(pszValueName,pStateValue->dwFlags,
		szNewValueName,ARRAYSIZE(szNewValueName));

	if (pStateValue->dwFlags & VF_ISNUMERIC) {
		if ((ReadRegistryDWordValue(hkeyRoot,pszKeyName,
			szNewValueName,&dwValue) == ERROR_SUCCESS) &&
			dwValue == pStateValue->dwValue) {
                        *pdwFound = FS_PRESENT;
			return TRUE;
                }
	} else if (pStateValue->dwFlags & VF_DELETE) {

		if (dwAppState & AS_POLICYFILE) {
			// see if this is a value that's marked for deletion 
			// (valuename is prepended with "**del."

			if ((ReadRegistryStringValue(hkeyRoot,pszKeyName,
				szNewValueName,szValue,ARRAYSIZE(szValue) * sizeof(TCHAR))) == ERROR_SUCCESS) {
                                *pdwFound = FS_DELETED;
				return TRUE;
                        }
		} else {
			// return TRUE if value ISN't there...
			if (ReadRegistryDWordValue(hkeyRoot,pszKeyName,
				szNewValueName,&dwValue) != ERROR_SUCCESS) {
                                *pdwFound = FS_DELETED;
				return TRUE;
                        }
		}
	} else {
		if ((ReadRegistryStringValue(hkeyRoot,pszKeyName,
			szNewValueName,szValue,ARRAYSIZE(szValue) * sizeof(TCHAR))) == ERROR_SUCCESS &&
			!lstrcmpi(szValue,pStateValue->szValue)) {
                        *pdwFound = FS_PRESENT;
			return TRUE;
                }
	}

	return FALSE;
}

BOOL ReadStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
	TABLEENTRY * pTableEntry,DWORD * pdwData,DWORD * pdwFound)
{
	UINT uRet;
	TCHAR szNewValueName[MAX_PATH+1];

	// add prefixes if appropriate
	PrependValueName(pszValueName,((SETTINGS *) pTableEntry)->dwFlags,
		szNewValueName,ARRAYSIZE(szNewValueName));

	if ( ((SETTINGS *) pTableEntry)->dwFlags & DF_TXTCONVERT) {
		// read numeric value as text if specified
		TCHAR szNum[11];
		uRet = ReadRegistryStringValue(hkeyRoot,pszKeyName,
			szNewValueName,szNum,ARRAYSIZE(szNum) * sizeof(TCHAR));
		if (uRet == ERROR_SUCCESS) {
			StringToNum(szNum,pdwData);
			*pdwFound = FS_PRESENT;
			return TRUE;
		}
	} else {
		// read numeric value as binary
		uRet = ReadRegistryDWordValue(hkeyRoot,pszKeyName,
			szNewValueName,pdwData);
		if (uRet == ERROR_SUCCESS) {
			*pdwFound = FS_PRESENT;
			return TRUE;
		}
	}

	// see if this settings has been marked as 'deleted'
	if ((dwAppState & AS_POLICYFILE) && !(dwCmdLineFlags & CLF_DIALOGMODE)) {
		TCHAR szVal[MAX_PATH+1];
		*pdwData = 0;
		PrependValueName(pszValueName,VF_DELETE,szNewValueName,
			ARRAYSIZE(szNewValueName));
		uRet=ReadRegistryStringValue(hkeyRoot,pszKeyName,
			szNewValueName,szVal,ARRAYSIZE(szVal) * sizeof(TCHAR));
		if (uRet == ERROR_SUCCESS) {
			*pdwFound = FS_DELETED;
		 	return TRUE;
		}
	}

	return FALSE;
}


UINT LoadListboxData(USERDATA ** ppUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	TCHAR * pszCurrentKeyName,HGLOBAL hUser,DWORD * pdwFound)
{
	HKEY hKey;
	UINT nIndex=0,nLen;
	TCHAR szValueName[MAX_PATH+1],szValueData[MAX_PATH+1];
	DWORD cbValueName,cbValueData;
	DWORD dwType,dwAlloc=1024,dwUsed=0;
	HGLOBAL hBuf;
	TCHAR * pBuf;
	SETTINGS * pSettings = (SETTINGS *) pTableEntry;
	LISTBOXINFO * pListboxInfo = (LISTBOXINFO *)
		GETOBJECTDATAPTR(pSettings);
	BOOL fFoundValues=FALSE,fFoundDelvals=FALSE;
	UINT uRet=ERROR_SUCCESS;

	if (RegOpenKey(hkeyRoot,pszCurrentKeyName,&hKey) != ERROR_SUCCESS)
		return ERROR_SUCCESS;	// nothing to do

	// allocate a temp buffer to read entries into
	if (!(hBuf = GlobalAlloc(GHND,dwAlloc * sizeof(TCHAR))) ||
		!(pBuf = (TCHAR *) GlobalLock(hBuf))) {
	 	if (hBuf)
			GlobalFree(hBuf);
		return ERROR_NOT_ENOUGH_MEMORY;
	}

	while (TRUE) {
		cbValueName=ARRAYSIZE(szValueName);
		cbValueData=ARRAYSIZE(szValueData) * sizeof(TCHAR);
		uRet=RegEnumValue(hKey,nIndex,szValueName,&cbValueName,NULL,
			&dwType,szValueData,&cbValueData);
		// stop if we're out of items
		if (uRet != ERROR_SUCCESS && uRet != ERROR_MORE_DATA)
			break;
		nIndex++;

		// if valuename prefixed with '**', it's a control code, ignore it
		if (szValueName[0] == TEXT('*') && szValueName[1] == TEXT('*')) {
			// if we found **delvals., then some sort of listbox stuff
			// is going on, remember that we found this code
			if (!lstrcmpi(szValueName,szDELVALS))
				fFoundDelvals = TRUE;
			continue;
		}

		// only process this item if enum was successful
		// (so we'll skip items with weird errors like ERROR_MORE_DATA and
		// but keep going with the enum)
		if (uRet == ERROR_SUCCESS) {
			TCHAR * pszData;

			// if there's no value name prefix scheme specified (e.g.
			// value names are "foo1", "foo2", etc), and the explicit valuename
			// flag isn't set where we remember the value name as well as
			// the data for every value, then we need the value name to
			// be the same as the value data ("thing.exe=thing.exe"). 
			if (!(pSettings->dwFlags & DF_EXPLICITVALNAME) &&
				!(pListboxInfo->uOffsetPrefix) && !(pListboxInfo->uOffsetValue)) {
				if (dwType != REG_SZ || lstrcmpi(szValueName,szValueData))
					continue;	// skip this value if val name != val data
			}

			// if explicit valuenames used, then copy the value name into
			// buffer
			if (pSettings->dwFlags & DF_EXPLICITVALNAME) {
				nLen = lstrlen(szValueName) + 1;
				if (!(pBuf=ResizeBuffer(pBuf,hBuf,dwUsed+nLen+4,&dwAlloc)))
					return ERROR_NOT_ENOUGH_MEMORY;
				lstrcpy(pBuf+dwUsed,szValueName);
				dwUsed += nLen;
			}


			// for default listbox type, value data is the actual "data"
			// and value name either will be the same as the data or
			// some prefix + "1", "2", etc.  If there's a data value to
			// write for each entry, then the "data" is the value name
			// (e.g. "Larry = foo", "Dave = foo"), etc.  If explicit value names
			// are turned on, then both the value name and data are stored
			// and editable
			 
			// copy value data into buffer
			if (pListboxInfo->uOffsetValue) {
				// data value set, use value name for data
				pszData = szValueName;
			} else pszData = szValueData;

			nLen = lstrlen(pszData) + 1;
			if (!(pBuf=ResizeBuffer(pBuf,hBuf,dwUsed+nLen+4,&dwAlloc)))
				return ERROR_NOT_ENOUGH_MEMORY;
			lstrcpy(pBuf+dwUsed,pszData);
			dwUsed += nLen;
			fFoundValues=TRUE;
		}
	}

	// doubly null-terminate the buffer... safe to do this because we
	// tacked on the extra "+4" in the ResizeBuffer calls above
	*(pBuf+dwUsed) = TEXT('\0');
	dwUsed++;

	uRet = ERROR_SUCCESS;

	if (fFoundValues) {
		// add the value data to user's buffer
		GlobalUnlock(hUser);
		if (!SetVariableLengthData(hUser,((SETTINGS *)
			pTableEntry)->uDataIndex,pBuf,dwUsed)) {
			uRet = ERROR_NOT_ENOUGH_MEMORY;
		} else if (!((*ppUserData) = (USERDATA *) GlobalLock(hUser)))
			uRet = ERROR_NOT_ENOUGH_MEMORY;
		// set flag that we found setting in registry/policy file
		if (pdwFound)
			*pdwFound |= FS_PRESENT;
	} else {
	 	if (fFoundDelvals && pdwFound) {
			*pdwFound |= FS_DELETED;		
		}
	}

	GlobalUnlock(hBuf);
	GlobalFree(hBuf);

	RegCloseKey(hKey);

	return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\metrics.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#ifndef _METRICS_H_
#define _METRICS_H_

#define LISTBOX_SPACING_X	3	// number of pixels between adjacent listboxes
#define SPLITTER_WIDTH		2

#endif	_METRICS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\parse.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#ifndef _PARSE_H_
#define _PARSE_H_

#define KYWD_ID_KEYNAME                1
#define KYWD_ID_VALUENAME              2
#define KYWD_ID_CATEGORY               3
#define KYWD_ID_POLICY                 4
#define KYWD_ID_PART                   5
#define KYWD_ID_CHECKBOX               6
#define KYWD_ID_TEXT                   7
#define KYWD_ID_EDITTEXT               8
#define KYWD_ID_NUMERIC                9
#define KYWD_ID_DEFCHECKED            10
#define KYWD_ID_MAXLENGTH             11
#define KYWD_ID_MIN                   12
#define KYWD_ID_MAX                   13
#define KYWD_ID_SPIN                  14
#define KYWD_ID_REQUIRED              15
#define KYWD_ID_EDITTEXT_DEFAULT      16
#define KYWD_ID_COMBOBOX_DEFAULT      17
#define KYWD_ID_NUMERIC_DEFAULT       18
#define KYWD_ID_OEMCONVERT            19
#define KYWD_ID_CLASS                 20
#define KYWD_ID_USER                  21
#define KYWD_ID_MACHINE               22
#define KYWD_ID_TXTCONVERT            23
#define KYWD_ID_VALUE                 24
#define KYWD_ID_VALUEON               25
#define KYWD_ID_VALUEOFF              26
#define KYWD_ID_ACTIONLIST            27
#define KYWD_ID_ACTIONLISTON          28
#define KYWD_ID_ACTIONLISTOFF         29
#define KYWD_ID_DELETE                30
#define KYWD_ID_COMBOBOX              31
#define KYWD_ID_SUGGESTIONS           32
#define KYWD_ID_DROPDOWNLIST          33
#define KYWD_ID_NAME                  34
#define KYWD_ID_ITEMLIST              35
#define KYWD_ID_DEFAULT               36
#define KYWD_ID_SOFT                  37
#define KYWD_ID_STRINGSSECT           38
#define KYWD_ID_LISTBOX               39
#define KYWD_ID_VALUEPREFIX           40
#define KYWD_ID_ADDITIVE              41
#define KYWD_ID_EXPLICITVALUE         42
#define KYWD_ID_VERSION               43
#define KYWD_ID_GT                    44
#define KYWD_ID_GTE                   45
#define KYWD_ID_LT                    46
#define KYWD_ID_LTE                   47
#define KYWD_ID_EQ                    48
#define KYWD_ID_NE                    49
#define KYWD_ID_END                   50
#define KYWD_ID_NOSORT                51
#define KYWD_ID_EXPANDABLETEXT        52
#define KYWD_ID_HELP                  53
#define KYWD_ID_CLIENTEXT             54

#define KYWD_DONE                    100

#define DEFAULT_TMP_BUF_SIZE         512
#define WORDBUFSIZE 255
#define FILEBUFSIZE 8192

#define CI_FREE                        0
#define CI_UNLOCKANDFREE               1
#define CI_FREETABLE                   2

#define CLEANLISTSIZE                  4

typedef struct tagKEYWORDINFO {
    LPCTSTR pWord;
    UINT nID;    
} KEYWORDINFO;

typedef struct tagCLEANUPINFO {
    HGLOBAL   hMem;
    UINT       nAction;
} CLEANUPINFO;

typedef struct tagENTRYDATA {
    BOOL    fHasKey;
    BOOL    fHasValue;
    BOOL     fParentHasKey;
} ENTRYDATA;

typedef struct tagPARSEPROCSTRUCT {
    HANDLE        hFile;                // file handle of .INF file
    HGLOBAL        hTable;              // handle of current table
    TABLEENTRY    *pTableEntry;         // pointer to struct for current entry
    DWORD        *pdwBufSize;           // size of buffer of pTableEntry
    ENTRYDATA    *pData;                // used to maintain state between calls to parseproc
    KEYWORDINFO    *pEntryCmpList;
} PARSEPROCSTRUCT;

typedef UINT (* PARSEPROC) (HWND,UINT,PARSEPROCSTRUCT *,BOOL *,BOOL *);

typedef struct tagPARSEENTRYSTRUCT {
    HANDLE      hFile;
    TABLEENTRY * pParent;
    DWORD        dwEntryType;
    KEYWORDINFO    *pEntryCmpList;
    KEYWORDINFO    *pTypeCmpList;
    PARSEPROC    pParseProc;
    DWORD        dwStructSize;
    BOOL        fHasSubtable;
    BOOL        fParentHasKey;
} PARSEENTRYSTRUCT;

#endif // _PARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\parse.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"
#include "parse.h"

UINT nFileLine;
TABLEENTRY * pListCurrent;  // current category list (either user or machine)
UINT    *pnDataItemCount;

// buffer to read .INF file into
CHAR * pFileBuf;
CHAR * pFilePtr;
CHAR * pFileEnd;
WCHAR *pUnicodeFileBuf;

BOOL fInComment;
BOOL fEOF;
BOOL fUnicode;
BOOL fCheckUnicode;

LPSTR pszParseFileName;

UINT ParseEntry(HWND hWnd,PARSEENTRYSTRUCT *ppes,BOOL *pfMore);

UINT ParseCategory(HWND hWnd,HANDLE hFile,TABLEENTRY * pParent,
    BOOL fParentHasKey,BOOL *pfMore);
UINT CategoryParseProc(HWND hWnd,UINT nMsg,PARSEPROCSTRUCT * ppps,
    BOOL * pfMore,BOOL * pfFoundEnd);

UINT ParsePolicy(HWND hWnd,HANDLE hFile,TABLEENTRY * pParent,
     BOOL fParentHasKey,BOOL *pfMore);
UINT PolicyParseProc(HWND hWnd,UINT nMsg,PARSEPROCSTRUCT * ppps,
    BOOL * pfMore,BOOL * pfFoundEnd);

UINT ParseSettings(HWND hWnd,HANDLE hFile,TABLEENTRY * pParent,
    BOOL fParentHasKey,BOOL *pfMore);
UINT SettingsParseProc(HWND hWnd,UINT nMsg,PARSEPROCSTRUCT * ppps,
    BOOL * pfMore,BOOL * pfFoundEnd);

UINT ParseClass(HWND hWnd,HANDLE hFile,BOOL *pfMore);
UINT InitSettingsParse(PARSEPROCSTRUCT *ppps,DWORD dwType,DWORD dwSize,
    KEYWORDINFO * pKeyList,SETTINGS ** ppSettings,CHAR **pObjectData);

BOOL CompareKeyword(HWND hWnd,CHAR * szWord,KEYWORDINFO *pKeywordList,
    UINT * pnListIndex);
VOID DisplayKeywordError(HWND hWnd,UINT uErrorID,CHAR * szFound,
    KEYWORDINFO * pExpectedList,CHAR * szFilename,UINT nLine);

CHAR * GetNextSectionWord(HWND hWnd,HANDLE hFile,CHAR * szBuf,UINT cbBuf,
    KEYWORDINFO * pKeywordList,UINT *pnListIndex,BOOL * pfMore,UINT * puErr);
UINT GetNextSectionNumericWord(HWND hWnd,HANDLE hFile,UINT * pnVal);
CHAR * GetNextWord(HWND hWnd,HANDLE hFile,CHAR * szBuf,UINT cbBuf,BOOL * pfMore,UINT *
    puErr);

UINT ParseValue(HWND hWnd,PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,BOOL *pfMore);
UINT ParseSuggestions(HWND hWnd,PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,BOOL * pfMore);
UINT ParseActionList(HWND hWnd,PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,LPCSTR pszKeyword,BOOL * pfMore);
UINT ParseItemList(HWND hWnd,PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    BOOL * pfMore);

CHAR * AddDataToEntry(TABLEENTRY * pTableEntry,CHAR * szData,UINT cbData,
    UINT * puOffsetData,DWORD * pdwBufSize);
BOOL AddCleanupItem(CLEANUPINFO * pCleanUp,UINT nMax,HGLOBAL hMem, UINT nAction);
UINT CleanupAndReturn(UINT uRetVal,CLEANUPINFO * pCleanup);

// list of legal keyword entries in "CATEGORY" section
KEYWORDINFO pCategoryEntryCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
    {szCATEGORY,KYWD_ID_CATEGORY},{szPOLICY,KYWD_ID_POLICY},
    {szEND,KYWD_ID_END}, {NULL,0} };
KEYWORDINFO pCategoryTypeCmpList[] = { {szCATEGORY,KYWD_ID_CATEGORY},
    {NULL,0} };

// list of legal keyword entries in "POLICY" section
KEYWORDINFO pPolicyEntryCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
    {szVALUENAME,KYWD_ID_VALUENAME}, {szPART,KYWD_ID_PART},
    {szVALUEON,KYWD_ID_VALUEON},{szVALUEOFF,KYWD_ID_VALUEOFF},
    {szACTIONLISTON,KYWD_ID_ACTIONLISTON},{szACTIONLISTOFF,KYWD_ID_ACTIONLISTOFF},
    {szEND,KYWD_ID_END},{szHELP,KYWD_ID_HELP}, {szCLIENTEXT,KYWD_ID_CLIENTEXT},{NULL, 0} };
KEYWORDINFO pPolicyTypeCmpList[] = { {szPOLICY,KYWD_ID_POLICY}, {NULL,0} };

// list of legal keyword entries in "PART" section
KEYWORDINFO pSettingsEntryCmpList[] = { {szCHECKBOX,KYWD_ID_CHECKBOX},
    {szTEXT,KYWD_ID_TEXT},{szEDITTEXT,KYWD_ID_EDITTEXT},
    {szNUMERIC,KYWD_ID_NUMERIC},{szCOMBOBOX,KYWD_ID_COMBOBOX},
    {szDROPDOWNLIST,KYWD_ID_DROPDOWNLIST},{szLISTBOX,KYWD_ID_LISTBOX},
    {szEND,KYWD_ID_END},{szCLIENTEXT,KYWD_ID_CLIENTEXT},{NULL,0}};
KEYWORDINFO pSettingsTypeCmpList[] = {{szPART,KYWD_ID_PART},{NULL,0}};

KEYWORDINFO pCheckboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szVALUEON,KYWD_ID_VALUEON},{szVALUEOFF,KYWD_ID_VALUEOFF},
    {szACTIONLISTON,KYWD_ID_ACTIONLISTON},{szACTIONLISTOFF,KYWD_ID_ACTIONLISTOFF},
    {szDEFCHECKED, KYWD_ID_DEFCHECKED},{szCLIENTEXT,KYWD_ID_CLIENTEXT},
    {szEND,KYWD_ID_END},{NULL,0} };

KEYWORDINFO pTextCmpList[] = {{szEND,KYWD_ID_END},{NULL,0}};

KEYWORDINFO pEditTextCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szDEFAULT,KYWD_ID_EDITTEXT_DEFAULT},
    {szREQUIRED,KYWD_ID_REQUIRED},{szMAXLENGTH,KYWD_ID_MAXLENGTH},
    {szOEMCONVERT,KYWD_ID_OEMCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END},{szEXPANDABLETEXT,KYWD_ID_EXPANDABLETEXT},
    {szCLIENTEXT,KYWD_ID_CLIENTEXT},{NULL,0} };

KEYWORDINFO pComboboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szDEFAULT,KYWD_ID_COMBOBOX_DEFAULT},{szSUGGESTIONS,KYWD_ID_SUGGESTIONS},
    {szREQUIRED,KYWD_ID_REQUIRED},{szMAXLENGTH,KYWD_ID_MAXLENGTH},
    {szOEMCONVERT,KYWD_ID_OEMCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END},{szNOSORT, KYWD_ID_NOSORT},
    {szEXPANDABLETEXT,KYWD_ID_EXPANDABLETEXT},{szCLIENTEXT,KYWD_ID_CLIENTEXT},{NULL,0} };

KEYWORDINFO pNumericCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szMIN, KYWD_ID_MIN},{szMAX,KYWD_ID_MAX},{szSPIN,KYWD_ID_SPIN},
    {szDEFAULT,KYWD_ID_NUMERIC_DEFAULT},{szREQUIRED,KYWD_ID_REQUIRED},
    {szTXTCONVERT,KYWD_ID_TXTCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END}, {szCLIENTEXT,KYWD_ID_CLIENTEXT},{NULL,0} };

KEYWORDINFO pDropdownlistCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szREQUIRED,KYWD_ID_REQUIRED},{szITEMLIST,KYWD_ID_ITEMLIST},
    {szEND,KYWD_ID_END},{szNOSORT, KYWD_ID_NOSORT},{szCLIENTEXT,KYWD_ID_CLIENTEXT},{NULL,0}};

KEYWORDINFO pListboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUEPREFIX,KYWD_ID_VALUEPREFIX},
    {szADDITIVE,KYWD_ID_ADDITIVE},{szNOSORT, KYWD_ID_NOSORT},
    {szEXPLICITVALUE,KYWD_ID_EXPLICITVALUE},{szEND,KYWD_ID_END},{szCLIENTEXT,KYWD_ID_CLIENTEXT},{NULL,0} };

KEYWORDINFO pClassCmpList[] = { {szCLASS, KYWD_ID_CLASS},
    {szCATEGORY,KYWD_ID_CATEGORY}, {szStringsSect,KYWD_ID_STRINGSSECT},
    {NULL,0} };
KEYWORDINFO pClassTypeCmpList[] = { {szUSER, KYWD_ID_USER},
    {szMACHINE,KYWD_ID_MACHINE}, {NULL,0} };

KEYWORDINFO pVersionCmpList[] = { {szVERSION, KYWD_ID_VERSION}, {NULL,0}};
KEYWORDINFO pOperatorCmpList[] = { {szGT, KYWD_ID_GT}, {szGTE,KYWD_ID_GTE},
    {szLT, KYWD_ID_LT}, {szLTE,KYWD_ID_LTE}, {szEQ,KYWD_ID_EQ},
    {szNE, KYWD_ID_NE}, {NULL,0}};

UINT ParseTemplateFile(HWND hWnd,HANDLE hFile,LPSTR pszFileName)
{
    BOOL fMore;
    UINT uRet;

    nFileLine = 1;
    pListCurrent = gClassList.pMachineCategoryList;
    pnDataItemCount = &gClassList.nMachineDataItems;
    pszParseFileName = pszFileName;

    if (!(pFileBuf = (CHAR *) GlobalAlloc(GPTR,FILEBUFSIZE))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pUnicodeFileBuf = NULL;

    pFilePtr = pFileEnd = NULL;
    fEOF = fInComment = fUnicode = FALSE;
    fCheckUnicode = TRUE;

    do {

        uRet=ParseClass(hWnd,hFile,&fMore);

    } while (fMore && uRet == ERROR_SUCCESS);

    GlobalFree(pFileBuf);
    if (NULL != pUnicodeFileBuf)
        GlobalFree(pUnicodeFileBuf);

    return uRet;
}

UINT ParseClass(HWND hWnd,HANDLE hFile,BOOL *pfMore)
{
    CHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr,nKeywordID,nClassID;

    if (!GetNextWord(hWnd,hFile,szWordBuf,sizeof(szWordBuf),pfMore,&uErr))
        return uErr;

    if (!CompareKeyword(hWnd,szWordBuf,pClassCmpList,&nKeywordID))
        return ERROR_ALREADY_DISPLAYED;

    switch (nKeywordID) {

        case KYWD_ID_CATEGORY:

            return ParseCategory(hWnd,hFile,pListCurrent,
                FALSE,pfMore);
            break;

        case KYWD_ID_CLASS:

            if (!GetNextSectionWord(hWnd,hFile,szWordBuf,sizeof(szWordBuf),
                pClassTypeCmpList,&nClassID,pfMore,&uErr))
               return uErr;

            switch (nClassID) {

                case KYWD_ID_USER:

                    pListCurrent = gClassList.pUserCategoryList;
                    pnDataItemCount = &gClassList.nUserDataItems;
                    break;

                case KYWD_ID_MACHINE:
                    pListCurrent = gClassList.pMachineCategoryList;
                    pnDataItemCount = &gClassList.nMachineDataItems;
                    break;
            }
            break;

        // hack for localization: allow a "strings" section at the bottom, if we
        // encounter that then we're thru with parsing
        case KYWD_ID_STRINGSSECT:
            *pfMore = FALSE;    // that's all, folks
            return ERROR_SUCCESS;
            break;
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

    NAME:       ParseEntry

    SYNOPSIS:   Main parsing "engine" for category, policy and part
                parsing

    NOTES:      Allocates memory to build a temporary TABLEENTRY struct
                describing the parsed information.  Reads the beginning and end of a
                section and loops through the words in each section, calling
                a caller-defined ParseProc for each keyword to let the
                caller handle appropriately.  Passes the newly-constucted
                TABLEENTRY to AddTableEntry to save it, and frees the temporary
                memory.
                This function is re-entrant.
                The ENTRYDATA struct is declared on ParseEntry's stack
                but used by the ParseProc to maintain state between
                calls-- e.g., whether or not a key name has been found.
                This can't be maintained as a static in the ParseProc because
                the ParseProc may be reentered (for instance, if categories
                have subcategories).
                There are many possible error paths and there is some
                memory dealloc that needs to be done in an error case. Rather
                than do deallocs by hand on every error path or use a "goto
                cleanup" (ick!), items to be freed are added to a "cleanup
                list" and then CleanupAndReturn is called in an error condition,
                which frees items on the list and returns a specified value.

    ENTRY:      hWnd-- parent window
                ppes-- PARSEENTRYSTRUCT that specifes type of entry, the
                    parent table, a keyword list, a ParseProc callback
                    and other goodies
                pfMore-- set to FALSE if at end of file

    EXIT:       ERROR_SUCCESS if successful, otherwise an error code
                (can be ERROR_ALREADY_DISPLAYED)

********************************************************************/
UINT ParseEntry(HWND hWnd,PARSEENTRYSTRUCT *ppes,BOOL *pfMore)
{
    CHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr,nListIndex;
    BOOL fFoundEnd = FALSE;
    CLEANUPINFO CleanUp[CLEANLISTSIZE];
    PARSEPROCSTRUCT pps;
    ENTRYDATA EntryData;
    DWORD dwBufSize = DEFAULT_TMP_BUF_SIZE;
    TABLEENTRY *pTmp;

    memset(CleanUp,0,sizeof(CleanUp));
    memset(&pps,0,sizeof(pps));
    memset(&EntryData,0,sizeof(EntryData));

    pps.pdwBufSize = &dwBufSize;
    pps.pData = &EntryData;
    pps.pData->fParentHasKey = ppes->fParentHasKey;

    if (!(pps.pTableEntry = (TABLEENTRY *) GlobalAlloc(GPTR,*pps.pdwBufSize)))
        return ERROR_NOT_ENOUGH_MEMORY;

    AddCleanupItem(CleanUp,CLEANLISTSIZE,(HGLOBAL) pps.pTableEntry,
        CI_FREE);

    // initialize TABLEENTRY struct
    pps.pTableEntry->dwSize = ppes->dwStructSize;
    pps.pTableEntry->dwType = ppes->dwEntryType;
    pps.pEntryCmpList = ppes->pEntryCmpList;
    pps.hFile = ppes->hFile;

    // get the entry name
    if (!GetNextSectionWord(hWnd,ppes->hFile,szWordBuf,sizeof(szWordBuf),NULL,NULL,
        pfMore,&uErr))
        return CleanupAndReturn(uErr,CleanUp);

    // store the entry name in pTableEntry
    pTmp = (TABLEENTRY *) AddDataToEntry(pps.pTableEntry,
        szWordBuf,lstrlen(szWordBuf)+1,&(pps.pTableEntry->uOffsetName),
        pps.pdwBufSize);
    if (!pTmp)
        return CleanupAndReturn(ERROR_NOT_ENOUGH_MEMORY,CleanUp);

    pps.pTableEntry = pTmp;

    // loop through the body of the declaration
    while (!fFoundEnd && GetNextSectionWord(hWnd,ppes->hFile,szWordBuf,
        sizeof(szWordBuf),pps.pEntryCmpList,&nListIndex,pfMore,&uErr)) {

        if ( (uErr = (*ppes->pParseProc) (hWnd,nListIndex,&pps,pfMore,&fFoundEnd))
            != ERROR_SUCCESS)
            return CleanupAndReturn(uErr,CleanUp);

    }

    if (uErr != ERROR_SUCCESS)
        return CleanupAndReturn(uErr,CleanUp);

    // Last word was "END"

    // get the keyword that goes with "END" ("END CATGORY", "END POLICY", etc.)
    if (!GetNextSectionWord(hWnd,ppes->hFile,szWordBuf,sizeof(szWordBuf),
        ppes->pTypeCmpList,&nListIndex,pfMore,&uErr))
        return CleanupAndReturn(uErr,CleanUp);

    // call the object's parse proc one last time to let it object if
    // key name or something like that is missing
    if ( (uErr = (*ppes->pParseProc) (hWnd,KYWD_DONE,&pps,pfMore,&fFoundEnd))
        != ERROR_SUCCESS)
        return CleanupAndReturn(uErr,CleanUp);

    // fix up linked list pointers.  If parent has no children yet, make this
    // 1st child; otherwise walk the list of children and insert this at the end
    if (!ppes->pParent->pChild) {
        ppes->pParent->pChild = pps.pTableEntry;
    } else {
        TABLEENTRY * pLastChild = ppes->pParent->pChild;
        while (pLastChild->pNext) {
            pLastChild = pLastChild->pNext;
        }
        pLastChild->pNext = pps.pTableEntry;
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

    NAME:       ParseCategory

    SYNOPSIS:   Parses a category

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.

********************************************************************/
UINT ParseCategory(HWND hWnd,HANDLE hFile,TABLEENTRY * pParent,
    BOOL fParentHasKey,BOOL *pfMore)
{
    PARSEENTRYSTRUCT pes;

    pes.hFile = hFile;
    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_CATEGORY;
    pes.pEntryCmpList = pCategoryEntryCmpList;
    pes.pTypeCmpList = pCategoryTypeCmpList;
    pes.pParseProc = &CategoryParseProc;
    pes.dwStructSize = sizeof(CATEGORY);
    pes.fHasSubtable = TRUE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(hWnd,&pes,pfMore);
}

/*******************************************************************

    NAME:       CategoryParseProc

    SYNOPSIS:   Keyword callback ParseProc for category parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT CategoryParseProc(HWND hWnd,UINT nMsg,PARSEPROCSTRUCT * ppps,
    BOOL * pfMore,BOOL * pfFoundEnd)
{
    CHAR szWordBuf[WORDBUFSIZE+1];
    CATEGORY * pCategory = (CATEGORY *) ppps->pTableEntry;
    TABLEENTRY * pOld = ppps->pTableEntry;
    UINT uErr;
    DWORD dwDelta;
    TABLEENTRY *pTmp;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL,pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pCategory
            pTmp = (TABLEENTRY *) AddDataToEntry((TABLEENTRY *) pCategory,
                szWordBuf,lstrlen(szWordBuf)+1,&(pCategory->uOffsetKeyName),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;

            ppps->pTableEntry = pTmp;

            // fix up other pointers
            dwDelta = (DWORD)(ppps->pTableEntry - pOld);

            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_POLICY:
        case KYWD_ID_CATEGORY:

            {
                BOOL fHasKey = ppps->pData->fHasKey | ppps->pData->fParentHasKey;
                if (nMsg == KYWD_ID_POLICY)
                    uErr=ParsePolicy(hWnd,ppps->hFile,
                        (TABLEENTRY *) pCategory,fHasKey,pfMore);
                else
                    uErr=ParseCategory(hWnd,ppps->hFile,
                        (TABLEENTRY *) pCategory,fHasKey,pfMore);
            }

            return uErr;
            break;

        case KYWD_DONE:
#if 0
            if (!ppps->pData->fHasKey) {
                DisplayKeywordError(hWnd,IDS_ParseErr_NO_KEYNAME,NULL,NULL,
                    pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }
#endif
            return ERROR_SUCCESS;
            break;

        default:
            return ERROR_SUCCESS;
            break;
    }
}


/*******************************************************************

    NAME:       ParsePolicy

    SYNOPSIS:   Parses a policy

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.

********************************************************************/
UINT ParsePolicy(HWND hWnd,HANDLE hFile,TABLEENTRY * pParent,
    BOOL fParentHasKey,BOOL *pfMore)
{
    PARSEENTRYSTRUCT pes;

    pes.hFile = hFile;
    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_POLICY;
    pes.pEntryCmpList = pPolicyEntryCmpList;
    pes.pTypeCmpList = pPolicyTypeCmpList;
    pes.pParseProc = &PolicyParseProc;
    pes.dwStructSize = sizeof(POLICY);
    pes.fHasSubtable = TRUE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(hWnd,&pes,pfMore);
}

/*******************************************************************

    NAME:       PolicyParseProc

    SYNOPSIS:   Keyword callback ParseProc for policy parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT PolicyParseProc(HWND hWnd,UINT nMsg,PARSEPROCSTRUCT * ppps,
    BOOL * pfMore,BOOL * pfFoundEnd)
{
    CHAR szWordBuf[WORDBUFSIZE+1];
    LPTSTR lpHelpBuf;
    POLICY * pPolicy = (POLICY *) ppps->pTableEntry;
    TABLEENTRY * pOld = ppps->pTableEntry;
    UINT uErr;
    DWORD dwDelta;
    TABLEENTRY *pTmp;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL,pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pPolicy
            pTmp = (TABLEENTRY *) AddDataToEntry((TABLEENTRY *) pPolicy,
                szWordBuf,lstrlen(szWordBuf)+1,&(pPolicy->uOffsetKeyName),ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;

            ppps->pTableEntry = pTmp;

            // fix up other pointers
            dwDelta = (DWORD)(ppps->pTableEntry - pOld);

            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_VALUENAME:

            // have we already found a key name?
            if (ppps->pData->fHasValue) {
                DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_VALUENAME,
                    NULL,NULL,pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pSettings
            pTmp = (TABLEENTRY *) AddDataToEntry((TABLEENTRY *) pPolicy,
                szWordBuf,lstrlen(szWordBuf)+1,&(pPolicy->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
    
            ppps->pTableEntry = pTmp;
            // fix up other pointers
            dwDelta = (DWORD)(ppps->pTableEntry - pOld);

            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;

        case KYWD_ID_HELP:

            lpHelpBuf = (LPTSTR) LocalAlloc (LPTR, HELPBUFSIZE * sizeof(TCHAR));

            if (!lpHelpBuf) {
                DisplayKeywordError(hWnd,IDS_ErrOUTOFMEMORY,
                    NULL,NULL,pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the help string
            if (!GetNextSectionWord(hWnd,ppps->hFile,lpHelpBuf,HELPBUFSIZE,
                NULL,NULL,pfMore,&uErr)) {
                LocalFree (lpHelpBuf);
                return uErr;
            }

            LocalFree (lpHelpBuf);
            return ERROR_SUCCESS;

        case KYWD_ID_CLIENTEXT:

            // get the clientext name
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            return ERROR_SUCCESS;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_PART:
            {
                BOOL fHasKey = ppps->pData->fHasKey | ppps->pData->fParentHasKey;
                return ParseSettings(hWnd,ppps->hFile,
                    (TABLEENTRY *) pPolicy,fHasKey,pfMore);
            }
            break;

        case KYWD_ID_VALUEON:
            return ParseValue(hWnd,ppps,&pPolicy->uOffsetValue_On,
                &ppps->pTableEntry,pfMore);
            break;

        case KYWD_ID_VALUEOFF:

            return ParseValue(hWnd,ppps,&pPolicy->uOffsetValue_Off,
                &ppps->pTableEntry,pfMore);
            break;

        case KYWD_ID_ACTIONLISTON:
            return ParseActionList(hWnd,ppps,&pPolicy->uOffsetActionList_On,
                &ppps->pTableEntry,szACTIONLISTON,pfMore);
            break;

        case KYWD_ID_ACTIONLISTOFF:
            return ParseActionList(hWnd,ppps,&pPolicy->uOffsetActionList_Off,
                &ppps->pTableEntry,szACTIONLISTOFF,pfMore);
            break;

        case KYWD_DONE:

            if (!ppps->pData->fHasKey && !ppps->pData->fParentHasKey) {
                DisplayKeywordError(hWnd,IDS_ParseErr_NO_KEYNAME,NULL,NULL,
                    pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            ( (POLICY *) ppps->pTableEntry)->uDataIndex = *pnDataItemCount;
            (*pnDataItemCount) ++;

            return ERROR_SUCCESS;
            break;

        default:
            return ERROR_SUCCESS;
            break;
    }
}

/*******************************************************************

    NAME:       ParseSettings

    SYNOPSIS:   Parses a policy setting

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.

********************************************************************/
UINT ParseSettings(HWND hWnd,HANDLE hFile,TABLEENTRY * pParent,
    BOOL fParentHasKey,BOOL *pfMore)
{
    PARSEENTRYSTRUCT pes;

    pes.hFile = hFile;
    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_SETTING;
    pes.pEntryCmpList = pSettingsEntryCmpList;
    pes.pTypeCmpList = pSettingsTypeCmpList;
    pes.pParseProc = &SettingsParseProc;
    pes.dwStructSize = sizeof(SETTINGS);
    pes.fHasSubtable = FALSE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(hWnd,&pes,pfMore);
}

/*******************************************************************

    NAME:       SettingsParseProc

    SYNOPSIS:   Keyword callback ParseProc for policy settings parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT SettingsParseProc(HWND hWnd,UINT nMsg,PARSEPROCSTRUCT * ppps,
    BOOL * pfMore,BOOL * pfFoundEnd)
{
    CHAR szWordBuf[WORDBUFSIZE+1];
    TABLEENTRY *pTmp;

    SETTINGS * pSettings = (SETTINGS *) ppps->pTableEntry;
    CHAR * pObjectData = GETOBJECTDATAPTR(pSettings);

    UINT uErr;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL,pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pSettings
            pTmp = (TABLEENTRY *) AddDataToEntry((TABLEENTRY *) pSettings,
                szWordBuf,lstrlen(szWordBuf)+1,&(pSettings->uOffsetKeyName),ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;

            ppps->pTableEntry = pTmp;
            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_VALUENAME:

            // have we already found a value name?
            if (ppps->pData->fHasValue) {
                DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_VALUENAME,
                    NULL,NULL,pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the value name
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the value name in pSettings
            pTmp = (TABLEENTRY *) AddDataToEntry((TABLEENTRY *) pSettings,
                szWordBuf,lstrlen(szWordBuf)+1,&(pSettings->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;
            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_CLIENTEXT:

            // get the clientext name
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            return ERROR_SUCCESS;

        case KYWD_ID_REQUIRED:
            pSettings->dwFlags |= DF_REQUIRED;
            return ERROR_SUCCESS;
            break;

                case KYWD_ID_EXPANDABLETEXT:
                        pSettings->dwFlags |= DF_EXPANDABLETEXT;
                        return ERROR_SUCCESS;
                        break;

        case KYWD_ID_SUGGESTIONS:

            return ParseSuggestions(hWnd,ppps,&((POLICYCOMBOBOXINFO *)
                (GETOBJECTDATAPTR(pSettings)))->uOffsetSuggestions,
                &ppps->pTableEntry,pfMore);

        case KYWD_ID_TXTCONVERT:
            pSettings->dwFlags |= DF_TXTCONVERT;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_SOFT:
            pSettings->dwFlags |= VF_SOFT;
            return ERROR_SUCCESS;
            break;

        case KYWD_DONE:

            if (!ppps->pData->fHasKey && !ppps->pData->fParentHasKey) {
                DisplayKeywordError(hWnd,IDS_ParseErr_NO_KEYNAME,NULL,NULL,
                    pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            if (!ppps->pData->fHasValue) {
                DisplayKeywordError(hWnd,IDS_ParseErr_NO_VALUENAME,NULL,NULL,
                    pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }

            ( (SETTINGS *) ppps->pTableEntry)->uDataIndex = *pnDataItemCount;
            (*pnDataItemCount) ++;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_CHECKBOX:
            return (InitSettingsParse(ppps,ETYPE_SETTING | STYPE_CHECKBOX,
                sizeof(CHECKBOXINFO),pCheckboxCmpList,&pSettings,&pObjectData));
            break;

        case KYWD_ID_TEXT:
            ppps->pData->fHasValue = TRUE;  // no key value for static text items
            return (InitSettingsParse(ppps,ETYPE_SETTING | STYPE_TEXT,
                0,pTextCmpList,&pSettings,&pObjectData));
            break;

        case KYWD_ID_EDITTEXT:
            uErr=InitSettingsParse(ppps,ETYPE_SETTING | STYPE_EDITTEXT,
                sizeof(EDITTEXTINFO),pEditTextCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(((SETTINGS *) ppps->pTableEntry)));

                pEditTextInfo->nMaxLen = MAXSTRLEN;

            }
            break;

        case KYWD_ID_COMBOBOX:
            uErr=InitSettingsParse(ppps,ETYPE_SETTING | STYPE_COMBOBOX,
                sizeof(POLICYCOMBOBOXINFO),pComboboxCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(((SETTINGS *) ppps->pTableEntry)));

                pEditTextInfo->nMaxLen = MAXSTRLEN;

            }
            break;

        case KYWD_ID_NUMERIC:
            uErr=InitSettingsParse(ppps,ETYPE_SETTING | STYPE_NUMERIC,
                sizeof(NUMERICINFO),pNumericCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;

            ( (NUMERICINFO *) pObjectData)->uDefValue = 1;
            ( (NUMERICINFO *) pObjectData)->uMinValue = 1;
            ( (NUMERICINFO *) pObjectData)->uMaxValue = 9999;
            ( (NUMERICINFO *) pObjectData)->uSpinIncrement = 1;

            break;

        case KYWD_ID_DROPDOWNLIST:
            ppps->pEntryCmpList = pDropdownlistCmpList;
            ppps->pTableEntry->dwType = ETYPE_SETTING | STYPE_DROPDOWNLIST;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_LISTBOX:
            uErr=InitSettingsParse(ppps,ETYPE_SETTING | STYPE_LISTBOX,
                sizeof(LISTBOXINFO),pListboxCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;

            // listboxes have no single value name, set the value name to ""
            pTmp = (TABLEENTRY *) AddDataToEntry((TABLEENTRY *) pSettings,
                (CHAR *) szNull,lstrlen(szNull)+1,&(pSettings->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;
            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_EDITTEXT_DEFAULT:
        case KYWD_ID_COMBOBOX_DEFAULT:
            // get the default text
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the default text in pTableEntry
            pTmp = (TABLEENTRY *) AddDataToEntry((TABLEENTRY *)
                pSettings,szWordBuf,lstrlen(szWordBuf)+1,
                &((EDITTEXTINFO *) (GETOBJECTDATAPTR(pSettings)))->uOffsetDefText,
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;

            ppps->pTableEntry = pTmp;
            pSettings->dwFlags |= DF_USEDEFAULT;

            break;

        case KYWD_ID_MAXLENGTH:
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(pSettings));

                if ((uErr=GetNextSectionNumericWord(hWnd,ppps->hFile,
                    &pEditTextInfo->nMaxLen)) != ERROR_SUCCESS)
                    return uErr;
            }
            break;

        case KYWD_ID_MAX:
            if ((uErr=GetNextSectionNumericWord(hWnd,ppps->hFile,
                &((NUMERICINFO *)pObjectData)->uMaxValue)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_MIN:
            if ((uErr=GetNextSectionNumericWord(hWnd,ppps->hFile,
                &((NUMERICINFO *)pObjectData)->uMinValue)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_SPIN:
            if ((uErr=GetNextSectionNumericWord(hWnd,ppps->hFile,
                &((NUMERICINFO *)pObjectData)->uSpinIncrement)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_NUMERIC_DEFAULT:
            if ((uErr=GetNextSectionNumericWord(hWnd,ppps->hFile,
                &((NUMERICINFO *)pObjectData)->uDefValue)) != ERROR_SUCCESS)
                return uErr;

            pSettings->dwFlags |= (DF_DEFCHECKED | DF_USEDEFAULT);

        break;

        case KYWD_ID_DEFCHECKED:

            pSettings->dwFlags |= (DF_DEFCHECKED | DF_USEDEFAULT);

            break;

        case KYWD_ID_VALUEON:

            return ParseValue(hWnd,ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetValue_On,
                &ppps->pTableEntry,pfMore);
            break;

        case KYWD_ID_VALUEOFF:

            return ParseValue(hWnd,ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetValue_Off,
                &ppps->pTableEntry,pfMore);
            break;

        case KYWD_ID_ACTIONLISTON:
            return ParseActionList(hWnd,ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetActionList_On,
                &ppps->pTableEntry,szACTIONLISTON,pfMore);
            break;

        case KYWD_ID_ACTIONLISTOFF:
            return ParseActionList(hWnd,ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetActionList_Off,
                &ppps->pTableEntry,szACTIONLISTOFF,pfMore);
            break;

        case KYWD_ID_ITEMLIST:
            return ParseItemList(hWnd,ppps,&pSettings->uOffsetObjectData,
                pfMore);
            break;

        case KYWD_ID_VALUEPREFIX:
            // get the string to be ised as prefix
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the string pTableEntry
            pTmp = (TABLEENTRY *) AddDataToEntry((TABLEENTRY *)
                pSettings,szWordBuf,lstrlen(szWordBuf)+1,
                &((LISTBOXINFO *) (GETOBJECTDATAPTR(pSettings)))->uOffsetPrefix,
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;
            break;

        case KYWD_ID_ADDITIVE:

            pSettings->dwFlags |= DF_ADDITIVE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_EXPLICITVALUE:

            pSettings->dwFlags |= DF_EXPLICITVALNAME;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_NOSORT:

            pSettings->dwFlags |= DF_NOSORT;

            break;



    }

    return ERROR_SUCCESS;
}

UINT InitSettingsParse(PARSEPROCSTRUCT *ppps,DWORD dwType,DWORD dwSize,
    KEYWORDINFO * pKeyList,SETTINGS ** ppSettings,CHAR **ppObjectData)
{
    TABLEENTRY *pTmp;

    if (dwSize) {
        // increase the buffer to fit object-specific data if specified
        pTmp = (TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
            NULL,dwSize,&( ((SETTINGS * )ppps->pTableEntry)->uOffsetObjectData),
            ppps->pdwBufSize);
        if (!pTmp) return ERROR_NOT_ENOUGH_MEMORY;
        ppps->pTableEntry = pTmp;
    }
    else ( (SETTINGS *) ppps->pTableEntry)->uOffsetObjectData= 0;

    ppps->pEntryCmpList = pKeyList;
    ppps->pTableEntry->dwType = dwType;

    *ppSettings = (SETTINGS *) ppps->pTableEntry;
    *ppObjectData = GETOBJECTDATAPTR((*ppSettings));

    return ERROR_SUCCESS;
}

UINT ParseValue_W(HWND hWnd,PARSEPROCSTRUCT * ppps,CHAR * pszWordBuf,
    DWORD cbWordBuf,DWORD * pdwValue,DWORD * pdwFlags,BOOL * pfMore)
{
    UINT uErr;
    *pdwFlags = 0;
    *pdwValue = 0;

    // get the next word
    if (!GetNextSectionWord(hWnd,ppps->hFile,pszWordBuf,cbWordBuf,
        NULL,NULL,pfMore,&uErr))
        return uErr;

    // if this keyword is "SOFT", set the soft flag and get the next word
    if (!lstrcmpi(szSOFT,pszWordBuf)) {
        *pdwFlags |= VF_SOFT;
        if (!GetNextSectionWord(hWnd,ppps->hFile,pszWordBuf,cbWordBuf,
            NULL,NULL,pfMore,&uErr))
            return uErr;
    }

    // this word is either the value to use, or the keyword "NUMERIC"
    // followed by a numeric value to use
    if (!lstrcmpi(szNUMERIC,pszWordBuf)) {
        // get the next word
        if (!GetNextSectionWord(hWnd,ppps->hFile,pszWordBuf,cbWordBuf,
            NULL,NULL,pfMore,&uErr))
            return uErr;

        if (!StringToNum(pszWordBuf,pdwValue)) {
            DisplayKeywordError(hWnd,IDS_ParseErr_NOT_NUMERIC,
                pszWordBuf,NULL,pszParseFileName,nFileLine);
            return ERROR_ALREADY_DISPLAYED;
        }

        *pdwFlags |= VF_ISNUMERIC;
    } else {

        // "DELETE" is a special word
        if (!lstrcmpi(pszWordBuf,szDELETE))
            *pdwFlags |= VF_DELETE;
    }

    return ERROR_SUCCESS;
}

UINT ParseValue(HWND hWnd,PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,BOOL * pfMore)
{
    CHAR szWordBuf[WORDBUFSIZE+1];
    STATEVALUE * pStateValue;
    DWORD dwValue;
    DWORD dwFlags = 0;
    DWORD dwAlloc;
    UINT uErr;
    TABLEENTRY *pTmp;

    // call worker function
    uErr=ParseValue_W(hWnd,ppps,szWordBuf,sizeof(szWordBuf),&dwValue,
        &dwFlags,pfMore);
    if (uErr != ERROR_SUCCESS) return uErr;

    dwAlloc = sizeof(STATEVALUE);
    if (!dwFlags) dwAlloc += lstrlen(szWordBuf) + 1;

    // allocate temporary buffer to build STATEVALUE struct
    pStateValue = (STATEVALUE *) GlobalAlloc(GPTR,dwAlloc);
    if (!pStateValue)
        return ERROR_NOT_ENOUGH_MEMORY;

    pStateValue->dwFlags = dwFlags;
    if (dwFlags & VF_ISNUMERIC)
        pStateValue->dwValue = dwValue;
    else if (!dwFlags) {
        lstrcpy(pStateValue->szValue,szWordBuf);
    }
 
    pTmp=(TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
        (CHAR *) pStateValue,dwAlloc,puOffsetData,NULL);

    GlobalFree(pStateValue);

    if (!pTmp)
        return ERROR_NOT_ENOUGH_MEMORY;

    (*ppTableEntryNew) = pTmp;
    return FALSE;
}

#define DEF_SUGGESTBUF_SIZE     1024
#define SUGGESTBUF_INCREMENT    256
UINT ParseSuggestions(HWND hWnd,PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,BOOL * pfMore)
{
    CHAR szWordBuf[WORDBUFSIZE+1];
    CHAR *pTmpBuf, *pTmp;
    DWORD dwAlloc=DEF_SUGGESTBUF_SIZE;
    DWORD dwUsed = 0;
    BOOL fContinue = TRUE;
    UINT uErr;
    TABLEENTRY *pTmpTblEntry;
    KEYWORDINFO pSuggestionsTypeCmpList[] = { {szSUGGESTIONS,KYWD_ID_SUGGESTIONS},
        {NULL,0} };

    if (!(pTmpBuf = (CHAR *) GlobalAlloc(GPTR,dwAlloc)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // get the next word
    while (fContinue && GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,
        sizeof(szWordBuf),NULL,NULL,pfMore,&uErr)) {

        // if this word is "END", add the whole list to the setting object data
        if (!lstrcmpi(szEND,szWordBuf)) {
            // get the next word after "END, make sure it's "SUGGESTIONS"
            if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                pSuggestionsTypeCmpList,NULL,pfMore,&uErr)) {
                GlobalFree(pTmpBuf);
                return uErr;
            }

            // doubly-NULL terminate the list
            *(pTmpBuf+dwUsed) = '\0';
            dwUsed++;

            pTmpTblEntry=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                pTmpBuf,dwUsed,puOffsetData,NULL);

            if (!pTmpTblEntry) {
                GlobalFree(pTmpBuf);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            *ppTableEntryNew=pTmpTblEntry;
            fContinue = FALSE;

        } else {
            // pack the word into the temporary buffer
            UINT nLength = lstrlen(szWordBuf);
            DWORD dwNeeded = dwUsed + nLength + 2;

            // resize buffer as necessary
            if (dwNeeded > dwAlloc) {
                while (dwAlloc < dwNeeded)
                    dwAlloc += SUGGESTBUF_INCREMENT;
                if (!(pTmp = (CHAR *) GlobalReAlloc(pTmpBuf,dwAlloc,
                    GMEM_MOVEABLE | GMEM_ZEROINIT))) {
                    GlobalFree(pTmpBuf);
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                pTmpBuf = pTmp;
            }

            lstrcpy(pTmpBuf + dwUsed,szWordBuf);
            dwUsed += lstrlen(szWordBuf) +1;

        }
    }

    GlobalFree(pTmpBuf);

    return uErr;
}

UINT ParseActionList(HWND hWnd,PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,LPCSTR pszKeyword,BOOL * pfMore)
{
    CHAR szWordBuf[WORDBUFSIZE+1];
    ACTIONLIST *pActionList;
    ACTION *pActionCurrent;
    UINT uOffsetActionCurrent;
    DWORD dwAlloc=DEF_SUGGESTBUF_SIZE;
    DWORD dwUsed = sizeof(ACTION) + sizeof(UINT);
    UINT uErr=ERROR_SUCCESS,nIndex;
    BOOL fContinue = TRUE;
    KEYWORDINFO pActionlistTypeCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
        {szVALUENAME,KYWD_ID_VALUENAME},{szVALUE,KYWD_ID_VALUE},
        {szEND,KYWD_ID_END},{NULL,0} };
    KEYWORDINFO pActionlistCmpList[] = { {pszKeyword,KYWD_ID_ACTIONLIST},
        {NULL,0} };
    BOOL fHasKeyName=FALSE,fHasValueName=FALSE;
    BOOL AddActionListString(CHAR * pszData,DWORD cbData,CHAR ** ppBase,UINT * puOffset,
        DWORD * pdwAlloc,DWORD * pdwUsed);
    TABLEENTRY *pTmp;

    if (!(pActionList = (ACTIONLIST *) GlobalAlloc(GPTR,dwAlloc)))
        return ERROR_NOT_ENOUGH_MEMORY;

    pActionCurrent = pActionList->Action;
    uOffsetActionCurrent = sizeof(UINT);

    // get the next word
    while ((uErr == ERROR_SUCCESS) && fContinue &&
        GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
        pActionlistTypeCmpList,&nIndex,pfMore,&uErr)) {

        switch (nIndex) {

            case KYWD_ID_KEYNAME:

                if (fHasKeyName) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_KEYNAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the key name
                if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,
                    sizeof(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // store the key name away
                if (!AddActionListString(szWordBuf,lstrlen(szWordBuf)+1,
                    (CHAR **)&pActionList,
                    &pActionCurrent->uOffsetKeyName,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                fHasKeyName = TRUE;
                pActionCurrent = (ACTION *) ((CHAR *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_VALUENAME:

                if (fHasValueName) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_KEYNAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the value name
                if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,
                    sizeof(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // store the value name away
                if (!AddActionListString(szWordBuf,lstrlen(szWordBuf)+1,
                    (CHAR **)&pActionList,
                    &pActionCurrent->uOffsetValueName,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                fHasValueName = TRUE;
                pActionCurrent = (ACTION *) ((CHAR *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_VALUE:
                if (!fHasValueName) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_NO_VALUENAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // call worker function to get value and value type
                uErr=ParseValue_W(hWnd,ppps,szWordBuf,sizeof(szWordBuf),
                    &pActionCurrent->dwValue,&pActionCurrent->dwFlags,pfMore);
                if (uErr != ERROR_SUCCESS)
                    break;

                // if value is string, add it to buffer
                if (!pActionCurrent->dwFlags && !AddActionListString(szWordBuf,
                    lstrlen(szWordBuf)+1,(CHAR **)&pActionList,
                    &pActionCurrent->uOffsetValue,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                pActionCurrent = (ACTION *) ((CHAR *) pActionList + uOffsetActionCurrent);

                // done with this action in the list, get ready for the next one
                pActionList->nActionItems++;
                fHasValueName = fHasKeyName = FALSE;

                uOffsetActionCurrent = dwUsed;
                // make room for next ACTION struct
                if (!AddActionListString(NULL,sizeof(ACTION),(CHAR **)&pActionList,
                    &pActionCurrent->uOffsetNextAction,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                pActionCurrent = (ACTION *) ((CHAR *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_END:
                if (fHasKeyName || fHasValueName) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_NO_VALUENAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // make sure word following "END" is "ACTIONLIST"
                if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                    pActionlistCmpList,NULL,pfMore,&uErr)) {
                    break;
                }

                // commit the action list we've built to table entry

                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    (CHAR *)pActionList,dwUsed,puOffsetData,NULL);

                if (!pTmp) {
                    uErr=ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    uErr = ERROR_SUCCESS;
                    *ppTableEntryNew = pTmp;
                    fContinue = FALSE;
                }

                break;
        }
    }

    GlobalFree(pActionList);

    return uErr;
}

UINT ParseItemList(HWND hWnd,PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    BOOL * pfMore)
{
    // ptr to location to put the offset to next DROPDOWNINFO struct in chain
    UINT * puLastOffsetPtr = puOffsetData;
    TABLEENTRY * pTableEntryOld;
    TABLEENTRY *pTmp;
    int nItemIndex=-1;
    BOOL fHasItemName = FALSE,fHasActionList=FALSE,fHasValue=FALSE,fFirst=TRUE;
    DROPDOWNINFO * pddi;
    CHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr=ERROR_SUCCESS,nIndex;
    KEYWORDINFO pItemlistTypeCmpList[] = { {szNAME,KYWD_ID_NAME},
        {szACTIONLIST,KYWD_ID_ACTIONLIST},{szVALUE,KYWD_ID_VALUE},
        {szEND,KYWD_ID_END},{szDEFAULT,KYWD_ID_DEFAULT},{NULL,0} };
    KEYWORDINFO pItemlistCmpList[] = { {szITEMLIST,KYWD_ID_ITEMLIST},
        {NULL,0} };

    // get the next word
    while ((uErr == ERROR_SUCCESS) &&
        GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
        pItemlistTypeCmpList,&nIndex,pfMore,&uErr)) {

        switch (nIndex) {

            case KYWD_ID_NAME:

                // if this is the first keyword after a prior item
                // (e.g., item and value flags both set) reset for next one
                if (fHasItemName && fHasValue) {
                    fHasValue = fHasActionList= fHasItemName = FALSE;
                    puLastOffsetPtr = &pddi->uOffsetNextDropdowninfo;
                }

                if (fHasItemName) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_ITEMNAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the item name
                if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,
                    sizeof(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // add room for a DROPDOWNINFO struct at end of buffer
                pTableEntryOld=ppps->pTableEntry;
                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    NULL,sizeof(DROPDOWNINFO),puLastOffsetPtr,NULL);
                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry=pTmp;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((CHAR *) ppps->pTableEntry + *puLastOffsetPtr);

                // store the key name away
                pTableEntryOld=ppps->pTableEntry;
                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    szWordBuf,lstrlen(szWordBuf)+1,&pddi->uOffsetItemName,
                    NULL);
                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((CHAR *) ppps->pTableEntry + *puLastOffsetPtr);

                nItemIndex++;

                fHasItemName = TRUE;

                break;

            case KYWD_ID_DEFAULT:

                if (nItemIndex<0) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                ( (SETTINGS *) ppps->pTableEntry)->dwFlags |= DF_USEDEFAULT;
                ( (DROPDOWNINFO *) GETOBJECTDATAPTR(((SETTINGS *)ppps->pTableEntry)))
                    ->uDefaultItemIndex = nItemIndex;

                break;

            case KYWD_ID_VALUE:

                if (!fHasItemName) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // call worker function to get value and value type
                uErr=ParseValue_W(hWnd,ppps,szWordBuf,sizeof(szWordBuf),
                    &pddi->dwValue,&pddi->dwFlags,pfMore);
                if (uErr != ERROR_SUCCESS)
                    break;

                // if value is string, add it to buffer
                if (!pddi->dwFlags) {
                    // store the key name away
                    pTableEntryOld = ppps->pTableEntry;
                    pTmp=(TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
                        szWordBuf,lstrlen(szWordBuf)+1,&pddi->uOffsetValue,
                        NULL);
                    if (!pTmp)
                        return ERROR_NOT_ENOUGH_MEMORY;
                    ppps->pTableEntry = pTmp;
                    // adjust pointer to offset, in case table moved
                    puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                        ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                    pddi = (DROPDOWNINFO *)
                        ((CHAR *) ppps->pTableEntry + *puLastOffsetPtr);
                }
                fHasValue = TRUE;

                break;

            case KYWD_ID_ACTIONLIST:

                if (!fHasItemName) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                if (fHasActionList) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_DUPLICATE_ACTIONLIST,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                pTableEntryOld=ppps->pTableEntry;
                uErr=ParseActionList(hWnd,ppps,&pddi->uOffsetActionList,
                    &ppps->pTableEntry,szACTIONLIST,pfMore);
                if (uErr != ERROR_SUCCESS)
                    return uErr;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((CHAR *) ppps->pTableEntry + *puLastOffsetPtr);

                fHasActionList = TRUE;

                break;

            case KYWD_ID_END:

                if (!fHasItemName) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }
                if (!fHasValue) {
                    DisplayKeywordError(hWnd,IDS_ParseErr_NO_VALUE,
                        NULL,NULL,pszParseFileName,nFileLine);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // make sure word following "END" is "ITEMLIST"
                if (!GetNextSectionWord(hWnd,ppps->hFile,szWordBuf,sizeof(szWordBuf),
                    pItemlistCmpList,NULL,pfMore,&uErr)) {
                    break;
                }

                return ERROR_SUCCESS;
                break;
        }
    }

    return uErr;
}

BOOL AddActionListString(CHAR * pszData,DWORD cbData,CHAR ** ppBase,UINT * puOffset,
    DWORD * pdwAlloc,DWORD *pdwUsed)
{
    DWORD dwNeeded = *pdwUsed + cbData;
    CHAR    *pOldBase;

    // realloc if necessary
    if (dwNeeded > *pdwAlloc) {
        while (*pdwAlloc < dwNeeded)
            *pdwAlloc += SUGGESTBUF_INCREMENT;
        pOldBase = *ppBase;
        if (!(*ppBase = (CHAR *) GlobalReAlloc(*ppBase,*pdwAlloc,
            GMEM_MOVEABLE | GMEM_ZEROINIT)))
            return FALSE;
        puOffset = (UINT *)(*ppBase + ((CHAR *)puOffset - pOldBase));
    }

    *puOffset = *pdwUsed;

    if (pszData) memcpy(*ppBase + *puOffset,pszData,cbData);
    *pdwUsed = dwNeeded;

    return TRUE;
}

BOOL AddCleanupItem(CLEANUPINFO * pCleanUp,UINT nMax,HGLOBAL hMem, UINT nAction)
{
    UINT nCount;

    for (nCount=0;nCount<nMax;nCount++,pCleanUp++) {
        if (!pCleanUp->hMem) {
            pCleanUp->hMem = hMem;
            pCleanUp->nAction = nAction;
            return TRUE;
        }
    }

    return FALSE;
}

UINT CleanupAndReturn(UINT uRetVal,CLEANUPINFO * pCleanUp)
{
    while (pCleanUp->hMem) {

        switch (pCleanUp->nAction) {
            case CI_UNLOCKANDFREE:
                GlobalUnlock(pCleanUp->hMem);
                // fall through
            case CI_FREE:
                GlobalFree(pCleanUp->hMem);
                break;
            case CI_FREETABLE:
                FreeTable(pCleanUp->hMem);
                break;
        }

        pCleanUp ++;
    }

    return uRetVal;
}

CHAR * AddDataToEntry(TABLEENTRY * pTableEntry,CHAR * pszData,UINT cbData,
    UINT * puOffsetData,DWORD * pdwBufSize)
{
    TABLEENTRY * pTemp;
    DWORD dwNeeded,dwOldSize = pTableEntry->dwSize;

    // puOffsetData points to location that holds the offset to the
    // new data-- size we're adding this to the end of the table, the
    // offset will be the current size of the table.  Set this offset
    // in *puOffsetData.  Also, notice we touch *puOffsetData BEFORE
    // the realloc, in case puOffsetData points into the region being
    // realloced and the block of memory moves.
    *puOffsetData = pTableEntry->dwSize;

    // reallocate entry buffer if necessary
    dwNeeded = pTableEntry->dwSize + cbData;

    if (!(pTemp = (TABLEENTRY *) GlobalReAlloc(pTableEntry,
        dwNeeded,GMEM_ZEROINIT | GMEM_MOVEABLE))) {
        return NULL;
    }

    pTableEntry = pTemp;
    pTableEntry->dwSize = dwNeeded;

    if (pszData) memcpy((CHAR *)pTableEntry + dwOldSize,pszData,cbData);
    if (pdwBufSize) *pdwBufSize = pTableEntry->dwSize;

    return (CHAR *) pTableEntry;
}

#define MSGSIZE 1024
#define FMTSIZE 512
VOID DisplayKeywordError(HWND hWnd,UINT uErrorID,CHAR * szFound,
    KEYWORDINFO * pExpectedList,CHAR * szFilename,UINT nLine)
{
    CHAR * pMsg,*pFmt,*pErrTxt,*pTmp;

    pMsg = (CHAR *) GlobalAlloc(GPTR,MSGSIZE);
    pFmt = (CHAR *) GlobalAlloc(GPTR,FMTSIZE);
    pErrTxt = (CHAR *) GlobalAlloc(GPTR,FMTSIZE);
    pTmp = (CHAR *) GlobalAlloc(GPTR,FMTSIZE);

    if (!pMsg || !pFmt || !pErrTxt || !pTmp) {
        if (pMsg) GlobalFree(pMsg);
        if (pFmt) GlobalFree(pFmt);
        if (pErrTxt) GlobalFree(pErrTxt);
        if (pTmp) GlobalFree(pTmp);

        MsgBox(hWnd,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
        return;
    }

    LoadSz(IDS_ParseFmt_MSG_FORMAT,pFmt,FMTSIZE);
    wsprintf(pMsg,pFmt,szFilename,nLine,uErrorID,LoadSz(uErrorID,
        pErrTxt,FMTSIZE));

    if (szFound) {
        LoadSz(IDS_ParseFmt_FOUND,pFmt,FMTSIZE);
        wsprintf(pTmp,pFmt,szFound);
        lstrcat(pMsg,pTmp);
    }

    if (pExpectedList) {
        UINT nIndex=0;
        LoadSz(IDS_ParseFmt_EXPECTED,pFmt,FMTSIZE);
        lstrcpy(pErrTxt,szNull);

        while (pExpectedList[nIndex].pWord) {
            lstrcat(pErrTxt,pExpectedList[nIndex].pWord);
            if (pExpectedList[nIndex+1].pWord) {
                lstrcat(pErrTxt,", ");
            }

            nIndex++;
        }

        wsprintf(pTmp,pFmt,pErrTxt);
        lstrcat(pMsg,pTmp);
    }

    lstrcat(pMsg,LoadSz(IDS_ParseFmt_FATAL,pTmp,FMTSIZE));

    MsgBoxSz(hWnd,pMsg,MB_ICONEXCLAMATION,MB_OK);

    GlobalFree(pMsg);
    GlobalFree(pFmt);
    GlobalFree(pErrTxt);
    GlobalFree(pTmp);
}

/*******************************************************************

    NAME:       CompareKeyword

    SYNOPSIS:   Compares a specified buffer to a list of valid keywords.
                If it finds a match, the index of the match in the list
                is returned in *pnListIndex.  Otherwise an error message
                is displayed.

    EXIT:       Returns TRUE if a keyword match is found, FALSE otherwise.
                If TRUE, *pnListIndex contains matching index.

********************************************************************/
BOOL CompareKeyword(HWND hWnd,CHAR * szWord,KEYWORDINFO *pKeywordList,
    UINT * pnListIndex)
{
    KEYWORDINFO * pKeywordInfo = pKeywordList;

    while (pKeywordInfo->pWord) {
        if (!lstrcmpi(szWord,pKeywordInfo->pWord)) {
            if (pnListIndex)
                *pnListIndex = pKeywordInfo->nID;
            return TRUE;
        }
        pKeywordInfo ++;
    }

    DisplayKeywordError(hWnd,IDS_ParseErr_UNEXPECTED_KEYWORD,
        szWord,pKeywordList,pszParseFileName,nFileLine);

    return FALSE;
}

/*******************************************************************

    NAME:       PrivGetPrivateProfileString

    SYNOPIS:    Force GetPrivateProfileString to be Unicode

    NOTES:      NT4 has a bug where if were calling GetPrivateProfileStringA
                and it's a Unicode ini file it will hit uninitialized
                memory.  Always call the W api to avoid this.

********************************************************************/
#ifdef UNICODE
#define PrivGetPrivateProfileString GetPrivateProfileStringW
#else
DWORD PrivGetPrivateProfileString(LPCSTR szSection, LPCSTR szValue, LPCSTR szDefault, LPSTR szBuffer, DWORD cbBuffer, LPCSTR szFilename)
{
    WCHAR wszSection[256];
    WCHAR wszValue[256];
    WCHAR wszDefault[256];
    WCHAR wszFilename[256];
    DWORD ret;
    LPWSTR pwszBuffer;

    pwszBuffer = LocalAlloc (LPTR, cbBuffer * sizeof(WCHAR));

    if (!pwszBuffer) {
        return GetLastError();
    }

    if (0 == MultiByteToWideChar(CP_ACP, 0, szSection, -1, wszSection, 256))
        return 0;

    if (0 == MultiByteToWideChar(CP_ACP, 0, szValue, -1, wszValue, 256))
        return 0;

    if (0 == MultiByteToWideChar(CP_ACP, 0, szDefault, -1, wszDefault, 256))
        return 0;

    if (0 == MultiByteToWideChar(CP_ACP, 0, szFilename, -1, wszFilename, 256))
        return 0;

    ret = GetPrivateProfileStringW(wszSection, wszValue, wszDefault, pwszBuffer, cbBuffer, wszFilename);

    if (0 != ret)
        if (0 == WideCharToMultiByte(CP_ACP, 0, pwszBuffer, -1, szBuffer, cbBuffer, NULL, NULL))
            return 0;


    LocalFree (pwszBuffer);
    return ret;
}
#endif // !UNICODE

/*******************************************************************

    NAME:       GetNextWord

    SYNOPSIS:   Fills input buffer with next word in file stream

    NOTES:      Calls GetNextChar() to get character stream.  Whitespace
                and comments are skipped.  Quoted strings are returned
                as one word (including whitespace) with the quotes removed.

    EXIT:       If successful, returns a pointer to the input buffer
                (szBuf).  *pfMore indicates if there are more words to
                be read.  If an error occurs, its value is returned in *puErr.

********************************************************************/
CHAR * GetNextWord(HWND hWnd,HANDLE hFile,CHAR * szBuf,UINT cbBuf,BOOL * pfMore,UINT *
    puErr)
{
    CHAR * pChar;
    BOOL fInWord = FALSE;
    BOOL fInQuote = FALSE;
    CHAR * pWord = szBuf;
    UINT cbWord = 0;
    CHAR * GetNextChar(HANDLE hFile,BOOL * pfMore,UINT * puErr);
    BOOL IsComment(CHAR * pBuf);
    BOOL IsWhitespace(CHAR * pBuf);
    BOOL IsEndOfLine(CHAR * pBuf);
    BOOL IsQuote(CHAR * pBuf);
    BOOL IsLocalizedString(CHAR * pBuf);
    UINT ProcessIfdefs(HWND hWnd,HANDLE hFile,CHAR * pBuf,UINT cbBuf,BOOL * pfMore);

    // clear buffer to start with
    lstrcpy(szBuf,szNull);

    while (pChar = GetNextChar(hFile,pfMore,puErr)) {

        // keep track of which file line we're on
        if (IsEndOfLine(pChar)) nFileLine++;

        // keep track of wheter we are inside quoted string or not
        if (IsQuote(pChar) && !fInComment) {
            if (!fInQuote)
                fInQuote = TRUE;  // entering quoted string
            else {
                fInQuote = FALSE; // leaving quoted string
                break;  // end of word
            }

        }

        if (!fInQuote) {

            // skip over lines with comments (';')
            if (!fInComment & IsComment(pChar)) fInComment = TRUE;
            if (fInComment) {
                if (IsEndOfLine(pChar)) {
                    fInComment = FALSE;
                }
                continue;
            }

            if (IsWhitespace(pChar)) {

                // if we haven't found word yet, skip over whitespace
                if (!fInWord)
                    continue;

                // otherwise, whitespace signals end of word
                break;
            }
        }

        // found a non-comment, non-whitespace character
        if (!fInWord) fInWord = TRUE;

        if (!IsQuote(pChar)) {
            // add this character to word

            *pWord = *pChar;
            pWord++;
            cbWord++;

            if (cbWord > cbBuf) {
                *(pWord - 1) = TEXT('\0');
                MsgBoxParam(NULL,IDS_WORDTOOLONG,szBuf,MB_ICONEXCLAMATION,MB_OK);
                *puErr = ERROR_ALREADY_DISPLAYED;
                goto Exit;
            }
    #if 0
            if (IsDBCSLeadByte((BYTE) *pChar)) {
                *pWord = *pChar;
                pWord++;
                cbWord++;
            }
    #endif
        }
    }

    *pWord = '\0';  // null-terminate

    // if found string a la '!!foo', then look for a string in the [strings]
    // section with the key name 'foo' and use that instead.  This is because
    // our localization tools are brainless and require a [strings] section.
    // So although template files are sectionless, we allow a [strings] section
    // at the bottom.
    if (IsLocalizedString(szBuf)) {
        LPTSTR lpTmp;

        lpTmp = LocalAlloc (LPTR, cbBuf * sizeof(TCHAR));

        if (lpTmp) {
            DWORD dwSize;

            if (g_bWinnt) {
                dwSize = PrivGetPrivateProfileString(szStrings,szBuf+2,
                                        szNull,lpTmp,cbBuf,pszParseFileName);
            }
            else {
                dwSize = GetPrivateProfileStringA(szStrings,szBuf+2,
                                        szNull,lpTmp,cbBuf,pszParseFileName);
            }

            if (!dwSize) {
                DisplayKeywordError(hWnd,IDS_ParseErr_STRING_NOT_FOUND,
                                    szBuf,NULL,pszParseFileName,nFileLine);
                *puErr=ERROR_ALREADY_DISPLAYED;
                return NULL;
            }

            // replace the word we're returning with the one from the [strings]
            // section
            lstrcpy(szBuf,lpTmp);

            LocalFree (lpTmp);
        }
    } else {
        *puErr = ProcessIfdefs(hWnd,hFile,szBuf,cbBuf,pfMore);
    }

Exit:

    if (*puErr != ERROR_SUCCESS || !fInWord) return NULL;
    return szBuf;
}

/*******************************************************************

    NAME:       GetNextSectionWord

    SYNOPSIS:   Gets next word and warns if end-of-file encountered.
                Optionally checks the keyword against a list of valid
                keywords.

    NOTES:      Calls GetNextWord() to get word.  This is called in
                situations where we expect there to be another word
                (e.g., inside a section) and it's an error if the
                file ends.

********************************************************************/
CHAR * GetNextSectionWord(HWND hWnd,HANDLE hFile,CHAR * szBuf,UINT cbBuf,
    KEYWORDINFO * pKeywordList,UINT *pnListIndex,BOOL * pfMore,UINT * puErr)
{
    CHAR * pch;

    if (!(pch=GetNextWord(hWnd,hFile,szBuf,cbBuf,pfMore,puErr))) {

        if (!*pfMore && *puErr != ERROR_ALREADY_DISPLAYED) {
            DisplayKeywordError(hWnd,IDS_ParseErr_UNEXPECTED_EOF,
                NULL,pKeywordList,pszParseFileName,nFileLine);
            *puErr = ERROR_ALREADY_DISPLAYED;
        }

        return NULL;
    }

    if (pKeywordList && !CompareKeyword(hWnd,szBuf,pKeywordList,pnListIndex)) {
        *puErr = ERROR_ALREADY_DISPLAYED;
        return NULL;
    }

    return pch;
}

/*******************************************************************

    NAME:       GetNextSectionNumericWord

    SYNOPSIS:   Gets next word and converts string to number.  Warns if
                not a numeric value

********************************************************************/
UINT GetNextSectionNumericWord(HWND hWnd,HANDLE hFile,UINT * pnVal)
{
    UINT uErr;
    CHAR szWordBuf[255];
    BOOL fMore;

    if (!GetNextSectionWord(hWnd,hFile,szWordBuf,sizeof(szWordBuf),
        NULL,NULL,&fMore,&uErr))
        return uErr;

    if (!StringToNum(szWordBuf,pnVal)) {
        DisplayKeywordError(hWnd,IDS_ParseErr_NOT_NUMERIC,szWordBuf,
            NULL,pszParseFileName,nFileLine);
        return ERROR_ALREADY_DISPLAYED;
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

    NAME:       GetNextChar

    SYNOPSIS:   Returns a pointer to the next character from the
                file stream.

    NOTES:      Reads a chunk of the file into a buffer and returns
                a pointer inside the buffer, reading new chunks into
                the buffer as necessary.

    EXIT:       Returns pointer to next character in stream.
                If

********************************************************************/
CHAR * GetNextChar(HANDLE hFile,BOOL * pfMore,UINT * puErr)
{
    CHAR * pCurrentChar;
    UINT uRet;
    UINT ReadFileToBuffer(HANDLE hFile,CHAR * pBuf,DWORD cbBuf,DWORD *pdwRead,
        BOOL * pfEOF);

    *puErr = ERROR_SUCCESS;
    *pfMore = TRUE;

    // read another chunk into buffer if necessary

    // if we haven't gotten a buffer-ful yet or have read through the current
    // buffer
    if (!pFilePtr || pFilePtr > pFileEnd) {
        DWORD dwRead;

        // if we're finished with this buffer, and we're at the end of file
        // (fEOF true), then signal end of stream
        if ( (pFilePtr > pFileEnd) && fEOF) {
            *pfMore = FALSE;
            return NULL;
        }

        uRet=ReadFileToBuffer(hFile,(VOID *) pFileBuf,FILEBUFSIZE,&dwRead,
            &fEOF);
        if (uRet != ERROR_SUCCESS) {
            *puErr = uRet;
            return NULL;
        }

        pFilePtr = pFileBuf;
        pFileEnd = pFilePtr + dwRead-1;
#if 0
    } else if (pFilePtr == pFileEnd && IsDBCSLeadByte((BYTE) *pFilePtr)) {
        // have to watch for one tricky situation-- where the first
        // byte of a DBCS char has fallen on the end of our read buffer.
        // In this case, copy that byte to beginning of buffer, and read in
        // another chunk to rest of buffer.
        DWORD dwRead;

        *pFileBuf = *pFilePtr;
        uRet=ReadFileToBuffer(hFile,(VOID *) (pFileBuf+1),FILEBUFSIZE-1,&dwRead,
            &fEOF);
        if (uRet != ERROR_SUCCESS) {
            *puErr = uRet;
            return NULL;
        }

        pFilePtr = pFileBuf;
        pFileEnd = pFilePtr + dwRead;
#endif
    }

    pCurrentChar = pFilePtr;
    pFilePtr = CharNext(pFilePtr);

    return pCurrentChar;
}

UINT ReadFileToBuffer(HANDLE hFile,CHAR * pBuf,DWORD cbBuf,DWORD *pdwRead,
    BOOL * pfEOF)
{
    VOID *pDestBuf = fUnicode ? (VOID *) pUnicodeFileBuf : (VOID *) pBuf;

    if (!ReadFile(hFile,pDestBuf,cbBuf,pdwRead,NULL))
        return GetLastError();

    if (*pdwRead<cbBuf) *pfEOF = TRUE;
    else *pfEOF = FALSE;

    if (fCheckUnicode)
    {
        if (*pdwRead >= sizeof(WCHAR))
        {
            if (IsTextUnicode(pDestBuf, *pdwRead, NULL))
            {
                fUnicode = TRUE;

                pUnicodeFileBuf = (WCHAR *) GlobalAlloc(GPTR,FILEBUFSIZE);
                if (NULL == pUnicodeFileBuf)
                    return ERROR_OUTOFMEMORY;

                *pdwRead -= sizeof(WCHAR);
                CopyMemory(pUnicodeFileBuf, pBuf+sizeof(WCHAR), *pdwRead);
            }
        }

        fCheckUnicode = FALSE;
    }

    if (fUnicode)
    {
        // If we read an odd number of bytes in a unicode file either the
        // file is corrupt or somebody is passing a bogus cbBuf
        ASSERT(0 == (*pdwRead & 1));

        *pdwRead = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        pUnicodeFileBuf,
                        *pdwRead / sizeof(WCHAR),
                        pBuf,
                        cbBuf,
                        NULL,
                        NULL);

        if (0 == *pdwRead)
            return GetLastError();
    }

    return ERROR_SUCCESS;
}


BOOL IsComment(CHAR * pBuf)
{
    return (*pBuf == ';');
}

BOOL IsQuote(CHAR * pBuf)
{
    return (*pBuf == '\"');
}

BOOL IsEndOfLine(CHAR * pBuf)
{
    return (*pBuf == 0x0D);     // CR
}

BOOL IsWhitespace(CHAR * pBuf)
{
    return (   *pBuf == 0x20    // space
            || *pBuf == 0x0D    // CR
            || *pBuf == 0X0A    // LF
            || *pBuf == 0x09    // tab
            || *pBuf == 0x1A    // EOF
           );
}

BOOL IsLocalizedString(CHAR * pBuf)
{
    return (*pBuf == '!' && *(pBuf+1) == '!');
}

BOOL fFilterDirectives = TRUE;
UINT nGlobalNestedLevel = 0;

// reads up through the matching directive #endif in current scope
//and sets file pointer immediately past the directive
UINT FindMatchingDirective(HWND hWnd,HANDLE hFile,BOOL *pfMore,BOOL fElseOK)
{
    CHAR szWordBuf[255];
    UINT uErr=ERROR_SUCCESS,nNestedLevel=1;
    BOOL fContinue = TRUE;

    // set the flag to stop catching '#' directives in low level word-fetching
    // routine
    fFilterDirectives = FALSE;

    // keep reading words.  Keep track of how many layers of #ifdefs deep we
    // are.  Every time we encounter an #ifdef or #ifndef, increment the level
    // count (nNestedLevel) by one.  For every #endif decrement the level count.
    // When the level count hits zero, we've found the matching #endif.
    while (nNestedLevel > 0) {
        if (!GetNextSectionWord(hWnd,hFile,szWordBuf,sizeof(szWordBuf),NULL,NULL,
            pfMore,&uErr))
            break;

        if (!lstrcmpi(szWordBuf,szIFDEF) || !lstrcmpi(szWordBuf,szIFNDEF) ||
            !lstrcmpi(szWordBuf,szIF))
            nNestedLevel ++;
        else if (!lstrcmpi(szWordBuf,szENDIF)) {
            nNestedLevel --;
        }
        else if (!lstrcmpi(szWordBuf,szELSE) && (nNestedLevel == 1)) {
            if (fElseOK) {
                // ignore "#else" unless it's on the same level as the #ifdef
                // we're finding a match for (nNestedLevel == 1), in which
                // case treat it as the matching directive
                nNestedLevel --;
                // increment global nesting so we expect an #endif to come along
                // later to match this #else
                nGlobalNestedLevel++;
            } else {
                // found a #else where we already had a #else in this level
                DisplayKeywordError(hWnd,IDS_ParseErr_UNMATCHED_DIRECTIVE,
                    szWordBuf,NULL,pszParseFileName,nFileLine);
                return ERROR_ALREADY_DISPLAYED;
            }
        }
    }

    fFilterDirectives = TRUE;

    return uErr;
}

#define CURRENT_VERSION 2
// if the word in the word buffer is #ifdef, #if, #ifndef, #else or #endif,
// this function reads ahead an appropriate amount (
UINT ProcessIfdefs(HWND hWnd,HANDLE hFile,CHAR * pBuf,UINT cbBuf,BOOL * pfMore)
{
    UINT uRet;

    if (!fFilterDirectives)
        return ERROR_SUCCESS;

    if (!lstrcmpi(pBuf,szIFDEF)) {
    // we've found an '#ifdef <something or other>, where ISV policy editors
    // can understand particular keywords they make up.  We don't have any
    // #ifdef keywords of our own so always skip this
        uRet = FindMatchingDirective(hWnd,hFile,pfMore,TRUE);
        if (uRet != ERROR_SUCCESS)
            return uRet;
        if (!GetNextWord(hWnd,hFile,pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szIFNDEF)) {
        // this is an #ifndef, and since nothing is ever ifdef'd for our policy
        // editor, this always evaluates to TRUE

        // keep reading this section but increment the nested level count,
        // when we find the matching #endif or #else we'll be able to respond
        // correctly
        nGlobalNestedLevel ++;

        // get next word (e.g. "foo" for #ifndef foo) and throw it away
        if (!GetNextWord(hWnd,hFile,pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        // get next word and return it for real
        if (!GetNextWord(hWnd,hFile,pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        return ERROR_SUCCESS;

    } else if (!lstrcmpi(pBuf,szENDIF)) {
        // if we ever encounter an #endif here, we must have processed
        // the preceeding section.  Just step over the #endif and go on

        if (!nGlobalNestedLevel) {
            // found an endif without a preceeding #if<xx>

            DisplayKeywordError(hWnd,IDS_ParseErr_UNMATCHED_DIRECTIVE,
                pBuf,NULL,pszParseFileName,nFileLine);
            return ERROR_ALREADY_DISPLAYED;
        }
        nGlobalNestedLevel--;

        if (!GetNextWord(hWnd,hFile,pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szIF)) {
        // syntax is "#if VERSION (comparision) (version #)"
        // e.g. "#if VERSION >= 2"
        CHAR szWordBuf[255];
        UINT nIndex,nVersion,nOperator;
        BOOL fDirectiveTrue = FALSE;

        // get the next word (must be "VERSION")
        if (!GetNextSectionWord(hWnd,hFile,szWordBuf,sizeof(szWordBuf),
            pVersionCmpList,&nIndex,pfMore,&uRet))
            return uRet;

        // get the comparison operator (>, <, ==, >=, <=)
        if (!GetNextSectionWord(hWnd,hFile,szWordBuf,sizeof(szWordBuf),
            pOperatorCmpList,&nOperator,pfMore,&uRet))
            return uRet;

        // get the version number
        uRet=GetNextSectionNumericWord(hWnd,hFile,&nVersion);
        if (uRet != ERROR_SUCCESS)
            return uRet;

        // now evaluate the directive

        switch (nOperator) {
            case KYWD_ID_GT:
                fDirectiveTrue = (CURRENT_VERSION > nVersion);
                break;

            case KYWD_ID_GTE:
                fDirectiveTrue = (CURRENT_VERSION >= nVersion);
                break;

            case KYWD_ID_LT:
                fDirectiveTrue = (CURRENT_VERSION < nVersion);
                break;

            case KYWD_ID_LTE:
                fDirectiveTrue = (CURRENT_VERSION <= nVersion);
                break;

            case KYWD_ID_EQ:
                fDirectiveTrue = (CURRENT_VERSION == nVersion);
                break;

            case KYWD_ID_NE:
                fDirectiveTrue = (CURRENT_VERSION != nVersion);
                break;
        }


        if (fDirectiveTrue) {
            // keep reading this section but increment the nested level count,
            // when we find the matching #endif or #else we'll be able to respond
            // correctly
            nGlobalNestedLevel ++;
        } else {
            // skip over this section
            uRet = FindMatchingDirective(hWnd,hFile,pfMore,TRUE);
            if (uRet != ERROR_SUCCESS)
                return uRet;
        }

        // get next word and return it for real
        if (!GetNextWord(hWnd,hFile,pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szELSE)) {
        // found an #else, which means we took the upper branch, skip over
        // the lower branch
        if (!nGlobalNestedLevel) {
            // found an #else without a preceeding #if<xx>

            DisplayKeywordError(hWnd,IDS_ParseErr_UNMATCHED_DIRECTIVE,
                pBuf,NULL,pszParseFileName,nFileLine);
            return ERROR_ALREADY_DISPLAYED;
        }
        nGlobalNestedLevel--;

        uRet = FindMatchingDirective(hWnd,hFile,pfMore,FALSE);
        if (uRet != ERROR_SUCCESS)
            return uRet;
        if (!GetNextWord(hWnd,hFile,pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\pch.c ===
#include "admincfg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\poledit.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

HINSTANCE ghInst;          // current instance
CHAR 	 *pbufTemplates; //Buffer containing list of all active template files
HGLOBAL	  hBufTemplates;
DWORD	  dwBufTemplates;

BOOL ParseCommandLine(LPSTR lpszCommandLine,DWORD * pdwFlags);
extern VOID RunDialogMode(HWND hWnd,HWND hwndUser);
BOOL RestoreWindowPlacement( HWND hWnd,int nCmdShow);

//extern HBRUSH		hbrWindow;
//extern HBRUSH		hbrWindowText;
//extern HFONT		hfontHelv;

CHAR szAppName[SMALLBUF];
DWORD dwCmdLineFlags=0;
DWORD dwDlgRetCode=AD_SUCCESS;
BOOL g_bWinnt;

/*******************************************************************

	NAME:		WinMain

	SYNOPSIS:	App entry point

********************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,int nCmdShow)
{

	MSG msg;
	HANDLE hAccelTable;
        OSVERSIONINFO ver;


        //
        // Determine if we are running on Windows NT
        //

        ver.dwOSVersionInfoSize = sizeof(ver);
        if (GetVersionEx(&ver)) {
            g_bWinnt = (ver.dwPlatformId == VER_PLATFORM_WIN32_NT);
        } else {
            g_bWinnt = FALSE;
        }



        //
        // If this is NT, turn off alignment faults
        //

        if (g_bWinnt) {
            UINT uiErrMode;

            uiErrMode = SetErrorMode(0);
            SetErrorMode (uiErrMode | SEM_NOALIGNMENTFAULTEXCEPT);
        }


	if (!LoadString(hInstance,IDS_APPNAME,szAppName,sizeof(szAppName))) {
		MsgBox(NULL,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

        // allocate the buffer to read template files into
        if (!(hBufTemplates = GlobalAlloc(GHND,MEDIUMBUF)) ||
                !(pbufTemplates = (CHAR *) GlobalLock(hBufTemplates))) {
                if (hBufTemplates)
                        GlobalFree(hBufTemplates);
                return FALSE;
        }

        dwBufTemplates = MEDIUMBUF;

	// validate command line flags, if in dialog mode make sure we have all the requred
	// pieces.  If not, bag out
	if (!ParseCommandLine(lpCmdLine,&dwCmdLineFlags) ||
		(dwCmdLineFlags & CLF_DIALOGMODE) && (!(dwCmdLineFlags &
		CLF_USETEMPLATENAME) || !(dwCmdLineFlags & CLF_USEPOLICYFILENAME) ||
		!(dwCmdLineFlags & (CLF_USEWORKSTATIONNAME | CLF_USEUSERNAME)))) {
		MsgBox(NULL,IDS_ErrCOMMANDLINE,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	if (!hPrevInstance) {
		if (!InitApplication(hInstance)) {
			return (FALSE);
		}
	}

	/* Perform initializations that apply to a specific instance */

	if (!InitInstance(hInstance, nCmdShow)) {
#ifdef DEBUG
		OutputDebugString("InitInstance returned FALSE\r\n");
#endif
		return (FALSE);
	}

	hAccelTable = LoadAccelerators (hInstance,MAKEINTRESOURCE(IDA_ACCEL));

	/* Acquire and dispatch messages until a WM_QUIT message is received. */

	while (GetMessage(&msg,NULL,0,0))
	{
		if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg)) {
			TranslateMessage(&msg);// Translates virtual key codes
			DispatchMessage(&msg); // Dispatches message to window
		}
	}


//	if (hfontHelv) DeleteObject(hfontHelv);

	if (dwCmdLineFlags & CLF_DIALOGMODE)
		ExitProcess(dwDlgRetCode);

	return (int)(msg.wParam); // Returns the value from PostQuitMessage

	lpCmdLine; // This will prevent 'unused formal parameter' warnings
}

/****************************************************************************

	NAME: 		ParseCommandLine

	SYNOPSIS:	Parses command line for filename and other information

****************************************************************************/
BOOL ParseCommandLine(LPSTR lpszCommandLine,DWORD * pdwFlags)
{
	CHAR * GetTextToNextSpace(LPSTR pszText,CHAR * pszOutBuf,UINT cbOutBuf,
		BOOL fSkipLeading);

	if (!lpszCommandLine || !*lpszCommandLine)
		return TRUE;	// nothing to do

	while (*lpszCommandLine) {

		// advance past spaces
		while (*lpszCommandLine == ' ')
			lpszCommandLine ++;

		if (*lpszCommandLine == '/') {
			
			lpszCommandLine ++;
			if (!*lpszCommandLine)
				return FALSE;

			switch (*lpszCommandLine) {
				case 'u':
				case 'U':		// user name
					lpszCommandLine = GetTextToNextSpace(lpszCommandLine,
						szDlgModeUserName,sizeof(szDlgModeUserName),TRUE);
					if (!lstrlen(szDlgModeUserName)) return FALSE;
					*pdwFlags |= CLF_USEUSERNAME;
					break;

				case 'w':
				case 'W':		// workstation name
					lpszCommandLine = GetTextToNextSpace(lpszCommandLine,
						szDlgModeUserName,sizeof(szDlgModeUserName),TRUE);
					if (!lstrlen(szDlgModeUserName)) return FALSE;
					*pdwFlags |= CLF_USEWORKSTATIONNAME;
					break;

				case 't':
				case 'T':		// template name
					lpszCommandLine = GetTextToNextSpace(lpszCommandLine,
                                                pbufTemplates,dwBufTemplates,TRUE);
					if (!lstrlen(pbufTemplates)) return FALSE;
					*pdwFlags |= CLF_USETEMPLATENAME;
					break;

				case 'f':
				case 'F':		// file name
					lpszCommandLine = GetTextToNextSpace(lpszCommandLine,
						szDatFilename,sizeof(szDatFilename),TRUE);
					if (!lstrlen(szDatFilename)) return FALSE;
					*pdwFlags |= CLF_USEPOLICYFILENAME;
					break;

				case 'd':
				case 'D':		// dialog mode switch
					*pdwFlags |= CLF_DIALOGMODE;
					lpszCommandLine++;

					break;

				default:
					return FALSE;

			}
			
		} else {
			lpszCommandLine = GetTextToNextSpace(lpszCommandLine,
				szDatFilename,sizeof(szDatFilename),FALSE);
			return TRUE;							
		}
	}

	return TRUE;
}

CHAR * GetTextToNextSpace(LPSTR pszText,CHAR * pszOutBuf,UINT cbOutBuf,
	BOOL fSkipLeading)
{
	BOOL fInQuote = FALSE;

	lstrcpy(pszOutBuf,szNull);

	if (!pszText)
		return NULL;

	if (fSkipLeading) {
		// skip 1st character
		pszText++;
		// skip leading colon, if there is one
		if (*pszText == ':') pszText ++;
	}

	while (*pszText && cbOutBuf>1) {
		if (*pszText == ' ' && !fInQuote)
			break;
		if (*pszText == '\"') {
			fInQuote = !fInQuote;
		} else {
			*pszOutBuf = *pszText;		
			pszOutBuf ++;
			cbOutBuf --;
		}
		pszText ++;
 	}

	if (cbOutBuf)
		*pszOutBuf = '\0';	// null-terminate

	while (*pszText == ' ')
		pszText++;			// advance past spaces

	return pszText;
}

/****************************************************************************

	NAME: 		InitApplication

	SYNOPSIS:	Initializes window data and registers window class

****************************************************************************/
BOOL InitApplication(HINSTANCE hInstance)
{
	WNDCLASS  wc;

	// Fill in window class structure with parameters that describe the
	// main window.

	wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;// Class style(s).
	wc.lpfnWndProc   = (WNDPROC)WndProc;       // Window Procedure
	wc.cbClsExtra    = 0;                      // No per-class extra data.
	wc.cbWndExtra    = 0;                      // No per-window extra data.
	wc.hInstance     = hInstance;              // Owner of this class
	wc.hIcon         = LoadIcon (hInstance, MAKEINTRESOURCE(IDI_APPICON));
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
	wc.lpszMenuName  = MAKEINTRESOURCE(IDM_MAIN);
	wc.lpszClassName = szAppName;              // Name to register as

	// Register the window class and return success/failure code.
	if (!RegisterClass(&wc)) return FALSE;

	wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;// Class style(s).
	wc.lpfnWndProc   = (WNDPROC)ClipWndProc;   // Window Procedure
	wc.cbClsExtra    = 0;                      // No per-class extra data.
	wc.cbWndExtra    = sizeof(DWORD);
	wc.hInstance     = hInstance;              // Owner of this class
	wc.hIcon         = NULL;
	wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = "ClipClass";              // Name to register as

	if (!RegisterClass(&wc)) return FALSE;

	return TRUE;
}


/*******************************************************************

	NAME:		InitInstance

	SYNOPSIS:	Saves instance handle and creates main window

********************************************************************/
BOOL InitInstance(HINSTANCE hInstance,int nCmdShow)
{
	HWND hWnd; // Main window handle.
	DWORD dwStyle = WS_OVERLAPPEDWINDOW;

	// Save the instance handle in static variable, which will be used in
	// many subsequence calls from this application to Windows.

	ghInst = hInstance; // Store instance handle in our global variable

	if (dwCmdLineFlags & CLF_DIALOGMODE)
		dwStyle = (WS_OVERLAPPED | WS_CAPTION) &~ WS_VISIBLE;	// invisible window

	// Create a main window for this application instance.
	hWnd = CreateWindow(
		szAppName,	     // See RegisterClass() call.
		szAppName,	     // Text for window title bar.
		dwStyle,		// Window style.
		CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, // Use default positioning
		NULL,		     // Overlapped windows have no parent.
		NULL,		     // Use the window class menu.
		hInstance,	     // This instance owns this window.
		NULL		     // We don't use any data in our WM_CREATE
	);

	// If window could not be created, return "failure"
	if (!hWnd) {
		return (FALSE);
	}


    SetClassLongPtr(hWnd, GCLP_HICONSM, (LONG_PTR)LoadIcon(hInstance, szAppName));

	// hide app window if in dialog mode (but still create it to minimize
	// code path changes elsewhere)
	if (dwCmdLineFlags & CLF_DIALOGMODE)
		nCmdShow = SW_HIDE;

	RestoreWindowPlacement(hWnd, nCmdShow);
	UpdateWindow(hWnd);         // Sends WM_PAINT message

	if (dwCmdLineFlags & CLF_DIALOGMODE) {
		RunDialogMode(hWnd,hwndUser);
		DestroyWindow(hWnd);
	}

	return (TRUE);
}


/****************************************************************************

	FUNCTION: About(HWND, UINT, WPARAM, LPARAM)

	PURPOSE:  Processes messages for "About" dialog box

	MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

	COMMENTS:

	Display version information from the version section of the
	application resource.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

LRESULT CALLBACK About(
		HWND hDlg,           // window handle of the dialog box
		UINT message,        // type of message
		WPARAM uParam,       // message-specific information
	        LPARAM lParam)
{
	return (FALSE); // Didn't process the message

	lParam; // This will prevent 'unused formal parameter' warnings
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\options.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

extern BOOL fInfLoaded;

INT_PTR CALLBACK TemplateOptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam);
VOID InitTemplateOptDlg(HWND hDlg);

BOOL OnTemplateOptions(HWND hwndApp)
{
	return (BOOL)DialogBoxParam(ghInst,MAKEINTRESOURCE(DLG_TEMPLATEOPT),hwndApp,
		TemplateOptDlgProc,(LPARAM) hwndApp);
}


INT_PTR CALLBACK TemplateOptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{

   int i;

	switch (uMsg) {

		case WM_INITDIALOG:
			SetWindowLongPtr(hDlg,DWLP_USER,lParam);
			InitTemplateOptDlg(hDlg);
			return TRUE;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				
				case IDD_TEMPLATELIST:
				    if ((HIWORD(wParam) == LBN_SETFOCUS) && (dwAppState & AS_CANOPENTEMPLATE))
                        EnableDlgItem(hDlg,IDD_CLOSETEMPLATE,TRUE);

					break;

				case IDOK:
				    if (LoadTemplatesFromDlg(hDlg) == ERROR_SUCCESS)
					{
					    EndDialog(hDlg, TRUE);
					}
					break;

				case IDCANCEL:
					EndDialog(hDlg,TRUE);
					break;

				case IDD_CLOSETEMPLATE:

                    i = (int)SendDlgItemMessage(hDlg, IDD_TEMPLATELIST, LB_GETCURSEL,0,0);

					if (i != LB_ERR)
					    SendDlgItemMessage(hDlg, IDD_TEMPLATELIST, LB_DELETESTRING, i, 0);
					
                    EnableDlgItem(hDlg,IDD_CLOSETEMPLATE,FALSE);
	
					if (SendDlgItemMessage(hDlg, IDD_TEMPLATELIST, LB_GETCOUNT, 0,0) == 0)
		            {
		                fInfLoaded = FALSE;
		                dwAppState &= ~AS_CANHAVEDOCUMENT;
						EnableMenuItems((HWND) GetWindowLongPtr(hDlg,DWLP_USER), dwAppState);
					}
				    break;

				case IDD_OPENTEMPLATE:
					OnOpenTemplate(hDlg,(HWND) GetWindowLongPtr(hDlg,DWLP_USER));
			
					break;
			}

			break;
			
	}

	return FALSE;
}


VOID InitTemplateOptDlg(HWND hDlg)
{
	// if template loaded, display the name in the dialog
	if (fInfLoaded)
	{
		TCHAR *p = pbufTemplates;
		while (*p)
		{
            SendDlgItemMessage(hDlg, IDD_TEMPLATELIST, LB_ADDSTRING, 0,(LPARAM) p);
			p += lstrlen(p)+1;
		}
	}

	if (dwAppState & AS_CANOPENTEMPLATE) {
		EnableDlgItem(hDlg,IDD_OPENTEMPLATE,TRUE);
		// hide the text telling you why button is disabled (since it isn't)
		ShowWindow(GetDlgItem(hDlg,IDD_TXTEMPLATE),SW_HIDE);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\policy.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"

INT_PTR CALLBACK PolicyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam);
BOOL OnPolicyDlgCreate(HWND hDlg,LPARAM lParam);

VOID ProcessMouseDown(HWND hwndParent,HWND hwndTree);
VOID ProcessMouseUp(HWND hwndParent,HWND hwndTree);
VOID ProcessMouseMove(HWND hwndParent,HWND hwndTree);
VOID SetKeyboardHook(HWND hDlg);
VOID RemoveKeyboardHook(VOID);
extern VOID EnsureSettingControlVisible(HWND hDlg,HWND hwndCtrl);
extern HIMAGELIST hImageListSmall;

UINT CALLBACK PropSheetHeaderCallback (HWND hDlg, UINT msg, LPARAM lParam)
{

    LPDLGTEMPLATE pDlgTemplate = (LPDLGTEMPLATE) lParam;

    //
    // Turn off context sensitive help
    //

    if (msg == PSCB_PRECREATE) {
        pDlgTemplate->style &= ~DS_CONTEXTHELP;
    }

    return 1;
}

BOOL DoPolicyDlg(HWND hwndOwner,HGLOBAL hUser)
{
	USERHDR UserHdr;
	POLICYDLGINFO * pdi;
	PROPSHEETPAGE pagePolicies;	
	HPROPSHEETPAGE hpagePolicies,hpage[2] = {NULL,NULL};
	PROPSHEETHEADER psh;
	BOOL fRet;
	HGLOBAL hUserTmp=NULL;
	USERDATA * pUserData=NULL,*pUserDataTmp=NULL;

	memset(&pagePolicies,0,sizeof(pagePolicies));
	memset(&psh,0,sizeof(psh));

	if (!GetUserHeader(hUser,&UserHdr)) {
		MsgBox(hwndOwner,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
 		return FALSE;
	}

	if (!(pUserData = (USERDATA *) GlobalLock(hUser)) ||
		!(hUserTmp = GlobalAlloc(GHND,pUserData->dwSize)) ||
		!(pUserDataTmp = GlobalLock(hUserTmp)) ||
		!(pdi = (POLICYDLGINFO *) GlobalAlloc(GPTR,sizeof(POLICYDLGINFO)))) {
		if (pUserData)
		 	GlobalUnlock(hUser);
		if (hUserTmp) {
			if (pUserDataTmp)
				GlobalUnlock(hUserTmp);
			GlobalFree(hUserTmp);
		}
		if (pdi) GlobalFree(pdi);
		MsgBox(hwndOwner,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	// make a copy of the user buffer to operate on, so that changes can
	// be cancelled
	memcpy(pUserDataTmp,pUserData,pUserData->dwSize);
	GlobalUnlock(hUser);
	GlobalUnlock(hUserTmp);

	pdi->dwControlTableSize = DEF_CONTROLS * sizeof(POLICYCTRLINFO);
	pdi->nControls = 0;
	pdi->hUser = hUserTmp;
	pdi->pEntryRoot = (UserHdr.dwType & UT_USER ?
		gClassList.pUserCategoryList : gClassList.pMachineCategoryList);
	pdi->hwndApp = hwndOwner;

	if (!(pdi->pControlTable = (POLICYCTRLINFO *)
		GlobalAlloc(GPTR,pdi->dwControlTableSize))) {
		GlobalFree(hUserTmp);
		GlobalFree(pdi);
		MsgBox(hwndOwner,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	pagePolicies.dwSize = sizeof(PROPSHEETPAGE);
	pagePolicies.dwFlags = PSP_DEFAULT;
	pagePolicies.hInstance = ghInst;
	pagePolicies.pfnDlgProc = PolicyDlgProc;
	pagePolicies.pszTemplate = MAKEINTRESOURCE(DLG_POLICIES);
	pagePolicies.lParam = (LPARAM) pdi;

	if (!(hpagePolicies = CreatePropertySheetPage(&pagePolicies))) {
		MsgBox(hwndOwner,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		fRet=FALSE;
		goto cleanup;
	}

	hpage[0] = hpagePolicies;

	psh.dwSize = sizeof(PROPSHEETHEADER);
	psh.dwFlags = PSH_PROPTITLE | PSH_USEICONID | PSH_NOAPPLYNOW | PSH_USECALLBACK;
	psh.hwndParent = hwndOwner;
	psh.hInstance = ghInst;
	psh.nPages = 1;
	psh.nStartPage = 0;
	psh.phpage = hpage;
	psh.pszCaption = UserHdr.szName;
	psh.pszIcon = MAKEINTRESOURCE(IDI_APPICON);
        psh.pfnCallback = PropSheetHeaderCallback;
	
	fRet=(BOOL) PropertySheet(&psh);

	if (fRet) {
		// user hit OK, copy the temporary user buffer to the real one.
		// may have to resize 'real' buffer.

		if (!CopyUser(hUserTmp,hUser)) {
			MsgBox(hwndOwner,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
			fRet = FALSE;
		}

		dwAppState |= AS_FILEDIRTY;
		EnableMenuItems(hwndOwner,dwAppState);
	}

cleanup:
	GlobalFree(pdi->pControlTable);
	GlobalFree(pdi);
	GlobalFree(hUserTmp);

	return fRet;
}

INT_PTR CALLBACK PolicyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{

	switch (uMsg) {

		case WM_INITDIALOG:

			if (!OnPolicyDlgCreate(hDlg,lParam)) {
				return FALSE;
			}
			SetKeyboardHook(hDlg);
			break;

		case WM_NOTIFY:

			if ( ((NMHDR *) lParam)->hwndFrom == GetDlgItem(hDlg,IDD_TVPOLICIES)
				&& ((POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER))->fActive) {
				BOOL fRet;
				fRet=OnTreeNotify(hDlg,( (NMHDR *)lParam)->hwndFrom,
					(NM_TREEVIEW *) lParam);
				SetWindowLongPtr(hDlg,DWLP_MSGRESULT,(LPARAM) fRet);
				return fRet;
			}

			switch ( ((NMHDR * ) lParam)->code) {

				case PSN_APPLY:				
					if (IsSelectedItemChecked(GetDlgItem(hDlg,IDD_TVPOLICIES)) &&
						!ProcessSettingsControls(hDlg,PSC_VALIDATENOISY)) {
						SetWindowLongPtr(hDlg,DWLP_MSGRESULT,(LPARAM) TRUE);
						return TRUE;
					}
					((POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER))->fActive=FALSE;
					RemoveKeyboardHook();
					return TRUE;
					break;

				case PSN_RESET:
					((POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER))->fActive=FALSE;
					RemoveKeyboardHook();
					return TRUE;
					break;

			}
			break;

		case WM_SETCURSOR:

			switch (HIWORD(lParam)) {
				case WM_LBUTTONDOWN:
					ProcessMouseDown(hDlg,GetDlgItem(hDlg,IDD_TVPOLICIES));
				break;

				case WM_LBUTTONUP:
					ProcessMouseUp(hDlg,GetDlgItem(hDlg,IDD_TVPOLICIES));
				break;

				case WM_MOUSEMOVE:
					ProcessMouseMove(hDlg,GetDlgItem(hDlg,IDD_TVPOLICIES));
				break;
			}
			break;

		case WM_MOUSEMOVE:
			ProcessMouseMove(hDlg,GetDlgItem(hDlg,IDD_TVPOLICIES));
			break;

		default:
			return FALSE;

	}

	return TRUE;

}

BOOL OnPolicyDlgCreate(HWND hDlg,LPARAM lParam)
{
	POLICYDLGINFO * pdi;
	HWND hwndPolicy = GetDlgItem(hDlg,IDD_TVPOLICIES);
	CHAR szTitle[255];
	USERHDR UserHdr;
	WINDOWPLACEMENT wp;

	if (!(pdi = (POLICYDLGINFO *) (( (PROPSHEETPAGE *) lParam)->lParam) ))
		return FALSE;
	if (!GetUserHeader(pdi->hUser,&UserHdr)) return FALSE;

	// Set the title of the dialog to "Policies for <user>"
	wsprintf(szTitle,LoadSz(IDS_POLICIESFOR,szSmallBuf,sizeof(szSmallBuf)),
		UserHdr.szName);
	SetWindowText(hDlg,szTitle);

	wp.length = sizeof(wp);
	GetWindowPlacement(pdi->hwndApp,&wp);

	SetWindowPos(hDlg,NULL,wp.rcNormalPosition.left+30,
		wp.rcNormalPosition.top+40,0,0,SWP_NOSIZE | SWP_NOZORDER);

	// lParam is pointer to POLICYDLGINFO struct with information for this
	// instance of the dialog, store the pointer in the window data
	pdi->fActive=TRUE;
	SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) pdi);

	// now that we've stored pointer to POLICYDLGINFO struct in our extra
	// window data, send WM_USER to clip window to tell it to create a
	// child container window (and store the handle in our POLICYDLGINFO)
	SendDlgItemMessage(hDlg,IDD_TVSETTINGS,WM_USER,0,0L);

	SetWindowLong(hwndPolicy,GWL_EXSTYLE,WS_EX_CLIENTEDGE);
	SetWindowLong(GetDlgItem(hDlg,IDD_TVSETTINGS),GWL_EXSTYLE,WS_EX_CLIENTEDGE);

	SetScrollRange(GetDlgItem(hDlg,IDD_TVSETTINGS),SB_VERT,0,100,TRUE);
	SetScrollRange(GetDlgItem(hDlg,IDD_TVSETTINGS),SB_VERT,0,0,TRUE);
	SetScrollRange(hwndPolicy,SB_VERT,0,100,TRUE);
	SetScrollRange(hwndPolicy,SB_VERT,0,0,TRUE);

	TreeView_SetImageList(hwndPolicy,hImageListSmall,TVSIL_NORMAL);

	if (!RefreshTreeView(pdi,hwndPolicy,pdi->pEntryRoot,pdi->hUser)) {
		MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	return TRUE;
}

BOOL SetPolicyState(HWND hDlg,TABLEENTRY * pTableEntry,UINT uState)
{
 	POLICY * pPolicy = (POLICY *) pTableEntry;
	USERDATA * pUserData;
	POLICYDLGINFO * pdi;

	if (!pPolicy) return FALSE;
	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)))
		return FALSE;
	if (!(pUserData = (USERDATA *) GlobalLock(pdi->hUser))) {
		return FALSE;
	}

	pUserData->SettingData[pPolicy->uDataIndex].uData = uState;
	
	GlobalUnlock(pdi->hUser);

	return TRUE;
}

HHOOK hKbdHook = NULL;
HWND hDlgActive = NULL;

LRESULT CALLBACK KeyboardHookProc(int nCode, WPARAM wParam,LPARAM lParam)
{
	if (wParam == VK_TAB && !(lParam & 0x80000000)) {	// tab key depressed
		BOOL fShift = (GetKeyState(VK_SHIFT) & 0x80000000);
		HWND hwndFocus = GetFocus();
		POLICYDLGINFO * pdi;
		int iIndex;
		int iDelta;

		if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlgActive, DWLP_USER)))
			return 0;

		// see if the focus control is one of the setting controls
		for (iIndex=0;iIndex<(int)pdi->nControls;iIndex++)
			if (pdi->pControlTable[iIndex].hwnd == hwndFocus)
				break;

		if (iIndex == (int) pdi->nControls)
			return 0;	// no, we don't care
			
		iDelta = (fShift ? -1 : 1);

		// from the current setting control, scan forwards or backwards
		// (depending if on shift state, this can be TAB or shift-TAB)
		// to find the next control to give focus to
		for (iIndex += iDelta;iIndex>=0 && iIndex<(int) pdi->nControls;
			iIndex += iDelta) {
			if (pdi->pControlTable[iIndex].uDataIndex !=
				NO_DATA_INDEX &&
				IsWindowEnabled(pdi->pControlTable[iIndex].hwnd)) {

				// found it, set the focus on that control and return 1
				// to eat the keystroke
				SetFocus(pdi->pControlTable[iIndex].hwnd);
				EnsureSettingControlVisible(hDlgActive,
					pdi->pControlTable[iIndex].hwnd);
				return 1;
			}
		}

		// at first or last control in settings table, let dlg code
		// handle it and give focus to next (or previous) control in dialog
	}

	return 0;
}

VOID SetKeyboardHook(HWND hDlg)
{
	// hook the keyboard to trap TABs.  If this fails for some reason,
	// fail silently and go on, not critical that tabs work correctly
	// (unless you have no mouse :)  )
	if (hKbdHook = SetWindowsHookEx(WH_KEYBOARD,KeyboardHookProc,
		ghInst,GetCurrentThreadId())) {
		hDlgActive = hDlg;
	}
}


VOID RemoveKeyboardHook(VOID)
{
	if (hKbdHook) {
		UnhookWindowsHookEx(hKbdHook);
		hKbdHook = NULL;
		hDlgActive = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\policy.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#ifndef _POLICY_H_
#define _POLICY_H_

#define NO_DATA_INDEX	(UINT) -1
#define DEF_CONTROLS 	10

typedef struct tagPOLICYCTRLINFO {
	HWND hwnd;
	DWORD dwType;
	UINT uDataIndex;			// index into user's data buffer
	SETTINGS * pSetting;
} POLICYCTRLINFO;

typedef struct tagSTRDATA {
	DWORD dwSize;				// size of structure incl. variable-len data
	CHAR  szData[];				// variable-length data	
} STRDATA;

typedef struct tagPOLICYDLGINFO {
	HGLOBAL hUser;				// handle to user's data buffer
	TABLEENTRY * pEntryRoot;	// root template
	SETTINGS * pCurrentSettings;// template for current settings 
	HWND 	hwndSettings;
	HWND	hwndApp;
	BOOL    fActive;

	POLICYCTRLINFO * pControlTable;
	DWORD dwControlTableSize;
	UINT nControls;
} POLICYDLGINFO;

#endif // _POLICY_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\registry.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

UINT nFileShortcutItems=0;

/*******************************************************************

	NAME:		RestoreStateFromRegistry

	SYNOPSIS:	Reads from registry and restores window
				placement

********************************************************************/
BOOL RestoreStateFromRegistry(HWND hWnd)
{
	HKEY	hKeyMain;
	DWORD 	dwType,dwSize;
    UINT  	nIndex;
	CHAR 	szFilename[MAX_PATH+1];
    CHAR 	szValueName[24];
	DWORD 	dwAlloc = MEDIUMBUF;
	DWORD   dwUsed = 0;

    if (dwCmdLineFlags & CLF_DIALOGMODE)
        return TRUE;    // nothing to do
    
    if (RegCreateKey(HKEY_CURRENT_USER,szAPPREGKEY,&hKeyMain) !=
        ERROR_SUCCESS) return FALSE;
    
	// get template names (if not already specified on command line)
	if (!(dwCmdLineFlags & CLF_USETEMPLATENAME))
	{
        nIndex = 0;
        wsprintf(szValueName, szTemplate, nIndex);
        dwSize = sizeof(szFilename);

	    while (RegQueryValueEx(hKeyMain,szValueName,NULL,&dwType,
	              (CHAR *) &szFilename,&dwSize) == ERROR_SUCCESS)
	    {
			if (!(pbufTemplates=ResizeBuffer(pbufTemplates,hBufTemplates,dwUsed+dwSize+4,&dwBufTemplates)))
				return ERROR_NOT_ENOUGH_MEMORY;

			lstrcpy(pbufTemplates+dwUsed,szFilename);
			dwUsed += dwSize;

            nIndex++;
            wsprintf(szValueName, szTemplate, nIndex);
	        dwSize = sizeof(szFilename);
		}

		if (nIndex == 0)
	    {
                        dwUsed = GetDefaultTemplateFilename(hWnd,pbufTemplates,dwBufTemplates);
	   	}

		// doubly null-terminate the buffer... safe to do this because we
		// tacked on the extra "+4" in the ResizeBuffer calls above
		*(pbufTemplates+dwUsed) = '\0';
		dwUsed ++;
	}

	// get view information
	dwSize = sizeof(ViewInfo);
	if (RegQueryValueEx(hKeyMain,LoadSz(IDS_VIEW,szSmallBuf,
		sizeof(szSmallBuf)),NULL,&dwType,
		(CHAR *) &ViewInfo,&dwSize) != ERROR_SUCCESS) {
		ViewInfo.fStatusBar = ViewInfo.fToolbar = TRUE;
		ViewInfo.dwView = VT_LARGEICONS;
   	}

	RegCloseKey(hKeyMain);
	return TRUE;
}


/*******************************************************************

	NAME:		SaveStateToRegistry

	SYNOPSIS:	Saves window placement, etc.

********************************************************************/
BOOL SaveStateToRegistry(HWND hWnd)
{
	HKEY hKeyMain;
	WINDOWPLACEMENT wp;
    UINT i;
    CHAR szValueName[24];
	DWORD dwFileLen;
	CHAR *p;

	
	if (dwCmdLineFlags & CLF_DIALOGMODE)
		return TRUE;  // nothing to do

	if (RegCreateKey(HKEY_CURRENT_USER,szAPPREGKEY,&hKeyMain) !=
		ERROR_SUCCESS) return FALSE;

	// save windowplacement
	wp.length = sizeof(wp);
	if (GetWindowPlacement(hWnd,&wp)) {
		RegSetValueEx(hKeyMain,LoadSz(IDS_WP,szSmallBuf,
			sizeof(szSmallBuf)),0,REG_BINARY,(CHAR *) &wp,
			sizeof(WINDOWPLACEMENT));
	}

	// save list of template files
	p = pbufTemplates;
	i = 0;
	while (*p)
	{
	    wsprintf(szValueName, szTemplate, i);
		dwFileLen = lstrlen(p)+1;
		RegSetValueEx(hKeyMain,szValueName,0,REG_SZ,p,dwFileLen);
		p += dwFileLen;
		i++;
	}

	// make sure there aren't more template file already listed in the registry.
	wsprintf(szValueName, szTemplate, i);
	RegDeleteValue(hKeyMain,szValueName);
							
	// save view infomation
	RegSetValueEx(hKeyMain,LoadSz(IDS_VIEW,szSmallBuf,sizeof(szSmallBuf)),
        0,REG_BINARY,(CHAR *)&ViewInfo,sizeof(ViewInfo));

	RegCloseKey(hKeyMain);
	return TRUE;
}

VOID LoadFileMenuShortcuts(HMENU hMenu)
{
	HKEY hKey;
	UINT nIndex,nMenuID = IDM_FILEHISTORY,uPos = GetMenuItemCount(hMenu);
	CHAR szValueName[24],szFileName[MAX_PATH+1];
	DWORD dwSize;
	MENUITEMINFO mii;

	if (RegOpenKey(HKEY_CURRENT_USER,szAPPREGKEY,&hKey) !=
		ERROR_SUCCESS) return;

	memset(&mii,0,sizeof(mii));
	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
	mii.fType = MFT_STRING;
	mii.dwTypeData = szFileName;
	mii.fState = MFS_ENABLED;
	
	for (nIndex = 0; nIndex<FILEHISTORY_COUNT;nIndex ++) {
		wsprintf(szValueName,szLastFile,nIndex);
		dwSize = sizeof(szFileName);
		if (RegQueryValueEx(hKey,szValueName,NULL,NULL,szFileName,
			&dwSize) == ERROR_SUCCESS) {

			if (!nFileShortcutItems) {
				// if this is the first file shortcut, insert a separator
				// bar first
				MENUITEMINFO miiTmp;

				memset(&miiTmp,0,sizeof(miiTmp));
				miiTmp.cbSize = sizeof(miiTmp);
				miiTmp.fMask = MIIM_TYPE;
				miiTmp.fType = MFT_SEPARATOR;
				InsertMenuItem(hMenu,uPos,TRUE,&miiTmp);
				uPos++;
			}

			mii.wID = nMenuID;
			mii.cch = lstrlen(szFileName);
			
			// insert the file shortcut menu item
			InsertMenuItem(hMenu,uPos,TRUE,&mii);
			uPos++;
			nMenuID ++;
			nFileShortcutItems++;
		}
	}
	
	RegCloseKey(hKey);
}

VOID SaveFileMenuShortcuts(HMENU hMenu)
{
	HKEY hKey;
	UINT nIndex,nMenuID = IDM_FILEHISTORY,nLen;
	CHAR szValueName[24],szFilename[MAX_PATH+1];
	MENUITEMINFO mii;

	if (RegCreateKey(HKEY_CURRENT_USER,szAPPREGKEY,&hKey) !=
		ERROR_SUCCESS) return;

	memset(&mii,0,sizeof(mii));
	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_TYPE;
	mii.dwTypeData = szFilename;

	// get the file shortcuts from menu and save them to registry
	for (nIndex = 0;nIndex<FILEHISTORY_COUNT;nIndex++) {
		mii.cch = sizeof(szFilename);
		if (GetMenuItemInfo(hMenu,nMenuID,FALSE,&mii) &&
			(nLen=lstrlen(szFilename))) {
			wsprintf(szValueName,szLastFile,nIndex);
			RegSetValueEx(hKey,szValueName,0,REG_SZ,szFilename,
				nLen+1);
		}
		nMenuID++;
	}

	RegCloseKey(hKey);
}

/*******************************************************************

	NAME:		RestoreWindowPlacement

	SYNOPSIS:	Restores window placement from registry, calls
				SetWindowPlacement()

********************************************************************/
BOOL RestoreWindowPlacement( HWND hWnd,int nCmdShow)
{
	WINDOWPLACEMENT wp;
	DWORD dwType,dwSize = sizeof(WINDOWPLACEMENT);
	HKEY hKeyMain;
	BOOL fRestored=FALSE;

	if (RegCreateKey(HKEY_CURRENT_USER,szAPPREGKEY,&hKeyMain) ==
		ERROR_SUCCESS) {

		// get info out of registry
		if (RegQueryValueEx(hKeyMain,LoadSz(IDS_WP,szSmallBuf,
			sizeof(szSmallBuf)),NULL,&dwType,
			(CHAR *) &wp,&dwSize) == ERROR_SUCCESS) {

			wp.showCmd = nCmdShow;
			SetWindowPlacement(hWnd,&wp);
			fRestored = TRUE;	
		}
	 	RegCloseKey(hKeyMain);
	}

	if (!fRestored)
		ShowWindow(hWnd,nCmdShow);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\regutil.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

UINT WriteRegistryDWordValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	DWORD dwValue)
{
	HKEY hKey;
	UINT uRet;

	if (!pszKeyName || !pszValueName)
		return ERROR_INVALID_PARAMETER;

	// create the key with appropriate name
	if ( (uRet = RegCreateKey(hkeyRoot,pszKeyName,&hKey))
		!= ERROR_SUCCESS)
		return uRet;
	
	uRet = RegSetValueEx(hKey,pszValueName,0,REG_DWORD,
		(CHAR *) &dwValue,sizeof(dwValue));
	RegCloseKey(hKey);

	return uRet;
}

UINT ReadRegistryDWordValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	DWORD * pdwValue)
{
	HKEY hKey;
	UINT uRet;
	DWORD dwType,dwSize = sizeof(DWORD);
	
	if (!pszKeyName || !pszValueName)
		return ERROR_INVALID_PARAMETER;
	*pdwValue = 0;

	// open appropriate key
	if ( (uRet = RegOpenKey(hkeyRoot,pszKeyName,&hKey))
		!= ERROR_SUCCESS)
		return uRet;
	
	uRet = RegQueryValueEx(hKey,pszValueName,0,&dwType,
		(CHAR *) pdwValue,&dwSize);
	RegCloseKey(hKey);

	return uRet;
}

UINT WriteRegistryStringValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	CHAR * pszValue, BOOL bExpandable)
{
	HKEY hKey;
	UINT uRet;

	if (!pszKeyName || !pszValueName)
		return ERROR_INVALID_PARAMETER;

	// create the key with appropriate name
	if ( (uRet = RegCreateKey(hkeyRoot,pszKeyName,&hKey))
		!= ERROR_SUCCESS)
		return uRet;
	
	uRet = RegSetValueEx(hKey,pszValueName,0,
                bExpandable ?  REG_EXPAND_SZ : REG_SZ,
		(CHAR *) pszValue,lstrlen(pszValue)+1);
	RegCloseKey(hKey);

	return uRet;
}

UINT ReadRegistryStringValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	CHAR * pszValue,UINT cbValue)
{
	HKEY hKey;
	UINT uRet;
	DWORD dwType;
	DWORD dwSize = cbValue;

	if (!pszKeyName || !pszValueName)
		return ERROR_INVALID_PARAMETER;

	// create the key with appropriate name
	if ( (uRet = RegOpenKey(hkeyRoot,pszKeyName,&hKey))
		!= ERROR_SUCCESS)
		return uRet;
	
	uRet = RegQueryValueEx(hKey,pszValueName,0,&dwType,
		(CHAR *) pszValue,&dwSize);
	RegCloseKey(hKey);

	return uRet;
}

UINT DeleteRegistryValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName)
{
	HKEY hKey;
	UINT uRet;

	if (!pszKeyName || !pszValueName)
		return ERROR_INVALID_PARAMETER;

	// create the key with appropriate name
	if ( (uRet = RegOpenKey(hkeyRoot,pszKeyName,&hKey))
		!= ERROR_SUCCESS)
		return uRet;
	
	uRet = RegDeleteValue(hKey,pszValueName);
	RegCloseKey(hKey);

	return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\settings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#ifndef _SETTINGS_H_
#define _SETTINGS_H_

#define	WT_CLIP			1
#define WT_SETTINGS		2

#define SSTYLE_STATIC 		WS_CHILD | WS_VISIBLE
#define SSTYLE_CHECKBOX		WS_CHILD | WS_VISIBLE | BS_CHECKBOX
#define SSTYLE_EDITTEXT		WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | WS_BORDER
#define SSTYLE_UPDOWN		WS_CHILD | WS_VISIBLE | UDS_NOTHOUSANDS
#define SSTYLE_COMBOBOX		WS_CHILD | WS_VISIBLE | CBS_AUTOHSCROLL | CBS_DROPDOWN \
	| WS_BORDER | CBS_SORT | WS_VSCROLL
#define SSTYLE_DROPDOWNLIST	WS_CHILD | WS_VISIBLE | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST \
	| WS_BORDER | CBS_SORT | WS_VSCROLL
#define SSTYLE_LISTVIEW		WS_CHILD | WS_VISIBLE | WS_BORDER
#define SSTYLE_LBBUTTON		WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON

#define LISTBOX_BTN_WIDTH 		100
#define LISTBOX_BTN_HEIGHT 		20

#define SC_XSPACING				3
#define SC_YSPACING				1
#define SC_YPAD                                 8
#define SC_EDITWIDTH			200
#define SC_UPDOWNWIDTH			50
#define SC_UPDOWNWIDTH2			30
#define SC_XLEADING				5
#define SC_XINDENT				10

#endif // _SETTINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\settings.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"
#include "settings.h"

HFONT hfontDlg=NULL;
BOOL SetHwndBkColor(HWND hWnd,COLORREF color);

BOOL GetTextSize(HWND hWnd,CHAR * szText,SIZE * pSize);
BOOL AdjustWindowToText(HWND hWnd,CHAR * szText,UINT xStart,UINT yStart,UINT yPad,
	UINT * pnWidth,UINT * pnHeight);
int AddControlHwnd(POLICYDLGINFO * pdi,POLICYCTRLINFO * pPolicyCtrlInfo);
BOOL SetWindowData(POLICYDLGINFO * pdi,HWND hwndControl,DWORD dwType,
	UINT uDataIndex,SETTINGS * pSetting);
VOID ProcessScrollBar(HWND hWnd,WPARAM wParam);
VOID ProcessCommand(HWND hWnd,HWND hwndCtrl);
HWND CreateSetting(POLICYDLGINFO * pdi,CHAR * pszClassName,CHAR * pszWindowName,
	DWORD dwExStyle,DWORD dwStyle,int x,int y,int cx,int cy,DWORD dwType,UINT uIndex,
	SETTINGS * pSetting);
VOID InsertComboboxItems(HWND hwndControl,CHAR *pSuggestionList);
BOOL ValidateIsNotEmpty(HWND hwndCtrl,HWND hDlg,SETTINGS * pSetting,DWORD dwValidate);
BOOL ObjectTypeHasDataOffset(DWORD dwType);
VOID EnsureSettingControlVisible(HWND hDlg,HWND hwndCtrl);
int FindComboboxItemData(HWND hwndControl,UINT nData);

/*******************************************************************

	NAME:		ClipWndProc

	SYNOPSIS:	Window proc for ClipClass window

********************************************************************/
LRESULT CALLBACK ClipWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	switch (message) {
		case WM_CREATE:

			if (!((CREATESTRUCT *) lParam)->lpCreateParams) {

				// this is the clip window in the dialog box.
				SetScrollRange(hWnd,SB_VERT,0,0,TRUE);

				hfontDlg = (HFONT) SendMessage(GetParent(hWnd),WM_GETFONT,0,0L);
			} else {
				// this is the container window

				// store away the dialog box HWND (the grandparent of this
				// window) because the pointer to instance data we need lives
				// in the dialog's window data
				SetWindowLong(hWnd,0,WT_SETTINGS);
			}

	 		break;

		case WM_USER:
			{
				HWND hwndParent = GetParent(hWnd);
				POLICYDLGINFO * pdi;

				if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hwndParent, DWLP_USER)))
					return FALSE;
				// make a container window that is clipped by this windows
				if (!(pdi->hwndSettings=CreateWindow("ClipClass",(CHAR *) szNull,
					WS_CHILD | WS_VISIBLE,0,0,400,400,hWnd,NULL,ghInst,
					(LPVOID) hWnd)))
					return FALSE;
				SetWindowLong(hWnd,0,WT_CLIP);
				return TRUE;
			}
			break;

		case WM_VSCROLL:

			if (GetWindowLong(hWnd,0) == WT_CLIP)
				ProcessScrollBar(hWnd,wParam);
			else goto defproc;

			return 0;

			break;


		case WM_COMMAND:

			if (GetWindowLong(hWnd,0) == WT_SETTINGS)
				ProcessCommand(hWnd,(HWND) lParam);

			break;

		case WM_GETDLGCODE:

			if (GetWindowLong(hWnd,0) == WT_CLIP) {
				SetWindowLongPtr(GetParent(hWnd),DWLP_MSGRESULT,DLGC_WANTTAB |
					DLGC_WANTALLKEYS);
				return DLGC_WANTTAB | DLGC_WANTALLKEYS;
			}
			break;

		case WM_SETFOCUS:
			// if clip window gains keyboard focus, transfer focus to first
			// control owned by settings window
			if (GetWindowLong(hWnd,0) == WT_CLIP) {
				HWND hwndParent = GetParent(hWnd);
				POLICYDLGINFO * pdi;
				INT nIndex;
				BOOL fForward=TRUE;
				HWND hwndOK = GetDlgItem(GetParent(hwndParent),IDOK);
				int iDelta;

				if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hwndParent, DWLP_USER)))
					return FALSE;

				// if OK button lost focus, then we're going backwards
				// in tab order; otherwise we're going forwards
				if ( (HWND) wParam == hwndOK)
					fForward = FALSE;

				// find the first control that has a data index (e.g. is
				// not static text) and give it focus

				if (pdi->nControls) {
					if (fForward) {		// search from start of table forwards
					 	nIndex = 0;
						iDelta = 1;
					} else {			// search from end of table backwards
						nIndex = pdi->nControls-1;
						iDelta = -1;
					}

					for (;nIndex>=0 && nIndex<(int)pdi->nControls;nIndex += iDelta) {
						if (pdi->pControlTable[nIndex].uDataIndex !=
							NO_DATA_INDEX &&
							IsWindowEnabled(pdi->pControlTable[nIndex].hwnd)) {
							 	SetFocus(pdi->pControlTable[nIndex].hwnd);
							EnsureSettingControlVisible(hwndParent,
								pdi->pControlTable[nIndex].hwnd);
							return FALSE;
						}
					}
				}

				// only get here if there are no setting windows that can
				// receive keyboard focus.  Give keyboard focus to the
				// next guy in line.  This is the "OK" button, unless we
				// shift-tabbed to get here from the "OK" button in which
				// case the tree window is the next guy in line

				if (fForward)
					SetFocus(hwndOK);
				else SetFocus(GetDlgItem(hwndParent,IDD_TVPOLICIES));

				return FALSE;
			}
			break;

		default:
defproc:		
			return (DefWindowProc(hWnd, message, wParam, lParam));
		
	}

	return (0);
}

/*******************************************************************

	NAME:		ProcessCommand

	SYNOPSIS:	WM_COMMAND handler for ClipClass window

********************************************************************/
VOID ProcessCommand(HWND hWnd,HWND hwndCtrl)
{
	// get instance-specific struct from dialog
	UINT uID = GetWindowLong(hwndCtrl,GWL_ID);
	POLICYDLGINFO * pdi;
	
	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(GetParent(GetParent(hWnd)),
		DWLP_USER))) return;

	if ( (uID >= IDD_SETTINGCTRL) && (uID < IDD_SETTINGCTRL+pdi->nControls)) {
		POLICYCTRLINFO * pPolicyCtrlInfo= &pdi->pControlTable[uID - IDD_SETTINGCTRL];

		switch (pPolicyCtrlInfo->dwType) {

			case STYPE_CHECKBOX:

				SendMessage(hwndCtrl,BM_SETCHECK,
					!(SendMessage(hwndCtrl,BM_GETCHECK,0,0)),0);

				break;

			case STYPE_LISTBOX:
				ShowListbox(hwndCtrl,pdi->hUser,pPolicyCtrlInfo->pSetting,
					pPolicyCtrlInfo->uDataIndex);
				break;

			default:	
				// nothing to do
				break;
		}
	}
}


/*******************************************************************

	NAME:		CreateSettingsControls

	SYNOPSIS:	Creates controls in settings window

	NOTES:		Looks at a table of SETTINGS structs to determine
				type of control to create and type-specific information.
				For some types, more than one control can be created
				(for instance, edit fields get a static control with
				the title followed by an edit field control).

	ENTRY:		hDlg - owner dialog
				hTable - table of SETTINGS structs containing setting
					control information						

********************************************************************/
BOOL CreateSettingsControls(HWND hDlg,SETTINGS * pSetting,BOOL fEnable)
{
	CHAR * pObjectData;
	POLICYDLGINFO * pdi;
	UINT xMax=0,yStart=SC_YSPACING,nHeight,nWidth,yMax,xWindowMax;
	HWND hwndControl,hwndBuddy,hwndParent;
	RECT rcParent;
	DWORD dwType, dwStyle;
	UINT uEnable = (fEnable ? 0 : WS_DISABLED);
	WINDOWPLACEMENT wp;

	// get instance-specific struct from dialog
	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)))
		return FALSE;

	wp.length = sizeof(wp);
	if (!GetWindowPlacement(GetDlgItem(hDlg,IDD_TVPOLICIES),&wp))
		return FALSE;
	xWindowMax = wp.rcNormalPosition.right - wp.rcNormalPosition.left;
		
	pdi->pCurrentSettings = pSetting;

	while (pSetting) {

		pObjectData = GETOBJECTDATAPTR(pSetting);

		dwType = pSetting->dwType & STYPE_MASK;
		nWidth = 0;

		switch (dwType) {

			case STYPE_TEXT:

				// create static text control
				if (!(hwndControl = CreateSetting(pdi,(CHAR *) szSTATIC,
					(CHAR *) (GETNAMEPTR(pSetting)),0,SSTYLE_STATIC | uEnable,0,
					yStart,0,15,STYPE_TEXT,NO_DATA_INDEX,0)))
					return FALSE;
				AdjustWindowToText(hwndControl,(CHAR *) (GETNAMEPTR(pSetting))
					,SC_XSPACING,yStart,0,&nWidth,&nHeight);

				yStart += nHeight + SC_YSPACING;
				nWidth += SC_XSPACING;
				
				break;

			case STYPE_CHECKBOX:
				
				// create checkbox control
				if (!(hwndControl = CreateSetting(pdi,(CHAR *) szBUTTON,
					(CHAR *) (GETNAMEPTR(pSetting)),0,SSTYLE_CHECKBOX | uEnable,
					0,yStart,200,nHeight,STYPE_CHECKBOX,pSetting->uDataIndex,
					pSetting)))
					return FALSE;
                                nWidth = 20;
				AdjustWindowToText(hwndControl,(CHAR *) (GETNAMEPTR(pSetting))
					,SC_XSPACING,yStart,0,&nWidth,&nHeight);
				yStart += nHeight + SC_YSPACING;
				nWidth += SC_XSPACING;
				break;

			case STYPE_EDITTEXT:
			case STYPE_COMBOBOX:

				// create static text with setting name
				if (!(hwndControl = CreateSetting(pdi,(CHAR *) szSTATIC,
					GETNAMEPTR(pSetting),0,SSTYLE_STATIC | uEnable,0,0,0,0,
					STYPE_TEXT,NO_DATA_INDEX,0)))
					return FALSE;
				AdjustWindowToText(hwndControl,
					GETNAMEPTR(pSetting),SC_XSPACING,yStart,SC_YPAD,
					&nWidth,&nHeight);

				nWidth += SC_XSPACING + 5;

				if (nWidth + SC_EDITWIDTH> xWindowMax) {
					// if next control will stick out of settings window,
					// put it on the next line
					if (nWidth > xMax)
						xMax = nWidth;
					yStart += nHeight + SC_YSPACING - SC_YPAD;
					nWidth = SC_XINDENT;
				}

				// create edit field or combo box control
				if (dwType == STYPE_EDITTEXT) {
					hwndControl = CreateSetting(pdi,(CHAR *) szEDIT,(CHAR *) szNull,
						WS_EX_CLIENTEDGE,SSTYLE_EDITTEXT | uEnable,nWidth,yStart,SC_EDITWIDTH,nHeight,
						STYPE_EDITTEXT,pSetting->uDataIndex,pSetting);
				} else {

                    dwStyle = SSTYLE_COMBOBOX | uEnable;

	                if (pSetting->dwFlags & DF_NOSORT) {
                        dwStyle &= ~CBS_SORT;
                    }

					hwndControl = CreateSetting(pdi,(CHAR *) szCOMBOBOX,(CHAR *)szNull,
						WS_EX_CLIENTEDGE,dwStyle,nWidth,yStart,SC_EDITWIDTH,nHeight*3,
						STYPE_COMBOBOX,pSetting->uDataIndex,pSetting);
				}
				if (!hwndControl) return FALSE;

				// limit the text length appropriately
				SendMessage(hwndControl,EM_SETLIMITTEXT,
					(WPARAM) ((EDITTEXTINFO *) pObjectData)->nMaxLen,0L);

				if (dwType == STYPE_COMBOBOX &&
					((POLICYCOMBOBOXINFO *) pObjectData)->uOffsetSuggestions)
					InsertComboboxItems(hwndControl,(CHAR *) pSetting +
						((POLICYCOMBOBOXINFO *) pObjectData)->uOffsetSuggestions);

				yStart += (UINT) ((float) nHeight*1.3) + SC_YSPACING;
				nWidth += SC_EDITWIDTH;

				break;	

			case STYPE_NUMERIC:
				// create static text for setting
				if (!(hwndControl = CreateSetting(pdi,(CHAR *) szSTATIC,
					GETNAMEPTR(pSetting),0,
					SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0)))
					return FALSE;
				AdjustWindowToText(hwndControl,
					GETNAMEPTR(pSetting),SC_XSPACING,yStart,SC_YPAD,
					&nWidth,&nHeight);

				nWidth += SC_XSPACING + 5;

				// create edit field
				if (!(hwndBuddy = CreateSetting(pdi,(CHAR *) szEDIT,
					(CHAR *) szNull,WS_EX_CLIENTEDGE,SSTYLE_EDITTEXT | uEnable,nWidth,yStart,SC_UPDOWNWIDTH,
					nHeight,STYPE_NUMERIC,pSetting->uDataIndex,pSetting)))
					return FALSE;
				// SendMessage(hwndBuddy,EM_LIMITTEXT,4,0);

				nWidth += SC_UPDOWNWIDTH + SC_XLEADING;

				// create spin (up-down) control if specifed
				if (((NUMERICINFO *)pObjectData)->uSpinIncrement)  {
					UDACCEL udAccel = {0,0};
					UINT nMax,nMin;
					if (!(hwndControl = CreateSetting(pdi,(CHAR *) szUPDOWN,
						(CHAR *) szNull,0,SSTYLE_UPDOWN | UDS_SETBUDDYINT | uEnable,nWidth,yStart,SC_UPDOWNWIDTH2,
						nHeight,STYPE_TEXT,NO_DATA_INDEX,0)))
					return FALSE;
					

					nWidth += SC_UPDOWNWIDTH2;

					nMax = ((NUMERICINFO *) pObjectData)->uMaxValue;
					nMin = ((NUMERICINFO *) pObjectData)->uMinValue;
					udAccel.nInc = ((NUMERICINFO *) pObjectData)->uSpinIncrement;
						
					SendMessage(hwndControl,UDM_SETBUDDY,(WPARAM) hwndBuddy,0L);
					SendMessage(hwndControl,UDM_SETRANGE,0,MAKELONG(nMax,nMin));
					SendMessage(hwndControl,UDM_SETACCEL,1,(LPARAM) &udAccel);
				}
				yStart += nHeight + SC_YSPACING;
				
				break;

			case STYPE_DROPDOWNLIST:

				// create text description
				if (!(hwndControl = CreateSetting(pdi,(CHAR *) szSTATIC,
					GETNAMEPTR(pSetting),0,
					SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0)))
					return FALSE;
				AdjustWindowToText(hwndControl,
					GETNAMEPTR(pSetting),SC_XSPACING,yStart,SC_YPAD,&nWidth,&nHeight);
				nWidth += SC_XLEADING;

				if (nWidth + SC_EDITWIDTH> xWindowMax) {
					// if next control will stick out of settings window,
					// put it on the next line
					if (nWidth > xMax)
						xMax = nWidth;
					yStart += nHeight + SC_YSPACING - SC_YPAD;
					nWidth = SC_XINDENT;
				}

                dwStyle = SSTYLE_DROPDOWNLIST | uEnable;

	            if (pSetting->dwFlags & DF_NOSORT) {
                    dwStyle &= ~CBS_SORT;
                }

				// create drop down listbox
				hwndControl = CreateSetting(pdi,(CHAR *) szCOMBOBOX,(CHAR *) szNull,
                        WS_EX_CLIENTEDGE,dwStyle,nWidth,yStart,SC_EDITWIDTH,nHeight*3,
						STYPE_DROPDOWNLIST,pSetting->uDataIndex,pSetting);
				if (!hwndControl) return FALSE;
				nWidth += SC_EDITWIDTH;

				{
					// insert dropdown list items into control
					UINT uOffset = pSetting->uOffsetObjectData,nIndex=0;
					DROPDOWNINFO * pddi;
					int iSel;

					while (uOffset) {
						pddi = (DROPDOWNINFO *) ( (CHAR *) pSetting + uOffset);
						iSel=(int)SendMessage(hwndControl,CB_ADDSTRING,0,(LPARAM)
							((CHAR *) pSetting + pddi->uOffsetItemName));
						if (iSel<0) return FALSE;
						SendMessage(hwndControl,CB_SETITEMDATA,iSel,nIndex);
						nIndex++;
						uOffset = pddi->uOffsetNextDropdowninfo;
					}
				}

				yStart += (UINT) ((float) nHeight*1.3) + 1;
				break;

			case STYPE_LISTBOX:

				// create static text with description
				if (!(hwndControl = CreateSetting(pdi,(CHAR *) szSTATIC,
					GETNAMEPTR(pSetting),0,
					SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0)))
					return FALSE;
				AdjustWindowToText(hwndControl,GETNAMEPTR(pSetting),SC_XSPACING,yStart,
					SC_YPAD,&nWidth,&nHeight);
				nWidth += SC_XLEADING;

				if (nWidth + LISTBOX_BTN_WIDTH> xWindowMax) {
					// if next control will stick out of settings window,
					// put it on the next line
					if (nWidth > xMax)
						xMax = nWidth;
					yStart += nHeight + SC_YSPACING - SC_YPAD;
					nWidth = SC_XINDENT;
				}
			
				// create pushbutton to show listbox contents
				hwndControl = CreateSetting(pdi,(CHAR *) szBUTTON,LoadSz(IDS_LISTBOX_SHOW,
					szSmallBuf,sizeof(szSmallBuf)),0,
					SSTYLE_LBBUTTON | uEnable,nWidth+5,yStart,
					LISTBOX_BTN_WIDTH,nHeight,STYPE_LISTBOX,
					pSetting->uDataIndex,pSetting);
				if (!hwndControl) return FALSE;
				nWidth += LISTBOX_BTN_WIDTH + SC_XLEADING;

				yStart += nHeight+1;
		}

		if (nWidth > xMax)
			xMax = nWidth;
		pSetting = (SETTINGS *) pSetting->pNext;
	}

	yMax = yStart - 1;

	SetWindowPos(pdi->hwndSettings,NULL,0,0,xMax,yMax,SWP_NOZORDER);
	hwndParent = GetParent(pdi->hwndSettings);
	GetClientRect(hwndParent,&rcParent);

	if (yMax > (UINT) rcParent.bottom-rcParent.top) {
		SetScrollRange(hwndParent,SB_VERT,0,100,TRUE);
		SetScrollPos(hwndParent,SB_VERT,0,TRUE);
	} else SetScrollRange(hwndParent,SB_VERT,0,0,TRUE);

	return TRUE;
}

/*******************************************************************

	NAME:		CreateSettings

	SYNOPSIS:	Creates a control and add it to the table of settings
				controls

********************************************************************/
HWND CreateSetting(POLICYDLGINFO * pdi,CHAR * pszClassName,CHAR * pszWindowName,
	DWORD dwExStyle,DWORD dwStyle,int x,int y,int cx,int cy,DWORD dwType,UINT uIndex,
	SETTINGS * pSetting)
{
	HWND hwndControl;

	if (!(hwndControl = CreateWindowEx(WS_EX_NOPARENTNOTIFY | dwExStyle,
		pszClassName,pszWindowName,dwStyle,x,y,cx,cy,pdi->hwndSettings,NULL,
		ghInst,NULL))) return NULL;

	if (!SetWindowData(pdi,hwndControl,dwType,uIndex,pSetting)) {
		DestroyWindow(hwndControl);
		return NULL;
	}

	SendMessage(hwndControl,WM_SETFONT,(WPARAM) hfontDlg,MAKELPARAM(TRUE,0));

	return hwndControl;
}

/*******************************************************************

	NAME:		ProcessSettingsControls

	SYNOPSIS:	For each settings control, takes currently entered data
				from control and saves data in user's buffer.

********************************************************************/
BOOL ProcessSettingsControls(HWND hDlg,DWORD dwValidate)
{
	UINT nIndex;
	USERDATA * pUserData;
	POLICYDLGINFO * pdi;
	SETTINGS * pSetting;
	CHAR szTextData[MAXSTRLEN];
	BOOL fRet=TRUE;

	// get instance-specific struct from dialog
	// from instance-specific struct, get user's data buffer and setting info
	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)) ||
		!(pUserData = (USERDATA *) GlobalLock(pdi->hUser))) {
		MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		fRet=FALSE;
		goto cleanup;
	}

	pSetting = pdi->pCurrentSettings;

	for (nIndex=0;nIndex<pdi->nControls;nIndex++) {
		pSetting = pdi->pControlTable[nIndex].pSetting;

		if (pdi->pControlTable[nIndex].uDataIndex != NO_DATA_INDEX) {
			switch (pdi->pControlTable[nIndex].dwType) {

				case STYPE_CHECKBOX:

					pUserData->SettingData[pdi->pControlTable[nIndex].uDataIndex].uData
						= (UINT)SendMessage(pdi->pControlTable[nIndex].hwnd,BM_GETCHECK,
							0,0L);

					break;

				case STYPE_EDITTEXT:
				case STYPE_COMBOBOX:
	
					SendMessage(pdi->pControlTable[nIndex].hwnd,WM_GETTEXT,
						sizeof(szTextData),(LPARAM) szTextData);

					// don't allow empty text if this is required field
					if (dwValidate && !ValidateIsNotEmpty(pdi->pControlTable[nIndex].hwnd,
						hDlg,pSetting,dwValidate)) {
						fRet = FALSE;
						goto cleanup;						
					}

					// add this text to buffer.  Need to unlock handle before
					// call and relock afterwards, as buffer may resize and move
					GlobalUnlock(pdi->hUser);
					SetVariableLengthData(pdi->hUser,pdi->pControlTable[nIndex].uDataIndex,
						szTextData,lstrlen(szTextData)+1);
					if (!(pUserData = (USERDATA *) GlobalLock(pdi->hUser)))
						return FALSE;

					break;

				case STYPE_NUMERIC:

					{
						BOOL fTranslated;
						UINT uRet;

						uRet=GetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
							&fTranslated,FALSE);						

						if (dwValidate) {
							NUMERICINFO * pNumericInfo;

							// don't allow empty text if this is required field
							if (!ValidateIsNotEmpty(pdi->pControlTable[nIndex].hwnd,
								hDlg,pSetting,dwValidate)) {
								fRet = FALSE;
								goto cleanup;						
							}
							// check for non-numeric in edit ctrl						
							if (!fTranslated) {
								if (dwValidate == PSC_VALIDATENOISY) {
								 	MsgBoxParam(hDlg,IDS_INVALIDNUM,
										GETNAMEPTR(pSetting),MB_ICONINFORMATION,
										MB_OK);
									SetFocus(pdi->pControlTable[nIndex].hwnd);
									SendMessage(pdi->pControlTable[nIndex].hwnd,
										EM_SETSEL,0,-1);
								}
								fRet = FALSE;
								goto cleanup;
							}

							// validate for max and min
							pNumericInfo = (NUMERICINFO *) GETOBJECTDATAPTR(pSetting);
							if (uRet < pNumericInfo->uMinValue) uRet = pNumericInfo->uMinValue;
							if (uRet > pNumericInfo->uMaxValue) uRet = pNumericInfo->uMaxValue;
						}

						pUserData->SettingData[pdi->pControlTable[nIndex].uDataIndex].uData =
							(fTranslated ? uRet : NO_VALUE);
					}
					
					break;

				case STYPE_DROPDOWNLIST:
					{
						int iSel;

						iSel = (int)SendMessage(pdi->pControlTable[nIndex].hwnd,
							CB_GETCURSEL,0,0L);
						iSel = (int)SendMessage(pdi->pControlTable[nIndex].hwnd,
							CB_GETITEMDATA,iSel,0L);

						if (dwValidate && iSel < 0) {
							if (dwValidate == PSC_VALIDATENOISY) {
								MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
									MB_ICONINFORMATION,MB_OK);
								SetFocus(pdi->pControlTable[nIndex].hwnd);
							}
							return FALSE;
						}

						pUserData->SettingData[pdi->pControlTable[nIndex].uDataIndex].uData
							= (UINT) iSel;

					}					
					break;
			}
		}
	}

cleanup:
	GlobalUnlock(pdi->hUser);
	return fRet;
}


/*******************************************************************

	NAME:		FreeSettingsControls

	SYNOPSIS:	Frees all settings controls

********************************************************************/
VOID FreeSettingsControls(HWND hDlg)
{
	UINT nIndex;
	POLICYDLGINFO * pdi;

	// get instance-specific struct from dialog
	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)))
		return;

	for (nIndex=0;nIndex<pdi->nControls;nIndex++) {
		DestroyWindow(pdi->pControlTable[nIndex].hwnd);
	}

	pdi->pCurrentSettings = NULL;
	pdi->nControls = 0;

	SetScrollRange(pdi->hwndSettings,SB_VERT,0,0,TRUE);
}

/*******************************************************************

	NAME:		SetVariableLengthData

	SYNOPSIS:	Adds variable length data to user's data buffer, reallocs
				if necessary.						

	CAVEATS:	Since this call may realloc the user's data buffer (hUser),
				it must always be unlocked before calling.

	NOTES:		For variable-length data (edit-text, listboxes), the
				SettingData struct for a particular setting contains an
				offset to the actual data.  (The offset is from the beginning
				of the USERDATA struct.)  If this offset is zero, it means
				no data has been entered and there is no allocation for
				that setting yet.  The offset points to a STRDATA struct,
				which contains a size entry followed by data.  If an allocation
				currently exists but is insufficient for new data (e.g.,
				user previously entered a string value, now goes back and
				changes it and the new one is longer), then the buffer is
				realloced, the end of the buffer is memcopy'd to enlarge the
				region of allocation, and offsets into the section that moved
				are fixed up.
				
********************************************************************/
#define SHRINK_THRESHOLD	64
BOOL SetVariableLengthData(HGLOBAL hUser,UINT nDataIndex,TCHAR * pchData,
	DWORD cbData)
{
	USERDATA * pUserData;
	STRDATA * pStrData = NULL;
	DWORD dwCurrentSize,dwStrSize;		
	UINT uOffsetData;

	if (!(pUserData = (USERDATA *) GlobalLock(hUser)))
		return FALSE;

	uOffsetData = pUserData->SettingData[nDataIndex].uOffsetData;

	// if no existing data and no new data, nothing to do
	if ((!uOffsetData || uOffsetData == INIT_WITH_DEFAULT) && cbData<1) {
		GlobalUnlock(hUser);
		return TRUE;
	}

	if (!uOffsetData || uOffsetData == INIT_WITH_DEFAULT) {
		// no data for this setting yet, allocate extra room and stick
		// this data at the end of the buffer
	
		pUserData->SettingData[nDataIndex].uOffsetData = pUserData->dwSize;
		dwStrSize = 0;

	} else {
		// there's already data for this setting, make sure there's enough
		// room to put the new data in the buffer
	
		pStrData = (STRDATA *) ( (LPBYTE) pUserData +
			pUserData->SettingData[nDataIndex].uOffsetData);
		dwStrSize = pStrData->dwSize;
	}

	// if the current string buffer is not large enough, or is larger than
	// we need by a lot (SHRINK_THRESHOLD), resize that buffer area to just
	// fit the current data (rounded up to DWORD alignment).
	// add sizeof(DWORD) to make room for length header in STRDATA struct
	if ((dwStrSize < cbData + sizeof(DWORD)) ||
		(dwStrSize > cbData+sizeof(DWORD)+SHRINK_THRESHOLD)) {
		int nAdditional = RoundToDWord(cbData -
			(dwStrSize - sizeof(DWORD)));
		DWORD dwOldSize;

		dwOldSize = dwCurrentSize = pUserData->dwSize;		

		// resize the buffer to make more room
		if (!(pUserData = (USERDATA *) ResizeBuffer((CHAR *) pUserData,
			hUser,dwCurrentSize+nAdditional,&dwCurrentSize)))
			return FALSE;
		pUserData->dwSize = dwCurrentSize;

		pStrData = (STRDATA *) ( (CHAR *) pUserData +
			pUserData->SettingData[nDataIndex].uOffsetData);
		pStrData->dwSize = dwStrSize;

		// we may be expanding the middle of the buffer-- copy the rest of
		// the buffer "down" to make room
		{
			TCHAR * pchFrom,* pchTo;
			UINT cbMove;
			UINT uOffsetMoved;
			UINT nIndex;

			pchFrom = (TCHAR *) pStrData + pStrData->dwSize;
			pchTo = pchFrom + nAdditional;
			uOffsetMoved = (UINT)(pchFrom - (CHAR *) pUserData);
			cbMove = dwOldSize - uOffsetMoved;

			pStrData->dwSize += nAdditional;

			if (cbMove) {
				memmove(pchTo,pchFrom,cbMove * sizeof(TCHAR));
				
				// now we've moved a chunk of the buffer, need to fix up
				// data offsets that point into the chunk that moved.

				for (nIndex = 0;nIndex<pUserData->nSettings;nIndex++) {

					if (ObjectTypeHasDataOffset(pUserData->SettingData[nIndex].dwType
						& STYPE_MASK)) {

                                            if (pUserData->SettingData[nIndex].uOffsetData != INIT_WITH_DEFAULT) {

						if (pUserData->SettingData[nIndex].uOffsetData >= uOffsetMoved) {

                                                    pUserData->SettingData[nIndex].uOffsetData
                                                            += nAdditional;
                                                }
                                            }
					}
				}
			}
		}
	}

        if (pStrData)
	    memcpy(pStrData->szData,pchData, cbData * sizeof(TCHAR));

	GlobalUnlock(hUser);

	return TRUE;
}

/*******************************************************************

	NAME:		EnableSettingsControls

	SYNOPSIS:	Enables or disables all setting controls

	NOTES:		If disabling, "clears" control as appropriate to the
				control type (e.g. for edit fields, clears text); if
				enabling, restores control contents from user's data buffer

********************************************************************/
BOOL EnableSettingsControls(HWND hDlg,BOOL fEnable)
{
	UINT nIndex;
	USERDATA * pUserData;
	UINT nDataIndex;
	HWND hwndControl;
	POLICYDLGINFO * pdi;
	SETTINGS * pSetting;

	// get instance-specific struct from dialog
	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)) ||
		!pdi->pCurrentSettings)
		return FALSE;
	if (!(pUserData = (USERDATA *) GlobalLock(pdi->hUser))) return FALSE;

	pSetting = pdi->pCurrentSettings;

	for (nIndex=0;nIndex<pdi->nControls;nIndex++) {
		nDataIndex = pdi->pControlTable[nIndex].uDataIndex;
		hwndControl = pdi->pControlTable[nIndex].hwnd;

		switch (pdi->pControlTable[nIndex].dwType) {

			case STYPE_CHECKBOX:
				SendMessage(hwndControl,BM_SETCHECK,(fEnable ?
					pUserData->SettingData[nDataIndex].uData :
					0),0L);
				
				break;

			case STYPE_EDITTEXT:
			case STYPE_COMBOBOX:
				// for edit fields, clear text from edit field if disabled;
				// replace text if enabled

				// if this is the first time this setting is enabled for this
				// user and there is a default value to use, set that in
				// the user's data buffer

				if (fEnable && pUserData->SettingData[nDataIndex].uOffsetData ==
					INIT_WITH_DEFAULT) {
					CHAR * pszDefaultText;
					pszDefaultText = (CHAR *) pdi->pControlTable[nIndex].pSetting +
						((EDITTEXTINFO *) GETOBJECTDATAPTR(pdi->pControlTable[nIndex].
						pSetting))->uOffsetDefText;

					// add this text to buffer.  Need to unlock handle before
					// call and relock afterwards, as buffer may resize and move
					GlobalUnlock(pdi->hUser);
					SetVariableLengthData(pdi->hUser,pdi->pControlTable[nIndex].uDataIndex,
						pszDefaultText,lstrlen(pszDefaultText)+1);
					if (!(pUserData = (USERDATA *) GlobalLock(pdi->hUser)))
						return FALSE;
				}	

				if (fEnable) {
					// set the text appropriately
					if (pUserData->SettingData[nDataIndex].uOffsetData) {
						CHAR * pchText;

						pchText = ((STRDATA *) ((CHAR *) pUserData +
							pUserData->SettingData[nDataIndex].uOffsetData))
							->szData;
						SendMessage(hwndControl,WM_SETTEXT,0,(LPARAM) pchText);
					}
				} else {
					// clear the text
					SendMessage(hwndControl,WM_SETTEXT,0,(LPARAM) szNull);
				}

				break;

			case STYPE_NUMERIC:
				if (fEnable) {
					UINT uData = pUserData->SettingData[nDataIndex].uData;

					if (uData != NO_VALUE)
						SetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
							uData,FALSE);

				} else {
					// clear the number
					SendMessage(hwndControl,WM_SETTEXT,0,(LPARAM) szNull);
				}
				break;


			case STYPE_DROPDOWNLIST:
				if (fEnable) {
					SendMessage(hwndControl,CB_SETCURSEL,
						FindComboboxItemData(hwndControl,pUserData->SettingData[nDataIndex].uData),
						0L);
				} else {
					SendMessage(hwndControl,CB_SETCURSEL,(UINT) -1,0L);
				}

				break;

			case STYPE_LISTBOX:

				// nothing to do

				break;
		}

		EnableWindow(pdi->pControlTable[nIndex].hwnd,fEnable);
	}

	GlobalUnlock(pdi->hUser);

        return TRUE;
}

BOOL SetWindowData(POLICYDLGINFO * pdi,HWND hwndControl,DWORD dwType,
	UINT uDataIndex,SETTINGS * pSetting)
{
	POLICYCTRLINFO PolicyCtrlInfo;
	int iCtrl;

        PolicyCtrlInfo.hwnd = hwndControl;
        PolicyCtrlInfo.dwType = dwType;
        PolicyCtrlInfo.uDataIndex = uDataIndex;
        PolicyCtrlInfo.pSetting = pSetting;

        iCtrl = AddControlHwnd(pdi,&PolicyCtrlInfo);
	if (iCtrl < 0) return FALSE;

	SetWindowLong(hwndControl,GWL_ID,iCtrl + IDD_SETTINGCTRL);

	return TRUE;
}

BOOL AdjustWindowToText(HWND hWnd,CHAR * szText,UINT xStart,UINT yStart,
	UINT yPad,UINT * pnWidth,UINT * pnHeight)
{
	SIZE size;

	if (GetTextSize(hWnd,szText,&size))
        {
            *pnHeight =size.cy + yPad;
            *pnWidth += size.cx;
            SetWindowPos(hWnd,NULL,xStart,yStart,*pnWidth,*pnHeight,SWP_NOZORDER);
        }

	return FALSE;
}

BOOL SetHwndBkColor(HWND hWnd,COLORREF color)
{
	HDC hDC;
	BOOL fRet;

	if (!(hDC = GetDC(hWnd))) return FALSE;

	fRet=(SetBkColor(hDC,color) != CLR_INVALID);

	ReleaseDC(hWnd,hDC);

	return fRet;
}

BOOL GetTextSize(HWND hWnd,CHAR * szText,SIZE * pSize)
{
	HDC hDC;
	BOOL fRet;

	if (!(hDC = GetDC(hWnd))) return FALSE;

        SelectObject(hDC, hfontDlg);
	fRet=GetTextExtentPoint(hDC,szText,lstrlen(szText),pSize);

	ReleaseDC(hWnd,hDC);

	return fRet;
}

int AddControlHwnd(POLICYDLGINFO * pdi,POLICYCTRLINFO * pPolicyCtrlInfo)
{
	int iRet;
	DWORD dwNeeded;
        POLICYCTRLINFO * pTemp;

	// grow table if necessary
	dwNeeded = (pdi->nControls+1) * sizeof(POLICYCTRLINFO);
	if (dwNeeded > pdi->dwControlTableSize) {
		pTemp = (POLICYCTRLINFO *) GlobalReAlloc(pdi->pControlTable,
			dwNeeded,GMEM_ZEROINIT | GMEM_MOVEABLE);
		if (!pTemp) return (-1);
                pdi->pControlTable = pTemp;
		pdi->dwControlTableSize = dwNeeded;
	}

        pdi->pControlTable[pdi->nControls] = *pPolicyCtrlInfo;

	iRet = (int) pdi->nControls;

	(pdi->nControls)++;

	return iRet;
}

// scrolls the control window into view if it's not visible
VOID EnsureSettingControlVisible(HWND hDlg,HWND hwndCtrl)
{	
	// get the clip window, which owns the scroll bar
	HWND hwndClip = GetDlgItem(hDlg,IDD_TVSETTINGS);	
	POLICYDLGINFO * pdi;
	UINT nPos = GetScrollPos(hwndClip,SB_VERT),ySettingWindowSize,yClipWindowSize;
	UINT nExtra;
	int iMin,iMax=0;
	WINDOWPLACEMENT wp;
	RECT rcCtrl;

	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)))
		return;

	// find the scroll range
	GetScrollRange(hwndClip,SB_VERT,&iMin,&iMax);
	if (!iMax) 	// no scroll bar, nothing to do
		return;

	// find the y size of the settings window that contains the settings controls
	// (this is clipped by the clip window in the dialog, scroll bar moves the
	// setting window up and down behind the clip window)
	wp.length = sizeof(wp);
	if (!GetWindowPlacement(pdi->hwndSettings,&wp))
		return; // unlikely to fail, but just bag out if it does rather than do something wacky
	ySettingWindowSize=wp.rcNormalPosition.bottom-wp.rcNormalPosition.top;

	// find y size of clip window
	if (!GetWindowPlacement(hwndClip,&wp))
		return; // unlikely to fail, but just bag out if it does rather than do something wacky
	yClipWindowSize=wp.rcNormalPosition.bottom-wp.rcNormalPosition.top;
	nExtra = ySettingWindowSize - yClipWindowSize;	

	// if setting window is smaller than clip window, there should be no
	// scroll bar so we should never get here.  Check just in case though...
	if (ySettingWindowSize < yClipWindowSize)
		return;	

	// get y position of control to be made visible
	if (!GetWindowPlacement(hwndCtrl,&wp))
		return;
	rcCtrl = wp.rcNormalPosition;
	rcCtrl.bottom = min ((int) ySettingWindowSize,rcCtrl.bottom + SC_YPAD);
	rcCtrl.top = max ((int) 0,rcCtrl.top - SC_YPAD);

	// if bottom of control is out of view, scroll the settings window up
	if ((float) rcCtrl.bottom >
		(float) (yClipWindowSize + ( (float) nPos/(float)iMax) * (ySettingWindowSize -
		yClipWindowSize))) {
		UINT nNewPos = (UINT)
			( ((float) (nExtra - (ySettingWindowSize - rcCtrl.bottom)) / (float) nExtra) * iMax);

		SetScrollPos(hwndClip,SB_VERT,nNewPos,TRUE);
		ProcessScrollBar(hwndClip,MAKELPARAM(SB_THUMBTRACK,nNewPos));
		return;
	}

	// if top of control is out of view, scroll the settings window down
	if ((float) rcCtrl.top <
		(float) ( (float) nPos/(float)iMax) * nExtra) {
		UINT nNewPos = (UINT)
			( ((float) rcCtrl.top / (float) nExtra) * iMax);

		SetScrollPos(hwndClip,SB_VERT,nNewPos,TRUE);
		ProcessScrollBar(hwndClip,MAKELPARAM(SB_THUMBTRACK,nNewPos));
		return;
	}
}


VOID ProcessScrollBar(HWND hWnd,WPARAM wParam)
{
	UINT nPos = GetScrollPos(hWnd,SB_VERT);
	RECT rcParent,rcChild;
	POLICYDLGINFO * pdi;

	// get instance-specific struct from dialog
	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(GetParent(hWnd),DWLP_USER)))
		return;

	switch (LOWORD(wParam)) {

		case SB_THUMBPOSITION:
		case SB_THUMBTRACK:
			nPos = HIWORD(wParam);
			break;

		case SB_TOP:
			nPos = 0;
			break;

		case SB_BOTTOM:
			nPos = 100;
			break;
		
		case SB_LINEUP:
			nPos -= 10;
			break;

		case SB_LINEDOWN:
			nPos += 10;
			break;

		case SB_PAGEUP:
			nPos -= 30;
			break;

		case SB_PAGEDOWN:
			nPos += 30;
			break;
	}

//	wsprintf(szDebugOut,"nPos: %lu\r\n",nPos);
//	OutputDebugString(szDebugOut);

	SetScrollPos(hWnd,SB_VERT,nPos,TRUE);

	GetClientRect(hWnd,&rcParent);
	GetClientRect(pdi->hwndSettings,&rcChild);

	SetWindowPos(pdi->hwndSettings,NULL,0,-(int) ((( (float)
		(rcChild.bottom-rcChild.top)-(rcParent.bottom-rcParent.top))
		/100.0) * (float) nPos),rcChild.right,rcChild.bottom,SWP_NOZORDER |
		SWP_NOSIZE);

}

/*******************************************************************

	NAME:		ValidateIsNotEmpty

	SYNOPSIS:	Returns TRUE if specified edit control has text in it,
				displays warning popup and returns FALSE if empty

********************************************************************/
BOOL ValidateIsNotEmpty(HWND hwndCtrl,HWND hDlg,SETTINGS * pSetting,DWORD dwValidate)
{
	if (pSetting->dwFlags & DF_REQUIRED) {
		CHAR szTextData[MAXSTRLEN];

		SendMessage(hwndCtrl,WM_GETTEXT,sizeof(szTextData),(LPARAM) szTextData);

		if (!lstrlen(szTextData)) {
			if (dwValidate == PSC_VALIDATENOISY) {
				MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
					MB_ICONINFORMATION,MB_OK);
				SetFocus(hwndCtrl);
			}
			return FALSE;
		}
	}

	return TRUE;
}

/*******************************************************************

	NAME:		ObjectTypeHasDataOffset

	SYNOPSIS:	Returns TRUE if specified object type has a data offset
				in SETTINGDATA struct (uOffsetData) rather than a value
				(uData).

********************************************************************/
BOOL ObjectTypeHasDataOffset(DWORD dwType)
{
	switch (dwType) {

		case STYPE_EDITTEXT:
		case STYPE_COMBOBOX:
		case STYPE_LISTBOX:
			return TRUE;		
	}

	return FALSE;
}

VOID InsertComboboxItems(HWND hwndControl,CHAR * pSuggestionList)
{
	while (*pSuggestionList) {
		SendMessage(hwndControl,CB_ADDSTRING,0,(LPARAM) pSuggestionList);
		pSuggestionList += lstrlen(pSuggestionList) + 1;
	}
}

/*******************************************************************

	NAME:		FindComboboxItemData

	SYNOPSIS:	Returns the index of item in combobox whose item data
				is equal to nData.  Returns -1 if no items have data
				which matches.

********************************************************************/
int FindComboboxItemData(HWND hwndControl,UINT nData)
{
	UINT nIndex;

	for (nIndex=0;nIndex<(UINT) SendMessage(hwndControl,CB_GETCOUNT,0,0L);
		nIndex++) {
		if ((UINT) SendMessage(hwndControl,CB_GETITEMDATA,nIndex,0L) == nData)
			return (int) nIndex;
	}

	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=windows
MINORCOMP=poledit

TARGETNAME=poledit
TARGETPATH=obj
TARGETTYPE=LIBRARY
TARGETLIBS=

INCLUDES=..;..\..\inc; \
         $(SHELL_INC_PATH);\
         

SOURCES=..\poledit.c  \
        ..\main.c     \
        ..\util.c     \
        ..\strings.c  \
        ..\registry.c \
        ..\user.c     \
        ..\infmgr.c   \
        ..\memory.c   \
        ..\parse.c    \
        ..\treeview.c \
        ..\treectrl.c \
        ..\listctrl.c \
        ..\policy.c   \
        ..\settings.c \
        ..\add.c      \
        ..\view.c     \
        ..\filecmd.c  \
        ..\regutil.c  \
        ..\save.c     \
        ..\load.c     \
        ..\remove.c   \
        ..\options.c  \
        ..\connect.c  \
        ..\listbox.c  \
        ..\copy.c     \
        ..\grouppri.c \
        ..\admincfg.rc

UMTYPE=windows
UMAPPL=poledit
UMENTRY=winmain
UMLIBS=$(SDK_LIB_PATH)\ntdll.lib     \
       $(SDK_LIB_PATH)\kernel32.lib  \
       $(SDK_LIB_PATH)\comdlg32.lib  \
       $(SDK_LIB_PATH)\shell32.lib   \
       $(SHELL_LIB_PATH)\shell32p.lib \
       $(SDK_LIB_PATH)\gdi32.lib     \
       $(SDK_LIB_PATH)\user32.lib    \
       $(SDK_LIB_PATH)\advapi32.lib  \
       $(SDK_LIB_PATH)\comctl32.lib  \
       $(SDK_LIB_PATH)\shell32.lib   \
       $(SDK_LIB_PATH)\htmlhelp.lib  \
       $(O)\poledit.lib                         \
       $(O)\admincfg.res

SUBSYSTEM_VERSION=4.00

PRECOMPILED_INCLUDE=..\admincfg.h
PRECOMPILED_PCH=admincfg.pch
PRECOMPILED_OBJ=admincfg.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\save.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"
UINT SaveUserData(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName);
UINT SaveOneEntry(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName,BOOL fErase);
UINT SavePolicy(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName);
UINT SaveSettings(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName,BOOL fErase);
UINT SaveListboxData(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName,BOOL fErase,BOOL fMarkDeleted);
UINT WriteStandardValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	TABLEENTRY * pTableEntry,DWORD dwData,BOOL fErase,BOOL fWriteZero);
UINT WriteCustomValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	STATEVALUE * pStateValue,BOOL fErase);
UINT WriteCustomValue_W(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	CHAR * pszValue,DWORD dwValue,DWORD dwFlags,BOOL fErase);
UINT WriteActionList(HKEY hkeyRoot,ACTIONLIST * pActionList,
	CHAR *pszCurrentKeyName,BOOL fErase);
UINT WriteDropdownValue(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName,CHAR * pszValueName,UINT nValue,BOOL fErase);
UINT ProcessPolicyActionLists(HKEY hkeyRoot,POLICY * pPolicy,
	CHAR * pszCurrentKeyName,UINT uState,BOOL fErase);
UINT ProcessCheckboxActionLists(HKEY hkeyRoot,TABLEENTRY * pTableEntry,
	CHAR * pszCurrentKeyName,DWORD dwVal,BOOL fErase);
BOOL GetCloneData(HGLOBAL hClone,UINT uDataIndex,DWORD *pdwData);
UINT DeleteSettings(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName);

/*******************************************************************

	NAME:		SaveFile

	SYNOPSIS:	Saves the active policy file

	NOTES:		Save is non-destructive; e.g. we don't wipe out the file
				and write it from scratch, because there may be stuff
				in the file that we're not aware of.  If this is a previously
				saved file, we look at the clones of users that contain
				their initial states and tip-toe through writing out
				the data.

********************************************************************/
BOOL SaveFile(CHAR * pszFilename,HWND hwndApp,HWND hwndList)
{
	HKEY hkeyMain=NULL,hkeyUser=NULL,hkeyWorkstation=NULL,hkeyRoot,hkeyInstance;
	HKEY hkeyGroup=NULL,hkeyGroupPriority=NULL;
	UINT uRet=ERROR_SUCCESS,nIndex;
	HGLOBAL hUser;
	USERDATA * pUserData;
	TABLEENTRY * pTableEntry;
	USERHDR * pUserHdrDeleted;
	CHAR szMappedName[MAXNAMELEN+1];
	HCURSOR hOldCursor;
	OFSTRUCT of;
	HFILE hFile;

	// RegLoadKey returns totally coarse error codes, and will not
	// return any error if the file is on a read-only share on the network,
	// so open the file normally first to try to catch errors
	if ((hFile=OpenFile(pszFilename,&of,OF_READWRITE)) == HFILE_ERROR) {
		DisplayStandardError(hwndApp,pszFilename,IDS_ErrREGERR_SAVEKEY1,
			of.nErrCode);
		return FALSE;
	}
	_lclose(hFile);

	if ((uRet = MyRegLoadKey(HKEY_LOCAL_MACHINE,szTMPDATA,pszFilename))
		!= ERROR_SUCCESS) {
		CHAR szFmt[REGBUFLEN],szMsg[REGBUFLEN+MAX_PATH+1];
		LoadSz(IDS_ErrREGERR_LOADKEY,szFmt,sizeof(szFmt));
		wsprintf(szMsg,szFmt,pszFilename,uRet);
		MsgBoxSz(hwndApp,szMsg,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	// write the information to the local registry, then use RegSaveKey to
	// make it into a hive file.
	if ( (RegCreateKey(HKEY_LOCAL_MACHINE,szTMPDATA,&hkeyMain) !=
		ERROR_SUCCESS) ||
		(RegCreateKey(hkeyMain,szUSERS,&hkeyUser) != ERROR_SUCCESS) ||
		(RegCreateKey(hkeyMain,szWORKSTATIONS,&hkeyWorkstation)
			!= ERROR_SUCCESS) ||
		(RegCreateKey(hkeyMain,szUSERGROUPS,&hkeyGroup) != ERROR_SUCCESS) ||
		(RegCreateKey(hkeyMain,szUSERGROUPDATA,&hkeyGroupPriority) != ERROR_SUCCESS)) {

			if (hkeyWorkstation) RegCloseKey(hkeyWorkstation);
			if (hkeyUser) RegCloseKey(hkeyUser);
			if (hkeyMain) RegCloseKey(hkeyMain);
			if (hkeyGroup) RegCloseKey(hkeyGroup);
			if (hkeyGroupPriority) RegCloseKey(hkeyGroupPriority);

			MsgBox(hwndApp,IDS_ErrREGERR_CANTSAVE,MB_ICONEXCLAMATION,MB_OK);
			
			return FALSE;
		}

	hOldCursor=SetCursor(LoadCursor(NULL,IDC_WAIT));

	for (nIndex = 0;nIndex < (UINT) ListView_GetItemCount(hwndList) &&
		(uRet == ERROR_SUCCESS);nIndex++) {
                if (hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,nIndex))) {

			if (!(pUserData = (USERDATA *) GlobalLock(hUser))) {
				SetCursor(hOldCursor);
				MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
				uRet = ERROR_NOT_ENOUGH_MEMORY;
				break;
			}

			if (pUserData->hdr.dwType & UT_USER) {
				pTableEntry = gClassList.pUserCategoryList;
				hkeyRoot = (pUserData->hdr.dwType & UF_GROUP ? hkeyGroup :
					hkeyUser);
			} else {
				pTableEntry = gClassList.pMachineCategoryList;
				hkeyRoot = hkeyWorkstation;
			}

			// create a key with user/machine name
			MapUserName(pUserData->hdr.szName,szMappedName);
			if ((uRet=RegCreateKey(hkeyRoot,szMappedName,
				&hkeyInstance)) != ERROR_SUCCESS)
				break;

			// build a tree of information to be merged under user/machine
			// name
			uRet=SaveUserData(pUserData,pTableEntry,hkeyInstance,NULL);
			GlobalUnlock(hUser);

			// create a clone for this user with last saved state
			CloneUser(hUser); 

			RegCloseKey(hkeyInstance);
		}
	}

#ifdef INCL_GROUP_SUPPORT
	SaveGroupPriorityList(hkeyGroupPriority);
#endif

	// delete any users that have been marked as deleted
	nIndex=0;
	while (pUserHdrDeleted = GetDeletedUser(nIndex)) {
		HKEY hkeyDelRoot=NULL;

		switch (pUserHdrDeleted->dwType) {
			case UT_USER:
				hkeyDelRoot = hkeyUser;
				break;

			case UT_MACHINE:
				hkeyDelRoot = hkeyWorkstation;
				break;
#ifdef INCL_GROUP_SUPPORT
			case UT_USER | UF_GROUP:
				hkeyDelRoot = hkeyGroup;
				break;
#endif
			default:
				continue;	// shouldn't happen, but just in case
		}

		// map the user name to map "default user" to ".default", etc.
		MapUserName(pUserHdrDeleted->szName,szMappedName);

		MyRegDeleteKey(hkeyDelRoot,szMappedName);
		nIndex++;
	}
	ClearDeletedUserList();

	RegCloseKey(hkeyUser);
	RegCloseKey(hkeyWorkstation);
	RegCloseKey(hkeyMain);
	RegCloseKey(hkeyGroup);
	RegCloseKey(hkeyGroupPriority);
	MyRegUnLoadKey(HKEY_LOCAL_MACHINE,szTMPDATA);
	RegFlushKey(HKEY_LOCAL_MACHINE);
	SetCursor(hOldCursor);
	SetFileAttributes(pszFilename,FILE_ATTRIBUTE_ARCHIVE);

	if (uRet != ERROR_SUCCESS) {
		if (uRet == ERROR_NOT_ENOUGH_MEMORY) {
			MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		} else {
			CHAR szFmt[REGBUFLEN],szMsg[REGBUFLEN+MAX_PATH+1];
			LoadSz(IDS_ErrREGERR_SAVEKEY,szFmt,sizeof(szFmt));
			wsprintf(szMsg,szFmt,pszFilename,uRet);
			MsgBoxSz(hwndApp,szMsg,MB_ICONEXCLAMATION,MB_OK);
		}
	}

	return (uRet == ERROR_SUCCESS);
}

/*******************************************************************

	NAME:		SaveToRegistry

	SYNOPSIS:	Writes loaded information to the registry

********************************************************************/
BOOL SaveToRegistry(HWND hwndApp,HWND hwndList)
{
	HKEY hkeyUser=NULL,hkeyWorkstation=NULL,hkeyRoot;
	UINT uRet = ERROR_SUCCESS,nIndex;
	HGLOBAL hUser;
	USERDATA * pUserData=NULL;
	TABLEENTRY * pTableEntry;
	HCURSOR hOldCursor;

        if ((RegOpenKeyEx(hkeyVirtHCU,NULL,0,KEY_ALL_ACCESS,&hkeyUser) != ERROR_SUCCESS) ||
                (RegOpenKeyEx(hkeyVirtHLM,NULL,0,KEY_ALL_ACCESS,&hkeyWorkstation) != ERROR_SUCCESS)) {
		MsgBox(hwndApp,IDS_ErrCANTOPENREGISTRY,MB_ICONEXCLAMATION,MB_OK);
		if (hkeyUser) RegCloseKey(hkeyUser);
		if (hkeyWorkstation) RegCloseKey(hkeyWorkstation);
		return FALSE;
	}

	hOldCursor=SetCursor(LoadCursor(NULL,IDC_WAIT));
	for (nIndex = 0;nIndex < (UINT) ListView_GetItemCount(hwndList)
		&& (uRet == ERROR_SUCCESS);nIndex++) {
                if (hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,nIndex))) {

			if (!(pUserData = (USERDATA *) GlobalLock(hUser))) {
				SetCursor(hOldCursor);
				MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
				uRet = ERROR_NOT_ENOUGH_MEMORY;
				break;
			}

			if (pUserData->hdr.dwType & UT_USER) {
				pTableEntry = gClassList.pUserCategoryList;
				hkeyRoot = hkeyUser;
			} else {
				pTableEntry = gClassList.pMachineCategoryList;
				hkeyRoot = hkeyWorkstation;
			}

			// build a tree of information to be merged under user/machine
			// name
			uRet=SaveUserData(pUserData,pTableEntry,hkeyRoot,NULL);
			GlobalUnlock(hUser);
		}
	}

	RegCloseKey(hkeyUser);
	RegCloseKey(hkeyWorkstation);
	SetCursor(hOldCursor);

	if (uRet != ERROR_SUCCESS) {
		if (uRet == ERROR_NOT_ENOUGH_MEMORY) {
			MsgBox(hwndApp,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		} else {
			CHAR szMsg[REGBUFLEN+1];
			wsprintf(szMsg,"%d",uRet);
			MsgBoxParam(hwndApp,IDS_ErrREGERR_SAVE,szMsg,MB_ICONEXCLAMATION,MB_OK);
		}
	}

	return (uRet == ERROR_SUCCESS);
}

/*******************************************************************

	NAME:		SaveUserData

	SYNOPSIS:	Saves one user to file

********************************************************************/
UINT SaveUserData(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName)
{
	UINT uRet=ERROR_SUCCESS;

	while (pTableEntry && (uRet == ERROR_SUCCESS)) {

		uRet = SaveOneEntry(pUserData,pTableEntry,hkeyRoot,
			pszCurrentKeyName,FALSE);

		pTableEntry = pTableEntry->pNext;
	}

	return uRet;
}

/*******************************************************************

	NAME:		SaveOneEntry

	SYNOPSIS:	Saves one entry (category, policy, or part) to
				file, calls SaveUserData for child entries

********************************************************************/
UINT SaveOneEntry(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName,BOOL fErase)
{
	UINT uRet;

#if 0
	wsprintf(szDebugOut,"Saving... %s\r\n",GETNAMEPTR(pTableEntry));
	OutputDebugString(szDebugOut);
#endif

	// if there is a key name for this entry, it becomes the "current"
	// key name-- it will be overridden if child entries specify their
	// own keys, otherwise it's the default key for children to use
	if (pTableEntry->uOffsetKeyName) {
		pszCurrentKeyName = GETKEYNAMEPTR(pTableEntry);
	}

	if ((pTableEntry->dwType == ETYPE_CATEGORY ||
		pTableEntry->dwType == ETYPE_ROOT) && (pTableEntry->pChild)) {

	// if entry is a category, recusively process sub-categories and policies

		if ((uRet=SaveUserData(pUserData,pTableEntry->pChild,
			hkeyRoot,pszCurrentKeyName)) != ERROR_SUCCESS) {
			return uRet;
		}
	}	else if (pTableEntry->dwType == ETYPE_POLICY) {

		if ((uRet = SavePolicy(pUserData,pTableEntry,hkeyRoot,
			pszCurrentKeyName)) != ERROR_SUCCESS) {
			return uRet;
		}

	} else if ( (pTableEntry->dwType & ETYPE_MASK) == ETYPE_SETTING
		&& !(pTableEntry->dwType & STYPE_TEXT)) {

		if ((uRet = SaveSettings(pUserData,pTableEntry,hkeyRoot,
			pszCurrentKeyName,fErase)) != ERROR_SUCCESS) {
			return uRet;
		}
	}

	return ERROR_SUCCESS;
}

/*******************************************************************

	NAME:		SavePolicy

	SYNOPSIS:	Saves policy to file

********************************************************************/
UINT SavePolicy(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName)
{
	UINT uState = pUserData->SettingData[((POLICY *)
		pTableEntry)->uDataIndex].uData;
	DWORD dwData;
	UINT uRet=ERROR_SUCCESS;
	CHAR * pszValueName = NULL;
	UINT uCloneState;

	// get the name of the value to write, if any
	if (((POLICY *) pTableEntry)->uOffsetValueName) 
		pszValueName = GETVALUENAMEPTR(((POLICY *) pTableEntry));
	// if this policy is "on" or "off" write it to registry
	// (not if it's "indeterminate")
	if (uState == IMG_CHECKED || uState == IMG_UNCHECKED) {

		// write the value associated with the policy, if it has one
		if (pszValueName) {

			dwData = (uState == IMG_CHECKED ? 1 : 0);

			// write this key & value
			if (dwData && ((POLICY *) pTableEntry)->uOffsetValue_On) {

				uRet= WriteCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
					(STATEVALUE *) ((CHAR *) pTableEntry + ((POLICY *)
					pTableEntry)->uOffsetValue_On),FALSE);
			} else if (!dwData && ((POLICY *) pTableEntry)->uOffsetValue_Off) {
				uRet= WriteCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
					(STATEVALUE *) ((CHAR *) pTableEntry + ((POLICY *)
					pTableEntry)->uOffsetValue_Off),FALSE);
			}
			else uRet=WriteStandardValue(hkeyRoot,pszCurrentKeyName,pszValueName,
				pTableEntry,dwData,FALSE,FALSE);
			if (uRet != ERROR_SUCCESS)
				return uRet;
		}

		// process settings underneath this policy (if any) if
		// policy is turned on.
		if (pTableEntry->pChild) {
			if (uState == IMG_CHECKED) {
				if ((uRet=SaveUserData(pUserData,pTableEntry->pChild,
					hkeyRoot,pszCurrentKeyName))
					!=ERROR_SUCCESS)
					return uRet;
			} else {
				DeleteSettings(pUserData,pTableEntry->pChild,hkeyRoot,
					pszCurrentKeyName);
			}
		}
		
		// write out each key & value in the action list, if an action
		// list is specified
		if (GetCloneData(pUserData->hClone,((POLICY *)pTableEntry)->uDataIndex,
			&uCloneState)) {
			// if the clone state (initial state) is different from the
			// current state, erase action list for the clone's state
			if (uCloneState != uState) {
				uRet=ProcessPolicyActionLists(hkeyRoot,(POLICY *) pTableEntry,
					pszCurrentKeyName,uCloneState,TRUE);
				if (uRet != ERROR_SUCCESS)
					return uRet;
			}
		}
		uRet=ProcessPolicyActionLists(hkeyRoot,(POLICY *) pTableEntry,
			pszCurrentKeyName,uState,FALSE);
		if (uRet != ERROR_SUCCESS)
			return uRet;
		
	} else {
		// policy is "indeterminate"... which means do no delta.
		// However, since we save non-destructively, we need to delete
		// the value for this key if it is currently written in the file.
		// See if we have a clone for this user (clone will exist if there
		// is already a saved file that contains this user, clone will
		// reflect initial state).  If the initial state was "checked"
		// or "unchecked", then erase the value from the file so that
		// the saved state is "nothing".
		TABLEENTRY * pTableEntryChild = pTableEntry->pChild;

		if (pszValueName) {
			CHAR szNewValueName[MAX_PATH+1];
			DeleteRegistryValue(hkeyRoot,pszCurrentKeyName,pszValueName);
			// delete the "delete" mark for this value, if there is one
			PrependValueName(pszValueName,VF_DELETE,szNewValueName,
				sizeof(szNewValueName));
			DeleteRegistryValue(hkeyRoot,pszCurrentKeyName,szNewValueName);
		}

		if (GetCloneData(pUserData->hClone,((POLICY *)pTableEntry)->uDataIndex,
			&uCloneState)) {
			// if the clone state (initial state) is different from the
			// current state, erase action list for the clone's state
			if (uCloneState != uState) {
				uRet=ProcessPolicyActionLists(hkeyRoot,(POLICY *) pTableEntry,
					pszCurrentKeyName,uCloneState,TRUE);
				if (uRet != ERROR_SUCCESS)
					return uRet;
			}
		}

		// erase values for any settings contained in this policy
		while (pTableEntryChild && (uRet == ERROR_SUCCESS)) {
			uRet = SaveOneEntry(pUserData,pTableEntryChild,hkeyRoot,
				pszCurrentKeyName,TRUE);

			pTableEntryChild = pTableEntryChild->pNext;
		}
	}

	return uRet;
}

/*******************************************************************

	NAME:		SaveSettings

	SYNOPSIS:	Saves settings entry to a file

	NOTES:		if fErase is TRUE, settings and action lists are deleted from file
********************************************************************/
UINT SaveSettings(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName,BOOL fErase)
{
	UINT uRet = ERROR_SUCCESS,uOffset;
	CHAR * pszValueName = NULL,* pszValue;
	DWORD dwData,dwCloneData;
	CHAR * pObjectData = GETOBJECTDATAPTR(((SETTINGS *)pTableEntry));
	CHAR szNewValueName[MAX_PATH+1];

	// nothing to save for static text items
	if ((((SETTINGS *) pTableEntry)->dwType & STYPE_MASK) == STYPE_TEXT)
		return ERROR_SUCCESS;

	if (((SETTINGS *) pTableEntry)->uOffsetValueName) {
		pszValueName = GETVALUENAMEPTR(((SETTINGS *) pTableEntry));
	} else {
		return ERROR_NOT_ENOUGH_MEMORY;	// should never happen, but bag out just in case
	}
	switch (pTableEntry->dwType & STYPE_MASK) {

		case STYPE_EDITTEXT:
		case STYPE_COMBOBOX:

			uOffset = pUserData->SettingData[((SETTINGS *)
				pTableEntry)->uDataIndex].uOffsetData;

			// add prefixes if appropriate
			PrependValueName(pszValueName,((SETTINGS *) pTableEntry)->dwFlags,
				szNewValueName,sizeof(szNewValueName));
			if (!fErase) {
				if (uOffset) {
					pszValue = ((STRDATA *) ((CHAR *) pUserData + uOffset))
					->szData;
				} else {
					pszValue = (CHAR *) szNull;
				}

				uRet=WriteRegistryStringValue(hkeyRoot,pszCurrentKeyName,
					szNewValueName,pszValue,
                                        (((SETTINGS *) pTableEntry)->dwFlags & DF_EXPANDABLETEXT) ?
                                        TRUE : FALSE);

				if ((dwAppState & AS_POLICYFILE) && !(dwCmdLineFlags & CLF_DIALOGMODE)
					&& !(((SETTINGS *) pTableEntry)->dwFlags & VF_DELETE)) {
					// delete the "delete" mark for this value, if there is one
					PrependValueName(pszValueName,VF_DELETE,szNewValueName,
						sizeof(szNewValueName));
					DeleteRegistryValue(hkeyRoot,pszCurrentKeyName,szNewValueName);
				}

			} else {
				DeleteRegistryValue(hkeyRoot,pszCurrentKeyName,szNewValueName);
				uRet = ERROR_SUCCESS;
				if (dwAppState & AS_POLICYFILE &&
					!(((SETTINGS *) pTableEntry)->dwFlags & VF_DELETE)) {
					// delete the "delete" mark for this value, if there is one
					PrependValueName(pszValueName,VF_DELETE,szNewValueName,
						sizeof(szNewValueName));
					DeleteRegistryValue(hkeyRoot,pszCurrentKeyName,szNewValueName);
				}
			}

			break;

		case STYPE_CHECKBOX:

			dwData = pUserData->SettingData[((SETTINGS *)
				pTableEntry)->uDataIndex].uData;

			if (dwData && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_On) {
				uRet= WriteCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
						(STATEVALUE *) ((CHAR *) pTableEntry + ((CHECKBOXINFO *)
						pObjectData)->uOffsetValue_On),fErase);
 			} else if (!dwData && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_Off) {
				uRet= WriteCustomValue(hkeyRoot,pszCurrentKeyName,pszValueName,
					(STATEVALUE *) ((CHAR *) pTableEntry + ((CHECKBOXINFO *)
					pObjectData)->uOffsetValue_Off),fErase);
			}
			else uRet=WriteStandardValue(hkeyRoot,pszCurrentKeyName,pszValueName,
				pTableEntry,dwData,fErase,FALSE);

			if (uRet == ERROR_SUCCESS) {

				// erase old actionlists if changed
				if (GetCloneData(pUserData->hClone,((SETTINGS *)pTableEntry)->uDataIndex,
					&dwCloneData)) {
					ProcessCheckboxActionLists(hkeyRoot,pTableEntry,
						pszCurrentKeyName,dwCloneData,TRUE);

				}

				ProcessCheckboxActionLists(hkeyRoot,pTableEntry,
					pszCurrentKeyName,dwData,fErase);
			}

			break;				

		case STYPE_NUMERIC:

			dwData = pUserData->SettingData[((SETTINGS *)
				pTableEntry)->uDataIndex].uData;

			uRet=WriteStandardValue(hkeyRoot,pszCurrentKeyName,pszValueName,
				pTableEntry,dwData,fErase,TRUE);
			break;

		case STYPE_DROPDOWNLIST:

			dwData = pUserData->SettingData[((SETTINGS *)
				pTableEntry)->uDataIndex].uData;

			if (GetCloneData(pUserData->hClone,((SETTINGS *)pTableEntry)->uDataIndex,
				&dwCloneData)) {
				// erase old value if changed
				if (dwData != dwCloneData && dwCloneData != NO_DATA_INDEX)
					uRet=WriteDropdownValue(pTableEntry,hkeyRoot,pszCurrentKeyName,
						pszValueName,dwCloneData,TRUE);
				if (uRet != ERROR_SUCCESS)
					return uRet;
			}

			// write new value
			if (dwData == NO_DATA_INDEX) {
				if (dwAppState & AS_POLICYFILE &&
					!(((SETTINGS *) pTableEntry)->dwFlags & VF_DELETE)) {
					// delete the "delete" mark for this value, if there is one
					PrependValueName(pszValueName,VF_DELETE,szNewValueName,
						sizeof(szNewValueName));
					DeleteRegistryValue(hkeyRoot,pszCurrentKeyName,szNewValueName);
				}
				uRet = ERROR_SUCCESS;
			}
			else
				uRet=WriteDropdownValue(pTableEntry,hkeyRoot,pszCurrentKeyName,
					pszValueName,dwData,fErase);
				
			break;

		case STYPE_LISTBOX:

			uRet=SaveListboxData(pUserData,pTableEntry,hkeyRoot,pszCurrentKeyName,
				fErase,FALSE);

			break;

	}

#ifdef DEBUG
	if (uRet != ERROR_SUCCESS) {
		wsprintf(szDebugOut,"ADMINCFG: registry write returned %d\r\n",uRet);
		OutputDebugString(szDebugOut);
	}
#endif

	return uRet;
}

UINT ProcessPolicyActionLists(HKEY hkeyRoot,POLICY * pPolicy,
	CHAR * pszCurrentKeyName,UINT uState,BOOL fErase)
{
	if ((uState == IMG_CHECKED) && (pPolicy->uOffsetActionList_On)) {
		return WriteActionList(hkeyRoot,(ACTIONLIST *)
			( (CHAR *) pPolicy + pPolicy->uOffsetActionList_On),pszCurrentKeyName,
			fErase);
	} else if ((uState == IMG_UNCHECKED) && pPolicy->uOffsetActionList_Off) {
		return WriteActionList(hkeyRoot,(ACTIONLIST *)
			( (CHAR *) pPolicy + pPolicy->uOffsetActionList_Off),
			pszCurrentKeyName,fErase);
	}

	return ERROR_SUCCESS;
}

UINT ProcessCheckboxActionLists(HKEY hkeyRoot,TABLEENTRY * pTableEntry,
	CHAR * pszCurrentKeyName,DWORD dwData,BOOL fErase)
{
	CHAR * pObjectData = GETOBJECTDATAPTR(((SETTINGS *)pTableEntry));
	UINT uOffsetActionList_On,uOffsetActionList_Off,uRet=ERROR_SUCCESS;

	uOffsetActionList_On = ((CHECKBOXINFO *) pObjectData)
		->uOffsetActionList_On;
	uOffsetActionList_Off = ((CHECKBOXINFO *) pObjectData)
		->uOffsetActionList_Off;

	if (dwData && uOffsetActionList_On) {
		uRet = WriteActionList(hkeyRoot,(ACTIONLIST *)
			((CHAR *) pTableEntry + uOffsetActionList_On),
			pszCurrentKeyName,fErase);
	} else if (!dwData && uOffsetActionList_Off) {
		uRet = WriteActionList(hkeyRoot,(ACTIONLIST *)
			((CHAR *) pTableEntry + uOffsetActionList_Off),
			pszCurrentKeyName,fErase);
	}

	return uRet;
}

UINT WriteCustomValue_W(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	CHAR * pszValue,DWORD dwValue,DWORD dwFlags,BOOL fErase)
{
	UINT uRet=ERROR_SUCCESS;
	CHAR szNewValueName[MAX_PATH+1];

	// first: "clean house" by deleting both the specified value name,
	// and the value name with the delete (**del.) prefix (if writing to policy
	// file).  Then write the appropriate version back out if need be
	if (dwAppState & AS_POLICYFILE) {
		// delete the "delete" mark for this value, if there is one
		PrependValueName(pszValueName,VF_DELETE,szNewValueName,
			sizeof(szNewValueName));
		DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);
	}

	// add prefixes if appropriate
	PrependValueName(pszValueName,(dwFlags & ~VF_DELETE),szNewValueName,
		sizeof(szNewValueName));
	DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);

	if (fErase) {
		// just need to delete value, done above

		uRet = ERROR_SUCCESS;
	} else if (dwFlags & VF_ISNUMERIC) {
		uRet=WriteRegistryDWordValue(hkeyRoot,pszKeyName,
			szNewValueName,dwValue);
	} else if (dwFlags & VF_DELETE) {
		// need to delete value (done above) and mark as deleted if writing
		// to policy file

		uRet = ERROR_SUCCESS;
		if ((dwAppState & AS_POLICYFILE) && !(dwCmdLineFlags & CLF_DIALOGMODE)) {
			PrependValueName(pszValueName,VF_DELETE,szNewValueName,
				sizeof(szNewValueName));
			uRet=WriteRegistryStringValue(hkeyRoot,pszKeyName,
				szNewValueName,(CHAR *) szNOVALUE, FALSE);
		}

	} else {
		uRet = WriteRegistryStringValue(hkeyRoot,pszKeyName,
			szNewValueName,pszValue,
                        (dwFlags & DF_EXPANDABLETEXT) ? TRUE : FALSE);
	}

	return uRet;
}

UINT WriteCustomValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	STATEVALUE * pStateValue,BOOL fErase)
{
	// pull info out of STATEVALUE struct and call worker function 
	return WriteCustomValue_W(hkeyRoot,pszKeyName,pszValueName,
		pStateValue->szValue,pStateValue->dwValue,pStateValue->dwFlags,
		fErase);
}

// writes a numeric value given root key, key name and value name.  The specified
// value is removed if fErase is TRUE.  Normally if the data (dwData) is zero
// the value will be deleted, but if fWriteZero is TRUE then the value will
// be written as zero if the data is zero.
UINT WriteStandardValue(HKEY hkeyRoot,CHAR * pszKeyName,CHAR * pszValueName,
	TABLEENTRY * pTableEntry,DWORD dwData,BOOL fErase,BOOL fWriteZero)
{
	UINT uRet=ERROR_SUCCESS;
	CHAR szNewValueName[MAX_PATH+1];

	// first: "clean house" by deleting both the specified value name,
	// and the value name with the delete (**del.) prefix (if writing to policy
	// file).  Then write the appropriate version back out if need be
	if (dwAppState & AS_POLICYFILE) {
		// delete the "delete" mark for this value, if there is one
		PrependValueName(pszValueName,VF_DELETE,szNewValueName,
			sizeof(szNewValueName));
		DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);
	}

	DeleteRegistryValue(hkeyRoot,pszKeyName,pszValueName);

	if (fErase) {
		// just need to delete value, done above
		uRet = ERROR_SUCCESS;
	} else if ( ((SETTINGS *) pTableEntry)->dwFlags & DF_TXTCONVERT) {
		// if specified, save value as text
		CHAR szNum[11];
		wsprintf(szNum,"%lu",dwData);
		PrependValueName(pszValueName,((SETTINGS *)pTableEntry)->dwFlags,
			szNewValueName,sizeof(szNewValueName));
		uRet = WriteRegistryStringValue(hkeyRoot,pszKeyName,
			szNewValueName,szNum, FALSE);
	} else {
		if (!dwData && !fWriteZero) {
			// if value is 0, delete the value (done above), and mark
			// it as deleted if writing to policy file
			uRet = ERROR_SUCCESS;
			
			if ((dwAppState & AS_POLICYFILE) && !(dwCmdLineFlags & CLF_DIALOGMODE)) {
				PrependValueName(pszValueName,VF_DELETE,szNewValueName,
					sizeof(szNewValueName));
				uRet=WriteRegistryStringValue(hkeyRoot,pszKeyName,
					szNewValueName,(CHAR *) szNOVALUE, FALSE);
			}

		} else {
			// save value as binary
			PrependValueName(pszValueName,((SETTINGS *)pTableEntry)->dwFlags,
				szNewValueName,sizeof(szNewValueName));
			uRet=WriteRegistryDWordValue(hkeyRoot,pszKeyName,
				szNewValueName,dwData);
		}
	}

	return uRet;
}

/*******************************************************************

	NAME:		WriteDropdownValue

	SYNOPSIS:	Writes (or deletes) the value corresponding to the
				nValue selection from a drop-down list, and writes
				(or deletes) the items in associated action list
				if there is one.

	NOTES:		if fErase is TRUE, deletes value & action list.

********************************************************************/
UINT WriteDropdownValue(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName,CHAR * pszValueName,UINT nValue,BOOL fErase)
{
	DROPDOWNINFO * pddi = (DROPDOWNINFO *)
		GETOBJECTDATAPTR( ((SETTINGS *) pTableEntry));
	UINT nIndex = 0,uRet=ERROR_SUCCESS;

	// walk the chain of DROPDOWNINFO structs to find the entry that
	// we want to write.  (for value n, find the nth struct)
	while (nIndex < nValue) {
		// selected val is higher than # of structs in chain,
		// should never happen but check just in case...
		if (!pddi->uOffsetNextDropdowninfo) {
			return ERROR_NOT_ENOUGH_MEMORY;
		}
		pddi = (DROPDOWNINFO *)
			((CHAR  *) pTableEntry + pddi->uOffsetNextDropdowninfo);
		nIndex++;
	}

	uRet=WriteCustomValue_W(hkeyRoot,pszCurrentKeyName,pszValueName,
		(CHAR *) pTableEntry+pddi->uOffsetValue,pddi->dwValue,pddi->dwFlags,
		fErase);
					
	if (uRet == ERROR_SUCCESS && pddi->uOffsetActionList) {
		uRet=WriteActionList(hkeyRoot,(ACTIONLIST *) ( (CHAR *)
			pTableEntry + pddi->uOffsetActionList),pszCurrentKeyName,
			fErase);
	}

	return uRet;
}

/*******************************************************************

	NAME:		WriteActionList

	SYNOPSIS:	Writes (or deletes) a list of key name\value name\value
				triplets as specified in an ACTIONLIST struct

	NOTES:		if fErase is TRUE, deletes every value in list

********************************************************************/
UINT WriteActionList(HKEY hkeyRoot,ACTIONLIST * pActionList,
	CHAR *pszCurrentKeyName,BOOL fErase)
{
	UINT nCount;
	CHAR * pszValueName;
	CHAR * pszValue=NULL;
	UINT uRet;

	ACTION * pAction = pActionList->Action;

	for (nCount=0;nCount < pActionList->nActionItems; nCount++) {
		// not every action in the list has to have a key name.  But if one
		// is specified, use it and it becomes the current key name for the
		// list until we encounter another one.
		if (pAction->uOffsetKeyName) {
			pszCurrentKeyName = (CHAR *) pActionList + pAction->uOffsetKeyName;
		}

		// every action must have a value name, enforced at parse time
		pszValueName = (CHAR *) pActionList + pAction->uOffsetValueName;

		// string values have a string elsewhere in buffer
		if (!pAction->dwFlags && pAction->uOffsetValue) {
			pszValue = (CHAR *) pActionList + pAction->uOffsetValue;
		} 

		// write the value in list
		uRet=WriteCustomValue_W(hkeyRoot,pszCurrentKeyName,pszValueName,
			pszValue,pAction->dwValue,pAction->dwFlags,fErase);

		if (uRet != ERROR_SUCCESS) return uRet;

		pAction = (ACTION*) ((CHAR *) pActionList + pAction->uOffsetNextAction);
	}

	return ERROR_SUCCESS;
}

/*******************************************************************

	NAME:		GetCloneData

	SYNOPSIS:	Retrieves the data for a specified setting index
				from a user's clone (initial state) if one exists.

	NOTES:		returns TRUE if successful, FALSE if no clone exists

********************************************************************/
BOOL GetCloneData(HGLOBAL hClone,UINT uDataIndex,DWORD *pdwData)
{
	USERDATA * pUserDataClone;
	if (!hClone) return FALSE;

	pUserDataClone = (USERDATA *) GlobalLock(hClone);	
	if (!pUserDataClone) return FALSE;
	
	*pdwData = pUserDataClone->SettingData[uDataIndex].uData;

	GlobalUnlock(hClone);
	return TRUE;
}


/*******************************************************************

	NAME:		DeleteSettings

	SYNOPSIS:	Deletes all settings for a policy; called if the policy
				is turned off

	NOTES:		In direct-registry mode, deletes the value(s).  When
				operating on a policy file, marks the values to be deleted.

				DeleteSettings calls worker function DeleteSetting so
				that hierarchy of key names works correctly (pszCurrentKeyName
				is preserved in DeleteSettings, but individual settings
				may override it in DeleteSetting)

********************************************************************/
UINT DeleteSettings(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName)
{
	UINT uRet=ERROR_SUCCESS;
	UINT DeleteSetting(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
		CHAR * pszCurrentKeyName);

	while (pTableEntry && (uRet == ERROR_SUCCESS)) {

		uRet = DeleteSetting(pUserData,pTableEntry,hkeyRoot,pszCurrentKeyName);
		pTableEntry = pTableEntry->pNext;
	}

	return uRet;
}

UINT DeleteSetting(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName)
{
	CHAR * pszValueName=NULL;
	DWORD dwSettingType;
	UINT uRet;

	// if this setting has its own key name, use it to override parent's key name
	if (pTableEntry->uOffsetKeyName) {
		pszCurrentKeyName = GETKEYNAMEPTR(pTableEntry);
	}

	dwSettingType = pTableEntry->dwType & STYPE_MASK;

	// special handling for listboxes, drop-down listboxes and static text
	// controls

	switch (dwSettingType) {
		case STYPE_LISTBOX:
			// for listboxes, call SaveListboxData to delete (fErase param set to TRUE)
			return SaveListboxData(pUserData,pTableEntry,hkeyRoot,pszCurrentKeyName,
				TRUE,TRUE);
			break;

		case STYPE_DROPDOWNLIST:

			{
			DWORD dwData;

			dwData = pUserData->SettingData[((SETTINGS *)
				pTableEntry)->uDataIndex].uData;

			// no data set, nothing to do
			if (dwData == NO_DATA_INDEX)
				break;

			if (((SETTINGS *) pTableEntry)->uOffsetValueName) {
				pszValueName = GETVALUENAMEPTR(((SETTINGS *) pTableEntry));
			} else {
				return ERROR_NOT_ENOUGH_MEMORY;	// should never happen, but bag out just in case
			}

			// erase the dropdown value (and any associated action lists)
			uRet = WriteDropdownValue(pTableEntry,hkeyRoot,pszCurrentKeyName,
				pszValueName,dwData,TRUE);
			if (uRet != ERROR_SUCCESS)
				return uRet;
			// fall through and do processing below
			}
			break;

		case STYPE_TEXT:

			return ERROR_SUCCESS;	// static text w/no reg value, nothing to do
			break;

	}
	
	// otherwise delete the value

	if (((SETTINGS *) pTableEntry)->uOffsetValueName) {
		pszValueName = GETVALUENAMEPTR(((SETTINGS *) pTableEntry));
	} else {
		return ERROR_NOT_ENOUGH_MEMORY;	// should never happen, but bag out just in case
	}

	// delete the value 
	DeleteRegistryValue(hkeyRoot,pszCurrentKeyName,pszValueName);
	
	if ((dwAppState & AS_POLICYFILE) && !(dwCmdLineFlags & CLF_DIALOGMODE)) {
		// if writing to a policy file, also mark it as deleted.
		// WriteCustomValue_W will prepend "**del." to the value name
		WriteCustomValue_W(hkeyRoot,pszCurrentKeyName,pszValueName,NULL,0,
			VF_DELETE | ((SETTINGS *) pTableEntry)->dwFlags,FALSE);
	}

	return ERROR_SUCCESS;
}

UINT SaveListboxData(USERDATA * pUserData,TABLEENTRY * pTableEntry,HKEY hkeyRoot,
	CHAR * pszCurrentKeyName,BOOL fErase,BOOL fMarkDeleted)
{
	UINT uOffset,uRet,nItem=1;
	HKEY hKey;
	CHAR * pszData,* pszName;
	CHAR szValueName[MAX_PATH+1];
	DWORD cbValueName;
	LISTBOXINFO * pListboxInfo = (LISTBOXINFO *)
		GETOBJECTDATAPTR(((SETTINGS *) pTableEntry));

	if ((uRet=RegCreateKey(hkeyRoot,pszCurrentKeyName,&hKey)) != ERROR_SUCCESS)
		return uRet;
	uOffset = pUserData->SettingData[((SETTINGS *)
		pTableEntry)->uDataIndex].uOffsetData;

	// erase all values for this key, first off
	while (TRUE) {
		cbValueName=sizeof(szValueName);
		uRet=RegEnumValue(hKey,0,szValueName,&cbValueName,NULL,
			NULL,NULL,NULL);
		// stop if we're out of items
		if (uRet != ERROR_SUCCESS && uRet != ERROR_MORE_DATA)
			break;
		RegDeleteValue(hKey,szValueName);
	}
	uRet=ERROR_SUCCESS;

	if (!fErase || fMarkDeleted) {
		// if in policy file mode, write a control code that will cause
		// all values under that key to be deleted when client downloads from the file.
		// Don't do this if listbox is additive (DF_ADDITIVE), in that case whatever
		// we write here will be dumped in along with existing values
		if ((dwAppState & AS_POLICYFILE) && !(dwCmdLineFlags & CLF_DIALOGMODE) &&
			!(((SETTINGS *) pTableEntry)->dwFlags & DF_ADDITIVE))
		uRet=WriteRegistryStringValue(hkeyRoot,pszCurrentKeyName,(CHAR *) szDELVALS,
			(CHAR *) szNOVALUE, FALSE);
	}

	if (!fErase) {
		if (uOffset) {
			pszData = ((STRDATA *) ((CHAR *) pUserData + uOffset))->szData;

			while (*pszData && (uRet == ERROR_SUCCESS)) {
				UINT nLen = lstrlen(pszData)+1;

				if (((SETTINGS *)pTableEntry)->dwFlags & DF_EXPLICITVALNAME) {
					// value name specified for each item
					pszName = pszData;	// value name
					pszData += nLen;	// now pszData points to value data
					nLen = lstrlen(pszData)+1;
				} else {
					// value name is either same as the data, or a prefix
					// with a number

					if (!pListboxInfo->uOffsetPrefix) {
						// if no prefix set, then name = data
						pszName = pszData;
					} else {
						// value name is "<prefix><n>" where n=1,2,etc.
						wsprintf(szValueName,"%s%lu",(CHAR *) pTableEntry +
							pListboxInfo->uOffsetPrefix,nItem);
						pszName = szValueName;
						nItem++;
					}
				}

				uRet=RegSetValueEx(hKey,pszName,0,REG_SZ,pszData,
					nLen);
				pszData += nLen;
			}
		}
	} 

	RegCloseKey(hKey);

	return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\remove.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"

BOOL OnRemove(HWND hwndApp,HWND hwndList)
{
	int nItem,nItemStart=-1;
	UINT nSelItems=0;
	BOOL fRet=TRUE;

	// find out how many items are selected
	while ((nItem=ListView_GetNextItem(hwndList,nItemStart,LVNI_SELECTED))
		>=0) {
		nSelItems++;		
		nItemStart = nItem;
	}

	if (!nSelItems) return FALSE;	// nothing selected 

	// display appropriate message depending on whether 1 user, 1 workstation,
	// 1 group or multiple items selected

	if (nSelItems == 1) {
		HGLOBAL hUser;
		USERDATA *pUserData;
		UINT uMsg;
		int nRet;
		
                if (!(hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,nItemStart))) ||
			!(pUserData = (USERDATA *) GlobalLock(hUser)))
			return FALSE;

		switch (pUserData->hdr.dwType) {
#ifdef INCL_GROUP_SUPPORT
			case (UT_USER | UF_GROUP):
				uMsg = IDS_QUERYREMOVE_GROUP;
				break;
#endif

			case UT_USER:
				uMsg = IDS_QUERYREMOVE_USER;
				break;

			default:
				uMsg = IDS_QUERYREMOVE_WORKSTA;
				break;
		}

		nRet=MsgBoxParam(hwndApp,uMsg,pUserData->hdr.szName,MB_ICONQUESTION,
			MB_YESNO);

		GlobalUnlock(hUser);

		if (nRet != IDYES)
			return FALSE;
	} else {
		if (MsgBox(hwndApp,IDS_QUERYREMOVE_MULTIPLE,MB_ICONQUESTION,MB_YESNO)
			!= IDYES)
			return FALSE;
	}

	// remove all selected items
	while (((nItem=ListView_GetNextItem(hwndList,-1,LVNI_SELECTED))
		>=0) && fRet) {
#ifdef INCL_GROUP_SUPPORT
		HGLOBAL hUser;
		USERDATA *pUserData;
		
                if ((hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,nItem))) &&
			(pUserData = (USERDATA *) GlobalLock(hUser))) {
			if (pUserData->hdr.dwType == (UT_USER | UF_GROUP))
				RemoveGroupPriEntry(pUserData->hdr.szName);
		 	GlobalUnlock(hUser);
		}
#endif
		fRet=RemoveUser(hwndList,nItem,TRUE);
	}

	if (fRet) {
		dwAppState |= AS_FILEDIRTY;		// file is dirty
		dwAppState &= ~AS_CANREMOVE;	// no selection in list ctrl, disable item
		EnableMenuItems(hwndApp,dwAppState);
		SetStatusItemCount(hwndList);
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\strids.h ===
#define INCL_GROUP_SUPPORT	1

#define IDM_MAIN			100
#define IDM_NEW             200
#define IDM_OPEN            201
#define IDM_SAVE            202
#define IDM_SAVEAS          203
#define IDM_CLOSE			204
#define IDM_EXIT            205
#define IDM_OPENREGISTRY	206
#define IDM_CONNECT			207
#define IDM_DISCONNECT		208

#define IDM_FILEHISTORY		210

#define IDM_ADDUSER			300
#define IDM_ADDWORKSTATION	301
#define IDM_REMOVE			302
#define IDM_PROPERTIES		303
#define IDM_COPY			304
#define IDM_PASTE			305
#define IDM_ADDGROUP		306

#define IDM_TOOLBAR			400
#define IDM_STATUSBAR		401
#define IDM_LARGEICONS		402
#define IDM_SMALLICONS		403
#define IDM_LIST   			404
#define IDM_DETAILS			405

#define IDM_TEMPLATEOPT		500
#define IDM_GROUPPRIORITY	501

#define IDM_HELPCONTENTS    600
#define IDM_HELPSEARCH      601
#define IDM_HELPHELP        602
#define IDM_ABOUT           603

#define DLG_VERFIRST        700
#define DLG_VERLAST         704

#define IDS_APPNAME			800
#define IDS_ARIAL			801
#define IDS_HELV			802
#define IDS_TITLEFORMAT		803
#define IDS_UNTITLED		804
#define IDS_LOCALREGISTRY	805
#define IDS_REGISTRYON		806

#define IDS_DATA					855
#define IDS_VIEW					856
#define IDS_COLOR					857
#define IDS_WP						858
#define IDS_INFDIR					861
#define IDS_DEF_NT_INFNAME                              862
#define IDS_DEF_INFNAME					863
#define IDS_DEF_COMMONNAME                              864
#define IDS_INF_EXT					865
#define IDS_SETTINGSFOR                                 866
#define IDS_POLICIESFOR                                 867
#define IDS_CONNECT					868
#define IDS_DISCONNECT					869
#define IDS_SAVING					870
#define IDS_LOADING					871
#define IDS_CONNECTINGTO                                872
#define IDS_LOADINGTEMPLATE                             873
#define IDS_READINGREGISTRY                             874
#define IDS_SAVINGREGISTRY                              875
#define IDS_ENTRIES					876
#define IDS_ONEENTRY                                    877
#define IDS_NOENTRIES                                   878

#define IDS_WORDTOOLONG                                 899
#define IDS_ErrOUTOFMEMORY				900
#define IDS_ErrCANTOPENREGISTRY				901
#define IDS_ErrINVALIDPOLICYFILE			902
#define IDS_ErrREGERR_CANTSAVE				903
#define IDS_ErrREGERR_LOADKEY				904
#define IDS_ErrREGERR_SAVEKEY				905
#define IDS_ErrREGERR_LOAD				906
#define IDS_ErrREGERR_SAVE				907
#define IDS_ErrCOMMANDLINE				908
#define IDS_ErrOPENTEMPLATE				909
#define IDS_ErrREGERR_LOADKEY1				910
#define IDS_ErrREGERR_SAVEKEY1				911

#define	IDS_ParseFmt_MSG_FORMAT				950
#define	IDS_ParseFmt_FOUND				951
#define IDS_ParseFmt_EXPECTED				952
#define	IDS_ParseFmt_FATAL					953

#define IDS_InfOPENFILTER1					1100
#define IDS_InfOPENFILTER2					1101
#define IDS_InfOPENTITLE					1102
#define IDS_FILEFILTER1						1103
#define IDS_FILEFILTER2						1104
#define IDS_QUERYSAVE						1105
#define IDS_OPENTITLE						1106
#define IDS_QUERYREMOVE_USER				1107
#define IDS_QUERYREMOVE_WORKSTA				1108
#define IDS_QUERYREMOVE_MULTIPLE			1109
#define IDS_USERALREADYEXISTS				1110
#define IDS_MACHINEALREADYEXISTS			1111
#define IDS_ENTRYREQUIRED					1112
#define IDS_INVALIDNUM						1113
#define IDS_QUERYSAVEREGISTRY				1114
#define IDS_NEEDCOMPUTERNAME				1115
#define IDS_CANTCONNECT						1116
#define IDS_QUERYSAVEREMOTEREGISTRY			1117
#define IDS_NEEDUSERNAME					1118
#define IDS_NEEDWORKSTANAME					1119
#define IDS_DUPLICATEUSER					1120
#define IDS_DUPLICATEWORKSTA				1121
#define IDS_CHOOSUSRDLL						1122
#define IDS_ADDBUTTON						1123
#define IDS_CANTLOADCHOOSUSR				1126
#define IDS_NOPROVIDER						1127
#define IDS_INVALIDPROVIDER					1128
#define IDS_PROVIDERERROR					1129
#define IDS_ERRORADDINGUSERS				1130
#define IDS_LOCALUSER						1131
#define IDS_LOCALCOMPUTER					1132
#define IDS_DEFAULTUSER						1133
#define IDS_DEFAULTCOMPUTER					1134
#define IDS_LISTBOX_SHOW					1135
#define IDS_VALUE							1136
#define IDS_VALUENAME						1137
#define IDS_EMPTYVALUENAME					1138
#define IDS_VALUENAMENOTUNIQUE				1139
#define IDS_ERRFORMAT						1140
#define IDS_EMPTYVALUEDATA					1141
#define IDS_VALUEDATANOTUNIQUE				1142
#define IDS_QUERYPASTE_USER					1143
#define IDS_QUERYPASTE_WORKSTA				1144
#define IDS_QUERYPASTE_MULTIPLE				1145
#define IDS_COMPUTERBROWSETITLE				1146
#define IDS_GROUPSNOTADDED					1147
#define IDS_COLUMNTITLE						1148
#define IDS_GROUPDLGTXT						1149
#define IDS_GROUPDLGTITLE					1150
#define IDS_QUERYREMOVE_GROUP				1151
#define IDS_DUPLICATEGROUP					1152
#define IDS_HELPFILE						1153
#define IDS_CHOOSEUSER_TITLE                                    1154
#define IDS_ACCOUNTUNKNOWN                                      1155
#define IDS_CANTLOADNETUI2                                      1156
#define IDS_ERRORADDINGGROUP                                    1157
#define IDS_ADDUSERS                                            1158
#define IDS_ADDGROUPS                                           1159

#define IDS_ParseErr_UNEXPECTED_KEYWORD		2000
#define IDS_ParseErr_UNEXPECTED_EOF			2001
#define IDS_ParseErr_DUPLICATE_KEYNAME		2002
#define IDS_ParseErr_DUPLICATE_VALUENAME	2003
#define IDS_ParseErr_NO_KEYNAME				2004
#define IDS_ParseErr_NO_VALUENAME			2005
#define IDS_ParseErr_NO_VALUE				2006
#define IDS_ParseErr_NOT_NUMERIC			2007
#define IDS_ParseErr_DUPLICATE_ITEMNAME		2008
#define IDS_ParseErr_NO_ITEMNAME			2009
#define IDS_ParseErr_DUPLICATE_ACTIONLIST	2010
#define IDS_ParseErr_STRING_NOT_FOUND		2011
#define IDS_ParseErr_UNMATCHED_DIRECTIVE	2012

#define IDI_APPICON			1000

#define IDA_ACCEL			1005
#define IDB_TOOLBAR			1006

#define IDC_TOOLBAR			1010
#define IDC_STATUSBAR		1011

#define IDB_IMGSMALL		1020
#define IDB_IMGLARGE		1021

#define IDS_TIPS			1500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\treectrl.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

HTREEITEM hItemPressed = NULL;

VOID ProcessMouseDown(HWND hDlg,HWND hwndTree);
VOID ProcessMouseUp(HWND hDlg,HWND hwndTree);
BOOL ProcessExpand(HWND hDlg,HWND hwndTree,TV_ITEM * ptvi,
	BOOL fExpanding);
BOOL ProcessSelection(HWND hDlg,HWND hwndTree,NM_TREEVIEW * pntv);
VOID ProcessPolicyCheckbox(HWND hDlg,HWND hwndTree,HTREEITEM hItem,BOOL fHasSel);
UINT AdvanceCheckboxState(UINT uImage);
BOOL IsAncestorOfSelection(HWND hwndTree,HTREEITEM hParent);
BOOL IsSelectedItemChecked(HWND hwndTree);
BOOL ProcessCheckboxFromKeyboard(HWND hDlg,HWND hwndTree);

BOOL OnTreeNotify(HWND hDlg,HWND hwndTree,NM_TREEVIEW *pntv)
{

	switch (pntv->hdr.code) {

		case NM_CLICK:
			ProcessMouseUp(hDlg,hwndTree);
			return 0;
			break;

		case TVN_ITEMEXPANDING:
			// if we're collapsing a branch that contains the current
			// selection, validate its controls
			if ( ((pntv->action & TVE_ACTIONMASK) == TVE_COLLAPSE)
				&& IsSelectedItemChecked(hwndTree)
				&& IsAncestorOfSelection(hwndTree,pntv->itemNew.hItem)
				&& !ProcessSettingsControls(hDlg,PSC_VALIDATENOISY))
				return TRUE; // invalid stuff in ctrls, don't allow collapse

			return ProcessExpand(hDlg,hwndTree,&pntv->itemNew,
				((pntv->action & TVE_ACTIONMASK) == TVE_EXPAND) );
			break;

		case TVN_SELCHANGING:
			return ProcessSelection(hDlg,hwndTree,pntv);

			break;

		case TVN_KEYDOWN:
			{
				WORD wKey = ( (TV_KEYDOWN *) pntv)->wVKey;
				if (wKey == VK_SPACE) {
					return ProcessCheckboxFromKeyboard(hDlg,hwndTree);
				}
				return FALSE;
			}

			break;
	}

	return 0;
}

VOID ProcessMouseDown(HWND hDlg,HWND hwndTree)
{
	TV_HITTESTINFO ht;
	TV_ITEM tvi;
	POLICYDLGINFO * pdi;
	TABLEENTRY * pTableEntry;

	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)))
		return;

	GetCursorPos(&ht.pt);
	ScreenToClient(hwndTree,&ht.pt);

	if (TreeView_HitTest(hwndTree,&ht) && ht.flags & TVHT_ONITEMICON) {

		tvi.mask = TVIF_HANDLE;
		tvi.hItem = ht.hItem;		

		if (!TreeView_GetItem(hwndTree,&tvi)) return;

		pTableEntry = (TABLEENTRY *) tvi.lParam;

		if (!pTableEntry || pTableEntry->dwType != ETYPE_POLICY) return;

		hItemPressed = tvi.hItem;
	}
}

VOID ProcessMouseUp(HWND hDlg,HWND hwndTree)
{
	BOOL fHasSel = TRUE;

	if (hItemPressed) {

		// if checkbox for item other than selected item is being changed,
		// validate setting controls for current selection because selection
		// will change.
		if (hItemPressed != TreeView_GetSelection(hwndTree)) {
			if (!ProcessSettingsControls(hDlg,PSC_NOVALIDATE)) {
				hItemPressed = NULL;
				return;
			}
			fHasSel = FALSE;
		}				

		ProcessPolicyCheckbox(hDlg,hwndTree,hItemPressed,fHasSel);
		hItemPressed = NULL;
	}
}

BOOL ProcessCheckboxFromKeyboard(HWND hDlg,HWND hwndTree)
{
	TV_ITEM tvi;
	TABLEENTRY * pTableEntry;

	if (!(tvi.hItem = TreeView_GetSelection(hwndTree)))
		return FALSE;
	tvi.mask = TVIF_PARAM;

	if (!TreeView_GetItem(hwndTree,&tvi))
		return FALSE;

	pTableEntry = (TABLEENTRY *) tvi.lParam;

	if (!pTableEntry || pTableEntry->dwType != ETYPE_POLICY)
		return FALSE;

	ProcessPolicyCheckbox(hDlg,hwndTree,tvi.hItem,TRUE);
	return TRUE;
}

VOID ProcessMouseMove(HWND hwndDlg,HWND hwndTree)
{
	if (!hItemPressed) return;

	{
		TV_HITTESTINFO ht;

		GetCursorPos(&ht.pt);
		ScreenToClient(hwndDlg,&ht.pt);

		if (TreeView_HitTest(hwndTree,&ht) &&
			((ht.flags & TVHT_ONITEMICON )
				&& (ht.hItem == hItemPressed)) )
			return;

		hItemPressed=NULL;
	}					
}

VOID ProcessPolicyCheckbox(HWND hDlg,HWND hwndTree,HTREEITEM hItem,BOOL fHasSel)
{
	TV_ITEM tvi;
	BOOL fPrevEnabled;
	POLICYDLGINFO * pdi;

	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)))
		return;

	tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
	tvi.hItem = hItem;
	if (!TreeView_GetItem(hwndTree,&tvi) || !tvi.lParam) return;

	fPrevEnabled = (tvi.iImage == IMG_CHECKED);

	tvi.iSelectedImage=tvi.iImage = AdvanceCheckboxState(tvi.iImage);
	SetPolicyState(hDlg,(TABLEENTRY *) tvi.lParam,tvi.iImage);	

	tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
	TreeView_SetItem(hwndTree,&tvi);

	if (fHasSel && pdi->nControls) {
		if (fPrevEnabled)
			ProcessSettingsControls(hDlg,PSC_NOVALIDATE);
		EnableSettingsControls( hDlg,(tvi.iImage == IMG_CHECKED) );
	}
}

BOOL ProcessExpand(HWND hDlg,HWND hwndTree,TV_ITEM * ptvi,BOOL fExpanding)
{
	DWORD dwType;
	HTREEITEM hItem;
	POLICYDLGINFO * pdi;

	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)) || !ptvi->lParam)
		return 0;

	dwType = ((TABLEENTRY *) ptvi->lParam)->dwType;

	if (dwType == ETYPE_ROOT) {
		// OK to expand (which happens right after root item is added),
		// not OK to collapse
		return !fExpanding;
	}

	if (dwType == ETYPE_POLICY) {
		return 0;
	}

	ptvi->iSelectedImage=ptvi->iImage = GetImageIndex(dwType,fExpanding,TRUE);

	ptvi->mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
	
	TreeView_SetItem(hwndTree,ptvi);

	// if collapsing, set all children's images to "collapsed"
	if (!fExpanding && (hItem = TreeView_GetChild(hwndTree,ptvi->hItem))) {
		TV_ITEM tvi;

		do {

			tvi.hItem = hItem;
			tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;

			if (!TreeView_GetItem(hwndTree,&tvi)) return 0;
			
			ProcessExpand(hDlg,hwndTree,&tvi,fExpanding);

			hItem = TreeView_GetNextSibling(hwndTree,hItem);

		} while (hItem);
	}

	return 0;	// OK to proceed
}


UINT AdvanceCheckboxState(UINT uImage)
{
	switch (uImage) {

		case IMG_CHECKED:
			return IMG_UNCHECKED;
			break;

		case IMG_UNCHECKED:
			return (dwAppState & AS_POLICYFILE ? IMG_INDETERMINATE :
				IMG_CHECKED);
			break;

		case IMG_INDETERMINATE:
			return IMG_CHECKED;
			break;
 	}

        return IMG_UNCHECKED;
}

BOOL ProcessSelection(HWND hDlg,HWND hwndTree,NM_TREEVIEW * pntv)
{
	TABLEENTRY * pTableEntry = (TABLEENTRY *) pntv->itemNew.lParam;
	POLICY * pPolicy;
	CHAR szText[MAXSTRLEN+SMALLBUF+1];
	TV_ITEM tvi;
	POLICYDLGINFO * pdi;

	if (!(pdi = (POLICYDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER)) ||
		!pTableEntry)
		return FALSE;

	tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;

	if (tvi.hItem = pntv->itemOld.hItem) {
		if (TreeView_GetItem(hwndTree,&tvi) && tvi.iImage == IMG_CHECKED)
			if (!ProcessSettingsControls(hDlg,PSC_VALIDATENOISY)) return TRUE;
		
	}

	FreeSettingsControls(hDlg);

	tvi.hItem = pntv->itemNew.hItem;
	if (!TreeView_GetItem(hwndTree,&tvi)) return FALSE;

	if ( (pTableEntry->dwType==ETYPE_POLICY)) {

		pPolicy = (POLICY *) pTableEntry;
		if (pPolicy->pChild) {
			BOOL fEnabled = (tvi.iImage == IMG_CHECKED);
			wsprintf(szText,LoadSz(IDS_SETTINGSFOR,szSmallBuf,sizeof(szSmallBuf)),
				(CHAR *) (GETNAMEPTR(pPolicy)));
			SetDlgItemText(hDlg,IDD_TXSETTINGS,szText);

			CreateSettingsControls(hDlg,(SETTINGS *) pPolicy->pChild,fEnabled);
			EnableSettingsControls(hDlg,fEnabled);
		} else {
			SetDlgItemText(hDlg,IDD_TXSETTINGS,szNull);
		}

	} else {
		SetDlgItemText(hDlg,IDD_TXSETTINGS,szNull);
	}

	return FALSE;
}

/*******************************************************************

	NAME:		IsAncestorOfSelection

	SYNOPSIS:	For specified tree control, checks to see if specified
				item is an ancestor of the currently selected item
				in the tree control.

	NOTES:		Used to figure out if a tree collapse is going to hide
				the selected item

********************************************************************/
BOOL IsAncestorOfSelection(HWND hwndTree,HTREEITEM hParent)
{
	HTREEITEM hItem;
		
	hItem= TreeView_GetSelection(hwndTree);
		
	while (hItem) {
		if (hItem == hParent) return TRUE;
		hItem = TreeView_GetParent(hwndTree,hItem);
	}

	return FALSE;
}


/*******************************************************************

	NAME:		IsSelectedItemChecked

	SYNOPSIS:	Returns true if selected treeview item is checked

********************************************************************/
BOOL IsSelectedItemChecked(HWND hwndTree)
{
	HTREEITEM hItem= TreeView_GetSelection(hwndTree);

	if (hItem) {
		TV_ITEM tvi;
		tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
		tvi.hItem = hItem;
		if (TreeView_GetItem(hwndTree,&tvi) && tvi.iImage == IMG_CHECKED)
			return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\treeview.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"

BOOL InsertTableToTreeView(POLICYDLGINFO * pdi,HWND hwndTree,TABLEENTRY * pTableEntry,
	HTREEITEM hParent,USERDATA * pUserData);
UINT GetChildCount(TABLEENTRY * pTableEntry);

BOOL RefreshTreeView(POLICYDLGINFO * pdi,HWND hwndTree,TABLEENTRY * pTableEntry,
	HGLOBAL hUser)
{
	TV_INSERTSTRUCT tvis;
	USERDATA * pUserData;
	HTREEITEM hTreeItemTop=NULL;

	if (!(pUserData = (USERDATA *) GlobalLock(hUser))) return FALSE;

	TreeView_DeleteAllItems(hwndTree);
	hTreeItemTop = NULL;

	tvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE
		| TVIF_CHILDREN;
	tvis.item.hItem = NULL;
	tvis.item.lParam = 0;
	tvis.hParent = TVI_ROOT;
	tvis.hInsertAfter = TVI_LAST;
	tvis.item.pszText = pUserData->hdr.szName;
	tvis.item.cchTextMax = lstrlen(tvis.item.pszText) + 1;
	tvis.item.iImage = tvis.item.iSelectedImage =
		GetUserImageIndex(pUserData->hdr.dwType);
	tvis.item.cChildren = GetChildCount(pTableEntry);
	tvis.item.lParam = (LPARAM) NULL;

	if (!(hTreeItemTop=TreeView_InsertItem(hwndTree,&tvis))) {
		GlobalUnlock(hUser);
		return FALSE;
	}

	if (!InsertTableToTreeView(pdi,hwndTree,pTableEntry->pChild,hTreeItemTop,pUserData)) {
		GlobalUnlock(hUser);
		return FALSE;
	}

	TreeView_Expand(hwndTree,hTreeItemTop,TVE_EXPAND);

	GlobalUnlock(hUser);
	return TRUE;
}

BOOL InsertTableToTreeView(POLICYDLGINFO * pdi,HWND hwndTree,TABLEENTRY * pTableEntry,
	HTREEITEM hParent,USERDATA * pUserData)
{
	TV_INSERTSTRUCT tvis;
	HTREEITEM hTreeItem;

        tvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE |
                         TVIF_CHILDREN | TVIF_HANDLE | TVIF_STATE;
	tvis.item.hItem = NULL;
	tvis.item.state = 0;
	tvis.item.stateMask = TVIS_ALL;
	tvis.item.lParam = 0;

	tvis.hParent = hParent;
	tvis.hInsertAfter = TVI_LAST;

	while (pTableEntry) {

		tvis.item.pszText = GETNAMEPTR(pTableEntry);
		tvis.item.cchTextMax = lstrlen(tvis.item.pszText)+1;

		if (pTableEntry->dwType == ETYPE_CATEGORY) {
			tvis.item.cChildren = GetChildCount(pTableEntry);
			tvis.item.iImage = tvis.item.iSelectedImage = IMG_BOOKCLOSED;
		} else {
			tvis.item.cChildren = 0;
			tvis.item.iImage = tvis.item.iSelectedImage =
				pUserData->SettingData[((POLICY *) pTableEntry)->uDataIndex].uData;
		}

		tvis.item.lParam = (LPARAM) pTableEntry;

		if (!(hTreeItem=TreeView_InsertItem(hwndTree,&tvis))) return FALSE;

		if ((pTableEntry->dwType == ETYPE_CATEGORY) && pTableEntry->pChild) {
			if (!InsertTableToTreeView(pdi,hwndTree,pTableEntry->pChild,
				hTreeItem,pUserData)) return FALSE;
		}

		pTableEntry = pTableEntry->pNext;
	}

	return TRUE;
}


#define NUMBITMAPS 19
#define NUMIMAGES 11

#define MAPCOLOR	0x00FF00FF
HIMAGELIST hImageListSmall = NULL,hImageListLarge = NULL;
 
BOOL InitImageLists(VOID)
{
	if ( !(hImageListSmall = ImageList_LoadBitmap(ghInst,MAKEINTRESOURCE(IDB_IMGSMALL),
		16,5,(COLORREF) MAPCOLOR)) || 
                !(hImageListLarge = ImageList_LoadBitmap(ghInst,MAKEINTRESOURCE(IDB_IMGLARGE),
		32,5,(COLORREF) MAPCOLOR)) ) {
		FreeImageLists();
		return FALSE;
	}

	ImageList_SetBkColor(hImageListSmall, GetSysColor(COLOR_WINDOW));
	ImageList_SetBkColor(hImageListLarge, GetSysColor(COLOR_WINDOW));

	return TRUE;	
}

VOID FreeImageLists(VOID)
{
	if (hImageListSmall) {
		ImageList_Destroy(hImageListSmall);
		hImageListSmall=NULL;
	}
	if (hImageListLarge) {
		ImageList_Destroy(hImageListLarge);
		hImageListLarge=NULL;
	}
}

UINT GetImageIndex(DWORD dwType,BOOL fExpanded,BOOL fEnabled)
{
 	switch (dwType) {

		case ETYPE_CATEGORY:

			return (fExpanded ? IMG_BOOKOPEN : IMG_BOOKCLOSED);
			break;

		case ETYPE_POLICY:

			return IMG_INDETERMINATE;
			break;

		case ETYPE_SETTING | STYPE_TEXT:
		case ETYPE_SETTING | STYPE_EDITTEXT:
		case ETYPE_SETTING | STYPE_COMBOBOX:
		case ETYPE_SETTING | STYPE_ENUM:
		case ETYPE_SETTING | STYPE_NUMERIC:

			return IMG_EMPTY;
			break;

		case ETYPE_SETTING | STYPE_CHECKBOX:
			return IMG_UNCHECKED;
			break;
	}

        return IMG_INDETERMINATE;
}

UINT GetChildCount(TABLEENTRY * pTableEntry)
{
	TABLEENTRY * pChild = pTableEntry->pChild;
	UINT nCount=0;

	while (pChild) {
		nCount++;
		pChild = pChild->pNext;
	}
	
	return nCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\treeview.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#ifndef _TREEVIEW_H_
#define _TREEVIEW_H_

// state image indexes
#define IMG_USER			0
#define IMG_USERS			1
#define IMG_MACHINE			2
#define IMG_MACHINES		3
#define IMG_BOOKOPEN		4
#define IMG_BOOKCLOSED		5
#define IMG_CHECKED			6
#define IMG_UNCHECKED		7
#define IMG_INDETERMINATE	8
#define IMG_EMPTY			9
#endif	_TREEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\strings.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

const TCHAR szUSERS[]		= REGSTR_KEY_POL_USERS;
const TCHAR szWORKSTATIONS[]    = REGSTR_KEY_POL_COMPUTERS;
const TCHAR szDEFAULTENTRY[]    = REGSTR_KEY_POL_DEFAULT;
const TCHAR szUSERGROUPS[]      = REGSTR_KEY_POL_USERGROUPS;
const TCHAR szUSERGROUPDATA[]   = REGSTR_KEY_POL_USERGROUPDATA;
const TCHAR szTMPDATA[]	        = TEXT("PolicyData");
const TCHAR szLISTBOX[]         = TEXT("LISTBOX");
const TCHAR szEDIT[]            = TEXT("EDIT");
const TCHAR szBUTTON[]          = TEXT("BUTTON");
const TCHAR szSTATIC[]          = TEXT("STATIC");
const TCHAR szLISTVIEW[] 	= WC_LISTVIEW;
const TCHAR szTREEVIEW[] 	= WC_TREEVIEW;
const TCHAR szUPDOWN[]		= UPDOWN_CLASS;
const TCHAR szSlash[]           = TEXT("\\");
const TCHAR szNull[]            = TEXT("");
const TCHAR szAPPREGKEY[]       = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\PolEdit");
const TCHAR szLASTCONNECTION[]  = TEXT("LastConnection");
const TCHAR szToolbarClass[]    = TOOLBARCLASSNAME;
const TCHAR szLastFile[]        = TEXT("File%lu");
const TCHAR szTemplate[]        = TEXT("Template%lu");

const TCHAR szCLASS[]           = TEXT("CLASS");
const TCHAR szCATEGORY[]        = TEXT("CATEGORY");
const TCHAR szPOLICY[]          = TEXT("POLICY");
const TCHAR szUSER[]            = TEXT("USER");
const TCHAR szMACHINE[]         = TEXT("MACHINE");

const TCHAR szCHECKBOX[]        = TEXT("CHECKBOX");
const TCHAR szTEXT[]            = TEXT("TEXT");
const TCHAR szEDITTEXT[]        = TEXT("EDITTEXT");
const TCHAR szNUMERIC[]         = TEXT("NUMERIC");
const TCHAR szCOMBOBOX[]        = TEXT("COMBOBOX");
const TCHAR szDROPDOWNLIST[]    = TEXT("DROPDOWNLIST");

const TCHAR szKEYNAME[]         = TEXT("KEYNAME");
const TCHAR szVALUENAME[]       = TEXT("VALUENAME");
const TCHAR szNAME[]            = TEXT("NAME");
const TCHAR szEND[]             = TEXT("END");
const TCHAR szPART[]            = TEXT("PART");
const TCHAR szSUGGESTIONS[]     = TEXT("SUGGESTIONS");
const TCHAR szDEFCHECKED[]      = TEXT("DEFCHECKED");
const TCHAR szDEFAULT[]         = TEXT("DEFAULT");
const TCHAR szMAXLENGTH[]       = TEXT("MAXLEN");
const TCHAR szMIN[]             = TEXT("MIN");
const TCHAR szMAX[]             = TEXT("MAX");
const TCHAR szSPIN[]            = TEXT("SPIN");
const TCHAR szREQUIRED[]        = TEXT("REQUIRED");
const TCHAR szOEMCONVERT[]      = TEXT("OEMCONVERT");
const TCHAR szTXTCONVERT[]      = TEXT("TXTCONVERT");
const TCHAR szEXPANDABLETEXT[]  = TEXT("EXPANDABLETEXT");
const TCHAR szVALUEON[]         = TEXT("VALUEON");
const TCHAR szVALUEOFF[]        = TEXT("VALUEOFF");
const TCHAR szVALUE[]           = TEXT("VALUE");
const TCHAR szACTIONLIST[]      = TEXT("ACTIONLIST");
const TCHAR szACTIONLISTON[]    = TEXT("ACTIONLISTON");
const TCHAR szACTIONLISTOFF[]   = TEXT("ACTIONLISTOFF");
const TCHAR szDELETE[]          = TEXT("DELETE");
const TCHAR szITEMLIST[]        = TEXT("ITEMLIST");
const TCHAR szSOFT[]            = TEXT("SOFT");
const TCHAR szVALUEPREFIX[]     = TEXT("VALUEPREFIX");
const TCHAR szADDITIVE[]        = TEXT("ADDITIVE");
const TCHAR szEXPLICITVALUE[]   = TEXT("EXPLICITVALUE");
const TCHAR szNOSORT[]          = TEXT("NOSORT");
const TCHAR szHELP[]            = TEXT("EXPLAIN");
const TCHAR szCLIENTEXT[]       = TEXT("CLIENTEXT");
const TCHAR szStringsSect[]     = TEXT("[strings]");
const TCHAR szStrings[]         = TEXT("strings");

const TCHAR szDELETEPREFIX[]    = TEXT("**del.");
const TCHAR szSOFTPREFIX[]      = TEXT("**soft.");
const TCHAR szDELVALS[]         = TEXT("**delvals.");
const TCHAR szNOVALUE[]         = TEXT(" ");

const TCHAR szProviderKey[]     = REGKEY_SP_CONFIG;
const TCHAR szValueAddressBook[] = REGVAL_SP_ABPROVIDER;
const TCHAR szValuePlatform[]   = REGVAL_SP_PLATFORM;
const TCHAR szRegPathCVNetwork[] = REGSTR_PATH_CVNETWORK;
const TCHAR szInstalled[]       = TEXT("Installed");
const TCHAR sz1[]               = TEXT("1");

const TCHAR szIFDEF[]           = TEXT("#ifdef");
const TCHAR szIF[]              = TEXT("#if");
const TCHAR szENDIF[]           = TEXT("#endif");
const TCHAR szIFNDEF[]          = TEXT("#ifndef");
const TCHAR szELSE[]            = TEXT("#else");
const TCHAR szVERSION[]         = TEXT("VERSION");
const TCHAR szLT[]              = TEXT("<");
const TCHAR szLTE[]             = TEXT("<=");
const TCHAR szGT[]              = TEXT(">");
const TCHAR szGTE[]             = TEXT(">=");
const TCHAR szEQ[]              = TEXT("==");
const TCHAR szNE[]              = TEXT("!=");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\user.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#ifndef _USER_H_
#define _USER_H_

#define UT_USER		0x01	// user types
#define UT_MACHINE	0x02
#define UT_MASK		0x03

#define UF_GROUP	0x04	// flag, combined with UT_USER or UT_MACHINE
							// signifies group

#define MAXNAMELEN	39

#define INIT_WITH_DEFAULT	(UINT) -1
#define NO_VALUE			(UINT) -1

typedef struct tagSETTINGDATA {
	DWORD dwType;
	union {
		UINT uData;			// for checkboxes/radio buttons/enum types, contains data
		UINT uOffsetData;	// for string types, contains offset to data from
							// beginning of USERDATA buffer
	};	
} SETTINGDATA;

typedef struct tagUSERHDR {
	DWORD 		dwType;			// type of user
	CHAR  		szName[MAXNAMELEN+1];		// user/group/machine name
} USERHDR;

typedef struct tagUSERDATA {
	DWORD 			dwSize;			// size of buffer
	USERHDR			hdr;
	HGLOBAL			hClone;			// if non-NULL, "clone" of this user with initial settings
	UINT			nSettings;
	SETTINGDATA		SettingData[];
	// variable-length data here
} USERDATA;

#endif	_USER_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\strings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

extern const TCHAR szUSERS[];
extern const TCHAR szWORKSTATIONS[];
extern const TCHAR szDEFAULTENTRY[];
extern const TCHAR szUSERGROUPS[];
extern const TCHAR szUSERGROUPDATA[];
extern const TCHAR szTMPDATA[];
extern const TCHAR szLISTBOX[];
extern const TCHAR szBUTTON[];
extern const TCHAR szEDIT[];
extern const TCHAR szSTATIC[];
extern const TCHAR szLISTVIEW[];
extern const TCHAR szTREEVIEW[];
extern const TCHAR szUPDOWN[];
extern const TCHAR szSlash[];
extern const TCHAR szNull[];
extern const TCHAR szAPPREGKEY[];
extern const TCHAR szLASTCONNECTION[];
extern const TCHAR szToolbarClass[];
extern const TCHAR szLastFile[];
extern const TCHAR szTemplate[];


extern const TCHAR szCLASS[];
extern const TCHAR szCATEGORY[];
extern const TCHAR szPOLICY[];
extern const TCHAR szUSER[];
extern const TCHAR szMACHINE[];

extern const TCHAR szCHECKBOX[];
extern const TCHAR szTEXT[];
extern const TCHAR szEDITTEXT[];
extern const TCHAR szNUMERIC[];
extern const TCHAR szCOMBOBOX[];
extern const TCHAR szDROPDOWNLIST[];

extern const TCHAR szKEYNAME[];
extern const TCHAR szVALUENAME[];
extern const TCHAR szNAME[];
extern const TCHAR szEND[];
extern const TCHAR szPART[];
extern const TCHAR szSUGGESTIONS[];
extern const TCHAR szDEFCHECKED[];
extern const TCHAR szDEFAULT[];
extern const TCHAR szMAXLENGTH[];
extern const TCHAR szMIN[];
extern const TCHAR szMAX[];
extern const TCHAR szSPIN[];
extern const TCHAR szREQUIRED[];
extern const TCHAR szOEMCONVERT[];
extern const TCHAR szTXTCONVERT[];
extern const TCHAR szEXPANDABLETEXT[];
extern const TCHAR szVALUE[];
extern const TCHAR szVALUEON[];
extern const TCHAR szVALUEOFF[];
extern const TCHAR szACTIONLIST[];
extern const TCHAR szACTIONLISTON[];
extern const TCHAR szACTIONLISTOFF[];
extern const TCHAR szDELETE[];
extern const TCHAR szITEMLIST[];
extern const TCHAR szVALUEPREFIX[];
extern const TCHAR szADDITIVE[];
extern const TCHAR szEXPLICITVALUE[];

extern const TCHAR szDELETEPREFIX[7];
extern const TCHAR szSOFTPREFIX[8];
extern const TCHAR szDELVALS[10];
extern const TCHAR szNOVALUE[];
extern const TCHAR szSOFT[];
extern const TCHAR szNOSORT[];
extern const TCHAR szHELP[];
extern const TCHAR szCLIENTEXT[];
extern const TCHAR szStringsSect[];
extern const TCHAR szStrings[];

extern const TCHAR szProviderKey[];
extern const TCHAR szValueAddressBook[];
extern const TCHAR szValuePlatform[];
extern const TCHAR szRegPathCVNetwork[];
extern const TCHAR szInstalled[];
extern const TCHAR sz1[];

extern const TCHAR szIFDEF[];
extern const TCHAR szIF[];
extern const TCHAR szENDIF[];
extern const TCHAR szIFNDEF[];
extern const TCHAR szELSE[];
extern const TCHAR szVERSION[];
extern const TCHAR szLT[];
extern const TCHAR szLTE[];
extern const TCHAR szGT[];
extern const TCHAR szGTE[];
extern const TCHAR szEQ[];
extern const TCHAR szNE[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\user.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "admincfg.h"
#include "regstr.h"

BOOL InitSettingData(TABLEENTRY * pTableEntry,SETTINGDATA *pSettingData);
HGLOBAL AllocateUser(CHAR * szName,DWORD dwType);
VOID RemoveDeletedUser(USERHDR * pUserHdr);

USERHDR * pDeletedUserList = NULL;
UINT nDeletedUserCount = 0;

/*******************************************************************

	NAME:		AddUser

	SYNOPSIS:	Allocates a user and adds it to the list control.

********************************************************************/
HGLOBAL AddUser(HWND hwndList,CHAR * szName,DWORD dwType)
{
	HGLOBAL hUser;
	LV_ITEM lvi;
	UINT uStrID=0;

	if (!(hUser = AllocateUser(szName,dwType))) return NULL;

	lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvi.iItem = 0;
	lvi.iSubItem = 0;
	lvi.state = 0;
        lvi.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
	lvi.pszText = szName;
	lvi.cchTextMax = lstrlen(szName)+1;
	lvi.iImage = GetUserImageIndex(dwType);
	lvi.lParam = (LPARAM) hUser;

	if (dwAppState & AS_POLICYFILE) {
		// if a "default user/default workstation" entry exists, init the new
		// user/computer with that data
		switch (dwType & UT_MASK) {
			case UT_USER:
				uStrID = IDS_DEFAULTUSER;
				break;

			case UT_MACHINE:
				uStrID = IDS_DEFAULTCOMPUTER;
			break;
		}

		if (uStrID) {
			LV_FINDINFO lvfi;
			CHAR szDefaultName[USERNAMELEN+1];
			int iSel=-1;
			HGLOBAL hDefaultUser;
			USERDATA * pUserData;
			BOOL fFound=FALSE;

			LoadSz(uStrID,szDefaultName,sizeof(szDefaultName));

			lvfi.flags = LVFI_STRING | LVFI_NOCASE;
			lvfi.psz = szDefaultName;

			while (!fFound && (iSel=ListView_FindItem(hwndUser,iSel,&lvfi)) >= 0) {
                                hDefaultUser=(HGLOBAL) LongToHandle(ListView_GetItemParm(hwndUser,iSel));
				if (hDefaultUser && (pUserData = (USERDATA *)
					GlobalLock(hDefaultUser))) {
					if ( (pUserData->hdr.dwType & UT_MASK) == dwType)
						fFound = TRUE;
					GlobalUnlock(hDefaultUser);
				}
			}

			// copy default user data to new user
			if (fFound)
				CopyUser(hDefaultUser,hUser);

		}
	}

	if (ListView_InsertItem(hwndList,&lvi) < 0) {
	  	FreeUser(hUser);
		return NULL;
	}

	return hUser;	
}

/*******************************************************************

	NAME:		AllocateUser

	SYNOPSIS:	Allocates memory for user information and initializes
				the data area

********************************************************************/
HGLOBAL AllocateUser(CHAR * szName,DWORD dwType)
{
	HGLOBAL hMem;
	USERDATA * pUserData;
	DWORD dwNeeded;
	TABLEENTRY * pTableEntry;

	dwNeeded = sizeof(USERDATA) + sizeof(SETTINGDATA) *
		( (dwType & UT_USER) ? gClassList.nUserDataItems :
			gClassList.nMachineDataItems );

	if (!(hMem=GlobalAlloc(GHND,dwNeeded))) return NULL;

	if (!(pUserData = (USERDATA *) GlobalLock(hMem))) {
		GlobalFree(hMem);
		return NULL;
	}

	// init the data structure
	pUserData->dwSize = dwNeeded;
	pUserData->hdr.dwType = dwType;
	pUserData->nSettings = ( (dwType & UT_USER)
		? gClassList.nUserDataItems : gClassList.nMachineDataItems );
	lstrcpy(pUserData->hdr.szName,szName);

	pTableEntry = ( ( dwType & UT_USER ) ? gClassList.pUserCategoryList :
		gClassList.pMachineCategoryList);

	if (!InitSettingData(pTableEntry,pUserData->SettingData)) {
		GlobalUnlock(hMem);
		GlobalFree(hMem);
		return NULL;						 		
	}

	// remove this user from the deleted list, if it's on it
	RemoveDeletedUser(&pUserData->hdr);

	GlobalUnlock(hMem);
	return hMem;
}

/*******************************************************************

	NAME:		CloneUser

	SYNOPSIS:	Clones the specified user by allocating a duplicate buffer,
				copying the data to the 2nd buffer and storing a handle to
				the new buffer in the original.  This is so the initial state
				of a user can be preserved so we can do non-destructive saves.

********************************************************************/
BOOL CloneUser(HGLOBAL hUser)
{
	USERDATA * pUserData = (USERDATA *) GlobalLock(hUser);
	USERDATA * pUserDataClone;
	HGLOBAL  hUserClone;
	
	if (!pUserData) return FALSE;

	// free existing clone if there is one
	if (pUserData->hClone) {
		GlobalFree(pUserData->hClone);
		pUserData->hClone = NULL;
	}

	hUserClone = GlobalAlloc(GHND,pUserData->dwSize);
	if (!hUserClone || !(pUserDataClone = (USERDATA *) GlobalLock(hUserClone))) {
		if (hUserClone)
			GlobalFree(hUserClone);
		GlobalUnlock(hUser);
		return FALSE;
	}

	// copy the user data to clone and save handle to clone in original user
	memcpy (pUserDataClone,pUserData,pUserData->dwSize);
	pUserData->hClone = hUserClone;

	GlobalUnlock(hUser);
	GlobalUnlock(hUserClone);

	return TRUE;
}

BOOL CopyUser(HGLOBAL hUserSrc,HGLOBAL hUserDst)
{
	BOOL fRet=FALSE;
	USERDATA * pUserDataSrc = NULL,* pUserDataDst = NULL;
	HGLOBAL hCloneDst;
	USERHDR UserhdrDst;

	if (!(pUserDataSrc = (USERDATA *) GlobalLock(hUserSrc)) ||
		!(pUserDataDst = (USERDATA *) GlobalLock(hUserDst))) {
			goto cleanup;
		}

	// save destination user header & clone handle.. don't want to overwrite
	// this stuff
	UserhdrDst = pUserDataDst->hdr;
	hCloneDst = pUserDataDst->hClone;

	// resize buffer if necessary
	if (pUserDataDst->dwSize != pUserDataSrc->dwSize) {
		if (!(pUserDataDst = (USERDATA *) ResizeBuffer((CHAR *) pUserDataDst,
			hUserDst,pUserDataSrc->dwSize,&pUserDataDst->dwSize))) {
			goto cleanup;
		}
	}

	// copy src to dest
	memcpy(pUserDataDst,pUserDataSrc,pUserDataSrc->dwSize);
	fRet = TRUE;

	// put the destination user's old header & clone handle back in the
	// user data
	pUserDataDst->hClone = hCloneDst;
	pUserDataDst->hdr = UserhdrDst;
	
cleanup:
	if (pUserDataSrc)
		GlobalUnlock(hUserSrc);
	if (pUserDataDst)
		GlobalUnlock(hUserDst);

	return fRet;
}

/*******************************************************************

	NAME:		InitSettingData

	SYNOPSIS:	Walks a template tree and initializes user's data buffer
				according to template tree

	NOTES:		Sets checkboxes to "indeterminate", puts default text
				in data buffer, etc.

********************************************************************/
BOOL InitSettingData(TABLEENTRY * pTableEntry,SETTINGDATA *pSettingData)
{
	while (pTableEntry) {

		if (pTableEntry->pChild &&
			!InitSettingData(pTableEntry->pChild,pSettingData))
			return FALSE;

		if (pTableEntry->dwType == ETYPE_POLICY) {

			pSettingData[ ( (POLICY *) pTableEntry)->uDataIndex].dwType =
				pTableEntry->dwType;

			pSettingData[ ( (POLICY *) pTableEntry)->uDataIndex].uData
				= (dwAppState & AS_POLICYFILE ? IMG_INDETERMINATE :
				IMG_UNCHECKED);

		} else if ((pTableEntry->dwType & ETYPE_MASK) == ETYPE_SETTING) {
			SETTINGS * pSetting = (SETTINGS *) pTableEntry;

			pSettingData[pSetting->uDataIndex].dwType =
				pTableEntry->dwType;

			switch (pTableEntry->dwType & STYPE_MASK) {
				
				case STYPE_EDITTEXT:
				case STYPE_COMBOBOX:
					if (pSetting->dwFlags & DF_USEDEFAULT) {
						pSettingData[pSetting->uDataIndex].uData =
						INIT_WITH_DEFAULT;
					break;

				case STYPE_CHECKBOX:
					pSettingData[pSetting->uDataIndex].uData =
						( (pSetting->dwFlags & DF_USEDEFAULT) ? 1 : 0);
					break;

				case STYPE_NUMERIC:
					pSettingData[pSetting->uDataIndex].uData =
						( (pSetting->dwFlags & DF_USEDEFAULT) ?
						(((NUMERICINFO *) GETOBJECTDATAPTR(pSetting)))
						->uDefValue : NO_VALUE);
					break;

				case STYPE_DROPDOWNLIST:
					pSettingData[pSetting->uDataIndex].uData =
						( (pSetting->dwFlags & DF_USEDEFAULT) ?
						(((DROPDOWNINFO *) GETOBJECTDATAPTR(pSetting)))
						->uDefaultItemIndex : NO_VALUE);

					break;

				}

			}
		}

		pTableEntry = pTableEntry->pNext;
	}

	return TRUE;
}

/*******************************************************************

	NAME:		FreeUser

	SYNOPSIS:	Frees a user buffer.  If it has a clone, frees the clone too.

********************************************************************/
BOOL FreeUser(HGLOBAL hUser)
{
	USERDATA * pUserData;

	// free user's clone if one exists
	if (pUserData = (USERDATA *) GlobalLock(hUser)) {
		if (pUserData->hClone) {
			if (GlobalFlags(pUserData->hClone))
				GlobalUnlock(pUserData->hClone);
			GlobalFree(pUserData->hClone);
		}
		GlobalUnlock(hUser);
	}
	if (GlobalFlags(hUser))
		GlobalUnlock(hUser);
	GlobalFree(hUser);

	return TRUE;
}

BOOL RemoveAllUsers(HWND hwndList)
{
	UINT nIndex,nCount = ListView_GetItemCount(hwndList);

	for (nIndex=0;nIndex<nCount;nIndex++)
		RemoveUser(hwndList,0,FALSE);

#ifdef INCL_GROUP_SUPPORT
	FreeGroupPriorityList();
#endif

	return TRUE;
}

BOOL RemoveUser(HWND hwndList,UINT nIndex,BOOL fMarkDeleted)
{
	HGLOBAL hUser;

        hUser = (HGLOBAL) LongToHandle(ListView_GetItemParm(hwndList,nIndex));
	if (!hUser) return FALSE;

	if (fMarkDeleted) {
		USERHDR UserHdr;

		if (!GetUserHeader(hUser,&UserHdr))
			return FALSE;
		if (!AddDeletedUser(&UserHdr))
			return FALSE;
	}
	
	FreeUser(hUser);
	ListView_DeleteItem(hwndList,nIndex);

        return TRUE;
}

BOOL SortUsers(VOID)
{

	ListView_Arrange(hwndUser,LVA_SORTASCENDING);

	return TRUE;
}

BOOL AddDefaultUsers(HWND hwndList)
{	
	if (!AddUser(hwndList,LoadSz(IDS_DEFAULTUSER,szSmallBuf,sizeof(szSmallBuf)),
		UT_USER)) return FALSE;
	if (!AddUser(hwndList,LoadSz(IDS_DEFAULTCOMPUTER,szSmallBuf,sizeof(szSmallBuf)),
		UT_MACHINE)) return FALSE;

	return TRUE;
}

BOOL GetUserHeader(HGLOBAL hUser,USERHDR * pUserHdr)
{
	USERDATA * pUserData;

	if (!(pUserData = (USERDATA *) GlobalLock(hUser)))
		return FALSE;

	*pUserHdr = pUserData->hdr;

	GlobalUnlock(hUser);

	return TRUE;
}

UINT GetUserImageIndex(DWORD dwUserType)
{
	return ( (dwUserType & UT_USER ?
		( (dwUserType & UF_GROUP) ? IMG_USERS : IMG_USER) :
		  (dwUserType & UF_GROUP) ? IMG_MACHINES : IMG_MACHINE ) );
}

// when a user is deleted from the main window, we can't just delete it from
// the file right away, so add the user to a list of people we've deleted.
// If/when the user saves, we'll commit the changes and delete them from the 
// file.
BOOL AddDeletedUser(USERHDR * pUserHdr)
{
        USERHDR * pTemp;

	// alloc/realloc buffer to hold copy of the user header
	if (!pDeletedUserList) {
		pDeletedUserList = (USERHDR *) GlobalAlloc(GPTR,sizeof(USERHDR));
                if (!pDeletedUserList)
                        return FALSE;   // out of memory

	} else {
	 	pTemp = (USERHDR *) GlobalReAlloc((HGLOBAL) pDeletedUserList,
			sizeof(USERHDR) * (nDeletedUserCount + 1),GMEM_ZEROINIT | GMEM_MOVEABLE);
                if (!pTemp) return FALSE;
                pDeletedUserList = pTemp;
	}


	pDeletedUserList[nDeletedUserCount] = *pUserHdr;
	nDeletedUserCount++;

        return TRUE;
}

USERHDR * GetDeletedUser(UINT nIndex)
{
	if (!pDeletedUserList || nIndex >= nDeletedUserCount)
		return NULL;
	
	return &pDeletedUserList[nIndex];
}

// when adding a user, check to see if it's on the deleted list
// and if so remove it.  (ex: add "joe", remove "joe", add "joe".
// on 2nd add, have to remove "joe" from deleted list)
VOID RemoveDeletedUser(USERHDR * pUserHdr)
{
	UINT nIndex;

	for (nIndex=0;nIndex<nDeletedUserCount;nIndex++) {
		// got a match?
		if (!lstrcmpi(pDeletedUserList[nIndex].szName,
			pUserHdr->szName) && (pDeletedUserList[nIndex].dwType ==
			pUserHdr->dwType)) {

			// move subsequent entries up one slot in the array
			nDeletedUserCount --;
			while (nIndex<nDeletedUserCount) {
				pDeletedUserList[nIndex] = pDeletedUserList[nIndex+1];
				nIndex++;
			}
		}
	}
}

VOID ClearDeletedUserList(VOID)
{
	if (pDeletedUserList)
		GlobalFree(pDeletedUserList);

	pDeletedUserList = NULL;
	nDeletedUserCount = 0;
}

// maps the localized default entries in resource ("default user",
// "default computer") to hard-coded non-localized name (".default").
// Other names are unchanged (szMappedName returned same as szUserName)
VOID MapUserName(CHAR * szUserName,CHAR * szMappedName)
{
	if (!lstrcmpi(szUserName,LoadSz(IDS_DEFAULTUSER,szSmallBuf,
		sizeof(szSmallBuf))) ||
		!lstrcmpi(szUserName,LoadSz(IDS_DEFAULTCOMPUTER,szSmallBuf,
		sizeof(szSmallBuf)))) {
		lstrcpy(szMappedName,szDEFAULTENTRY);
	}
	else lstrcpy(szMappedName,szUserName);

}

// unmaps the ".default" hard-coded entry to the localized text
// "default user" or "default computer"
VOID UnmapUserName(CHAR * szMappedName,CHAR * szUserName,BOOL fUser)
{

	if (!lstrcmpi(szMappedName,szDEFAULTENTRY)) {
		lstrcpy(szUserName,LoadSz( (fUser ? IDS_DEFAULTUSER :
			IDS_DEFAULTCOMPUTER),szSmallBuf,sizeof(szSmallBuf)));
	} else {
		lstrcpy(szUserName,szMappedName);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\view.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"
#include "grouppri.h"

VIEWINFO ViewInfo;
HWND hwndToolbar;
HWND hwndStatusBar;

extern UINT nFileShortcutItems;
#ifdef INCL_GROUP_SUPPORT
extern GROUPPRIENTRY * pGroupPriEntryFirst;
#endif	
VOID EnableMenuItems(HWND hwndApp,DWORD dwState)
{
	HMENU hMenu = GetMenu(hwndApp);
	BOOL fEnable;
	UINT nIndex;

	// enable "New" and "Open" if we can have a document (i.e. a template
	// is loaded)
	fEnable = dwState & AS_CANHAVEDOCUMENT;
	EnableMenuItem(hMenu,IDM_NEW,(fEnable ? MF_ENABLED : MF_GRAYED));
	SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_NEW,MAKELONG(fEnable,0));
	EnableMenuItem(hMenu,IDM_OPEN,(fEnable ? MF_ENABLED : MF_GRAYED));
	SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_OPEN,MAKELONG(fEnable,0));

	for (nIndex=0;nIndex < nFileShortcutItems; nIndex++)
		EnableMenuItem(hMenu,IDM_FILEHISTORY+nIndex,
			(fEnable ? MF_ENABLED : MF_GRAYED));

	// enable "Open Registry" if we can have a document, and if it's not already
	// open
	fEnable = ((dwState & AS_CANHAVEDOCUMENT) && !(dwState & AS_LOCALREGISTRY));
	EnableMenuItem(hMenu,IDM_OPENREGISTRY,(fEnable ? MF_ENABLED : MF_GRAYED));

	// enable "Save" and "Close" if we have a policy file or registry open
	fEnable = dwState & AS_FILELOADED;
	EnableMenuItem(hMenu,IDM_SAVE,( fEnable ? MF_ENABLED : MF_GRAYED));
	SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_SAVE,MAKELONG(fEnable,0));
	EnableMenuItem(hMenu,IDM_CLOSE,(fEnable ? MF_ENABLED : MF_GRAYED));

	// enable "Save As", "Add User", "Add Workstation", if we have a policy file
	// but not if we're directly editing a registry
	fEnable = ((dwState & AS_FILELOADED) && (dwState & AS_POLICYFILE));
	EnableMenuItem(hMenu,IDM_SAVEAS,(fEnable ? MF_ENABLED : MF_GRAYED));
	EnableMenuItem(hMenu,IDM_ADDUSER,(fEnable ? MF_ENABLED : MF_GRAYED));
	SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_ADDUSER,MAKELONG(fEnable,0));
	EnableMenuItem(hMenu,IDM_ADDWORKSTATION,(fEnable ? MF_ENABLED : MF_GRAYED));
	SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_ADDWORKSTATION,MAKELONG(fEnable,0));

#ifdef INCL_GROUP_SUPPORT
	EnableMenuItem(hMenu,IDM_ADDGROUP,(fEnable ? MF_ENABLED : MF_GRAYED));
	SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_ADDGROUP,MAKELONG(fEnable,0));
#endif

	// enable "Remove" if we're editing policy file and the "OK to remove" flag
	// is set (item is selected in list control)
	fEnable = ((dwState & AS_CANREMOVE) && (dwState & AS_POLICYFILE));
	EnableMenuItem(hMenu,IDM_REMOVE, (fEnable ? MF_ENABLED : MF_GRAYED));
	SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_REMOVE,MAKELONG(fEnable,0));

	// enable "Copy" and "Paste" appropriately
	fEnable = CanCopy(hwndUser);
	EnableMenuItem(hMenu,IDM_COPY, (fEnable ? MF_ENABLED : MF_GRAYED));
	fEnable = CanPaste(hwndUser);
	EnableMenuItem(hMenu,IDM_PASTE, (fEnable ? MF_ENABLED : MF_GRAYED));

	// enable "Properties" the "OK to remove" flag
	// is set (item is selected in list control)
	fEnable = (dwState & AS_CANREMOVE);
	EnableMenuItem(hMenu,IDM_PROPERTIES, (fEnable ? MF_ENABLED : MF_GRAYED));

#ifdef INCL_GROUP_SUPPORT
	// enable "Group priority..." if any group priority items in list
	EnableMenuItem(hMenu,IDM_GROUPPRIORITY, (pGroupPriEntryFirst ?
		MF_ENABLED : MF_GRAYED));
#endif

}

VOID CheckMenuItems(HWND hwndApp)
{
	HMENU hMenu = GetMenu(hwndApp);

        if (hMenu)
        {
            // update the menu item checkmarks
            CheckMenuItem(hMenu,IDM_TOOLBAR,MF_BYCOMMAND | (ViewInfo.fToolbar ?
                    MF_CHECKED : MF_UNCHECKED));
            CheckMenuItem(hMenu,IDM_STATUSBAR,MF_BYCOMMAND | (ViewInfo.fStatusBar ?
                    MF_CHECKED : MF_UNCHECKED));
        }
}

VOID CheckViewItem(HWND hwndApp,DWORD dwView)
{
	HMENU hMenu = GetMenu(hwndApp);
	UINT uCmd;

	switch (dwView) {
		case VT_LARGEICONS:
			uCmd = IDM_LARGEICONS;
			break;
		case VT_SMALLICONS:
			uCmd = IDM_SMALLICONS;
			break;
		case VT_LIST:
			uCmd = IDM_LIST;
			break;
		case VT_REPORT:
			uCmd = IDM_DETAILS;
			break;
		default:
			return;

	}

	CheckMenuRadioItem(hMenu, IDM_LARGEICONS, IDM_DETAILS,
	                 uCmd, MF_BYCOMMAND);
}

VOID SetNewView(HWND hwndApp,HWND hwndList,DWORD dwNewView)
{
	ViewInfo.dwView = dwNewView;
	SetViewType(hwndList,ViewInfo.dwView);
	CheckViewItem(hwndApp,ViewInfo.dwView);
}

VOID SetTitleBar(HWND hwndApp,CHAR * szFilename)
{
	CHAR szTitle[255+SMALLBUF];
	CHAR szAppName[SMALLBUF];
	CHAR szUntitled[SMALLBUF];
	CHAR szFormat[SMALLBUF];

	LoadSz(IDS_APPNAME,szAppName,sizeof(szAppName));
	LoadSz(IDS_TITLEFORMAT,szFormat,sizeof(szFormat));
	
	if (dwAppState & AS_LOCALREGISTRY) {
		wsprintf(szTitle,szFormat,szAppName,LoadSz(IDS_LOCALREGISTRY,szSmallBuf,
			sizeof(szSmallBuf)));
	} else if (dwAppState & AS_REMOTEREGISTRY) {

                if (szFilename) {
                    CHAR szMsg[SMALLBUF+COMPUTERNAMELEN+1];

                    wsprintf(szMsg,LoadSz(IDS_REGISTRYON,szSmallBuf,sizeof(szSmallBuf)),
                            szFilename);
                    wsprintf(szTitle,szFormat,szAppName,szMsg);
                } else {
                    lstrcpy(szTitle,szAppName);
                }
	} else if (szFilename) {
		// make a title a la "AdminConfig - <filename>".  If no filename yet,
		// use "(untitled)".
		wsprintf(szTitle,szFormat,szAppName,(lstrlen(szFilename) ? szFilename :
			LoadSz(IDS_UNTITLED,szUntitled,sizeof(szUntitled))));
	} else {
	 	lstrcpy(szTitle,szAppName);
	}

	// Set the window text
	SetWindowText(hwndApp,szTitle);
}

/*******************************************************************

	NAME:		InitToolbar

	SYNOPSIS:	Creates and initializes toolbar and status bar

	ENTRY:		HWND of main window

********************************************************************/
BOOL InitToolbar(HWND hWnd)
{
    int border[3];

	TBBUTTON tbButtons[] = {
		{ 6, IDM_NEW,		TBSTATE_ENABLED, TBSTYLE_BUTTON,  	0},
	    { 7, IDM_OPEN,  	TBSTATE_ENABLED, TBSTYLE_BUTTON,	0},
		{ 8, IDM_SAVE,		0, TBSTYLE_BUTTON,	0},
		{ 0, 0,				TBSTATE_ENABLED, TBSTYLE_SEP,		0},
		{ 0, IDM_ADDUSER,	0, TBSTYLE_BUTTON,0},
#ifdef INCL_GROUP_SUPPORT
		{ 2, IDM_ADDGROUP,	0, TBSTYLE_BUTTON,0},
#endif
		{ 1, IDM_ADDWORKSTATION,0, TBSTYLE_BUTTON,0},
		{ 5, IDM_REMOVE,	0, TBSTYLE_BUTTON,0} };

	RECT rc;
	TBADDBITMAP ab;
	int nStdBtnOffset;
	/* create Tool Bar */
	hwndToolbar = CreateWindowEx (WS_EX_TOOLWINDOW,szToolbarClass,szNull,
		(ViewInfo.fToolbar ? WS_VISIBLE : 0) | WS_CHILD | TBSTYLE_TOOLTIPS | WS_CLIPSIBLINGS,
		0,0,100,30,hWnd,0,ghInst,NULL);

	if (!hwndToolbar) {
		MsgBox(hWnd,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	// this tells the toolbar what version we are
	SendMessage(hwndToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

	ab.hInst = HINST_COMMCTRL;	// take them from commctrl
	ab.nID   = IDB_STD_SMALL_COLOR;	// standard toolbar images
	SendMessage(hwndToolbar, TB_ADDBITMAP, 0, (LPARAM)&ab);

	ab.hInst = ghInst;	// take them from our instance
	ab.nID   = IDB_TOOLBAR;
	nStdBtnOffset = (int) SendMessage(hwndToolbar, TB_ADDBITMAP, 3, (LPARAM)&ab);

	tbButtons[4].iBitmap = nStdBtnOffset + 0;
#ifdef INCL_GROUP_SUPPORT
	tbButtons[5].iBitmap = nStdBtnOffset + 2;
	tbButtons[6].iBitmap = nStdBtnOffset + 1;
#else
	tbButtons[5].iBitmap = nStdBtnOffset + 1;
#endif
	// add buttons
	SendMessage(hwndToolbar,TB_ADDBUTTONS,sizeof(tbButtons)/sizeof(TBBUTTON),
		(LPARAM) tbButtons);

	GetClientRect( hwndToolbar, &rc );
	ViewInfo.dyToolbar = rc.bottom+1;

	/* create Status Bar */
	hwndStatusBar = CreateStatusWindow( WS_CHILD | CCS_NOHILITE |
		SBARS_SIZEGRIP | (ViewInfo.fStatusBar ? WS_VISIBLE : 0),
		 szNull, hWnd, IDC_STATUSBAR );

	if (!hwndStatusBar) {
		MsgBox(hWnd,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
		return FALSE;
	}

	// set the border spacing
	border[0] = 0;
    border[1] = -1;
    border[2] = 2;
    SendMessage(hwndStatusBar, SB_SETBORDERS, 0, (LPARAM)(LPINT)border);

	GetClientRect( hwndStatusBar, &rc );
	ViewInfo.dyStatusBar = rc.bottom;

	return TRUE;
}

/*******************************************************************

	NAME:		DeInitToolbar

	SYNOPSIS:	Destroys toolbar and status bar

********************************************************************/
VOID DeInitToolbar(VOID)
{
	if (hwndToolbar) DestroyWindow(hwndToolbar);
	if (hwndStatusBar) DestroyWindow(hwndStatusBar);
}

/*******************************************************************

	NAME:		ProcessTooltips

	SYNOPSIS:	Loads appropriate tip resource string and copies it into
				buffer.

********************************************************************/
BOOL ProcessTooltips(TOOLTIPTEXT * pttt)
{

	if (!pttt->hdr.idFrom) {
		lstrcpy(pttt->szText,szNull);
		return FALSE;
	}

	lstrcpy(pttt->szText,LoadSz(IDS_TIPS + (UINT)pttt->hdr.idFrom,szSmallBuf,
		sizeof(szSmallBuf)));

	return TRUE;
}

BOOL ReplaceMenuItem(HWND hWnd,UINT idOld,UINT idNew,UINT idResourceTxt)
{

	MENUITEMINFO mii;
	HMENU hMenu = GetMenu(hWnd);

	if (!hMenu) return FALSE;

	memset(&mii,0,sizeof(mii));
	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_DATA;
	mii.fType = MFT_STRING;
	mii.wID = idNew;
	mii.dwTypeData = (LPSTR) LoadSz(idResourceTxt,szSmallBuf,sizeof(szSmallBuf));
	mii.cch = lstrlen(mii.dwTypeData);
	if (InsertMenuItem(hMenu,idOld,FALSE,&mii)) {
		RemoveMenu(hMenu,idOld,MF_BYCOMMAND);
	}

	DrawMenuBar(hWnd);

	return TRUE;
}

VOID SetStatusText(CHAR * pszText)
{
	// if NULL pointer, set to null string ("")
	if (!pszText)
		pszText = (CHAR *) szNull;

	if (hwndStatusBar) {
		SendMessage(hwndStatusBar,WM_SETTEXT,0,(LPARAM) pszText);
	 	UpdateWindow(hwndStatusBar);
	}	
}

VOID GetStatusText(CHAR * pszText,UINT cbText)
{
	if (!pszText)
		return;

	if (hwndStatusBar)
		SendMessage(hwndStatusBar,WM_GETTEXT,cbText,(LPARAM) pszText);
}

VOID SetStatusItemCount(HWND hwndList)
{
	UINT nCount = ListView_GetItemCount(hwndList);

	if (nCount > 1) {
		CHAR szStatusText[SMALLBUF];
		wsprintf(szStatusText,LoadSz(IDS_ENTRIES,szSmallBuf,sizeof(szSmallBuf))
			,nCount);
		SetStatusText(szStatusText);
	} else {
		SetStatusText(LoadSz( (nCount == 0 ? IDS_NOENTRIES : IDS_ONEENTRY),
			szSmallBuf,sizeof(szSmallBuf)));
 	}
}

VOID AddFileShortcut(HMENU hMenu,CHAR * pszNewFilename)
{
	MENUITEMINFO mii;
	CHAR szFilename[MAX_PATH+1];
	UINT nIndex;

	memset(&mii,0,sizeof(mii));
	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_TYPE;
	mii.fType = MFT_STRING;
	mii.dwTypeData = szFilename;
	mii.cch = sizeof(szFilename);

	// see if there is an existing shortcut with this name
	for (nIndex = 0;nIndex<nFileShortcutItems;nIndex++) {
		mii.cch = sizeof(szFilename);
		if (GetMenuItemInfo(hMenu,IDM_FILEHISTORY+nIndex,
			FALSE,&mii) && !lstrcmpi(szFilename,pszNewFilename))
			return; // already has a shortcut menu item, nothing to do
	}

	// add another menu item if we have less than max shorcuts
	if (nFileShortcutItems < FILEHISTORY_COUNT) {
		MENUITEMINFO miiTmp;
		memset(&miiTmp,0,sizeof(miiTmp));
		miiTmp.cbSize = sizeof(miiTmp);

		// add a separator if this is first shortcut item
		if (!nFileShortcutItems) {
			miiTmp.fMask = MIIM_TYPE;
			miiTmp.fType = MFT_SEPARATOR;
			InsertMenuItem(hMenu,GetMenuItemCount(hMenu),TRUE,&miiTmp);
		}

		// add a menu item with empty string, string will get set below
		miiTmp.fType = MFT_STRING;
		miiTmp.wID = IDM_FILEHISTORY + nFileShortcutItems;
		miiTmp.fMask = MIIM_TYPE | MIIM_ID;
		miiTmp.dwTypeData = (LPSTR) szNull;
		mii.cch = 1;
		InsertMenuItem(hMenu,GetMenuItemCount(hMenu),TRUE,&miiTmp);

		nFileShortcutItems ++;
	}

	// move existing items down one slot to make new one most recent
	if (nFileShortcutItems) {
		for (nIndex=nFileShortcutItems-1;nIndex > 0;nIndex --) {
			mii.cch = sizeof(szFilename);
			if (GetMenuItemInfo(hMenu,IDM_FILEHISTORY+nIndex-1,
				FALSE,&mii))
				SetMenuItemInfo(hMenu,IDM_FILEHISTORY+nIndex,
					FALSE,&mii);
	 	}
	}

	lstrcpy(szFilename,pszNewFilename);
	mii.cch = lstrlen(szFilename);
	SetMenuItemInfo(hMenu,IDM_FILEHISTORY,
		FALSE,&mii);

}

VOID SetViewType(HWND hwndList,DWORD dwView)
{
	DWORD dwStyle;
	
	switch (dwView) {
		case VT_LARGEICONS:
			dwStyle = LVS_ICON;
			break;
		case VT_SMALLICONS:
			dwStyle = LVS_SMALLICON;
			break;
		case VT_LIST:
			dwStyle = LVS_LIST;
			break;
		case VT_REPORT:
			dwStyle = LVS_REPORT;
			break;

		default:
			return;	// invalid dwView constant					
	}

	// set the window style to change the view type
	SetWindowLong(hwndList,GWL_STYLE,
		(GetWindowLong(hwndList,GWL_STYLE) & ~LVS_TYPEMASK) | dwStyle);
	ListView_Arrange(hwndList,LVA_SORTASCENDING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\util.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"
#include <stdlib.h>

// global small buffer for general use
TCHAR szSmallBuf[SMALLBUF];

BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable)
{
    return EnableWindow(GetDlgItem(hDlg,uID),fEnable);
}

BOOL IsDlgItemEnabled(HWND hDlg,UINT uID)
{
    return IsWindowEnabled(GetDlgItem(hDlg,uID));
}

int MsgBox(HWND hWnd,UINT nResource,UINT uIcon,UINT uButtons)
{
    TCHAR szMsgBuf[REGBUFLEN];

    LoadSz(IDS_APPNAME,szSmallBuf,ARRAYSIZE(szSmallBuf));
    LoadSz(nResource,szMsgBuf,ARRAYSIZE(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    LoadSz(IDS_APPNAME,szSmallBuf,ARRAYSIZE(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

int MsgBoxParam(HWND hWnd,UINT nResource,TCHAR * szReplaceText,UINT uIcon,
	UINT uButtons)
{
#if 1
    TCHAR szFormat[REGBUFLEN];
    LPTSTR lpMsgBuf;
    INT iResult;

    lpMsgBuf = (LPTSTR) LocalAlloc (LPTR, (lstrlen(szReplaceText) + 1 + REGBUFLEN) * sizeof(TCHAR));

    if (!lpMsgBuf)
    {
        return 0;
    }

    LoadSz(nResource,szFormat,ARRAYSIZE(szFormat));

    wsprintf(lpMsgBuf,szFormat,szReplaceText);

    iResult = MsgBoxSz(hWnd,lpMsgBuf,uIcon,uButtons);

    LocalFree (lpMsgBuf);

    return iResult;
#else

        //
        // szReplaceText can be REGBUFLEN+1 + sizeof(szFormat) (also REGBUFLEN),
        // so szMsgBuf must be sizeof(szReplaceText) + sizeof(szFormat).
        //
        TCHAR szMsgBuf[(REGBUFLEN+1) * 2],szFormat[REGBUFLEN];

	LoadSz(nResource,szFormat,ARRAYSIZE(szFormat));
	wsprintf(szMsgBuf,szFormat,szReplaceText);
	return (MsgBoxSz(hWnd,szMsgBuf,uIcon,uButtons));
#endif
}

LONG AddListboxItem(HWND hDlg,int idControl,TCHAR * szItem)
{
	return (LONG)(SendDlgItemMessage(hDlg,idControl,LB_ADDSTRING,0,
		(LPARAM) szItem));
}

LONG GetListboxItemText(HWND hDlg,int idControl,UINT nIndex,TCHAR * szText)
{
	return (LONG)(SendDlgItemMessage(hDlg,idControl,LB_GETTEXT,(WPARAM) nIndex,
		(LPARAM) szText));
}

LONG SetListboxItemData(HWND hDlg,int idControl,UINT nIndex,LPARAM dwData)
{
	return (LONG)(SendDlgItemMessage(hDlg,idControl,LB_SETITEMDATA,(WPARAM) nIndex,
		dwData));
}

LONG GetListboxItemData(HWND hDlg,int idControl,UINT nIndex)
{
	return (LONG)(SendDlgItemMessage(hDlg,idControl,LB_GETITEMDATA,(WPARAM) nIndex,
		0L));
}

LONG SetListboxSelection(HWND hDlg,int idControl,UINT nIndex)
{
	return (LONG)(SendDlgItemMessage(hDlg,idControl,LB_SETCURSEL,(WPARAM) nIndex,
		0L));
}

LONG GetListboxSelection(HWND hDlg,int idControl)
{
	return (LONG)(SendDlgItemMessage(hDlg,idControl,LB_GETCURSEL,0,
		0L));
}

TCHAR * ResizeBuffer(TCHAR *pBuf,HGLOBAL hBuf,DWORD dwNeeded,DWORD * pdwCurSize)
{
	TCHAR * pNew;

	if (dwNeeded <= *pdwCurSize) return pBuf; // nothing to do
	*pdwCurSize = dwNeeded;

	GlobalUnlock(hBuf);

	if (!GlobalReAlloc(hBuf,dwNeeded * sizeof(TCHAR),GHND))
		return NULL;

	if (!(pNew = (TCHAR *) GlobalLock(hBuf))) return NULL;

	return pNew;
}

LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = TEXT('\0');
        LoadString( ghInst, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

DWORD RoundToDWord(DWORD dwSize)
{
	DWORD dwResult = dwSize;

	if ( dwResult % sizeof(DWORD)) dwResult += (sizeof(DWORD) -
		dwResult % sizeof(DWORD));
	
	return dwResult;
}

/*******************************************************************

	NAME:		MyRegDeleteKey

	SYNOPSIS:	This does what RegDeleteKey should do, which is delete
				keys that have subkeys.  Unfortunately, NT jumped off
				the empire state building and we have to jump off after
				them, so RegDeleteKey will (one day, I'm told) puke on
				keys that have subkeys.  This fcn enums them and recursively
				deletes the leaf keys.

	NOTES:		This algorithm goes against the spirit of what's mentioned
				in the SDK, which is "don't mess with a key that you're enuming",
				since it deletes keys during an enum.  However, MarcW the
				registry guru says that this is the way to do it.  The alternative,
				I suppose, is to allocate buffers and enum all the subkeys into
				the buffer, close the enum and go back through the buffer
				elminating the subkeys.  But since you have to do this recursively,
				you would wind up allocating a lot of buffers.
				

********************************************************************/
LONG MyRegDeleteKey(HKEY hkey,LPTSTR pszSubkey)
{
	TCHAR szSubkeyName[MAX_PATH+1];
	HKEY hkeySubkey;
	UINT uRet;

	uRet = RegOpenKey(hkey,pszSubkey,&hkeySubkey);
	if (uRet != ERROR_SUCCESS)
		return uRet;
	
	// best algorithm according to marcw: keep deleting zeroth subkey till
	// there are no more
	while (RegEnumKey(hkeySubkey,0,szSubkeyName,ARRAYSIZE(szSubkeyName))
		== ERROR_SUCCESS && (uRet == ERROR_SUCCESS)) {
		uRet=MyRegDeleteKey(hkeySubkey,szSubkeyName);
	}

	RegCloseKey(hkeySubkey);
	if (uRet != ERROR_SUCCESS)
		return uRet;

	return RegDeleteKey(hkey,pszSubkey);
}

//*************************************************************
//
//  MyRegLoadKey()
//
//  Purpose:    Loads a hive into the registry
//
//  Parameters: hKey        -   Key to load the hive into
//              lpSubKey    -   Subkey name
//              lpFile      -   hive filename
//
//  Return:     ERROR_SUCCESS if successful
//              Error number if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/22/95     ericflo    Created
//
//*************************************************************

LONG MyRegLoadKey(HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpFile)

{
    HANDLE hToken;
    LUID luid;
    DWORD dwSize = 1024;
    PTOKEN_PRIVILEGES lpPrevPrivilages;
    TOKEN_PRIVILEGES tp;
    LONG error;


    if (g_bWinnt) {
        //
        // Allocate space for the old privileges
        //

        lpPrevPrivilages = GlobalAlloc(GPTR, dwSize);

        if (!lpPrevPrivilages) {
            return GetLastError();
        }


        if (!OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
             return GetLastError();
        }

        LookupPrivilegeValue( NULL, SE_RESTORE_NAME, &luid );

        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luid;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        if (!AdjustTokenPrivileges( hToken, FALSE, &tp,
             dwSize, lpPrevPrivilages, &dwSize )) {

            if (GetLastError() == ERROR_MORE_DATA) {
                PTOKEN_PRIVILEGES lpTemp;

                lpTemp = GlobalReAlloc(lpPrevPrivilages, dwSize, GMEM_MOVEABLE);

                if (!lpTemp) {
                    GlobalFree (lpPrevPrivilages);
                    return GetLastError();
                }

                lpPrevPrivilages = lpTemp;

                if (!AdjustTokenPrivileges( hToken, FALSE, &tp,
                     dwSize, lpPrevPrivilages, &dwSize )) {
                    return GetLastError();
                }

            } else {
                return GetLastError();
            }

        }
    }

    //
    // Load the hive
    //

    error = RegLoadKey(hKey, lpSubKey, lpFile);


    if (g_bWinnt) {
        AdjustTokenPrivileges( hToken, FALSE, lpPrevPrivilages,
                               0, NULL, NULL );

        CloseHandle (hToken);
    }

    return error;
}


//*************************************************************
//
//  MyRegUnLoadKey()
//
//  Purpose:    Unloads a registry key
//
//  Parameters: hKey          -  Registry handle
//              lpSubKey      -  Subkey to be unloaded
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Ported
//
//*************************************************************

LONG MyRegUnLoadKey(HKEY hKey, LPCTSTR lpSubKey)
{
    HANDLE hToken;
    LUID luid;
    DWORD dwSize = 1024;
    PTOKEN_PRIVILEGES lpPrevPrivilages;
    TOKEN_PRIVILEGES tp;
    LONG error;


    if (g_bWinnt) {
        //
        // Allocate space for the old privileges
        //

        lpPrevPrivilages = GlobalAlloc(GPTR, dwSize);

        if (!lpPrevPrivilages) {
            return GetLastError();
        }


        if (!OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
             return GetLastError();
        }

        LookupPrivilegeValue( NULL, SE_RESTORE_NAME, &luid );

        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luid;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        if (!AdjustTokenPrivileges( hToken, FALSE, &tp,
             dwSize, lpPrevPrivilages, &dwSize )) {

            if (GetLastError() == ERROR_MORE_DATA) {
                PTOKEN_PRIVILEGES lpTemp;

                lpTemp = GlobalReAlloc(lpPrevPrivilages, dwSize, GMEM_MOVEABLE);

                if (!lpTemp) {
                    GlobalFree (lpPrevPrivilages);
                    return GetLastError();
                }

                lpPrevPrivilages = lpTemp;

                if (!AdjustTokenPrivileges( hToken, FALSE, &tp,
                     dwSize, lpPrevPrivilages, &dwSize )) {
                    return GetLastError();
                }

            } else {
                return GetLastError();
            }

        }
    }

    //
    // Unload the hive
    //

    error = RegUnLoadKey(hKey, lpSubKey);


    if (g_bWinnt) {
        AdjustTokenPrivileges( hToken, FALSE, lpPrevPrivilages,
                               0, NULL, NULL );

        CloseHandle (hToken);
    }

    return error;
}

//*************************************************************
//
//  MyRegSaveKey()
//
//  Purpose:    Saves a registry key
//
//  Parameters: hKey          -  Registry handle
//              lpSubKey      -  Subkey to be unloaded
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error number if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Ported
//
//*************************************************************

LONG MyRegSaveKey(HKEY hKey, LPCTSTR lpSubKey)
{

    HANDLE hToken;
    LUID luid;
    DWORD dwSize = 1024;
    PTOKEN_PRIVILEGES lpPrevPrivilages;
    TOKEN_PRIVILEGES tp;
    LONG error;


    if (g_bWinnt) {
        //
        // Allocate space for the old privileges
        //

        lpPrevPrivilages = GlobalAlloc(GPTR, dwSize);

        if (!lpPrevPrivilages) {
            return GetLastError();
        }


        if (!OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
             return GetLastError();
        }

        LookupPrivilegeValue( NULL, SE_BACKUP_NAME, &luid );

        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luid;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        if (!AdjustTokenPrivileges( hToken, FALSE, &tp,
             dwSize, lpPrevPrivilages, &dwSize )) {

            if (GetLastError() == ERROR_MORE_DATA) {
                PTOKEN_PRIVILEGES lpTemp;

                lpTemp = GlobalReAlloc(lpPrevPrivilages, dwSize, GMEM_MOVEABLE);

                if (!lpTemp) {
                    GlobalFree (lpPrevPrivilages);
                    return GetLastError();
                }

                lpPrevPrivilages = lpTemp;

                if (!AdjustTokenPrivileges( hToken, FALSE, &tp,
                     dwSize, lpPrevPrivilages, &dwSize )) {
                    return GetLastError();
                }

            } else {
                return GetLastError();
            }

        }
    }

    //
    // Save the hive
    //

    error = RegSaveKey(hKey, lpSubKey, NULL);


    if (g_bWinnt) {
        AdjustTokenPrivileges( hToken, FALSE, lpPrevPrivilages,
                               0, NULL, NULL );

        CloseHandle (hToken);
    }

    return error;
}

/*******************************************************************

	NAME:		StringToNum

	SYNOPSIS:	Converts string value to numeric value

	NOTES:		Calls atoi() to do conversion, but first checks
				for non-numeric characters

	EXIT:		Returns TRUE if successful, FALSE if invalid
				(non-numeric) characters

********************************************************************/
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal)
{
	TCHAR *pTst = pszStr;

	if (!pszStr) return FALSE;

	// verify that all characters are numbers
	while (*pTst) {
		if (!(*pTst >= TEXT('0') && *pTst <= TEXT('9'))) {
                   if (*pTst != TEXT('-'))
		       return FALSE;
		}
		pTst = CharNext(pTst);
	}

	*pnVal = atoi(pszStr);

	return TRUE;
}

DWORD ListView_GetItemParm( HWND hwnd, int i )
{
	LV_ITEM lvi;

	lvi.mask = LVIF_PARAM;
	lvi.iItem = i;
	lvi.iSubItem = 0;
	lvi.state = (UINT)-1;
	lvi.lParam = 0L;
	ListView_GetItem (  hwnd, &lvi );
	return (DWORD)lvi.lParam;
}

VOID DisplayStandardError(HWND hwndOwner,TCHAR * pszParam,UINT uMsgID,UINT uErr)
{
	TCHAR szError[256],szMsg[512+MAX_PATH+1],szFmt[256];

	if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
		uErr,0,szError,ARRAYSIZE(szError),NULL)) {
		// if getting system text fails, make a string a la
		// "error <n> occurred"
		LoadSz(IDS_ERRFORMAT,szFmt,ARRAYSIZE(szFmt));
		wsprintf(szError,szFmt,uErr);
	}

	LoadSz(uMsgID,szFmt,ARRAYSIZE(szFmt));
	if (pszParam) {
		wsprintf(szMsg,szFmt,pszParam,szError);
	} else {
		wsprintf(szMsg,szFmt,szError);
	}
	
	MsgBoxSz(hwndOwner,szMsg,MB_ICONEXCLAMATION,MB_OK);
}

#ifdef DEBUG
CHAR szDebugOut[255];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\view.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#ifndef _VIEW_H_
#define _VIEW_H_

// constants for dwView member
#define VT_SMALLICONS	0x01
#define VT_LARGEICONS	0x02
#define VT_LIST			0x03
#define VT_REPORT		0x04

typedef struct tagVIEWINFO {
	BOOL 	fToolbar;
	BOOL 	fStatusBar;
	UINT	dyToolbar;
	UINT	dyStatusBar;
	DWORD   dwView;
} VIEWINFO;

extern VIEWINFO ViewInfo;

// Toolbar variables
extern HWND hwndToolbar;

// Status bar variables
extern HWND hwndStatusBar;	

BOOL InitToolbar(HWND hWnd);
VOID DeInitToolbar(VOID);
BOOL ProcessTooltips(TOOLTIPTEXT * pttt);

#endif	_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\polsetup\polsetup.c ===
//*************************************************************
//  File name: POLSETUP.C
//
//  Description:  Uninstall program for the Policy Editor
//
//  Command Line Options:
//
//          No options installs the policy editor
//      -u  Uninstalls the policy editor
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <windows.h>

//
// Platform specific command lines
//

#define NT_INST_CMD    TEXT("rundll32 syssetup.dll,SetupInfObjectInstallAction DefaultInstall 132 %s")
#define WIN_INST_CMD   TEXT("rundll setupx.dll,InstallHinfSection DefaultInstall 132 %s")

#define NT_UNINST_CMD  TEXT("rundll32 syssetup.dll,SetupInfObjectInstallAction POLEDIT_remove 4 poledit.inf")
#define WIN_UNINST_CMD TEXT("rundll setupx.dll,InstallHinfSection POLEDIT_remove 4 poledit.inf")


//
// ParseCmdLine
//
// Returns TRUE for uninstall
//         FALSE for normal install
//

BOOL ParseCmdLine(LPCTSTR lpCmdLine)
{

    while( *lpCmdLine && *lpCmdLine != TEXT('-') && *lpCmdLine != TEXT('/')) {
        lpCmdLine++;
    }

    if (!(*lpCmdLine)) {
        return FALSE;
    }

    lpCmdLine++;

    if ( (*lpCmdLine == TEXT('u')) || (*lpCmdLine == TEXT('U')) ) {
        return TRUE;
    }

    return FALSE;
}



int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;
    TCHAR szCmdLine[MAX_PATH + MAX_PATH];
    OSVERSIONINFO ver;
    BOOL bNT, bUninstall = FALSE;
    TCHAR szPoleditInf[MAX_PATH];
    LPTSTR lpFileName;


    //
    // Determine if we are running on Windows NT
    //

    ver.dwOSVersionInfoSize = sizeof(ver);
    if (GetVersionEx(&ver)) {
        bNT = (ver.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        bNT = FALSE;
    }


    //
    // Parse command line
    //

    if (ParseCmdLine(GetCommandLine())) {
        bUninstall = TRUE;
    }


    //
    // Choose the correct command line
    //

    if (bUninstall) {
        if (bNT) {
            lstrcpy (szCmdLine, NT_UNINST_CMD);
        } else {
            lstrcpy (szCmdLine, WIN_UNINST_CMD);
        }
    } else {

        if (!SearchPath (NULL, TEXT("poledit.inf"), NULL, MAX_PATH,
                    szPoleditInf, &lpFileName)) {
            return 1;
        }

        if (bNT) {
            wsprintf (szCmdLine, NT_INST_CMD, szPoleditInf);
        } else {
            wsprintf (szCmdLine, WIN_INST_CMD, szPoleditInf);
        }
    }


    //
    // Spawn the real setup program
    //

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = NULL;
    si.lpDesktop = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWNORMAL;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;


    if (CreateProcess(NULL, szCmdLine, NULL, NULL, FALSE,
                      NORMAL_PRIORITY_CLASS, NULL, NULL,
                      &si, &ProcessInformation)) {

        WaitForSingleObject(ProcessInformation.hProcess, 30000);
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
        return 0;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\policy\poledit\wizard.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1993                    **
//*********************************************************************

#include "admincfg.h"

extern HIMAGELIST hImageListSmall;
HWND hwndUserList;
CHAR gszName[MAXSTRLEN];
BOOL gfMaintenance;

//-----------------------------------------------------------------------
// Function: AddPage(lphPages,lpwCount,id,pfn,lpsi)
//
// Action: Add a property sheet page to the list of pages to display.
//
// Return: TRUE if page was added, FALSE if not
//-----------------------------------------------------------------------
BOOL NEAR PASCAL AddPage(HPROPSHEETPAGE *lphPages,
                         UINT           *lpwCount,
                         UINT            id,
                         DLGPROC         pfn,
                         HWND            hwndUser)
{
	PROPSHEETPAGE psp;

    memset(&psp,0,sizeof(PROPSHEETPAGE));

    if(NUM_WIZARD_PAGES > *lpwCount)
    {
	    psp.dwSize = sizeof(psp);
	    psp.dwFlags = PSP_DEFAULT;
	    psp.hInstance = ghInst;
	    psp.pszTemplate = MAKEINTRESOURCE(id);
	    psp.pfnDlgProc = pfn;
        psp.lParam = (LPARAM)hwndUser;

        // Use release function for the first page only. This means it
        // always gets called exactly once if any of our pages are visited,
        if(!*lpwCount)
        {
            psp.dwFlags |= PSP_USECALLBACK;
        }

        lphPages[*lpwCount] = CreatePropertySheetPage(&psp);
        if(lphPages[*lpwCount])
        {
            (*lpwCount)++;
            return TRUE;
        }
    }

    return FALSE;
}
/*******************************************************************

	NAME:		BeginEndDlgProc

	SYNOPSIS:	Generic dialog proc for the beginning and ending wizard pages

********************************************************************/
BOOL CALLBACK BeginEndDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	
	LPPROPSHEETPAGE lpsp;

	lpsp = (LPPROPSHEETPAGE)GetWindowLong(hDlg,DWL_USER);

	switch (uMsg) {

		case WM_INITDIALOG:

			{
				// get propsheet page struct passed in
				lpsp = (LPPROPSHEETPAGE) lParam;

				// store pointer to private page info in window data for later
                SetWindowLong(hDlg,DWL_USER,lParam);
				return TRUE;
			}
			break;	// WM_INITDIALOG
				  	
	 	case WM_NOTIFY:

			{
				switch (((NMHDR *)lParam)->code){

					case PSN_SETACTIVE:
						// initialize 'back' and 'next' wizard buttons
						if (lpsp->pszTemplate == MAKEINTRESOURCE(IDD_INTRO_DLG))
						    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
						else if (lpsp->pszTemplate == MAKEINTRESOURCE(IDD_EXPLAIN_DLG))
						    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT | PSWIZB_BACK);
						else if (lpsp->pszTemplate == MAKEINTRESOURCE(IDD_END_DLG))
						{
							PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH |PSWIZB_BACK);
							PropSheet_CancelToClose(GetParent(hDlg));
						}
						return TRUE;
						break;

					case PSN_QUERYCANCEL:

                        SetWindowLong(hDlg,DWL_MSGRESULT,FALSE);
						return TRUE;
						break;

                    case PSN_WIZBACK:
                    	//Finish dlg goes to different place.
                        
						if (lpsp->pszTemplate == MAKEINTRESOURCE(IDD_END_DLG))
						{
						    PropSheet_SetCurSel(GetParent(hDlg),NULL, I_USER_DLG);
                            SetWindowLong(hDlg,DWL_MSGRESULT, IDD_USER_DLG);
                            return TRUE;
                        }

				}
			}
			break;

	}

	return FALSE;
}

/****************************************************************************\
 *
 *	NAME:		RestDlgProc
 *
 *	SYNOPSIS:	Generic dialog proc for the beginning and ending wizard pages
 *
\****************************************************************************/
BOOL CALLBACK RestDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	
	LPPROPSHEETPAGE lpsp;

	lpsp = (LPPROPSHEETPAGE)GetWindowLong(hDlg,DWL_USER);

	switch (uMsg) {

		case WM_INITDIALOG:

			{
				// get propsheet page struct passed in
				lpsp = (LPPROPSHEETPAGE) lParam;

				// store pointer to private page info in window data for later
                SetWindowLong(hDlg,DWL_USER,lParam);

				// initialize 'back' and 'next' wizard buttons, if
				// page wants something different it can fix in init proc below

				PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT | PSWIZB_BACK);

				return TRUE;
			}
			break;	// WM_INITDIALOG
				  	
	 	case WM_NOTIFY:

			{
				switch (((NMHDR *)lParam)->code){

					case PSN_SETACTIVE:
						// initialize 'back' and 'next' wizard buttons
						PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT | PSWIZB_BACK);

						return TRUE;
						break;

					case PSN_QUERYCANCEL:

                        SetWindowLong(hDlg,DWL_MSGRESULT,FALSE);
						return TRUE;
						break;
				}
			}
			break;

	}

	return FALSE;
}

/*******************************************************************

	NAME:		MainDlgProc


********************************************************************/
BOOL CALLBACK MainDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	
	LPPROPSHEETPAGE lpsp;
	USERHDR UserHdr;
	HGLOBAL hUser;

	lpsp = (LPPROPSHEETPAGE)GetWindowLong(hDlg,DWL_USER);

	switch (uMsg) {

		case WM_INITDIALOG:

			{
				// get propsheet page struct passed in
				lpsp = (LPPROPSHEETPAGE) lParam;

				// store pointer to private page info in window data for later
                SetWindowLong(hDlg,DWL_USER,lParam);

				hUser = FindUser((HWND)lpsp->lParam,gszName,UT_USER);

				if (!hUser || !GetUserHeader(hUser,&UserHdr)) {
				 		MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
 		                return FALSE;
	            }

			    PropSheet_SetTitle(GetParent(hDlg), PSH_PROPTITLE, UserHdr.szName);

				// initialize 'back' and 'next' wizard buttons
				PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT | PSWIZB_BACK);

				GlobalUnlock(hUser);
				return TRUE;
			}
			break;	// WM_INITDIALOG
				  	
	 	case WM_NOTIFY:												 

			{
				switch (((NMHDR *)lParam)->code){

					case PSN_SETACTIVE:
						// initialize 'back' and 'next' wizard buttons
						PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT | PSWIZB_BACK);

						return TRUE;
						break;

					case PSN_QUERYCANCEL:

                        SetWindowLong(hDlg,DWL_MSGRESULT,FALSE);
						return TRUE;
						break;

				    case PSN_WIZBACK:
						// In maintenance mode, Back brings you to a different screen.
						if (gfMaintenance)
						{
						    SetWindowLong(hDlg,DWL_MSGRESULT,IDD_USER_DLG);
							return TRUE;
						}
						break;
				}
			}
			break;

	}

	return FALSE;
}

/****************************************************************************\
 *
 *	NAME:		UserDlgProc
 *
 *	SYNOPSIS:	Generic dialog proc for the beginning and ending wizard pages
 *
\****************************************************************************/
BOOL CALLBACK UserDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	
	LPPROPSHEETPAGE lpsp;
    USERDATA       *pUserData;
    HGLOBAL         hUser;
    UINT            i;

	lpsp = (LPPROPSHEETPAGE)GetWindowLong(hDlg,DWL_USER);

	switch (uMsg) {

		case WM_INITDIALOG:

			{
				// get propsheet page struct passed in
				lpsp = (LPPROPSHEETPAGE) lParam;

				// store pointer to private page info in window data for later
                SetWindowLong(hDlg,DWL_USER,lParam);

				PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH);
				
				// Once we're here, it's the same as maintenance mode.
				gfMaintenance = TRUE;
				return TRUE;
			}
			break;	// WM_INITDIALOG

	 	case WM_COMMAND:
			switch (wParam) {

				case IDD_USER_ADD:
				    //if (HIWORD(wParam) == BN_CLICK
				    PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
					break;

				case IDD_USER_CHANGE:
				    i = SendDlgItemMessage(hDlg, IDD_USER_LIST, LB_GETCURSEL, 0, 0L);

					if (i >= 0)
					{
					    SendDlgItemMessage(hDlg, IDD_USER_LIST, LB_GETTEXT, i, (LPARAM)gszName);
						PropSheet_SetCurSel(GetParent(hDlg),NULL, I_MAIN_DLG);
					}
					break;
			}

			break;

	 	case WM_NOTIFY:

			{
				switch (((NMHDR *)lParam)->code){

					case PSN_SETACTIVE:
						// initialize 'back' and 'next' wizard buttons
					
						SendDlgItemMessage(hDlg, IDD_USER_LIST, LB_RESETCONTENT,0,0);
						i = 0;
		                while ((hUser = (HGLOBAL) ListView_GetItemParm(hwndUser,i)) &&
		                    (pUserData = (USERDATA *) GlobalLock(hUser)))
		                { 
		                    SendDlgItemMessage(hDlg,IDD_USER_LIST, LB_ADDSTRING, 0, (LPARAM)pUserData->hdr.szName  );
		                    GlobalUnlock(hUser);
		                    i++;
		                }
                

				        PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH);

						return TRUE;
						break;

					case PSN_QUERYCANCEL:

                        SetWindowLong(hDlg,DWL_MSGRESULT,FALSE);
						return TRUE;
						break;

					case PSN_WIZFINISH:
						// save changes if user OK's the dialog
						dwAppState = AS_FILELOADED | AS_FILEHASNAME | AS_POLICYFILE | AS_FILEDIRTY;
						if (!SaveFile(szDatFilename,hDlg,(HWND)lpsp->lParam))
							dwDlgRetCode = AD_POLSAVEERR;

                        PropSheet_SetCurSel(GetParent(hDlg),NULL, I_END_DLG);
					    SetWindowLong(hDlg,DWL_MSGRESULT,IDD_END_DLG);
						return TRUE;
						break;
				}
			}
			break;

	}

	return FALSE;
}


/*******************************************************************

	NAME:		NewUserDlgProc


********************************************************************/
BOOL CALLBACK NewUserDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	
	LPPROPSHEETPAGE lpsp;
    HGLOBAL         hUser;
    UINT            nRet;
	CHAR			szName[MAXSTRLEN];

	lpsp = (LPPROPSHEETPAGE)GetWindowLong(hDlg,DWL_USER);

	switch (uMsg) {

		case WM_INITDIALOG:

			{
				// get propsheet page struct passed in
				lpsp = (LPPROPSHEETPAGE) lParam;

				// store pointer to private page info in window data for later
                SetWindowLong(hDlg,DWL_USER,lParam);

				PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT | PSWIZB_BACK);
				return TRUE;
			}
			break;	// WM_INITDIALOG

	 	case WM_NOTIFY:

			{
				switch (((NMHDR *)lParam)->code){

					case PSN_WIZNEXT:

						if (!GetDlgItemText(hDlg, IDD_NEWUSER_NAME, szName, sizeof(szName)))
                        {
                            MsgBox(hDlg, IDS_NOUSER, MB_ICONEXCLAMATION,MB_OK);
                            SetWindowLong(hDlg,DWL_MSGRESULT, -1);
                            return TRUE;
                        }
                        

						hUser = FindUser(hwndUser,szName, UT_USER);

						if ((hUser) &&
							(MsgBox(hDlg, IDS_USEREXISTS, MB_ICONEXCLAMATION, MB_YESNO) != IDYES))
						{
						    // Allow user to enter another name.
						    SetWindowLong(hDlg,DWL_MSGRESULT,-1);
				        	return TRUE;
						}

						if (!hUser) {
							hUser = AddUser(hwndUser,szName,UT_USER);
						}

						if (!hUser) {
							MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
							dwDlgRetCode = AD_OUTOFMEMORY;
							return FALSE;
						}

	                    GlobalUnlock(hUser);
                    	lstrcpy(szName, gszName);

	                    SetWindowLong(hDlg,DWL_MSGRESULT, IDD_MAIN_DLG);
						return TRUE;
						break;



					case PSN_SETACTIVE:
						// initialize 'back' and 'next' wizard buttons
				        PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT | PSWIZB_BACK);

						return TRUE;
						break;

					case PSN_QUERYCANCEL:

                        SetWindowLong(hDlg,DWL_MSGRESULT,FALSE);
						return TRUE;
						break;
				}
			}
			break;

	}

	return FALSE;
}

BOOL WINAPI DoWizard(HWND hWnd, HWND hwndUser)
{
    HPROPSHEETPAGE      hPages[NUM_WIZARD_PAGES];
    PROPSHEETHEADER     psHeader;
    int                 iRet;

	// zero out structures
    memset(&hPages,0,sizeof(hPages));
	memset(&psHeader,0,sizeof(psHeader));

    AddPage((HPROPSHEETPAGE *)&hPages, &psHeader.nPages, IDD_INTRO_DLG,   BeginEndDlgProc, hwndUser);
    AddPage((HPROPSHEETPAGE *)&hPages, &psHeader.nPages, IDD_EXPLAIN_DLG, BeginEndDlgProc, hwndUser);
    AddPage((HPROPSHEETPAGE *)&hPages, &psHeader.nPages, IDD_MAIN_DLG,    MainDlgProc, hwndUser);
    AddPage((HPROPSHEETPAGE *)&hPages, &psHeader.nPages, IDD_UNRATE_DLG,  RestDlgProc, hwndUser);
    AddPage((HPROPSHEETPAGE *)&hPages, &psHeader.nPages, IDD_USER_DLG,    UserDlgProc, hwndUser);
    AddPage((HPROPSHEETPAGE *)&hPages, &psHeader.nPages, IDD_NEWUSER_DLG, NewUserDlgProc, hwndUser);
    AddPage((HPROPSHEETPAGE *)&hPages, &psHeader.nPages, IDD_END_DLG,     BeginEndDlgProc, hwndUser);

	// fill out property sheet header struct
	psHeader.dwSize = sizeof(psHeader);
    psHeader.dwFlags = PSH_WIZARD;
    psHeader.hwndParent = hWnd;
	psHeader.hInstance = ghInst;
	psHeader.phpage = hPages;

	// Set global information
	LoadSz(IDS_DEFAULTUSER,gszName,sizeof(gszName));
	gfMaintenance = FALSE; 

	// run the Wizard
    iRet = PropertySheet(&psHeader);

	if (iRet < 0) {
		// property sheet failed, most likely due to lack of memory
        MsgBox(NULL,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
    }

	return (iRet > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\debug.c ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "pch.h"

VOID
_DebugMsg (
    UINT mask,
    PCSTR Format,
    ...
    )
{
    va_list args;
    DWORD Error;
    WCHAR Output[2048];
    PWSTR UnicodeFormat;
    UINT Size;

    Error = GetLastError();

    va_start (args, Format);

    Size = (lstrlenA (Format) + 1) * sizeof (WCHAR);

    UnicodeFormat = LocalAlloc (LPTR, Size);
    if (!UnicodeFormat) {
        SetLastError (Error);
        return;
    }

    MultiByteToWideChar (CP_ACP, 0, Format, -1, UnicodeFormat, Size/sizeof(WCHAR));

    _vsnwprintf (Output, sizeof(Output) - 3, UnicodeFormat, args);
    lstrcatW (Output, L"\r\n");
    OutputDebugStringW (Output);

    if (mask == DM_ASSERT) {
        DebugBreak();
    }

    va_end (args);

    LocalFree (UnicodeFormat);

    SetLastError (Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\global.h ===
//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#ifdef DBG

#define DEBUGMSG(x) _DebugMsg x

VOID _DebugMsg(UINT mask, PCSTR pszMsg, ...);

#define DMASSERT(x) if (!(x)) \
                        _DebugMsg(DM_ASSERT,"profmap.dll assertion " #x " failed\n, line %u of %s", __LINE__, TEXT(__FILE__));

#else

#define DEBUGMSG(x)
#define DMASSERT(x)

#endif

//
// userenv.c
//

BOOL OurConvertSidToStringSid (PSID Sid, PWSTR *SidString);
VOID DeleteSidString (PWSTR SidString);
BOOL RegDelnode (HKEY KeyRoot, PWSTR SubKey);

PACL
CreateDefaultAcl (
    PSID pSid
    );


VOID
FreeDefaultAcl (
    PACL Acl            OPTIONAL
    );

BOOL
GetProfileRoot (
    IN      PSID Sid,
    OUT     PWSTR ProfileDir
    );



#define USER_PROFILE_MUTEX           TEXT("Global\\userenv:  User Profile Mutex for ")
#define PROFILE_LIST_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define PROFILE_IMAGE_VALUE_NAME     TEXT("ProfileImagePath")
#define PROFILE_GUID                 TEXT("Guid")
#define PROFILE_GUID_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileGuid")
#define WINDOWS_POLICIES_KEY         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")
#define ROOT_POLICIES_KEY            TEXT("Software\\Policies")

BOOL
UpdateProfileSecurity (
    PSID Sid
    );

BOOL DeleteProfileRegistrySettings (LPTSTR lpSidString);

PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

LONG MyRegLoadKey(HKEY hKey, LPTSTR lpSubKey, LPTSTR lpFile);
BOOL MyRegUnLoadKey(HKEY hKey, LPTSTR lpSubKey);
BOOL SetupNewHive(LPTSTR lpSidString, PSID pSid);
DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD);
BOOL SecureUserKey(LPTSTR lpKey, PSID pSid);
LPWSTR ProduceWFromA(LPCSTR pszA);
BOOL IsUserAnAdminMember(HANDLE hToken);

//
// Stuff lifted from win9x upgrade code
//

#define MemAlloc(s)         LocalAlloc(LPTR,s)
#define MemReAlloc(x,s)     LocalReAlloc(x,s,LMEM_MOVEABLE)
#define MemFree(x)          LocalFree(x)

typedef struct {
    PBYTE Buf;
    DWORD Size;
    DWORD End;
    DWORD GrowSize;
    DWORD UserIndex;        // Unused by Growbuf. For caller use.
} GROWBUFFER, *PGROWBUFFER;

#define GROWBUF_INIT {NULL,0,0,0,0}

PBYTE
GrowBuffer (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    );

VOID
FreeGrowBuffer (
    IN  PGROWBUFFER GrowBuf
    );

typedef struct {
    GROWBUFFER ListArray;
    POOLHANDLE ListData;
} GROWLIST, *PGROWLIST;

#define GROWLIST_INIT {GROWBUF_INIT, NULL}

VOID
FreeGrowList (
    IN  PGROWLIST GrowList
    );

PBYTE
GrowListAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

PBYTE
RealGrowListAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListAppendAddNul(list,data,size)    RealGrowListAppendAddNul (list,data,size)

PBYTE
GrowListGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    );

UINT
GrowListGetSize (
    IN      PGROWLIST GrowList
    );


PWSTR
GetEndOfStringW (
    PCWSTR p
    );

PWSTR
StringCopyABW (
    OUT     PWSTR Buf,
    IN      PCWSTR a,
    IN      PCWSTR b
    );

UINT
SizeOfStringW (
    PCWSTR str
    );


__inline
PCWSTR
RealGrowListAppendStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    return (PCWSTR) GrowListAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        String < End ? (UINT)((PBYTE) End - (PBYTE) String) : 0
                        );
}

#define GrowListAppendStringABW(list,a,b) RealGrowListAppendStringABW(list,a,b)

#define GrowListAppendStringW(list,str) GrowListAppendStringABW(list,str,GetEndOfStringW(str))
#define GrowListAppendStringNW(list,str,len) GrowListAppendStringABW(list,str,CharCountToPointerW(str,len))
#define GrowListGetStringW(list,index) (PCWSTR)(GrowListGetItem(list,index))

#define GrowListAppendEmptyItem(list)           GrowListAppend (list,NULL,0)

#ifdef UNICODE

#define GrowListAppendString GrowListAppendStringW
#define GrowListAppendStringAB GrowListAppendStringABW
#define GrowListAppendStringN GrowListAppendStringNW
#define GrowListGetString GrowListGetStringW

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\rpc\$(O)\$(@F)
    copy ..\rpc\$(O)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\poolmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    poolmem.c

Abstract:

    poolmem provides a managed allocation scheme in which large blocks of memory are
    allocated (pools) and then divided up by request into low overhead memory chunks
    upon request. poolmem provides for easy creation/clean-up of memory, freeing the
    developer for more important tasks.

Author:

    Marc R. Whitten (marcw) 13-Feb-1997

Revision History:

    jimschm     28-Sep-1998 Debug message fixes

--*/

#include "pch.h"

typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK;

struct _POOLMEMORYBLOCK {
    DWORD                 Index;            // Tracks into RawMemory.
    DWORD                 Size;             // the size in bytes of RawMemory.
    PPOOLMEMORYBLOCK      NextBlock;        // A pointer to the next block in the pool chain.
    PPOOLMEMORYBLOCK      PrevBlock;        // A pointer to the prev block in the pool chain.
    DWORD                 UseCount;         // The number of allocations currently referring
                                            // to this block.
    PBYTE                 RawMemory;        // The actual bytes of allocable memory in this block.
};


typedef struct _ALLOCATION ALLOCATION, * PALLOCATION;
struct _ALLOCATION {

    PPOOLMEMORYBLOCK    ParentBlock;        // A reference to the block from which this allocation
                                            // was created.

};

typedef struct _POOLHEADER {
    PPOOLMEMORYBLOCK PoolHead;              // The active memory block in this pool.
    DWORD            MinimumBlockSize;      // minimum size to allocate when a new block is needed.
} POOLHEADER, *PPOOLHEADER;


BOOL
pPoolMemAddMemory (
    IN  POOLHANDLE  Handle,
    IN  DWORD       Size
    )
/*++

Routine Description:

    pPoolMemAddMemory is the function responsible for actually growing the size of
    the pool by adding a new block of memory. This function is used by
    PoolMemInitPool and PoolMemGetMemory.

    when called, this function attempts to allocate at least poolHeader ->
    MinimumBlockSize bytes of memory. If the requested size is actually larger
    than the minimum, the requested size is allocated instead. This is consistent
    with PoolMem's main purpose: An efficient allocator for larger numbers of small
    objects. If PoolMem is being used to allocate very large objects, the benefits
    are lost and poolmem becomes a very inefficient allocator.

Arguments:

    Handle - A Handle to a Pool of Memory.

    Size - Size to allocate.


Return Value:

    returns TRUE if memory was successfully added, FALSE otherwise.

--*/
{
    PBYTE               allocedMemory;
    PPOOLMEMORYBLOCK    newBlock;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;
    DWORD               sizeNeeded;

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(POOLMEMORYBLOCK) > poolHeader -> MinimumBlockSize) {
        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK);
    }
    else {
        sizeNeeded = poolHeader -> MinimumBlockSize;
    }
    allocedMemory = MemAlloc(sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory;
        newBlock -> Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK);
        newBlock -> RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK);
        newBlock -> Index       = 0;
        newBlock -> UseCount    = 0;

        //
        // Link the block into the list.
        //
        if (poolHeader -> PoolHead) {
            poolHeader -> PoolHead -> PrevBlock = newBlock;
        }
        newBlock   -> NextBlock   = poolHeader -> PoolHead;
        newBlock   -> PrevBlock   = NULL;
        poolHeader -> PoolHead    = newBlock;

    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;

}


POOLHANDLE
PoolMemInitPool (
    VOID
    )
/*++

Routine Description:

    Initializes a new memory pool and returns a handle to it.

Arguments:

    None.

Return Value:

    If the function completes succssessfully, it returns a valid POOLHANDLE, otherwise,
    it returns NULL.

--*/

{
    BOOL        ableToAddMemory;
    PPOOLHEADER header = NULL;

    //
    // Allocate the header of this pool.
    //
    header = MemAlloc(sizeof(POOLHEADER));

    if (header) {
        //
        // Allocation was successful. Now, initialize the pool.
        //
        header -> MinimumBlockSize = POOLMEMORYBLOCKSIZE;
        header -> PoolHead = NULL;

        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = pPoolMemAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            MemFree(header);
            header = NULL;
        }
    }

    return (POOLHANDLE) header;

}

VOID
PoolMemEmptyPool (
    IN      POOLHANDLE Handle
    )

/*++

Routine Description:

    PoolMemEmptyPool resets the index pointer of the index block back
    to zero, so the next allocation will come from the already allocated
    active block.

    Calling this function invalidates all pointers previously allocated from
    the active block.

Arguments:

    Handle - Specifies the pool to reset

Return Value:

    None.

--*/

{
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;

    poolHeader -> PoolHead -> UseCount = 0;
    poolHeader -> PoolHead -> Index = 0;
}



VOID
PoolMemSetMinimumGrowthSize (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    )
/*++

Routine Description:

    Sets the minimum growth size for a memory pool. This value is used when new blocks
    are actually added to the pool. The PoolMem allocator will attempt to allocate at
    least this minimum size.

Arguments:

    Handle - A valid POOLHANDLE.
    Size   - The minimum size in bytes to grow the pool by on each allocation.

Return Value:

    None.

--*/

{
    PPOOLHEADER poolHeader = (PPOOLHEADER) Handle;

    poolHeader -> MinimumBlockSize = max(Size,0);
}


VOID
PoolMemDestroyPool (
    POOLHANDLE Handle
    )
/*++

Routine Description:

    PoolMemDestroyPool completely cleans up the memory pool identified by Handle. It
    simply walks the list of memory blocks associated with the memory pool, freeing each of them.

Arguments:

    Handle - A valid POOLHANDLE.

Return Value:

    None.

--*/
{
    PPOOLMEMORYBLOCK nextBlock;
    PPOOLMEMORYBLOCK blockToFree;
    PPOOLHEADER      poolHeader;


    poolHeader = (PPOOLHEADER) Handle;

    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader ->  PoolHead;

    while (blockToFree != NULL) {

        nextBlock = blockToFree->NextBlock;
        MemFree(blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    MemFree(poolHeader);

}

PVOID
PoolMemRealGetMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size,
    IN DWORD      AlignSize
    )

/*++

Routine Description:

    PoolMemRealGetMemory is the worker routine that processes all requests to retrieve memory
    from a pool. Other calls eventually decay into a call to this common routine. This routine
    attempts to service the request out of the current memory block, or, if it cannot, out of
    a newly allocated block.

Arguments:

    (File) - The File from whence the call orignated. This is used for memory tracking and checking
             in the debug version.
    (Line) - The Line from whence the call orignated.

    Handle - A valid POOLHANDLE.
    Size   - Contains the size in bytes that the caller needs from the pool.
    AlignSize - Provides an alignment value. The returned memory will be aligned on <alignsize> byte
        boundaries.

Return Value:

    The allocated memory, or, NULL if no memory could be allocated.

--*/
{
    BOOL                haveEnoughMemory = TRUE;
    PVOID               rMemory          = NULL;
    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle;
    PPOOLMEMORYBLOCK    currentBlock;
    PALLOCATION         allocation;
    DWORD               sizeNeeded;
    DWORD_PTR           padLength;

    //
    // Assume that the current block of memory will be sufficient.
    //
    currentBlock = poolHeader -> PoolHead;

    //
    // Determine if more memory is needed, attempt to add if needed. Note that the size
    // must include the size of an ALLOCATION struct in addition to the size required
    // by the callee. Note the references to AlignSize in the test below. This is to ensure
    // that there is enough memory to allocate after taking into acount data alignment.
    //
    sizeNeeded = Size + sizeof(ALLOCATION);

    if (currentBlock -> Size - currentBlock -> Index < sizeNeeded + AlignSize) {

        haveEnoughMemory = pPoolMemAddMemory(poolHeader,sizeNeeded + AlignSize);

        //
        // Make sure that the currentBlock is correctly set
        //
        currentBlock = poolHeader -> PoolHead;
    }

    //
    // If there is enough memory available, return it.
    //
    if (haveEnoughMemory) {
        if (AlignSize) {

            padLength = (DWORD_PTR) currentBlock + sizeof(POOLMEMORYBLOCK)
                + currentBlock -> Index + sizeof(ALLOCATION);
            currentBlock -> Index += (DWORD)(AlignSize - (padLength % AlignSize)) % AlignSize;

        }

        //
        // Save a reference to this block in the memorys ALLOCATION structure.
        // This will be used to decrease the use count on a block when releasing
        // memory.
        //
        (PBYTE) allocation = &(currentBlock -> RawMemory[currentBlock -> Index]);
        allocation -> ParentBlock = currentBlock;


        //
        //  Ok, get a reference to the actual memory to return to the user.
        //
        rMemory = (PVOID)
            &(currentBlock->RawMemory[currentBlock -> Index + sizeof(ALLOCATION)]);

        //
        // Update memory block data fields.
        //
        currentBlock->Index += sizeNeeded;
        currentBlock->UseCount++;
    }

    return rMemory;
}

VOID
PoolMemReleaseMemory (
    IN POOLHANDLE Handle,
    IN LPVOID     Memory
    )
/*++

Routine Description:

    PoolMemReleaseMemory notifies the Pool that a piece of memory is no longer needed.
    if all memory within a non-active block (i.e. not the first block) is released,
    that block will be freed. If all memory is released within an active block, that blocks
    stats are simply cleared, effectively reclaiming its space.

Arguments:

    Handle - A Handle to a Pool of Memory.
    Memory - Contains the address of the memory that is no longer needed.

Return Value:

    None.

--*/
{
    PALLOCATION         allocation;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;

    //
    // Get a reference to the ALLOCATION struct that precedes the actual memory.
    //
    allocation = (PALLOCATION) Memory - 1;

    //
    // Check to make sure this memory has not previously been freed.
    //
    if (allocation -> ParentBlock == NULL) {
        return;
    }

    //
    // Update the use count on this allocations parent block.
    //
    allocation -> ParentBlock -> UseCount--;




    if (allocation -> ParentBlock -> UseCount == 0) {

        //
        // This was the last allocation still referring to the parent block.
        //

        if (allocation -> ParentBlock != poolHeader -> PoolHead) {
            //
            // Since the parent block isn't the active block, simply delete it.
            //

            if (allocation -> ParentBlock -> NextBlock) {
                allocation -> ParentBlock -> NextBlock -> PrevBlock =
                    allocation -> ParentBlock -> PrevBlock;
            }
            allocation -> ParentBlock -> PrevBlock -> NextBlock =
                allocation -> ParentBlock -> NextBlock;
            MemFree(allocation -> ParentBlock);


        }
        else {
            //
            // Since this is the active block, reset it.
            //
            allocation -> ParentBlock -> Index = 0;
            allocation -> ParentBlock = NULL;

        }
    }
    else {
        allocation -> ParentBlock = NULL;

    }

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\pch.h ===
#ifdef UNICODE

#ifndef _UNICODE
#define _UNICODE
#endif

#else

#ifndef _MBCS
#define _MBCS
#endif

#endif

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <tchar.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#define _USERENV_
#include <userenv.h>
#include <userenvp.h>
#include <profmapp.h>

#include <lm.h>
#include <aclapi.h>

#include "poolmem.h"
#include "reg.h"
#include "global.h"
#include "pmapapi.h"

#include <ntrpcp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\poolmem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    poolmem.h

Abstract:

    Declares the pool memory interface.  A pool of memory is a set of
    blocks (typically 8K each) that are used for several allocations,
    and then freed at the end of processing.  See below for routines.

Author:

    Marc R. Whitten (marcw)     02-Feb-1997

Revision History:

    jimschm     04-Feb-1998     Named pools for tracking

--*/

#pragma once

typedef PVOID POOLHANDLE;


/*++

  Create and destroy routines:

    POOLHANDLE
    PoolMemInitPool (
        VOID
        );

    POOLHANDLE
    PoolMemInitNamedPool (
        IN      PCSTR Name
        );

    VOID
    PoolMemDestroyPool (
        IN      POOLHANDLE Handle
        );

  Primitive routines:

    PVOID
    PoolMemGetMemory (
        IN      POOLHANDLE Handle,
        IN      DWORD Size
        );

    PVOID
    PoolMemGetAlignedMemory (
        IN      POOLHANDLE Handle,
        IN      DWORD Size
        );

    VOID
    PoolMemReleaseMemory (
        IN      POOLHANDLE Handle,
        IN      PVOID Memory
        );

  Performance and debugging control:

    VOID
    PoolMemSetMinimumGrowthSize (
        IN      POOLHANDLE Handle,
        IN      DWORD GrowthSize
        );

    VOID
    PoolMemEmptyPool (
        IN      POOLHANDLE Handle
        );

    VOID
    PoolMemDisableTracking (
        IN      POOLHANDLE Handle
        );

  Allocation and duplication of data types:

    PCTSTR
    PoolMemCreateString (
        IN      POOLHANDLE Handle,
        IN      UINT TcharCount
        );

    PCTSTR
    PoolMemCreateDword (
        IN      POOLHANDLE Handle
        );

    PBYTE
    PoolMemDuplicateMemory (
        IN      POOLHANDLE Handle,
        IN      PBYTE Data,
        IN      UINT DataSize
        );

    PDWORD
    PoolMemDuplciateDword (
        IN      POOLHANDLE Handle,
        IN      DWORD Data
        );

    PTSTR
    PoolMemDuplicateString (
        IN      POOLHANDLE Handle,
        IN      PCTSTR String
        );

    PTSTR
    PoolMemDuplicateMultiSz (
        IN      POOLHANDLE Handle,
        IN      PCTSTR MultiSz
        );


--*/

#define ByteCountW(x)   (lstrlen(x)*sizeof(WCHAR))



//
// Default size of memory pool blocks. This can be changed on a per-pool basis
// by calling PoolMemSetMinimumGrowthSize().
//

#define POOLMEMORYBLOCKSIZE 8192

POOLHANDLE
PoolMemInitPool (
    VOID
    );

#define PoolMemInitNamedPool(x) PoolMemInitPool()

VOID
PoolMemDestroyPool (
    IN POOLHANDLE Handle
    );


//
// Callers should use PoolMemGetMemory or PoolMemGetAlignedMemory. These each decay into
// PoolMemRealGetMemory.
//
#define PoolMemGetMemory(h,s)           PoolMemRealGetMemory(h,s,0)

#define PoolMemGetAlignedMemory(h,s)    PoolMemRealGetMemory(h,s,sizeof(DWORD))

PVOID PoolMemRealGetMemory(IN POOLHANDLE Handle, IN DWORD Size, IN DWORD AlignSize);

VOID PoolMemReleaseMemory (IN POOLHANDLE Handle, IN PVOID Memory);
VOID PoolMemSetMinimumGrowthSize(IN POOLHANDLE Handle, IN DWORD Size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\reg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg.h

Abstract:

    Implements macros to simplify the registry APIs and to track
    the resource allocations.

Author:

    Jim Schmidt (jimschm) 24-Mar-1997

Revision History:

    jimschm 09-Apr-1997     Expanded Get functionality

--*/

#pragma once

//
// Reg API simplification routines
//

typedef struct {
    HKEY KeyHandle;
    BOOL OpenedByEnum;
    DWORD Index;
    WCHAR SubKeyName[MAX_PATH];
} REGKEY_ENUMW, *PREGKEY_ENUMW;

typedef struct {
    HKEY KeyHandle;
    DWORD Index;
    WCHAR ValueName[MAX_PATH];
    DWORD Type;
    DWORD DataSize;
} REGVALUE_ENUMW, *PREGVALUE_ENUMW;

typedef struct _tagREGKEYINFOW {
    WCHAR KeyName[MAX_PATH];
    HKEY KeyHandle;
    REGKEY_ENUMW KeyEnum;
    UINT BaseKeyBytes;
    struct _tagREGKEYINFOW *Parent, *Child;
} REGKEYINFOW, *PREGKEYINFOW;

typedef enum {
    ENUMERATE_SUBKEY_BEGIN,
    ENUMERATE_SUBKEY_RETURN,
    ENUMERATE_SUBKEY_NEXT,
    ENUMERATE_SUBKEY_DONE,
    NO_MORE_ITEMS
} REGTREESTATE;

typedef struct {
    WCHAR FullKeyName[MAX_PATH];
    UINT FullKeyNameBytes;
    UINT EnumBaseBytes;
    PREGKEYINFOW CurrentKey;
    POOLHANDLE EnumPool;
    REGTREESTATE State;
    BOOL FirstEnumerated;
} REGTREE_ENUMW, *PREGTREE_ENUMW;


//
// Enum functions
//

BOOL
EnumFirstRegKeyW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
RealEnumFirstRegKeyStrW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
    );

#define EnumFirstRegKeyStrA RealEnumFirstRegKeyStrA
#define EnumFirstRegKeyStrW RealEnumFirstRegKeyStrW



BOOL
EnumNextRegKeyW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

VOID
AbortRegKeyEnumW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

BOOL
RealEnumFirstRegKeyInTreeW (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTreeW(e,base)  RealEnumFirstRegKeyInTreeW(e,base)


BOOL
RealEnumNextRegKeyInTreeW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );

#define EnumNextRegKeyInTreeW(e)        RealEnumNextRegKeyInTreeW(e)

VOID
AbortRegKeyTreeEnumW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );


BOOL
EnumFirstRegValueW (
    OUT     PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumNextRegValueW (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    );

//
// Versions that allow caller to specify allocator, and macro that uses
// MemAllocWrapper
//

typedef PVOID (ALLOCATOR_PROTOTYPE)(DWORD Size);
typedef ALLOCATOR_PROTOTYPE * ALLOCATOR;

ALLOCATOR_PROTOTYPE MemAllocWrapper;

typedef VOID (DEALLOCATOR_PROTOTYPE)(PVOID Mem);
typedef DEALLOCATOR_PROTOTYPE * DEALLOCATOR;

DEALLOCATOR_PROTOTYPE MemFreeWrapper;

BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataW(key,valuename) GetRegValueData2W((key),(valuename),MemAllocWrapper,MemFreeWrapper)\

PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeW(key,valuename,type)  GetRegValueDataOfType2W((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)

PBYTE
GetRegKeyData2W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataW(key,subkey)  GetRegKeyData2W((key),(subkey),MemAllocWrapper,MemFreeWrapper)

PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataW(keystr,value)   GetRegData2W((keystr),(value),MemAllocWrapper,MemFreeWrapper)

BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    );


//
// Reg key create & open
//

HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
    );

HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
    );

HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
    );

HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
    );

LONG
RealCloseRegKey (
    IN      HKEY Key
    );

#define CloseRegKey RealCloseRegKey


#define CreateRegKeyW RealCreateRegKeyW
#define CreateRegKeyStrW RealCreateRegKeyStrW
#define OpenRegKeyStrW RealOpenRegKeyStrW
#define OpenRegKeyW RealOpenRegKeyW


//
// Registry root functions
//

VOID
SetRegRoot (
    IN      HKEY Root
    );

HKEY
GetRegRoot (
    VOID
    );


// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootStringW (PCWSTR RootString, PDWORD LengthPtr OPTIONAL);

// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootKey (HKEY RootKey);

// Given non-zero array offset to root, returns string or NULL if element
// is out of bounds
PCWSTR GetRootStringFromOffsetW (INT i);

// Given non-zero array offset to root, returns registry handle or NULL if
// element is out of bounds
HKEY GetRootKeyFromOffset (INT i);

// Converts the root at the head of RegPath to an HKEY and gives the number
// of characters occupied by the root string (including optional wack)
HKEY ConvertRootStringToKeyW (PCWSTR RegPath, PDWORD LengthPtr OPTIONAL);

// Returns a pointer to a static string for the matching root, or NULL if
// RegRoot does not point to a valid root
PCWSTR ConvertKeyToRootStringW (HKEY RegRoot);



//
// Macros
//

#define GetRegValueStringW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_SZ)
#define GetRegValueBinaryW(key,valuename) (PBYTE) GetRegValueDataOfTypeW((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordW(key,valuename) (PDWORD) GetRegValueDataOfTypeW((key),(valuename),REG_DWORD)

#define GetRegValueString2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define REGKEY_ENUM                     REGKEY_ENUMW
#define PREGKEY_ENUM                    PREGKEY_ENUMW
#define REGVALUE_ENUM                   REGVALUE_ENUMW
#define PREGVALUE_ENUM                  PREGVALUE_ENUMW
#define REGTREE_ENUM                    REGTREE_ENUMW
#define PREGTREE_ENUM                   PREGTREE_ENUMW

#define EnumFirstRegKey                 EnumFirstRegKeyW
#define EnumFirstRegKeyStr              EnumFirstRegKeyStrW
#define EnumNextRegKey                  EnumNextRegKeyW
#define AbortRegKeyEnum                 AbortRegKeyEnumW
#define EnumFirstRegKeyInTree           EnumFirstRegKeyInTreeW
#define EnumNextRegKeyInTree            EnumNextRegKeyInTreeW
#define AbortRegKeyTreeEnum             AbortRegKeyTreeEnumW
#define EnumFirstRegValue               EnumFirstRegValueW
#define EnumNextRegValue                EnumNextRegValueW

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeW
#define GetRegValueData                 GetRegValueDataW
#define GetRegValueDataOfType           GetRegValueDataOfTypeW
#define GetRegKeyData                   GetRegKeyDataW
#define GetRegValueData2                GetRegValueData2W
#define GetRegValueDataOfType2          GetRegValueDataOfType2W
#define GetRegKeyData2                  GetRegKeyData2W
#define GetRegValueString               GetRegValueStringW
#define GetRegValueBinary               GetRegValueBinaryW
#define GetRegValueMultiSz              GetRegValueMultiSzW
#define GetRegValueDword                GetRegValueDwordW
#define GetRegValueString2              GetRegValueString2W
#define GetRegValueBinary2              GetRegValueBinary2W
#define GetRegValueMultiSz2             GetRegValueMultiSz2W
#define GetRegValueDword2               GetRegValueDword2W
#define GetRegData2                     GetRegData2W
#define GetRegData                      GetRegDataW

#define CreateRegKey                    CreateRegKeyW
#define CreateRegKeyStr                 CreateRegKeyStrW
#define OpenRegKey                      OpenRegKeyW
#define OpenRegKeyStr                   OpenRegKeyStrW
#define GetOffsetOfRootString           GetOffsetOfRootStringW
#define GetRootStringFromOffset         GetRootStringFromOffsetW
#define ConvertRootStringToKey          ConvertRootStringToKeyW
#define ConvertKeyToRootString          ConvertKeyToRootStringW
#define CreateEncodedRegistryString     CreateEncodedRegistryStringW
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExW
#define FreeEncodedRegistryString       FreeEncodedRegistryStringW


#endif


VOID
RegistrySearchAndReplaceW (
    IN      PCWSTR Root,
    IN      PCWSTR Search,
    IN      PCWSTR Replace
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\regrep.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    regrep.c

Abstract:

    Implements a registry search/replace tool.

Author:

    Jim Schmidt (jimschm) 19-Apr-1999

Revision History:

    jimschm     26-May-1999 Moved from win9xupg, ported to use different
                            utilities

--*/

#include "pch.h"

VOID
pUpdateKeyNames (
    IN      PCWSTR Search,
    IN      PCWSTR Replace,
    IN      PCWSTR RootKey
    );

VOID
pUpdateValueNames (
    IN      PCWSTR Search,
    IN      PCWSTR Replace,
    IN      PCWSTR RootKey
    );

VOID
pUpdateValueData (
    IN      PCWSTR Search,
    IN      PCWSTR Replace,
    IN      PCWSTR RootKey
    );


PWSTR
AppendWackW (
    IN PWSTR str
    )
{
    PCWSTR Last;

    if (!str)
        return str;

    if (*str) {
        str = GetEndOfStringW (str);
        Last = str - 1;
    } else {
        Last = str;
    }

    if (*Last != '\\') {
        *str = L'\\';
        str++;
        *str = 0;
    }

    return str;
}


VOID
RegistrySearchAndReplaceW (
    IN      PCWSTR Root,
    IN      PCWSTR Search,
    IN      PCWSTR Replace
    )
{
    pUpdateKeyNames (Search, Replace, Root);
    pUpdateValueNames (Search, Replace, Root);
    pUpdateValueData (Search, Replace, Root);
}


PCWSTR
_wcsistr (
    PCWSTR wstrStr,
    PCWSTR wstrSubStr
    )

{
    PCWSTR wstrStart, wstrStrPos, wstrSubStrPos;
    PCWSTR wstrEnd;

    wstrEnd = (PWSTR) ((LPBYTE) wstrStr + ByteCountW (wstrStr) - ByteCountW (wstrSubStr));

    for (wstrStart = wstrStr ; wstrStart <= wstrEnd ; wstrStart++) {
        wstrStrPos = wstrStart;
        wstrSubStrPos = wstrSubStr;

        while (*wstrSubStrPos &&
               towlower (*wstrSubStrPos) == towlower (*wstrStrPos))
        {
            wstrStrPos++;
            wstrSubStrPos++;
        }

        if (!(*wstrSubStrPos))
            return wstrStart;
    }

    return NULL;
}

#define DEFAULT_GROW_SIZE 8192

PBYTE
GrowBuffer (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  GrowBuffer makes sure there is enough bytes in the buffer
  to accomodate SpaceNeeded.  It allocates an initial buffer
  when no buffer is allocated, and it reallocates the buffer
  in increments of GrowBuf->Size (or DEFAULT_GROW_SIZE) when
  needed.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE NewBuffer;
    DWORD TotalSpaceNeeded;
    DWORD GrowTo;

    if (!GrowBuf->Buf) {
        GrowBuf->Size = 0;
        GrowBuf->End = 0;
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = DEFAULT_GROW_SIZE;
    }

    TotalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (TotalSpaceNeeded > GrowBuf->Size) {
        GrowTo = (TotalSpaceNeeded + GrowBuf->GrowSize) - (TotalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        GrowTo = 0;
    }

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAlloc (GrowTo);
        if (!GrowBuf->Buf) {
            DEBUGMSG ((DM_WARNING, "GrowBuffer: Initial alloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
    } else if (GrowTo) {
        NewBuffer = MemReAlloc (GrowBuf->Buf, GrowTo);
        if (!NewBuffer) {
            DEBUGMSG ((DM_WARNING, "GrowBuffer: Realloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
        GrowBuf->Buf = NewBuffer;
    }

    NewBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

    return NewBuffer;
}


VOID
FreeGrowBuffer (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  FreeGrowBuffer frees a buffer allocated by GrowBuffer.

Arguments:

  GrowBuf  - A pointer to the same structure passed to GrowBuffer

Return Value:

  none

--*/


{
    if (GrowBuf->Buf) {
        MemFree (GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}

#define INSERT_LAST     0xffffffff

PBYTE
pGrowListAdd (
    IN OUT  PGROWLIST GrowList,
    IN      UINT InsertBefore,
    IN      PBYTE DataToAdd,            OPTIONAL
    IN      UINT SizeOfData,
    IN      UINT NulBytesToAdd
    )

/*++

Routine Description:

  pGrowListAdd allocates memory for a binary block by using a pool, and
  then expands an array of pointers, maintaining a quick-access list.

Arguments:

  GrowList - Specifies the list to add the entry to

  InsertBefore - Specifies the index of the array element to insert
                 before, or INSERT_LIST to append.

  DataToAdd - Specifies the binary block of data to add.

  SizeOfData - Specifies the size of data.

  NulBytesToAdd - Specifies the number of nul bytes to add to the buffer

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    PBYTE *Item;
    PBYTE *InsertAt;
    PBYTE Data;
    UINT OldEnd;
    UINT Size;
    UINT TotalSize;

    TotalSize = SizeOfData + NulBytesToAdd;

    //
    // Allocate pool if necessary
    //

    if (!GrowList->ListData) {
        GrowList->ListData = PoolMemInitNamedPool ("GrowList");
        if (!GrowList->ListData) {
            return NULL;
        }
    }

    //
    // Expand list array
    //

    OldEnd = GrowList->ListArray.End;
    Item = (PBYTE *) GrowBuffer (&GrowList->ListArray, sizeof (PBYTE));
    if (!Item) {
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToAdd || NulBytesToAdd) {
        Data = PoolMemGetAlignedMemory (GrowList->ListData, TotalSize);
        if (!Data) {
            GrowList->ListArray.End = OldEnd;
            return NULL;
        }

        if (DataToAdd) {
            CopyMemory (Data, DataToAdd, SizeOfData);
        }
        if (NulBytesToAdd) {
            ZeroMemory (Data + SizeOfData, NulBytesToAdd);
        }
    } else {
        Data = NULL;
    }

    //
    // Adjust array
    //

    Size = GrowListGetSize (GrowList);

    if (InsertBefore >= Size) {
        //
        // Append mode
        //

        *Item = Data;

    } else {
        //
        // Insert mode
        //

        InsertAt = (PBYTE *) (GrowList->ListArray.Buf) + InsertBefore;
        MoveMemory (&InsertAt[1], InsertAt, (Size - InsertBefore) * sizeof (PBYTE));
        *InsertAt = Data;
    }

    return Data ? Data : (PBYTE) 1;
}


VOID
FreeGrowList (
    IN  PGROWLIST GrowList
    )

/*++

Routine Description:

  FreeGrowList frees the resources allocated by a GROWLIST.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    FreeGrowBuffer (&GrowList->ListArray);
    if (GrowList->ListData) {
        PoolMemDestroyPool (GrowList->ListData);
    }

    ZeroMemory (GrowList, sizeof (GROWLIST));
}


PBYTE
GrowListGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GrowListGetItem returns a pointer to the block of data
  for item specified by Index.

Arguments:

  GrowList - Specifies the list to access

  Index - Specifies zero-based index of item in list to access

Return Value:

  A pointer to the item's data, or NULL if the Index does not
  represent an actual item.

--*/

{
    PBYTE *ItemPtr;
    UINT Size;

    Size = GrowListGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    ItemPtr = (PBYTE *) (GrowList->ListArray.Buf);
    return ItemPtr[Index];
}


UINT
GrowListGetSize (
    IN      PGROWLIST GrowList
    )

/*++

Routine Description:

  GrowListGetSize calculates the number of items in the list.

Arguments:

  GrowList - Specifies the list to calculate the size of

Return Value:

  The number of items in the list, or zero if the list is empty.

--*/

{
    return GrowList->ListArray.End / sizeof (PBYTE);
}


PBYTE
GrowListAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend appends a black of data as a new list item.

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGrowListAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 0);
}


VOID
pMoveKey (
    IN      PCWSTR SourceKey,
    IN      PCWSTR DestKey
    )
{
    HKEY Src;
    HKEY Dest;
    REGVALUE_ENUM e;
    DWORD Size;
    PBYTE Data;
    LONG rc;
    GROWBUFFER Buf = GROWBUF_INIT;

    Src = OpenRegKeyStr (SourceKey);
    Dest = CreateRegKeyStr (DestKey);

    if (Src && Dest) {
        if (EnumFirstRegValue (&e, Src)) {

            Buf.End = 0;
            Data = GrowBuffer (&Buf, e.DataSize);
            if (Data) {

                Size = e.DataSize;
                rc = RegQueryValueEx (
                        Src,
                        e.ValueName,
                        NULL,
                        NULL,
                        Data,
                        &Size
                        );

                if (rc == ERROR_SUCCESS) {

                    rc = RegSetValueEx (Dest, e.ValueName, 0, e.Type, Data, Size);
                }
            }
        }
    }

    CloseRegKey (Src);
    CloseRegKey (Dest);

    FreeGrowBuffer (&Buf);
}


PBYTE
RealGrowListAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend appends a black of data as a new list item and
  appends two zero bytes (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGrowListAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 2);
}


UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      UINT SearchChars
    )
{
    UINT Count;
    UINT SourceChars;
    PCWSTR End;

    Count = 0;
    SourceChars = lstrlenW (SourceString);

    End = SourceString + SourceChars - SearchChars;

    if (!SearchChars) {
        return 0;
    }

    while (SourceString <= End) {
        if (!_wcsnicmp (SourceString, SearchString, SearchChars)) {
            Count++;
            SourceString += SearchChars;
        } else {
            SourceString++;
        }
    }

    return Count;
}


PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    )
{
    PWSTR NewString;
    PBYTE p;
    PBYTE Dest;
    UINT Count;
    UINT Size;
    UINT SearchBytes;
    UINT ReplaceBytes;
    UINT SearchChars;

    //
    // Count occurances within the string
    //

    SearchBytes = ByteCountW (SearchString);
    SearchChars = SearchBytes / sizeof (WCHAR);
    ReplaceBytes = ByteCountW (ReplaceString);

    Count = CountInstancesOfSubStringW (
                SourceString,
                SearchString,
                SearchChars
                );

    if (!Count) {
        return NULL;
    }

    Size = SizeOfStringW (SourceString) -
           Count * SearchBytes +
           Count * ReplaceBytes;

    NewString = (PWSTR) MemAlloc (Size);
    if (!NewString) {
        return NULL;
    }

    p = (PBYTE) SourceString;
    Dest = (PBYTE) NewString;

    while (*((PWSTR) p)) {
        if (!_wcsnicmp ((PWSTR) p, SearchString, SearchChars)) {
            CopyMemory (Dest, ReplaceString, ReplaceBytes);
            Dest += ReplaceBytes;
            p += SearchBytes;
        } else {
            *((PWSTR) Dest) = *((PWSTR) p);
            p += sizeof (WCHAR);
            Dest += sizeof (WCHAR);
        }
    }

    *((PWSTR) Dest) = 0;

    return NewString;
}


VOID
pMoveKeyTree (
    IN      PCWSTR SourceKey,
    IN      PCWSTR DestKey
    )
{
    REGTREE_ENUM e;
    WCHAR DestSubKey[MAX_PATH];
    PWSTR p;
    GROWLIST List = GROWLIST_INIT;
    UINT Count;
    UINT u;
    PCWSTR Item;
    DWORD Len;

    lstrcpyW (DestSubKey, DestKey);
    p = AppendWackW (DestSubKey);

    if (EnumFirstRegKeyInTree (&e, SourceKey)) {

        do {

            lstrcpyW (p, (PCWSTR) ((PBYTE) e.FullKeyName + e.EnumBaseBytes));
            pMoveKey (e.FullKeyName, DestSubKey);
            GrowListAppendString (&List, e.FullKeyName);

        } while (EnumNextRegKeyInTree (&e));
    }

    Count = GrowListGetSize (&List);

    u = Count;
    while (u > 0) {
        u--;

        Item = GrowListGetString (&List, u);

        ConvertRootStringToKey (Item, &Len);
        RegDeleteKey (ConvertRootStringToKey (Item, NULL), Item + Len);
    }

    FreeGrowList (&List);
}


VOID
pUpdateKeyNames (
    IN      PCWSTR Search,
    IN      PCWSTR Replace,
    IN      PCWSTR RootKey
    )
{
    REGTREE_ENUM e;
    GROWLIST List = GROWLIST_INIT;
    UINT Count;
    UINT u;
    PCWSTR OldKey;
    PCWSTR NewKey;

    if (EnumFirstRegKeyInTree (&e, RootKey)) {
        do {
            if (_wcsistr (e.CurrentKey->KeyName, Search)) {
                GrowListAppendString (&List, e.FullKeyName);
            }
        } while (EnumNextRegKeyInTree (&e));
    }

    Count = GrowListGetSize (&List);
    u = Count;

    while (u > 0) {
        u--;

        OldKey = GrowListGetString (&List, u);
        NewKey = StringSearchAndReplaceW (
                    OldKey,
                    Search,
                    Replace
                    );

        pMoveKeyTree (OldKey, NewKey);
    }

    FreeGrowList (&List);
}


VOID
pUpdateValueNames (
    IN      PCWSTR Search,
    IN      PCWSTR Replace,
    IN      PCWSTR RootKey
    )
{
    REGTREE_ENUM e;
    REGVALUE_ENUM ev;
    GROWLIST List = GROWLIST_INIT;
    HKEY Key;
    UINT Count;
    UINT u;
    PBYTE Data;
    DWORD Type;
    DWORD Size;
    PCWSTR ValueName;
    PCWSTR NewValueName;
    BOOL b;
    LONG rc;

    if (EnumFirstRegKeyInTree (&e, RootKey)) {

        do {
            Key = OpenRegKeyStr (e.FullKeyName);

            if (Key) {
                if (EnumFirstRegValue (&ev, Key)) {
                    do {
                        if (_wcsistr (ev.ValueName, Search)) {
                            GrowListAppendString (&List, ev.ValueName);
                        }
                    } while (EnumNextRegValue (&ev));

                    Count = GrowListGetSize (&List);
                    u = Count;

                    while (u > 0) {
                        u--;

                        ValueName = GrowListGetString (&List, u);

                        b = FALSE;

                        if (GetRegValueTypeAndSize (Key, ValueName, &Type, &Size)) {

                            Data = GetRegValueData (Key, ValueName);
                            if (Data) {
                                NewValueName = StringSearchAndReplaceW (
                                                    ValueName,
                                                    Search,
                                                    Replace
                                                    );

                                rc = RegSetValueEx (Key, NewValueName, 0, Type, Data, Size);

                                if (rc == ERROR_SUCCESS) {
                                    if (lstrcmpiW (ValueName, NewValueName)) {
                                        rc = RegDeleteValue (Key, ValueName);
                                    }
                                }

                                MemFree (Data);
                                MemFree ((PVOID) NewValueName);
                                SetLastError (rc);

                                b = (rc == ERROR_SUCCESS);
                            }
                        }
                    }
                }

                FreeGrowList (&List);
                CloseRegKey (Key);

            }

        } while (EnumNextRegKeyInTree (&e));
    }
}


VOID
pUpdateValueData (
    IN      PCWSTR Search,
    IN      PCWSTR Replace,
    IN      PCWSTR RootKey
    )
{
    REGTREE_ENUM e;
    REGVALUE_ENUM ev;
    HKEY Key;
    PCWSTR Data;
    PCWSTR NewData;
    LONG rc;

    if (EnumFirstRegKeyInTree (&e, RootKey)) {

        do {
            Key = OpenRegKeyStr (e.FullKeyName);

            if (Key) {
                if (EnumFirstRegValue (&ev, Key)) {
                    do {
                        Data = GetRegValueString (Key, ev.ValueName);

                        if (Data) {
                            if (_wcsistr (Data, Search)) {

                                NewData = StringSearchAndReplaceW (Data, Search, Replace);
                                rc = RegSetValueEx (Key, ev.ValueName, 0, ev.Type, (PBYTE) NewData, SizeOfStringW (NewData));
                                MemFree ((PVOID) NewData);
                            }

                            MemFree ((PVOID) Data);
                        }

                    } while (EnumNextRegValue (&ev));
                }

                CloseRegKey (Key);

            }
        } while (EnumNextRegKeyInTree (&e));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\profmap.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    profmap.c

Abstract:

    Implements profile mapping APIs, to move local profile ownership
    from one user to another.

Author:

    Jim Schmidt (jimschm) 27-May-1999

Revision History:

    <alias> <date> <comments>

--*/


#include "pch.h"

//
// Worker prototypes
//

DWORD
pRemapUserProfile (
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    );

HANDLE
pConnectToServer(
    IN PCWSTR ServerName
    );

VOID
pDisconnectFromServer (
    IN HANDLE RpcHandle
    );

BOOL
pLocalRemapAndMoveUserW (
    IN      DWORD Flags,
    IN      PCWSTR ExistingUser,
    IN      PCWSTR NewUser
    );

VOID
pFixSomeSidReferences (
    PSID ExistingSid,
    PSID NewSid
    );

VOID
pOurGetProfileRoot (
    IN      PCWSTR SidString,
    OUT     PWSTR ProfileRoot
    );

#define REMAP_KEY_NAME      L"$remap$"

//
// Implementation
//

BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    return TRUE;
}



/*++

Routine Description:

  SmartLocalFree and SmartRegCloseKey are cleanup routines that ignore NULL
  values.

Arguments:

  Mem or Key - Specifies the value to clean up.

Return Value:

  None.

--*/

VOID
SmartLocalFree (
    PVOID Mem               OPTIONAL
    )
{
    if (Mem) {
        LocalFree (Mem);
    }
}


VOID
SmartRegCloseKey (
    HKEY Key                OPTIONAL
    )
{
    if (Key) {
        RegCloseKey (Key);
    }
}


BOOL
WINAPI
pLocalRemapUserProfileW (
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    )

/*++

Routine Description:

  pLocalRemapUserProfile begins the process of remapping a profile from one
  SID to another. This function validates the caller's arguments, and then
  calls  pRemapUserProfile to do the work.  Top-level exceptions are handled
  here.


Arguments:

  Flags      - Specifies zero or more profile mapping flags.
  SidCurrent - Specifies the SID of the user who's profile is going to be
               remaped.
  SidNew     - Specifies the SID of the user who will own the profile.

Return Value:

  TRUE if success, FALSE if failure.  GetLastError provides failure code.

--*/

{
    DWORD Error;
    PWSTR CurrentSidString = NULL;
    PWSTR NewSidString = NULL;
    INT Order;
    PWSTR p, q;
    HANDLE hToken = NULL;
    DWORD dwErr1 = ERROR_ACCESS_DENIED, dwErr2 = ERROR_ACCESS_DENIED;

    DEBUGMSG((DM_VERBOSE, "========================================================="));
    DEBUGMSG((
        DM_VERBOSE,
        "RemapUserProfile: Entering, Flags = <0x%x>, SidCurrent = <0x%x>, SidNew = <0x%x>",
        Flags,
        SidCurrent,
        SidNew
        ));

    if (!OpenThreadToken (
            GetCurrentThread(),
            TOKEN_ALL_ACCESS,
            FALSE,
            &hToken
            )) {
        Error = GetLastError();
        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: OpenThreadToken failed with code %u", Error));
        goto Exit;
    }

    if (!IsUserAnAdminMember (hToken)) {
        Error = ERROR_ACCESS_DENIED;
        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Caller is not an administrator"));
        goto Exit;
    }

#ifdef DBG

        {
            PSID DbgSid;
            PWSTR DbgSidString;

            DbgSid = GetUserSid (hToken);

            if (OurConvertSidToStringSid (DbgSid, &DbgSidString)) {
                DEBUGMSG ((DM_VERBOSE, "RemapAndMoveUserW: Caller's SID is %s", DbgSidString));
                DeleteSidString (DbgSidString);
            }

            DeleteUserSid (DbgSid);
        }

#endif

    //
    // Validate args
    //

    Error = ERROR_INVALID_PARAMETER;

    if (!IsValidSid (SidCurrent)) {
        DEBUGMSG((DM_WARNING, "RemapUserProfile: received invalid current user sid."));
        goto Exit;
    }

    if (!IsValidSid (SidNew)) {
        DEBUGMSG((DM_WARNING, "RemapUserProfile: received invalid new user sid."));
        goto Exit;
    }

    //
    // All arguments are valid. Lock the users and call a worker.
    //

    if (!OurConvertSidToStringSid (SidCurrent, &CurrentSidString)) {
        Error = GetLastError();
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Can't stringify current sid."));
        goto Exit;
    }

    if (!OurConvertSidToStringSid (SidNew, &NewSidString)) {
        Error = GetLastError();
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Can't stringify new sid."));
        goto Exit;
    }

    //
    // SID arguments must be unique.  We assume the OS uses the same character set
    // to stringify a SID, even if something like a locale change happens in the
    // middle of our code.
    //

    p = CurrentSidString;
    q = NewSidString;

    while (*p && *p == *q) {
        p++;
        q++;
    }

    Order = *p - *q;

    if (!Order) {
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Both sids match (%s=%s)",
                  CurrentSidString, NewSidString));
        Error = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    ASSERT (lstrcmpi (CurrentSidString, NewSidString));

    //
    // Grab the user profile mutexes in wchar-sorted order.  This eliminates
    // a deadlock with another RemapUserProfile call.
    //

    if (Order < 0) {
        dwErr1 = EnterUserProfileLock (CurrentSidString);
        if (dwErr1 == ERROR_SUCCESS) {
            dwErr2 = EnterUserProfileLock (NewSidString);
        }
    } else {
        dwErr2 = EnterUserProfileLock (NewSidString);
        if (dwErr2 == ERROR_SUCCESS) {
            dwErr1 = EnterUserProfileLock (CurrentSidString);
        }
    }

    if (dwErr1 != ERROR_SUCCESS || dwErr2 != ERROR_SUCCESS) {
        Error = GetLastError();
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Failed to grab a user profile lock, error = %u", Error));
        goto Exit;
    }

    __try {
        Error = pRemapUserProfile (Flags, SidCurrent, SidNew);
    }
    __except (TRUE) {
        Error = ERROR_NOACCESS;
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Exception thrown in PrivateRemapUserProfile."));
    }

Exit:
    if (hToken) {
        CloseHandle (hToken);
    }

    if (CurrentSidString) {
        if(dwErr1 == ERROR_SUCCESS) {
            LeaveUserProfileLock (CurrentSidString);
        }
        DeleteSidString (CurrentSidString);
    }

    if (NewSidString) {
        if(dwErr2 == ERROR_SUCCESS) {
            LeaveUserProfileLock (NewSidString);
        }
        DeleteSidString (NewSidString);
    }

    SetLastError (Error);
    return Error == ERROR_SUCCESS;
}


BOOL
GetNamesFromUserSid (
    IN      PCWSTR RemoteTo,
    IN      PSID Sid,
    OUT     PWSTR *User,
    OUT     PWSTR *Domain
    )

/*++

Routine Description:

  GetNamesFromUserSid obtains the user and domain name from a SID.  The SID
  must be a user account (not a group, printer, etc.).

Arguments:

  RemoteTo - Specifies the computer to remote the call to
  Sid      - Specifies the SID to look up
  User     - Receives the user name.  If non-NULL, the caller must free this
             buffer with LocalFree.
  Domain   - Receives the domain name.  If non-NULL, the caller must free the
             buffer with LocalFree.

Return Value:

  TRUE on success, FALSE on failure, GetLastError provides failure code.

--*/

{
    DWORD UserSize = 256;
    DWORD DomainSize = 256;
    PWSTR UserBuffer = NULL;
    PWSTR DomainBuffer = NULL;
    DWORD Result = ERROR_SUCCESS;
    BOOL b;
    SID_NAME_USE use;

    //
    // Allocate initial buffers of 256 chars
    //

    UserBuffer = LocalAlloc (LPTR, UserSize * sizeof (WCHAR));
    if (!UserBuffer) {
        Result = ERROR_OUTOFMEMORY;
        DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Alloc error %u.", GetLastError()));
        goto Exit;
    }

    DomainBuffer = LocalAlloc (LPTR, DomainSize * sizeof (WCHAR));
    if (!DomainBuffer) {
        Result = ERROR_OUTOFMEMORY;
        DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Alloc error %u.", GetLastError()));
        goto Exit;
    }

    b = LookupAccountSid (
            RemoteTo,
            Sid,
            UserBuffer,
            &UserSize,
            DomainBuffer,
            &DomainSize,
            &use
            );

    if (!b) {
        Result = GetLastError();

        if (Result == ERROR_NONE_MAPPED) {
            DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Account not found"));
            goto Exit;
        }

        if (UserSize <= 256 && DomainSize <= 256) {
            DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Unexpected error %u", Result));
            Result = ERROR_UNEXP_NET_ERR;
            goto Exit;
        }

        //
        // Try allocating new buffers
        //

        if (UserSize > 256) {
            SmartLocalFree (UserBuffer);
            UserBuffer = LocalAlloc (LPTR, UserSize * sizeof (WCHAR));

            if (!UserBuffer) {
                Result = ERROR_OUTOFMEMORY;
                DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Alloc error %u.", GetLastError()));
                goto Exit;
            }
        }

        if (DomainSize > 256) {
            SmartLocalFree (DomainBuffer);
            DomainBuffer = LocalAlloc (LPTR, DomainSize * sizeof (WCHAR));

            if (!DomainBuffer) {
                Result = ERROR_OUTOFMEMORY;
                DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Alloc error %u.", GetLastError()));
                goto Exit;
            }
        }

        //
        // Try look up again
        //

        b = LookupAccountSid (
                RemoteTo,
                Sid,
                UserBuffer,
                &UserSize,
                DomainBuffer,
                &DomainSize,
                &use
                );

        if (!b) {
            //
            // All attempts failed.
            //

            Result = GetLastError();

            if (Result != ERROR_NONE_MAPPED) {
                DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Unexpected error %u (2)", Result));
                Result = ERROR_UNEXP_NET_ERR;
            }

            goto Exit;
        }
    }

    //
    // LookupAccountSid succeeded.  Now verify that the accout type
    // is correct.
    //

    if (use != SidTypeUser) {
        DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: SID specifies bad account type: %u", (DWORD) use));
        Result = ERROR_NONE_MAPPED;
        goto Exit;
    }

    ASSERT (Result == ERROR_SUCCESS);

Exit:
    if (Result != ERROR_SUCCESS) {

        SmartLocalFree (UserBuffer);
        SmartLocalFree (DomainBuffer);

        SetLastError (Result);
        return FALSE;
    }

    *User = UserBuffer;
    *Domain = DomainBuffer;

    return TRUE;
}


DWORD
pRemapUserProfile (
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    )

/*++

Routine Description:

  pRemapUserProfile changes the security of a profile from one SID to
  another. Upon completion, the original user will not have access to the
  profile, and the new user will.

Arguments:

  Flags      - Specifies zero or more profile remap flags.  Specify
               REMAP_PROFILE_NOOVERWRITE to guarantee no existing user
               setting is overwritten.  Specify
               REMAP_PROFILE_NOUSERNAMECHANGE to make sure the user name does
               not change.
  SidCurrent - Specifies the current user SID. This user must own the profile,
               and upon completion, the user will not have a local profile.
  SidNew     - Specifies the new user SID.  This user will own the profile
               upon completion.

Return Value:

  A Win32 status code.

--*/

{
    PWSTR CurrentUser = NULL;
    PWSTR CurrentDomain = NULL;
    PWSTR CurrentSidString = NULL;
    PWSTR NewUser = NULL;
    PWSTR NewDomain = NULL;
    PWSTR NewSidString = NULL;
    DWORD Size;
    DWORD Size2;
    DWORD Result = ERROR_SUCCESS;
    INT UserCompare;
    INT DomainCompare;
    BOOL b;
    HKEY hCurrentProfile = NULL;
    HKEY hNewProfile = NULL;
    HKEY hProfileList = NULL;
    LONG rc;
    DWORD Disposition;
    DWORD Index;
    PWSTR pValue = NULL;
    DWORD ValueSize;
    PBYTE pData = NULL;
    DWORD DataSize;
    DWORD Type;
    BOOL CleanUpFailedCopy = FALSE;
    WCHAR ProfileDir[MAX_PATH];
    DWORD Loaded;

    //
    // The caller must make sure we have valid args.
    //

    //
    // Get the names for the user
    //

    b = GetNamesFromUserSid (NULL, SidCurrent, &CurrentUser, &CurrentDomain);

    if (!b) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Current user SID is not a valid user"));
        goto Exit;
    }

    b = GetNamesFromUserSid (NULL, SidNew, &NewUser, &NewDomain);

    if (!b) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: New user SID is not a valid user"));
        goto Exit;
    }

    //
    // Compare them
    //

    UserCompare = lstrcmpi (CurrentUser, NewUser);
    DomainCompare = lstrcmpi (CurrentDomain, NewDomain);

    //
    // Either the user or domain must be different.  If the caller specifies
    // REMAP_PROFILE_NOUSERNAMECHANGE, then user cannot be different.
    //

    if (UserCompare == 0 && DomainCompare == 0) {
        //
        // This case should not be possible.
        //

        ASSERT (FALSE);
        Result = ERROR_INVALID_PARAMETER;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: User and domain names match for different SIDs"));
        goto Exit;
    }

    if ((Flags & REMAP_PROFILE_NOUSERNAMECHANGE) && UserCompare != 0) {
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: User name can't change from %s to %s",
                  CurrentUser, NewUser));
        Result = ERROR_BAD_USERNAME;
        goto Exit;
    }

    //
    // The SID change now makes sense.  Let's change it.  Start by
    // obtaining a string version of the SID.
    //

    if (!OurConvertSidToStringSid (SidCurrent, &CurrentSidString)) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't stringify current sid."));
        goto Exit;
    }

    if (!OurConvertSidToStringSid (SidNew, &NewSidString)) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't stringify new sid."));
        goto Exit;
    }

    //
    // Prepare transfer memory
    //

    ValueSize = 1024;
    pValue = (PWSTR) LocalAlloc (LPTR, ValueSize);
    if (!pValue) {
        Result = ERROR_OUTOFMEMORY;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Value alloc error %d", GetLastError()));
        goto Exit;
    }

    DataSize = 4096;
    pData = (PBYTE) LocalAlloc (LPTR, DataSize);
    if (!pData) {
        Result = ERROR_OUTOFMEMORY;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Data alloc error %d", GetLastError()));
        goto Exit;
    }

    //
    // Open the profile list key
    //

    rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH, 0, KEY_READ|KEY_WRITE,
                       &hProfileList);

    if (rc != ERROR_SUCCESS) {
        Result = rc;
        DEBUGMSG((DM_WARNING, "PrivateRemapUserProfile: Can't open profile list key."));
        goto Exit;
    }

    //
    // Open the current user's profile list key.  Then make sure the profile is not
    // loaded, and get the profile directory.
    //

    rc = RegOpenKeyEx (hProfileList, CurrentSidString, 0, KEY_READ, &hCurrentProfile);

    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            Result = ERROR_NO_SUCH_USER;
        } else {
            Result = rc;
        }

        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't open current user's profile list key."));
        goto Exit;
    }

    Size = sizeof(Loaded);
    rc = RegQueryValueEx (hCurrentProfile, L"RefCount", NULL, &Type, (PBYTE) &Loaded, &Size);
    if (rc != ERROR_SUCCESS || Type != REG_DWORD) {
        DEBUGMSG((DM_VERBOSE, "pRemapUserProfile: Current user does not have a ref count."));
        Loaded = 0;
    }

    if (Loaded) {
        Result = ERROR_ACCESS_DENIED;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Current user profile is loaded."));
        goto Exit;
    }

    Size = sizeof(ProfileDir);
    rc = RegQueryValueEx (hCurrentProfile, PROFILE_IMAGE_VALUE_NAME, NULL,
                          &Type, (LPBYTE) ProfileDir, &Size);

    if (rc != ERROR_SUCCESS || (Type != REG_SZ && Type != REG_EXPAND_SZ)) {
        Result = ERROR_BAD_USER_PROFILE;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Current user does not have a profile path."));
        goto Exit;
    }

    //
    // Now open the new user's key.  If it already exists, then the
    // caller can specify REMAP_PROFILE_NOOVERWRITE to make sure
    // we don't blow away an existing profile setting.
    //

    rc = RegCreateKeyEx(hProfileList, NewSidString, 0, 0, 0,
                        KEY_READ | KEY_WRITE, NULL, &hNewProfile, &Disposition);

    if (rc != ERROR_SUCCESS) {
        Result = rc;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't create destination profile entry."));
        goto Exit;
    }

    if (Disposition == REG_OPENED_EXISTING_KEY) {
        //
        // Did the caller specify REMAP_PROFILE_NOOVERWRITE?
        //

        if (Flags & REMAP_PROFILE_NOOVERWRITE) {
            Result = ERROR_USER_EXISTS;
            DEBUGMSG((DM_VERBOSE, "pRemapUserProfile: Destination profile entry exists."));
            goto Exit;
        }

        //
        // Verify existing profile is not loaded
        //

        Size = sizeof(Loaded);
        rc = RegQueryValueEx (hNewProfile, L"RefCount", NULL, &Type, (PBYTE) &Loaded, &Size);
        if (rc != ERROR_SUCCESS || Type != REG_DWORD) {
            DEBUGMSG((DM_WARNING, "pRemapUserProfile: Existing destination user does not have a ref count."));
            Loaded = 0;
        }

        if (Loaded) {
            Result = ERROR_ACCESS_DENIED;
            DEBUGMSG((DM_WARNING, "pRemapUserProfile: Existing destination user profile is loaded."));
            goto Exit;
        }

        //
        // Remove the key
        //

        RegCloseKey (hNewProfile);
        hNewProfile = NULL;

        if (!RegDelnode (hProfileList, NewSidString)) {
            Result = GetLastError();
            DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't reset new profile list key."));
            goto Exit;
        }

        //
        // Reopen the destination key
        //

        rc = RegCreateKeyEx(hProfileList, NewSidString, 0, 0, 0,
                            KEY_READ | KEY_WRITE, NULL, &hNewProfile, &Disposition);

        if (rc != ERROR_SUCCESS) {
            Result = rc;
            DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't create new profile list key after successful delete."));
            goto Exit;
        }
    }

    //
    // Transfer contents of current user key to new user.  Unfortunately,
    // because the registry APIs don't have a rename capability, we can't
    // be fool-proof here.  If we fail to transfer one or more settings,
    // the profile can wind up broken.
    //
    // If an error is encountered, we abandon the successful work above,
    // which includes possibly deletion of an existing profile list key.
    //

    CleanUpFailedCopy = TRUE;

    for (Index = 0 ; ; Index++) {

        Size = ValueSize;
        Size2 = DataSize;

        rc = RegEnumValue (hCurrentProfile, Index, pValue, &Size, NULL,
                           &Type, pData, &Size2);

        if (rc == ERROR_NO_MORE_ITEMS) {
            break;
        }

        if (rc == ERROR_MORE_DATA) {
            //
            // Grow buffer(s) and try again
            //

            ASSERT (Size > ValueSize || Size2 > DataSize);

            if (Size > ValueSize) {
                LocalFree (pValue);
                pValue = (PWSTR) LocalAlloc (LPTR, Size);
                if (!pValue) {
                    Result = ERROR_OUTOFMEMORY;
                    DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't alloc %u bytes for value name.", Size));
                    goto Exit;
                }
            }

            if (Size2 > DataSize) {
                LocalFree (pData);
                pData = (PBYTE) LocalAlloc (LPTR, Size2);
                if (!pData) {
                    Result = ERROR_OUTOFMEMORY;
                    DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't alloc %u bytes for value data.", Size2));
                    goto Exit;
                }
            }

            rc = RegEnumValue (hCurrentProfile, Index, pValue, &Size, NULL,
                           &Type, pData, &Size2);
        }

        ASSERT (rc != ERROR_MORE_DATA);

        if (rc == ERROR_SUCCESS) {
            //
            // We have the value, now save it.
            //

            rc = RegSetValueEx (hNewProfile, pValue, 0, Type, pData, Size2);

            if (rc != ERROR_SUCCESS) {
                Result = rc;
                DEBUGMSG((DM_WARNING, "pRemapUserProfile: RegSetValueEx returned %d.", rc));
                goto Exit;
            }

        } else {
            Result = rc;
            DEBUGMSG((DM_WARNING, "pRemapUserProfile: RegEnumValueEx returned %d.", rc));
            goto Exit;
        }
    }

    //
    // Update new profile's SID
    //

    rc = RegSetValueEx (hNewProfile, L"SID", 0, REG_BINARY, SidNew, GetLengthSid (SidNew));

    if (rc != ERROR_SUCCESS) {
        Result = rc;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Error %d setting new profile SID.", Result));
        goto Exit;
    }

    //
    // Delete GUID value if it exists.  It will get re-established on the next logon.
    //

    RegDeleteValue (hNewProfile, L"GUID");

    //
    // Set security on the new key.  We pass pNewSid and that is all
    // CreateUserProfile needs.  To get by arg checking, we throw in
    // NewUser as the user name.
    //

    if (!UpdateProfileSecurity (SidNew)) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: UpdateProfileSecurity returned %u.", Result));
        goto Exit;
    }

    //
    // Remove current user profile list key.  If removal fails, the API
    // will not fail.
    //

    CleanUpFailedCopy = FALSE;

    RegCloseKey (hCurrentProfile);
    hCurrentProfile = NULL;

    if (!DeleteProfileRegistrySettings (CurrentSidString)) {
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Delete of original profile failed with code %d.  Ignoring.", GetLastError()));
    }

    //
    // Success -- the profile was transferred and nothing went wrong
    //

    RegFlushKey (HKEY_LOCAL_MACHINE);
    ASSERT (Result == ERROR_SUCCESS);

Exit:

    SmartRegCloseKey (hCurrentProfile);
    SmartRegCloseKey (hNewProfile);

    if (CleanUpFailedCopy) {
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Backing out changes because of failure"));
        RegDelnode (hProfileList, NewSidString);
    }

    SmartLocalFree (CurrentUser);
    SmartLocalFree (CurrentDomain);
    SmartLocalFree (NewUser);
    SmartLocalFree (NewDomain);

    DeleteSidString (CurrentSidString);
    DeleteSidString (NewSidString);

    SmartLocalFree (pValue);
    SmartLocalFree (pData);

    SmartRegCloseKey (hProfileList);

    return Result;
}


BOOL
WINAPI
RemapUserProfileW (
    IN      PCWSTR Computer,
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    )

/*++

Routine Description:

  RemapUserProfileW is the exported API.  It calls the local version via RPC.

Arguments:

  Computer   - Specifies the computer to remote the API to.  If NULL or ".",
               the API will run locally.  If non-NULL, the API will run on
               the remote computer.
  Flags      - Specifies the profile mapping flags.  See implementation above
               for details.
  SidCurrent - Specifies the SID of the user who owns the profile.
  SidNew     - Specifies the SID of the user who will own the profile after
               the API completes.

Return Value:

  TRUE if success, FALSE if failure.  GetLastError provides the failure code.

--*/

{
    DWORD Result = ERROR_SUCCESS;
    HANDLE RpcHandle;

    if (!IsValidSid (SidCurrent)) {
        DEBUGMSG((DM_WARNING, "RemapUserProfileW: received invalid current user sid."));
        SetLastError (ERROR_INVALID_SID);
        return FALSE;
    }

    if (!IsValidSid (SidNew)) {
        DEBUGMSG((DM_WARNING, "RemapUserProfileW: received invalid new user sid."));
        SetLastError (ERROR_INVALID_SID);
        return FALSE;
    }



    if (!Computer) {
        Computer = L".";
    }

    __try {
        RpcHandle = pConnectToServer (Computer);
        if (!RpcHandle) {
            Result = GetLastError();
        }
    }
    __except (TRUE) {
        Result = ERROR_NOACCESS;
    }

    if (Result != ERROR_SUCCESS) {
        SetLastError (Result);
        return FALSE;
    }

    Result = ProfMapCli_RemoteRemapUserProfile (
                RpcHandle,
                Flags,
                SidCurrent,
                GetLengthSid (SidCurrent),
                SidNew,
                GetLengthSid (SidNew)
                );

    pDisconnectFromServer (RpcHandle);

    if (Result != ERROR_SUCCESS) {
        SetLastError (Result);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
RemapUserProfileA (
    IN      PCSTR Computer,
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    )

/*++

Routine Description:

  RemapUserProfileA is a wrapper to RemapUserProfileW.

Arguments:

  Computer   - Specifies the computer to remote the API to.  If NULL or ".",
               the API will run locally.  If non-NULL, the API will run on
               the remote computer.
  Flags      - Specifies the profile mapping flags.  See implementation above
               for details.
  SidCurrent - Specifies the SID of the user who owns the profile.
  SidNew     - Specifies the SID of the user who will own the profile after
               the API completes.

Return Value:

  TRUE if success, FALSE if failure.  GetLastError provides the failure code.

--*/

{
    PWSTR UnicodeComputer;
    BOOL b;
    DWORD Err;

    if (!Computer) {
        UnicodeComputer = NULL;
    } else {
        UnicodeComputer = ProduceWFromA (Computer);
        if (!UnicodeComputer) {
            return FALSE;
        }
    }

    b = RemapUserProfileW (UnicodeComputer, Flags, SidCurrent, SidNew);

    Err = GetLastError();
    SmartLocalFree (UnicodeComputer);
    SetLastError (Err);

    return b;
}


DWORD
WINAPI
ProfMapSrv_RemoteRemapUserProfile (
    IN      HANDLE RpcHandle,
    IN      DWORD Flags,
    IN      PBYTE CurrentSid,
    IN      DWORD CurrentSidSize,
    IN      PBYTE NewSid,
    IN      DWORD NewSidSize
    )

/*++

Routine Description:

  ProfMapSrv_RemoteRemapUserProfile implements the server-side API.  This
  function is called when a client makes a RPC request.

Arguments:

  RpcHandle      - The binding handle, provided by the MIDL stub code.
  Flags          - Specifies the profile mapping flags.
  CurrentSid     - Specifies the SID of the user who owns the profile.
  CurrentSidSize - Specifies the size, in bytes, of CurrentSid.
  NewSid         - Specifies the SID of the user who will own the profile
                   after completion.
  NewSidSize     - Specifies the size, in bytes, of NewSid.

Return Value:

  A Win32 status code.  This value is passed via the MIDL stub back to the
  RPC client.

--*/

{
    DWORD Result;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcImpersonateClient (NULL);

    if (RpcStatus != ERROR_SUCCESS) {
        DEBUGMSG((DM_WARNING, "Call request denied by RPC impersonation.", RpcHandle));
        return RpcStatus;
    }

    if (pLocalRemapUserProfileW (Flags, (PSID) CurrentSid, (PSID) NewSid)) {
        Result = ERROR_SUCCESS;
    } else {
        Result = GetLastError();
    }

    RpcRevertToSelf();

    DEBUGMSG((DM_VERBOSE, "RPC request completed with code %u", Result));

    return Result;
}


HANDLE
pConnectToServer(
    IN PCWSTR ServerName
    )

/*++

Routine Description:

  pConnectToServer connects a client to a server.

Arguments:

  ServerName - Specifies the server to connect to.  The server name is a
               standard name ("\\computer" or ".").

Return Value:

  A handle to the server connection, or NULL if the server could not be
  reached.  GetLastError provides the failure code.

--*/

{
    RPC_BINDING_HANDLE RpcHandle;
    NTSTATUS Status;

    Status = RpcpBindRpc (
                (PWSTR) ServerName,
                L"ProfMapApi",
                0,
                &RpcHandle
                );

    if (!NT_SUCCESS(Status)) {
        SetLastError (Status);
        return NULL;
    }

    return RpcHandle;
}


VOID
pDisconnectFromServer (
    IN HANDLE RpcHandle
    )

/*++

Routine Description:

  pDisconnectFromServer closes the server binding handle opened by
  pConnectToServer.

Arguments:

  RpcHandle - Specifies a non-NULL binding handle, as returned from
              pConnectToServer.

Return Value:

  None.

--*/

{
    RpcpUnbindRpc( RpcHandle );
}



BOOL
WINAPI
InitializeProfileMappingApi (
    VOID
    )

/*++

Routine Description:

  InitializeProfileMappingApi is called by winlogon.exe to initialize the RPC
  server interfaces.

Arguments:

  None.

Return Value:

  TRUE if successful, FALSE otherwise.  GetLastError provides the failure
  code.

--*/

{
    NTSTATUS Status;

    Status = RpcpInitRpcServer();
    if (!NT_SUCCESS(Status)) {
        SetLastError (Status);
        return FALSE;
    }

    Status = RpcpStartRpcServer( L"ProfMapApi", ProfMapSrv_pmapapi_ServerIfHandle );
    if (!NT_SUCCESS(Status)) {
        SetLastError (Status);
        return FALSE;
    }

    return TRUE;
}


BOOL
pHasPrefix (
    IN      PCWSTR Prefix,
    IN      PCWSTR String
    )

/*++

Routine Description:

  pHasPrefix checks String to see if it begins with Prefix.  The check is
  case-insensitive.

Arguments:

  Prefix - Specifies the prefix to check
  String - Specifies the string that may or may not have the prefix.

Return Value:

  TRUE if String has the prefix, FALSE otherwise.

--*/

{
    WCHAR c1 = 0, c2 = 0;

    while (*Prefix) {
        c1 = (WCHAR) CharLower ((PWSTR) (*Prefix++));
        c2 = (WCHAR) CharLower ((PWSTR) (*String++));

        if (c1 != c2) {
            break;
        }
    }

    return c1 == c2;
}


PSID
pGetSidForUser (
    IN      PCWSTR Name
    )

/*++

Routine Description:

  pGetSidForUser is a wrapper to LookupAccountSid.  It allocates the SID via
  LocalAlloc.

Arguments:

  Name - Specifies the user name to look up

Return Value:

  A pointer to the SID, which must be freed with LocalFree, or NULL on error.
  GetLastError provides failure code.

--*/

{
    DWORD Size;
    PSID Buffer;
    DWORD DomainSize;
    PWSTR Domain;
    SID_NAME_USE Use;
    BOOL b = FALSE;

    Size = 256;
    Buffer = (PSID) LocalAlloc (LPTR, Size);
    if (!Buffer) {
        return NULL;
    }

    DomainSize = 256;
    Domain = (PWSTR) LocalAlloc (LPTR, DomainSize);

    if (!Domain) {
        LocalFree (Buffer);
        return NULL;
    }

    b = LookupAccountName (
            NULL,
            Name,
            Buffer,
            &Size,
            Domain,
            &DomainSize,
            &Use
            );

    if (Size > 256) {
        LocalFree (Buffer);
        Buffer = (PSID) LocalAlloc (LPTR, Size);
        if (!Buffer) {
            LocalFree (Domain);
            return NULL;
        }
    }

    if (DomainSize > 256) {
        LocalFree (Domain);
        Domain = (PWSTR) LocalAlloc (LPTR, DomainSize);
        if (!Domain) {
            LocalFree (Buffer);
            return NULL;
        }
    }

    if (Size > 256 || DomainSize > 256) {

        b = LookupAccountName (
                NULL,
                Name,
                Buffer,
                &Size,
                Domain,
                &DomainSize,
                &Use
                );
    }

    LocalFree (Domain);

    if (!b) {
        LocalFree (Buffer);
        return NULL;
    }

    return Buffer;
}


BOOL
WINAPI
RemapAndMoveUserW (
    IN      PCWSTR RemoteTo,
    IN      DWORD Flags,
    IN      PCWSTR ExistingUser,
    IN      PCWSTR NewUser
    )

/*++

Routine Description:

  RemapAndMoveUserW is an API entry point to move settings of one SID to
  another.  In particular, it moves the local user profile, local group
  memberships, some registry use of the SID, and some file system use of the
  SID.

Arguments:

  RemoteTo     - Specifies the computer to remote the call to.  Specify a
                 standard name ("\\computer" or ".").  If NULL, the call will
                 be run locally.
  Flags        - Specifies zero, or REMAP_PROFILE_NOOVERWRITE.
  ExistingUser - Specifies the existing user, in DOMAIN\user format.  This
                 user must have a local profile.
  NewUser      - Specifies the new user who will own ExistingUser's profile
                 after completion.  Specify the user in DOMAIN\User format.

Return Value:

  TRUE on success, FALSE on failure, GetLastError provides the failure code.

--*/

{
    DWORD Result = ERROR_SUCCESS;
    HANDLE RpcHandle;

    if (!RemoteTo) {
        RemoteTo = L".";
    }

    __try {
        RpcHandle = pConnectToServer (RemoteTo);
        if (!RpcHandle) {
            Result = GetLastError();
        }
    }
    __except (TRUE) {
        Result = ERROR_NOACCESS;
    }

    if (Result != ERROR_SUCCESS) {
        SetLastError (Result);
        return FALSE;
    }

    __try {
        Result = ProfMapCli_RemoteRemapAndMoveUser (
                    RpcHandle,
                    Flags,
                    (PWSTR) ExistingUser,
                    (PWSTR) NewUser
                    );
    }
    __except (TRUE) {
        Result = ERROR_NOACCESS;
    }

    pDisconnectFromServer (RpcHandle);

    if (Result != ERROR_SUCCESS) {
        SetLastError (Result);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
RemapAndMoveUserA (
    IN      PCSTR RemoteTo,
    IN      DWORD Flags,
    IN      PCSTR ExistingUser,
    IN      PCSTR NewUser
    )

/*++

Routine Description:

  RemapAndMoveUserA is the ANSI API entry point.  It calls RemapAndMoveUserW.

Arguments:

  RemoteTo     - Specifies the computer to remote the call to.  Specify a
                 standard name ("\\computer" or ".").  If NULL, the call will
                 be run locally.
  Flags        - Specifies zero, or REMAP_PROFILE_NOOVERWRITE.
  ExistingUser - Specifies the existing user, in DOMAIN\user format.  This
                 user must have a local profile.
  NewUser      - Specifies the new user who will own ExistingUser's profile
                 after completion.  Specify the user in DOMAIN\User format.

Return Value:

  TRUE on success, FALSE on failure, GetLastError provides the failure code.

--*/

{
    PWSTR UnicodeRemoteTo = NULL;
    PWSTR UnicodeExistingUser = NULL;
    PWSTR UnicodeNewUser = NULL;
    DWORD Err;
    BOOL b = TRUE;

    __try {
        Err = GetLastError();

        if (RemoteTo) {
            UnicodeRemoteTo = ProduceWFromA (RemoteTo);
            if (!UnicodeRemoteTo) {
                b = FALSE;
                Err = GetLastError();
            }
        }

        if (b) {
            UnicodeExistingUser = ProduceWFromA (ExistingUser);
            if (!UnicodeExistingUser) {
                b = FALSE;
                Err = GetLastError();
            }
        }

        if (b) {
            UnicodeNewUser = ProduceWFromA (NewUser);
            if (!UnicodeNewUser) {
                b = FALSE;
                Err = GetLastError();
            }
        }

        if (b) {
            b = RemapAndMoveUserW (
                    UnicodeRemoteTo,
                    Flags,
                    UnicodeExistingUser,
                    UnicodeNewUser
                    );

            if (!b) {
                Err = GetLastError();
            }
        }

        SmartLocalFree (UnicodeRemoteTo);
        SmartLocalFree (UnicodeExistingUser);
        SmartLocalFree (UnicodeNewUser);
    }
    __except (TRUE) {
        SetLastError (ERROR_NOACCESS);
    }

    SetLastError (Err);
    return b;
}


DWORD
WINAPI
ProfMapSrv_RemoteRemapAndMoveUser (
    IN      HANDLE RpcHandle,
    IN      DWORD Flags,
    IN      PWSTR ExistingUser,
    IN      PWSTR NewUser
    )

/*++

Routine Description:

  ProfMapSrv_RemoteRemapAndMoveUser implements the server function that is
  called whenever a client makes an RPC request. This function calls the
  local worker.

Arguments:

  RpcHandle    - A binding handle provided by the MIDL stub code.
  Flags        - Specifies the profile mapping flags.
  ExistingUser - Specifies the user who owns the profile.
  NewUser      - Specifies the user who will take ownership of ExistingUser's
                 profile.

Return Value:

  A Win32 status code, which is passed back to the client via RPC.

--*/

{
    DWORD Result;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcImpersonateClient (NULL);

    if (RpcStatus != ERROR_SUCCESS) {
        DEBUGMSG((DM_WARNING, "Call request denied by RPC impersonation.", RpcHandle));
        return RpcStatus;
    }

    if (pLocalRemapAndMoveUserW (Flags, ExistingUser, NewUser)) {
        Result = ERROR_SUCCESS;
    } else {
        Result = GetLastError();
    }

    RpcRevertToSelf();

    DEBUGMSG((DM_VERBOSE, "RPC request completed with code %u", Result));

    return Result;
}


BOOL
pDoesUserHaveProfile (
    IN      PSID Sid
    )

/*++

Routine Description:

  pDoesUserHaveProfile checks if a profile exists for the user, who is
  specified by the SID.

Arguments:

  Sid - Specifies the SID of the user who may or may not have a local
        profile

Return Value:

  TRUE if the user has a profile and the profile directory exists, FALSE
  otherwise.

--*/

{
    WCHAR ProfileDir[MAX_PATH];

    if (GetProfileRoot (Sid, ProfileDir)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pLocalRemapAndMoveUserW (
    IN      DWORD Flags,
    IN      PCWSTR ExistingUser,
    IN      PCWSTR NewUser
    )

/*++

Routine Description:

  pLocalRemapAndMoveUserW implements the remap and move of a user's security
  settings. This includes moving the user's profile, moving local group
  membership, adjusting some of the SIDs in the registry, and adjusting some
  of the SID directories in the file system. Upon completion, NewUser will
  own ExistingUser's profile.

Arguments:

  Flags        - Specifies the profile remap flags.  See RemapUserProfile.
  ExistingUser - Specifies the user who owns the local profile, in
                 DOMAIN\User format.
  NewUser      - Specifies the user who will own ExistingUser's profile upon
                 completion.  Specify the user in DOMAIN\User format.

Return Value:

  TRUE upon success, FALSE otherwise, GetLastError provides the failure code.

--*/

{
    NET_API_STATUS Status;
    DWORD Entries;
    DWORD EntriesRead;
    BOOL b = FALSE;
    DWORD Error;
    WCHAR Computer[MAX_PATH];
    DWORD Size;
    PSID ExistingSid = NULL;
    PSID NewSid = NULL;
    USER_INFO_0 ui0;
    PLOCALGROUP_USERS_INFO_0 lui0 = NULL;
    LOCALGROUP_MEMBERS_INFO_0 lmi0;
    PCWSTR FixedExistingUser;
    PCWSTR FixedNewUser;
    BOOL NewUserIsOnDomain = FALSE;
    BOOL ExistingUserIsOnDomain = FALSE;
    HANDLE hToken = NULL;
    BOOL NewUserProfileExists = FALSE;

    Error = GetLastError();

    __try {

        //
        // Guard the API for admins only
        //

        if (!OpenThreadToken (
                GetCurrentThread(),
                TOKEN_ALL_ACCESS,
                FALSE,
                &hToken
                )) {
            Error = GetLastError();
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: OpenThreadToken failed with code %u", Error));
            goto Exit;
        }

        if (!IsUserAnAdminMember (hToken)) {
            Error = ERROR_ACCESS_DENIED;
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Caller is not an administrator"));
            goto Exit;
        }

#ifdef DBG

        {
            PSID DbgSid;
            PWSTR DbgSidString;

            DbgSid = GetUserSid (hToken);

            if (OurConvertSidToStringSid (DbgSid, &DbgSidString)) {
                DEBUGMSG ((DM_VERBOSE, "RemapAndMoveUserW: Caller's SID is %s", DbgSidString));
                DeleteSidString (DbgSidString);
            }

            DeleteUserSid (DbgSid);
        }

#endif

        //
        // Determine if profile users are domain users or local users.
        // Because the user names are in netbios format of domain\user,
        // we know the user is local only when domain matches the
        // computer name.
        //

        Size = MAX_PATH - 2;
        if (!GetComputerName (Computer, &Size)) {
            Error = GetLastError();
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: GetComputerName failed with code %u", Error));
            goto Exit;
        }

        lstrcat (Computer, L"\\");

        if (pHasPrefix (Computer, ExistingUser)) {
            FixedExistingUser = ExistingUser + lstrlen (Computer);
        } else {
            FixedExistingUser = ExistingUser;
            ExistingUserIsOnDomain = TRUE;
        }

        if (pHasPrefix (Computer, NewUser)) {
            FixedNewUser = NewUser + lstrlen (Computer);
        } else {
            FixedNewUser = NewUser;
            NewUserIsOnDomain = TRUE;
        }

        //
        // Get the SID of the NewUser.  This might fail.
        //

        NewSid = pGetSidForUser (NewUser);

        if (!NewSid) {
            Status = GetLastError();
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Can't get info for %s, rc=%u", NewUser, Status));
        } else {
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: NewUser exists"));

            //
            // Determine if new user has a profile
            //

            NewUserProfileExists = pDoesUserHaveProfile (NewSid);

            if (NewUserProfileExists) {
                DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: NewUser profile exists"));
            }
        }

        if (NewUserProfileExists && (Flags & REMAP_PROFILE_NOOVERWRITE)) {
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Can't overwrite existing user"));
            Error = ERROR_USER_EXISTS;
            goto Exit;
        }

        //
        // Get the SID for ExitingUser.  This cannot fail.
        //

        ExistingSid = pGetSidForUser (ExistingUser);
        if (!ExistingSid) {
            Error = ERROR_NONE_MAPPED;
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: No SID for %s", ExistingUser));
            goto Exit;
        }

        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Got SIDs for users"));

        //
        // Decide which of the four cases we are doing:
        //
        // Case 1: Local account to local account
        // Case 2: Domain account to local account
        // Case 3: Local account to domain account
        // Case 4: Domain account to domain account
        //

        if (!NewUserIsOnDomain && !ExistingUserIsOnDomain) {

            //
            // For Case 1, all we do is rename the user, and we're done.
            //

            //
            // To rename the user, it may be necessary to delete the
            // existing "new" user.  This abandons a profile.
            //

            if (NewSid) {

                if (Flags & REMAP_PROFILE_NOOVERWRITE) {
                    DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Can't overwrite %s", FixedNewUser));
                    Error = ERROR_USER_EXISTS;
                    goto Exit;
                }

                Status = NetUserDel (NULL, FixedNewUser);

                if (Status != ERROR_SUCCESS) {
                    Error = Status;
                    DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Can't remove %s, code %u", FixedNewUser, Status));
                    goto Exit;
                }

            }

            //
            // Now the NewUser does not exist.  We can move ExistingUser
            // to MoveUser via net apis.  The SID doesn't change.
            //

            ui0.usri0_name = (PWSTR) FixedNewUser;

            Status = NetUserSetInfo (
                        NULL,
                        FixedExistingUser,
                        0,
                        (PBYTE) &ui0,
                        NULL
                        );

            if (Status != ERROR_SUCCESS) {
                Error = Status;

                DEBUGMSG((
                    DM_VERBOSE,
                    "RemapAndMoveUserW: Error renaming %s to %s, code %u",
                    FixedExistingUser,
                    FixedNewUser,
                    Status
                    ));

                goto Exit;
            }

            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Renamed local user %s to %s", FixedExistingUser, FixedNewUser));

            b = TRUE;
            goto Exit;

        }

        //
        // For cases 2 through 4, we need to verify that the new user
        // already exists, then we adjust the system security and fix
        // SID use.
        //

        if (!NewSid) {
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: User %s must exist", FixedNewUser));
            Error = ERROR_NO_SUCH_USER;
            goto Exit;
        }

        //
        // Move the profile from ExistingUser to NewUser
        //

        if (!pLocalRemapUserProfileW (0, ExistingSid, NewSid)) {
            Error = GetLastError();
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: LocalRemapUserProfileW failed with code %u", Error));
            goto Exit;
        }

        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Profile was remapped"));

        //
        // Put NewUser in all the same groups as ExistingUser
        //

        Status = NetUserGetLocalGroups (
                    NULL,
                    FixedExistingUser,
                    0,
                    0,
                    (PBYTE *) &lui0,
                    MAX_PREFERRED_LENGTH,
                    &EntriesRead,
                    &Entries
                    );

        if (Status != ERROR_SUCCESS) {
            Error = Status;
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: NetUserGetLocalGroups failed with code %u for  %s", Status, FixedExistingUser));
            goto Exit;
        }

        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Local groups: %u", EntriesRead));

        lmi0.lgrmi0_sid = NewSid;

        for (Entries = 0 ; Entries < EntriesRead ; Entries++) {

            Status = NetLocalGroupAddMembers (
                        NULL,
                        lui0[Entries].lgrui0_name,
                        0,
                        (PBYTE) &lmi0,
                        1
                        );

            if (Status == ERROR_MEMBER_IN_ALIAS) {
                Status = ERROR_SUCCESS;
            }

            if (Status != ERROR_SUCCESS) {
                Error = Status;

                DEBUGMSG((
                    DM_VERBOSE,
                    "RemapAndMoveUserW: NetLocalGroupAddMembers failed with code %u for %s",
                    Status,
                    lui0[Entries].lgrui0_name
                    ));

                goto Exit;
            }
        }

        NetApiBufferFree (lui0);
        lui0 = NULL;

        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Local groups transferred"));

        //
        // Perform fixups
        //

        pFixSomeSidReferences (ExistingSid, NewSid);

        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Some SID references fixed"));

        //
        // Remove ExistingUser
        //

        if (!ExistingUserIsOnDomain) {

            //
            // Local user case: delete the user account
            //

            if (Flags & REMAP_PROFILE_KEEPLOCALACCOUNT) {

                DEBUGMSG((DM_VERBOSE, "RemapUserProfile: Keeping local account"));

            } else {

                Status = NetUserDel (NULL, FixedExistingUser);

                if (Status != ERROR_SUCCESS) {
                    Error = Status;
                    DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: NetUserDel failed with code %u for %s", Error, FixedExistingUser));
                    DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Ignoring error because changes cannot be undone!"));
                }

                DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Removed local user %s", FixedExistingUser));
            }

        } else {

            //
            // Non-local user case: remove the user from each local group
            //

            Status = NetUserGetLocalGroups (
                        NULL,
                        FixedExistingUser,
                        0,
                        0,
                        (PBYTE *) &lui0,
                        MAX_PREFERRED_LENGTH,
                        &EntriesRead,
                        &Entries
                        );

            if (Status != ERROR_SUCCESS) {
                Error = Status;

                DEBUGMSG((
                    DM_VERBOSE,
                    "RemapAndMoveUserW: NetUserGetLocalGroups failed with code %u for %s",
                    Error,
                    FixedExistingUser
                    ));

                goto Exit;
            }

            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Got local groups for %s", FixedExistingUser));

            lmi0.lgrmi0_sid = ExistingSid;

            for (Entries = 0 ; Entries < EntriesRead ; Entries++) {

                Status = NetLocalGroupDelMembers (
                            NULL,
                            lui0[Entries].lgrui0_name,
                            0,
                            (PBYTE) &lmi0,
                            1
                            );

                if (Status != ERROR_SUCCESS) {
                    Error = Status;

                    DEBUGMSG((
                        DM_VERBOSE,
                        "RemapAndMoveUserW: NetLocalGroupDelMembers failed with code %u for %s",
                        Error,
                        lui0[Entries].lgrui0_name
                        ));

                    goto Exit;
                }
            }

            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Removed local group membership"));
        }

        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Success"));
        b = TRUE;
    }
    __except (TRUE) {
        Error = ERROR_NOACCESS;
    }

Exit:
    if (hToken) {
        CloseHandle (hToken);
    }

    if (lui0) {
        NetApiBufferFree (lui0);
    }

    SmartLocalFree (ExistingSid);
    SmartLocalFree (NewSid);

    SetLastError (Error);

    return b;
}


typedef struct {
    PCWSTR Path;
    WCHAR ExpandedPath[MAX_PATH];
} IGNOREPATH, *PIGNOREPATH;


BOOL
IsPatternMatchW (
    IN     PCWSTR Pattern,
    IN     PCWSTR Str
    )
{
    WCHAR chSrc, chPat;

    while (*Str) {
        chSrc = (WCHAR) CharLowerW ((PWSTR) *Str);
        chPat = (WCHAR) CharLowerW ((PWSTR) *Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (Pattern[1] == L'*') {
                Pattern++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = (WCHAR) CharLowerW ((PWSTR) Pattern[1]);
            if (!chPat) {
                return TRUE;
            }

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                Pattern++;
                if (IsPatternMatchW (Pattern, Str)) {
                    return TRUE;
                }

                // no, that didn't work, stick with star
                Pattern--;
            }

            //
            // Allow any character and continue
            //

            Str++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat) {
                return FALSE;
            }
        }

        //
        // Advance when pattern character matches string character
        //

        Pattern++;
        Str++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *Pattern;
    if (chPat && (chPat != L'*' || Pattern[1])) {
        return FALSE;
    }

    return TRUE;
}


BOOL
DoesStringHavePrefixW (
    IN      PCWSTR Prefix,
    IN      PCWSTR String
    )
{
    while (*Prefix) {
        if (CharLowerW ((PWSTR) *Prefix) != CharLowerW ((PWSTR) *String)) {
            return FALSE;
        }

        Prefix++;
        String++;
    }

    return TRUE;
}


VOID
pFixDirReference (
    IN      PCWSTR CurrentPath,
    IN      PCWSTR ExistingSidString,
    IN      PCWSTR NewSidString,
    IN      PACL NewAcl,                    OPTIONAL
    IN      PIGNOREPATH IgnoreDirList       OPTIONAL
    )

/*++

Routine Description:

  pFixDirReference is a recursive function that renames a directory if it
  matches an existing SID exactly.  It also updates the SIDs.

Arguments:

  CurrentPath       - Specifies the full file system path.
  ExistingSidString - Specifies the string version of the SID to find.
  NewSidString      - Specifies the SID to rename the directory to when
                      ExistingSidString is found.
  NewAcl            - Specifies the new ACL to use
  IgnoreDirList     - Specifies a list of directories to ignore.  A NULL
                      Path member indicates the end of the list, and the
                      ExpandedPath member must be filled by the caller.

Return Value:

  None.

--*/

{
    WIN32_FIND_DATA fd;
    HANDLE hFind;
    WCHAR SubPath[MAX_PATH];
    WCHAR NewPath[MAX_PATH];
    GROWBUFFER Buf = GROWBUF_INIT;
    UINT NeededLen;
    BOOL Present;
    BOOL Defaulted;
    PACL Acl;
    UINT u;

    if ((lstrlenW (CurrentPath) + lstrlenW (ExistingSidString) + 2) >= MAX_PATH) {
        return;
    }

    if (*CurrentPath == 0) {
        return;
    }

    wsprintf (SubPath, L"%s\\*", CurrentPath);

    hFind = FindFirstFile (SubPath, &fd);
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            //
            // Ignore dot and dot-dot
            //

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (!lstrcmpi (fd.cFileName, L".") || !lstrcmpi (fd.cFileName, L"..")) {
                    continue;
                }
            }

            if (NewAcl) {
                //
                // Obtain security descriptor of the file
                //

                wsprintf (SubPath, L"%s\\%s", CurrentPath, fd.cFileName);

                Buf.End = 0;

                if (!GetFileSecurity (
                        SubPath,
                        DACL_SECURITY_INFORMATION,
                        Buf.Buf,
                        Buf.Size,
                        &NeededLen
                        )) {

                    if (Buf.Size < NeededLen) {
                        GrowBuffer (&Buf, NeededLen);

                        if (GetFileSecurity (
                                SubPath,
                                DACL_SECURITY_INFORMATION,
                                Buf.Buf,
                                Buf.Size,
                                &NeededLen
                                )) {

                            Buf.End = GetSecurityDescriptorLength (
                                        (PSECURITY_DESCRIPTOR) Buf.Buf
                                        );
                        }
                    }
                } else {
                    Buf.End = GetSecurityDescriptorLength (
                                (PSECURITY_DESCRIPTOR) Buf.Buf
                                );
                }

                //
                // If a user-specified ACL is found, replace it.  We do this
                // because doing a search/replace of ACEs is somewhat
                // sophisticated.  Could be implmented here.
                //

                if (Buf.End && IsValidSecurityDescriptor ((PSECURITY_DESCRIPTOR) Buf.Buf)) {

                    if (!GetSecurityDescriptorDacl (
                            (PSECURITY_DESCRIPTOR) Buf.Buf,
                            &Present,
                            &Acl,
                            &Defaulted
                            )) {
                        Defaulted = TRUE;
                    }

                    if (!Defaulted && Present) {
                        //
                        // The user specified an ACL.  Replace it.
                        //

                        DEBUGMSG((DM_VERBOSE, "pFixDirReference: Updating security for %s", SubPath));

                        SetNamedSecurityInfo (
                            SubPath,
                            SE_FILE_OBJECT,
                            DACL_SECURITY_INFORMATION,
                            NULL,
                            NULL,
                            NewAcl,
                            NULL
                            );

                    } else {
                        DEBUGMSG((DM_VERBOSE, "pFixDirReference: Not updating security for %s", SubPath));
                    }
                } else {
                    DEBUGMSG((DM_VERBOSE, "pFixDirReference: Path %s has no security descriptor", SubPath));
                }
            }

            //
            // Rename file/directory or recurse on directory
            //

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                wsprintf (SubPath, L"%s\\%s", CurrentPath, fd.cFileName);

                if (IgnoreDirList) {
                    //
                    // Check if this path is to be ignored
                    //

                    for (u = 0 ; IgnoreDirList[u].Path ; u++) {

                        if (IgnoreDirList[u].ExpandedPath[0]) {
                            if (IsPatternMatchW (IgnoreDirList[u].ExpandedPath, SubPath)) {
                                break;
                            }
                        }
                    }
                } else {
                    u = 0;
                }

                //
                // If this path is not to be ignored, recursively fix it
                //

                if (!IgnoreDirList || !IgnoreDirList[u].Path) {

                    pFixDirReference (
                        SubPath,
                        ExistingSidString,
                        NewSidString,
                        NewAcl,
                        IgnoreDirList
                        );

                } else {
                    //
                    // This path is to be ignored
                    //

                    DEBUGMSG((DM_VERBOSE, "pFixDirReference:  Ignoring path %s", SubPath));
                    continue;
                }
            }

            if (!lstrcmpi (fd.cFileName, ExistingSidString)) {

                //
                // Rename the SID referenced in the file system
                //

                wsprintf (SubPath, L"%s\\%s", CurrentPath, ExistingSidString);
                wsprintf (NewPath, L"%s\\%s", CurrentPath, NewSidString);

                DEBUGMSG((DM_VERBOSE, "pFixDirReference:  Moving %s to %s", SubPath, NewPath));

                MoveFile (SubPath, NewPath);
            }

        } while (FindNextFile (hFind, &fd));

        FindClose (hFind);
    }

    FreeGrowBuffer (&Buf);
}


BOOL
pOurExpandEnvironmentStrings (
    IN      PCWSTR String,
    OUT     PWSTR OutBuffer,
    IN      PCWSTR UserProfile,         OPTIONAL
    IN      HKEY UserHive               OPTIONAL
    )

/*++

Routine Description:

  pOurExpandEnvironmentStrings expands standard environment variables,
  implementing special cases for the variables that have different values
  than what the profmap.dll environment has.  In particular, %APPDATA% and
  %USERPROFILE% are obtained by quering the registry.

  Because this routine is private, certain assumptions are made, such as
  the %APPDATA% or %USERPROFILE% environment variables must appear only
  at the begining of String.

Arguments:

  String      - Specifies the string that might contain one or more
                environment variables.
  OutBuffer   - Receivies the expanded string
  UserProfile - Specifies the root to the user's profile
  UserHive    - Specifies the handle of the root to the user's registry hive

Return Value:

  TRUE if the string was expanded, or FALSE if it is longer than MAX_PATH.
  OutBuffer is always valid upon return. Note that it might be an empty
  string.

--*/

{
    WCHAR TempBuf1[MAX_PATH*2];
    WCHAR TempBuf2[MAX_PATH*2];
    PCWSTR CurrentString;
    DWORD Size;
    HKEY Key;
    LONG rc;

    CurrentString = String;

    //
    // Special case -- replace %APPDATA% with the app data from the user hive
    //

    if (UserHive && DoesStringHavePrefixW (L"%APPDATA%", CurrentString)) {

        rc = RegOpenKeyEx (
                UserHive,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders",
                0,
                KEY_READ,
                &Key
                );

        if (rc == ERROR_SUCCESS) {

            Size = MAX_PATH - lstrlen (CurrentString + 1);

            rc = RegQueryValueEx (
                    Key,
                    L"AppData",
                    NULL,
                    NULL,
                    (PBYTE) TempBuf1,
                    &Size
                    );

            RegCloseKey (Key);
        }

        if (rc != ERROR_SUCCESS) {
            //
            // In case of an error, use a wildcard
            //

            lstrcpy (TempBuf1, UserProfile);
            lstrcat (TempBuf1, L"\\*");

        } else {
            DEBUGMSG ((DM_VERBOSE, "Got AppData path from user hive: %s", TempBuf1));
        }

        lstrcat (TempBuf1, CurrentString + 9);

        CurrentString = TempBuf1;
    }

    //
    // Special case -- replace %USERPROFILE% with ProfileRoot, because
    //                 our environment is for another user
    //

    if (UserProfile && DoesStringHavePrefixW (L"%USERPROFILE%", CurrentString)) {

        lstrcpy (TempBuf2, UserProfile);
        lstrcat (TempBuf2, CurrentString + 13);

        CurrentString = TempBuf2;
    }

    //
    // Now replace other environment variables
    //

    Size = ExpandEnvironmentStrings (CurrentString, OutBuffer, MAX_PATH);

    if (Size && Size < MAX_PATH) {
        return TRUE;
    }

    *OutBuffer = 0;
    return FALSE;
}


VOID
pOurGetProfileRoot (
    IN      PCWSTR SidString,
    OUT     PWSTR ProfileRoot
    )

/*++

Routine Description:

  pOurGetProfileRoot queries the ProfileRoot key to find the root of the
  user's profile.

Arguments:

  SidString   - Specifies the string version of the user's SID. The SID is
                used to find the profile root.
  ProfileRoot - Receives the profile root, or an empty string if the profile
                root can't be obtained. The return value might also be the
                root of all user profiles, if SidString is not match a valid
                user.

Return Value:

  None.

--*/

{
    HKEY Key;
    HKEY SidKey;
    LONG rc;
    WCHAR ProfilesDir[MAX_PATH];
    DWORD Size;

    *ProfileRoot = 0;
    *ProfilesDir = 0;

    rc = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            PROFILE_LIST_PATH,
            0,
            KEY_READ,
            &Key
            );

    if (rc != ERROR_SUCCESS) {
        DEBUGMSG ((DM_WARNING, "pOurGetProfileRoot failed with rc=%u", rc));
        return;
    }

    Size = sizeof(ProfilesDir);

    rc = RegQueryValueEx (
            Key,
            L"ProfilesDirectory",
            NULL,
            NULL,
            (PBYTE) ProfilesDir,
            &Size
            );

    if (rc != ERROR_SUCCESS) {
        DEBUGMSG ((DM_WARNING, "pOurGetProfileRoot: Can't get profile root (rc=%u)", rc));
    }

    rc = RegOpenKeyEx (
            Key,
            SidString,
            0,
            KEY_READ,
            &SidKey
            );

    if (rc == ERROR_SUCCESS) {

        Size = MAX_PATH * sizeof (WCHAR);

        rc = RegQueryValueEx (
                SidKey,
                L"ProfileImagePath",
                NULL,
                NULL,
                (PBYTE) ProfilesDir,
                &Size
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DM_WARNING, "pOurGetProfileRoot: SID key exists, but ProfileImagePath can't be queried (rc=%u)", rc));
        }

        RegCloseKey (SidKey);
    }

    RegCloseKey (Key);

    pOurExpandEnvironmentStrings (ProfilesDir, ProfileRoot, NULL, NULL);
}


VOID
pFixSomeSidReferences (
    PSID ExistingSid,
    PSID NewSid
    )

/*++

Routine Description:

  pFixSomeSidReferences adjusts important parts of the system that use SIDs.
  When a SID changes, this function adjusts the system, so the new SID is
  used and no settings are lost.  This function adjusts the registry and file
  system.  It does not attempt to adjust SID use whereever a SID might be
  used.

  For Win2k, this code deliberately ignores crypto sid directories, because
  the original SID is used as part of the recovery encryption key. In future
  versions, proper migration of these settings is expected.

  This routine also blows away the ProtectedRoots subkey for the crypto APIs.
  The ProtectedRoots key has an ACL, and when we delete the key, the cyrpto
  APIs will rebuild it with the proper ACL.

  WARNING: We know there is a risk in loss of access to data that was encrypted
           using the SID.  Normally the original account will not be removed,
           so the SID will exist on the system, and that (in theory) allows the
           original data to be recovered. But because the cyrpto code gets the
           SID from the file system, there is no way for the user to decrypt
           their data.  The future crypto migration code should fix this issue.

Arguments:

  ExistingSid - Specifies the SID that potentially has settings somewhere on
                the system.
  NewSid      - Specifies the SID that is replacing ExistingSid.

Return Value:

  None.

--*/

{
    PWSTR ExistingSidString;
    PWSTR NewSidString;
    UINT u;
    WCHAR ExpandedRoot[MAX_PATH];
    //PACL NewAcl;
    WCHAR ProfileRoot[MAX_PATH];
    HKEY UserHive;
    WCHAR HivePath[MAX_PATH + 14];
    LONG rc;

    PCWSTR RegRoots[] = {
        L"HKLM\\SOFTWARE\\Microsoft\\Protected Storage System Provider",
        L"HKLM\\SOFTWARE\\Microsoft\\EventSystem",
        L"HKLM\\SOFTWARE\\Microsoft\\Installer\\Managed",
        L"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        NULL
        };

    PCWSTR DirList[] = {
        L"%SYSTEMROOT%\\system32\\appmgmt",
        NULL
        };

    IGNOREPATH IgnoreDirList[] = {
        {L"%APPDATA%\\Microsoft\\Crypto", L""},
        {L"%APPDATA%\\Microsoft\\Protect", L""},
        {NULL, L""}
        };

    //
    // Get the SIDs in text format
    //

    if (!OurConvertSidToStringSid (ExistingSid, &ExistingSidString)) {
        return;
    }

    if (!OurConvertSidToStringSid (NewSid, &NewSidString)) {
        DeleteSidString (ExistingSidString);
        return;
    }

    //
    // Initialize directory strings and load the user hive
    //

    pOurGetProfileRoot (NewSidString, ProfileRoot);
    DEBUGMSG ((DM_VERBOSE, "ProfileRoot (NewSid): %s", ProfileRoot));

    wsprintf (HivePath, L"%s\\ntuser.dat", ProfileRoot);
    DEBUGMSG ((DM_VERBOSE, "User hive: %s", HivePath));

    rc = RegLoadKey (HKEY_LOCAL_MACHINE, REMAP_KEY_NAME, HivePath);

    if (rc == ERROR_SUCCESS) {

        rc = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                REMAP_KEY_NAME,
                0,
                KEY_READ|KEY_WRITE,
                &UserHive
                );

        if (rc != ERROR_SUCCESS) {
            RegUnLoadKey (HKEY_LOCAL_MACHINE, REMAP_KEY_NAME);
            DEBUGMSG ((DM_WARNING, "pFixSomeSidReferences: Can't open user hive root, rc=%u", rc));
            UserHive = NULL;
        }

    } else {
        DEBUGMSG ((DM_WARNING, "RemapAndMoveUserW: Can't load user's hive, rc=%u", rc));
        UserHive = NULL;
    }

    for (u = 0 ; IgnoreDirList[u].Path ; u++) {

        pOurExpandEnvironmentStrings (
            IgnoreDirList[u].Path,
            IgnoreDirList[u].ExpandedPath,
            ProfileRoot,
            UserHive
            );

        DEBUGMSG((DM_VERBOSE, "pFixSomeSidReferences: Ignoring %s", IgnoreDirList[u].ExpandedPath));
    }

    //
    // Search and replace select parts of the registry where SIDs are used
    //

    for (u = 0 ; RegRoots[u] ; u++) {
        RegistrySearchAndReplaceW (
            RegRoots[u],
            ExistingSidString,
            NewSidString
            );
    }

    //
    // Create a new ACL
    //

    //NewAcl = CreateDefaultAcl (NewSid);

    //
    // Test for directories and rename them
    //

    for (u = 0 ; DirList[u] ; u++) {

        if (pOurExpandEnvironmentStrings (DirList[u], ExpandedRoot, ProfileRoot, UserHive)) {

            pFixDirReference (
                ExpandedRoot,
                ExistingSidString,
                NewSidString,
                NULL,
                IgnoreDirList
                );
        }
    }

    //
    // Fix profile directory
    //

    pFixDirReference (
        ProfileRoot,
        ExistingSidString,
        NewSidString,
        NULL /* NewAcl */,
        IgnoreDirList
        );

    //
    // Crypto special case -- blow away ProtectedRoots key (413828)
    //

    DEBUGMSG ((DM_WARNING, "Can't remove protected roots key, code is currently disabled"));

    if (UserHive) {
        if (!RegDelnode (UserHive, L"Software\\Microsoft\\SystemCertificates\\Root\\ProtectedRoots")) {
            DEBUGMSG ((DM_WARNING, "Can't remove protected roots key, GLE=%u", GetLastError()));
        }
    } else {
        DEBUGMSG ((DM_WARNING, "Can't remove protected roots key because user hive could not be opened"));
    }

    //
    // Cleanup
    //

    if (UserHive) {
        RegCloseKey (UserHive);
        RegUnLoadKey (HKEY_LOCAL_MACHINE, REMAP_KEY_NAME);
    }

    //FreeDefaultAcl (NewAcl);

    DeleteSidString (ExistingSidString);
    DeleteSidString (NewSidString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\resource.h ===
// empty
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\moveusr\pch.h ===
#ifdef UNICODE

#ifndef _UNICODE
#define _UNICODE
#endif

#else

#ifndef _MBCS
#define _MBCS
#endif

#endif

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <tchar.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include <userenv.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <profmapp.h>
#ifdef __cplusplus
}
#endif

#include "msg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\moveusr\moveusr.c ===
#include "pch.h"
#include "userenvp.h"       // needed until API becomes public

VOID
pFixSomeSidReferences (
    PSID ExistingSid,
    PSID NewSid
    );

VOID
PrintMessage (
    IN      UINT MsgId,
    IN      PCTSTR *ArgArray
    )
{
    DWORD rc;
    PTSTR MsgBuf;

    rc = FormatMessageW (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_HMODULE,
            (LPVOID) GetModuleHandle(NULL),
            (DWORD) MsgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );

    if (rc) {
        _tprintf (TEXT("%s"), MsgBuf);
        LocalFree (MsgBuf);
    }
}


PTSTR
GetErrorText (
    IN      UINT Error
    )
{
    DWORD rc;
    PTSTR MsgBuf;

    if (Error == ERROR_NONE_MAPPED) {
        Error = ERROR_NO_SUCH_USER;
    } else if (Error & 0xF0000000) {
        Error = RtlNtStatusToDosError (Error);
    }

    rc = FormatMessageW (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_SYSTEM|
                FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            (DWORD) Error,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPVOID) &MsgBuf,
            0,
            NULL
            );

    if (!rc) {
        MsgBuf = NULL;
    }

    return MsgBuf;
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    PrintMessage (MSG_HELP, NULL);

    exit (1);
}


PSID
GetSidFromName (
    IN      PCTSTR RemoteTo,
    IN      PCTSTR Name
    )
{
    DWORD Size;
    PSID Buffer;
    DWORD DomainSize;
    PTSTR Domain;
    SID_NAME_USE Use;
    BOOL b = FALSE;

    Size = 1024;
    Buffer = (PSID) LocalAlloc (LPTR, Size);
    if (!Buffer) {
        return NULL;
    }

    DomainSize = 256;
    Domain = (PTSTR) LocalAlloc (LPTR, DomainSize);
    if (!Domain) {
        LocalFree (Buffer);
        return NULL;
    }

    b = LookupAccountName (
            RemoteTo,
            Name,
            Buffer,
            &Size,
            Domain,
            &DomainSize,
            &Use
            );

    if (Size > 1024) {
        LocalFree (Buffer);
        Buffer = (PSID) LocalAlloc (LPTR, Size);
    }

    if (DomainSize > 256) {
        LocalFree (Domain);
        Domain = (PTSTR) LocalAlloc (LPTR, DomainSize);

        if (!Domain) {
            if (Buffer) {
                LocalFree (Buffer);
            }
            return NULL;
        }
    }

    if (Size > 1024 || DomainSize > 256) {

        b = LookupAccountName (
                RemoteTo,
                Name,
                Buffer,
                &Size,
                Domain,
                &DomainSize,
                &Use
                );
    }

    LocalFree (Domain);

    if (!b) {
        if (Buffer) {
            LocalFree (Buffer);
        }

        return NULL;
    }

    return Buffer;
}


PCTSTR
pSkipUnc (
    PCTSTR Path
    )
{
    if (Path[0] == TEXT('\\') && Path[1] ==  TEXT('\\')) {
        return Path + 2;
    }

    return Path;
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    DWORD Size;
    PCTSTR User1 = NULL;
    PCTSTR User2 = NULL;
    TCHAR FixedUser1[MAX_PATH];
    TCHAR FixedUser2[MAX_PATH];
    TCHAR Computer[MAX_PATH];
    BOOL Overwrite = FALSE;
    INT c;
    BOOL b;
    PCTSTR RemoteTo = NULL;
    NTSTATUS Status;
    BYTE WasEnabled;
    DWORD Error;
    PCTSTR ArgArray[3];
    TCHAR RemoteToBuf[MAX_PATH];
    BOOL NoDecoration = FALSE;
    BOOL ReAdjust = FALSE;
    BOOL KeepLocalUser = FALSE;
    DWORD Flags;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {

            c = _tcsnextc (argv[i] + 1);

            switch (_totlower ((wint_t) c)) {

            case TEXT('y'):
                if (Overwrite) {
                    HelpAndExit();
                }

                Overwrite = TRUE;
                break;

            case TEXT('d'):
                if (NoDecoration) {
                    HelpAndExit();
                }

                NoDecoration = TRUE;
                break;

            case TEXT('k'):
                if (KeepLocalUser) {
                    HelpAndExit();
                }

                KeepLocalUser = TRUE;
                break;

            case TEXT('c'):
                if (RemoteTo) {
                    HelpAndExit();
                }

                if (argv[i][2] == TEXT(':')) {
                    RemoteTo = &argv[i][3];
                } else if ((i + 1) < argc) {
                    i++;
                    RemoteTo = argv[i];
                } else {
                    HelpAndExit();
                }

                if (pSkipUnc (RemoteTo) == RemoteTo) {
                    RemoteToBuf[0] = TEXT('\\');
                    RemoteToBuf[1] = TEXT('\\');
                    lstrcpyn (RemoteToBuf + 2, RemoteTo, MAX_PATH-3);
                    RemoteTo = RemoteToBuf;
                }

                if (!(*RemoteTo)) {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            if (!User1) {

                User1 = argv[i];
                if (!(*User1)) {
                    HelpAndExit();
                }

            } else if (!User2) {

                User2 = argv[i];
                if (!(*User2)) {
                    HelpAndExit();
                }

            } else {
                HelpAndExit();
            }
        }
    }

    if (!User2) {
        HelpAndExit();
    }

    Size = MAX_PATH;
    GetComputerName (Computer, &Size);

    if (NoDecoration || _tcschr (User1, TEXT('\\'))) {
        lstrcpy (FixedUser1, User1);
    } else {
        wsprintf (FixedUser1, TEXT("%s\\%s"), RemoteTo ? pSkipUnc(RemoteTo) : Computer, User1);
    }

    if (NoDecoration || _tcschr (User2, TEXT('\\'))) {
        lstrcpy (FixedUser2, User2);
    } else {
        wsprintf (FixedUser2, TEXT("%s\\%s"), RemoteTo ? pSkipUnc(RemoteTo) : Computer, User2);
    }

    b = TRUE;

    if (b) {
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

        if (Status == ERROR_SUCCESS) {
            ReAdjust = TRUE;
        }
    }

    if (b) {
        ArgArray[0] = FixedUser1;
        ArgArray[1] = FixedUser2;
        ArgArray[2] = RemoteTo;

        if (!RemoteTo) {
            PrintMessage (MSG_MOVING_PROFILE_LOCAL, ArgArray);
        } else {
            PrintMessage (MSG_MOVING_PROFILE_REMOTE, ArgArray);
        }

        Flags = 0;

        if (KeepLocalUser) {
            Flags |= REMAP_PROFILE_KEEPLOCALACCOUNT;
        }

        if (!Overwrite) {
            Flags |= REMAP_PROFILE_NOOVERWRITE;
        }

        b = RemapAndMoveUser (
                RemoteTo,
                Flags,
                FixedUser1,
                FixedUser2
                );

        if (ReAdjust) {
            Error = GetLastError();
            RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
            SetLastError (Error);
        }
    }

    if (b) {
        PrintMessage (MSG_SUCCESS, NULL);
    } else {
        Error = GetLastError();
        ArgArray[0] = (PTSTR) IntToPtr (Error);
        ArgArray[1] = GetErrorText (Error);

        if (Error < 10000) {
            PrintMessage (MSG_DECIMAL_ERROR, ArgArray);
        } else {
            PrintMessage (MSG_HEXADECIMAL_ERROR, ArgArray);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\userenv.c ===
#include "pch.h"

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnodeRecurse (HKEY hKeyRoot, PWSTR lpSubKey)
{
    PWSTR End;
    LONG rc;
    DWORD dwSize;
    WCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    rc = RegDeleteKey(hKeyRoot, lpSubKey);

    if (rc == ERROR_SUCCESS) {
        return TRUE;
    }


    rc = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } else {
            return FALSE;
        }
    }


    End = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    rc = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (rc == ERROR_SUCCESS) {

        do {

            lstrcpy (End, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            rc = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (rc == ERROR_SUCCESS);
    }

    End--;
    *End = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    rc = RegDeleteKey(hKeyRoot, lpSubKey);

    if (rc == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL RegDelnode (HKEY hKeyRoot, PWSTR lpSubKey)
{
    WCHAR szDelKey[2 * MAX_PATH];


    lstrcpy (szDelKey, lpSubKey);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);

}


//*************************************************************
//
//  CreateNestedDirectory()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary.
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//
//*************************************************************

UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[2*MAX_PATH];
    LPTSTR lpEnd;
    PACL Acl;
    BOOL Present;
    BOOL Defaulted;

    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        DEBUGMSG ((DM_WARNING, "CreateNestedDirectory:  Received a NULL pointer."));
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        //
        // Update the security
        //

        if (lpSecurityAttributes) {

            if (!GetSecurityDescriptorDacl (
                    lpSecurityAttributes->lpSecurityDescriptor,
                    &Present,
                    &Acl,
                    &Defaulted
                    )) {

                Present = FALSE;

            }

            if (Present && !Defaulted) {

                if (!SetNamedSecurityInfo (
                        (PTSTR) lpDirectory,
                        SE_FILE_OBJECT,
                        DACL_SECURITY_INFORMATION|PROTECTED_DACL_SECURITY_INFORMATION,
                        NULL,
                        NULL,
                        Acl,
                        NULL
                        )) {

                    return GetLastError();

                }
            }
        }

        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    DEBUGMSG ((DM_WARNING, "CreateNestedDirectory:  CreateDirectory failed with %d.", GetLastError()));
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    DEBUGMSG ((DM_VERBOSE, "CreateNestedDirectory:  Failed to create the directory with error %d.", GetLastError()));

    return 0;

}



//*************************************************************
//
//  CreateSecureDirectory()
//
//  Purpose:    Creates a secure directory that only the user,
//              admin, and system have access to in the normal case
//              and for only the user and system in the restricted case.
//
//
//  Parameters: lpDirectory -   Directory Name
//              pSid        -   Sid (used by CreateUserProfile)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/20/95     ericflo    Created
//              9/30/98     ushaji     added fRestricted flag
//
//*************************************************************

BOOL CreateSecureDirectory (LPTSTR lpDirectory, PSID pSid)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    PACL pAcl = NULL;
    BOOL bRetVal = FALSE;


    //
    // Verbose Output
    //

    DEBUGMSG ((DM_VERBOSE, "CreateSecureDirectory: Entering with <%s>", lpDirectory));

    if (!pSid) {

        //
        // Attempt to create the directory
        //

        if (CreateNestedDirectory(lpDirectory, NULL)) {
            DEBUGMSG ((DM_VERBOSE, "CreateSecureDirectory: Created the directory <%s>", lpDirectory));
            bRetVal = TRUE;

        } else {

            DEBUGMSG ((DM_VERBOSE, "CreateSecureDirectory: Failed to created the directory <%s>", lpDirectory));
        }

        goto Exit;
    }


    //
    // Get the default ACL
    //

    pAcl = CreateDefaultAcl (pSid);



    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DEBUGMSG ((DM_VERBOSE, "CreateSecureDirectory: Failed to initialize security descriptor.  Error = %d", GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DEBUGMSG ((DM_VERBOSE, "CreateSecureDirectory: Failed to set security descriptor dacl.  Error = %d", GetLastError()));
        goto Exit;
    }


    //
    // Add the security descriptor to the sa structure
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Attempt to create the directory
    //

    if (CreateNestedDirectory(lpDirectory, &sa)) {
        DEBUGMSG ((DM_VERBOSE, "CreateSecureDirectory: Created the directory <%s>", lpDirectory));
        bRetVal = TRUE;

    } else {

        DEBUGMSG ((DM_VERBOSE, "CreateSecureDirectory: Failed to created the directory <%s>", lpDirectory));
    }


Exit:

    FreeDefaultAcl (pAcl);

    return bRetVal;

}


PACL
CreateDefaultAcl (
    PSID pSid
    )
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to initialize system sid.  Error = %d", GetLastError()));
         goto Exit;
    }

    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                              0, 0, 0, 0, &psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to initialize admin sid.  Error = %d", GetLastError()));
        goto Exit;
    }

    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (pSid)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to initialize acl.  Error = %d", GetLastError()));
        goto Exit;
    }

    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSid)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, pSid)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);



    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    return pAcl;
}


VOID
FreeDefaultAcl (
    PACL pAcl
    )
{
    if (pAcl) {
        GlobalFree (pAcl);
    }
}


BOOL
OurConvertSidToStringSid (
    IN      PSID Sid,
    OUT     PWSTR *SidString
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS NtStatus;

    //
    // Convert the sid into text format
    //

    NtStatus = RtlConvertSidToUnicodeString (&UnicodeString, Sid, TRUE);

    if (!NT_SUCCESS (NtStatus)) {

        DEBUGMSG ((
            DM_WARNING,
            "CreateUserProfile: RtlConvertSidToUnicodeString failed, status = 0x%x",
            NtStatus
            ));

        return FALSE;
    }

    *SidString = UnicodeString.Buffer;
    return  TRUE;
}


VOID
DeleteSidString (
    PWSTR SidString
    )
{
    UNICODE_STRING String;

    if (!SidString) {
        return;
    }

    RtlInitUnicodeString (&String, SidString);
    RtlFreeUnicodeString (&String);

}


BOOL
GetProfileRoot (
    IN      PSID Sid,
    OUT     PWSTR ProfileDir
    )
{
    WCHAR LocalProfileKey[MAX_PATH];
    HKEY hKey;
    DWORD Size;
    DWORD Type;
    DWORD Attributes;
    PWSTR SidString;
    WCHAR ExpandedRoot[MAX_PATH];

    ProfileDir[0] = 0;

    if (!OurConvertSidToStringSid (Sid, &SidString)) {
        DEBUGMSG ((DM_WARNING, "GetProfileRoot: Can't convert SID to string"));
        return FALSE;
    }

    //
    // Check if this user's profile exists
    //

    lstrcpy (LocalProfileKey, PROFILE_LIST_PATH);
    lstrcat (LocalProfileKey, TEXT("\\"));
    lstrcat (LocalProfileKey, SidString);

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, LocalProfileKey,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        Size = MAX_PATH;
        RegQueryValueEx (hKey, PROFILE_IMAGE_VALUE_NAME, NULL,
                         &Type, (LPBYTE) ProfileDir, &Size);

        RegCloseKey (hKey);
    }

    if (ProfileDir[0]) {

        ExpandEnvironmentStrings (ProfileDir, ExpandedRoot, MAX_PATH);
        Attributes = GetFileAttributes (ExpandedRoot);

        if (Attributes == 0xFFFFFFFF || !(Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
            ProfileDir[0] = 0;
            DEBUGMSG ((DM_VERBOSE, "GetProfileRoot: Profile %s is not vaild", SidString));
        } else {
            lstrcpy (ProfileDir, ExpandedRoot);
        }

    } else {
        DEBUGMSG ((DM_VERBOSE, "GetProfileRoot: SID %s does not have a profile directory", SidString));
    }

    DeleteSidString (SidString);

    return ProfileDir[0] != 0;
}


BOOL
UpdateProfileSecurity (
    PSID Sid
    )
{
    WCHAR ProfileDir[MAX_PATH];
    WCHAR ExpProfileDir[MAX_PATH];
    WCHAR LocalProfileKey[MAX_PATH];
    PWSTR SidString = NULL;
    PWSTR End, Save;
    LONG rc;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey;
    BOOL b = FALSE;
    BOOL UnloadProfile = FALSE;

    __try {
        //
        // Convert the sid into text format
        //

        if (!OurConvertSidToStringSid (Sid, &SidString)) {
            DEBUGMSG ((
                DM_WARNING,
                "UpdateProfileSecurity: Can't convert SID to string"
                ));
            __leave;
        }

        //
        // Check if this user's profile exists already
        //

        lstrcpy(LocalProfileKey, PROFILE_LIST_PATH);
        lstrcat(LocalProfileKey, TEXT("\\"));
        lstrcat(LocalProfileKey, SidString);

        ProfileDir[0] = 0;

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, LocalProfileKey,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(ProfileDir);
            RegQueryValueEx (hKey, PROFILE_IMAGE_VALUE_NAME, NULL,
                             &dwType, (LPBYTE) ProfileDir, &dwSize);

            RegCloseKey (hKey);
        }


        if (!ProfileDir[0]) {
            DEBUGMSG ((DM_WARNING, "UpdateProfileSecurity: No profile for specified user"));
            SetLastError (ERROR_BAD_PROFILE);
            __leave;
        }

        //
        // The user has a profile, so update the security settings
        //

        ExpandEnvironmentStrings (
            ProfileDir,
            ExpProfileDir,
            ARRAYSIZE(ExpProfileDir)
            );

        //
        // Load the hive temporary so the security can be fixed
        //

        End = CheckSlash (ExpProfileDir);
        Save = End - 1;
        lstrcpy (End, L"NTUSER.DAT");

        rc = MyRegLoadKey (HKEY_USERS, SidString, ExpProfileDir);

        *Save = 0;

        if (rc != ERROR_SUCCESS) {

            DEBUGMSG((DM_WARNING, "UpdateProfileSecurity:  Failed to load hive, error = %d.", rc));
            SetLastError (rc);

            __leave;
        }

        UnloadProfile = TRUE;

        if (!SetupNewHive (SidString, Sid)) {
            DEBUGMSG((DM_WARNING, "UpdateProfileSecurity:  SetupNewHive failed, error = %d.", GetLastError()));
            __leave;

        }

        //
        // Fix the file system security
        //

        if (!CreateSecureDirectory (ExpProfileDir, Sid)) {
            DEBUGMSG((DM_WARNING, "UpdateProfileSecurity:  CreateSecureDirectory failed, error = %d.", GetLastError()));
            __leave;
        }

        b = TRUE;

    }
    __finally {
        dwError = GetLastError();

        if (UnloadProfile) {
            MyRegUnLoadKey (HKEY_USERS, SidString);
        }

        DeleteSidString (SidString);

        SetLastError (dwError);
    }

    return b;
}


//*************************************************************
//
//  DeleteProfileRegistrySettings()
//
//  Purpose:    Deletes the specified profile from the
//              registry.
//
//  Parameters: lpSidString     -   Registry subkey
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/23/95     ericflo    Created
//              5/20/99     jimschm    Moved out of DeleteProfile
//
//*************************************************************

BOOL DeleteProfileRegistrySettings (LPTSTR lpSidString)
{
    LONG lResult;
    TCHAR szTemp[MAX_PATH];
    TCHAR szUserGuid[MAX_PATH];
    HKEY hKey;
    DWORD dwType, dwSize;

    if (lpSidString && *lpSidString) {

        lstrcpy(szTemp, PROFILE_LIST_PATH);
        lstrcat(szTemp, TEXT("\\"));
        lstrcat(szTemp, lpSidString);

        //
        // get the user guid
        //

        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp, 0, KEY_READ, &hKey);

        if (lResult == ERROR_SUCCESS) {

            //
            // Query for the user guid
            //

            dwSize = MAX_PATH * sizeof(TCHAR);
            lResult = RegQueryValueEx (hKey, PROFILE_GUID, NULL, &dwType, (LPBYTE) szUserGuid, &dwSize);

            if (lResult != ERROR_SUCCESS) {
                DEBUGMSG((DM_WARNING, "DeleteProfile:  Failed to query profile guid with error %d", lResult));
            }
            else {
                lstrcpy(szTemp, PROFILE_GUID_PATH);
                lstrcat(szTemp, TEXT("\\"));
                lstrcat(szTemp, szUserGuid);

                //
                // Delete the profile guid from the guid list
                //

                lResult = RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

                if (lResult != ERROR_SUCCESS) {
                    DEBUGMSG((DM_WARNING, "DeleteProfile:  failed to delete profile guid.  Error = %d", lResult));
                }
            }

            RegCloseKey(hKey);
        }

        lstrcpy(szTemp, PROFILE_LIST_PATH);
        lstrcat(szTemp, TEXT("\\"));
        lstrcat(szTemp, lpSidString);

        lResult = RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        if (lResult != ERROR_SUCCESS) {
            DEBUGMSG((DM_WARNING, "DeleteProfile:  Unable to delete registry entry.  Error = %d", lResult));
            SetLastError(lResult);
            return FALSE;
        }
    }

    return TRUE;
}


/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        DEBUGMSG((DM_WARNING, "GetUserSid: Failed to allocate %d bytes",
                  BytesRequired));
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            DEBUGMSG((DM_WARNING, "GetUserSid: Failed to allocate %d bytes",
                      BytesRequired));
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        DEBUGMSG((DM_WARNING, "GetUserSid: Failed to query user info from user token, status = 0x%x",
                  status));
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        DEBUGMSG((DM_WARNING, "GetUserSid: Failed to allocate %d bytes",
                  BytesRequired));
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        DEBUGMSG((DM_WARNING, "GetUserSid: RtlCopySid Failed. status = %d",
                  status));
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}


//*************************************************************
//
//  MyRegLoadKey()
//
//  Purpose:    Loads a hive into the registry
//
//  Parameters: hKey        -   Key to load the hive into
//              lpSubKey    -   Subkey name
//              lpFile      -   hive filename
//
//  Return:     ERROR_SUCCESS if successful
//              Error number if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/22/95     ericflo    Created
//
//*************************************************************

LONG MyRegLoadKey(HKEY hKey, LPTSTR lpSubKey, LPTSTR lpFile)
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    int error;
    DWORD dwException;
    WCHAR szException[20];

    __try {

        //
        // Enable the restore privilege
        //

        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, TRUE, &WasEnabled);

        if (NT_SUCCESS(Status)) {

            error = RegLoadKey(hKey, lpSubKey, lpFile);

            //
            // Restore the privilege to its previous state
            //

            Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, TRUE, &WasEnabled);
            if (!NT_SUCCESS(Status)) {
                DEBUGMSG((DM_WARNING, "MyRegLoadKey:  Failed to restore RESTORE privilege to previous enabled state"));
            }


            //
            // Convert a sharing violation error to success since the hive
            // is already loaded
            //

            if (error == ERROR_SHARING_VIOLATION) {
                error = ERROR_SUCCESS;
            }


            //
            // Check if the hive was loaded
            //

            if (error != ERROR_SUCCESS) {
                DEBUGMSG((DM_WARNING, "MyRegLoadKey:  Failed to load subkey <%s>, error =%d", lpSubKey, error));
            }

        } else {
            error = ERROR_ACCESS_DENIED;
            DEBUGMSG((DM_WARNING, "MyRegLoadKey:  Failed to enable restore privilege to load registry key, error %u", error));
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        dwException = GetExceptionCode();
        ASSERT(dwException == 0);
        wsprintf(szException, L"!!!! 0x%x ", dwException);
        OutputDebugString(szException);
        OutputDebugString(L"Exception hit in MyRegLoadKey in userenv\n");
        ASSERT(dwException == 0);

    }

    DEBUGMSG((DM_VERBOSE, "MyRegLoadKey: Returning %d.", error));

    return error;
}


//*************************************************************
//
//  MyRegUnLoadKey()
//
//  Purpose:    Unloads a registry key
//
//  Parameters: hKey          -  Registry handle
//              lpSubKey      -  Subkey to be unloaded
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Ported
//
//*************************************************************

BOOL MyRegUnLoadKey(HKEY hKey, LPTSTR lpSubKey)
{
    BOOL bResult = TRUE;
    LONG error;
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    DWORD dwException;
    WCHAR szException[20];


    __try {

        //
        // Enable the restore privilege
        //

        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, TRUE, &WasEnabled);

        if (NT_SUCCESS(Status)) {

            error = RegUnLoadKey(hKey, lpSubKey);

            if ( error != ERROR_SUCCESS) {
                DEBUGMSG((DM_WARNING, "MyRegUnLoadKey:  Failed to unmount hive %x", error));
                SetLastError(error);
                bResult = FALSE;
            }

            //
            // Restore the privilege to its previous state
            //

            Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, TRUE, &WasEnabled);
            if (!NT_SUCCESS(Status)) {
                DEBUGMSG((DM_WARNING, "MyRegUnLoadKey:  Failed to restore RESTORE privilege to previous enabled state"));
            }

        } else {
            DEBUGMSG((DM_WARNING, "MyRegUnloadKey:  Failed to enable restore privilege to unload registry key"));
            Status = ERROR_ACCESS_DENIED;
            SetLastError(Status);
            bResult = FALSE;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwException = GetExceptionCode();
        ASSERT(dwException == 0);
        wsprintf(szException, L"!!!! 0x%x ", dwException);
        OutputDebugString(szException);
        OutputDebugString(L"Exception hit in MyRegUnLoadKey in userenv\n");
        ASSERT(dwException == 0);
    }

    DEBUGMSG((DM_VERBOSE, "MyRegUnloadKey: Returning %d, error %u.", bResult, GetLastError()));

    return bResult;
}


//*************************************************************
//
//  SetDefaultUserHiveSecurity()
//
//  Purpose:    Initializes a user hive with the
//              appropriate acls
//
//  Parameters: pSid            -   Sid (used by CreateNewUser)
//              RootKey         -   registry handle to hive root
//
//  Return:     ERROR_SUCCESS if successful
//              other error code  if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created as part of
//                                       SetupNewHive
//              3/29/98     adamed     Moved out of SetupNewHive
//                                       to this function
//
//*************************************************************

BOOL SetDefaultUserHiveSecurity(PSID pSid, HKEY RootKey)
{
    DWORD Error;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL, psidRestricted = NULL;
    DWORD cbAcl, AceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;


    //
    // Verbose Output
    //

    DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity:  Entering"));


    //
    // Create the security descriptor that will be applied to each key
    //

    //
    // Give the user access by their real sid so they still have access
    // when they logoff and logon again
    //

    psidUser = pSid;
    bFreeSid = FALSE;

    if (!psidUser) {
        DEBUGMSG((DM_WARNING, "SetDefaultUserHiveSecurity:  Failed to get user sid"));
        return FALSE;
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize system sid.  Error = %d",
                   GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize admin sid.  Error = %d",
                   GetLastError()));
         goto Exit;
    }

    //
    // Get the Restricted sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_RESTRICTED_CODE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidRestricted)) {
         DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize restricted sid.  Error = %d",
                   GetLastError()));
         goto Exit;
    }



    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + (2*GetLengthSid(psidRestricted)) +
            sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize acl.  Error = %d", GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidUser)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for user.  Error = %d", GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for system.  Error = %d", GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for admin.  Error = %d", GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidRestricted)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for Restricted.  Error = %d", GetLastError()));
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for user.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for system.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for admin.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidRestricted)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for restricted.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize security descriptor.  Error = %d", GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to set security descriptor dacl.  Error = %d", GetLastError()));
        goto Exit;
    }

    //
    // Set the security descriptor on the entire tree
    //

    Error = ApplySecurityToRegistryTree(RootKey, &sd);

    if (ERROR_SUCCESS == Error) {
        bRetVal = TRUE;
    }
    else
        SetLastError(Error);

Exit:

    //
    // Free the sids and acl
    //

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}



//*************************************************************
//
//  SetupNewHive()
//
//  Purpose:    Initializes the new user hive created by copying
//              the default hive.
//
//  Parameters: lpSidString     -   Sid string
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL SetupNewHive(LPTSTR lpSidString, PSID pSid)
{
    DWORD Error, IgnoreError;
    HKEY RootKey;
    BOOL bRetVal = FALSE;


    //
    // Verbose Output
    //

    DEBUGMSG((DM_VERBOSE, "SetupNewHive:  Entering"));


    //
    // Open the root of the user's profile
    //

    Error = RegOpenKeyEx(HKEY_USERS,
                         lpSidString,
                         0,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         &RootKey);

    if (Error != ERROR_SUCCESS) {

        DEBUGMSG((DM_WARNING, "SetupNewHive: Failed to open root of user registry, error = %d", Error));

    } else {

        //
        // First Secure the entire hive -- use security that
        // will be sufficient for most of the hive.
        // After this, we can add special settings to special
        // sections of this hive.
        //

        if (SetDefaultUserHiveSecurity(pSid, RootKey)) {

            TCHAR szSubKey[MAX_PATH];
            LPTSTR lpEnd;

            //
            // Change the security on certain keys in the user's registry
            // so that only Admin's and the OS have write access.
            //

            lstrcpy (szSubKey, lpSidString);
            lpEnd = CheckSlash(szSubKey);
            lstrcpy (lpEnd, WINDOWS_POLICIES_KEY);

            if (!SecureUserKey(szSubKey, pSid)) {
                DEBUGMSG((DM_WARNING, "SetupNewHive: Failed to secure windows policies key"));
            }

            lstrcpy (lpEnd, ROOT_POLICIES_KEY);

            if (!SecureUserKey(szSubKey, pSid)) {
                DEBUGMSG((DM_WARNING, "SetupNewHive: Failed to secure root policies key"));
            }


            bRetVal = TRUE;

        } else {
            Error = GetLastError();
            DEBUGMSG((DM_WARNING, "SetupNewHive:  Failed to apply security to user registry tree, error = %d", Error));
        }

        RegFlushKey (RootKey);

        IgnoreError = RegCloseKey(RootKey);
        if (IgnoreError != ERROR_SUCCESS) {
            DEBUGMSG((DM_WARNING, "SetupNewHive:  Failed to close reg key, error = %d", IgnoreError));
        }
    }

    //
    // Verbose Output
    //

    DEBUGMSG((DM_VERBOSE, "SetupNewHive:  Leaving with a return value of %d, error %u", bRetVal, Error));

    if (!bRetVal)
        SetLastError(Error);
    return(bRetVal);

}


//*************************************************************
//
//  ApplySecurityToRegistryTree()
//
//  Purpose:    Applies the passed security descriptor to the passed
//              key and all its descendants.  Only the parts of
//              the descriptor inddicated in the security
//              info value are actually applied to each registry key.
//
//  Parameters: RootKey   -     Registry key
//              pSD       -     Security Descriptor
//
//  Return:     ERROR_SUCCESS if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/19/95     ericflo    Created
//
//*************************************************************

DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD)

{
    DWORD Error = ERROR_SUCCESS;
    DWORD SubKeyIndex;
    LPTSTR SubKeyName;
    HKEY SubKey;
    DWORD cchSubKeySize = MAX_PATH + 1;



    //
    // First apply security
    //

    RegSetKeySecurity(RootKey, DACL_SECURITY_INFORMATION, pSD);


    //
    // Open each sub-key and apply security to its sub-tree
    //

    SubKeyIndex = 0;

    SubKeyName = GlobalAlloc (GPTR, cchSubKeySize * sizeof(TCHAR));

    if (!SubKeyName) {
        DEBUGMSG ((DM_WARNING, "ApplySecurityToRegistryTree:  Failed to allocate memory, error = %d", GetLastError()));
        return GetLastError();
    }

    while (TRUE) {

        //
        // Get the next sub-key name
        //

        Error = RegEnumKey(RootKey, SubKeyIndex, SubKeyName, cchSubKeySize);


        if (Error != ERROR_SUCCESS) {

            if (Error == ERROR_NO_MORE_ITEMS) {

                //
                // Successful end of enumeration
                //

                Error = ERROR_SUCCESS;

            } else {

                DEBUGMSG ((DM_WARNING, "ApplySecurityToRegistryTree:  Registry enumeration failed with error = %d", Error));
            }

            break;
        }


        //
        // Open the sub-key
        //

        Error = RegOpenKeyEx(RootKey,
                             SubKeyName,
                             0,
                             WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                             &SubKey);

        if (Error == ERROR_SUCCESS) {

            //
            // Apply security to the sub-tree
            //

            ApplySecurityToRegistryTree(SubKey, pSD);


            //
            // We're finished with the sub-key
            //

            RegCloseKey(SubKey);
        }


        //
        // Go enumerate the next sub-key
        //

        SubKeyIndex ++;
    }


    GlobalFree (SubKeyName);

    return Error;

}


//*************************************************************
//
//  SecureUserKey()
//
//  Purpose:    Sets security on a key in the user's hive
//              so only admin's can change it.
//
//  Parameters: lpKey           -   Key to secure
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Created
//
//*************************************************************

BOOL SecureUserKey(LPTSTR lpKey, PSID pSid)
{
    DWORD Error;
    HKEY RootKey;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL, psidRestricted = NULL;
    DWORD cbAcl, AceIndex, dwDisp;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;


    //
    // Verbose Output
    //

    DEBUGMSG ((DM_VERBOSE, "SecureUserKey:  Entering"));


    //
    // Create the security descriptor
    //

    //
    // Give the user access by their real sid so they still have access
    // when they logoff and logon again
    //

    psidUser = pSid;
    bFreeSid = FALSE;

    if (!psidUser) {
        DEBUGMSG ((DM_WARNING, "SecureUserKey:  Failed to get user sid"));
        return FALSE;
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize system sid.  Error = %d", GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize admin sid.  Error = %d", GetLastError()));
         goto Exit;
    }


    //
    // Get the restricted sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_RESTRICTED_CODE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidRestricted)) {
         DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize restricted sid.  Error = %d", GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + (2 * GetLengthSid (psidRestricted)) +
            sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize acl.  Error = %d", GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidUser)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for user.  Error = %d", GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for system.  Error = %d", GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for admin.  Error = %d", GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidRestricted)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for restricted.  Error = %d", GetLastError()));
        goto Exit;
    }



    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidUser)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for user.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for system.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for admin.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidRestricted)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for restricted.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize security descriptor.  Error = %d", GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to set security descriptor dacl.  Error = %d", GetLastError()));
        goto Exit;
    }


    //
    // Open the root of the user's profile
    //

    Error = RegCreateKeyEx(HKEY_USERS,
                         lpKey,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         NULL,
                         &RootKey,
                         &dwDisp);

    if (Error != ERROR_SUCCESS) {

        DEBUGMSG ((DM_WARNING, "SecureUserKey: Failed to open root of user registry, error = %d", Error));

    } else {

        //
        // Set the security descriptor on the key
        //

        Error = ApplySecurityToRegistryTree(RootKey, &sd);


        if (Error == ERROR_SUCCESS) {
            bRetVal = TRUE;

        } else {

            DEBUGMSG ((DM_WARNING, "SecureUserKey:  Failed to apply security to registry key, error = %d", Error));
            SetLastError(Error);
        }

        RegCloseKey(RootKey);
    }


Exit:

    //
    // Free the sids and acl
    //

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidRestricted) {
        FreeSid(psidRestricted);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }


    //
    // Verbose Output
    //

    DEBUGMSG ((DM_VERBOSE, "SecureUserKey:  Leaving with a return value of %d", bRetVal));


    return(bRetVal);

}


//*************************************************************
//
//  ProduceWFromA()
//
//  Purpose:    Creates a buffer for a Unicode string and copies
//              the ANSI text into it (converting in the process)
//
//  Parameters: pszA    -   ANSI string
//
//
//  Return:     Unicode pointer if successful
//              NULL if an error occurs
//
//  Comments:   The caller needs to free this pointer.
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

LPWSTR ProduceWFromA(LPCSTR pszA)
{
    LPWSTR pszW;
    int cch;

    if (!pszA)
        return (LPWSTR)pszA;

    cch = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0);

    if (cch == 0)
        cch = 1;

    pszW = LocalAlloc(LPTR, cch * sizeof(WCHAR));

    if (pszW) {
        if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszA, -1, pszW, cch)) {
            LocalFree(pszW);
            pszW = NULL;
        }
    }

    return pszW;
}


//*************************************************************
//
//  IsUserAnAdminMember()
//
//  Purpose:    Determines if the user is a member of the administrators group.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is a admin
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              7/25/95     ericflo    Created
//
//*************************************************************

BOOL IsUserAnAdminMember(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL FoundAdmins = FALSE;
    PSID AdminsDomainSid=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Admins domain sid.
    //


    Status = RtlAllocateAndInitializeSid(
               &authNT,
               2,
               SECURITY_BUILTIN_DOMAIN_RID,
               DOMAIN_ALIAS_RID_ADMINS,
               0, 0, 0, 0, 0, 0,
               &AdminsDomainSid
               );

    if (Status == STATUS_SUCCESS) {

        //
        // Test if user is in the Admins domain
        //

        if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                          NULL, SecurityImpersonation, TokenImpersonation,
                          &hImpToken)) {
            DEBUGMSG((DM_WARNING, "IsUserAnAdminMember: DuplicateTokenEx failed with error %d", GetLastError()));
            FoundAdmins = FALSE;
            hImpToken = NULL;
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, AdminsDomainSid, &FoundAdmins)) {
            DEBUGMSG((DM_WARNING, "IsUserAnAdminmember: CheckTokenMembership failed for AdminsDomainSid with error %d", GetLastError()));
            FoundAdmins = FALSE;
        }
    }

    //
    // Tidy up
    //

Exit:

    if (hImpToken)
        CloseHandle(hImpToken);

    if (AdminsDomainSid)
        RtlFreeSid(AdminsDomainSid);

    return(FoundAdmins);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\dll\reg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reg.c

Abstract:

    Implements utilities to parse a registry key string, and also implements
    wrappers to the registry API.  There are four groups of APIs in this
    source file: enumerator functions, query functions, open and create
    functions, and registry string parsing functions.

    The enumerator functions allow simplified enumeration, where the caller
    typically allocates an enumeration structure on the stack and calls a
    registry enum API such as EnumFirstRegKeyStr.  The caller then accesses
    the enumeration structure directly.  The registry enumeration functions
    maintain a handle to the parent registry key, so remember to abort
    registry key enumeration if your code completes before all keys are
    enumerated.

    The query functions allow simplified querying, where the caller receives
    a MemAlloc'd pointer to the data and does not have to worry about managing
    the numerous parameters needed to do the query.  The query functions
    also allow filtering of values that are not the expected type.  All
    query functions have a version with 2 appended to the function name which
    allow the caller to specify an alternative allocator and deallocator.

    The open and create functions simplify the process of obtaining a key
    handle.  They allow the caller to specify a key string as input and return
    the key handle as output.

    The registry string parsing functions are utilities that can be used when
    processing registry key strings.  The functions extract the registry root
    from a string, convert it into a handle, convert a hive handle into a
    string, and so on.

Author:

    Jim Schmidt (jimschm)  20-Mar-1997

Revisions:

    jimschm     26-May-1999 Moved from win9xupg, gutted as well
    ovidiut     22-Feb-1999 Added GetRegSubkeysCount
    calinn      23-Sep-1998 Fixed REG_SZ filtering
    jimschm     25-Mar-1998 Added CreateEncodedRegistryStringEx
    jimschm     21-Oct-1997 Added EnumFirstKeyInTree/EnumNextKeyInTree
    marcw       16-Jul-1997 Added CreateEncodedRegistryString/FreeEncodedRegistryString
    jimschm     22-Jun-1997 Added GetRegData

--*/

#include "pch.h"

REGSAM g_OpenSam = KEY_ALL_ACCESS;
REGSAM g_CreateSam = KEY_ALL_ACCESS;

//
// Private prototypes
//

BOOL
pPopRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr
    );

//
// Implementation
//


PWSTR
StringCopyABW (
    OUT     PWSTR Buf,
    IN      PCWSTR a,
    IN      PCWSTR b
    )
{
    PWSTR r = Buf;

    while (*a && a < b) {
        *Buf++ = *a++;
    }

    *Buf = 0;

    return r;
}


UINT
SizeOfStringW (
    PCWSTR str
    )
{
    return (lstrlenW(str) + 1) * sizeof(WCHAR);
}

PWSTR
GetEndOfStringW (
    PCWSTR p
    )
{
    while (*p) {
        p++;
    }

    return (PWSTR) p;
}


REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_OpenSam;
    g_OpenSam = Mode;

    return OldMode;
}

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    )
{
    return g_OpenSam;
}

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_CreateSam;
    g_CreateSam = Mode;

    return OldMode;
}

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    )
{
    return g_CreateSam;
}




/*++

Routine Description:

  EnumFirstRegKeyA and EnumFirstRegKeyW begin an enumeration of registry
  subkeys.  They initialize the registy enumeration structure and
  call the registry APIs to enumerate subkeys of the specified key handle.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  Key       - Specifies the handle of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegKeyW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGKEY_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegKeyW (EnumPtr);
}


/*++

Routine Description:

  CreateRegKeyA and CreateRegKeyW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the new key.

  NewKeyName - Specifies the name of the subkey to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = RegCreateKeyExW (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    return SubKey;
}


/*++

Routine Description:

  CreateRegKeyStrA and CreateRegKeyStrW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  NewKeyName - Specifies the full path to the key to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
    )
{
    LONG rc;
    DWORD DontCare;
    WCHAR RegKey[MAX_PATH];
    PCWSTR Start;
    PCWSTR End;
    HKEY Parent, NewKey;
    BOOL CloseParent = FALSE;
    DWORD EndPos;

    //
    // Get the root
    //

    Parent = ConvertRootStringToKeyW (NewKeyName, &EndPos);
    if (!Parent) {
        return NULL;
    }

    Start = &NewKeyName[EndPos];

    if (!(*Start)) {
        return Parent;
    }

    //
    // Create each node until entire key exists
    //

    NewKey = NULL;

    do {
        //
        // Find end of this node
        //

        End = wcschr (Start, '\\');
        if (!End) {
            End = GetEndOfStringW (Start);
        }

        StringCopyABW (RegKey, Start, End);

        //
        // Try to open the key (unless it's the last in the string)
        //

        if (*End) {
            rc = RegOpenKeyExW (
                     Parent,
                     RegKey,
                     0,
                     KEY_READ|KEY_CREATE_SUB_KEY,
                     &NewKey
                     );
            if (rc != ERROR_SUCCESS) {
                NewKey = NULL;
            }
        } else {
            NewKey = NULL;
        }

        //
        // If open failed, create the key
        //

        if (NewKey) {
            rc = ERROR_SUCCESS;
        } else {
            rc = RegCreateKeyExW (
                    Parent,
                    RegKey,
                    0,
                    NULL,
                    0,
                    g_CreateSam,
                    NULL,
                    &NewKey,
                    &DontCare
                    );
        }

        if (CloseParent) {
            CloseRegKey (Parent);
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            return NULL;
        }

        Parent = NewKey;
        CloseParent = TRUE;

        //
        // Go to next node
        //

        Start = End;
        if (*Start) {
            Start++;
        }
    } while (*Start);

    return Parent;
}

/*++

Routine Description:

  OpenRegKeyStrA and OpenRegKeyStrW parse a text string that specifies a
  registry key into the hive and subkey, and then they open the subkey
  and return the handle.

Arguments:

  RegKey    - Specifies the complete path to the registry subkey, including
              the hive.

Return Value:

  A non-NULL registry handle if successful, or NULL if either the subkey
  could not be opened or the string is malformed.

--*/

HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        return RootKey;
    }

    Key = RealOpenRegKeyW (RootKey, &RegKey[End]);
    return Key;
}


/*++

Routine Description:

  EnumFirstRegKeyStrA and EnumFirstRegKeyStrW start an enumeration of
  subkeys within the given key.  In these functions, the key is specified
  via a string instead of an HKEY value.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  RegKey    - Specifies the full path of the registry key to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
RealEnumFirstRegKeyStrW (
    IN      PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
    )
{
    HKEY Key;
    BOOL b;

    Key = RealOpenRegKeyStrW (RegKey);
    if (!Key) {
        return FALSE;
    }

    b = EnumFirstRegKeyW (EnumPtr, Key);
    if (!b) {
        CloseRegKey (Key);
    } else {
        EnumPtr->OpenedByEnum = TRUE;
    }

    return b;
}


/*++

Routine Description:

  AbortRegKeyEnumA and AbortRegKeyEnumW release all resources associated
  with a registry subkey enumeration.  Call this function to stop the
  enumeration before it completes by itself.

Arguments:

  EnumPtr   - Specifies the enumeration to stop.  Receives the updated
              state of enumeration.

Return Value:


  none

--*/

VOID
AbortRegKeyEnumW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    if (EnumPtr->OpenedByEnum && EnumPtr->KeyHandle) {
        CloseRegKey (EnumPtr->KeyHandle);
        EnumPtr->KeyHandle = NULL;
    }
}


/*++

Routine Description:

  EnumNextRegKeyA and EnumNextRegKeyW continue an enumeration started by
  one of the subkey enumeration routines above.  If all items have been
  enumerated, this function cleans up all resources and returns FALSE.

Arguments:

  EnumPtr   - Specifies the enumeration to continue.  Receives the updated
              state of enumeration.  The structure can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more subkeys are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegKeyW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    )
{
    LONG rc;

    rc = RegEnumKeyW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->SubKeyName,
            MAX_PATH
            );

    if (rc != ERROR_SUCCESS) {
        if (EnumPtr->OpenedByEnum) {
            CloseRegKey (EnumPtr->KeyHandle);
            EnumPtr->KeyHandle = NULL;
        }

        if (rc == ERROR_NO_MORE_ITEMS) {
            SetLastError (ERROR_SUCCESS);
        } else {
            SetLastError (rc);
        }

        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}


BOOL
pPushRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR KeyName
    )
{
    PREGKEYINFOW RetVal;
    PWSTR p;

    RetVal = (PREGKEYINFOW) PoolMemGetAlignedMemory (
                                EnumPtr->EnumPool,
                                sizeof (REGKEYINFOW)
                                );

    if (!RetVal) {
        return FALSE;
    }

    //
    // Initialize struct to zero
    //

    ZeroMemory (RetVal, sizeof (REGKEYINFOW));

    //
    // Link parent and child pointers
    //

    RetVal->Parent = EnumPtr->CurrentKey;
    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = RetVal;
    }
    EnumPtr->CurrentKey = RetVal;

    //
    // Prepare full key path by appending the key name to the existing
    // base
    //

    RetVal->BaseKeyBytes = EnumPtr->FullKeyNameBytes;

    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + RetVal->BaseKeyBytes);

    if (EnumPtr->FullKeyNameBytes) {
        lstrcpyW (p, L"\\");
        EnumPtr->FullKeyNameBytes += ByteCountW (p);
        p++;
    }

    lstrcpynW (p, KeyName, MAX_PATH - (EnumPtr->FullKeyNameBytes / sizeof (WCHAR)));
    EnumPtr->FullKeyNameBytes += ByteCountW (KeyName);

    //
    // Save the key name independent of the full registry path.
    // Also open the key.
    //

    lstrcpynW (RetVal->KeyName, KeyName, MAX_PATH);
    RetVal->KeyHandle = OpenRegKeyStrW (EnumPtr->FullKeyName);

    if (!RetVal->KeyHandle) {
        pPopRegKeyInfoW (EnumPtr);
        return FALSE;
    }

    return TRUE;
}



BOOL
pPopRegKeyInfoW (
    IN      PREGTREE_ENUMW EnumPtr
    )
{
    PREGKEYINFOW FreeMe;
    PWSTR p;

    FreeMe = EnumPtr->CurrentKey;

    //
    // Skip if nothing was ever pushed
    //

    if (!FreeMe) {
        return FALSE;
    }

    //
    // Trim the full key string
    //

    EnumPtr->CurrentKey = FreeMe->Parent;
    EnumPtr->FullKeyNameBytes = FreeMe->BaseKeyBytes;
    p = (PWSTR) ((PBYTE) EnumPtr->FullKeyName + FreeMe->BaseKeyBytes);
    *p = 0;

    //
    // Adjust the linkage
    //

    if (EnumPtr->CurrentKey) {
        EnumPtr->CurrentKey->Child = NULL;
    }

    //
    // Clean up resources
    //

    if (FreeMe->KeyHandle) {
        CloseRegKey (FreeMe->KeyHandle);
    }

    AbortRegKeyEnumW (&FreeMe->KeyEnum);
    PoolMemReleaseMemory (EnumPtr->EnumPool, (PVOID) FreeMe);

    //
    // Return FALSE if last item was poped
    //

    return EnumPtr->CurrentKey != NULL;
}


BOOL
RealEnumFirstRegKeyInTreeW (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    )
{
    ZeroMemory (EnumPtr, sizeof (REGTREE_ENUMW));

    //
    // Allocate pool for enum structs
    //

    EnumPtr->EnumPool = PoolMemInitNamedPool ("RegKeyInTreeW");
    if (!EnumPtr->EnumPool) {
        return FALSE;
    }

    PoolMemSetMinimumGrowthSize (EnumPtr->EnumPool, 32768);

    //
    // Push base key on the enum stack
    //

    if (!pPushRegKeyInfoW (EnumPtr, BaseKeyStr)) {
        AbortRegKeyTreeEnumW (EnumPtr);
        return FALSE;
    }

    EnumPtr->EnumBaseBytes = ByteCountW (BaseKeyStr);

    //
    // Set state so EnumNextRegKeyInTree knows what to do
    //

    EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
    return TRUE;
}


BOOL
RealEnumNextRegKeyInTreeW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    if (EnumPtr->State == NO_MORE_ITEMS) {
        return FALSE;
    }

    for (;;) {
        switch (EnumPtr->State) {

        case ENUMERATE_SUBKEY_BEGIN:
            //
            // Start enumeration
            //

            if (EnumFirstRegKeyW (
                    &EnumPtr->CurrentKey->KeyEnum,
                    EnumPtr->CurrentKey->KeyHandle
                    )) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_NEXT:
            //
            // Continue enumerations
            //

            if (EnumNextRegKeyW (&EnumPtr->CurrentKey->KeyEnum)) {
                EnumPtr->State = ENUMERATE_SUBKEY_RETURN;
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_DONE;
            }

            break;

        case ENUMERATE_SUBKEY_DONE:
            //
            // Enumeration of this key is done; pop and continue.
            //

            if (!pPopRegKeyInfoW (EnumPtr)) {
                EnumPtr->State = NO_MORE_ITEMS;
                AbortRegKeyTreeEnumW (EnumPtr);
            } else {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
            }

            break;

        case ENUMERATE_SUBKEY_RETURN:
            //
            // Return enumerated item to caller
            //

            if (!pPushRegKeyInfoW (EnumPtr, EnumPtr->CurrentKey->KeyEnum.SubKeyName)) {
                EnumPtr->State = ENUMERATE_SUBKEY_NEXT;
                break;
            }

            if (!EnumPtr->FirstEnumerated) {
                EnumPtr->FirstEnumerated = TRUE;
                EnumPtr->EnumBaseBytes += sizeof (WCHAR);
            }

            EnumPtr->State = ENUMERATE_SUBKEY_BEGIN;
            return TRUE;

        default:
            return FALSE;
        }
    }
}


VOID
AbortRegKeyTreeEnumW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    )
{
    //
    // Free all resources
    //

    while (pPopRegKeyInfoW (EnumPtr)) {
    }

    PoolMemDestroyPool (EnumPtr->EnumPool);
}



/*++

Routine Description:

  EnumFirstRegValueA and EnumerateFirstRegvalueW enumerate the first registry
  value name in the specified subkey.

Arguments:

  EnumPtr   - Receives the updated state of enumeration.  The structure
              can be accessed directly.

  hKey      - Specifies handle of registry subkey to enumerate.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumFirstRegValueW (
    IN      PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    )
{
    ZeroMemory (EnumPtr, sizeof (REGVALUE_ENUMW));
    EnumPtr->KeyHandle = hKey;

    return EnumNextRegValueW (EnumPtr);
}


/*++

Routine Description:

  EnumNextRegValueA and EnumNextRegValueW continue the enumeration started
  by EnumFirstRegValueA/W.  The enumeration structure is updated to
  reflect the next value name in the subkey being enumerated.

Arguments:

  EnumPtr   - Specifies the registry subkey and enumeration position.
              Receives the updated state of enumeration.  The structure
              can be accessed directly.

Return Value:

  TRUE if successful, or FALSE if an error or if no more values are available.
  Call GetLastError for the failure code.

--*/

BOOL
EnumNextRegValueW (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    )
{
    LONG rc;
    DWORD ValueNameSize;

    ValueNameSize = MAX_PATH;

    rc = RegEnumValueW (
            EnumPtr->KeyHandle,
            EnumPtr->Index,
            EnumPtr->ValueName,
            &ValueNameSize,
            NULL,
            &EnumPtr->Type,
            NULL,
            &EnumPtr->DataSize
            );

    if (rc == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    EnumPtr->Index += 1;
    return TRUE;
}



PVOID
MemAllocWrapper (
    IN      DWORD Size
    )

/*++

Routine Description:

  pemAllocWrapper implements a default allocation routine.  The APIs
  that have a "2" at the end allow the caller to supply an alternative
  allocator or deallocator.  The routines without the "2" use this
  default allocator.

Arguments:

  Size - Specifies the amount of memory (in bytes) to allocate

Return Value:

  A pointer to a block of memory that can hold Size bytes, or NULL
  if allocation fails.

--*/

{
    return MemAlloc (Size);
}


VOID
MemFreeWrapper (
    IN      PVOID Mem
    )

/*++

Routine Description:

  MemFreeWrapper implements a default deallocation routine.
  See MemAllocWrapper above.

Arguments:

  Mem - Specifies the block of memory to free, and was allocated by the
        MemAllocWrapper function.

Return Value:

  none

--*/

{
    MemFree (Mem);
}


/*++

Routine Description:

  GetRegValueData2A and GetRegValueData2W query a registry value and
  return the data as a pointer.  They use the specified Alloc and Free
  routines to allocate and free the memory as needed.

  A GetRegValueData macro is defined, and it uses the default allocators,
  simplifying the function parameters and allowing the caller to free
  the return value via MemFree.

Arguments:

  hKey  - Specifies the registry key that holds the specified value.

  Value - Specifies the value name to query.

  Alloc - Specifies the allocation routine, called to allocate a block of
          memory for the return data.

  Free  - Specifies the deallocation routine, called if an error is encountered
          during processing.

Return Value:

  A pointer to the data retrieved, or NULL if the value does not exist or an
  error occurred.  Call GetLastError to obtian the failure code.

--*/

PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = RegQueryValueExW (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }


    DataBuf = (PBYTE) Alloc (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


/*++

Routine Description:

  GetRegValueDataOfType2A and GetRegValueDataOfType2W are extensions of
  GetRegValueData.  They only return a data pointer when the data stored
  in the registry value is the correct type.

Arguments:

  hKey - Specifies the registry key to query

  Value - Specifies the value name to query

  MustBeType - Specifies the type of data (a REG_* constant).  If the specified
               value has data but is a different type, NULL will be returned.

  Alloc - Specifies the allocation routine, called to allocate the return data.

  Free - Specifies the deallocation routine, called when an error is encountered.

Return Value:

  If successful, returns a pointer to data that matches the specified type.
  If the data is a different type, the value name does not exist, or an
  error occurs during the query, NULL is returned, and the failure code
  can be obtained from GetLastError.

--*/


PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExW (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }
    switch (MustBeType) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            if (Type == REG_SZ) break;
            if (Type == REG_EXPAND_SZ) break;
            return NULL;
        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            if (Type == REG_DWORD) break;
            if (Type == REG_DWORD_BIG_ENDIAN) break;
            return NULL;
        default:
            if (Type == MustBeType) break;
            return NULL;
    }

    DataBuf = (PBYTE) Alloc (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    Free (DataBuf);
    SetLastError (rc);
    return NULL;
}


BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size;

    rc = RegQueryValueExW (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  GetRegKeyData2A and GetRegKeyData2W return default data associated
  with a registry key.  They open the specified subkey, query the value,
  close the subkey and return the data.

Arguments:

  Parent - Specifies the key that contains SubKey.

  SubKey - Specifies the name of the subkey to obtain the default value for.

  Alloc  - Specifies the allocation routine, called to allocate a block of
           memory for the registry data.

  Free   - Specifies the deallocation routine, called to free the block of
           data if an error occurs.

Return Value:

  A pointer to the block of data obtained from the subkey's default value,
  or NULL if the subkey does not exist or an error was encountered.  Call
  GetLastError for a failure code.

--*/

PBYTE
GetRegKeyData2W (
    IN      HKEY Parent,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyW (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2W (SubKeyHandle, L"", Alloc, Free);

    CloseRegKey (SubKeyHandle);

    return Data;
}


/*++

Routine Description:

  GetRegData2A and GetRegData2W open a registry key, query a value,
  close the registry key and return the value.

Arguments:

  KeyString - Specifies the registry key to open

  ValueName - Specifies the value to query

  Alloc - Specifies the allocation routine, used to allocate a block of
          memory to hold the value data

  Free  - Specifies the deallocation routine, used to free the block of
          memory when an error is encountered.

Return Value:

  A pointer to the registry data retrieved, or NULL if the key or value
  does not exist, or if an error occurs. Call GetLastError for a failure code.

--*/

PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Alloc,
    IN      DEALLOCATOR Free
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrW (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2W (Key, ValueName, Alloc, Free);

    CloseRegKey (Key);

    return Data;
}


BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    )
/*++

Routine Description:

  GetRegSubkeysCount retrieves the number of subkeys of a given parent key.

Arguments:

  ParentKey - Specifies a handle to the parent registry key.

  SubKeyCount - Receives the number of subkeys

  MaxSubKeyLen - Receives the length, in chars, of the longest subkey string

Return Value:

  TRUE if the count was retrieved successfully, FALSE otherwise.
  In this case, call GetLastError for a failure code.

--*/

{
    LONG rc;

    rc = RegQueryInfoKey (
                ParentKey,
                NULL,
                NULL,
                NULL,
                SubKeyCount,
                MaxSubKeyLen,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  OpenRegKeyA and OpenRegKeyW open a subkey.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the subkey.

  KeyToOpen - Specifies the name of the subkey to open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
    )
{
    LONG rc;
    HKEY SubKey;

    rc = RegOpenKeyExW (
             ParentKey,
             KeyToOpen,
             0,
             g_OpenSam,
             &SubKey
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return NULL;
    }

    return SubKey;
}


LONG
RealCloseRegKey (
    IN      HKEY Key
    )

/*++

Routine Description:

  RealCloseRegKey closes the reg handle supplied, unless the handle is
  a pre-defined Win32 handle.  The CloseRegKey macro resolves directly
  to this function in the free build, and to OurCloseRegKey in the
  checked build.

Arguments:

  Key       - Specifies the reg handle to close

Return Value:

  A standard Win32 error code indicating outcome.

--*/

{
    LONG rc = ERROR_INVALID_HANDLE;

    if (!Key) {
        return ERROR_SUCCESS;
    }

    if (GetOffsetOfRootKey (Key)) {
        return ERROR_SUCCESS;
    }

    __try {
        rc = RegCloseKey (Key);
    }
    __except (TRUE) {
    }

    return rc;
}


/*++

Routine Description:

  GetOffsetOfRootString returns a non-zero offset to the g_RegRoots table
  below.  The offset can be used with GetRootStringFromOffset and
  GetRootKeyFromOffset.

Arguments:

  RootString    - A pointer to a string containing the path to a registry key
  LengthPtr     - A pointer to a variable that receives the length of the
                  registry root, including the joining backslash if it exists.

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if RootString does not
  contain a registry root.

--*/

typedef struct {
    PCSTR   RootText;
    PCWSTR  WideRootText;
    INT     TextLength;
    HKEY    RootKey;
} REGISTRYROOT, *PREGISTRYROOT;

static
REGISTRYROOT g_RegRoots[] = {
    "HKLM",                    L"HKLM",                    4, HKEY_LOCAL_MACHINE,
    "HKEY_LOCAL_MACHINE",      L"HKEY_LOCAL_MACHINE",     18, HKEY_LOCAL_MACHINE,
    "HKU",                     L"HKU",                     3, HKEY_USERS,
    "HKEY_USERS",              L"HKEY_USERS",             10, HKEY_USERS,
    "HKCU",                    L"HKCU",                    4, HKEY_CURRENT_USER,
    "HKEY_CURRENT_USER",       L"HKEY_CURRENT_USER",      17, HKEY_CURRENT_USER,
    "HKCC",                    L"HKCC",                    4, HKEY_CURRENT_CONFIG,
    "HKEY_CURRENT_CONFIG",     L"HKEY_CURRENT_CONFIG",    19, HKEY_CURRENT_CONFIG,
    "HKCR",                    L"HKCR",                    4, HKEY_CLASSES_ROOT,
    "HKEY_CLASSES_ROOT",       L"HKEY_CLASSES_ROOT",      17, HKEY_CLASSES_ROOT,
    "HKDD",                    L"HKDD",                    4, HKEY_DYN_DATA,
    "HKEY_DYN_DATA",           L"HKEY_DYN_DATA",          13, HKEY_DYN_DATA,
    NULL,                      NULL,                       0, NULL
};

#define REGROOTS    14

INT
GetOffsetOfRootStringW (
    IN      PCWSTR RootString,
    OUT     PDWORD LengthPtr       OPTIONAL
    )
{
    int i;
    WCHAR c;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (!_wcsnicmp (RootString, g_RegRoots[i].WideRootText,
                        g_RegRoots[i].TextLength)
            ) {
            c = RootString[g_RegRoots[i].TextLength];
            if (c && c != L'\\') {
                continue;
            }

            if (LengthPtr) {
                *LengthPtr = g_RegRoots[i].TextLength;
                if (c) {
                    *LengthPtr += 1;
                }
            }

            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetOffsetOfRootKey returns a non-zero offset to the g_RegRoots table
  corresponding to the root that matches the supplied HKEY.  This offset
  can be used with GetRootStringFromOffset and GetRootKeyFromOffset.

Arguments:

  RootKey   - Supplies the handle to locate in g_RegRoots table

Return Value:

  A non-zero offset to the g_RegRoots table, or zero if the handle is not
  a registry root.

--*/

INT
GetOffsetOfRootKey (
    IN      HKEY RootKey
    )
{
    INT i;

    for (i = 0 ; g_RegRoots[i].RootText ; i++) {
        if (g_RegRoots[i].RootKey == RootKey) {
            return i + 1;
        }
    }

    return 0;
}


/*++

Routine Description:

  GetRootStringFromOffset and GetRootKeyFromOffset return a pointer to a
  static string or HKEY, respectively.  If the offset supplied is invalid,
  these functions return NULL.

Arguments:

  i - The offset as returned by GetOffsetOfRootString or GetOffsetOfRootKey

Return Value:

  A pointer to a static string/HKEY, or NULL if offset is invalid

--*/

PCSTR
GetRootStringFromOffsetA (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].RootText;
}

PCWSTR
GetRootStringFromOffsetW (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].WideRootText;
}

HKEY
GetRootKeyFromOffset (
    IN      INT i
    )
{
    if (i < 1 || i > REGROOTS) {
        return NULL;
    }

    return g_RegRoots[i - 1].RootKey;
}


/*++

Routine Description:

  ConvertRootStringToKey converts a registry key path's root to an HKEY.

Arguments:

  RegPath   - A pointer to a registry string that has a root at the begining
  LengthPtr - An optional pointer to a variable that receives the length of
              the root, including the joining backslash if it exists.

Return Value:

  A handle to the registry key, or NULL if RegPath does not have a root

--*/

HKEY
ConvertRootStringToKeyW (
    PCWSTR RegPath,
    PDWORD LengthPtr           OPTIONAL
    )
{
    return GetRootKeyFromOffset (GetOffsetOfRootStringW (RegPath, LengthPtr));
}


/*++

Routine Description:

  ConvertKeyToRootString converts a root HKEY to a registry root string

Arguments:

  RegRoot   - A handle to a registry root

Return Value:

  A pointer to a static string, or NULL if RegRoot is not a valid registry
  root handle

--*/

PCWSTR
ConvertKeyToRootStringW (
    HKEY RegRoot
    )
{
    return GetRootStringFromOffsetW (GetOffsetOfRootKey (RegRoot));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\profmap\rpc\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPSTR  [string] LPSTR
#define LPTSTR [string] LPTSTR
#define LPWSTR [string] wchar_t *
#define enum   [v1_enum] enum
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\proquota\debug.c ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include "debug.h"

#if DBG

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szProQuota[] = TEXT("PROQUOTA(%x): ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon")
#define DEBUG_KEY_NAME      TEXT("ProQuotaDebugLevel")

TCHAR szLogFileName[] = L"%SystemRoot%\\Debug\\UserMode\\proquota.log";       // Current log


//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

    dwDebugLevel = DL_NORMAL;


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[30];
    TCHAR szDebugBuffer[2*MAX_PATH+40];
    va_list marker;
    DWORD dwErrCode;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {
        wsprintf (szDebugTitle, c_szProQuota, GetCurrentProcessId());
        OutputDebugString(szDebugTitle);

        va_start(marker, pszMsg);
        wvsprintf(szDebugBuffer, pszMsg, marker);
        OutputDebugString(szDebugBuffer);
        OutputDebugString(c_szCRLF);
        va_end(marker);

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;
            TCHAR szExpLogFileName[MAX_PATH+1];

            DWORD dwRet = ExpandEnvironmentStrings ( szLogFileName, szExpLogFileName, MAX_PATH+1);

            if ( dwRet != 0 && dwRet <= MAX_PATH) {

                hFile = CreateFile(szExpLogFileName,
                                   FILE_WRITE_DATA | FILE_APPEND_DATA,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if (hFile != INVALID_HANDLE_VALUE) {

                    if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                        WriteFile (hFile, (LPCVOID) szDebugTitle,
                                   lstrlen (szDebugTitle) * sizeof(TCHAR),
                                   &dwBytesWritten,
                                   NULL);

                        WriteFile (hFile, (LPCVOID) szDebugBuffer,
                                   lstrlen (szDebugBuffer) * sizeof(TCHAR),
                                   &dwBytesWritten,
                                   NULL);

                        WriteFile (hFile, (LPCVOID) c_szCRLF,
                                   lstrlen (c_szCRLF) * sizeof(TCHAR),
                                   &dwBytesWritten,
                                   NULL);
                    }

                    CloseHandle (hFile);
                }
            }
        }

    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\proquota\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#if DBG

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);

#else

#define DebugMsg(x)


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\proquota\proquota.h ===
#define WM_QUOTADLG             (WM_USER + 100)
#define WM_REFRESH              (WM_USER + 101)
#define WM_EXITWINDOWS          (WM_USER + 102)
#define WM_WARNUSER             (WM_USER + 103)

#define IDI_ICON                 1
#define IDI_CAUTION              2
#define IDI_STOP                 3

#define IDS_SIZEOK               1
#define IDS_SIZEWARN             2
#define IDS_SIZEBAD              3
#define IDS_COLUMN1              4
#define IDS_COLUMN2              5
#define IDS_SIZEFMT              6
#define IDS_LOGOFFOK             7
#define IDS_CAUTION              8
#define IDS_DEFAULTMSG           9
#define IDS_EXCEEDMSG           10
#define IDS_MSGTITLE            11
#define IDS_QUOTAENUMMSG        12

#define IDD_QUOTA              100
#define IDC_QUOTA_TEXT         101
#define IDC_QUOTA_FILELIST     102
#define IDC_QUOTA_HIDESMALL    103
#define IDC_QUOTA_SIZE         104
#define IDC_QUOTA_MAXSIZE      105
#define IDC_QUOTA_ICON         106

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

//
// shell32.dll
//

void WINAPI ExitWindowsDialog(HWND hwndParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\proquota\proquota.c ===
//*************************************************************
//  File name: PROQUOTA.C
//
//  Description:  Profile quota management
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <wchar.h>
#include <aclapi.h>
#include <shellapi.h>
#include <commctrl.h>
#include "proquota.h"
#include "debug.h"

#define WINLOGON_KEY                 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")

HINSTANCE hInst;
HWND      hwndMain;
HWND      g_hQuotaDlg = NULL;
BOOL      g_bHideSmallItems;
BOOL      g_bShowReg = FALSE;
HANDLE    hThread;
HANDLE    hExitEvent;
HANDLE    g_hQuotaDlgEvent;
DWORD     g_dwProfileSize = 0;
DWORD     g_dwProfileSizeTemp = 0;
DWORD     g_dwMaxProfileSize = 10240;  //KB
CRITICAL_SECTION g_cs;
HICON     hIconGood, hIconCaution, hIconStop;
BOOL      g_bQueryEndSession;
TCHAR     g_szExcludeList[2*MAX_PATH];
TCHAR    *g_lpQuotaMessage=NULL;

TCHAR     szClassName[] = TEXT("proquota");
TCHAR     szEventName[] = TEXT("proquota instance event");
TCHAR     szSizeFormat[40];

BOOL      g_bWarnUser = FALSE;
DWORD     g_dwWarnUserTimeout = 15;  // minutes
BOOL      g_bWarningTimerRunning = FALSE;
BOOL      g_bWarningDisplayed = FALSE;


//
// Function prototypes
//

LRESULT CALLBACK ProQuotaWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK QuotaDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL SetSecurity (void);
BOOL ReadRegistry (void);
BOOL ReadExclusionList();
VOID QuotaThread(HWND hWnd);
BOOL RecurseDirectory (LPTSTR lpDir, LPTSTR lpTop, HWND hLV, LPTSTR lpExcludeList);
BOOL EnumerateProfile (HWND hLV);
LPTSTR CheckSemicolon (LPTSTR lpDir);
LPTSTR CheckSlash (LPTSTR lpDir);
LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList);

//*************************************************************
//
//  WinMain()
//
//  Purpose:    Entry point
//
//  Parameters: hInstance     -  Instance handle
//              hPrevInstance -  Previous Instance
//              lpCmdLine     -  Command line
//              nCmdShow      -  ShowWindow flag
//
//  Return:     int
//
//*************************************************************

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{
    MSG msg;
    WNDCLASS  wc;
    HANDLE hEvent;


    //
    // Verbose output
    //

#if DBG
    InitDebugSupport();
    DebugMsg((DM_VERBOSE, TEXT("WinMain:  Entering...")));
#endif

    hInst = hInstance;


    //
    // Check if this app is already running
    //

    hEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, szEventName);

    if (hEvent) {
        DebugMsg((DM_VERBOSE, TEXT("WinMain:  Proquota already running.  Exiting...")));
        CloseHandle (hEvent);
        return 0;
    }

    hEvent = CreateEvent (NULL, TRUE, TRUE, szEventName);


    g_hQuotaDlgEvent = CreateEvent (NULL, FALSE, TRUE, NULL);

    if (!g_hQuotaDlgEvent) {
        DebugMsg((DM_VERBOSE, TEXT("WinMain:  Proquota Couldn't get prowquota dlg event, error %d..."), GetLastError()));
        CloseHandle (hEvent);
        return 0;
    }

    //
    // Get the quota settings
    //

    if (!ReadRegistry()) {
        DebugMsg((DM_VERBOSE, TEXT("WinMain:  ReadRegistry returned FALSE.  Exiting...")));
        CloseHandle (hEvent);
        return 0;
    }

    //
    // Munge the access mask on the process token so taskmgr
    // can't kill this app.
    //

    SetSecurity();

    //
    // Make sure proquota is the first one that is attempted to be shutdown
    //

    SetProcessShutdownParameters(0x3ff, 0);

    //
    // Initialize
    //

    InitializeCriticalSection (&g_cs);
    InitCommonControls();

    LoadString (hInst, IDS_SIZEFMT, szSizeFormat, 40);

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = (WNDPROC)ProQuotaWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szClassName;

    if (!RegisterClass(&wc)) {
        DebugMsg((DM_WARNING, TEXT("WinMain:  RegisterClass failed with %d"), GetLastError()));
        CloseHandle (hEvent);
        return 0;
    }


    //
    // Create a hidden top level window so we get
    // broadcasted messages.
    //

    hwndMain = CreateWindow(szClassName, NULL, WS_OVERLAPPED, 0, 0, 0, 0,
                            NULL, NULL, hInstance, NULL);

    if (!hwndMain) {
        DebugMsg((DM_WARNING, TEXT("WinMain:  CreateWindow failed with %d"), GetLastError()));
        CloseHandle (hEvent);
        return 0;
    }


    while (GetMessage (&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    DebugMsg((DM_VERBOSE, TEXT("WinMain:  Leaving...")));
    CloseHandle (hEvent);

    if (g_lpQuotaMessage) {
        LocalFree(g_lpQuotaMessage);
        g_lpQuotaMessage = NULL;
    }
    return (int)(msg.wParam);
}

//*************************************************************
//
//  ProQuotaWndProc()
//
//  Purpose:    Window procedure
//
//  Parameters: hWnd    -   Window handle
//              message -   Window message
//              wParam  -   WPARAM
//              lParam  -   LPARAM
//
//
//  Return:     LRESULT
//
//*************************************************************

LRESULT CALLBACK ProQuotaWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD  dwThreadId;

    switch (message) {
       case WM_CREATE:

          hIconGood = LoadIcon (hInst, MAKEINTRESOURCE(IDI_ICON));
          hIconCaution = LoadIcon (hInst, MAKEINTRESOURCE(IDI_CAUTION));
          hIconStop = LoadIcon (hInst, MAKEINTRESOURCE(IDI_STOP));

          hExitEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("PROQUOTA Exit Event"));

          if (!hExitEvent) {
            DebugMsg((DM_WARNING, TEXT("ProQuotaWndProc:  Failed to create exit event with error %d"), GetLastError()));
            return -1;
          }

          hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) QuotaThread,
                                  (LPVOID) hWnd, CREATE_SUSPENDED, &dwThreadId);

          if (!hThread) {
              DebugMsg((DM_WARNING, TEXT("ProQuotaWndProc:  Failed to create thread with error %d"), GetLastError()));
              CloseHandle (hExitEvent);
              return -1;
          }

          SetThreadPriority (hThread, THREAD_PRIORITY_IDLE);
          ResumeThread (hThread);
          break;

       case WM_USER:

          if (lParam == WM_LBUTTONDBLCLK) {
              PostMessage (hWnd, WM_QUOTADLG, 0, 0);
          }

#if DBG
          if (lParam == WM_RBUTTONUP) {
              DestroyWindow (hWnd);
          }
#endif
          break;

       case WM_QUERYENDSESSION:
          {
              BOOL bLogoff;

              //EnterCriticalSection (&g_cs);
              bLogoff = (g_dwProfileSize <= g_dwMaxProfileSize);
              //LeaveCriticalSection (&g_cs);

              //
              // If it is zero assume that it has not yet finished enumerating..
              //
          
              if (g_dwProfileSize == 0) {
                  bLogoff = FALSE;
                  DebugMsg((DM_VERBOSE, TEXT("ProQuotaWndProc: Recd QueryEnd Message before enumerating.")));
              }
            
              DebugMsg((DM_VERBOSE, TEXT("ProQuotaWndProc: Recd QueryEnd Message. Returning %s"), bLogoff?TEXT("TRUE"):TEXT("FALSE")));

              if (bLogoff) {
                  return TRUE;
              }

              PostMessage (hWnd, WM_QUOTADLG, 1, 0);
          }
          return FALSE;


       case WM_QUOTADLG:
          if (!g_hQuotaDlg) {

              if (wParam) {
                  g_bQueryEndSession = TRUE;
              } else {
                  g_bQueryEndSession = FALSE;
              }

              DialogBox (hInst, MAKEINTRESOURCE(IDD_QUOTA), hwndMain, QuotaDlgProc);
              g_hQuotaDlg = NULL;
          }
          break;

       case WM_WARNUSER:
          if (!g_bWarningDisplayed) {
              TCHAR szTitle[100];

              g_bWarningDisplayed = TRUE;

              LoadString (hInst, IDS_MSGTITLE, szTitle, 100);
              MessageBox(hWnd, g_lpQuotaMessage, szTitle, MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL);

              g_bWarningDisplayed = FALSE;
          }
          break;

       case WM_TIMER:
          if (g_dwWarnUserTimeout > 0) {
             PostMessage (hWnd, WM_WARNUSER, 0, 0);
          }
          break;

       case WM_EXITWINDOWS:
          ExitWindowsDialog(NULL);
          break;

       case WM_DESTROY:
          {
          NOTIFYICONDATA nid;

          nid.cbSize = sizeof(nid);
          nid.hWnd   = hWnd;
          nid.uID    = 1;

          Shell_NotifyIcon (NIM_DELETE, &nid);

          SetEvent (hExitEvent);

          WaitForSingleObject (hThread, INFINITE);

          CloseHandle (hExitEvent);
          CloseHandle (hThread);
          PostQuitMessage(0);
          }
          break;

       default:
          return (DefWindowProc(hWnd, message, wParam, lParam));
       }

    return FALSE;
}



//*************************************************************
//
//  QuotaThread()
//
//  Purpose:    Initializes the tray icon
//
//  Parameters: hWnd    -    main window handle
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

VOID QuotaThread (HWND hWnd)
{
    NOTIFYICONDATA nid;
    TCHAR  szProfile[MAX_PATH];
    TCHAR  szMessage[64];
    HANDLE hFileChange;
    HANDLE hRegChange;
    HANDLE hWaitHandles[4];
    BOOL   bFirst = TRUE;
    HICON  hOk, hWarning, hBad;
    DWORD  dwDelta;
    HKEY   hKeySystem;
    LONG   lResult;
    DWORD  dwResult;


    DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  Entering...")));

    //
    // Load the status icons
    //

    hOk = LoadImage (hInst, MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON,
                     16, 16, LR_DEFAULTCOLOR);

    hWarning =  LoadImage (hInst, MAKEINTRESOURCE(IDI_CAUTION), IMAGE_ICON,
                           16, 16, LR_DEFAULTCOLOR);

    hBad = LoadImage (hInst, MAKEINTRESOURCE(IDI_STOP), IMAGE_ICON,
                       16, 16, LR_DEFAULTCOLOR);


    //
    // Get the profile directory
    //

    szProfile[0] = TEXT('\0');
    GetEnvironmentVariable (TEXT("USERPROFILE"), szProfile, MAX_PATH);

    if (szProfile[0] == TEXT('\0')) {
        ExitThread (0);
    }
    DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  User's profile:  <%s>"), szProfile));


    //
    // Setup change notify
    //

    hFileChange = FindFirstChangeNotification (szProfile, TRUE,
                                     FILE_NOTIFY_CHANGE_FILE_NAME |
                                     FILE_NOTIFY_CHANGE_DIR_NAME  |
                                     FILE_NOTIFY_CHANGE_SIZE);

    if (hFileChange == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to setup file change notification.  %d"),
                 GetLastError()));
        ExitThread (0);
    }


    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                            0, KEY_READ, &hKeySystem);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to open registry key.  %d"), lResult));
        ExitThread (0);
    }


    hRegChange = CreateEvent (NULL, FALSE, FALSE, TEXT("PROQUOTA reg change event"));

    if (!hRegChange) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to setup reg event for change notification.  %d"),
                 GetLastError()));
        RegCloseKey (hKeySystem);
        FindCloseChangeNotification (hFileChange);
        ExitThread (0);
    }

    lResult = RegNotifyChangeKeyValue(hKeySystem, FALSE, REG_NOTIFY_CHANGE_LAST_SET,
                                      hRegChange, TRUE);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to setup RegNotifyChangeKeyValue.  %d"),
                 lResult));
        CloseHandle (hRegChange);
        RegCloseKey (hKeySystem);
        FindCloseChangeNotification (hFileChange);
        ExitThread (0);
    }


    hWaitHandles[0] = hExitEvent;
    hWaitHandles[1] = hFileChange;
    hWaitHandles[2] = hRegChange;
    hWaitHandles[3] = g_hQuotaDlgEvent;

    while (TRUE) {

        //
        // Calculate the profile size
        //

        if (g_hQuotaDlg) {
            DebugMsg((DM_VERBOSE, TEXT("QuotaTHread: Enumerating profile and refreshing dialog")));
            if (!EnumerateProfile (GetDlgItem (g_hQuotaDlg, IDC_QUOTA_FILELIST))) {
                DebugMsg((DM_WARNING, TEXT("QuotaThread:  EnumerateProfile failed with Dlg Item.")));
                break;
            }
        }
        else {
            if (!EnumerateProfile (NULL)) {
                DebugMsg((DM_WARNING, TEXT("QuotaThread:  EnumerateProfile failed.")));
                break;
            }
        }

        
        //
        // Update the status icon
        //

        nid.cbSize = sizeof(nid);
        nid.hWnd   = hWnd;
        nid.uID    = 1;
        nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
        nid.uCallbackMessage = WM_USER;
        szMessage[0] = TEXT('\0');

        if (g_dwProfileSize > g_dwMaxProfileSize) {
            DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  User has exceeded their profile quota.")));
            nid.hIcon = hBad;
            LoadString (hInst, IDS_SIZEBAD, szMessage, 64);
            dwDelta = g_dwProfileSize - g_dwMaxProfileSize;

            if (g_bWarnUser && !g_bWarningTimerRunning) {
                g_bWarningTimerRunning = TRUE;
                SetTimer (hwndMain, 1, g_dwWarnUserTimeout * 60000, NULL);
                PostMessage (hwndMain, WM_WARNUSER, 0, 0);
            }

        } else if ( (g_dwMaxProfileSize - g_dwProfileSize) < (g_dwProfileSize * .10)) {
            DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  User is within 10% of their profile quota.")));
            nid.hIcon = hWarning;
            LoadString (hInst, IDS_SIZEWARN, szMessage, 64);
            dwDelta = g_dwMaxProfileSize - g_dwProfileSize;

            if (g_bWarnUser && g_bWarningTimerRunning) {
                KillTimer (hwndMain, 1);
                g_bWarningTimerRunning = FALSE;
            }

        } else {
            DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  User has space available in their profile quota.")));
            nid.hIcon = hOk;
            LoadString (hInst, IDS_SIZEOK, szMessage, 64);
            dwDelta = g_dwMaxProfileSize - g_dwProfileSize;

            if (g_bWarnUser && g_bWarningTimerRunning) {
                KillTimer (hwndMain, 1);
                g_bWarningTimerRunning = FALSE;
            }
        }

        _snwprintf (nid.szTip, ARRAYSIZE(nid.szTip), szMessage, dwDelta);


        if (bFirst) {
            if (Shell_NotifyIcon (NIM_ADD, &nid))  {
                bFirst = FALSE;
            }
        } else {
            Shell_NotifyIcon (NIM_MODIFY, &nid);
        }


        //
        // Notify the dialog if it's present
        //

        if (g_hQuotaDlg) {
            PostMessage (g_hQuotaDlg, WM_REFRESH, 0, 0);
        }


        //
        // Clean up and wait for the next change
        //

        FindNextChangeNotification (hFileChange);


        dwResult = WaitForMultipleObjects (4, hWaitHandles, FALSE, INFINITE);


        if (dwResult == WAIT_FAILED) {
            break;
        }

        switch (dwResult - WAIT_OBJECT_0) {

            case 0:
                goto Exit;
                break;

            case 2:

                EnterCriticalSection (&g_cs);

                if (!ReadRegistry()) {
                    PostMessage (hwndMain, WM_DESTROY, 0, 0);
                    goto Exit;
                }
                
                LeaveCriticalSection (&g_cs);

                RegNotifyChangeKeyValue(hKeySystem, FALSE,
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                        hRegChange, TRUE);
                // fall through

            case 1:
                Sleep (2000);
                DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  Running background enumeration.")));
                break;

            case 3:
                break;
        }

    }


Exit:

    RegCloseKey (hKeySystem);
    CloseHandle (hRegChange);
    FindCloseChangeNotification (hFileChange);
    DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  Leaving...")));
    ExitThread (0);

}

//*************************************************************
//
//  SetSecurity()
//
//  Purpose:    Removes TERMINATE_PROCESS access to this process
//              so taskman can't blow us away.
//
//  Parameters:
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SetSecurity (void)
{
    HANDLE hProcess;
    PACL  pDACL;
    PSECURITY_DESCRIPTOR pSD;
    WORD wIndex;
    ACE_HEADER * lpAceHeader;
    ACCESS_ALLOWED_ACE * lpAce;
    DWORD dwResult;

    hProcess = GetCurrentProcess();

    if (GetSecurityInfo (hProcess, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,
                         NULL, NULL, &pDACL, NULL, &pSD) != ERROR_SUCCESS) {
        return FALSE;
    }

    for (wIndex = 0; wIndex < pDACL->AceCount; wIndex++) {

        if (GetAce(pDACL, wIndex, &lpAceHeader)) {

            if (lpAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE) {
                lpAce = (ACCESS_ALLOWED_ACE *) lpAceHeader;

                lpAce->Mask &= ~(PROCESS_TERMINATE | WRITE_DAC | WRITE_OWNER);
            }
        }
    }

    dwResult = SetSecurityInfo (hProcess, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,
                                NULL, NULL, pDACL, NULL);

    LocalFree (pSD);

    if (dwResult != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  ReadExclusionList()
//
//  Purpose:    Checks if the profile quota policy is set,
//              and if so gets the max profile size.
//
//  Parameters: void
//
//  Return:     TRUE if profile quota is enabled
//              FALSE if not
//
//*************************************************************

BOOL ReadExclusionList()
{
    TCHAR szExcludeList2[MAX_PATH];
    TCHAR szExcludeList1[MAX_PATH];
    HKEY  hKey;
    DWORD dwSize, dwType;

    //
    // Check for a list of directories to exclude both user preferences
    // and user policy
    //

    szExcludeList1[0] = TEXT('\0');
    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szExcludeList1);
        RegQueryValueEx (hKey,
                         TEXT("ExcludeProfileDirs"),
                         NULL,
                         &dwType,
                         (LPBYTE) szExcludeList1,
                         &dwSize);

        RegCloseKey (hKey);
    }

    szExcludeList2[0] = TEXT('\0');
    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      SYSTEM_POLICIES_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szExcludeList2);
        RegQueryValueEx (hKey,
                         TEXT("ExcludeProfileDirs"),
                         NULL,
                         &dwType,
                         (LPBYTE) szExcludeList2,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Merge the user preferences and policy together
    //

    g_szExcludeList[0] = TEXT('\0');

    if (szExcludeList1[0] != TEXT('\0')) {
        CheckSemicolon(szExcludeList1);
        lstrcpy (g_szExcludeList, szExcludeList1);
    }

    if (szExcludeList2[0] != TEXT('\0')) {
        lstrcat (g_szExcludeList, szExcludeList2);
    }

    return TRUE;
}


//*************************************************************
//
//  ReadQuotaMsg()
//
//  Purpose:    Reads the msg that needs to be displayed.
//
//  Parameters: hKey    - Handle to the open policy 
//
//  Return:     TRUE if mesg could be read
//              FALSE otherwise
//
//*************************************************************
BOOL ReadQuotaMsg(HKEY hKey)
{
    DWORD dwType, dwSize, dwValue, dwErr;

    if (g_lpQuotaMessage) {
        LocalFree(g_lpQuotaMessage);
        g_lpQuotaMessage = NULL;
    }
    
    dwSize = sizeof(TCHAR)*500;
    g_lpQuotaMessage = LocalAlloc (LPTR, dwSize);
    
    if (!g_lpQuotaMessage) {
        DebugMsg((DM_WARNING, TEXT("ReadRegistry:  Failed to allocate memory for msg with %d."), GetLastError()));
        return FALSE;
    }
    
    dwErr = RegQueryValueEx (hKey,  TEXT("ProfileQuotaMessage"), NULL,
                        &dwType, (LPBYTE) g_lpQuotaMessage, &dwSize);
    
    if (dwErr == ERROR_MORE_DATA) {
        LPTSTR lpTemp1;
        
        //
        // Go in again with a larger buffer
        //
        
        lpTemp1 = LocalReAlloc(g_lpQuotaMessage, dwSize, 
            LMEM_MOVEABLE | LMEM_ZEROINIT);
        
        if (!lpTemp1) {
            DebugMsg((DM_WARNING, TEXT("ReadRegistry:  Failed to reallocate memory for msg with %d."), GetLastError()));
            LocalFree(g_lpQuotaMessage);
            g_lpQuotaMessage = NULL;            
            return FALSE;
        }
        
        g_lpQuotaMessage = lpTemp1;
        
        dwErr = RegQueryValueEx (hKey,  TEXT("ProfileQuotaMessage"), NULL,
            &dwType, (LPBYTE) g_lpQuotaMessage, &dwSize);
    }
    
    //
    // Load the default message otherwise
    //
    
    if (dwErr != ERROR_SUCCESS) {
        dwSize = sizeof(TCHAR)*500;
        LoadString (hInst, IDS_DEFAULTMSG, g_lpQuotaMessage, 500);
    }
    
    //
    // if there is any message expand the environment variables in it.
    // 
    //
    
    if (*g_lpQuotaMessage) {
        LPTSTR lpTemp1, lpTemp2;
        
        dwSize = sizeof(TCHAR)*500;
        lpTemp1 = LocalAlloc (LPTR, dwSize);
        
        if (lpTemp1) {
            dwSize = ExpandEnvironmentStrings (g_lpQuotaMessage, lpTemp1, 500);
            
            if (dwSize <= 500) 
                lstrcpy (g_lpQuotaMessage, lpTemp1);
            else {
                lpTemp2 = LocalReAlloc(lpTemp1, dwSize*sizeof(TCHAR), 
                    LMEM_MOVEABLE | LMEM_ZEROINIT);
                
                if (lpTemp2) {
                    lpTemp1 = lpTemp2;
                    
                    //
                    // go in with a larger buffer
                    //
                    
                    ExpandEnvironmentStrings (g_lpQuotaMessage, lpTemp1, dwSize);
                    
                    lpTemp2 = LocalReAlloc(g_lpQuotaMessage, dwSize*sizeof(TCHAR), 
                        LMEM_MOVEABLE | LMEM_ZEROINIT);
                    
                    if (lpTemp2) {
                        g_lpQuotaMessage = lpTemp2;
                        lstrcpy (g_lpQuotaMessage, lpTemp1);
                    } else {
                        DebugMsg((DM_WARNING, TEXT("ReadRegistry:  Failed to resize msg buffer with %d.Not expanding env var"), GetLastError()));
                    }
                }
                else {
                    DebugMsg((DM_WARNING, TEXT("ReadRegistry:  Failed to reallocate memory for tmp buffer with %d.Not expanding env var"), GetLastError()));
                }
            }
            
            LocalFree (lpTemp1);
        } else {
            DebugMsg((DM_WARNING, TEXT("ReadRegistry:  Failed to allocate memory for tmp buffer with %d.Not expanding env var"), GetLastError()));
        }
    }

    return TRUE;
    
}

//*************************************************************
//
//  ReadRegistry()
//
//  Purpose:    Checks if the profile quota policy is set,
//              and if so gets the max profile size.
//
//  Parameters: void
//
//  Return:     TRUE if profile quota is enabled
//              FALSE if not
//
//*************************************************************
BOOL ReadRegistry (void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwValue, dwErr;

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                            0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwValue);
        lResult = RegQueryValueEx (hKey, TEXT("EnableProfileQuota"), NULL,
                                   &dwType, (LPBYTE) &dwValue, &dwSize);

        if (lResult == ERROR_SUCCESS) {

            if (dwValue) {

                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Profile quotas are enabled.")));

                dwSize = sizeof(g_dwMaxProfileSize);
                RegQueryValueEx (hKey, TEXT("MaxProfileSize"), NULL,
                                 &dwType, (LPBYTE) &g_dwMaxProfileSize, &dwSize);
                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Max Profile Size:  %d"), g_dwMaxProfileSize));


                dwSize = sizeof(g_bShowReg);
                RegQueryValueEx (hKey, TEXT("IncludeRegInProQuota"), NULL,
                                 &dwType, (LPBYTE) &g_bShowReg, &dwSize);
                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Show registry in file list:  %s"),
                         g_bShowReg ? TEXT("TRUE") : TEXT("FALSE")));


                dwSize = sizeof(g_bWarnUser);
                RegQueryValueEx (hKey, TEXT("WarnUser"), NULL,
                                 &dwType, (LPBYTE) &g_bWarnUser, &dwSize);
                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Warn user when quota exceeded:  %s"),
                         g_bWarnUser ? TEXT("TRUE") : TEXT("FALSE")));


                if (g_bWarnUser) {

                    dwSize = sizeof(g_dwWarnUserTimeout);
                    if (RegQueryValueEx (hKey, TEXT("WarnUserTimeout"), NULL,
                                     &dwType, (LPBYTE) &g_dwWarnUserTimeout, &dwSize) == ERROR_SUCCESS) {

                        if (g_dwWarnUserTimeout > 1440) {
                            g_dwWarnUserTimeout = 1440;
                        }

                        DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  User warning reminder timeout:  %d"), g_dwWarnUserTimeout));
                    }
                }
                    
                //
                // Now read the message that needs to be displayed
                //

                if (!ReadQuotaMsg(hKey)) {
                    RegCloseKey (hKey);
                    return FALSE;
                }


                if (ReadExclusionList()) {
                    RegCloseKey (hKey);                
                    return TRUE;
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Failed to read the ExclusionList")));
                }

            } else {
                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Profile quotas are DISABLED.")));
            }

        } else {
            DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Failed to query EnableProfileQuota with error %d."), lResult));
        }

        RegCloseKey (hKey);

    } else {
        DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Failed to open System policy key with error %d."), lResult));
    }

    return FALSE;
}


//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  CheckSemicolon()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericlfo    Created
//
//*************************************************************
LPTSTR CheckSemicolon (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT(';')) {
        *lpEnd =  TEXT(';');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  RecurseDirectory()
//
//  Purpose:    Recurses through the subdirectories counting the size.
//
//  Parameters: lpDir         -   Directory
//              lpTop         -   Top of the display name
//              hLV           -   Listview window handle (optional)
//              lpExcludeList -   Null-termed list of dirs to be skipped (optional)             
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/30/96     ericflo    Created
//              12/22/98    ushaji     Added exclusionlist support
// Notes:
//      The buffer size expected is MAX_PATH+4 for some internal processing
// We should fix this to be better post Win 2K.
//*************************************************************

BOOL RecurseDirectory (LPTSTR lpDir, LPTSTR lpTop, HWND hLV, LPTSTR lpExcludeList)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;
    LPTSTR lpEnd, lpTemp;
    BOOL bResult = TRUE;
    BOOL bSkip;


    //
    // Setup the ending pointer
    //

    lpEnd = CheckSlash (lpDir);


    //
    // Append *.* to the source directory
    //

    lstrcpy(lpEnd, TEXT("*.*"));



    //
    // Search through the source directory
    //

    hFile = FindFirstFile(lpDir, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
             (GetLastError() == ERROR_PATH_NOT_FOUND) ) {

            //
            // bResult is already initialized to TRUE, so
            // just fall through.
            //

        } else {

            DebugMsg((DM_WARNING, TEXT("RecurseDirectory:  FindFirstFile for <%s> failed with %d."),
                     lpDir, GetLastError()));
            bResult = FALSE;
        }

        goto RecurseDir_Exit;
    }


    do {

        //
        // Append the file / directory name to the working buffer
        //

        // skip the file if the path > MAX_PATH
        
        if ((1+lstrlen(fd.cFileName)+lstrlen(lpDir)+lstrlen(TEXT("\\*.*"))) >= 2*MAX_PATH) {
            continue;
        }

        lstrcpy (lpEnd, fd.cFileName);


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Check for "." and ".."
            //

            if (!lstrcmpi(fd.cFileName, TEXT("."))) {
                continue;
            }

            if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
                continue;
            }


            //
            // Check if this directory should be excluded
            //

            if (lpExcludeList) {

                bSkip = FALSE;
                lpTemp = lpExcludeList;

                while (*lpTemp) {

                    if (lstrcmpi (lpTemp, lpDir) == 0) {
                        bSkip = TRUE;
                        break;
                    }

                    lpTemp += lstrlen (lpTemp) + 1;
                }

                if (bSkip) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> due to exclusion list."),
                             lpDir));
                    continue;
                }
            }

            //
            // Found a directory.
            //
            // 1)  Change into that subdirectory on the source drive.
            // 2)  Recurse down that tree.
            // 3)  Back up one level.
            //

            //
            // Recurse the subdirectory
            //

            if (!RecurseDirectory(lpDir, lpTop, hLV, lpExcludeList)) {
                bResult = FALSE;
                goto RecurseDir_Exit;
            }

        } else {

            //
            // Found a file, add the filesize and put in the listview
            // if appropriate.
            //

            g_dwProfileSizeTemp += fd.nFileSizeLow;
            DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Profile Size <%d> after <%s> "), g_dwProfileSizeTemp,
                             fd.cFileName));

            if (hLV) {
                LV_ITEM lvi;
                BOOL bAddItem = TRUE;

                if ((lstrlen(fd.cFileName) >= 6) &&
                    (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                    TEXT("ntuser"), 6,
                                    fd.cFileName, 6) == 2)) {
                    bAddItem = (g_bShowReg ? TRUE : FALSE);
                }

                if (bAddItem && g_bHideSmallItems && (fd.nFileSizeLow <= 2048)) {
                    bAddItem = FALSE;
                }

                if (bAddItem) {
                    TCHAR szSize[40];
                    DWORD dwFileSize;
                    INT  iItem;

                    lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
                    lvi.iItem = 0;
                    lvi.iSubItem = 0;
                    lvi.state = 0;
                    lvi.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
                    lvi.pszText = lpTop;
                    lvi.lParam = fd.nFileSizeLow;

                    iItem = ListView_InsertItem (hLV, &lvi);

                    if (fd.nFileSizeLow <= 1024) {
                        dwFileSize = 1;
                    } else {
                        dwFileSize = fd.nFileSizeLow / 1024;
                    }
                    _snwprintf (szSize, ARRAYSIZE(szSize), szSizeFormat, dwFileSize);

                    lvi.mask = LVIF_TEXT | LVIF_STATE;
                    lvi.iItem = iItem;
                    lvi.iSubItem = 1;
                    lvi.state = 0;
                    lvi.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
                    lvi.pszText = szSize;
                    lvi.lParam = fd.nFileSizeLow;

                    ListView_SetItem (hLV, &lvi);
                }
            }
        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


RecurseDir_Exit:

    //
    // Remove the file / directory name appended above
    //

    *lpEnd = TEXT('\0');


    //
    // Close the search handle
    //

    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    return bResult;
}

//*************************************************************
//
//  CenterWindow()
//
//  Purpose:    Centers a window on the screen
//
//  Parameters: hwnd    -   window handle to center
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/21/96     ericflo    Ported
//
//*************************************************************

void CenterWindow (HWND hwnd)
{
    RECT    rect;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    //
    // Get window rect
    //

    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;


    //
    // Get parent rect
    //

    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        //
        // Return the desktop windows size (size of main screen)
        //

        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        HWND    hwndParent;
        RECT    rectParent;

        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }

        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    //
    // Center the child in the parent
    //

    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;


    //
    // Move the child into position
    //

    SetWindowPos(hwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);
}



//*************************************************************
//
//  QuotaDlgProc()
//
//  Purpose:    Quota dialog box
//
//  Parameters: hDlg    -   Window handle
//              message -   Window message
//              wParam  -   WPARAM
//              lParam  -   LPARAM
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

LRESULT CALLBACK QuotaDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuffer[40];
    TCHAR szSize[40];
    HWND hLV;
    LV_COLUMN col;
    RECT rect;
    INT  cx;
    HKEY hKey;
    DWORD dwSize, dwType;
    LPTSTR lpMessage;


    switch (message) {
       case WM_INITDIALOG:

          hLV = GetDlgItem (hDlg, IDC_QUOTA_FILELIST);


          //
          // Add the columns to the listview
          //

          GetClientRect (hLV, &rect);
          cx = (rect.right * 31) / 40;

          LoadString (hInst, IDS_COLUMN1, szBuffer, 40);

          col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
          col.fmt = LVCFMT_LEFT;
          col.cx = cx;
          col.pszText = szBuffer;
          col.iSubItem = 0;
          ListView_InsertColumn (hLV, 0, &col);

          LoadString (hInst, IDS_COLUMN2, szBuffer, 40);

          col.cx = rect.right - cx - GetSystemMetrics(SM_CYHSCROLL);
          col.fmt = LVCFMT_RIGHT;
          col.iSubItem = 1;
          ListView_InsertColumn (hLV, 1, &col);


          //
          // Hide small items by default
          //

          g_bHideSmallItems = TRUE;
          CheckDlgButton (hDlg, IDC_QUOTA_HIDESMALL, BST_CHECKED);


          CenterWindow (hDlg);
          SetForegroundWindow (hDlg);


          // EnumerateProfile (GetDlgItem (hDlg, IDC_QUOTA_FILELIST));


          dwSize = 500 * sizeof(TCHAR);
          lpMessage = LocalAlloc (LPTR, dwSize);
          if (!lpMessage)
              break;

          LoadString (hInst ,IDS_QUOTAENUMMSG, lpMessage, 500);
          
          SetDlgItemText (hDlg, IDC_QUOTA_TEXT, lpMessage);


          if (g_dwProfileSize > g_dwMaxProfileSize) {
              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconStop, 0);

          } else if ( (g_dwMaxProfileSize - g_dwProfileSize) < (g_dwProfileSize * .10)) {
              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconCaution, 0);

          }  else {
              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconGood, 0);
          }

          //
          // Setting the global value at the end QuotaThread is not trying
          // to refresh the dialog etc. at the same time.
          //
          
          g_hQuotaDlg = hDlg;

          SetEvent(g_hQuotaDlgEvent);

          LocalFree (lpMessage);

          break;
          
      case WM_REFRESH:

          //
          // Popuplate the listview
          //


          //
          // Set the size information
          //

          _snwprintf (szSize, ARRAYSIZE(szSize), szSizeFormat, g_dwProfileSize);
          SetDlgItemText (hDlg, IDC_QUOTA_SIZE, szSize);

          _snwprintf (szSize, ARRAYSIZE(szSize), szSizeFormat, g_dwMaxProfileSize);
          SetDlgItemText (hDlg, IDC_QUOTA_MAXSIZE, szSize);


          dwSize = 500 * sizeof(TCHAR);
          lpMessage = LocalAlloc (LPTR, dwSize);

          if (!lpMessage) {
              break;
          }

          if (g_dwProfileSize > g_dwMaxProfileSize) {

              //
              // This messge is already read
              //

              SetDlgItemText (hDlg, IDC_QUOTA_TEXT, g_lpQuotaMessage);
              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconStop, 0);

          } else if ( (g_dwMaxProfileSize - g_dwProfileSize) < (g_dwProfileSize * .10)) {

              LoadString (hInst, IDS_CAUTION, lpMessage, 500);
              SetDlgItemText (hDlg, IDC_QUOTA_TEXT, lpMessage);

              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconCaution, 0);

          }  else {

              LoadString (hInst, IDS_LOGOFFOK, lpMessage, 500);
              SetDlgItemText (hDlg, IDC_QUOTA_TEXT, lpMessage);

              SendDlgItemMessage (hDlg, IDC_QUOTA_ICON, STM_SETICON, (WPARAM) hIconGood, 0);
          }

          LocalFree (lpMessage);
          break;


       case WM_COMMAND:
          if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
             g_hQuotaDlg = NULL;
             if ((g_dwProfileSize < g_dwMaxProfileSize) && (g_bQueryEndSession) && (g_dwProfileSize != 0)) {
                 PostMessage (hwndMain, WM_EXITWINDOWS, 0, 0);
             }
             EndDialog(hDlg, TRUE);
             return TRUE;
          }

          if (LOWORD(wParam) == IDC_QUOTA_HIDESMALL) {
              g_bHideSmallItems = IsDlgButtonChecked (hDlg, IDC_QUOTA_HIDESMALL);
              EnumerateProfile (GetDlgItem(hDlg, IDC_QUOTA_FILELIST));
          }

          break;
    }

    return FALSE;
}

//*************************************************************
//
//  ListViewSortCallback()
//
//  Purpose:    List view callback function for sorting
//
//  Parameters: lParam1     -   lParam1
//              lParam2     -   lParam2
//              lParamSort  -   Column id
//
//  Return:     -1, 0, 1
//
//*************************************************************
INT CALLBACK ListViewSortCallback (LPARAM lParam1, LPARAM lParam2,
                                    LPARAM lParamSort)
{

    if (lParam1 < lParam2) {
        return 1;

    } else if (lParam1 == lParam2) {
        return 0;

    } else {
        return -1;
    }

}


//*************************************************************
//
//  ConvertExclusionList()
//
//  Purpose:    Converts the semi-colon profile relative exclusion
//              list to fully qualified null terminated exclusion
//              list
//
//  Parameters: lpSourceDir     -  Profile root directory
//              lpExclusionList -  List of directories to exclude
//
//  Return:     List if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList)
{
    LPTSTR lpExcludeList = NULL, lpInsert, lpEnd, lpTempList;
    LPCTSTR lpTemp, lpDir;
    TCHAR szTemp[MAX_PATH];
    DWORD dwSize = 2;  // double null terminator
    DWORD dwStrLen;


    //
    // Setup a temp buffer to work with
    //

    lstrcpy (szTemp, lpSourceDir);
    lpEnd = CheckSlash (szTemp);


    //
    // Loop through the list
    //

    lpTemp = lpDir = lpExclusionList;

    while (*lpTemp) {

        //
        // Look for the semicolon separator
        //

        while (*lpTemp && ((*lpTemp) != TEXT(';'))) {
            lpTemp++;
        }


        //
        // Remove any leading spaces
        //

        while (*lpDir == TEXT(' ')) {
            lpDir++;
        }


        //
        // Put the directory name on the temp buffer
        //

        lstrcpyn (lpEnd, lpDir, (int)(lpTemp - lpDir + 1));


        //
        // Add the string to the exclusion list
        //

        if (lpExcludeList) {

            dwStrLen = lstrlen (szTemp) + 1;
            dwSize += dwStrLen;

            lpTempList = LocalReAlloc (lpExcludeList, dwSize * sizeof(TCHAR),
                                       LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (!lpTempList) {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to realloc memory with %d"), GetLastError()));
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }

            lpExcludeList = lpTempList;

            lpInsert = lpExcludeList + dwSize - dwStrLen - 1;
            lstrcpy (lpInsert, szTemp);

        } else {

            dwSize += lstrlen (szTemp);
            lpExcludeList = LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

            if (!lpExcludeList) {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to alloc memory with %d"), GetLastError()));
                goto Exit;
            }

            lstrcpy (lpExcludeList, szTemp);
        }


        //
        // If we are at the end of the exclusion list, we're done
        //

        if (!(*lpTemp)) {
            goto Exit;
        }


        //
        // Prep for the next entry
        //

        lpTemp++;
        lpDir = lpTemp;
    }

Exit:

    return lpExcludeList;
}

//*************************************************************
//
//  EnumerateProfile()
//
//  Purpose:    Enumerates the profile for size and names
//
//  Parameters: hLV -   listview window handle (optional)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL EnumerateProfile (HWND hLV)
{
    TCHAR szProfile[2*MAX_PATH];
    LPTSTR lpEnd;
    BOOL bRetVal = FALSE;
    LPTSTR lpExcludeList = NULL;
    LVITEM item;


    //
    // Get the profile directory
    //

    szProfile[0] = TEXT('\0');
    GetEnvironmentVariable (TEXT("USERPROFILE"), szProfile, MAX_PATH);

    if (szProfile[0] == TEXT('\0')) {
        ExitThread (0);
    }

    lpEnd = CheckSlash (szProfile);


    //
    // Claim the critical section
    //

    EnterCriticalSection (&g_cs);


    if (hLV) {
        ListView_DeleteAllItems (hLV);
    }

    //
    // Get current profile size
    //

    g_dwProfileSizeTemp = 0;


    //
    // Convert the exclusionlist read from the registry to a Null terminated list
    // readable by recursedirectory.
    //

    if (g_szExcludeList[0] != TEXT('\0'))
        lpExcludeList = ConvertExclusionList (szProfile, g_szExcludeList);
    else
        lpExcludeList = NULL;


    if (!RecurseDirectory (szProfile, lpEnd, hLV, lpExcludeList)) {
        SendMessage (hLV, WM_SETREDRAW, TRUE, 0);
        goto Exit;
    }

    g_dwProfileSize = g_dwProfileSizeTemp;

    //
    // Sort by size
    //

    ListView_SortItems (hLV, ListViewSortCallback, 1);


    //
    // Select the next item
    //

    item.mask = LVIF_STATE;
    item.iItem = 0;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);


    //
    // Convert to K
    //

    if (g_dwProfileSize < 1024) {
        g_dwProfileSize = 1;
    } else {
        g_dwProfileSize /= 1024;
    }


    bRetVal = TRUE;

Exit:
    //
    // Release the critical section
    //

    LeaveCriticalSection (&g_cs);

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\refgp\refgp.h ===
////////////////////////////////////////////////////////////////
//
// Refgp.h
//
// Refresh Group Policy exe
//
//
////////////////////////////////////////////////////////////////

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <lm.h>
#define SECURITY_WIN32
#include <tchar.h>
#include <stdio.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlwapi.h>
#include "userenv.h"
#include "userenvp.h"
                                                   
#define    IDS_USAGE_FIRST                      101

#define    IDS_USAGE1                           101
#define    IDS_USAGE2                           102
#define    IDS_USAGE3                           103
#define    IDS_USAGE4                           104
#define    IDS_USAGE5                           105
#define    IDS_USAGE6                           106
#define    IDS_USAGE7                           107
#define    IDS_USAGE8                           108
#define    IDS_USAGE9                           109
#define    IDS_USAGE10                          110
#define    IDS_USAGE11                          111
#define    IDS_USAGE12                          112
#define    IDS_USAGE13                          113
#define    IDS_USAGE14                          114
#define    IDS_USAGE15                          115
#define    IDS_USAGE16                          116
#define    IDS_USAGE17                          117
#define    IDS_USAGE18                          118
#define    IDS_USAGE19                          119
#define    IDS_USAGE20                          120
#define    IDS_USAGE21                          121
#define    IDS_USAGE22                          122
#define    IDS_USAGE23                          123
#define    IDS_USAGE24                          124
#define    IDS_USAGE25                          125
#define    IDS_USAGE26                          126
#define    IDS_USAGE27                          127
#define    IDS_USAGE28                          128
#define    IDS_USAGE29                          129
#define    IDS_USAGE30                          130
#define    IDS_USAGE31                          131
#define    IDS_USAGE32                          132
#define    IDS_USAGE33                          133
#define    IDS_USAGE34                          134
#define    IDS_USAGE35                          135
#define    IDS_USAGE36                          136
#define    IDS_USAGE37                          137
#define    IDS_USAGE38                          138
#define    IDS_USAGE39                          139
#define    IDS_USAGE40                          140
#define    IDS_USAGE41                          141
#define    IDS_USAGE42                          142
#define    IDS_USAGE43                          143
#define    IDS_USAGE44                          144
#define    IDS_USAGE45                          145
#define    IDS_USAGE46                          146

#define    IDS_USAGE_LAST                       146



#define    IDS_REFRESH_LAUNCHED                 201
#define    IDS_REFRESH_FAILED                   202
#define    IDS_POLWAIT_FAILED                   203
#define    IDS_POLWAIT_TIMEDOUT                 204
#define    IDS_REFRESH_BACKGND_SUCCESS          205
#define    IDS_NEED_LOGOFF                      206
#define    IDS_NEED_REBOOT                      207
#define    IDS_PROMPT_REBOOT                    208
#define    IDS_PROMPT_LOGOFF                    209
#define    IDS_YES                              210
#define    IDS_NO                               211
#define    IDS_REFRESH_POLICY_FAILED            212
#define    IDS_COULDNT_REBOOT                   213
#define    IDS_COULDNT_LOGOFF                   214
#define    IDS_NOTIFY_MACHINE_FG                215
#define    IDS_NOTIFY_USER_FG                   216
#define    IDS_REBOOTING                        217
#define    IDS_LOGGING_OFF                      218
#define    IDS_OUT_OF_MEMORY                    219
#define    IDS_REFRESH_BACKGND_TRIGGERED        220
#define    IDS_SPACE                            221
#define    IDS_SET_MODE_FAILED                  222
#define    IDS_NEED_LOGOFF_SYNC                 223
#define    IDS_NEED_REBOOT_SYNC                 224

                                                
#define    IDS_TARGET                           301
#define    IDS_USER                             302
#define    IDS_MACHINE                          303
#define    IDS_BOTH                             304
#define    IDS_TIME                             305
#define    IDS_FORCE                            306
#define    IDS_LOGOFF                           307
#define    IDS_BOOT                             308
#define    IDS_SYNC                             309
                                                   
#include <stdio.h>
#include <locale.h>
#include <winnlsp.h>

#ifdef __cplusplus
extern "C" {
#endif

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid);
NTSTATUS LoadSidAuthFromString (const WCHAR* pString, PSID_IDENTIFIER_AUTHORITY pSidAuth);
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\refgp\sid.c ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "refgp.h"

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}

//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    SID_IDENTIFIER_AUTHORITY Auth;

    pSidStr = LocalAlloc(LPTR, (lstrlen (lpszSidStr) + 1)*sizeof(WCHAR));;
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    lstrcpy (pSidStr, lpszSidStr);
    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        LocalFree( pSidStr );
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = lstrlenW (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    len = lstrlen (szNum);
    pwszNumStr = LocalAlloc( LPTR, (len + 1) * sizeof(WCHAR));

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    lstrcpy (pwszNumStr, szNum);
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        LocalFree( pwszNumStr );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\refgp\refgp.cxx ===
////////////////////////////////////////////////////////////////
//
// Refgp.cxx
//
// Refresh Group Policy exe
//
//
////////////////////////////////////////////////////////////////


#include "refgp.h"

#define USER_POLICY_APPLIED_EVENT    TEXT("userenv: User Group Policy has been applied")
#define MACHINE_POLICY_APPLIED_EVENT TEXT("Global\\userenv: Machine Group Policy has been applied")

#define USER_POLICY_DONE_EVENT       TEXT("userenv: User Group Policy Processing is done")
#define MACHINE_POLICY_DONE_EVENT    TEXT("Global\\userenv: Machine Group Policy Processing is done")

#define USER_POLICY_REFRESH_NEEDFG_EVENT    TEXT("userenv: User Group Policy ForcedRefresh Needs Foreground Processing")
#define MACHINE_POLICY_REFRESH_NEEDFG_EVENT TEXT("Global\\userenv: Machine Group Policy ForcedRefresh Needs Foreground Processing")

#define REFRESH_MACHINE 1
#define REFRESH_USER    2

HINSTANCE hInst;

typedef enum _FAILSTATES {
    NO_FAILURE,
    REFRESH_FAILED,
    POLWAIT_FAILED,
    POLWAIT_TIMEDOUT
} FAILSTATES;


typedef struct _REFSTRUCT {
    BOOL        bMachine;
    DWORD       dwOption;
    DWORD       dwTimeOut;
    DWORD       dwError;
    FAILSTATES  fState;
    BOOL        bFGNeeded;
} REFSTRUCT, *LPREFSTRUCT;


REFSTRUCT refMach;
REFSTRUCT refUser;

WCHAR  szUser[200];
WCHAR  szMach[200];
WCHAR  szErr[MAX_PATH*2];



// Process arg. checks whether argument is present
BOOL ProcessArg(int *pargc, LPWSTR **pargv, DWORD dwStringId, BOOL *bValue)
{
    WCHAR szStr[200];
    LPWSTR *argv = *pargv;

    if (*pargc == 0)
        return TRUE;

    if (!LoadString (hInst, dwStringId, szStr, 200)) {
        return FALSE;
    }

    for (; (*argv); *argv++) {
        if (_wcsicmp(*argv, szStr) == 0) {
            *bValue = TRUE;
            (*pargc)--;
            return TRUE;
        }
    }
    
    return TRUE;
}


// Process arg. checks whether argument is present and what the value is after the ":" in string format
BOOL ProcessArg(int *pargc, WCHAR ***pargv, DWORD dwStringId, WCHAR **szValue)
{
    WCHAR szStr[200];
    LPWSTR *argv = *pargv, szJunk=NULL;
    

    if (*pargc == 0)
        return TRUE;

    if (!LoadString (hInst, dwStringId, szStr, 200)) {
        return FALSE;
    }

    for (; (*argv); *argv++) {
        if (_wcsnicmp(*argv, szStr, lstrlen(szStr)) == 0) {
            *szValue = (*argv)+lstrlen(szStr);
            (*pargc)--;
            return TRUE;
        }
    }

    *szValue = NULL;
    return TRUE;
}

// Process arg. checks whether argument is present and what the value is after the ":" in long format
BOOL ProcessArg(int *pargc, WCHAR ***pargv, DWORD dwStringId, long *plValue)
{
    WCHAR szStr[200];
    LPWSTR *argv = *pargv, szJunk=NULL;


    if (*pargc == 0)
        return TRUE;

    if (!LoadString (hInst, dwStringId, szStr, 200)) {
        return FALSE;
    }

    for (; (*argv); *argv++) {
        if (_wcsnicmp(*argv, szStr, lstrlen(szStr)) == 0) {
            *plValue = wcstol((*argv)+lstrlen(szStr), &szJunk, 10);
            (*pargc)--;
            return TRUE;
        }
    }

    return TRUE;
}

BOOL CompareOptions(WCHAR *szValue, DWORD dwOptionId)
{
    WCHAR szStr[200];
    
    if (!szValue)
        return FALSE;
    
    if (!LoadString (hInst, dwOptionId, szStr, 200)) {
        return FALSE;
    }


    if (_wcsicmp(szValue, szStr) == 0)
        return TRUE;

    return FALSE;
    
}

BOOL GetValue(WCHAR *szValue, DWORD dwOptionId)
{    
    if (!LoadString (hInst, dwOptionId, szValue, 200)) {
        return FALSE;
    }

    return TRUE;
}


void PrintMsg(DWORD dwMsgId, ...)
{
    WCHAR szFmt[200];
    WCHAR szMsg[200];
    va_list marker;    
    
    if (!LoadString (hInst, dwMsgId, szFmt, 200)) {
        return;
    }


   va_start(marker, dwMsgId);
   wvnsprintf(szMsg, 200, szFmt, marker);
   va_end(marker);

   wprintf(szMsg);
   
    return;
}

void PrintUsage()
{
    for (DWORD dwMsgId = IDS_USAGE_FIRST; dwMsgId <= IDS_USAGE_LAST; dwMsgId++) {
        PrintMsg(dwMsgId);
    }

    return;
}


BOOL PromptUserForFG(BOOL bMachine)
{
    WCHAR tTemp, tChar;
    WCHAR Yes[20], No[20];
    
    if (!LoadString (hInst, IDS_YES, Yes, 20)) {
        return FALSE; // safe
    }
    
    if (!LoadString (hInst, IDS_NO, No, 20)) {
        return FALSE; // safe
    }

    for (;;) {
        if (bMachine)
            PrintMsg(IDS_PROMPT_REBOOT);
        else
            PrintMsg(IDS_PROMPT_LOGOFF);

        tChar = getwchar();

        tTemp = tChar;
        while (tTemp != TEXT('\n')) {
            tTemp = getwchar();
        }

        if (towupper(tChar) == towupper(Yes[0]))
            return TRUE;

        if (towupper(tChar) == towupper(No[0]))
            return FALSE;            
    }
    
    
    return FALSE;
}

//***************************************************************************
//
//  GetErrString
//
//  Purpose:    Calls FormatMessage to Get the error string corresp. to a error
//              code
//
//
//  Parameters: dwErr           -   Error Code
//              szErr           -   Buffer to return the error string (MAX_PATH)
//                                  is assumed.!!!
//
//  Return:     szErr
//
//***************************************************************************

LPTSTR GetErrString(DWORD dwErr, LPTSTR szErr)
{
    szErr[0] = TEXT('\0');

    FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                  NULL, dwErr,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  szErr, MAX_PATH, NULL);

    return szErr;
}



void RefreshPolicyAndWait(LPREFSTRUCT   lpRef)
{
    HANDLE  hNotifyEvent=NULL, hFGProcessingEvent=NULL; 
    DWORD   dwRet=0;


    lpRef->fState = REFRESH_FAILED;
    lpRef->dwError = E_FAIL;
    lpRef->bFGNeeded = FALSE;

    if (!RefreshPolicyEx(lpRef->bMachine, lpRef->dwOption)) {
        lpRef->fState = REFRESH_FAILED;
        lpRef->dwError = GetLastError();
        goto Exit;
    }    


    if (lpRef->dwTimeOut != 0) {
        
        lpRef->fState = POLWAIT_FAILED;
        lpRef->dwError = E_FAIL;
        
        hNotifyEvent = OpenEvent(SYNCHRONIZE, FALSE, lpRef->bMachine ? MACHINE_POLICY_DONE_EVENT : USER_POLICY_DONE_EVENT );   

        if (!hNotifyEvent) {
            lpRef->fState = POLWAIT_FAILED;
            lpRef->dwError = GetLastError();
            goto Exit;
        }


        hFGProcessingEvent = OpenEvent(SYNCHRONIZE, FALSE, lpRef->bMachine ? MACHINE_POLICY_REFRESH_NEEDFG_EVENT : USER_POLICY_REFRESH_NEEDFG_EVENT);   

        if (!hNotifyEvent) {
            lpRef->fState = POLWAIT_FAILED;
            lpRef->dwError = GetLastError();
            goto Exit;
        }

        
        dwRet = WaitForSingleObject(hNotifyEvent, (lpRef->dwTimeOut == INFINITE) ? INFINITE : 1000*(lpRef->dwTimeOut));

        if (dwRet == WAIT_FAILED) {
            lpRef->fState = POLWAIT_FAILED;
            lpRef->dwError = GetLastError();
            goto Exit;
        }
        else if (dwRet == WAIT_ABANDONED) {
            lpRef->fState = POLWAIT_FAILED;
            lpRef->dwError = E_UNEXPECTED;
            goto Exit;
        }
        else if (dwRet == WAIT_TIMEOUT) {
            lpRef->fState = POLWAIT_TIMEDOUT;
            lpRef->dwError = 0;
            goto Exit;
        }


        lpRef->bFGNeeded = (lpRef->dwOption == RP_FORCE) && (WaitForSingleObject(hFGProcessingEvent, 0) == WAIT_OBJECT_0);
    }
    

    lpRef->fState = NO_FAILURE;

Exit:
    if (hNotifyEvent) 
        CloseHandle(hNotifyEvent);

    if (hFGProcessingEvent) 
        CloseHandle(hFGProcessingEvent);

    return;
}


void PrintRefreshError(LPREFSTRUCT lpRef)
{
    LPWSTR  szTarget = (lpRef->bMachine) ? szMach: szUser;

    switch (lpRef->fState) {
    case REFRESH_FAILED:
        PrintMsg(IDS_REFRESH_FAILED, szTarget, GetErrString(lpRef->dwError, szErr));
        break;

    case POLWAIT_FAILED:
        PrintMsg(IDS_POLWAIT_FAILED, szTarget, GetErrString(lpRef->dwError, szErr));
        break;

    case POLWAIT_TIMEDOUT:
        PrintMsg(IDS_POLWAIT_TIMEDOUT, szTarget);

    case NO_FAILURE:
        if (lpRef->dwTimeOut == 0)
            PrintMsg(IDS_REFRESH_BACKGND_TRIGGERED, szTarget);
        else
            PrintMsg(IDS_REFRESH_BACKGND_SUCCESS, szTarget);

        break;
    default:
        break;
    }
}



void __cdecl main (int argc, char **argv)
{
    DWORD   uTarget=0; 
    BOOL    bArgValid = TRUE;
    LONG    lTime = 600;
    DWORD   dwTime = 600, dwRet = 0, dwOption = 0, dwThread = 0;


    HANDLE  hNotifyEvent=NULL, hFGProcessingEvent=NULL, hToken = NULL; 
    BOOL    bNeedFG = FALSE;
    LPWSTR  lpCommandLine=0, szTarget=0;
    int     wargc=0;
    LPWSTR *wargv=NULL, *wargv1=NULL;
    BOOL    bForce=FALSE, bOkToLogoff=FALSE, bOkToBoot=FALSE, bNextFgSync = FALSE;
    BOOL    bNeedBoot = FALSE, bNeedLogoff = FALSE;
    BOOL    bError = FALSE;
    HANDLE  hThreads[2] = {0, 0};


        
    setlocale( LC_ALL, ".OCP" );
    SetThreadUILanguage(0);

    lpCommandLine = GetCommandLine();

    wargv1 = CommandLineToArgvW(lpCommandLine, &wargc);

    wargv = (LPWSTR *)LocalAlloc(LPTR, (1+wargc)*sizeof(LPWSTR));
    if (!wargv) {
        PrintMsg(IDS_OUT_OF_MEMORY);
        goto Exit;
    }    

    memcpy(wargv, wargv1, wargc*sizeof(LPWSTR));
    
    hInst = GetModuleHandle(wargv[0]);

    if ((!GetValue(szUser, IDS_USER)) || (!GetValue(szMach, IDS_MACHINE))) {
        // we cannot read the resource strings. no point continuing
        return;
    }


    //
    // Ignore the first argument 
    //

    wargc--;
    wargv++;
    
    //
    // Get the args
    //

    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_TARGET, &szTarget);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_TIME, &lTime);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_FORCE, &bForce);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_LOGOFF, &bOkToLogoff);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_BOOT, &bOkToBoot);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_SYNC, &bNextFgSync);
    bArgValid   = bArgValid && (wargc == 0);

    //
    // Get the target correctly
    //

    uTarget = 0;
    if (bArgValid ) {
        if (!szTarget) {
            uTarget |= REFRESH_MACHINE;
            uTarget |= REFRESH_USER;
        }
        else if ( CompareOptions(szTarget, IDS_MACHINE) )
            uTarget |= REFRESH_MACHINE;
        else if ( CompareOptions(szTarget, IDS_USER) ) 
            uTarget |= REFRESH_USER;
        else {
            bArgValid = FALSE;
        }
    }

    //
    // Get the options correctly
    //

    if (bArgValid) {
        if ( bForce )
            dwOption = RP_FORCE;
        else 
            dwOption = 0;
    }


    if (lTime == -1)
        dwTime = INFINITE;
    else
        dwTime = lTime;
        

    if (!bArgValid) {
        PrintUsage();
        goto Exit;
    }

    if (bOkToBoot) 
        bOkToLogoff = TRUE;


    if (bNextFgSync) {
        if (uTarget & REFRESH_MACHINE) {
            dwRet = ForceSyncFgPolicy( 0 );

            if (dwRet != ERROR_SUCCESS) {
                PrintMsg(IDS_SET_MODE_FAILED, GetErrString(dwRet, szErr));
                goto Exit;
            }
        }

        if (uTarget & REFRESH_USER) {
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
                PrintMsg(IDS_SET_MODE_FAILED, GetErrString(GetLastError(), szErr));
                goto Exit;
            }
            
            LPWSTR szSid = GetSidString( hToken );

            if (!szSid) {
                PrintMsg(IDS_SET_MODE_FAILED, GetErrString(GetLastError(), szErr));
                goto Exit;
            }

            dwRet = ForceSyncFgPolicy( szSid );

            if (dwRet != ERROR_SUCCESS) {
                LocalFree (szSid);
                PrintMsg(IDS_SET_MODE_FAILED, GetErrString(dwRet, szErr));
                goto Exit;
            }

            LocalFree (szSid);
            CloseHandle (hToken);
            hToken = 0;
        }

    }
    else {
        if (uTarget & REFRESH_MACHINE) {
            refMach.bMachine = TRUE;
            refMach.dwOption = dwOption;
            refMach.dwTimeOut = dwTime;


            if ((hThreads[dwThread] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RefreshPolicyAndWait, &refMach, 0, 0)) == NULL) {
                PrintMsg(IDS_REFRESH_POLICY_FAILED, GetErrString(GetLastError(), szErr));
                goto Exit;
            }

            dwThread++;
        }


        if (uTarget & REFRESH_USER) {
            refUser.bMachine = FALSE;
            refUser.dwOption = dwOption;
            refUser.dwTimeOut = dwTime;


            if ((hThreads[dwThread] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RefreshPolicyAndWait, &refUser, 0, 0)) == NULL) {
                PrintMsg(IDS_REFRESH_POLICY_FAILED, GetErrString(GetLastError(), szErr));
                goto Exit;
            }

            dwThread++;
        }


        PrintMsg(IDS_REFRESH_LAUNCHED);


        dwRet = WaitForMultipleObjects(dwThread, hThreads, TRUE, INFINITE);

        if ((dwRet != WAIT_OBJECT_0) && (dwRet != (WAIT_OBJECT_0 + 1))) {
            // our threads didn't terminate properly..
            PrintMsg(IDS_REFRESH_POLICY_FAILED, GetErrString(GetLastError(), szErr));
            goto Exit;
        }


        if (uTarget & REFRESH_USER) {
            PrintRefreshError(&refUser);
            if (refUser.fState != NO_FAILURE)
                bError = TRUE;
        }

        if (uTarget & REFRESH_MACHINE) {
            PrintRefreshError(&refMach);
            if (refMach.fState != NO_FAILURE)
                bError = TRUE;
        }

        if (bError) {
            goto Exit;
        }
    }


    PrintMsg(IDS_SPACE);

    if ((uTarget & REFRESH_USER) && (bNextFgSync || refUser.bFGNeeded)) {
        if ( bNextFgSync ) 
            PrintMsg(IDS_NEED_LOGOFF_SYNC);
        else 
            PrintMsg(IDS_NEED_LOGOFF);
        bNeedLogoff = TRUE;
    }
        
    if ((uTarget & REFRESH_MACHINE) && (bNextFgSync || refMach.bFGNeeded)) {
        if ( bNextFgSync ) 
            PrintMsg(IDS_NEED_REBOOT_SYNC);
        else
            PrintMsg(IDS_NEED_REBOOT);
        bNeedBoot = TRUE;
    }


    if ( !bNeedBoot && !bNeedLogoff) {
        goto Exit;
    }


    PrintMsg(IDS_SPACE);
    
    if (bNeedBoot && !bOkToBoot) {
        bOkToBoot = PromptUserForFG(TRUE);
    }

    
    if (bNeedBoot && bOkToBoot) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
            goto Exit;
        }

        BYTE                 bytesTokenPrivNew[sizeof(DWORD)+sizeof(LUID_AND_ATTRIBUTES)];
        PTOKEN_PRIVILEGES    pTokenPrivNew = (PTOKEN_PRIVILEGES)bytesTokenPrivNew;
        BYTE                 bytesTokenPrivOld[sizeof(DWORD)+sizeof(LUID_AND_ATTRIBUTES)];
        PTOKEN_PRIVILEGES    pTokenPrivOld = (PTOKEN_PRIVILEGES)bytesTokenPrivOld;

        DWORD                dwSize=sizeof(DWORD)+sizeof(LUID_AND_ATTRIBUTES);
        DWORD                dwRetSize=0;


        pTokenPrivNew->PrivilegeCount = 1;
        pTokenPrivNew->Privileges->Attributes = SE_PRIVILEGE_ENABLED;
        if (!LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &(pTokenPrivNew->Privileges->Luid))) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
            goto Exit;
        }

        if (!AdjustTokenPrivileges(hToken, FALSE, pTokenPrivNew, dwSize, pTokenPrivOld, &dwRetSize)) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
            goto Exit;
        }


        PrintMsg(IDS_NOTIFY_MACHINE_FG);            
        if (!ExitWindowsEx(EWX_REBOOT, 0)) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
        }
        else {
            PrintMsg(IDS_REBOOTING);
        }


        if (!AdjustTokenPrivileges(hToken, FALSE, pTokenPrivOld, 0, NULL, 0)) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
            goto Exit;
        }

        // if we are rebooting no need to call logoff code
        goto Exit;
    }
    


    if (bNeedLogoff && !bOkToLogoff) {
        bOkToLogoff = PromptUserForFG(FALSE);
    }

    if (bNeedLogoff && bOkToLogoff) {
        PrintMsg(IDS_NOTIFY_USER_FG);
        if (!ExitWindowsEx(EWX_LOGOFF, 0)) {
            PrintMsg(IDS_COULDNT_LOGOFF, GetErrString(GetLastError(), szErr));                
        }
        else {
            PrintMsg(IDS_LOGGING_OFF);
        }
    }

Exit:
    if (hToken) 
        CloseHandle(hToken);

    for (;dwThread;dwThread--) 
        if (hThreads[dwThread-1]) {
            CloseHandle(hThreads[dwThread-1]);
        }

    if (wargv1)
        GlobalFree(wargv1);

    if (wargv)
        LocalFree(wargv);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\refreshevent\test\evprov.cpp ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:  EVPROV.cpp
//
// Description:
//    Sample event provider.
//
// History:
//
// **************************************************************************

#include <windows.h>
#include <stdio.h>

#include <wbemidl.h>

#include "oahelp.inl"
#include "evprov.h"


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::CMyEventProvider()
{
    m_pNs = 0;
    m_pSink = 0;
    m_cRef = 0;
    m_pEventClassDef = 0;
    m_eStatus = Pending;
    m_hThread = 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::~CMyEventProvider()
{
    if (m_hThread)
        CloseHandle(m_hThread);

    if (m_pNs)
        m_pNs->Release();

    if (m_pSink)
        m_pSink->Release();

    if (m_pEventClassDef)
        m_pEventClassDef->Release();        
}


//***************************************************************************
//
//***************************************************************************
// ok

STDMETHODIMP CMyEventProvider::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemEventProvider==riid)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::AddRef()
{
    return ++m_cRef;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    // If here, we are shutting down.
    // ==============================

    m_eStatus = PendingStop;

    return 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

HRESULT CMyEventProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags
    )
{
    // Copy the sink.
    // ==============
    
    m_pSink = pSink;
    m_pSink->AddRef();

    // Create the event thread.
    // ========================
    
    DWORD dwTID;
    
    m_hThread = CreateThread(
        0,
        0,
        CMyEventProvider::EventThread,
        this,
        0,
        &dwTID
        );


    // Wait for provider to be 'ready'.
    // ================================
    
    while (m_eStatus != Running)
        Sleep(100);

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//  This particular provider, being in a DLL operates via its own thread.  
//
//  In practice, such a provider would probably be implemented within a 
//  separate EXE.
//
//***************************************************************************
// ok

DWORD WINAPI CMyEventProvider::EventThread(LPVOID pArg)
{
    // Make transition to the per-instance method.
    // ===========================================
    
    ((CMyEventProvider *)pArg)->InstanceThread();
    return 0;
}

//***************************************************************************
//
//  Events are generated from here
//
//***************************************************************************
// ok

void CMyEventProvider::InstanceThread()
{
    int nIteration = 0;

    m_eStatus = Running;
        
    while (m_eStatus == Running)
    {
        Sleep(10000);    // Provide an event every ten seconds
        
        
        // Generate a new event object.
        // ============================
        
        IWbemClassObject *pEvt = 0;

        HRESULT hRes = m_pEventClassDef->SpawnInstance(0, &pEvt);
        if (hRes != 0)
            continue;   // Failed
            

        // Generate some values to put in the event.
        // =========================================
                
        wchar_t Buf[128];
        swprintf(Buf, L"Test Event <%d>", nIteration);
 
        CVARIANT vName(Buf);
        pEvt->Put(CBSTR(L"Name"), 0, vName, 0);        

        if (nIteration % 2)
            swprintf(Buf, L"Machine");
        else
            swprintf(Buf, L"User");

 
        CVARIANT vTarget(Buf);
        pEvt->Put(CBSTR(L"MachineOrUser"), 0, vTarget, 0);       

        if (((nIteration >> 1) % 4) == 0)
            swprintf(Buf, L"");
        else if (((nIteration >> 1) % 4) == 1)
            swprintf(Buf, L"Force");
        else if (((nIteration >> 1) % 4) == 2)
            swprintf(Buf, L"FetchAndStore");
        else if (((nIteration >> 1) % 4) == 3)
            swprintf(Buf, L"MergeAndApply");


        CVARIANT vOption(Buf);
        pEvt->Put(CBSTR(L"RefreshOption"), 0, vOption, 0);       


        // Deliver the event to CIMOM.
        // ============================
        
        hRes = m_pSink->Indicate(1, &pEvt);
        
        if (hRes)
        {
            // If here, delivery failed.  Do something to report it.
        }

        pEvt->Release();                    
        nIteration++;
    }

    // When we get to here, we are no longer interested in the
    // provider and Release() has long since returned.
    
    m_eStatus = Stopped;
    delete this;
}





//***************************************************************************
//
//***************************************************************************

    // Inherited from IWbemProviderInit
    // ================================

HRESULT CMyEventProvider::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            )
{
    // We don't care about most of the incoming parameters in this
    // simple sample.  However, we will save the namespace pointer
    // and get our event class definition.
    // ===========================================================

    m_pNs = pNamespace;
    m_pNs->AddRef();    

    // Grab the class definition for the event.
    // ======================================
    
    IWbemClassObject *pObj = 0;

    HRESULT hRes = m_pNs->GetObject(
        CBSTR(EVENTCLASS),          
        0,                          
        pCtx,  
        &pObj,
        0
        );

    if (hRes != 0)
        return WBEM_E_FAILED;

    m_pEventClassDef = pObj;

    // Tell CIMOM that we're up and running.
    // =====================================

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    
    return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\refreshevent\test\evprov.h ===
// **************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  EVPROV.H
//
// Description:
//        Sample event provider - header file defines event provider class
//
// History:
//
// **************************************************************************

#ifndef _EVPROV_H_
#define _EVPROV_H_

// {C0A94C66-CB70-4D06-91D2-5DE68C0D0EC5}
DEFINE_GUID(CLSID_MyEventProvider, 
0xC0A94C66, 0xCB70, 0x4D06, 0x91, 0xD2, 0x5D, 0xE6, 0x8C, 0x0D, 0x0E, 0xC5);

#define EVENTCLASS  L"PolicyRefreshEvent"


class CMyEventProvider : public IWbemEventProvider, public IWbemProviderInit
{
    ULONG               m_cRef;
    IWbemServices       *m_pNs;
    IWbemObjectSink     *m_pSink;
    IWbemClassObject    *m_pEventClassDef;
    int                 m_eStatus;
    HANDLE              m_hThread;
            
    static DWORD WINAPI EventThread(LPVOID pArg);
    void InstanceThread();

public:
    enum { Pending, Running, PendingStop, Stopped };

    CMyEventProvider();
   ~CMyEventProvider();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // Inherited from IWbemEventProvider
    // =================================

    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags
            );

    // Inherited from IWbemProviderInit
    // ================================

    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\refreshevent\test\oahelp.inl ===
// **************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  OAHELP.INL
//
// Description:
//        OLE Automation Helpers for client code
//
// History:
//
// **************************************************************************

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\create.cpp ===
//*************************************************************
//
//  Create namespace classes
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    9-Sep-99   SitaramR    Created
//
//*************************************************************

#include <windows.h>
#include <wchar.h>
#include <ole2.h>
#include <initguid.h>
#include <wbemcli.h>

#define SECURITY_WIN32
#include <security.h>
#include <aclapi.h>
#include <seopaque.h>
#include <ntdsapi.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <lm.h>

#include "smartptr.h"
#include "RsopInc.h"
#include "rsopsec.h"
#include "rsoputil.h"
#include "rsopdbg.h"
#include "stdio.h"
#include "wbemtime.h"

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


BOOL PrintToString( XPtrST<WCHAR>& xwszValue, WCHAR *pwszString,
                    WCHAR *pwszParam1, WCHAR *pwszParam2,
                    DWORD dwParam3 );

//
// b7b1b3dd-ab09-4242-9e30-9980e5d322f7
//
const GUID guidProperty = {0xb7b1b3dd, 0xab09, 0x4242, 0x9e, 0x30, 0x99, 0x80, 0xe5, 0xd3, 0x22, 0xf7};

DWORD
RSoPBuildPrivileges( PSECURITY_DESCRIPTOR pSD, PSECURITY_DESCRIPTOR pAbsoluteSD, LPWSTR*, DWORD );

LPWSTR
GetDomainName();

DWORD
MakeUserName( LPWSTR szDomain, LPWSTR szUser, LPWSTR* pszUserName );

//*************************************************************
//
//  CreateNameSpace
//
//  Purpose:  Creates a new namespace
//
//  Parameters: pwszNameSpace - Namespace to create
//              pwszParentNS  - Parent namespace in which to create pwszNameSpace
//
//              pWbemLocator  - Wbem locator
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT
CreateNameSpace( WCHAR *pwszNameSpace, WCHAR *pwszParentNS, IWbemLocator *pWbemLocator )
{
    IWbemClassObject *pNSClass = NULL;
    IWbemClassObject *pNSInstance = NULL;
    IWbemServices *pWbemServices = NULL;

    XBStr xParentNameSpace( pwszParentNS );
    if ( !xParentNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("LogRegistryRsopData: Unable to allocate memory" ));
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pWbemLocator->ConnectServer( xParentNameSpace,
                                              NULL,
                                              NULL,
                                              0L,
                                              0L,
                                              NULL,
                                              NULL,
                                              &pWbemServices );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::ConnectServer failed with 0x%x" ), hr );
        return hr;
    }

    XInterface<IWbemServices> xWbemServices( pWbemServices );

    XBStr xbstrNS( L"__Namespace" );
    if ( !xbstrNS )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::Failed to allocated memory" ));
        return E_OUTOFMEMORY;
    }

    hr = pWbemServices->GetObject( xbstrNS,
                                   0, NULL, &pNSClass, NULL );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::GetObject failed with 0x%x" ), hr );
        return hr;
    }

    XInterface<IWbemClassObject> xNSClass( pNSClass );

    hr = pNSClass->SpawnInstance( 0, &pNSInstance );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace: SpawnInstance failed with 0x%x" ), hr );
        return hr;
    }

    XInterface<IWbemClassObject> xNSInstance( pNSInstance );

    XBStr xbstrName( L"Name" );
    if ( !xbstrName )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::Failed to allocated memory" ));
        return E_OUTOFMEMORY;
    }

    XBStr xbstrNameSpace( pwszNameSpace );
    if ( !xbstrNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace::Failed to allocated memory" ));
        return E_OUTOFMEMORY;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = xbstrNameSpace;

    hr = pNSInstance->Put( xbstrName, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace: Put failed with 0x%x" ), hr );
        return hr;
    }

    hr = pWbemServices->PutInstance( pNSInstance, WBEM_FLAG_CREATE_ONLY, NULL, NULL );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateNameSpace: PutInstance failed with 0x%x" ), hr );
        return hr;
    }

    return hr;
}


//*************************************************************
//
//  Function:   SetupCreationTimeAndCommit
//
//  Purpose:    Connects to a namespace where it expects to
//              find class RSOP_Session as defined in rsop.mof.
//              It then instantiates the class and sets the
//              data member 'creationTime' to the current
//              date and time.
//
//  Parameters: pWbemLocator -  Pointer to IWbemLocator used to
//                              connect to the namespace.
//              wszNamespace -  Name of the Namespace to connect.
//
//  Returns:    On success, it returns S_OK.
//              On failure, it returns an HRESULT error code.
//
//  History:    12/07/99 - LeonardM - Created.
//
//*************************************************************
HRESULT SetupCreationTimeAndCommit(IWbemLocator* pWbemLocator, LPWSTR wszNamespace)
{
    //
    // Check arguments
    //

    if(!pWbemLocator || !wszNamespace || (wcscmp(wszNamespace, L"") == 0))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function called with invalid argument(s)."));
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // Connect to the namespace
    //

    XBStr xbstrNamespace = wszNamespace;
    if(!xbstrNamespace)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    XInterface<IWbemServices>xpNamespace;
    HRESULT hr = pWbemLocator->ConnectServer(   xbstrNamespace,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL,
                                                &xpNamespace);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: ConnectServer failed. hr=0x%08X"), hr);
        return hr;
    }


    VARIANT var;
    VariantInit(&var);

    //
    // Get class RSOP_Session
    //

    XBStr xbstrClassName = L"RSOP_Session";
    if (!xbstrClassName)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    XInterface<IWbemClassObject>xpClass;
    hr = xpNamespace->GetObject(xbstrClassName, 0, NULL, &xpClass, NULL);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: GetObject failed. hr=0x%08X"), hr);
        return hr;
    }

    //
    // Spawn an instance of class RSOP_Session
    //

    XBStr xbstrInstancePath = L"RSOP_Session.id=\"Session1\"";
    if(!xbstrInstancePath)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory."));
        return FALSE;
    }


    XInterface<IWbemClassObject>xpInstance;

    hr = xpNamespace->GetObject(xbstrInstancePath, 0, NULL, &xpInstance, NULL);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("SetupCreationTimeAndCommit: GetObject failed. trying to spawn instance. hr=0x%08X"), hr);
        hr = xpClass->SpawnInstance(0, &xpInstance);
    }

    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: SpawnInstance failed. hr=0x%08X"), hr);
        return hr;
    }

    //
    // Set the 'id' data member of class RSOP_Session
    //

    XBStr xbstrPropertyName;
    XBStr xbstrPropertyValue;

    xbstrPropertyName = L"id";
    if(!xbstrPropertyName)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    xbstrPropertyValue = L"Session1";
    if(!xbstrPropertyValue)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xbstrPropertyValue;

    hr = xpInstance->Put(xbstrPropertyName, 0, &var, 0);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Put failed. hr=0x%08X"), hr);
        return hr;
    }

    //
    // Set the 'creationTime' data member of class RSOP_Session
    //

    xbstrPropertyName = L"creationTime";
    if(!xbstrPropertyName)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    hr = GetCurrentWbemTime(xbstrPropertyValue);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: GetCurrentWbemTime. hr=0x%08X"), hr);
        return hr;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xbstrPropertyValue;

    hr = xpInstance->Put(xbstrPropertyName, 0, &var, 0);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Put failed. hr=0x%08X"), hr);
        return hr;
    }

    //
    // Set the 'ttlMinutes' data member of class RSOP_Session
    //

    xbstrPropertyName = L"ttlMinutes";
    if(!xbstrPropertyName)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    var.vt = VT_I4;
    var.lVal = DEFAULT_NAMESPACE_TTL_MINUTES;

    hr = xpInstance->Put(xbstrPropertyName, 0, &var, 0);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: Put failed. hr=0x%08X"), hr);
        return hr;
    }

    // if any more data integrity checks needs to be done
    // it can be done at this point

    
    //
    // Put instance of class RSOP_Session
    //

    hr = xpNamespace->PutInstance(xpInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupCreationTimeAndCommit: PutInstance failed. hr=0x%08X"), hr);
        return hr;
    }

    return S_OK;
}


//*************************************************************
//
//  SetupNameSpaceSecurity
//
//  Purpose:  Sets namespace security.
//
//  Parameters: szNamespace  - New namespace returned here
//              pSD - source security descriptor
//              pWbemLocator   - Wbem locator
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT
SetNameSpaceSecurity(   LPCWSTR szNamespace, 
                        PSECURITY_DESCRIPTOR pSD,
                        IWbemLocator* pWbemLocator)
{
    XBStr xNameSpace( (LPWSTR) szNamespace );
    if ( !xNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNameSpaceSecurity: Unable to allocate memory" ));
        return E_FAIL;
    }

    XInterface<IWbemServices> xptrServices;

    HRESULT hr = pWbemLocator->ConnectServer( xNameSpace,
                                              0,
                                              0,
                                              0L,
                                              0L,
                                              0,
                                              0,
                                              &xptrServices );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNameSpaceSecurity::ConnectServer failed with 0x%x" ), hr );
        return hr;
    }

    return SetNamespaceSD( (SECURITY_DESCRIPTOR*)pSD, xptrServices);
}

//*************************************************************
//
//  GetNameSpaceSecurity
//
//  Purpose:  Sets namespace security.
//
//  Parameters: szNamespace  - New namespace returned here
//              pSD - source security descriptor
//              pWbemLocator   - Wbem locator
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT
GetNameSpaceSecurity(   LPCWSTR szNamespace, 
                        PSECURITY_DESCRIPTOR *ppSD,
                        IWbemLocator* pWbemLocator)
{
    XBStr xNameSpace( (LPWSTR) szNamespace );
    if ( !xNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetNameSpaceSecurity: Unable to allocate memory" ));
        return E_FAIL;
    }

    XInterface<IWbemServices> xptrServices;

    HRESULT hr = pWbemLocator->ConnectServer( xNameSpace,
                                              0,
                                              0,
                                              0L,
                                              0L,
                                              0,
                                              0,
                                              &xptrServices );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetNameSpaceSecurity::ConnectServer failed with 0x%x" ), hr );
        return hr;
    }

    return GetNamespaceSD(xptrServices, (SECURITY_DESCRIPTOR **)ppSD);
}


//*************************************************************
//
//  CopyNameSpaceSecurity
//
//  Purpose:  Copies namespace security.
//
//  Parameters: pwszSrcNameSpace  - Source namespace
//              pwszDstNameSpace  - Dest   namespace
//              pWbemLocator      - Wbem locator
//
//  Returns:    HRESULT
//
//*************************************************************

HRESULT CopyNameSpaceSecurity(LPWSTR pwszSrcNameSpace, LPWSTR pwszDstNameSpace, IWbemLocator *pWbemLocator )
{
    XHandle xhThreadToken;


    //
    // There is a bug in WMI which destroys the current thread token
    // if connectserver is called to the local machine with impersonation.
    // The following SetThreadToken needs to be removed once WMI bug 454721 is fixed.
    //

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ,
                          TRUE, &xhThreadToken)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: Openthreadtoken failed with error %d."), GetLastError());
    }


    // internal function. arg checks not needed

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CopyNameSpaceSecurity: Copying Sec Desc from <%s> -> <%s>."),
                                    pwszSrcNameSpace, pwszDstNameSpace );


    //
    // Copy to a BStr
    //

    XBStr xSrcNameSpace(pwszSrcNameSpace);

    if (!xSrcNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }

    XBStr xDstNameSpace(pwszDstNameSpace);

    if (!xDstNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: Function failed to allocate memory."));
        return E_OUTOFMEMORY;
    }


    //
    // Get the Source WBem Service
    //

    XInterface<IWbemServices> xpSrcSvc;

    HRESULT hr = pWbemLocator->ConnectServer(   xSrcNameSpace,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL,
                                                &xpSrcSvc);


    SetThreadToken(NULL, xhThreadToken);


    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: ConnectServer failed for src. hr=0x%08X"), hr);
        return hr;
    }


    //
    // Self relative SD on the Source Name Space
    //

    XPtrLF<SECURITY_DESCRIPTOR> xpSelfRelativeSD;

    hr = GetNamespaceSD(xpSrcSvc, &xpSelfRelativeSD);

    SetThreadToken(NULL, xhThreadToken);

    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: GetNameSpaceSD failed for src. hr=0x%08X"), hr);
        return hr;
    }



    //
    // Get the Dest WBem Service
    //

    XInterface<IWbemServices> xpDstSvc;

    hr = pWbemLocator->ConnectServer(           xDstNameSpace,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL,
                                                &xpDstSvc);


    SetThreadToken(NULL, xhThreadToken);


    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNameSpaceSecurity: ConnectServer failed for Dst. hr=0x%08X"), hr);
        return hr;
    }


    //
    // Set the SD already got on the Destination
    //

    hr = SetNamespaceSD( xpSelfRelativeSD, xpDstSvc);

    SetThreadToken(NULL, xhThreadToken);


    if(FAILED(hr))
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CopyNameSpaceSecurity: SetNamespaceSD failed on Dst, 0x%08X", hr );
        return hr;
    }


    // All Done
    return S_OK;
}


//*************************************************************
//
//  ProviderDeleteRsopNameSpace
//
//  Purpose:    WMI doesn't provide a mechanism to allow a user to delete a namespace
//              unless it has write permissions on the parent
//
//  Parameters: pwszNameSpace       - Namespace to be deleted
//              hToken              - Token of the calling user.
//              szSidString         - String form of the calling user's sid.
//              dwFlags             - Flag to indicate planning mode or diagnostic mode
//
//  Returns:    S_OK if successful, HRESULT o/w
//
//*************************************************************

HRESULT ProviderDeleteRsopNameSpace( IWbemLocator *pWbemLocator, LPWSTR szNameSpace, HANDLE hToken, LPWSTR szSidString, DWORD dwFlags)
{

    BOOL bDelete = FALSE;
    BOOL bFound = FALSE;
    HRESULT hr = S_OK;
    LPWSTR  pStr = szNameSpace;

    //
    // Make sure that the namespace is under root\rsop
    //

    for ( ;*pStr; pStr++) {
        if (_wcsnicmp(pStr, RSOP_NS_ROOT_CHK, wcslen(RSOP_NS_ROOT_CHK)) == 0) {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"ProviderDeleteRsopNameSpace: namespace is not under root\\rsop" );
        return E_INVALIDARG;
    }


    if ( dwFlags & SETUP_NS_SM && IsInteractiveNameSpace(szNameSpace, szSidString)) {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"ProviderDeleteRsopNameSpace: interactive namespace for the user." );
        bDelete = TRUE;
    }
    else {
        //
        // if it is not interactive namespace check access
        //

        XPtrLF<SECURITY_DESCRIPTOR> xsd;

        hr = GetNameSpaceSecurity(szNameSpace, (PSECURITY_DESCRIPTOR *)&xsd, pWbemLocator);

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"ProviderDeleteRsopNameSpace: GetNameSpaceSecurity failed with error 0x%x", hr );
            return hr;
        }


        GENERIC_MAPPING map;
        PRIVILEGE_SET ps[3];
        DWORD dwSize = 3 * sizeof(PRIVILEGE_SET);
        BOOL bResult;
        DWORD dwGranted = 0;
    
        map.GenericRead    = WMI_GENERIC_READ;
        map.GenericWrite   = WMI_GENERIC_WRITE;
        map.GenericExecute = WMI_GENERIC_EXECUTE;
        map.GenericAll     = WMI_GENERIC_ALL;
        

        if (!AccessCheck(xsd, hToken, RSOP_ALL_PERMS, &map, ps, &dwSize, &dwGranted, &bResult)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"ProviderDeleteRsopNameSpace: AccessCheck failed with error 0x%x", hr );
            return hr;
        }
    

        if(bResult && dwGranted) {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"ProviderDeleteRsopNameSpace: User has full rights on the child namespace");
            bDelete = TRUE;
        }
        else {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"ProviderDeleteRsopNameSpace: This user is not granted access on the namespace", hr );

        }
    }

    if (bDelete) {
        hr = DeleteRsopNameSpace(szNameSpace, pWbemLocator);
    }
    else {
        hr = WBEM_E_ACCESS_DENIED;
    }

    return hr;
}


//*************************************************************
//
//  SetupNewNameSpace
//
//  Purpose:    Creates a new temp namespace and two child namespaces, User and Computer.
//              It also copies all the class definitions
//              Additionally, it calls SetupCreationTimeAndCommit
//              which in turn instantiates RSOP_Session and updates the
//              data member 'creationTime' with the current time.
//
//  Parameters: pwszNameSpace       - New namespace returned here (This is allocated here)
//              szRemoteComputer    - Remote Computer under which this name space has to be
//                                    created.
//              szUserSid           - UserSid. Only relevant in Diagnostic mode
//              pSid                - Sid of the calling User
//              pWbemLocator        - Wbem locator
//              dwFlags             - Flag to indicate planning mode or diagnostic mode
//              dwExtendedInfo      - The extended info to modify appropriately
//
//  Returns:    True if successful, false otherwise
//
//
// Usage:
//      In Diagnostic mode, we copy instances. In planning mode we just copy Classes
//*************************************************************

HRESULT SetupNewNameSpace( 
                        LPWSTR       *pwszOutNameSpace,
                        LPWSTR        szRemoteComputer,
                        LPWSTR        szUserSid,
                        PSID          pSid,
                        IWbemLocator *pWbemLocator,
                        DWORD         dwFlags,
                        DWORD        *pdwExtendedInfo)
{
    GUID          guid;
    XPtrLF<WCHAR> xwszRelNameSpace;
    XPtrLF<WCHAR> xwszRootNameSpace;
    XPtrLF<WCHAR> xwszSrcNameSpace;
    DWORD         dwSrcNSLen;
    XPtrLF<WCHAR> xwszNameSpace;
    LPWSTR        szComputerLocal;
    HRESULT       hr = S_OK, hrUser = S_OK, hrMachine = S_OK;

    if ((dwFlags & SETUP_NS_SM_INTERACTIVE) || 
        (dwFlags & SETUP_NS_SM_NO_USER) ||  
        (dwFlags & SETUP_NS_SM_NO_COMPUTER)) {

        if (!(dwFlags & SETUP_NS_SM)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::invalid flag parameters"));
            return E_INVALIDARG;
        }
    }


    
    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    SECURITY_ATTRIBUTES sa;
    CSecDesc Csd;

    *pwszOutNameSpace = NULL;
    
    Csd.AddLocalSystem(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddAdministrators(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);

    if (dwFlags & SETUP_NS_SM_INTERACTIVE) {
        Csd.AddSid(pSid, RSOP_READ_PERMS, CONTAINER_INHERIT_ACE);
    }
    else {
        Csd.AddSid(pSid, RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    }


    Csd.AddAdministratorsAsOwner();
    Csd.AddAdministratorsAsGroup();


    xsd = Csd.MakeSelfRelativeSD();
    if (!xsd) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::Makeselfrelativesd failed with %d"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // ignore inheritted perms..
    //

    if (!SetSecurityDescriptorControl( (SECURITY_DESCRIPTOR *)xsd, SE_DACL_PROTECTED, SE_DACL_PROTECTED )) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::SetSecurityDescriptorControl failed with %d"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Initialise the out params
    //

    if ((dwFlags & SETUP_NS_SM) && (!szUserSid))
        return E_INVALIDARG;


    //
    // Calculate the length required for the name spaces
    //

    DWORD dwLenNS=RSOP_NS_TEMP_LEN;

    if ((szRemoteComputer) && (*szRemoteComputer)) {
        dwLenNS += lstrlen(szRemoteComputer);
        szComputerLocal = szRemoteComputer;
    }
    else {
        szComputerLocal = L".";
    }


    xwszRelNameSpace = (LPWSTR)LocalAlloc(LPTR,  (1+MAX(RSOP_NS_TEMP_LEN, lstrlen(szUserSid)))*sizeof(WCHAR));

    if (!xwszRelNameSpace) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::AllocMem failed with 0x%x"), hr );
        return hr;
    }

    //
    // guid for the Name Space
    //

    hr = CoCreateGuid( &guid );
    if ( FAILED(hr) ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CoCreateGuid failed with 0x%x"), hr );
        return hr;
    }


    //
    // Allocate the memory and initialise
    //

    xwszRootNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(lstrlen(szComputerLocal)+RSOP_NS_ROOT_LEN));
    if (!xwszRootNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::Not enough Space. Error - 0x%x"), GetLastError() );
        return HRESULT_FROM_WIN32(GetLastError());
    }        

    // allocating max needed        

    dwSrcNSLen = (RSOP_NS_ROOT_LEN+lstrlen(szUserSid)+RSOP_NS_MAX_OFFSET_LEN+10);

    if (dwFlags & SETUP_NS_SM)
        dwSrcNSLen += lstrlen(szUserSid);

    xwszSrcNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR)*dwSrcNSLen);

    if (!xwszSrcNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::Not enough Space. Error - 0x%x"), GetLastError() );
        return HRESULT_FROM_WIN32(GetLastError());
    }        
    


    swprintf(xwszRootNameSpace, RSOP_NS_REMOTE_ROOT_FMT, szComputerLocal);
    wcscpy(xwszSrcNameSpace, RSOP_NS_DIAG_ROOT);
    LPTSTR lpEnd = xwszSrcNameSpace+lstrlen(xwszSrcNameSpace);

    //
    // Create a new Name Space under the root
    //

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("SetupNewNameSpace: Creating new NameSpace <%s>"), xwszRootNameSpace);

    if (dwFlags & SETUP_NS_SM_INTERACTIVE) {

        XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szUserSid)+1));
        if (!xszWmiName) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace couldn't allocate memory with error %d"), GetLastError() );
            return FALSE;
        }

        ConvertSidToWMIName(szUserSid, xszWmiName);

        swprintf( xwszRelNameSpace,
                  L"%s%s",
                  RSOP_NS_TEMP_PREFIX,
                  xszWmiName);
    }
    else {
        swprintf( xwszRelNameSpace,
                  L"%s%08lX_%04X_%04X_%02X%02X_%02X%02X%02X%02X%02X%02X",
                  RSOP_NS_TEMP_PREFIX,
                  guid.Data1,
                  guid.Data2,
                  guid.Data3,
                  guid.Data4[0], guid.Data4[1],
                  guid.Data4[2], guid.Data4[3],
                  guid.Data4[4], guid.Data4[5],
                  guid.Data4[6], guid.Data4[7] );
    }


    hr = CreateAndCopyNameSpace(pWbemLocator, xwszSrcNameSpace, xwszRootNameSpace, 
                            xwszRelNameSpace, 0, xsd, &xwszNameSpace);
              
    if ( FAILED(hr) ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace failed with 0x%x"), hr );
        return hr;
    }


    //
    // if it has come till here, the assumption is that we
    // could create the namespace in the context that we are running in
    //
    // In diagnostic interactive mode we have already made sure that the sid is the 
    // same as the user.
    //

    if (pdwExtendedInfo) {
        *pdwExtendedInfo &= ~RSOP_USER_ACCESS_DENIED;
        *pdwExtendedInfo &= ~RSOP_COMPUTER_ACCESS_DENIED;

    }

    wcscat(lpEnd, L"\\"); lpEnd++;

    DWORD dwCopyFlags = 0;
    
    if (dwFlags & SETUP_NS_PM) {

        //
        // if it is planning mode, copy classes from RSOP_NS_USER
        //

        wcscpy(lpEnd, RSOP_NS_USER_OFFSET);
        dwCopyFlags = NEW_NS_FLAGS_COPY_CLASSES;
    }
    else {

        if (dwFlags & SETUP_NS_SM_NO_USER) {

            //
            // If no user copy classes from root\rsop\user itself
            //

            wcscpy(lpEnd, RSOP_NS_SM_USER_OFFSET);
            dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES;
        }
        else {
            
            //
            // if it is diagnostic mode, copy classes and instances from RSOP_NS_USER_SId
            //

            XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szUserSid)+1));
            if (!xszWmiName) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace couldn't allocate memory with error %d"), GetLastError() );
                return FALSE;
            }

            ConvertSidToWMIName(szUserSid, xszWmiName);

            swprintf(lpEnd, RSOP_NS_DIAG_USER_OFFSET_FMT, xszWmiName);

            dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES | NEW_NS_FLAGS_COPY_INSTS;
        }
    }
    

    hrUser = CreateAndCopyNameSpace(pWbemLocator, xwszSrcNameSpace, xwszNameSpace, 
                            RSOP_NS_SM_USER_OFFSET, dwCopyFlags, 
                            xsd, NULL);
              
    if ( FAILED(hrUser) ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace failed with 0x%x"), hrUser );
    }


    //
    // for machine only the flags are different. source namespaces are the same
    //
    
    if (dwFlags & SETUP_NS_PM) {
        dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES;
    }
    else {
        if (dwFlags & SETUP_NS_SM_NO_COMPUTER) 
            dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES;
        else
            dwCopyFlags =  NEW_NS_FLAGS_COPY_CLASSES | NEW_NS_FLAGS_COPY_INSTS;
    }


    wcscpy(lpEnd, RSOP_NS_MACHINE_OFFSET);
    
    hrMachine = CreateAndCopyNameSpace(pWbemLocator, xwszSrcNameSpace, xwszNameSpace,
                            RSOP_NS_DIAG_MACHINE_OFFSET, dwCopyFlags, 
                            xsd, NULL);
              
    if ( FAILED(hrMachine) ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::CreateNameSpace failed with 0x%x"), hrMachine );
    }


    if (FAILED(hrUser)) {
        if (pdwExtendedInfo) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::User part of rsop failed with 0x%x"), hrUser );
            *pdwExtendedInfo |= RSOP_USER_ACCESS_DENIED;
        }
    }

    if (FAILED(hrMachine)) {
        if (pdwExtendedInfo) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::computer part of rsop failed with 0x%x"), hrMachine );
            *pdwExtendedInfo |= RSOP_COMPUTER_ACCESS_DENIED;
        }
    }

    if (FAILED(hrUser)) {
        return hrUser;
    }

    if (FAILED(hrMachine)) {
        return hrMachine;
    }


    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("SetupNewNameSpace: Returning Successfully"));


    //
    // Now handover the ownership to the caller.
    //

    *pwszOutNameSpace = xwszNameSpace.Acquire();

    return S_OK;
}


//*************************************************************
// ConvertSidToWMIName
//
// WMI doesn't like '-' in names. Connverting - to '_' blindly
//*************************************************************

void ConvertSidToWMIName(LPTSTR lpSid, LPTSTR lpWmiName)
{
    for (;(*lpSid); lpSid++, lpWmiName++) {
        if (*lpSid == L'-')
            *lpWmiName = L'_';
        else
            *lpWmiName = *lpSid;
    }

    *lpWmiName = L'\0';
}


//*************************************************************
// ConvertWMINameToSid
//
// WMI doesn't like '-' in names. 
//*************************************************************

void ConvertWMINameToSid(LPTSTR lpWmiName, LPTSTR lpSid )
{
    for (;(*lpWmiName); lpSid++, lpWmiName++) {
        if (*lpWmiName == L'_')
            *lpSid = L'-';
        else
            *lpSid = *lpWmiName;
    }

    *lpSid = L'\0';
}



//*************************************************************
//
//  DeleteNameSpace
//
//  Purpose:  Deletes namespace
//
//  Parameters: pwszNameSpace - Namespace to delete
//              pWbemLocator  - Wbem locator pointer
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT
DeleteNameSpace( WCHAR *pwszNameSpace, WCHAR *pwszParentNameSpace, IWbemLocator *pWbemLocator )
{
    XBStr xParentNameSpace( pwszParentNameSpace );
    if ( !xParentNameSpace )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("DeleteNameSpace: Unable to allocate memory" ));
        return E_OUTOFMEMORY;
    }

    IWbemServices *pWbemServices = NULL;
    HRESULT hr = pWbemLocator->ConnectServer( xParentNameSpace,
                                              NULL,
                                              NULL,
                                              0L,
                                              0L,
                                              NULL,
                                              NULL,
                                              &pWbemServices );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("DeleteNameSpace::ConnectServer failed with 0x%x" ), hr );
        return hr;
    }

    XInterface<IWbemServices> xWbemServices( pWbemServices );

    WCHAR wszNSRef[] = L"__Namespace.name=\"%ws\"";
    XPtrST<WCHAR> xwszNSValue;

    if ( !PrintToString( xwszNSValue, wszNSRef, pwszNameSpace, 0, 0 ) )
    {
        return E_OUTOFMEMORY;
    }

    XBStr xbstrNSValue( xwszNSValue );
    if ( !xbstrNSValue )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("DeleteNameSpace: Failed to allocate memory" ));
        return E_OUTOFMEMORY;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = xbstrNSValue;

    hr = pWbemServices->DeleteInstance( var.bstrVal,
                                        0L,
                                        NULL,
                                        NULL );

    if ( FAILED(hr) )
    {
         dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("DeleteNameSpace: Failed to DeleteInstance with 0x%x"), hr );
        return hr;
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("DeleteNameSpace: Deleted namespace %s under %s" ), pwszNameSpace, pwszParentNameSpace);
    return hr;
}

//*************************************************************
//
//  DeleteRsopNameSpace
//
//  Purpose:  Deletes namespace
//
//  Parameters: pwszNameSpace - Namespace to delete (the full path)
//              pWbemLocator  - Wbem locator pointer
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT DeleteRsopNameSpace( WCHAR *pwszNameSpace, IWbemLocator *pWbemLocator )
{
    LPWSTR pwszChildName = NULL;
    HRESULT hr = S_OK;

    //
    // Generating the parent child name by traversing the name
    //
     
    pwszChildName = wcsrchr(pwszNameSpace, L'\\');

    if (!pwszChildName) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("DeleteRsopNameSpace: Invalid format - %s" ), pwszNameSpace);
        return E_INVALIDARG;
    }


    WCHAR wTmp = *pwszChildName;
    *pwszChildName = L'\0';
    pwszChildName++;

    hr = DeleteNameSpace(pwszChildName, pwszNameSpace, pWbemLocator);

    *(pwszChildName-1) = wTmp;
    return hr;
}

//*************************************************************
//
//  IsInteractiveNameSpace
//
//  Purpose:  returns whether a namespace is a special namespace
//            specifically created to allow interactive users to get rsop
//            data
//
//  Parameters: pwszNameSpace - Namespace 
//              szSid         - Sid of the user
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

BOOL IsInteractiveNameSpace(WCHAR *pwszNameSpace, WCHAR *szSid)
{
    LPWSTR          pwszChildName = NULL;
    HRESULT         hr = S_OK;
    XPtrLF<WCHAR>   xwszInteractiveNameSpace;
    BOOL            bInteractive = FALSE;

    xwszInteractiveNameSpace = (LPWSTR)LocalAlloc(LPTR, (5+wcslen(RSOP_NS_TEMP_PREFIX) + wcslen(szSid))*sizeof(WCHAR));

    if (!xwszInteractiveNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("IsInteractiveNameSpace: Couldn't Allocate memory. Error - %d" ), GetLastError());
        return bInteractive;
    }
    
    //
    // Generating the parent child name by traversing the name
    //
     
    pwszChildName = wcsrchr(pwszNameSpace, L'\\');

    if (!pwszChildName) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("IsInteractiveNameSpace: Invalid format - %s" ), pwszNameSpace);
        return bInteractive;
    }

    pwszChildName++;

    XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szSid)+1));
    if (!xszWmiName) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("IsInteractiveNameSpace::CreateNameSpace couldn't allocate memory with error %d"), GetLastError() );
        return bInteractive;
    }

    ConvertSidToWMIName(szSid, xszWmiName);

    swprintf( xwszInteractiveNameSpace,
              L"%s%s",
              RSOP_NS_TEMP_PREFIX,
              xszWmiName);

    if (_wcsicmp(pwszChildName, xwszInteractiveNameSpace) == 0) {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("IsInteractiveNameSpace:: Interactive namespace"));
        bInteractive = TRUE;
    }

    return bInteractive;
}


//*************************************************************
//
//  GetInteractiveNameSpace
//
//  Purpose:  returns whether a namespace is a special namespace
//            specifically created to allow interactive users to get rsop
//            data
//
//  Parameters: pwszNameSpace - Namespace 
//              szSid         - Sid of the user
//
//  Returns:    True if successful, false otherwise
//
//*************************************************************

HRESULT GetInteractiveNameSpace(WCHAR *szSid, LPWSTR *szNameSpace)
{
    XPtrLF<WCHAR>   xwszInteractiveNameSpace;

    *szNameSpace = NULL;

    xwszInteractiveNameSpace = (LPWSTR)LocalAlloc(LPTR, (5+wcslen(RSOP_NS_TEMP_FMT) + wcslen(szSid))*sizeof(WCHAR));

    if (!xwszInteractiveNameSpace) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetInteractiveNameSpace: Couldn't Allocate memory. Error - %d" ), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    
    XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szSid)+1));
    if (!xszWmiName) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetInteractiveNameSpace::Couldn't allocate memory with error %d"), GetLastError() );
        return HRESULT_FROM_WIN32(GetLastError());
    }

    ConvertSidToWMIName(szSid, xszWmiName);

    swprintf( xwszInteractiveNameSpace,
              RSOP_NS_TEMP_FMT,
              xszWmiName);


    *szNameSpace = xwszInteractiveNameSpace.Acquire();

    return S_OK;
}

//*************************************************************
//
//  PrintToString
//
//  Purpose:    Safe swprintf routine
//
//  Parameters: xwszValue  - String returned here
//              wszString  - Format string
//              pwszParam1 - Param 1
//              pwszParam2 - Param 2
//              dwParam3   - Param 3
//
//*************************************************************

BOOL PrintToString( XPtrST<WCHAR>& xwszValue, WCHAR *pwszString,
                    WCHAR *pwszParam1, WCHAR *pwszParam2,
                    DWORD dwParam3 )
{
    DWORD dwSize = wcslen(pwszString)+32;

    if ( pwszParam1 )
    {
        dwSize += wcslen( pwszParam1 );
    }
    if ( pwszParam2 )
    {
        dwSize += wcslen( pwszParam2 );
    }

    xwszValue = new WCHAR[dwSize];
    if ( !xwszValue ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("PrintToString: Failed to allocate memory" ));
        return FALSE;
    }

    while ( _snwprintf( xwszValue, dwSize, pwszString,
                        pwszParam1, pwszParam2, dwParam3 ) <= 0 ) {

        dwSize *= 2;
        xwszValue = new WCHAR[dwSize];
        if ( !xwszValue ) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("PrintToString: Failed to allocate memory" ));
            return FALSE;
        }

    }

    return TRUE;
}



//*************************************************************
//
//  CreateAndCopyNameSpace
//
//  Purpose:  Creates and Copies the name space
//            This does an exact replica of the Src Name Space including
//            copying the security Descriptors from the Source
//
//  Parameters:
//
//  Returns:    domain name if successful, 0 otherwise
//
//*************************************************************

HRESULT
CreateAndCopyNameSpace(IWbemLocator *pWbemLocator, LPWSTR szSrcNameSpace, LPWSTR szDstRootNameSpace, 
                            LPWSTR szDstRelNameSpace, DWORD dwFlags, PSECURITY_DESCRIPTOR pSecDesc, LPWSTR *szDstNameSpaceOut)
{

    BOOL            bOk = TRUE, bAbort = FALSE;
    BOOL            bCopyClasses   = (dwFlags & NEW_NS_FLAGS_COPY_CLASSES) ? TRUE : FALSE;
    BOOL            bCopyInstances = (dwFlags & NEW_NS_FLAGS_COPY_INSTS)   ? TRUE : FALSE;
    XPtrLF<WCHAR>   xszDstNameSpace;
    HRESULT         hr = S_OK;
    
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CreateAndCopyNameSpace: New Name space from %s -> %s,%s, flags 0x%x "), 
                                    szSrcNameSpace, szDstRootNameSpace, szDstRelNameSpace, dwFlags);
    
    if (szDstNameSpaceOut)
    {
        *szDstNameSpaceOut = 0;
    }
    
    xszDstNameSpace = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(lstrlen(szDstRootNameSpace)+lstrlen(szDstRelNameSpace)+5));
    if (!xszDstNameSpace)
    {
        return E_OUTOFMEMORY;      
    }

    lstrcpy(xszDstNameSpace, szDstRootNameSpace);
    lstrcat(xszDstNameSpace, L"\\");
    lstrcat(xszDstNameSpace, szDstRelNameSpace);
    
    hr = CreateNameSpace( szDstRelNameSpace, szDstRootNameSpace, pWbemLocator );
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateAndCopyNameSpace::CreateNameSpace failed with 0x%x"), hr );
        return hr;
    }

    if (!pSecDesc)
    {
        hr = CopyNameSpaceSecurity(szSrcNameSpace, xszDstNameSpace, pWbemLocator );

        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateAndCopyNameSpace::CopyNameSpaceSecurity failed with 0x%x"), hr );
            goto Exit;
        }
    }
    else 
    {
        hr = SetNameSpaceSecurity( xszDstNameSpace, pSecDesc, pWbemLocator);

        if ( FAILED(hr) ) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("SetupNewNameSpace::SetNameSpaceSecurity failed with 0x%x"), hr );
            goto Exit;
        }
    }
    

    

    if (bCopyClasses) {
    
        hr = CopyNameSpace( szSrcNameSpace, xszDstNameSpace, bCopyInstances, &bAbort, pWbemLocator );
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateAndCopyNameSpace::CopyNameSpace failed with 0x%x"), hr );
            goto Exit;
        }


        //
        // Instantiate class RSOP_Session and set data member
        // 'creationTime' with current date and time.
        //

        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CreateAndCopyNameSpace: Setting up creation time"));

        hr = SetupCreationTimeAndCommit(pWbemLocator, xszDstNameSpace);
        if(FAILED(hr))
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CreateAndCopyNameSpace: SetupCreationTimeAndCommit failed with 0x%x"), hr );
            goto Exit;
        }
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CreateAndCopyNameSpace: Returning with Success NameSpace %s "), 
                                    xszDstNameSpace);
    
    if (szDstNameSpaceOut)
    {
        *szDstNameSpaceOut = xszDstNameSpace.Acquire();    
    }

    return hr;    

Exit:
    DeleteNameSpace(szDstRelNameSpace, szDstRootNameSpace, pWbemLocator);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\gpfilter.cpp ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//  GPO WQL filter class
//
//  History:    10-Mar-00   SitaramR    Created
//
//*************************************************************

#include "windows.h"
#include "ole2.h"
#include "gpfilter.h"
#include "rsopdbg.h"

CDebug dbgFilt(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"UserEnvDebugLevel",
                 L"userenv.log",
                 L"userenv.bak",
                 FALSE );

//*************************************************************
//
//  CGpoFilter::~CGpoFilter
//
//  Purpose:    Destructor
//
//*************************************************************

CGpoFilter::~CGpoFilter()
{
    GPFILTER *pFilterTemp;

    while ( m_pFilterList ) {
        pFilterTemp = m_pFilterList->pNext;
        FreeGpFilter( m_pFilterList );
        m_pFilterList = pFilterTemp;
    }
}



//*************************************************************
//
//  CGpoFilter::Add
//
//  Purpose:    Adds the list of planning mode filters
//              whose filter access check succeeds
//
//  Parameters: pVar - Pointer to variant of safearray of filters
//
//*************************************************************

HRESULT CGpoFilter::Add( VARIANT *pVar )
{
    if ( pVar->vt == VT_NULL || pVar->vt == VT_EMPTY )
        return S_OK;

    UINT ul = SafeArrayGetDim( pVar->parray );

    //
    // Null filter can be specified
    //

    if ( ul == 0 )
        return S_OK;

    if ( ul != 1 ) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: Dimension of input safearray is not 1"),
                  GetLastError());
        return E_FAIL;
    }

    if ( pVar->vt != (VT_ARRAY | VT_BSTR ) ) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: Variant type 0x%x is unexpected"), pVar->vt );
        return E_FAIL;
    }

    long lLower, lUpper;

    HRESULT hr = SafeArrayGetLBound( pVar->parray, 1, &lLower );
    if ( FAILED(hr)) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: GetLBound failed with 0x%x"), hr );
        return E_FAIL;
    }

    hr = SafeArrayGetUBound( pVar->parray, 1, &lUpper );
    if ( FAILED(hr)) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: GetUBound failed with 0x%x"), hr );
        return E_FAIL;
    }

    for ( long i=lLower; i<(lUpper+1); i++ ) {

        BSTR bstrId = NULL;
        hr = SafeArrayGetElement( pVar->parray, &i, &bstrId );

        if ( FAILED(hr)) {
            dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::Add: GetElement failed with 0x%x"), hr );
            return E_FAIL;
        }

        dbgFilt.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CGpoFilter::Add: Filter %d. <%s>"), i, bstrId );

        GPFILTER *pGpFilter = AllocGpFilter( (WCHAR *) bstrId );
        if ( pGpFilter == NULL )
            return E_OUTOFMEMORY;

        //
        // Insert does not fail, because it's an insertion into a linked list
        //

        Insert( pGpFilter );
    }

    return S_OK;
}



//*************************************************************
//
//  CGpoFilter::Insert
//
//  Purpose:    Insert filter into sorted list in ascending order
//
//  Parameters: pGpFilter - Filter to insert
//
//*************************************************************

void CGpoFilter::Insert( GPFILTER *pGpFilter )
{
    GPFILTER *pCurPtr = m_pFilterList;
    GPFILTER *pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                      pGpFilter->pwszId, -1, pCurPtr->pwszId, -1 );

        if ( iResult == CSTR_EQUAL ) {

            //
            // Duplicate, so do nothing
            //

            return;

        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Since filters are in ascending order, this means
            // filter is not in list, so add.
            //

            pGpFilter->pNext = pCurPtr;
            if ( pTrailPtr == NULL )
                m_pFilterList = pGpFilter;
            else
                pTrailPtr->pNext = pGpFilter;

            return;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }
    }   // while

    //
    // Null list or end of list case
    //

    pGpFilter->pNext = pCurPtr;

    if ( pTrailPtr == NULL )
        m_pFilterList = pGpFilter;
    else
        pTrailPtr->pNext = pGpFilter;

    return;
}


//*************************************************************
//
//  CGpoFilter::FilterCheck
//
//  Purpose:    Checks if a filter passes the query check
//
//  Parameters: pwszId - Filter id to check
//
//*************************************************************

BOOL CGpoFilter::FilterCheck( WCHAR *pwszId )
{
    GPFILTER *pCurPtr = m_pFilterList;

    while ( pCurPtr ) {

        INT iResult = CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                      pwszId, -1, pCurPtr->pwszId, -1 );
        if ( iResult == CSTR_EQUAL ) {

           return TRUE;

        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Since ids are in ascending order,
            // we are done.
            //

            return FALSE;

        } else {

            //
            // Advance down the list
            //

            pCurPtr = pCurPtr->pNext;

        } // final else

    }   // while pcurptr

    return FALSE;
}


//*************************************************************
//
//  CGpoFilter::AllocGpFilter
//
//  Purpose:    Allocs and returns a GPFILTER struct
//
//  Parameters: pwszId  - Id of filter
//
//*************************************************************

GPFILTER * CGpoFilter::AllocGpFilter( WCHAR *pwszId )
{
    GPFILTER *pGpFilter = (GPFILTER *) LocalAlloc( LPTR, sizeof(GPFILTER) );

    if ( pGpFilter == NULL ) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::AllocGpFilter failed to allocate memory") );
        return NULL;
    }

    pGpFilter->pwszId = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszId) + 1) * sizeof(WCHAR) );
    if ( pGpFilter->pwszId == NULL ) {
        dbgFilt.Msg( DEBUG_MESSAGE_WARNING, TEXT("CGpoFilter::AllocGpFilter failed to allocate memory") );
        LocalFree( pGpFilter );
        return NULL;
    }

    lstrcpy( pGpFilter->pwszId, pwszId );

    return pGpFilter;
}



//*************************************************************
//
//  FreeGpFilter()
//
//  Purpose:    Frees GPFILTER struct
//
//  Parameters: pGpFilter - GPFILTER to free
//
//*************************************************************

void CGpoFilter::FreeGpFilter( GPFILTER *pGpFilter )
{
    if ( pGpFilter ) {
        LocalFree( pGpFilter->pwszId );
        LocalFree( pGpFilter );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\gpfilter.h ===
//***********************************************

//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//  GPO WQL filter class
//
//  History:    10-Mar-00   SitaramR    Created
//
//*************************************************************

#include <initguid.h>


typedef struct _GPFILTER {
    WCHAR *             pwszId;  // Gpo filter id
    struct _GPFILTER *  pNext;   // Singly linked list pointer
} GPFILTER;



class CGpoFilter
{

public:
    CGpoFilter() : m_pFilterList(0) {}
    ~CGpoFilter();

    HRESULT Add( VARIANT *pVar );
    BOOL FilterCheck( WCHAR *pwszId );

private:

    void Insert( GPFILTER *pGpFilter );
    GPFILTER * AllocGpFilter( WCHAR *pwszId );
    void FreeGpFilter( GPFILTER *pGpFilter );

    GPFILTER *   m_pFilterList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\indicate.cpp ===
//*************************************************************
//
//  Resultant set of policy, Progressor Indicator class
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   NishadM    Created
//
//*************************************************************

#include "Indicate.h"

//*************************************************************
//
//  CProgressIndicator::CProgressIndicator(()
//
//  Purpose:    Constructor
//
//  Parameters:
//              pObjectSink         - response handler
//              pOutParams          - out parameters
//              bstrNumer           - numerator string
//              bstrDenom           - denominator string
//              ulNumer             - numerator
//              ulDenom             - denominator
//              fIntermediateStatus - intermediate status reqd.
//                  
//
//*************************************************************
CProgressIndicator::CProgressIndicator( IWbemObjectSink* pObjectSink,
                                        bool fIntermediateStatus,
                                        unsigned long ulNumer,
                                        unsigned long ulDenom ) :
                                        m_ulNumerator( ulNumer ),
                                        m_ulDenominator( ulDenom ),
                                        m_xObjectSink( pObjectSink ),
                                        m_fIntermediateStatus( fIntermediateStatus ),
                                        m_fIsValid( pObjectSink != 0 )
{
}

//*************************************************************
//
//  CProgressIndicator::~CProgressIndicator(()
//
//  Purpose:    Destructor
//
//
//*************************************************************
CProgressIndicator::~CProgressIndicator()
{
    m_xObjectSink.Acquire();
}

//*************************************************************
//
//  CProgressIndicator::IncrementBy(()
//
//  Purpose:    Increments the progress by x%
//
//  Parameters:
//              ulPercent - percent to increment by
//                  
//
//*************************************************************
HRESULT
CProgressIndicator::IncrementBy( unsigned long ulPercent )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }
    
    //
    // numerator cannot be greater than denominator
    //
    m_ulNumerator += ulPercent;
    if ( m_ulNumerator > m_ulDenominator )
    {
        m_ulNumerator = m_ulDenominator;
    }

    if ( m_fIntermediateStatus )
    {
        return m_xObjectSink->SetStatus(WBEM_STATUS_PROGRESS, MAKELONG( m_ulNumerator, m_ulDenominator ), 0, 0 );
    }

    return S_OK;
}

//*************************************************************
//
//  CProgressIndicator::SetComplete()
//
//  Purpose:    Increments progress to 100% and forces Indicate
//
//
//*************************************************************
HRESULT
CProgressIndicator::SetComplete()
{
    return IncrementBy( MaxProgress() - CurrentProgress() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\indicate.h ===
//***********************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   NishadM    Created
//
//*************************************************************

#ifndef _INDICATE_H_
#define _INDICATE_H_

#include <wbemcli.h>
#include "smartptr.h"

class CProgressIndicator
{
    public:
    CProgressIndicator( IWbemObjectSink*    pObjectSink,        // response handler
                        bool                fIntermediateStatus = FALSE, // need intermediate status
                        unsigned long       ulNumer = 0,
                        unsigned long       ulDenom = 100
                         );
    ~CProgressIndicator();

    HRESULT
    IncrementBy( unsigned long ulPercent );

    HRESULT
    SetComplete();

    unsigned long
    CurrentProgress() { return m_ulNumerator; };

    unsigned long
    MaxProgress() { return m_ulDenominator; };

    inline bool
    IsValid() { return m_fIsValid; };

    private:
    unsigned long       m_ulNumerator;
    unsigned long       m_ulDenominator;

    XInterface<IWbemObjectSink>     m_xObjectSink;

    bool                m_fIsValid;
    bool                m_fIntermediateStatus;
};

#endif // _INDICATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\rsopdbg.cpp ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:                        RsopDbg.cpp
//
// Description:
//
// History:    8-20-99   leonardm    Created
//
//*************************************************************

#include <windows.h>
#include <wchar.h>
#include "RsopUtil.h"
#include "smartptr.h"
#include "RsopDbg.h"

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

CDebug::CDebug() :
    _bInitialized(false)
{
#if DBG
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE | DEBUG_DESTINATION_DEBUGGER;
#else
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE;
#endif
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

CDebug::CDebug( const WCHAR* sRegPath,
                        const WCHAR* sKeyName,
                        const WCHAR* sLogFilename,
                        const WCHAR* sBackupLogFilename,
                        bool bResetLogFile)
     : _sRegPath(sRegPath),
       _sKeyName(sKeyName),
       _sLogFilename(sLogFilename),
       _sBackupLogFilename(sBackupLogFilename)
{

#if DBG
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE | DEBUG_DESTINATION_DEBUGGER;
#else
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE;
#endif

    Initialize(bResetLogFile);
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

bool CDebug::Initialize( const WCHAR* sRegPath,
                             const WCHAR* sKeyName,
                             const WCHAR* sLogFilename,
                             const WCHAR* sBackupLogFilename,
                             bool bResetLogFile)
{
    if (!xCritSec)
        return FALSE;

    XEnterCritSec xEnterCS(xCritSec);
    
    _sRegPath = sRegPath;
    _sKeyName = sKeyName;
    _sLogFilename = sLogFilename;
    _sBackupLogFilename = sBackupLogFilename;

    return Initialize(bResetLogFile);
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

bool CDebug::Initialize(bool bResetLogFile)
{

    //
    // reinitialize the default value
    //

#if DBG
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE | DEBUG_DESTINATION_DEBUGGER;
#else
    _dwDebugLevel = DEBUG_LEVEL_WARNING | DEBUG_DESTINATION_LOGFILE;
#endif
    
    _bInitialized = false;

    //
    // Check the registry for the appropriate debug level.
    //

    HKEY hKey;
    LONG lResult = RegOpenKey (HKEY_LOCAL_MACHINE, _sRegPath, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(_dwDebugLevel);
        DWORD dwType;
        RegQueryValueEx(hKey,_sKeyName,NULL,&dwType,(LPBYTE)&_dwDebugLevel,&dwSize);
        RegCloseKey(hKey);
    }


    //
    // If a new log file has been requested, copy current log file to backup
    // file by overwriting then start a new log file.
    //

    if (bResetLogFile)
    {
        WCHAR szExpLogFileName[MAX_PATH+1];
        WCHAR szExpBackupLogFileName[MAX_PATH+1];

        CWString sTmp;
        sTmp = L"%systemroot%\\debug\\UserMode\\" + _sLogFilename;
        if(!sTmp.ValidString())
        {
            return false;
        }

        DWORD dwRet = ExpandEnvironmentStrings( sTmp, szExpLogFileName, MAX_PATH+1);

        if ( dwRet == 0 || dwRet > MAX_PATH)
        {
            return false;
        }

        sTmp = L"%systemroot%\\debug\\UserMode\\" + _sBackupLogFilename;

        if(!sTmp.ValidString())
        {
            return false;
        }

        dwRet = ExpandEnvironmentStrings ( sTmp, szExpBackupLogFileName, MAX_PATH+1);

        if ( dwRet == 0 || dwRet > MAX_PATH)
        {
            return false;
        }


        dwRet = MoveFileEx( szExpLogFileName, szExpBackupLogFileName, 
                        MOVEFILE_REPLACE_EXISTING);

                        
        XHandle hFile = CreateFile(  szExpLogFileName,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    0,
                                    NULL);

        if(hFile == INVALID_HANDLE_VALUE)
        {
            return false;
        }
    }

    _bInitialized = true;
    return _bInitialized;
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

void CDebug::Msg(DWORD dwMask, LPCTSTR pszMsg, ...)
{

    //
    // Save the last error code (so the debug output doesn't change it).
    //

    DWORD dwErrCode = GetLastError();

    if(!_bInitialized)
    {
        return;
    }


    //
    // Display the error message if appropriate
    //

    bool bDebugOutput = (_dwDebugLevel & 0xFFFF0000 & DEBUG_DESTINATION_DEBUGGER) != 0;
    bool bLogfileOutput = (_dwDebugLevel & 0xFFFF0000 & DEBUG_DESTINATION_LOGFILE) != 0;

    if(!bDebugOutput && !bLogfileOutput)
    {

        //
        // No output
        //

        CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
        return;
    }


    //
    // Determine the correct amount of debug output
    //

    bool bOutput;
    switch(_dwDebugLevel & 0x0000FFFF)
    {

        //
        // No output
        //


        case DEBUG_LEVEL_NONE:
                bOutput = false;
                break;


        //
        // Asserts and warnings
        //

        case DEBUG_LEVEL_WARNING:
                bOutput = dwMask & (DEBUG_MESSAGE_ASSERT | DEBUG_MESSAGE_WARNING) ? true : false;
                break;


        //
        // Asserts, warnings and verbose
        //

        case DEBUG_LEVEL_VERBOSE:
                bOutput = dwMask & (DEBUG_MESSAGE_ASSERT | DEBUG_MESSAGE_WARNING | DEBUG_MESSAGE_VERBOSE) ? true : false;
                break;


        //
        // No output
        //

        default:
                bOutput = false;
                break;
    }

    if(!bOutput)
    {
        CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
        return;
    }

    WCHAR* pszMessageLevel;
    if((dwMask & 0x0000FFFF) == DEBUG_MESSAGE_ASSERT)
    {
        pszMessageLevel = L" [ASSERT] ";
    }
    else if((dwMask & 0x0000FFFF) == DEBUG_MESSAGE_WARNING)
    {
        pszMessageLevel = L" [WARNING] ";
    }
    else if((dwMask & 0x0000FFFF) == DEBUG_MESSAGE_VERBOSE)
    {
        pszMessageLevel = L" [VERBOSE] ";
    }
    else
    {
        pszMessageLevel = L" [<Unknown message type>] ";
    }

    SYSTEMTIME systime;
    GetLocalTime (&systime);

    WCHAR szDebugTitle[128];

    swprintf (  szDebugTitle,
                L"[%x.%x] %2d/%02d/%4d %02d:%02d:%02d:%03d ",
                GetCurrentProcessId(),
                GetCurrentThreadId(),
                systime.wMonth, systime.wDay, systime.wYear,
                systime.wHour, systime.wMinute, systime.wSecond,systime.wMilliseconds);

    const int nDebugBufferWChars = 2048;
    XPtrLF<WCHAR>xpDebugBuffer = (LPTSTR) LocalAlloc (LPTR, nDebugBufferWChars * sizeof(WCHAR));

    if(!xpDebugBuffer)
    {
        CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
        return;
    }

    va_list marker;
    va_start(marker, pszMsg);
    int nChars = wvsprintf(xpDebugBuffer, pszMsg, marker);

    if(bDebugOutput)
    {
        OutputDebugString(szDebugTitle);
        OutputDebugString(pszMessageLevel);
        OutputDebugString(xpDebugBuffer);
        OutputDebugString(L"\r\n");
    }

    va_end(marker);

    if(bLogfileOutput)
    {
        WCHAR szExpLogFileName[MAX_PATH+1];
        CWString sTmp = L"%systemroot%\\debug\\usermode\\" + _sLogFilename;
        if(!sTmp.ValidString())
        {
            return;
        }

        DWORD dwRet = ExpandEnvironmentStrings ( sTmp, szExpLogFileName, MAX_PATH+1);

        if(dwRet == 0 || dwRet > MAX_PATH)
        {
            CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
            return;
        }

        HANDLE hFile = CreateFile( szExpLogFileName,
                                   GENERIC_WRITE,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

        XHandle autoCloseHandle(hFile);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            DWORD dwLastError = GetLastError();
            CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
            return;
        }

        if(SetFilePointer(hFile, 0, NULL, FILE_END) == INVALID_FILE_SIZE)
        {
            CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
            return;
        }

        DWORD dwBytesWritten;
        WriteFile(hFile, (LPCVOID) szDebugTitle,lstrlen (szDebugTitle) * sizeof(WCHAR),&dwBytesWritten,NULL);
        WriteFile(hFile, (LPCVOID) pszMessageLevel,lstrlen (pszMessageLevel) * sizeof(WCHAR),&dwBytesWritten,NULL);
        WriteFile(hFile, (LPCVOID) xpDebugBuffer,lstrlen (xpDebugBuffer) * sizeof(WCHAR),&dwBytesWritten,NULL);
        WriteFile(hFile, (LPCVOID) L"\r\n",lstrlen (L"\r\n") * sizeof(WCHAR),&dwBytesWritten,NULL);
    }

    CleanupAndCheckForDbgBreak(dwErrCode, dwMask);
    return;
}

//*************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
//*************************************************************

void CDebug::CleanupAndCheckForDbgBreak(DWORD dwErrorCode, DWORD dwMask)
{
    SetLastError(dwErrorCode);

    // Break to the debugger if appropriate
#ifdef DEBUG
    if((dwMask & 0x0000FFFF) == DEBUG_MESSAGE_ASSERT)
    {
        DebugBreak();
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\namespc.cpp ===
//*************************************************************
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        NameSpace.cpp
//
// Contents:    Functions to copy classes and instances from one namespace to
//              another
//
// History:     25-Aug-99       NishadM    Created
//
//*************************************************************

#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#include <wbemcli.h>
#include "smartptr.h"
#include "RsopInc.h"
#include "rsoputil.h"
#include "rsopdbg.h"


HRESULT
GetWbemServicesPtr( LPCWSTR         wszNameSpace,
                    IWbemLocator**  ppLocator,
                    IWbemServices** ppServices )
{
    HRESULT                     hr;
    IWbemLocator*               pWbemLocator = 0;

    if ( !wszNameSpace || !ppLocator || !ppServices )
    {
        hr =  E_INVALIDARG;
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetWbemServicesPtr: Invalid argument" ));
    }
    else
    {
        if ( !*ppLocator )
        {
            //
            // get a handle to IWbemLocator
            //
            hr = CoCreateInstance(  CLSID_WbemLocator,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IWbemLocator,
                                    (void**) &pWbemLocator );
            if ( SUCCEEDED( hr ) )
            {
                *ppLocator = pWbemLocator;
            }
            else
            {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetWbemServicesPtr: CoCreateInstance failed with 0x%x"), hr );
            }
        }
        else
        {
            //
            // IWbemLocator was passed in. don't create it
            //
            pWbemLocator = *ppLocator;
        }
    }

    if ( pWbemLocator )
    {
        XBStr xNameSpace( (LPWSTR) wszNameSpace );

        if ( xNameSpace )
        {
            //
            // based on the name space, get a handle to IWbemServices
            //
            hr = pWbemLocator->ConnectServer( xNameSpace,
                                              0,
                                              0,
                                              0L,
                                              0L,
                                              0,
                                              0,
                                              ppServices );
        }
    }

    return hr;
}

HRESULT
CopyInstances(  IWbemServices*  pServicesSrc,
                IWbemServices*  pServicesDest,
                BSTR            bstrClass,
                BOOL*           pbAbort )
{
    HRESULT hr;
    IEnumWbemClassObject*       pEnum = 0;

    //
    // create an enumeration of instances
    //

    hr = pServicesSrc->CreateInstanceEnum(  bstrClass,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                            NULL,
                                            &pEnum );

    XInterface<IEnumWbemClassObject> xEnum( pEnum );
    ULONG ulReturned = 1;

    hr = *pbAbort ? E_ABORT : hr ;

    while ( SUCCEEDED( hr ) )
    {
        IWbemClassObject *pInstance;

        //
        // for every instance
        //
        hr = xEnum->Next( -1,
                          1,
                          &pInstance,
                          &ulReturned );
        //
        // perf: use batching calls
        //

        if ( SUCCEEDED( hr ) && ulReturned == 1 )
        {
            XInterface<IWbemClassObject> xInstance( pInstance );

            //
            // copy to the destination namespace
            //
            hr = pServicesDest->PutInstance(    pInstance,
                                                WBEM_FLAG_CREATE_OR_UPDATE,
                                                0,
                                                0 );
            hr = *pbAbort ? E_ABORT : hr ;
        }
        else
        {
            break;
        }
    }

    return hr;
}

HRESULT
CopyClasses(IWbemServices*  pServicesSrc,
            IWbemServices*  pServicesDest,
            BSTR            bstrParent,
            BOOL            bCopyInstances,
            BOOL*           pbAbort )
{
    HRESULT hr = S_OK;

    //
    // create an enumeration of classes
    //

    XInterface<IEnumWbemClassObject> xEnum;
    hr = pServicesSrc->CreateClassEnum( bstrParent,
                                        WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                        0,
                                        &xEnum );

    ULONG   ulReturned = 1;
    XBStr   xbstrClass( L"__CLASS" );

    hr = *pbAbort ? E_ABORT : hr ;

    while ( SUCCEEDED( hr ) )
    {
        XInterface<IWbemClassObject> xClass;

        //
        // for every class
        //
        hr = xEnum->Next( -1,
                          1,
                          &xClass,
                          &ulReturned );

        hr = *pbAbort ? E_ABORT : hr ;
        
        if ( SUCCEEDED( hr ) && ulReturned == 1 )
        {
            VARIANT var;

            VariantInit( &var );
            
            //
            // get __CLASS system property
            //
            hr = xClass->Get(   xbstrClass,
                                0,
                                &var,
                                0,
                                0 );

            if ( SUCCEEDED( hr ) )
            {
                //
                // system classes begin with "_", don't copy them
                //
                if ( wcsncmp( var.bstrVal, L"_", 1 ) )
                {
                    //
                    // copy class
                    //
                    hr = pServicesDest->PutClass(   xClass,
                                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                                    0,
                                                    0 );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = CopyClasses(   pServicesSrc,
                                            pServicesDest,
                                            var.bstrVal,
                                            bCopyInstances,
                                            pbAbort );
                        if ( FAILED( hr ) )
                        {
                            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyClasses: CopyClassesSorted failed with 0x%x"), hr );
                        }
                        else if ( bCopyInstances )
                        {
                            //
                            // copy instance
                            //
                            hr = CopyInstances( pServicesSrc, pServicesDest, var.bstrVal, pbAbort );

                            if ( FAILED(hr) )
                            {
                                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyClasses: CopyInstances failed with 0x%x"), hr );
                            }
                        }
                    }
                }
                
                VariantClear( &var );
            }
        }
        else
        {
            break;
        }
    }

    return hr;
}

HRESULT
CopyNameSpace(  LPCWSTR       wszSrc,
                LPCWSTR       wszDest,
                BOOL          bCopyInstances,
                BOOL*         pbAbort,
                IWbemLocator* pWbemLocator )
{
    //
    // parameter validation
    //

    if ( !wszSrc || !wszDest || !pbAbort )
    {
            return E_POINTER;
    }

    BOOL            bLocatorObtained = ( pWbemLocator == 0 );
    IWbemServices*  pServicesSrc;

    //
    // get a pointer to the source namespace
    //
    HRESULT hr = GetWbemServicesPtr( wszSrc, &pWbemLocator, &pServicesSrc );

    hr = *pbAbort ? E_ABORT : hr ;

    if ( SUCCEEDED( hr ) )
    {
        XInterface<IWbemServices>   xServicesSrc( pServicesSrc );
        IWbemServices*              pServicesDest;

        //
        // get a pointer to the destination namespace
        //
        hr = GetWbemServicesPtr( wszDest, &pWbemLocator, &pServicesDest );

        hr = *pbAbort ? E_ABORT : hr ;

        if ( SUCCEEDED( hr ) )
        {
            XInterface<IWbemServices> xServicesDest( pServicesDest );

            //
            // copy classes and instances
            //
            hr = CopyClasses(   pServicesSrc,
                                pServicesDest,
                                0,
                                bCopyInstances,
                                pbAbort );
            if ( FAILED(hr) )
            {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CopyNamespace: CopyClasses failed with 0x%x"), hr );
            }
        }
    }

    //
    // if we created IWbemLocator, release it
    //
    if ( bLocatorObtained && pWbemLocator )
    {
        pWbemLocator->Release();
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\rights.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <rpc.h>
#include <ntdsapi.h>
#define SECURITY_WIN32
#include <security.h>
#include <aclapi.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <wbemcli.h>

#include "smartptr.h"
#include "rsoputil.h"
#include "rsopdbg.h"
#include "rsopsec.h"


extern "C" {
DWORD CheckAccessForPolicyGeneration( HANDLE hToken, 
                                LPCWSTR szContainer,
                                LPWSTR  szDomain,
                                BOOL    bLogging,
                                BOOL*   pbAccessGranted);

}

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


//*************************************************************
//
//  CheckAccessForPolicyGeneration()
//
//  Purpose:    Finds out whether user has the right to generate rsop data
//
//  Parameters: hToken          -  Token of the user who is using the tool
//              szContainer     -  DS Container with which it needs to be validated
//              bLogging        -  Logging or Planning mode
//              pbAccessGranted -  Access was granted or not
//
//  Return:     ERROR_SUCCESS
//              Error Code otherwise
//
// The container passed in is actually parsed to figure out the first ou= or
// dc= supercontainer and then the rights are evaluated..
//
//*************************************************************

DWORD
CheckAccessForPolicyGeneration( HANDLE hToken, 
                                LPCWSTR szContainer,
                                LPWSTR  szDomain,
                                BOOL    bLogging,
                                BOOL*   pbAccessGranted)
{
    DWORD    dwError = ERROR_SUCCESS;
    XHandle  xhTokenDup;
    BOOL     bDomain = FALSE;
//    BOOLEAN  bSecurityWasEnabled;
    WCHAR   *pDomainString[1];
    PDS_NAME_RESULT pNameResult = NULL;

    *pbAccessGranted = 0;

    //
    // Parse the container first to get the OU= or DC=
    // The "Actual SOM"
    //

    while (*szContainer) {

        //
        // See if the DN name starts with OU=
        //

        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                           szContainer, 3, TEXT("OU="), 3) == CSTR_EQUAL) {
            break;
        }

        //
        // See if the DN name starts with DC=
        //

        else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                szContainer, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
            break;
        }


        //
        // Move to the next chunk of the DN name
        //

        while (*szContainer && (*szContainer != TEXT(','))) {
            szContainer++;
        }

        if (*szContainer == TEXT(',')) {
            szContainer++;
        }
    }

    if (!*szContainer) {
        return ERROR_INVALID_PARAMETER;
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CheckAccessForPolicyGeneration: SOM for account is %s", szContainer );

    
    //
    // See if the DN name starts with DC=
    //

    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       szContainer, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
        bDomain = TRUE;
    }
    
    
    //
    // preparse the name to just get the string , dc=
    //

    XPtrLF<WCHAR> xwszDomain;
    LPWSTR        szDomLocal;


    if (!szDomain) {
        dwError = GetDomain(szContainer, &xwszDomain);

        if (dwError != ERROR_SUCCESS) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: GetDomain failed with error %d", dwError );
            return dwError;
        }

        szDomLocal = xwszDomain;
    }
    else {
        szDomLocal = szDomain;
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CheckAccessForPolicyGeneration: Som resides in domain %s", szDomLocal );

    XPtrLF<WCHAR> xszDSObject = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(L"LDAP://")+
                                                                       wcslen(szDomLocal)+
                                                                       wcslen(szContainer)+5));

    if (!xszDSObject) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration:  AllocMem failed with %d.", GetLastError() );
        return GetLastError();
    }

    wcscpy(xszDSObject, L"LDAP://");
    wcscat(xszDSObject, szDomLocal);
    wcscat(xszDSObject, L"/");
    wcscat(xszDSObject, szContainer);

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CheckAccessForPolicyGeneration: getting SD off %s", xszDSObject );


    if ( !DuplicateTokenEx( hToken,
                            TOKEN_IMPERSONATE | TOKEN_QUERY,
                            0,
                            SecurityImpersonation,
                            TokenImpersonation,
                            &xhTokenDup ) )
    {
        dwError = GetLastError();
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: DuplicateTokenEx failed, 0x%X", dwError );
        return dwError;
    }


    //
    // Enable privilege to read SDs
    //

/*
    dwError = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE, TRUE, FALSE, &bSecurityWasEnabled);

    if (!NT_SUCCESS(dwError)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: DuplicateTokenEx failed, 0x%X", dwError );
        return dwError;
    }
*/


    XPtrLF<SECURITY_DESCRIPTOR> xptrSD;

    dwError = GetNamedSecurityInfo( (LPWSTR) xszDSObject,
                                    SE_DS_OBJECT_ALL,
                                    DACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION ,
                                    0,
                                    0,
                                    0,
                                    0,
                                    (void**) &xptrSD );

    if ( !dwError )
    {

        //
        // bf967aa5-0de6-11d0-a285-00aa003049e
        //
        GUID OUClass = {0xbf967aa5, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2};

        //
        // 19195a5b-6da0-11d0-afd3-00c04fd930c9
        //

        GUID DomainClass = {0x19195a5b, 0x6da0, 0x11d0, 0xaf, 0xd3, 0x00, 0xc0, 0x4f, 0xd9, 0x30, 0xc9};
        

        //
        // b7b1b3dd-ab09-4242-9e30-9980e5d322f7
        //
        GUID planningRight = {0xb7b1b3dd, 0xab09, 0x4242, 0x9e, 0x30, 0x99, 0x80, 0xe5, 0xd3, 0x22, 0xf7};

        //
        // b7b1b3de-ab09-4242-9e30-9980e5d322f7
        //
        GUID loggingRight = {0xb7b1b3de, 0xab09, 0x4242, 0x9e, 0x30, 0x99, 0x80, 0xe5, 0xd3, 0x22, 0xf7};

        OBJECT_TYPE_LIST ObjType[2];

        ObjType[0].Level = ACCESS_OBJECT_GUID;
        ObjType[0].Sbz = 0;

        if (bDomain) {
            ObjType[0].ObjectType = &DomainClass;
        }
        else {
            ObjType[0].ObjectType = &OUClass;
        }


        ObjType[1].Level = ACCESS_PROPERTY_SET_GUID;
        ObjType[1].Sbz = 0;

        if (bLogging) {
            ObjType[1].ObjectType = &loggingRight;
        }
        else {
            ObjType[1].ObjectType = &planningRight;
        }


        GENERIC_MAPPING GenericMapping =    {
                                            DS_GENERIC_READ,
                                            DS_GENERIC_WRITE,
                                            DS_GENERIC_EXECUTE,
                                            DS_GENERIC_ALL
                                            };

        const DWORD PriviledgeSize = 2 * ( sizeof(PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES) );
        BYTE PrivilegeSetBuffer[PriviledgeSize];
        DWORD cPrivilegeSet = PriviledgeSize;
        PPRIVILEGE_SET pPrivilegeSet = (PPRIVILEGE_SET)PrivilegeSetBuffer;
        DWORD dwGrantedAccess;

        if ( !AccessCheckByType( xptrSD,
                                0,
                                xhTokenDup,
                                ACTRL_DS_CONTROL_ACCESS,
                                ObjType,
                                ARRAYSIZE(ObjType),
                                &GenericMapping,
                                pPrivilegeSet,
                                &cPrivilegeSet,
                                &dwGrantedAccess,
                                pbAccessGranted ) )
        {
            dwError = GetLastError();
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: AccessCheckByType failed, 0x%X", dwError );
        }
    }
    else {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: GetNamedSecurityInfo failed, 0x%X", dwError );
    }

/*    
    dwError = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE, bSecurityWasEnabled, FALSE, &bSecurityWasEnabled);

    if (!NT_SUCCESS(dwError)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration: DuplicateTokenEx failed, 0x%X", dwError );
        return dwError;
    }
*/

    return dwError;
}

//*************************************************************
//
//  GetSOM()
//
//  Purpose:    Finds out the FQDN of a given user/computer
//
//  Parameters: szAccount       -  User or computer Account name in an appropriate format
//
//  Return:     SOM, NULL otherwise. GetLastError() for details
//              This just returns the DN of the user
//
//*************************************************************


LPWSTR
GetSOM( LPCWSTR szAccount )
{
    DWORD   dwSize = 0;
    XPtrLF<WCHAR>  xszXlatName;
    XPtrLF<WCHAR>  xszSOM;

    TranslateName(  szAccount,
                    NameUnknown,
                    NameFullyQualifiedDN,
                    xszXlatName,
                    &dwSize );
    if (!dwSize)
    {
        return 0;
    }

    xszXlatName = (LPWSTR)LocalAlloc( LPTR, ( dwSize + 1 ) * sizeof( WCHAR ) );
    if ( !xszXlatName )
    {
        return 0;
    }

    if ( !TranslateName(szAccount,
                        NameUnknown,
                        NameFullyQualifiedDN,
                        xszXlatName,
                        &dwSize ) )
    {
        return 0;
    }


    xszSOM = xszXlatName.Acquire();
    
    return xszSOM.Acquire();
}


//*************************************************************
//
//  GetDomain()
//
//  Purpose:    Finds out the domain given a SOM. 
//
//  Parameters: szSOM    -  SOM
//
//  Return:     domain Dns if success, null otherwise
//
//*************************************************************


DWORD
GetDomain( LPCWSTR szSOM, LPWSTR *pszDomain )
{
    DWORD    dwError = ERROR_SUCCESS;
    WCHAR   *pDomainString[1];
    PDS_NAME_RESULT pNameResult = NULL;

    //
    // preparse the name to just get the string , dc=
    //

    pDomainString[0] = NULL;

    LPWSTR pwszTemp = (LPWSTR)szSOM;

    while ( *pwszTemp ) {

        if (CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                            pwszTemp, 3, TEXT("DC="), 3) == CSTR_EQUAL ) {
            pDomainString[0] = pwszTemp;
            break;
        }
    
        //
        // Move to the next chunk of the DN name
        //
    
        while ( *pwszTemp && (*pwszTemp != TEXT(',')))
            pwszTemp++;
    
        if ( *pwszTemp == TEXT(','))
            pwszTemp++;
    
    }

    if (pDomainString[0] == NULL) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetDomain: Som doesn't have DC=. failing" );
        return ERROR_INVALID_PARAMETER;
    }



    dwError = DsCrackNames( (HANDLE) -1,
                            DS_NAME_FLAG_SYNTACTICAL_ONLY,
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            1,
                            pDomainString,
                            &pNameResult );

    if ( dwError != ERROR_SUCCESS
         || pNameResult->cItems == 0
         || pNameResult->rItems[0].status != ERROR_SUCCESS
         || pNameResult->rItems[0].pDomain == NULL ) {

        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetDomain:  DsCrackNames failed with 0x%x.", dwError );
        return dwError;
    }

    
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"GetDomain: Som resides in domain %s", pNameResult->rItems[0].pDomain );

    XPtrLF<WCHAR> xszDomain = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pNameResult->rItems[0].pDomain)+2));

    if (!xszDomain) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CheckAccessForPolicyGeneration:  AllocMem failed with %d.", GetLastError() );
        DsFreeNameResult( pNameResult );
        return GetLastError();
    }

    wcscpy(xszDomain, pNameResult->rItems[0].pDomain);
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"GetDomain: Domain for som %s = %s", szSOM, xszDomain );
    DsFreeNameResult( pNameResult );

    *pszDomain = xszDomain.Acquire();

    return ERROR_SUCCESS;
}


//*************************************************************
//
//  AuthenticateUser()
//
//  Purpose:    Authenticates whether the user has the right to do the operation
//
//  Parameters: hToken       -  Token of the user
//              szMachSOM    -  Machine SOM (optional)
//              szUserSOM    -  User SOM    (optional)
//              bLogging     -  Logging or Planning mode
//
//  Return:     S_OK on success, error code otherwise
//
//*************************************************************


HRESULT AuthenticateUser(HANDLE  hToken, LPCWSTR szMachSOM, LPCWSTR szUserSOM, BOOL bLogging, DWORD *pdwExtendedInfo)
{
    if ( !szMachSOM && !szUserSOM )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"AuthenticateUser: No mach and user som specified" );
        return E_INVALIDARG;
    }


    DWORD dwError = ERROR_SUCCESS;
    BOOL bMachAccess = FALSE, bUserAccess = FALSE;


    //
    // authenticate for machine SOM
    //

    if (szMachSOM) {
        dwError = CheckAccessForPolicyGeneration(   hToken, 
                                                    szMachSOM,
                                                    NULL,
                                                    bLogging,
                                                    &bMachAccess
                                                    );

        if ( dwError != ERROR_SUCCESS )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"AuthenticateUser: CheckAccessForPolicyGeneration Machine returned error - %d", dwError );
            return HRESULT_FROM_WIN32( dwError );
        }

        if ( !bMachAccess )
        {
            *pdwExtendedInfo |= RSOP_COMPUTER_ACCESS_DENIED;
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"AuthenticateUser: No access on Machine SOM");
        }
    }
    else {
        bMachAccess = TRUE;
    }


    //
    // authenticate for user SOM
    //

    if (szUserSOM) {
        dwError = CheckAccessForPolicyGeneration(   hToken,
                                                    szUserSOM,
                                                    NULL,
                                                    bLogging,
                                                    &bUserAccess
                                                    );

        if ( dwError != ERROR_SUCCESS )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"AuthenticateUser: CheckAccessForPolicyGeneration User returned error - %d", dwError );
            return HRESULT_FROM_WIN32( dwError );
        }

        if ( !bUserAccess )
        {
            *pdwExtendedInfo |= RSOP_USER_ACCESS_DENIED;
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"AuthenticateUser: No access on User SOM");
        }
    }
    else {
        bUserAccess = TRUE;
    }

    if ( !bUserAccess || !bMachAccess )
        return E_ACCESSDENIED;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\rsopsec.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:     RsopSec.cpp
//
// Description:  RSOP Namespace Security functions
//
// History:      8-26-99   leonardm    Created
//
//******************************************************************************

#include <windows.h>
#include <objbase.h>
#include <wbemcli.h>
#include <accctrl.h>
#include <aclapi.h>
#include <lm.h>
#include "RsopUtil.h"
#include "RsopSec.h"
#include "rsopdbg.h"
#include "smartptr.h"


//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP GetExplicitAccesses(   long lSecurityLevel,
                                    EXPLICIT_ACCESS** ppExplicitAccess,
                                    DWORD* pdwCount,
                                    CWString* psTrustees)
{

    WKSTA_INFO_100* pWkstaInfo = NULL;
    NET_API_STATUS status = NetWkstaGetInfo(NULL,100,(LPBYTE*)&pWkstaInfo);
    if(status != NERR_Success)
    {
        return E_FAIL;
    }

    CWString sCurrentDomain = pWkstaInfo->wki100_langroup;
    NetApiBufferFree(pWkstaInfo);

    if(!sCurrentDomain.ValidString() || sCurrentDomain == L"")
    {
        return E_FAIL;
    }


    static ACCESS_MODE AccessMode = GRANT_ACCESS;
    static DWORD Inheritance = SUB_CONTAINERS_ONLY_INHERIT;
    static DWORD AccessPermissions =    WBEM_ENABLE |
                                        WBEM_METHOD_EXECUTE |
                                        WBEM_FULL_WRITE_REP |
                                        WBEM_PARTIAL_WRITE_REP |
                                        WBEM_WRITE_PROVIDER |
                                        WBEM_REMOTE_ACCESS |
                                        READ_CONTROL |
                                        WRITE_DAC;

    XPtrArray<EXPLICIT_ACCESS> xpExplicitAccess = NULL;

    if(lSecurityLevel == NAMESPACE_SECURITY_DIAGNOSTIC)
    {
        if(*pdwCount < 1)
        {
            *pdwCount = 1;
            return E_FAIL;
        }

        *pdwCount = 1;

        xpExplicitAccess = new EXPLICIT_ACCESS[*pdwCount];
        if(!xpExplicitAccess)
        {
            return E_OUTOFMEMORY;
        }

        psTrustees[0] = sCurrentDomain + L"\\Domain Users";
        if(!psTrustees[0].ValidString())
        {
            return E_OUTOFMEMORY;
        }

        BuildExplicitAccessWithName(&(xpExplicitAccess[0]),
                                    psTrustees[0],
                                    AccessPermissions,
                                    AccessMode,
                                    Inheritance);

    }
    else if(lSecurityLevel == NAMESPACE_SECURITY_PLANNING)
    {
        if(*pdwCount < 2)
        {
            *pdwCount = 2;
            return E_FAIL;
        }

        *pdwCount = 2;

        xpExplicitAccess = new EXPLICIT_ACCESS[*pdwCount];

        if(!xpExplicitAccess)
        {
            return E_OUTOFMEMORY;
        }
        psTrustees[0] = sCurrentDomain + L"\\RSOP Admins";
        if(!psTrustees[0].ValidString())
        {
            return E_OUTOFMEMORY;
        }
        BuildExplicitAccessWithName(&(xpExplicitAccess[0]),
                                    psTrustees[0],
                                    AccessPermissions,
                                    AccessMode,
                                    Inheritance);

        psTrustees[1] = sCurrentDomain + L"\\Domain Admins";
        if(!psTrustees[1].ValidString())
        {
            return E_OUTOFMEMORY;
        }
        BuildExplicitAccessWithName(&(xpExplicitAccess[1]),
                                    psTrustees[1],
                                    AccessPermissions,
                                    AccessMode,
                                    Inheritance);

    }
    else
    {
        return E_INVALIDARG;
    }

    *ppExplicitAccess = xpExplicitAccess.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP ReplaceDaclOnSD(PSECURITY_DESCRIPTOR pSD, long lSecurityLevel)
{
    HRESULT hr;

    XPtrArray<EXPLICIT_ACCESS> xpExplicitAccess = NULL;

    DWORD dwCount = 2;
    XPtrArray<CWString> xpTrustees = new CWString[dwCount];
    if(!xpTrustees)
    {
        return E_OUTOFMEMORY;
    }

    hr = GetExplicitAccesses(lSecurityLevel, &xpExplicitAccess, &dwCount, xpTrustees);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Get the DACL of the Security descriptor
    //

    BOOL bDaclPresent;
    BOOL bDaclDefaulted;
    ACL* pAcl = NULL;

    BOOL bRes = GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pAcl,&bDaclDefaulted);
    if(!bRes)
    {
        return E_FAIL;
    }

    if(bDaclPresent)
    {

        //
        // Get the count of existing ACEs
        //

        ACL_SIZE_INFORMATION info;
        bRes = GetAclInformation(pAcl, &info, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);
        if(!bRes)
        {
            return E_FAIL;
        }


        //
        // Remove existing ACEs from DACL
        //

        for(int aceIndex = info.AceCount - 1; aceIndex >= 0; aceIndex--)
        {
            bRes = DeleteAce(pAcl, aceIndex);
            if(!bRes)
            {
                return E_FAIL;
            }
        }

        LocalFree(pAcl);
    }

    pAcl = NULL;


    //
    // SetEntriesInAcl
    //

    DWORD dwRes = SetEntriesInAcl(dwCount, xpExplicitAccess, NULL, &pAcl);
    if(dwRes != ERROR_SUCCESS)
    {
        return E_FAIL;
    }


    //
    // SetSecurityDescriptorDacl
    //

    bRes = SetSecurityDescriptorDacl(pSD, bDaclPresent, pAcl, bDaclDefaulted);
    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        return E_FAIL;
    }

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP RSoPMakeAbsoluteSD(SECURITY_DESCRIPTOR* pSelfRelativeSD, SECURITY_DESCRIPTOR** ppAbsoluteSD)
{
    BOOL bRes = IsValidSecurityDescriptor(pSelfRelativeSD);
    if(!bRes)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    XPtrLF<SECURITY_DESCRIPTOR> xpAbsoluteSD;
    XPtrLF<ACL> xpDacl;
    XPtrLF<ACL> xpSacl;
    XPtrLF<SID> xpOwner;
    XPtrLF<SID> xpPrimaryGroup;


    DWORD dwAbsoluteSecurityDescriptorSize = 0;
    DWORD dwDaclSize = 0;
    DWORD dwSaclSize = 0;
    DWORD dwOwnerSize = 0;
    DWORD dwPrimaryGroupSize = 0;

    bRes = ::MakeAbsoluteSD(
                            pSelfRelativeSD,
                            xpAbsoluteSD,
                            &dwAbsoluteSecurityDescriptorSize,
                            xpDacl,           // discretionary ACL
                            &dwDaclSize,     // size of discretionary ACL
                            xpSacl,           // system ACL
                            &dwSaclSize,     // size of system ACL
                            xpOwner,          // owner SID
                            &dwOwnerSize,    // size of owner SID
                            xpPrimaryGroup,       // primary-group SID
                            &dwPrimaryGroupSize  // size of group SID
                            );

    DWORD dwLastError = GetLastError();
    if(dwLastError != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }

    if(!dwAbsoluteSecurityDescriptorSize)
    {
        return E_FAIL;
    }

    xpAbsoluteSD = reinterpret_cast<SECURITY_DESCRIPTOR*>(LocalAlloc(LPTR, dwAbsoluteSecurityDescriptorSize));
    if(!xpAbsoluteSD)
    {
        return E_OUTOFMEMORY;
    }

    if(dwDaclSize)
    {
        xpDacl = reinterpret_cast<ACL*>(LocalAlloc(LPTR, dwDaclSize));
        if(!xpDacl)
        {
            return E_OUTOFMEMORY;
        }
    }
    if(dwSaclSize)
    {
        xpSacl = reinterpret_cast<ACL*>(LocalAlloc(LPTR, dwSaclSize));
        if(!xpSacl)
        {
            return E_OUTOFMEMORY;
        }
    }
    if(dwOwnerSize)
    {
        xpOwner = reinterpret_cast<SID*>(LocalAlloc(LPTR, dwOwnerSize));
        if(!xpOwner)
        {
            return E_OUTOFMEMORY;
        }
    }
    if(dwPrimaryGroupSize)
    {
        xpPrimaryGroup = reinterpret_cast<SID*>(LocalAlloc(LPTR, dwPrimaryGroupSize));
        if(!xpPrimaryGroup)
        {
            return E_OUTOFMEMORY;
        }
    }

    bRes = ::MakeAbsoluteSD(
                        pSelfRelativeSD,
                        xpAbsoluteSD,
                        &dwAbsoluteSecurityDescriptorSize,
                        xpDacl,           // discretionary ACL
                        &dwDaclSize,     // size of discretionary ACL
                        xpSacl,           // system ACL
                        &dwSaclSize,     // size of system ACL
                        xpOwner,          // owner SID
                        &dwOwnerSize,    // size of owner SID
                        xpPrimaryGroup,       // primary-group SID
                        &dwPrimaryGroupSize  // size of group SID
                        );

    if(!bRes)
    {
        return E_FAIL;
    }

    bRes = IsValidSecurityDescriptor(xpAbsoluteSD);

    if(!bRes)
    {
        return E_FAIL;
    }

    xpDacl.Acquire();
    xpSacl.Acquire();
    xpOwner.Acquire();
    xpPrimaryGroup.Acquire();

    *ppAbsoluteSD = xpAbsoluteSD.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP FreeAbsoluteSD(SECURITY_DESCRIPTOR* pAbsoluteSD)
{
    if(!pAbsoluteSD)
    {
        return E_POINTER;
    }

    BOOL bRes;

    BOOL bDaclPresent;
    BOOL bDaclDefaulted;

    XPtrLF<ACL> xpDacl;
    bRes = GetSecurityDescriptorDacl(       pAbsoluteSD,
                                        &bDaclPresent,
                                        &xpDacl,
                                        &bDaclDefaulted);

    if(!bRes)
    {
        return E_FAIL;
    }

    BOOL bSaclPresent;
    BOOL bSaclDefaulted;

    XPtrLF<ACL> xpSacl;
    bRes = GetSecurityDescriptorSacl(       pAbsoluteSD,
                                        &bSaclPresent,
                                        &xpSacl,
                                        &bSaclDefaulted);

    if(!bRes)
    {
        return E_FAIL;
    }

    BOOL bOwnerDefaulted;

    XPtrLF<SID>xpOwner;
    bRes = GetSecurityDescriptorOwner(pAbsoluteSD, reinterpret_cast<void**>(&xpOwner), &bOwnerDefaulted);
    if(!bRes)
    {
        return E_FAIL;
    }


    BOOL bGroupDefaulted;

    XPtrLF<SID>xpPrimaryGroup;
    bRes = GetSecurityDescriptorGroup(pAbsoluteSD, reinterpret_cast<void**>(&xpPrimaryGroup), &bGroupDefaulted);
    if(!bRes)
    {
        return E_FAIL;
    }

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:    8-26-99   leonardm    Created
//
//******************************************************************************
STDMETHODIMP GetNamespaceSD(IWbemServices* pWbemServices, SECURITY_DESCRIPTOR** ppSD)
{
    if(!pWbemServices)
    {
        return E_POINTER;
    }

    HRESULT hr;

    XInterface<IWbemClassObject> xpOutParams;

    const BSTR bstrInstancePath = SysAllocString(L"__systemsecurity=@");
    if(!bstrInstancePath)
    {
        return E_OUTOFMEMORY;
    }

    const BSTR bstrMethodName = SysAllocString(L"GetSD");
    if(!bstrMethodName)
    {
        SysFreeString(bstrInstancePath);
        return E_OUTOFMEMORY;
    }

    hr = pWbemServices->ExecMethod( bstrInstancePath,
                                    bstrMethodName,
                                    0,
                                    NULL,
                                    NULL,
                                    &xpOutParams,
                                    NULL);

    SysFreeString(bstrInstancePath);
    SysFreeString(bstrMethodName);

    if(FAILED(hr))
    {
        return hr;
    }


    VARIANT v;
    XVariant xv(&v);

    VariantInit(&v);

    hr = xpOutParams->Get(L"sd", 0, &v, NULL, NULL);
    if(FAILED(hr))
    {
        return hr;
    }

    if(v.vt != (VT_ARRAY | VT_UI1))
    {
        return E_FAIL;
    }

    long lLowerBound;
    hr = SafeArrayGetLBound(v.parray, 1, &lLowerBound);
    if(FAILED(hr))
    {
        return hr;
    }

    long lUpperBound;
    hr = SafeArrayGetUBound(v.parray, 1, &lUpperBound);
    if(FAILED(hr))
    {
        return hr;
    }

    DWORD dwSize = static_cast<DWORD>(lUpperBound - lLowerBound + 1);

    XPtrLF<SECURITY_DESCRIPTOR> xpSelfRelativeSD = static_cast<SECURITY_DESCRIPTOR*>(LocalAlloc(LPTR, dwSize));
    if(!xpSelfRelativeSD)
    {
        return E_OUTOFMEMORY;
    }

    BYTE* pSrc;
    hr = SafeArrayAccessData(v.parray, reinterpret_cast<void**>(&pSrc));
    if(FAILED(hr))
    {
        return hr;
    }

    CopyMemory(xpSelfRelativeSD, pSrc, dwSize);

    hr = SafeArrayUnaccessData(v.parray);
    if(FAILED(hr))
    {
        return hr;
    }

    *ppSD = xpSelfRelativeSD.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         8/20/99     leonardm    Created.
//
//******************************************************************************
STDMETHODIMP SetNamespaceSD(SECURITY_DESCRIPTOR* pSD, IWbemServices* pWbemServices)
{
    if(!pWbemServices)
    {
        return E_POINTER;
    }

    HRESULT hr;


    //
    // Get the class object
    //

    XInterface<IWbemClassObject> xpClass;

    BSTR bstrClassPath = SysAllocString(L"__systemsecurity");
    if(!bstrClassPath)
    {
        return E_OUTOFMEMORY;
    }

    hr = pWbemServices->GetObject(bstrClassPath, 0, NULL, &xpClass, NULL);

    SysFreeString(bstrClassPath);

    if(FAILED(hr))
    {
        return hr;
    }


    //
    // Get the input parameter class
    //

    XInterface<IWbemClassObject> xpMethod;
    hr = xpClass->GetMethod(L"SetSD", 0, &xpMethod, NULL);
    if(FAILED(hr))
    {
        return hr;
    }


    //
    // move the SD into a variant.
    //

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;

    DWORD dwLength = GetSecurityDescriptorLength(pSD);

    rgsabound[0].cElements = dwLength;

    SAFEARRAY* psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if(!psa)
    {
        return E_FAIL;
    }

    BYTE* pDest = NULL;

    hr = SafeArrayAccessData(psa, reinterpret_cast<void**>(&pDest));
    if(FAILED(hr))
    {
        return hr;
    }

    CopyMemory(pDest, pSD, dwLength);

    hr = SafeArrayUnaccessData(psa);
    if(FAILED(hr))
    {
        return hr;
    }

    VARIANT v;
    XVariant xv(&v);
    v.vt = VT_UI1|VT_ARRAY;
    v.parray = psa;


    //
    // put the property
    //

    XInterface<IWbemClassObject> xpInParam;
    hr = xpMethod->SpawnInstance(0, &xpInParam);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = xpInParam->Put(L"sd" , 0, &v, 0);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Execute the method
    //

    BSTR bstrInstancePath = SysAllocString(L"__systemsecurity=@");
    if(!bstrInstancePath)
    {
        return E_OUTOFMEMORY;
    }


    BSTR bstrMethodName = SysAllocString(L"SetSD");
    if(!bstrMethodName)
    {
        SysFreeString(bstrInstancePath);
        return E_OUTOFMEMORY;
    }

    hr = pWbemServices->ExecMethod( bstrInstancePath,
                                    bstrMethodName,
                                    0,
                                    NULL,
                                    xpInParam,
                                    NULL,
                                    NULL);

    SysFreeString(bstrInstancePath);
    SysFreeString(bstrMethodName);

    return hr;
}

//******************************************************************************
//
// Function:
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         8/20/99     leonardm    Created.
//
//******************************************************************************
HRESULT SetNamespaceSecurity(const WCHAR* pszNamespace,
                             long lSecurityLevel,
                             IWbemServices* pWbemServices)
{
    HRESULT hr;

    if(!pszNamespace)
    {
        return E_POINTER;
    }

    CWString sNamespace = pszNamespace;
    if(!sNamespace.ValidString() || sNamespace == L"" || !pWbemServices)
    {
        return E_INVALIDARG;
    }

    XPtrLF<SECURITY_DESCRIPTOR> xpOrgSelfRelativeSD;
    hr = GetNamespaceSD(pWbemServices, &xpOrgSelfRelativeSD);
    if(FAILED(hr))
    {
        return hr;
    }

    SECURITY_DESCRIPTOR* pAbsoluteSD = NULL;
    hr = RSoPMakeAbsoluteSD(xpOrgSelfRelativeSD, &pAbsoluteSD);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = ReplaceDaclOnSD(pAbsoluteSD, lSecurityLevel);
    if(FAILED(hr))
    {
        FreeAbsoluteSD(pAbsoluteSD);
        return hr;
    }


    //
    // Make a new self-relative SD here before proceeding.
    //

    DWORD dwBufferLength = 0;
    MakeSelfRelativeSD(     pAbsoluteSD, NULL,&dwBufferLength);

    DWORD dwLastError = GetLastError();
    if((dwLastError != ERROR_INSUFFICIENT_BUFFER) || !dwBufferLength)
    {
        FreeAbsoluteSD(pAbsoluteSD);
        return E_FAIL;
    }

    XPtrLF<SECURITY_DESCRIPTOR> xpNewSelfRelativeSD = reinterpret_cast<SECURITY_DESCRIPTOR*>(LocalAlloc(LPTR, dwBufferLength));
    if(!xpNewSelfRelativeSD)
    {
        FreeAbsoluteSD(pAbsoluteSD);
        return E_OUTOFMEMORY;
    }

    BOOL bRes = MakeSelfRelativeSD( pAbsoluteSD, xpNewSelfRelativeSD, &dwBufferLength);
    hr = FreeAbsoluteSD(pAbsoluteSD);
    if(!bRes || FAILED(hr))
    {
        return E_FAIL;
    }

        xpNewSelfRelativeSD->Control |= SE_DACL_PROTECTED;

    bRes = IsValidSecurityDescriptor(xpNewSelfRelativeSD);
    if(!bRes)
    {
        return E_FAIL;
    }

    hr = SetNamespaceSD( xpNewSelfRelativeSD, pWbemServices);

    return hr;
}


#undef dbg
#define dbg dbgCommon


const DWORD DEFAULT_ACE_NUM=10;

CSecDesc::CSecDesc() : 
                          m_cAces(0), m_xpSidList(NULL), 
                          m_cAllocated(0), m_bInitialised(FALSE), m_bFailed(FALSE)
{
    m_xpSidList = (SidStruct *)LocalAlloc(LPTR, sizeof(SidStruct)*DEFAULT_ACE_NUM);
    if (!m_xpSidList)
        return;

    m_cAllocated = DEFAULT_ACE_NUM;
    m_bInitialised = TRUE;
}


CSecDesc::~CSecDesc()
{
    if (m_xpSidList) 
        for (DWORD i = 0; i < m_cAllocated; i++) 
            if (m_xpSidList[i].pSid) 
                if (m_xpSidList[i].bUseLocalFree)
                    LocalFree(m_xpSidList[i].pSid);
                else
                    FreeSid(m_xpSidList[i].pSid);
}


BOOL CSecDesc::ReAllocSidList()
{
    XPtrLF<SidStruct>  xSidListNew;


    //
    // first allocate a larger buffer
    //

    xSidListNew = (SidStruct *)LocalAlloc(LPTR, sizeof(SidStruct)*(m_cAllocated+DEFAULT_ACE_NUM));

    if (!xSidListNew) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::ReallocArgStrings  Cannot add memory, error = %d", GetLastError());
        m_bFailed = TRUE;
        return FALSE;
    }


    //
    // copy the arguments
    //

    for (DWORD i = 0; i < (m_cAllocated); i++) {
        xSidListNew[i] = m_xpSidList[i];
    }

    m_xpSidList = xSidListNew.Acquire();
    m_cAllocated+= DEFAULT_ACE_NUM;

    return TRUE;
}



BOOL CSecDesc::AddLocalSystem(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddLocalSystem: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddLocalSystem: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}


BOOL CSecDesc::AddAdministrators(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}


BOOL CSecDesc::AddAdministratorsAsOwner()
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    m_xpOwnerSid = xSid.Acquire();

    m_bFailed = FALSE;
    return TRUE;
}

BOOL CSecDesc::AddAdministratorsAsGroup()
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    m_xpGrpSid = xSid.Acquire();

    m_bFailed = FALSE;
    return TRUE;
}


BOOL CSecDesc::AddEveryOne(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddEveryOne: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddEveryOne: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}


#if 0

BOOL CSecDesc::AddThisUser(HANDLE hToken, DWORD dwAccess, DWORD AceFlags)
{
    XPtrLF<SID>             xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddThisUser: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;
    
    xSid = (SID *)GetUserSid(hToken);        

    if (!pSid) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddThisUser: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }
    
    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;

    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].bUseLocalFree = TRUE;    
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}
#endif



BOOL CSecDesc::AddUsers(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;


    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {

         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddUsers: Failed to initialize sid.  Error = %d", GetLastError());
         return FALSE;
    }


    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}

BOOL CSecDesc::AddAuthUsers(DWORD dwAccess, DWORD AceFlags)
{
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    XPtr<SID, FreeSid>          xSid;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAuthUsers: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;


    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_AUTHENTICATED_USER_RID,
                                   0, 0, 0, 0, 0, 0, 0, (PSID *)&xSid)) {

         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAuthUsers: Failed to initialize authenticated users sid.  Error = %d", GetLastError());
         return FALSE;
     }
     

    if (m_cAces == m_cAllocated)
        if (!ReAllocSidList())
            return FALSE;


    m_xpSidList[m_cAces].pSid = xSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}

BOOL CSecDesc::AddSid(PSID pSid, DWORD dwAccess, DWORD AceFlags)
{
    XPtrLF<SID>    pLocalSid = 0;
    DWORD          dwSidLen = 0;
    
    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddSid: Not initialised or failure.");
         return FALSE;
    }
    
    m_bFailed = TRUE;

    if (!IsValidSid(pSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddSid: Not a vaild Sid.");
         return FALSE;
    }


    dwSidLen = GetLengthSid(pSid);

    pLocalSid = (SID *)LocalAlloc(LPTR, dwSidLen);
    if (!pLocalSid) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddSid: Couldn't allocate memory. Error %d", GetLastError());
         return FALSE;
    }

    
    if (!CopySid(dwSidLen, pLocalSid, pSid)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddSid: Couldn't copy Sid. Error %d", GetLastError());
         return FALSE;
    }
    
    
    m_xpSidList[m_cAces].pSid = (SID *)pLocalSid.Acquire();
    m_xpSidList[m_cAces].dwAccess = dwAccess;
    m_xpSidList[m_cAces].bUseLocalFree = TRUE;    
    m_xpSidList[m_cAces].AceFlags = AceFlags;
    m_cAces++;


    m_bFailed = FALSE;
    return TRUE;
}


PISECURITY_DESCRIPTOR CSecDesc::MakeSD()
{
    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    PACL    pAcl = 0;
    DWORD   cbMemSize;
    DWORD   cbAcl;
    DWORD   i;    
    
    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeSD: Not initialised or failure.");
         return NULL;
    }
    
    m_bFailed = TRUE;

    cbAcl = 0;

    for (i = 0; i < m_cAces; i++) 
        cbAcl+= GetLengthSid((SID *)(m_xpSidList[i].pSid));

    cbAcl += sizeof(ACL) + m_cAces*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));
    

    //
    // Allocate space for the SECURITY_DESCRIPTOR + ACL
    //

    cbMemSize = sizeof( SECURITY_DESCRIPTOR ) + cbAcl;

    xsd = (PISECURITY_DESCRIPTOR) LocalAlloc(LPTR, cbMemSize);

    if (!xsd) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::MakeSD: Failed to alocate security descriptor.  Error = %d", GetLastError());
        return NULL;
    }


    //
    // increment psd by sizeof SECURITY_DESCRIPTOR
    //

    pAcl = (PACL) ( ( (unsigned char*)((SECURITY_DESCRIPTOR *)xsd) ) + sizeof(SECURITY_DESCRIPTOR) );

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::MakeSD: Failed to initialize acl.  Error = %d", GetLastError());
        return NULL;
    }


    //
    // Add each of the new ACEs
    //
    
    for (i = 0; i < m_cAces; i++) {
        if (!AddAccessAllowedAceEx(pAcl, ACL_REVISION, m_xpSidList[i].AceFlags, m_xpSidList[i].dwAccess, m_xpSidList[i].pSid)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::MakeSD: Failed to add ace (%d).  Error = %d", i, GetLastError());
            return NULL;
        }
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(xsd, SECURITY_DESCRIPTOR_REVISION)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeGenericSecurityDesc: Failed to initialize security descriptor.  Error = %d", GetLastError());
        return NULL;
    }

    if (!SetSecurityDescriptorDacl(xsd, TRUE, pAcl, FALSE)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeGenericSecurityDesc: Failed to set security descriptor dacl.  Error = %d", GetLastError());
        return NULL;
    }


    if (m_xpOwnerSid) {
        if (!SetSecurityDescriptorOwner(xsd, m_xpOwnerSid, 0)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeGenericSecurityDesc: Failed to set security descriptor dacl.  Error = %d", GetLastError());
            return NULL;
        }
    }

    if (m_xpGrpSid) {
        if (!SetSecurityDescriptorGroup(xsd, m_xpGrpSid, 0)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"MakeGenericSecurityDesc: Failed to set security descriptor dacl.  Error = %d", GetLastError());
            return NULL;
        }
    }



    m_bFailed = FALSE;
    return xsd.Acquire();    
}


PISECURITY_DESCRIPTOR CSecDesc::MakeSelfRelativeSD()
{
    XPtrLF<SECURITY_DESCRIPTOR> xAbsoluteSD;
    DWORD dwLastError;

    if ((!m_bInitialised) || (m_bFailed)) {
         dbg.Msg( DEBUG_MESSAGE_WARNING, L"AddAdministrators: Not initialised or failure.");
         return FALSE;
    }
    
    xAbsoluteSD = MakeSD();

    if (!xAbsoluteSD) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"CSecDesc::MakeSelfRelativeSD: Failed to set security descriptor dacl.  Error = %d", GetLastError());
        return NULL;
    }

    m_bFailed = TRUE;


    //
    // Make a new self-relative SD here
    //

    DWORD dwBufferLength = 0;
    ::MakeSelfRelativeSD( xAbsoluteSD, 0, &dwBufferLength);

    dwLastError = GetLastError();
    if((dwLastError != ERROR_INSUFFICIENT_BUFFER) || !dwBufferLength)
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CSecDesc::MakeSelfRelativeSD:  MakeSelfRelativeSD failed, 0x%X", dwLastError );
        return NULL;
    }


    XPtrLF<SECURITY_DESCRIPTOR> xsd = reinterpret_cast<SECURITY_DESCRIPTOR*>(LocalAlloc(LPTR, dwBufferLength));
    if(!xsd)
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CSecDesc::MakeSelfRelativeSD:  MakeSelfRelativeSD failed, 0x%X", E_OUTOFMEMORY );
        return NULL;
    }

    BOOL bRes = ::MakeSelfRelativeSD( xAbsoluteSD, xsd, &dwBufferLength);

    if (!bRes) {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"CSecDesc::MakeSelfRelativeSD:  MakeSelfRelativeSD failed, 0x%X", GetLastError() );
        return NULL;
    }

    m_bFailed = FALSE;
    return xsd.Acquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\rsopinc.h ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        RsopInc.h
//
// Description: Headers for utility functions
//
// History:     8-26-99   NishadM    Created
//
//*************************************************************

#ifndef __RSOPINC_H__
#define __RSOPINC_H__

//****************************************************
// Definitions used in constructing the name spaces.
//
// PM Stands for Planning Mode Provider
// SM stands for Snapshot Mode Provider
//
// DIAG for diagnostic logging
//****************************************************

#define RSOP_MOF_SCHEMA_VERSION         0x00210000

#define RSOP_NS_ROOT                    L"\\\\.\\Root\\Rsop"
#define RSOP_NS_PM_ROOT                 RSOP_NS_ROOT
#define RSOP_NS_SM_ROOT                 RSOP_NS_ROOT
#define RSOP_NS_DIAG_ROOT               RSOP_NS_ROOT
#define RSOP_NS_ROOT_LEN                20

// Garbage collectable name spaces
#define RSOP_NS_TEMP_PREFIX             L"NS"
#define RSOP_NS_TEMP_FMT                L"\\\\.\\Root\\Rsop\\"RSOP_NS_TEMP_PREFIX L"%s"

#define RSOP_NS_TEMP_LEN                100

#define RSOP_NS_PM_FMT                  RSOP_NS_TEMP_FMT
#define RSOP_NS_SM_FMT                  RSOP_NS_TEMP_FMT

// user offsets
#define RSOP_NS_USER_OFFSET             L"User"
#define RSOP_NS_PM_USER_OFFSET          RSOP_NS_USER_OFFSET
#define RSOP_NS_SM_USER_OFFSET          RSOP_NS_USER_OFFSET
#define RSOP_NS_DIAG_ROOTUSER_OFFSET    RSOP_NS_USER_OFFSET

// The code assumes that this is a Sid when the name is generated and
// and when users are enumerated in snapshot provider.

#define RSOP_NS_DIAG_USER_OFFSET_FMT    L"User\\%s"

// machine offsets
#define RSOP_NS_MACHINE_OFFSET          L"Computer"
#define RSOP_NS_PM_MACHINE_OFFSET       RSOP_NS_MACHINE_OFFSET
#define RSOP_NS_SM_MACHINE_OFFSET       RSOP_NS_MACHINE_OFFSET
#define RSOP_NS_DIAG_MACHINE_OFFSET     RSOP_NS_MACHINE_OFFSET

#define RSOP_NS_MAX_OFFSET_LEN          20

// user
#define RSOP_NS_USER                    L"\\\\.\\Root\\Rsop\\User"
#define RSOP_NS_SM_USER                 RSOP_NS_USER
#define RSOP_NS_PM_USER                 RSOP_NS_USER
#define RSOP_NS_DIAG_USERROOT           RSOP_NS_USER

#define RSOP_NS_DIAG_USER_FMT           L"\\\\.\\Root\\Rsop\\User\\%s"

// machine
#define RSOP_NS_MACHINE                 L"\\\\.\\Root\\Rsop\\Computer"
#define RSOP_NS_SM_MACHINE              RSOP_NS_MACHINE
#define RSOP_NS_PM_MACHINE              RSOP_NS_MACHINE
#define RSOP_NS_DIAG_MACHINE            RSOP_NS_MACHINE

// remote name spaces
#define RSOP_NS_REMOTE_ROOT_FMT         L"\\\\%s\\Root\\Rsop"
#define RSOP_NS_SM_REMOTE_ROOT_FMT      RSOP_NS_REMOTE_ROOT_FMT
#define RSOP_NS_PM_REMOTE_ROOT_FMT      RSOP_NS_REMOTE_ROOT_FMT

// user
#define RSOP_NS_REMOTE_USER_FMT             L"\\\\%s\\Root\\Rsop\\User"
#define RSOP_NS_SM_REMOTE_USER_FMT          RSOP_NS_REMOTE_USER_FMT
#define RSOP_NS_PM_REMOTE_USER_FMT          RSOP_NS_REMOTE_USER_FMT
#define RSOP_NS_DIAG_REMOTE_USERROOT_FMT    RSOP_NS_REMOTE_USER_FMT

#define RSOP_NS_DIAG_REMOTE_USER_FMT        L"\\\\%s\\Root\\Rsop\\User\\%s"

// machine
#define RSOP_NS_REMOTE_MACHINE_FMT      L"\\\\%s\\Root\\Rsop\\Computer"
#define RSOP_NS_SM_REMOTE_MACHINE_FMT   RSOP_NS_REMOTE_MACHINE_FMT
#define RSOP_NS_PM_REMOTE_MACHINE_FMT   RSOP_NS_REMOTE_MACHINE_FMT

// check to make sure that the namespace is under root\rsop                                                        
#define RSOP_NS_ROOT_CHK                L"root\\rsop\\"   
             
#define RSOP_ALL_PERMS              (WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | \
                                    WBEM_WRITE_PROVIDER | WBEM_REMOTE_ACCESS | READ_CONTROL |  WRITE_DAC) 

#define RSOP_READ_PERMS             (WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_REMOTE_ACCESS | READ_CONTROL )

// WMI bits passed as generic mask into AccessCheck

#define WMI_GENERIC_READ    1
#define WMI_GENERIC_WRITE   0x1C
#define WMI_GENERIC_EXECUTE 0x2
#define WMI_GENERIC_ALL     0x6001f


#ifdef  __cplusplus
extern "C" {
#endif

#define DEFAULT_NAMESPACE_TTL_MINUTES 1440 

HRESULT
CopyNameSpace(  LPCWSTR         wszSrc,
                LPCWSTR         wszDest,
                BOOL            bCopyInstances,
                BOOL*           pbAbort,
                IWbemLocator*   pWbemLocator );



/*
HRESULT
SetupNewNameSpacePlanningMode(  LPWSTR              *pwszNameSpace,
                                LPWSTR               szRemoteComputer,
                                IWbemLocator        *pWbemLocator,
                                PSECURITY_DESCRIPTOR pSDUser,
                                PSECURITY_DESCRIPTOR pSDMach );

HRESULT
SetupNewNameSpaceDiagMode(  LPWSTR              *pwszNameSpace,
                            LPWSTR               szRemoteComputer,
                            LPWSTR               szUserSid,
                            IWbemLocator        *pWbemLocator);
*/
  
// SetupNewNameSpace flags 
#define SETUP_NS_PM             0x1
#define SETUP_NS_SM             0x2
#define SETUP_NS_SM_NO_USER     0x4
#define SETUP_NS_SM_NO_COMPUTER 0x8
#define SETUP_NS_SM_INTERACTIVE 0x10


HRESULT
SetNameSpaceSecurity(   LPCWSTR szNamespace, 
                        PSECURITY_DESCRIPTOR pSD,
                        IWbemLocator* pWbemLocator);


HRESULT
GetNameSpaceSecurity(   LPCWSTR szNamespace, 
                        PSECURITY_DESCRIPTOR *ppSD,
                        IWbemLocator* pWbemLocator);
        
HRESULT 
SetupNewNameSpace(
                        LPWSTR              *pwszNameSpace,
                        LPWSTR               szRemoteComputer,
                        LPWSTR               szUserSid,
                        PSID                 pSid,
                        IWbemLocator        *pWbemLocator,
                        DWORD                dwFlags,
                        DWORD               *pdwExtendedInfo);
                        
HRESULT 
ProviderDeleteRsopNameSpace( IWbemLocator *pWbemLocator, 
                             LPWSTR szNameSpace, 
                             HANDLE hToken, 
                             LPWSTR szSidString, 
                             DWORD dwFlags);


BOOL IsInteractiveNameSpace(WCHAR *pwszNameSpace, WCHAR *szSid);
HRESULT GetInteractiveNameSpace(WCHAR *szSid, LPWSTR *szNameSpace);


// copy flags
#define NEW_NS_FLAGS_COPY_CLASSES     1                // Copy Instances
#define NEW_NS_FLAGS_COPY_SD          2                // Copy Security Descriptor
#define NEW_NS_FLAGS_COPY_INSTS       4                // Copy Classes

HRESULT
CreateAndCopyNameSpace( IWbemLocator *pWbemLocator,
                        LPWSTR szSrcNameSpace,
                        LPWSTR szDstRootNameSpace,
                        LPWSTR szDstRelNameSpace, 
                        DWORD dwFlags,
                        PSECURITY_DESCRIPTOR pSecDesc,
                        LPWSTR *szDstNameSpaceOut);

// WMI doesn't like '-' in names. so to create an entry in WMI space
// using Sid use these 2 utility functions.

void ConvertSidToWMIName(LPTSTR lpSid, LPTSTR lpWmiName);
void ConvertWMINameToSid(LPTSTR lpWmiName, LPTSTR lpSid);

HRESULT
DeleteNameSpace( WCHAR *pwszNameSpace, WCHAR *pwszParentNameSpace, IWbemLocator *pWbemLocator );
HRESULT
DeleteRsopNameSpace( WCHAR *pwszNameSpace, IWbemLocator *pWbemLocator );

HRESULT
GetWbemServicesPtr( LPCWSTR         wszNameSpace,
                    IWbemLocator**  ppLocator,
                    IWbemServices** ppServices );


/*
typedef struct __tagPrincipal
{
    LPWSTR  szName; // e.g. Administrators, "Domain Admins"
    bool    bLocal; // e.g. true, false
} Principal;
*/

#ifdef  __cplusplus
}   // extern "C" {
#endif

#ifdef  __cplusplus

/*
class CPrincipals
{
    private:
        Principal*  m_pPrincipals;
        DWORD       m_nPrincipals;
        bool        m_bNormalized;
    public:
        CPrincipals( Principal* pPrin, DWORD dwPrin = 0 ) : m_pPrincipals(pPrin), m_nPrincipals(dwPrin)
        {
        };
        ~CPrincipals()
        {
            if ( m_bNormalized )
            {
                for ( DWORD i = 0 ; i < m_nPrincipals ; i++ )
                {
                    if ( !m_pPrincipals[i].bLocal && m_pPrincipals[i].szName )
                    {
                        LocalFree( m_pPrincipals[i].szName );
                    }
                }
            }
        };
        HRESULT NormalizePrincipals( LPWSTR szDomainName )
        {
            HRESULT hr = S_OK;
            
            for ( DWORD i = 0 ; i < m_nPrincipals ; i++ )
            {
                if ( !m_pPrincipals[i].bLocal )
                {
                    LPWSTR sz = ( LPWSTR )LocalAlloc( LPTR, sizeof( WCHAR ) * ( wcslen(szDomainName) + wcslen(m_pPrincipals[i].szName) + 2 ) );

                    if ( sz )
                    {
                        wcscpy( sz, szDomainName );
                        wcscat( sz, L"\\" );
                        wcscat( sz, m_pPrincipals[i].szName );
                    }
                    else
                    {
                        hr = GetLastError();
                    }
                    m_pPrincipals[i].szName = sz;            
                }
            }
            m_bNormalized = true;
            return hr;
        };
        void GetPrincipals( DWORD nCount, LPWSTR* pszNames )
        {
            for ( DWORD i = 0 ; i < m_nPrincipals && i < nCount ; i ++ )
            {
                pszNames[i] = m_pPrincipals[i].szName;
            }
        };
};
*/
  
class CFailRetStatus
{

private:
        IWbemObjectSink*    m_pResponseHandler;  // We don't own m_pResponseHandler
        HRESULT             m_hr;

public:
        CFailRetStatus( IWbemObjectSink* pResponseHandler )
           : m_pResponseHandler(pResponseHandler),
           m_hr( 0 )
        {
        }

        ~CFailRetStatus()
        {
            if ( m_pResponseHandler )
                m_pResponseHandler->SetStatus( WBEM_STATUS_COMPLETE, m_hr, NULL, NULL );
        }

        void SetError( HRESULT hr )
        {
            m_hr = hr;
        }

};

#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif


#endif

#endif // __RSOPINC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\rsopdbg.h ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        RsopDbg.h
//
// Description: Debugging functions
//
// History:     8-20-99   leonardm    Created
//
//*************************************************************

#ifndef DEBUG_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_
#define DEBUG_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_

#include "rsoputil.h"
#include "smartptr.h"

//
// Debug Levels
//

const DWORD DEBUG_LEVEL_NONE =     0x00000000;
const DWORD DEBUG_LEVEL_WARNING =  0x00000001;
const DWORD DEBUG_LEVEL_VERBOSE =  0x00000002;


//
// Debug message output destination
//

const DWORD DEBUG_DESTINATION_LOGFILE =  0x00010000;
const DWORD DEBUG_DESTINATION_DEBUGGER = 0x00020000;


//
// Debug message types
//

const DWORD DEBUG_MESSAGE_ASSERT =   0x00000001;
const DWORD DEBUG_MESSAGE_WARNING =  0x00000002;
const DWORD DEBUG_MESSAGE_VERBOSE =  0x00000004;



//*************************************************************
//
// Class:
//
// Description:
//
//*************************************************************

class CDebug
{
private:
    CWString _sRegPath;
    CWString _sKeyName;

    CWString _sLogFilename;
    CWString _sBackupLogFilename;

    bool _bInitialized;

    DWORD _dwDebugLevel;

    XCritSec xCritSec;
    
    void CleanupAndCheckForDbgBreak(DWORD dwErrorCode, DWORD dwMask);

public:
    CDebug();
    CDebug( const WCHAR* sRegPath,
                const WCHAR* sKeyName,
                const WCHAR* sLogFilename,
                const WCHAR* sBackupLogFilename,
                bool bResetLogFile = false);

    bool Initialize(const WCHAR* sRegPath,
                    const WCHAR* sKeyName,
                    const WCHAR* sLogFilename,
                    const WCHAR* sBackupLogFilename,
                    bool bResetLogFile = false);

    bool Initialize(bool bResetLogFile = false);

    void Msg(DWORD dwMask, LPCTSTR pszMsg, ...);
};

extern CDebug dbgRsop;
extern CDebug dbgCommon;
extern CDebug dbgAccessCheck;

// default to dbgRsop..
// The common routines need to define it to dbgCommon or #define dbg to dbgCommon and then
// use..

#define dbg dbgRsop


#endif // DEBUG_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\rsopsec.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        RsopSec.h
//
// Description: RSOP Namespace Security functions
//
// History:     8-26-99   leonardm    Created
//
//******************************************************************************

#ifndef _RSOPSEC_H__89DD6583_B442_41d6_B300_EFE4326A6752__INCLUDED
#define _RSOPSEC_H__89DD6583_B442_41d6_B300_EFE4326A6752__INCLUDED

#include "smartptr.h"

#ifdef  __cplusplus
extern "C" {
#endif

HRESULT SetNamespaceSecurity(const WCHAR* pszNamespace,
                             long lSecurityLevel,
                             IWbemServices* pWbemServices=NULL);

HRESULT SetNamespaceSD( SECURITY_DESCRIPTOR* pSD, IWbemServices* pWbemServices);
HRESULT GetNamespaceSD( IWbemServices* pWbemServices, SECURITY_DESCRIPTOR** ppSD);
HRESULT RSoPMakeAbsoluteSD(SECURITY_DESCRIPTOR* pSelfRelativeSD, SECURITY_DESCRIPTOR** ppAbsoluteSD);
HRESULT FreeAbsoluteSD(SECURITY_DESCRIPTOR* pAbsoluteSD);

LPWSTR GetSOM( LPCWSTR szAccount );
DWORD GetDomain( LPCWSTR szSOM, LPWSTR *pszDomain );


HRESULT AuthenticateUser(HANDLE  hToken, 
                         LPCWSTR szMachSOM, 
                         LPCWSTR szUserSOM, 
                         BOOL    bLogging,
                         DWORD  *pdwExtendedInfo);


//
// lSecurityLevels
//

const long NAMESPACE_SECURITY_DIAGNOSTIC = 0;
const long NAMESPACE_SECURITY_PLANNING = 1;

PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);

#ifdef  __cplusplus
}   // extern "C" {
#endif


typedef struct _SidStruct {
    PSID    pSid;
    DWORD   dwAccess;
    BOOL    bUseLocalFree;
    DWORD   AceFlags;
} SidStruct;
        

// need to add code for inheritted aces..
class CSecDesc
{
    private:
        XPtrLF<SidStruct> m_xpSidList;        
        DWORD             m_cAces;
        DWORD             m_cAllocated;
        BOOL              m_bInitialised;
        BOOL              m_bFailed;
        XPtrLF<SID>       m_xpOwnerSid;
        XPtrLF<SID>       m_xpGrpSid;

    
       // Not implemented.
       CSecDesc(const CSecDesc& x);
       CSecDesc& operator=(const CSecDesc& x);

       BOOL ReAllocSidList();
    
public:
    CSecDesc();
   ~CSecDesc();
   BOOL AddLocalSystem(DWORD dwAccess=GENERIC_ALL, DWORD AceFlags=0);
   BOOL AddAdministrators(DWORD dwAccess=GENERIC_ALL, DWORD AceFlags=0);
   BOOL AddEveryOne(DWORD dwAccess, DWORD AceFlags=0);
   BOOL AddAdministratorsAsOwner();
   BOOL AddAdministratorsAsGroup();

    //   BOOL AddThisUser(HANDLE hToken, DWORD dwAccess, BYTE AceFlags=0);   

    // This cannot be implemented here currently because it needs to call
    // GetUserSid which is in userenv\sid.c. To add that code we need to add the
    // common headers..

   BOOL AddUsers(DWORD dwAccess, DWORD AceFlags=0);
   BOOL AddAuthUsers(DWORD dwAccess, DWORD AceFlags=0);
   BOOL AddSid(PSID pSid, DWORD dwAccess, DWORD AceFlags=0);
   PISECURITY_DESCRIPTOR MakeSD();   
   PISECURITY_DESCRIPTOR MakeSelfRelativeSD();
};

#endif // _RSOPSEC_H__89DD6583_B442_41d6_B300_EFE4326A6752__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\smartptr.h ===
//*************************************************************
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        smartptr.h
//
// Contents:    Classes for smart pointers
//
// History:     7-Jun-99       SitaramR    Created
//
//              2-Dec-99       LeonardM    Major revision and cleanup.
//
//*************************************************************

#ifndef SMARTPTR_H
#define SMARTPTR_H

#include <comdef.h>
#include "userenv.h"

#pragma once
#pragma warning(disable:4284)


//*************************************************************
//
//  Class:      XPtrST
//
//  Purpose:    Smart pointer template to wrap pointers to a single type.
//
//*************************************************************

template<class T> class XPtrST
{

private:

    XPtrST (const XPtrST<T>& x);
    XPtrST<T>& operator=(const XPtrST<T>& x);

    T* _p;

public:

    XPtrST(T* p = NULL) : _p(p){}

    ~XPtrST(){ delete _p; }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            delete _p;
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XPtrArray
//
//  Purpose:    Smart pointer template to wrap pointers to an array .
//
//*************************************************************

template<class T> class XPtrArray
{

private:

    XPtrArray (const XPtrArray<T>& x);
    XPtrArray<T>& operator=(const XPtrArray<T>& x);

    T* _p;

public:

    XPtrArray(T* p = NULL) : _p(p){}

    ~XPtrArray(){ delete[] _p; }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            delete[] _p;
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};



//*************************************************************
//
//  Class:      XInterface
//
//  Purpose:    Smart pointer template for items Release()'ed, not ~'ed
//
//*************************************************************

template<class T> class XInterface
{

private:

    XInterface(const XInterface<T>& x);
    XInterface<T>& operator=(const XInterface<T>& x);

    T* _p;

public:

    XInterface(T* p = NULL) : _p(p){}

    ~XInterface()
    {
        if (_p)
        {
            _p->Release();
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if (_p)
        {
            _p->Release();
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};



//*************************************************************
//
//  Class:      XBStr
//
//  Purpose:    Smart pointer class for BSTRs
//
//*************************************************************

class XBStr
{

private:

    XBStr(const XBStr& x);
    XBStr& operator=(const XBStr& x);

    BSTR _p;

public:

    XBStr(WCHAR* p = 0) : _p(0)
    {
        if(p)
        {
            _p = SysAllocString(p);
        }
    }

    ~XBStr()
    {
        SysFreeString(_p);
    }

    operator BSTR(){ return _p; }

    void operator=(WCHAR* p)
    {
        SysFreeString(_p);
        _p = p ? SysAllocString(p) : NULL;
    }

    BSTR Acquire()
    {
        BSTR p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XSafeArray
//
//  Purpose:    Smart pointer class for SafeArrays
//
//*************************************************************

class XSafeArray
{

private:

    XSafeArray(const XSafeArray& x);
    XSafeArray& operator=(const XSafeArray& x);

    SAFEARRAY* _p;

public:

    XSafeArray(SAFEARRAY* p = 0) : _p(p){}

    ~XSafeArray()
    {
        if (_p)
        {
            SafeArrayDestroy(_p);
        }
    }

    operator SAFEARRAY*(){ return _p; }

    SAFEARRAY ** operator&(){ return &_p; }

    void operator=(SAFEARRAY* p)
    {
        if(_p)
        {
            SafeArrayDestroy(_p);
        }

        _p = p;
    }

    SAFEARRAY* Acquire()
    {
        SAFEARRAY* p = _p;
        _p = 0;
        return p;
    }

};


//*************************************************************
//
//  Class:      XVariant
//
//  Purpose:    Smart pointer class for Variants
//
//*************************************************************

class XVariant
{

private:

    XVariant(const XVariant& x);
    XVariant& operator=(const XVariant& x);

    VARIANT* _p;

public:

    XVariant(VARIANT* p = 0) : _p(p){}

    ~XVariant()
    {
        if (_p)
        {
            VariantClear(_p);
        }
    }

    void operator=(VARIANT* p)
    {
        if(_p)
        {
            VariantClear(_p);
        }
        _p = p;
    }

    operator VARIANT*(){ return _p; }

    VARIANT* Acquire()
    {
        VARIANT* p = _p;
        _p = 0;
        return p;
    }

};

//*************************************************************
//
//  Class:      XPtrLF
//
//  Purpose:    Smart pointer template for pointers that should be LocalFree()'d
//
//*************************************************************

template <typename T> class XPtrLF
{

private:

    XPtrLF(const XPtrLF<T>& x);
    XPtrLF<T>& operator=(const XPtrLF<T>& x);

    T* _p;

public:

    XPtrLF(HLOCAL p = 0 ) :
            _p((T*)p)
    {
    }

    ~XPtrLF()
    {
        if(_p)
        {
            LocalFree(_p);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            LocalFree(_p);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = NULL;
        return p;
    }

};

//*************************************************************
//
//  Class:      XPtr
//
//  Purpose:    Smart pointer template for pointers that provide
//              a custom free memory routine
//
//*************************************************************

typedef HLOCAL (__stdcall *PFNFREE)(HLOCAL);

//
// usage : XPtr<SID, FreeSid> xptrSid;
//

template <typename T, PFNFREE _f> class XPtr
{
private:
    XPtr(const XPtr<T, _f>& x);
    XPtr<T, _f>& operator=(const XPtr<T, _f>& x);
    T* _p;

public:

    XPtr( HLOCAL p = 0 ) :
            _p( reinterpret_cast<T*>( p ) )
    {
    }

    ~XPtr()
    {
        if(_p)
        {
            _f(_p);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            _f(_p);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = NULL;
        return p;
    }
};

//*************************************************************
//
//  Class:      XArray
//
//  Purpose:    Smart pointer template for pointers that provide
//              a custom free memory routine
//
//*************************************************************

typedef HLOCAL (__stdcall *PFNARRAYFREE)(HLOCAL, int);

//
// usage : XArray<EXPLICIT_ACCESS, 10> xaExplicitAccess( FreeAccessArray );
//

template <typename T, int nElements> class XArray
{
private:
    XArray(const XArray<T,nElements>& x);
    XArray<T,nElements>& operator=(const XArray<T,nElements>& x);
    T* _p;
    int _n;
    PFNARRAYFREE _f;

public:

    XArray( PFNARRAYFREE pfnFree, HLOCAL p = 0 ) :
            _p( reinterpret_cast<T*>( p ) ), _f( pfnFree ), _n( nElements )
    {
    }

    ~XArray()
    {
        if(_p)
        {
            _f(_p, _n);
        }
    }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            _f(_p, _n);
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p, _p = 0;
        return p;
    }
};

//******************************************************************************
//
// Class:
//
// Description:
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
class XHandle
{
private:
    HANDLE _h;

public:
    XHandle(HANDLE h = NULL) : _h(h) {}
    ~XHandle()
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            CloseHandle(_h);
        }
    }
    HANDLE* operator&(){return &_h;}
    operator HANDLE(){return _h;}

    void operator=(HANDLE h)
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            CloseHandle(_h);
        }
        _h = h;
    }
};

class XKey
{
private:
    HKEY _h;

public:
    XKey(HKEY h = NULL) : _h(h) {}
    ~XKey()
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            RegCloseKey(_h);
        }
    }
    HKEY* operator&(){return &_h;}
    operator HKEY(){return _h;}

    void operator=(HKEY h)
    {
        if(_h && _h != INVALID_HANDLE_VALUE)
        {
            RegCloseKey(_h);
        }
        _h = h;
    }
};


class XCoInitialize
{
public:
    XCoInitialize()
    {
        m_hr = CoInitializeEx( 0, COINIT_MULTITHREADED );
    };

    ~XCoInitialize()
    {
        if ( SUCCEEDED( m_hr ) )
        {
            CoUninitialize();
        }
    };

    HRESULT Status()
    {
        return m_hr;
    };

private:
    HRESULT      m_hr;
};

class XImpersonate
{
public:
    XImpersonate() : m_hImpToken( 0 ), m_hThreadToken( 0 )
    {
        m_hr = CoImpersonateClient();
    };

    XImpersonate( HANDLE hToken ) : m_hThreadToken( 0 ), m_hImpToken( hToken )
    {
        OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &m_hThreadToken );
        ImpersonateLoggedOnUser( hToken );
        m_hr = GetLastError();
    };

    ~XImpersonate()
    {
        if ( SUCCEEDED( m_hr ) )
        {
            if ( m_hImpToken )
            {
                SetThreadToken( 0, m_hThreadToken);
            }
            else
            {
                CoRevertToSelf();
            }
        }
    };

    HRESULT Status()
    {
        return m_hr;
    };

private:
    HRESULT     m_hr;
    XHandle     m_hThreadToken;
    HANDLE      m_hImpToken;   // we don't own this
};


//*************************************************************
//
//  Class:      XCriticalPolicySection
//
//  Purpose:    Smart pointer for freeing Group Policy critical section
//
//*************************************************************

class XCriticalPolicySection
{
private:
    HANDLE _h;

public:
    XCriticalPolicySection(HANDLE h = NULL) : _h(h){}
    ~XCriticalPolicySection()
    {
        if(_h)
        {
            LeaveCriticalPolicySection (_h);
        }
    }

    void operator=(HANDLE h)
    {
        if(_h)
        {
            LeaveCriticalPolicySection (_h);
        }
        _h = h;
    }
    
    operator bool() {return _h ? true : false;}
};


// critical section smartptr
class XCritSec
{
public:
    XCritSec()
    {
        lpCritSec = &CritSec;
        __try {
            InitializeCriticalSectionAndSpinCount(&CritSec, 0x80001000);
        }            
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // assumption, exception is out of memory
            // this is used in spewing debug messages. so cannot add a debug spew.
            lpCritSec = NULL;
        }            
    }

    ~XCritSec()
    {
        if (lpCritSec)
            DeleteCriticalSection(lpCritSec);
    }

    operator LPCRITICAL_SECTION(){return lpCritSec;}

    
private:
    CRITICAL_SECTION      CritSec;    
    LPCRITICAL_SECTION    lpCritSec;
};



// enter and exit critical section
class XEnterCritSec
{
public:
    XEnterCritSec(LPCRITICAL_SECTION lpCritSec) : m_lpCritSec( lpCritSec )
    {
        if (lpCritSec)
            EnterCriticalSection(lpCritSec);
    };

    
    ~XEnterCritSec()
    {
        if (m_lpCritSec)
            LeaveCriticalSection(m_lpCritSec);
    };


private:
    LPCRITICAL_SECTION      m_lpCritSec;   // we don't own this
};


//////////////////////////////////////////////////////////////////////
// XLastError
//
//
// Sets the Last Error Correctly..
//////////////////////////////////////////////////////////////////////

class XLastError
{
private:
    DWORD _e;

public:
    XLastError(){_e = GetLastError();}
    XLastError(DWORD e) : _e(e) {}
    ~XLastError(){SetLastError(_e);} 
    
    void operator=(DWORD e) {_e = e;}
    operator DWORD() {return _e;}
};



#endif SMARTPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\rsoputil.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:            RsopUtil.cpp
//
// Description:        
//
// History:    8-20-99   leonardm    Created
//
//******************************************************************************

#include <windows.h>
#include "RsopUtil.h"

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::CWString() : _pW(NULL), _len(0), _bState(false)
{
    _pW = new WCHAR[_len+1];

    if(_pW)
    {
        wcscpy(_pW, L"");
        _bState = true;
    }
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::CWString(const CWString& s) : _pW(NULL), _len(0), _bState(false)
{
    if(!s.ValidString())
    {
        return;
    }

    _len = s._len;

    _pW = new WCHAR[_len+1];

    if(_pW)
    {
        wcscpy(_pW, s._pW);
        _bState = true;
    }
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::CWString(const WCHAR* s) : _pW(NULL), _len(0), _bState(false)
{
    if(s)
    {
        _len = wcslen(s);
    }
    _pW = new WCHAR[_len+1];

    if(_pW)
    {
        wcscpy(_pW, s ? s : L"");
        _bState = true;
    }
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::~CWString()
{
    Reset();
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString& CWString::operator = (const CWString& s)
{
    if(&s == this)
    {
        return *this;
    }

    Reset();

    if(s.ValidString())
    {
        _len = s._len;
        _pW = new WCHAR[_len+1];
        if(_pW)
        {
            wcscpy(_pW, s._pW);
            _bState = true;
        }
    }

    return *this;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString& CWString::operator = (const WCHAR* s)
{
    Reset();

    _len = s ? wcslen(s) : 0;

    _pW = new WCHAR[_len+1];

    if(_pW)
    {
        wcscpy(_pW, s ? s : L"");
        _bState = true;
    }

    return *this;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
void CWString::Reset()
{
    if (_pW)
        delete[] _pW;
    _pW = NULL;
    _len =0;
    _bState = false;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString& CWString::operator += (const CWString& s)
{
    if(!s.ValidString())
    {
        Reset();
        return *this;
    }

    int newLen = _len + s._len;

    WCHAR* pW = new WCHAR[newLen+1];
    if(!pW)
    {
        Reset();
        return *this;
    }

    wcscpy(pW, _pW);
    wcscat(pW, s._pW);

    *this = pW;

    delete[] pW;

    return *this;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString CWString::operator + (const CWString& s) const
{
    if(!s.ValidString())
    {
        return *this;
    }

    CWString tmp;
    tmp.Reset();

    tmp._len = _len + s._len;
    tmp._pW = new WCHAR[tmp._len+1];

    if(!tmp._pW)
    {
        tmp.Reset();
        return tmp;
    }

    wcscpy(tmp._pW, _pW);
    wcscat(tmp._pW, s._pW);

    return tmp;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString operator + (const WCHAR* s1, const CWString& s2)
{
    CWString tmp;

    if(!s1 || !s2.ValidString())
    {
        return tmp;
    }

    tmp.Reset();

    tmp._len = wcslen(s1) + s2._len;
    tmp._pW = new WCHAR[tmp._len+1];

    if(!tmp._pW)
    {
        tmp.Reset();
        return tmp;
    }

    wcscpy(tmp._pW, s1);
    wcscat(tmp._pW, s2._pW);

    return tmp;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::operator const WCHAR* ()  const
{
    return _pW;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
CWString::operator WCHAR* ()  const
{
    return _pW;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::operator == (const WCHAR* s)  const
{
    CWString tmp = s;
    
    return (*this == tmp);
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::operator == (const CWString& s)  const
{
    if(!ValidString() || !s.ValidString())
    {
        return false;
    }

    if(&s == this)
    {
        return true;
    }

    if(_len != s._len || _bState != s._bState)
    {
        return false;
    }

    if(_wcsicmp(s._pW, _pW) != 0)
    {
        return false;
    }

    return true;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::CaseSensitiveCompare(const CWString& s)  const
{
    if(!ValidString() || !s.ValidString())
    {
        return false;
    }

    if(&s == this)
    {
        return true;
    }

    if(_len != s._len || _bState != s._bState)
    {
        return false;
    }

    if(wcscmp(s._pW, _pW) != 0)
    {
        return false;
    }

    return true;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::operator != (const CWString& s) const
{
    return !(*this == s);
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::operator != (const WCHAR* s) const
{
    CWString tmp = s;
    
    return !(*this == tmp);
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
int CWString::length() const
{
    return _len;
}

//******************************************************************************
//
// Function:    
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
bool CWString::ValidString() const
{
    return _bState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

//
//  For ease of debugging the SPMgr, all the debug support functions have
//  been stuck here.  Basically, we read info from win.ini, since that allows
//  us to configure the debug level via a text file (and DOS, for example).
//
//  Format is:
//
//  win.ini
//
//  [Gina]
//      DebugFlags=<Flag>[<,Flag>]*
//
//  WHERE:
//      Flag is one of the following:
//          Error, Warning, Trace
//

#if DBG         // NOTE:  This file not compiled for retail builds

#include "gina.h"
#include <stdio.h>
#include <wchar.h>

FILE *  LogFile;
DWORD   GINAInfoLevel = 3;



// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.

char   szSection[] = "Gina";
char * DebLevel[] = {"GINA-Error", "GINA-Warn", "GINA-Trace"
                    };

typedef struct _DebugKeys {
    char *  Name;
    DWORD   Value;
} DebugKeys, *PDebugKeys;

DebugKeys   DebugKeyNames[] = {
                {"Error",       DEB_ERROR},
                {"Warning",     DEB_WARN},
                {"Trace",       DEB_TRACE},
                };

#define NUM_DEBUG_KEYS  sizeof(DebugKeyNames) / sizeof(DebugKeys)
#define NUM_BREAK_KEYS  sizeof(BreakKeyNames) / sizeof(DebugKeys)

//+---------------------------------------------------------------------------
//
//  Function:   LogEvent
//
//  Synopsis:   Logs an event to the console and, optionally, a file.
//
//  Effects:
//
//  Arguments:  [Mask]   --
//              [Format] --
//              [Format] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
LogEvent(   long            Mask,
            const char *    Format,
            ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    char    szOutString[256];
    long    OriginalMask = Mask;


    if (Mask & GINAInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }
        if (Level >= (sizeof(DebLevel) / sizeof(char *)) )
        {
            Level = (sizeof(DebLevel) / sizeof(char *)) - 1;
        }


        //
        // Make the prefix first:  "Process.Thread> GINA-XXX"
        //

        PrefixSize = sprintf(szOutString, "%d.%d> %s: ",
                GetCurrentProcessId(), GetCurrentThreadId(), DebLevel[Level]);


        va_start(ArgList, Format);

        if (_vsnprintf(&szOutString[PrefixSize], sizeof(szOutString) - PrefixSize,
                            Format, ArgList) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("GINA!LogEvent:  Could not pack string into 256 bytes\n");

        }
        else
        {
            OutputDebugStringA(szOutString);
        }


        if (LogFile)
        {
            SYSTEMTIME  stTime;

            GetLocalTime(&stTime);
            fprintf(LogFile, "%02d:%02d:%02d.%03d: %s\n",
                    stTime.wHour, stTime.wMinute, stTime.wSecond,
                    stTime.wMilliseconds, szOutString);

            fflush(LogFile);
        }

    }

}

void
OpenLogFile(LPSTR   pszLogFile)
{
    LogFile = fopen(pszLogFile, "a");
    if (!LogFile)
    {
        OutputDebugStringA("GINA: Could not open logfile for append");
        OutputDebugStringA(pszLogFile);
    }
    DebugLog((DEB_TRACE, "Log file '%s' begins\n", pszLogFile));
}


DWORD
GetDebugKeyValue(
    PDebugKeys      KeyTable,
    int             cKeys,
    LPSTR           pszKey)
{
    int     i;

    for (i = 0; i < cKeys ; i++ )
    {
        if (_stricmp(KeyTable[i].Name, pszKey) == 0)
        {
            return(KeyTable[i].Value);
        }
    }
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadDebugParameters
//
//  Synopsis:   Loads debug parameters from win.ini
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
LoadDebugParameters(void)
{
    char    szVal[128];
    char *  pszDebug;
    int     cbVal;

    cbVal = GetProfileStringA(szSection, "DebugFlags", "Error,Warning", szVal, sizeof(szVal));

    pszDebug = strtok(szVal, ", \t");
    while (pszDebug)
    {
        GINAInfoLevel |= GetDebugKeyValue(DebugKeyNames, NUM_DEBUG_KEYS, pszDebug);
        pszDebug = strtok(NULL, ", \t");
    }

    cbVal = GetProfileStringA(szSection, "LogFile", "", szVal, sizeof(szVal));
    if (cbVal)
    {
        OpenLogFile(szVal);
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the GINAgr
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
InitDebugSupport(void)
{
    LoadDebugParameters();

}



#else // DBG

#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-94   RichardW   Created
//
//----------------------------------------------------------------------------


#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG

extern  DWORD   GINAInfoLevel;

#define DebugLog(x) LogEvent x


void    LogEvent(long, const char *, ...);
void    InitDebugSupport(void);

#define DEB_ERROR           0x00000001
#define DEB_WARN            0x00000002
#define DEB_TRACE           0x00000004



#else

#define DebugLog(x)

#endif



#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\wbemtime.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:            WbemTime.cpp
//
// Description:     Utility functions to convert between SYSTEMTIME and strings in
//                  WBEM datetime format.
//
// History:    12-08-99   leonardm    Created
//
//******************************************************************************

#include <wchar.h>
#include "smartptr.h"
#include "WbemTime.h"

//******************************************************************************
//
// Function:        SystemTimeToWbemTime
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         12/08/99        leonardm    Created.
//
//******************************************************************************

HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, XBStr& xbstrWbemTime)
{

    XPtrST<WCHAR> xTemp = new WCHAR[WBEM_TIME_STRING_LENGTH + 1];

    if(!xTemp)
    {
        return E_OUTOFMEMORY;
    }

    int nRes = swprintf(xTemp, L"%04d%02d%02d%02d%02d%02d.000000+000",
                sysTime.wYear,
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond);

    if(nRes != WBEM_TIME_STRING_LENGTH)
    {
        return E_FAIL;
    }

    xbstrWbemTime = xTemp;

    if(!xbstrWbemTime)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//******************************************************************************
//
// Function:        WbemTimeToSystemTime
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         12/08/99        leonardm    Created.
//
//******************************************************************************

HRESULT WbemTimeToSystemTime(XBStr& xbstrWbemTime, SYSTEMTIME& sysTime)
{
    if(!xbstrWbemTime || wcslen(xbstrWbemTime) != WBEM_TIME_STRING_LENGTH)
    {
        return ERROR_INVALID_PARAMETER;
    }

    for(int i = 0; i < 14; i++)
    {
        if(!iswdigit(xbstrWbemTime[i]))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }


    XPtrST<WCHAR>xpTemp = new WCHAR[5];
    if(!xpTemp)
    {
        return E_OUTOFMEMORY;
    }

    wcsncpy(xpTemp, xbstrWbemTime, 4);
    xpTemp[4] = L'\0';
    sysTime.wYear = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 4, 2);
    xpTemp[2] = L'\0';
    sysTime.wMonth = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 6, 2);
    xpTemp[2] = L'\0';
    sysTime.wDay = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 8, 2);
    xpTemp[2] = L'\0';
    sysTime.wHour = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 10, 2);
    xpTemp[2] = L'\0';
    sysTime.wMinute = (WORD)_wtol(xpTemp);

    wcsncpy(xpTemp, xbstrWbemTime + 12, 2);
    xpTemp[2] = L'\0';
    sysTime.wSecond = (WORD)_wtol(xpTemp);

    sysTime.wMilliseconds = 0;
    sysTime.wDayOfWeek = 0;

    return S_OK;
}

//*************************************************************
//
//  Function:   GetCurrentWbemTime
//
//  Purpose:    Gets the current date and time in WBEM format.
//
//  Parameters: xbstrCurrentTime -  Reference to XBStr which, on
//                                  success, receives the formated
//                                  string containing the current
//                                  date and time.
//
//  Returns:    On success it returns S_OK.
//              On failure, it returns E_OUTOFMEMORY.
//
//  History:    12/07/99 - LeonardM - Created.
//
//*************************************************************
HRESULT GetCurrentWbemTime(XBStr& xbstrCurrentTime)
{
    SYSTEMTIME sytemTime;
    GetSystemTime(&sytemTime);

    HRESULT hr = SystemTimeToWbemTime(sytemTime, xbstrCurrentTime);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\wbemtime.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:            WbemTime.h
//
// Description:     Utility functions to convert between SYSTEMTIME and strings in 
//                  WBEM datetime format.   
//
// History:    12-08-99   leonardm    Created
//
//******************************************************************************

#ifndef WBEMTIME_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_
#define WBEMTIME_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_


#ifdef  __cplusplus
extern "C" {
#endif


#define WBEM_TIME_STRING_LENGTH 25

//******************************************************************************
//
// Function:        SystemTimeToWbemTime
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:         12/08/99        leonardm    Created.
//
//******************************************************************************

HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, XBStr& xbstrWbemTime);


//******************************************************************************
//
// Function:        WbemTimeToSystemTime
//
// Description:    
//
// Parameters:    
//
// Return:        
//
// History:         12/08/99        leonardm    Created.
//
//******************************************************************************

HRESULT WbemTimeToSystemTime(XBStr& xbstrWbemTime, SYSTEMTIME& sysTime);


//*************************************************************
//
//  Function:   GetCurrentWbemTime
//
//  Purpose:    Gets the current date and time in WBEM format.
//
//  Parameters: xbstrCurrentTime -  Reference to XBStr which, on 
//                                  success, receives the formated
//                                  string containing the current 
//                                  date and time.
//
//  Returns:    On success it returns S_OK.
//              On failure, it returns E_OUTOFMEMORY.
//
//  History:    12/07/99 - LeonardM - Created.
//
//*************************************************************
HRESULT GetCurrentWbemTime(XBStr& xbstrCurrentTime);


#ifdef  __cplusplus
}   // extern "C" {
#endif


#endif // #ifndef WBEMTIME_H__D91F1DC7_B995_403d_9166_9D43DB050017__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\gina.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       gina.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include "gina.h"
#pragma hdrstop


HINSTANCE                   hDllInstance;   // My instance, for resource loading
HANDLE                      hGlobalWlx;     // Handle to tell winlogon who's calling
PWLX_DISPATCH_VERSION_1_0   pWlxFuncs;      // Ptr to table of functions

#define WINLOGON_APP        TEXT("Winlogon")
#define USERINIT            TEXT("Userinit")
#define USERINIT_DEFAULT    TEXT("Userinit.exe")



//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   DLL Entrance point
//
//  Arguments:  [hInstance]  --
//              [dwReason]   --
//              [lpReserved] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls ( hInstance );
            hDllInstance = hInstance;
#if DBG
            InitDebugSupport();
#endif
        case DLL_PROCESS_DETACH:
        default:
            return(TRUE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WlxNegotiate
//
//  Synopsis:   Negotiate version of interface with Winlogon
//
//  Arguments:  [dwWinlogonVersion] --
//              [pdwDllVersion]     --
//
//  Algorithm:
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxNegotiate(
    DWORD                   dwWinlogonVersion,
    DWORD                   *pdwDllVersion
    )
{
    if (dwWinlogonVersion < WLX_CURRENT_VERSION)
    {
        DebugLog((DEB_ERROR, "Unknown version: %d\n", dwWinlogonVersion));
        return(FALSE);
    }

    *pdwDllVersion = WLX_CURRENT_VERSION;

    DebugLog((DEB_TRACE, "Negotiate:  successful!\n"));

    return(TRUE);

}


//+---------------------------------------------------------------------------
//
//  Function:   WlxInitialize
//
//  Synopsis:   Initialize entrypoint from winlogon
//
//  Arguments:  [lpWinsta]           --
//              [hWlx]               --
//              [pvReserved]         --
//              [pWinlogonFunctions] --
//              [pWlxContext]        --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxInitialize(
    LPWSTR                  lpWinsta,
    HANDLE                  hWlx,
    PVOID                   pvReserved,
    PVOID                   pWinlogonFunctions,
    PVOID                   *pWlxContext
    )
{
    PGlobals  pGlobals;

    pWlxFuncs = (PWLX_DISPATCH_VERSION_1_0) pWinlogonFunctions;

    hGlobalWlx = hWlx;

    pGlobals = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(Globals));

    *pWlxContext = (PVOID) pGlobals;

    //
    // Read from registry...
    //

    pGlobals->fAllowNewUser = TRUE;


    pWlxFuncs->WlxUseCtrlAltDel(hWlx);

    InitCommonControls();

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxDisplaySASNotice
//
//  Synopsis:   Where we display the welcome, we're waiting dialog box
//
//  Arguments:  [pContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
WlxDisplaySASNotice(PVOID   pContext)
{
    int Result;

    Result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR) MAKEINTRESOURCE(IDD_WELCOME_DLG),
                                            NULL,
                                            WelcomeDlgProc,
                                            0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   WlxLoggedOutSAS
//
//  Synopsis:   Called when no one logged on...
//
//  Arguments:  [pWlxContext]       --
//              [dwSasType]         --
//              [pAuthenticationId] --
//              [pLogonSid]         --
//              [pdwOptions]        --
//              [phToken]           --
//              [pMprNotifyInfo]    --
//              [pProfile]          --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int
WINAPI
WlxLoggedOutSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType,
    PLUID                   pAuthenticationId,
    PSID                    pLogonSid,
    PDWORD                  pdwOptions,
    PHANDLE                 phToken,
    PWLX_MPR_NOTIFY_INFO    pMprNotifyInfo,
    PVOID *                 pProfile
    )
{
    int         result;
    // PWLX_PROFILE_V1_0   pWlxProfile;
    // PMiniAccount    pAccount;
    PGlobals        pGlobals;

    pGlobals = (PGlobals) pWlxContext;

    result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR) MAKEINTRESOURCE(IDD_LOGON_DIALOG),
                                            NULL,
                                            LogonDlgProc,
                                            (LPARAM) pGlobals );

    if (result == WLX_SAS_ACTION_LOGON)
    {
        result = AttemptLogon(pGlobals, pGlobals->pAccount,
                                pLogonSid, pAuthenticationId);

        if (result == WLX_SAS_ACTION_LOGON)
        {
            *pdwOptions = 0;
            *phToken = pGlobals->hUserToken;
            *pProfile = NULL;

            pMprNotifyInfo->pszUserName = DupString(pGlobals->pAccount->pszUsername);
            pMprNotifyInfo->pszDomain = DupString(pGlobals->pAccount->pszDomain);
            pMprNotifyInfo->pszPassword = DupString(pGlobals->pAccount->pszPassword);
            pMprNotifyInfo->pszOldPassword = NULL;

        }
    }
    return(result);
}

//+---------------------------------------------------------------------------
//
//  Function:   WlxActivateUserShell
//
//  Synopsis:   Activates progman or whatever for the user
//
//  Arguments:  [pWlxContext]       --
//              [pszDesktop]        --
//              [pszMprLogonScript] --
//              [pEnvironment]      --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxActivateUserShell(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktop,
    PWSTR                   pszMprLogonScript,
    PVOID                   pEnvironment
    )
{
    // BOOL        bExec;
    WCHAR       szText[MAX_PATH];
    PWSTR       pszScan;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    PGlobals    pGlobals;
    DWORD       StartCount;

    pGlobals = (PGlobals) pWlxContext;

    GetProfileString(WINLOGON_APP, USERINIT, USERINIT_DEFAULT, szText, MAX_PATH);

    StartCount = 0;

    pszScan = wcstok(szText, TEXT(","));
    while (pszScan)
    {
        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(STARTUPINFO);
        si.lpTitle = pszScan;
        si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
        si.dwFlags = 0;
        si.wShowWindow = SW_SHOW;   // at least let the guy see it
        si.lpReserved2 = NULL;
        si.cbReserved2 = 0;
        si.lpDesktop = pszDesktop;

        DebugLog((DEB_TRACE, "Starting '%ws' as user\n", pszScan));

        if (ImpersonateLoggedOnUser(pGlobals->hUserToken))
        {

            if (CreateProcessAsUser(pGlobals->hUserToken,   // Token to run as
                                NULL,                   // App name
                                pszScan,                // Command Line
                                NULL,                   // Process SD
                                NULL,                   // Thread SD
                                FALSE,                  // No inherit
                                CREATE_UNICODE_ENVIRONMENT,
                                pEnvironment,
                                NULL,
                                &si,
                                &pi))
            {
                StartCount++;
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }

            RevertToSelf();
        }
        else
        {
            break;  // It's not going to improve
        }

        pszScan = wcstok(NULL, TEXT(","));
    }

    return(StartCount > 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxLoggedOnSAS
//
//  Synopsis:   Called when someone hits CAD when we're logged on
//
//  Arguments:  [pWlxContext] --
//              [dwSasType]   --
//              [pReserved]   --
//
//  Algorithm:
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int
WINAPI
WlxLoggedOnSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType,
    PVOID                   pReserved
    )
{
    int result;

    result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR) MAKEINTRESOURCE(IDD_OPTIONS_DIALOG),
                                            NULL,
                                            OptionsDlgProc,
                                            (LPARAM) pWlxContext );



    return(result);

}

//+---------------------------------------------------------------------------
//
//  Function:   WlxIsLockOk
//
//  Synopsis:   Called to make sure that locking is ok
//
//  Arguments:  [pWlxContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxIsLockOk(
    PVOID                   pWlxContext
    )
{
    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxDisplayLockedNotice
//
//  Synopsis:   Displays a notice while the workstation is locked
//
//  Arguments:  [pWlxContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
WlxDisplayLockedNotice(PVOID   pWlxContext)
{
    int Result;

    Result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR) MAKEINTRESOURCE(IDD_WKSTA_LOCKED),
                                            NULL,
                                            WelcomeDlgProc,
                                            0 );

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxWkstaLockedSAS
//
//  Synopsis:   Responds during an unlock attempt
//
//  Arguments:  [pWlxContext] --
//              [dwSasType]   --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int
WINAPI
WlxWkstaLockedSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType
    )
{
    return(WLX_SAS_ACTION_UNLOCK_WKSTA);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxIsLogoffOk
//
//  Synopsis:   Called to make sure that logoff is ok
//
//  Arguments:  [pWlxContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
WlxIsLogoffOk(
    PVOID                   pWlxContext
    )
{
    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxLogoff
//
//  Synopsis:   Called when the user logs off
//
//  Arguments:  [pWlxContext] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
WlxLogoff(
    PVOID                   pWlxContext
    )
{
    PGlobals    pGlobals;

    pGlobals = (PGlobals) pWlxContext;

    //
    // Winlogon has closed it for us..
    //

    pGlobals->hUserToken = NULL;
    pGlobals->pAccount = NULL;

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxShutdown
//
//  Synopsis:   Called before shutdown so that we can unload/clean up.
//
//  Arguments:  [pWlxContext]  --
//              [ShutdownType] --
//
//  History:    4-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
WlxShutdown(
    PVOID                   pWlxContext,
    DWORD                   ShutdownType
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\rsoputil\rsoputil.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:            RsopUtil.h
//
// Description:        
//
// History:    8-20-99   leonardm    Created
//
//******************************************************************************

#ifndef RSOPUTIL_H__A7BD2656_0F51_4bf7_847E_92C36CD23D59__INCLUDED_
#define RSOPUTIL_H__A7BD2656_0F51_4bf7_847E_92C36CD23D59__INCLUDED_



//******************************************************************************
//
// Class:    
//
// Description:    
//
// History:        8/20/99        leonardm    Created.
//
//******************************************************************************
class CWString
{
private:
    WCHAR* _pW;
    int _len;
    bool _bState;

    void Reset();

public:
    CWString();

    CWString(const WCHAR* s);
    CWString(const CWString& s);

    ~CWString();

    CWString& operator = (const CWString& s);
    CWString& operator = (const WCHAR* s);

    operator const WCHAR* () const;
    operator WCHAR* () const;

    CWString& operator += (const CWString& s);
    CWString operator + (const CWString& s) const;
    
    friend CWString operator + (const WCHAR* s1, const CWString& s2);

    bool operator == (const CWString& s) const;
    bool operator == (const WCHAR* s) const;
    bool operator != (const CWString& s) const;
    bool operator != (const WCHAR* s) const;

    bool CaseSensitiveCompare(const CWString& s) const;

    int length() const;

    bool ValidString() const;
};

CWString operator + (const WCHAR* s1, const CWString& s2);

#endif // #ifndef RSOPUTIL_H__A7BD2656_0F51_4bf7_847E_92C36CD23D59__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\gina.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       gina.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------

//
// Make sure that you have defined UNICODE, _UNICODE, and WIN32 correctly in
// your build environment.
//

#include <windows.h>
#include <commctrl.h>
#include <lm.h>
#include <winwlx.h>

#include "ginadlg.h"
#include "resids.h"

#include "debug.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\out.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       out.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"

PMiniAccount    pAccountList = NULL;

BOOL
InitializeAccountList(
    VOID)
{
    // PMiniAccount
    //
    //
    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\ginadlg.h ===
#define IDD_WELCOME_DLG             100
#define IDD_WELCOME_TEXT            101
#define IDD_LOGON_LV                201
#define IDD_SHUTDOWN_BUTTON         202
#define IDD_LOGON_BUTTON            203
#define IDD_LOGON_DIALOG            300
#define IDD_OPTIONS_DIALOG          400
#define IDD_OPTIONS_ICON_SPOT       401
#define IDD_OPTIONS_ICON            402
#define IDD_OPTIONS_LOGON_TEXT      403
#define IDD_LOCK_BUTTON             405
#define IDD_PASSWORD_BUTTON         406
#define IDD_TASK_BUTTON             407
#define IDD_HELP_BUTTON             408
#define IDD_OPTION_TEXT             409
#define IDD_OPTIONS_EXIT            410
#define IDD_SHUTDOWN                500
#define IDD_CONFIRM_TEXT            501
#define IDD_CONFIRM_LOGOFF          502
#define IDD_CONFIRM_SHUTDOWN        503
#define IDD_CONFIRM_REBOOT          504
#define IDD_SHUTDOWN_ICON_SPOT      506
#define IDD_SHUTDOWN_ICON           507
#define IDD_CONFIG_BUTTON           411
#define IDD_NEW_USER_LOGON          600
#define IDD_NEW_USER_ICON_SPOT      601
#define IDD_NEW_USER_ICON_X         602
#define IDD_USERNAME_TEXT           603
#define IDD_USER_NAME               604
#define IDD_DOMAIN_TEXT             605
#define IDD_DOMAIN                  606
#define IDD_PASSWORD_TEXT           607
#define IDD_PASSWORD                608
#define IDD_LOGON_CONFIG            700
#define IDD_AUTO_LOGON              701
#define IDD_AUTO_LOGOFF_LOGON       702
#define IDD_LOCK_OTHERS             703
#define IDD_CONFIRM_POWEROFF        508
#define IDD_CHANGE_PASSWORD         800
#define IDD_USER_NAME_TEXT          801
#define IDD_NEW_PASSWORD_TEXT       802
#define IDD_FROM_TEXT               803
#define IDD_OLD_PASSWORD_TEXT       804
#define IDD_OLD_PASSWORD            805
#define IDD_NEW_PASSWORD            807
#define IDD_CONFIRM_PASSWORD_TEXT   808
#define IDD_CONFIRM_PASSWORD        809
#define IDD_FROM_TEXT               803
#define IDD_NO_NEW_USERS            704
#define IDD_WKSTA_LOCKED            200
#define IDD_LOCKED_ICON_SPOT        204
#define IDI_LOCKED_ICON             205
#define IDD_LOCKED_TEXT             206
#define IDD_LOCKED_BY_LABEL         207
#define IDD_LOCKED_BY               208
#define IDD_LOCKED_INST             209
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\resids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       resids.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-28-95   RichardW   Created
//
//----------------------------------------------------------------------------


#define IDI_USER_ICON       10
#define IDI_NEW_USER_ICON   11
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\globals.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       globals.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------


extern  HINSTANCE                   hDllInstance;
extern  HANDLE                      hGlobalWlx;
extern  PWLX_DISPATCH_VERSION_1_0   pWlxFuncs;


#define GINA_SAS_1      256
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by res.rc
//
#define IDD_WELCOME_DIALOG              101
#define IDD_LOGON_DIALOG                102
#define IDD_LOGON_LV                    1001
#define IDD_LOGON                       1002
#define IDD_SHUTDOWN                    1003
#define IDD_WELCOME_TEXT                -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       protos.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-95   RichardW   Created
//
//----------------------------------------------------------------------------


int
CALLBACK
WelcomeDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam);

int
CALLBACK
LogonDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam);

int
CALLBACK
ShutdownDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam);

int
CALLBACK
OptionsDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam);

VOID
CenterWindow(
    HWND    hwnd
    );

int
ErrorMessage(
    HWND        hWnd,
    PWSTR       pszTitleBar,
    DWORD       Buttons);

int
AttemptLogon(
    PGlobals        pGlobals,
    PMiniAccount    pAccount,
    PSID            pLogonSid,
    PLUID           pLogonId);

PWSTR
AllocAndCaptureText(
    HWND    hDlg,
    int     Id);

PWSTR
DupString(
    PWSTR   pszText);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\logon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       logon.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-28-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"
#pragma hdrstop

HIMAGELIST      hiLogonSmall;
HIMAGELIST      hiLogonLarge;
PMiniAccount    pAccountList;
WCHAR           szMiniKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Accounts");

BYTE            LongPseudoRandomString[] = {0x27, 0xbd, 0xff, 0xa0,
                                            0xaf, 0xbf, 0x00, 0x1c,
                                            0x24, 0x0e, 0x00, 0x01,
                                            0x24, 0x0f, 0x00, 0x05 };


MiniAccount TestAccounts[]  = { {NULL, TEXT("daveth"), TEXT("\\msft\\risc\\dev"), TEXT("daveth"), TEXT("Oooh"), 0, MINI_CAN_EDIT},
                                {NULL, TEXT("Test1"), TEXT("Redmond"), TEXT("Test1"), TEXT("Mine"), 0, MINI_CAN_EDIT},
                                {NULL, TEXT("Test2"), TEXT("NtWksta"), TEXT("Test2"), TEXT("Yours"), 0, 0},
                                {NULL, TEXT("New User"), TEXT(""), TEXT(""), TEXT(""), 0, MINI_NEW_ACCOUNT}

                              };

BOOL
SaveMiniAccount(PMiniAccount    pAccount)
{
    HKEY                    hMiniKey;
    PSerializedMiniAccount  pPacked;
    DWORD                   cbNeeded;
    PWSTR                   pszPack;
    int                     err;
    DWORD                   Disposition;

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            szMiniKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_READ,
                            NULL,
                            &hMiniKey,
                            &Disposition);

    if (err)
    {
        return(FALSE);
    }

    cbNeeded = sizeof(SerializedMiniAccount) +
                (wcslen(pAccount->pszDomain) + 1 +
                 wcslen(pAccount->pszPassword) + 1 +
                 wcslen(pAccount->pszComment) + 1 ) * sizeof(WCHAR) ;

    pPacked = LocalAlloc(LMEM_FIXED, cbNeeded);

    if (!pPacked)
    {
        return(FALSE);
    }

    pszPack = (PWSTR) (pPacked + 1);

    pPacked->Version = MINI_VERSION;
    pPacked->Flags = pAccount->Flags;
    pPacked->IconId = pAccount->IconId;

    pPacked->dwDomainOffset = sizeof(SerializedMiniAccount);
    pPacked->dwDomainLength = (wcslen(pAccount->pszDomain) + 1) * sizeof(WCHAR);
    wcscpy(pszPack, pAccount->pszDomain);
    pszPack += (pPacked->dwDomainLength / sizeof(WCHAR) );

    pPacked->dwPasswordOffset = pPacked->dwDomainOffset + pPacked->dwDomainLength;
    pPacked->dwPasswordLength = (wcslen(pAccount->pszPassword) + 1) * sizeof(WCHAR);
    wcscpy(pszPack, pAccount->pszPassword);
    pszPack += (pPacked->dwPasswordLength / sizeof(WCHAR) );

    pPacked->dwCommentOffset = pPacked->dwPasswordOffset + pPacked->dwPasswordLength;
    pPacked->dwCommentLength = (wcslen(pAccount->pszComment) + 1) * sizeof(WCHAR);
    wcscpy(pszPack, pAccount->pszComment);

    err = RegSetValueEx(hMiniKey,
                        pAccount->pszUsername,
                        0,
                        REG_BINARY,
                        (PBYTE) pPacked,
                        cbNeeded);

    RegCloseKey(hMiniKey);

    return(err == 0);
}

BOOL
LoadMiniAccounts(PGlobals   pGlobals)
{
    FILETIME            LastWrite;
    // HKEY                hKey;
    HKEY                hMiniKey;
    WCHAR               szClass[64];
    DWORD               err;
    DWORD               Disposition;
    DWORD               Class;
    DWORD               cKeys;
    DWORD               LongestKeyName;
    DWORD               LongestClass;
    DWORD               cValues;
    DWORD               LongestValueName;
    DWORD               LongestValueData;
    DWORD               Security;
    DWORD               i;
    WCHAR               szValue[MAX_PATH];
    DWORD               cbValue;
    DWORD               dwType;
    DWORD               cbData;
    PBYTE               pBuffer;
    DWORD               cbBuffer;
    PMiniAccount        pAccount;
    PSerializedMiniAccount  pPacked;


    if (pGlobals->fAllowNewUser)
    {
        pAccount = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount) );
        if (pAccount)
        {
            pAccount->pNext = NULL;
            pAccount->pszUsername = TEXT("New User");
            pAccount->pszDomain = TEXT("");
            pAccount->pszPassword = TEXT("");
            pAccount->pszComment = TEXT("");
            pAccount->Flags = MINI_NEW_ACCOUNT;

            pAccountList = pAccount;
        }
        else
            return(FALSE);
    }
    else
    {
        pAccountList = NULL;
    }

    //
    //

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            szMiniKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_READ,
                            NULL,
                            &hMiniKey,
                            &Disposition);

    if (err)
    {
        return(FALSE);
    }

    if (Disposition == REG_OPENED_EXISTING_KEY)
    {
        //
        // Enumerate the sub keys of our class, and Load them.
        //
        Class = sizeof(szClass) / sizeof(WCHAR);
        err = RegQueryInfoKey(  hMiniKey,
                                szClass,
                                &Class,
                                NULL,
                                &cKeys,
                                &LongestKeyName,
                                &LongestClass,
                                &cValues,
                                &LongestValueName,
                                &LongestValueData,
                                &Security,
                                &LastWrite);

        pBuffer = LocalAlloc(LMEM_FIXED, 512);
        cbBuffer = 512;

        for (i = 0; i < cValues ; i++ )
        {
            cbValue = MAX_PATH;

            err = RegEnumValue( hMiniKey,
                                i,
                                szValue,
                                &cbValue,
                                NULL,
                                &dwType,
                                NULL,
                                &cbData);

            if (err)
            {
                break;
            }

            if (dwType != REG_BINARY)
            {
                continue;
            }

            if (cbData > cbBuffer)
            {
                pBuffer = LocalReAlloc(pBuffer, LMEM_FIXED, cbData);
                if (!pBuffer)
                {
                    break;
                }
                cbBuffer = cbData;
            }

            err = RegQueryValueEx(  hMiniKey,
                                    szValue,
                                    0,
                                    &dwType,
                                    pBuffer,
                                    &cbData);

            if (err == 0)
            {
                pPacked = (PSerializedMiniAccount) pBuffer;

                if (pPacked->Version != MINI_VERSION)
                {
                    continue;
                }

                pAccount = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount));
                if (pAccount)
                {
                    pAccount->Flags = pPacked->Flags;
                    pAccount->IconId = pPacked->IconId;
                    pAccount->pszUsername = LocalAlloc(LMEM_FIXED, (cbValue+1)*sizeof(TCHAR));
                    if (pAccount->pszUsername)
                    {
                        wcscpy(pAccount->pszUsername, szValue);
                    }

                    pAccount->pszDomain = LocalAlloc(LMEM_FIXED, pPacked->dwDomainLength);
                    if (pAccount->pszDomain)
                    {
                        wcscpy(pAccount->pszDomain,
                               (PWSTR) ((pBuffer) + pPacked->dwDomainOffset) );
                    }

                    pAccount->pszPassword = LocalAlloc(LMEM_FIXED, pPacked->dwPasswordLength);
                    if (pAccount->pszPassword)
                    {
                        wcscpy(pAccount->pszPassword,
                               (PWSTR) (pBuffer + pPacked->dwPasswordOffset) );
                    }

                    pAccount->pszComment = LocalAlloc(LMEM_FIXED, pPacked->dwCommentLength);
                    if (pAccount->pszComment)
                    {
                        wcscpy(pAccount->pszComment,
                               (PWSTR) (pBuffer + pPacked->dwCommentOffset) );
                    }

                    pAccount->pNext = pAccountList;
                    pAccountList = pAccount;
                }
            }

        }

    }

    return(TRUE);
}

VOID
InitializeImageLists()
{
    HICON   hIcon;

    hiLogonSmall = ImageList_Create(16, 16, TRUE, 4, 0);
    hiLogonLarge = ImageList_Create(32, 32, TRUE, 4, 0);

    hIcon = LoadIcon(hDllInstance, MAKEINTRESOURCE(IDI_USER_ICON));
    if (!hIcon)
    {
        DebugLog((DEB_ERROR, "Unable to load icon, %d\n", GetLastError()));
    }
    ImageList_AddIcon(hiLogonLarge, hIcon);
    ImageList_AddIcon(hiLogonSmall, hIcon);

    hIcon = LoadIcon(hDllInstance, MAKEINTRESOURCE(IDI_NEW_USER_ICON));
    ImageList_AddIcon(hiLogonLarge, hIcon);
    ImageList_AddIcon(hiLogonSmall, hIcon);

}


PopulateListView(
    HWND            hLV,
    PMiniAccount    pAccList)
{
    LV_ITEM     lvi;
    LV_COLUMN   lvc;
    DWORD       Count;


    ListView_SetImageList(hLV, hiLogonLarge, LVSIL_NORMAL);
    ListView_SetImageList(hLV, hiLogonSmall, LVSIL_SMALL);

    //
    // Ok, now set up the columns for the list view
    //

    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = 0;

    lvc.iSubItem = 0;
    lvc.pszText = TEXT("Name        ");
    ListView_InsertColumn(hLV, 0, &lvc);

    lvc.iSubItem = 1;
    lvc.pszText = TEXT("Domain   ");
    ListView_InsertColumn(hLV, 1, &lvc);
    //
    // Comment
    //

    lvc.iSubItem = 2;
    lvc.pszText = TEXT("Comment   ");
    ListView_InsertColumn(hLV, 2, &lvc);

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;


    Count = 0;
    while (pAccList)
    {
        lvi.iItem = Count;
        lvi.iSubItem  = 0;
        lvi.iImage = (pAccList->Flags & MINI_NEW_ACCOUNT) ? 1 : 0;
        lvi.pszText = pAccList->pszUsername;
        lvi.lParam = (LPARAM) pAccList;

        ListView_InsertItem(hLV, &lvi);

        ListView_SetItemText(hLV, Count, 1, pAccList->pszDomain);
        ListView_SetItemText(hLV, Count, 2, pAccList->pszComment);

        Count++;
        pAccList = pAccList->pNext;

    }

    return(TRUE);
}

int
CALLBACK
NewUserDlgProc(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    PGlobals        pGlobals;
    PMiniAccount    pMini;

    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);
    switch (Message)
    {
        case WM_INITDIALOG:
            CenterWindow(hDlg);
            SetWindowLong(hDlg, GWL_USERDATA, lParam);
            return(TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                pMini = LocalAlloc(LMEM_FIXED, sizeof(MiniAccount));
                pMini->pszUsername = AllocAndCaptureText(hDlg, IDD_USER_NAME);
                pMini->pszDomain = AllocAndCaptureText(hDlg, IDD_DOMAIN);
                pMini->pszPassword = AllocAndCaptureText(hDlg, IDD_PASSWORD);
                pMini->pszComment = DupString(TEXT(""));
                pMini->Flags = MINI_SAVE | MINI_CAN_EDIT;
                pMini->IconId = 0;
                pMini->pNext = pAccountList;
                pAccountList = pMini;
                pGlobals->pAccount = pMini;
                EndDialog(hDlg, IDOK);
            }
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, IDCANCEL);
            }
            return(TRUE);
    }

    return(FALSE);

}

LogonDlgInit(
    HWND    hDlg,
    LPARAM  lParam)
{
    PGlobals        pGlobals;
    HWND            hLV;

    pGlobals = (PGlobals) lParam;
    SetWindowLong(hDlg, GWL_USERDATA, lParam);
    pGlobals->pAccount = NULL;

    if (pAccountList == NULL)
    {
        LoadMiniAccounts(pGlobals);
    }

    InitializeImageLists();

    hLV = GetDlgItem(hDlg, IDD_LOGON_LV);
    PopulateListView(hLV, pAccountList);

    CenterWindow(hDlg);

    ListView_SetColumnWidth(hLV, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hLV, 1, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hLV, 2, LVSCW_AUTOSIZE);

    ShowWindow(hLV, SW_NORMAL);
    EnableWindow(hLV, TRUE);
    EnableWindow(GetDlgItem(hDlg, IDD_LOGON_BUTTON), FALSE);

    return(TRUE);

}

int
HandleLvNotify(
    HWND        hDlg,
    PGlobals    pGlobals,
    NMHDR *     pNMH)
{
    NM_LISTVIEW *   pNotify;
    LV_ITEM         lvi;
    HWND            hLV;
    PMiniAccount *  ppAcc;
    int             ret;
    int             index;

    pNotify = (NM_LISTVIEW *) pNMH;

    hLV = GetDlgItem(hDlg, IDD_LOGON_LV);

    ppAcc = &pGlobals->pAccount;

    switch (pNotify->hdr.code)
    {
        case NM_CLICK:
        case NM_DBLCLK:
            EnableWindow(GetDlgItem(hDlg, IDD_LOGON_BUTTON), TRUE);

            index = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);
            if (index >= 0)
            {
                lvi.iItem = index;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;

                ret = ListView_GetItem(hLV, &lvi);
                *ppAcc = (PMiniAccount) lvi.lParam;
                DebugLog((DEB_TRACE, "Selected Item %d, lParam = %x\n", index, lvi.lParam));
            }

            if (pNotify->hdr.code == NM_DBLCLK)
            {
                PostMessage(hDlg, WM_COMMAND, IDOK, 0);
            }
            return(TRUE);

    }
    return(FALSE);

}

int
CALLBACK
LogonDlgProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    NMHDR *     pNotifyHeader;
    PGlobals    pGlobals;
    int         result;

    pGlobals = (PGlobals) GetWindowLong(hDlg, GWL_USERDATA);
    switch (Message)
    {
        case WM_INITDIALOG:
            return(LogonDlgInit(hDlg, lParam));

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, WLX_SAS_ACTION_NONE);
            }
            if (LOWORD(wParam) == IDD_LOGON_BUTTON)
            {
                if (pGlobals->pAccount->Flags & MINI_NEW_ACCOUNT)
                {
                    result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                                            hDllInstance,
                                                            (LPTSTR) MAKEINTRESOURCE(IDD_NEW_USER_LOGON),
                                                            hDlg,
                                                            (DLGPROC) NewUserDlgProc,
                                                            (LPARAM) pGlobals);
                }
                else
                {
                    result = IDOK;
                }

                if (result == IDOK)
                {
                    EndDialog(hDlg, WLX_SAS_ACTION_LOGON);
                }
            }
            if (LOWORD(wParam) == IDD_SHUTDOWN_BUTTON)
            {
                result = pWlxFuncs->WlxDialogBoxParam(  hGlobalWlx,
                                                        hDllInstance,
                                                        (LPTSTR) MAKEINTRESOURCE(IDD_SHUTDOWN),
                                                        hDlg,
                                                        (DLGPROC) ShutdownDlgProc,
                                                        (LPARAM) pGlobals);
                if (result != WLX_SAS_ACTION_NONE)
                {
                    EndDialog(hDlg, result);
                }
            }
            return(TRUE);
            break;

        case WM_NOTIFY:
            pNotifyHeader = (NMHDR *) lParam;
            if (wParam == IDD_LOGON_LV)
            {
                return(HandleLvNotify(hDlg, pGlobals, pNotifyHeader));
            }
        case WM_CLOSE:
            hiLogonSmall = NULL;
            hiLogonLarge = NULL;
            return(TRUE);

    }

    return(FALSE);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

int
AttemptLogon(
    PGlobals        pGlobals,
    PMiniAccount    pAccount,
    PSID            pLogonSid,
    PLUID           pLogonId)
{
    HANDLE              hUser;
    TOKEN_STATISTICS    TStats;
    TOKEN_GROUPS    *   pGroups;
    DWORD               size;
    DWORD               i;

    if (LogonUser(  pAccount->pszUsername,
                    pAccount->pszDomain,
                    pAccount->pszPassword,
                    LOGON32_LOGON_INTERACTIVE,
                    LOGON32_PROVIDER_DEFAULT,
                    &hUser))
    {
        if (pAccount->Flags & MINI_SAVE)
        {
            SaveMiniAccount(pAccount);
            pAccount->Flags &= ~MINI_SAVE;
        }

        pGlobals->hUserToken = hUser;

        //
        // Now, grovel the token we got back for interesting stuff:
        //

        GetTokenInformation(hUser,
                            TokenStatistics,
                            &TStats,
                            sizeof(TStats),
                            &size);

        *pLogonId = TStats.AuthenticationId;

        pGroups = LocalAlloc(LMEM_FIXED, 1024);

        if (!pGroups)
        {
            CloseHandle(hUser);
            return(WLX_SAS_ACTION_NONE);
        }

        //
        // The tricky part.  We need to get the Logon SID from the token,
        // since that is what Winlogon will use to protect the windowstation
        // and desktop.
        //

        GetTokenInformation(hUser,
                            TokenGroups,
                            pGroups,
                            1024,
                            &size);

        if (size > 1024)
        {
            pGroups = LocalReAlloc(pGroups, LMEM_FIXED, size);
            GetTokenInformation(hUser,
                                TokenGroups,
                                pGroups,
                                size,
                                &size);
        }

        for (i = 0; i < pGroups->GroupCount ; i++)
        {
            if ((pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) == SE_GROUP_LOGON_ID)
            {
                CopySid(GetLengthSid(pLogonSid),
                        pLogonSid,
                        pGroups->Groups[i].Sid );
                break;
            }
        }

        LocalFree(pGroups);

        return(WLX_SAS_ACTION_LOGON);
    }

    return(WLX_SAS_ACTION_NONE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\samples\gina\options.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1992 - 1998 Microsoft Corporation.
//
//  File:       options.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "gina.h"
#pragma hdrstop

typedef
NET_API_STATUS (NET_API_FUNCTION * NUCP)(LPWSTR, LPWSTR, LPWSTR, LPWSTR);

NUCP    NetUserChangePasswordFn = NULL;
HMODULE hNetApi32;

BOOL
LoadNetapi(HWND hDlg)
{
    hNetApi32 = LoadLibrary(TEXT("netapi32.dll"));
    if (hNetApi32)
    {
        NetUserChangePasswordFn = (NUCP) GetProcAddress(hNetApi32, "NetUserChangePassword");
        if (NetUserChangePasswordFn)
        {
            return(TRUE);
        }
    }

    ErrorMessage(hDlg, TEXT("Change Password"), MB_ICONSTOP | MB_OK);

    return(FALSE);

}

PWSTR
AllocAndCaptureText(
    HWND    hDlg,
    int     Id)
{
    WCHAR   szTemp[MAX_PATH];
    PWSTR   New;
    DWORD   cb;

    cb = GetDlgItemText(hDlg, Id, szTemp, MAX_PATH);
    New = LocalAlloc(LMEM_FIXED, (cb + 1) * sizeof(WCHAR));
    if (New)
    {
        wcscpy(New, szTemp);
    }
    return(New);
}

PWSTR
DupString(
    PWSTR   pszText)
{
    PWSTR   New;
    DWORD   cb;

    cb = (wcslen(pszText) + 1) * sizeof(WCHAR);
    New = LocalAlloc(LMEM_FIXED, cb);

    if (New)
    {
        wcscpy(New, pszText);
    }

    return(New);
}

BOOL
TryToChangePassword(
    HWN