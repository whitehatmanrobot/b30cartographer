    &IsDifferent
                                        );
                        if ( rc == SCESTATUS_SUCCESS ) {

                            if ( IsDifferent ) {
                                //
                                // mismatch should be raised with valScep
                                //
                                pNode->Status = SCE_STATUS_MISMATCH;
                                rc = ScepSetSingleServiceSetting(
                                            hSectionSap,
                                            pNode
                                            );
                                if ( rc == SCESTATUS_SUCCESS) {
                                    //
                                    // update SMP
                                    //
                                    rc = ScepSetSingleServiceSetting(
                                                hSectionSmp,
                                                pService
                                                );
                                }
                            }
                        }
                    }
                }

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS) {
                    break;
                }

                //
                // remove the SMP node from old configuration
                //
                if ( pNode != NULL ) {

                    //
                    // link to the next
                    //
                    if ( pParent != NULL ) {
                        pParent->Next = pNode->Next;

                    } else {
                        *pScepServices = pNode->Next;
                    }
                    //
                    // delete this node
                    //
                    ScepFree(pNode->ServiceName);
                    if (pNode->General.pSecurityDescriptor)
                        ScepFree(pNode->General.pSecurityDescriptor);

                    ScepFree(pNode);
                    pNode = NULL;
                }
            }

            //
            // delete remaining SMP entries, do not care error code
            //
            if ( rc == SCESTATUS_SUCCESS ) {
                for (pNode=*pScepServices; pNode != NULL; pNode = pNode->Next ) {

                    //
                    // first change SAP entry
                    //
                    rc = SceJetSeek(
                            hSectionSap,
                            pNode->ServiceName,
                            wcslen(pNode->ServiceName)*sizeof(WCHAR),
                            SCEJET_SEEK_EQ_NO_CASE
                            );

                    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
                        //
                        // was a match item
                        //
                        pNode->Status = SCE_STATUS_NOT_CONFIGURED;
                        rc = ScepSetSingleServiceSetting(
                                    hSectionSap,
                                    pNode
                                    );
                    }

                    if ( rc == SCESTATUS_SUCCESS ||
                         rc == SCESTATUS_RECORD_NOT_FOUND ) {

                        //
                        // delete SMP - it's taken out of the service list
                        //
                        rc = SceJetDelete(
                                hSectionSmp,
                                pNode->ServiceName,
                                FALSE,
                                SCEJET_DELETE_LINE_NO_CASE
                                );
                    }

                    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);
}


SCESTATUS
ScepUpdateObjectInfo(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    IN DWORD NameLen, // number of characters
    IN BYTE ConfigStatus,
    IN BOOL  IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Determine related changes to the object's parent(s), child(ren) in SMP and SAP
    database then update the SMP entry for the object. Refer to objedit.doc for
    the rule to update database.

Arguments:

    hProfile - the database handle

    Area - security area to update (file, registry, ds)

    ObjectName - object name in full name

    NameLen - the length of the object name

    ConfigStatus - the flag changed to

    IsContainer - if the object is a container type

    pSD - the security descriptor for the object

    SeInfo - the security information for the object

    pAnalysisStatus - output status of analysis for the object

Return Value:

    SCE status
*/
{
    SCESTATUS rc;
    PCWSTR SectionName;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    SE_OBJECT_TYPE ObjectType;

    HKEY            hKey;

    PWSTR JetName;
    DWORD NewNameLen;

    if ( hProfile == NULL || ObjectName == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( (ConfigStatus > SCE_STATUS_NO_AUTO_INHERIT ||
          ConfigStatus < SCE_STATUS_CHECK) &&
          (BYTE)SCE_NO_VALUE != ConfigStatus &&
          (DWORD)SCE_NO_VALUE != (DWORD)ConfigStatus ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    switch(Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        ObjectType = SE_REGISTRY_KEY;

        rc = ScepOpenRegistryObject(
                    ObjectType,
                    ObjectName,
                    KEY_READ,
                    &hKey
                    );

        if ( rc == ERROR_SUCCESS ) {
            RegCloseKey(hKey);

        } else {
            //
            // not find the key
            //
            return(SCESTATUS_INVALID_DATA);
        }

        JetName = ObjectName;
        NewNameLen = NameLen;

        break;

    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        ObjectType = SE_FILE_OBJECT;

        if ( ObjectName[0] == L'\\' ) {  // UNC name format
            return(SCESTATUS_INVALID_PARAMETER);
        }

        if ( 0xFFFFFFFF == GetFileAttributes(ObjectName) ) {
            return(SCESTATUS_INVALID_DATA);
        }

        JetName = ObjectName;
        NewNameLen = NameLen;
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        ObjectType = SE_DS_OBJECT;

        rc = ScepLdapOpen(NULL);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // detect if the Ds object exist
            //
            rc = ScepDsObjectExist(ObjectName);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // convert LDAP name to Jet index name
                //
                rc = ScepConvertLdapToJetIndexName(
                            ObjectName,
                            &JetName
                            );
            }
        }
        if ( rc != SCESTATUS_SUCCESS ) {

            ScepLdapClose(NULL);
            return(rc);
        }

        NewNameLen = wcslen(JetName);

        break;
#endif

    default:

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pAnalysisStatus ) {
        *pAnalysisStatus = (BYTE)SCE_NO_VALUE;
    }
    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                SectionName,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    SectionName,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS) {

            //
            // Start a transaction so all updates related to this object is atomic
            //
            rc = SceJetStartTransaction( hProfile );

            if ( rc == SCESTATUS_SUCCESS ) {

                rc = SceJetSeek(
                        hSectionSmp,
                        JetName,
                        NewNameLen*sizeof(WCHAR),
                        SCEJET_SEEK_EQ_NO_CASE
                        );

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // existing SMP object
                    //
                    if ( (BYTE)SCE_NO_VALUE == ConfigStatus ||
                         (DWORD)SCE_NO_VALUE == (DWORD)ConfigStatus ) {
                        //
                        // get the old configure flag
                        //
                        WCHAR StatusFlag;
                        BYTE ScepStatus=0;
                        DWORD Len;

                        rc = SceJetGetValue(
                                hSectionSmp,
                                SCEJET_CURRENT,
                                NULL,
                                NULL,
                                0,
                                NULL,
                                (PWSTR)&StatusFlag,
                                2,
                                &Len
                                );

                        if ( SCESTATUS_SUCCESS == rc ||
                             SCESTATUS_BUFFER_TOO_SMALL == rc ) {
                            //
                            // find the record
                            //
                            ScepStatus = *((BYTE *)&StatusFlag);

                            //
                            // update SAP entries.
                            //
                            rc = ScepObjectAdjustNode(
                                      hSectionSmp,
                                      hSectionSap,
                                      JetName,
                                      NewNameLen,
                                      ObjectType,
                                      ScepStatus,
                                      IsContainer,
                                      NULL,
                                      0,
                                      FALSE, // remove the node
                                      pAnalysisStatus
                                      );

                            if ( SCESTATUS_SUCCESS == rc ) {
                                //
                                // delete the SMP entry
                                //
                                rc = SceJetDelete(
                                        hSectionSmp,
                                        JetName,
                                        FALSE,
                                        SCEJET_DELETE_LINE_NO_CASE
                                        );
                            }

                        }

                    } else {

                        rc = ScepObjectUpdateExistingNode(
                                    hSectionSmp,
                                    hSectionSap,
                                    JetName,
                                    NewNameLen,
                                    ObjectType,
                                    ConfigStatus,
                                    IsContainer,
                                    pSD,
                                    SeInfo,
                                    pAnalysisStatus
                                    );

                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // Update the SMP record
                            //
                            rc = ScepObjectSetKeySetting(
                                hSectionSmp,
                                JetName,
                                ConfigStatus,
                                IsContainer,
                                pSD,
                                SeInfo,
                                TRUE
                                );
                        }
                    }

                } else if ( rc == SCESTATUS_RECORD_NOT_FOUND &&
                           (BYTE)SCE_NO_VALUE != ConfigStatus &&
                           (DWORD)SCE_NO_VALUE != (DWORD)ConfigStatus ) {
                    //
                    // new added object
                    //
                    rc = ScepObjectAdjustNode(
                            hSectionSmp,
                            hSectionSap,
                            JetName,
                            NewNameLen,
                            ObjectType,
                            ConfigStatus,
                            IsContainer,
                            pSD,
                            SeInfo,
                            TRUE,  // add the node
                            pAnalysisStatus
                            );

                }

                if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
                    rc = SCESTATUS_SUCCESS;
                }
                //
                // Commit or Rollback the changes
                //
                if ( rc == SCESTATUS_SUCCESS ) {
                   //
                   // needs return code for commiting the transaction
                   //
                   rc = SceJetCommitTransaction(hProfile, 0);

                }
                if ( rc != SCESTATUS_SUCCESS ) {

                    SceJetRollback(hProfile, 0);
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);

        } else if ( rc == SCESTATUS_BAD_FORMAT ) {
            //
            // SMP exist, but SAP does not exist
            //
        }

        SceJetCloseSection(&hSectionSmp, TRUE);

    } else if ( rc == SCESTATUS_BAD_FORMAT ) {
        //
        // SMP section does not exist
        //
    }

    //
    // free stuff used for DS
    //
    if ( Area == AREA_DS_OBJECTS ) {

        ScepFree(JetName);

        ScepLdapClose(NULL);
    }

    return(rc);
}



SCESTATUS
ScepObjectUpdateExistingNode(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN SE_OBJECT_TYPE ObjectType,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Update an existing object

Arguements:

    see ScepUpdateObjectInfo

Return Value:

    SCESTATUS
*/
{
    SCESTATUS  rc;
    BYTE ScepStatus, SapStatus;
    PSECURITY_DESCRIPTOR pScepSD=NULL;
    SECURITY_INFORMATION ScepSeInfo;

    BYTE retStat = SCE_STATUS_NOT_ANALYZED;

    rc = ScepObjectGetKeySetting(
            hSectionSmp,
            ObjectName,
            &ScepStatus,
            NULL,
            &pScepSD,
            &ScepSeInfo
            );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // check for analysis status
        //
        SapStatus = ScepGetObjectAnalysisStatus(
                        hSectionSap,
                        ObjectName,
                        FALSE
                        );

        if ( ScepStatus == SCE_STATUS_IGNORE ) {
            //
            // no change is needed if update from IGNORE to IGNORE
            //
            if ( ConfigStatus != SCE_STATUS_IGNORE ) {

                //
                // N.A. the object (changed from N.C)
                //
                rc = ScepObjectSetKeySetting(
                        hSectionSap,
                        ObjectName,
                        SCE_STATUS_NOT_ANALYZED,
                        TRUE,
                        NULL,
                        0,
                        TRUE
                        );
            } else {

                if ( SapStatus == SCE_STATUS_NOT_CONFIGURED ) {
                    retStat = SapStatus;
                }
            }

        } else if ( ConfigStatus == SCE_STATUS_IGNORE ) {
            //
            // changed to ignore. delete all children from SMP & SAP
            //
            rc = ScepObjectDeleteScepAndAllChildren(
                    hSectionSmp,
                    hSectionSap,
                    ObjectName,
                    IsContainer,
                    SCE_STATUS_NOT_CONFIGURED
                    );

            retStat = SCE_STATUS_NOT_CONFIGURED;

        } else if ( SapStatus == SCE_STATUS_NOT_ANALYZED ) {
            //
            // was already added/modified, no need to update SAP
            // although children status may be mixed with C.C. or N.A.
            //
            if ( ConfigStatus == SCE_STATUS_OVERWRITE &&
                 ScepStatus != SCE_STATUS_OVERWRITE ) {

                //
                // change C.C children to N.A. children
                //

                rc = ScepObjectRaiseChildrenInBetween(
                             hSectionSmp,
                             hSectionSap,
                             ObjectName,
                             NameLen,
                             IsContainer,
                             SCE_STATUS_NOT_ANALYZED,
                             TRUE  // change status only
                             );

            } else if ( ConfigStatus != SCE_STATUS_OVERWRITE &&
                        ScepStatus == SCE_STATUS_OVERWRITE ) {

                //
                // change N.A. children to C.C. children
                //
                rc = ScepObjectRaiseChildrenInBetween(
                             hSectionSmp,
                             hSectionSap,
                             ObjectName,
                             NameLen,
                             IsContainer,
                             SCE_STATUS_CHILDREN_CONFIGURED,
                             TRUE  // change status only
                             );
            }

        } else {

            if ( ScepStatus == SCE_STATUS_OVERWRITE &&
                 ( ConfigStatus == SCE_STATUS_CHECK ||
                   ConfigStatus == SCE_STATUS_NO_AUTO_INHERIT ) ) {
                //
                // delete all mismatched status between this node
                // and its children; N.A. all nodes in between
                //
                rc = ScepObjectRaiseChildrenInBetween(
                             hSectionSmp,
                             hSectionSap,
                             ObjectName,
                             NameLen,
                             IsContainer,
                             SCE_STATUS_NOT_ANALYZED,
                             FALSE
                             );

            } else if ( ConfigStatus == SCE_STATUS_OVERWRITE &&
                        (ScepStatus == SCE_STATUS_CHECK ||
                         ScepStatus == SCE_STATUS_NO_AUTO_INHERIT) ) {
                //
                // change C.C children to N.A. children
                //
                rc = ScepObjectRaiseChildrenInBetween(
                             hSectionSmp,
                             hSectionSap,
                             ObjectName,
                             NameLen,
                             IsContainer,
                             SCE_STATUS_NOT_ANALYZED,
                             TRUE  // change status only
                             );
            }

            //
            // compare the current node status
            //
            if ( rc == SCESTATUS_SUCCESS ||
                 rc == SCESTATUS_RECORD_NOT_FOUND ) {

                if ( SapStatus == SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                    // if errored, don't touch it.
                    retStat = SapStatus;
                    rc = SCESTATUS_SUCCESS;

                } else {
                    rc = ScepObjectCompareKeySetting(
                                hSectionSap,
                                ObjectName,
                                ObjectType,
                                TRUE,
                                pSD,
                                SeInfo,
                                pScepSD,
                                &retStat
                                );
                }
            }
        }

        if ( pScepSD ) {
            ScepFree(pScepSD);
        }
    }

    if ( pAnalysisStatus ) {
        *pAnalysisStatus = retStat;
    }

    return(rc);
}


SCESTATUS
ScepObjectGetKeySetting(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    OUT PBYTE Status,
    OUT PBOOL IsContainer OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor OPTIONAL,
    OUT PSECURITY_INFORMATION SeInfo OPTIONAL
    )
/*
Routine Description:

    Read settings for the object in the section

Arguements:

    hSection - the section handle

    others see ScepUpdateObjectInfo

Return Value:

    SCESTATUS
*/
{

    SCESTATUS        rc;
    PWSTR           Value=NULL;
    DWORD           ValueLen;

    PSECURITY_DESCRIPTOR pTempSD=NULL;
    SECURITY_INFORMATION tmpSeInfo;
    DWORD           SDsize, Win32Rc;

    if ( hSection == NULL || ObjectName == NULL || Status == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                ObjectName,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // allocate memory for value string
        //
        Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

        if ( Value == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        //
        // Get the value
        //
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    Value,
                    ValueLen,
                    &ValueLen
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            if (pSecurityDescriptor != NULL ) {
                //
                // convert security descriptor
                //
                Win32Rc = ConvertTextSecurityDescriptor(
                               Value+1,
                               &pTempSD,
                               &SDsize,
                               &tmpSeInfo
                               );
                if ( Win32Rc == NO_ERROR ) {

                    *pSecurityDescriptor = pTempSD;

                    if (tmpSeInfo )
                        *SeInfo = tmpSeInfo;

                } else
                    rc = ScepDosErrorToSceStatus(Win32Rc);
            }

            if ( rc == SCESTATUS_SUCCESS ) {

                *Status = *((BYTE *)Value);

                if ( IsContainer != NULL )
                    *IsContainer = *((CHAR *)Value+1) != '0' ? TRUE : FALSE;
            }
        }

        ScepFree(Value);

    }

    return(rc);
}


SCESTATUS
ScepObjectSetKeySetting(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    IN BYTE Status,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bOverwrite
    )
/*
Routine Description:

    Set settings for the object in the section

Arguements:

    See ScepObjectGetKeySetting

    bOverwrite - if the new setting should overwrite existing settings

Return Value:

    SCESTATUS
*/
{
    SCESTATUS        rc;
    DWORD           SDsize=0, Win32Rc=NO_ERROR;
    PWSTR           SDspec=NULL;


    if ( hSection == NULL ||
         ObjectName == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !bOverwrite ) {
        rc = SceJetSeek(
               hSection,
               ObjectName,
               wcslen(ObjectName)*sizeof(WCHAR),
               SCEJET_SEEK_EQ_NO_CASE
               );

        if ( rc != SCESTATUS_RECORD_NOT_FOUND ) {
            //
            // if found it, do not overwrite, so just return
            // if errored, also return
            //
            return(rc);
        }
    }
    //
    // convert security descriptor
    //
    if ( pSD ) {

        Win32Rc = ConvertSecurityDescriptorToText (
                        pSD,
                        SeInfo,
                        &SDspec,
                        &SDsize
                        );
    }

    if ( Win32Rc == NO_ERROR ) {

        rc = ScepSaveObjectString(
                    hSection,
                    ObjectName,
                    IsContainer,
                    Status,
                    SDspec,
                    SDsize
                    );
    } else
        rc = ScepDosErrorToSceStatus(Win32Rc);

    if ( SDspec != NULL ) {
        ScepFree(SDspec);
    }

    return(rc);

}


SCESTATUS
ScepObjectDeleteScepAndAllChildren(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN BOOL IsContainer,
    IN BYTE StatusToRaise
    )
/*
Routine Description:

    Delete a object and all child objects from SMP and SAP

Arguements:

    hSectionSmp - SMP section handle

    hSectionSap - SAP section handle

    ObjectName  - the object's name

    IsContainer - if the object is a container

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;

    rc = SceJetDelete(
            hSectionSmp,
            ObjectName,
            TRUE,
            SCEJET_DELETE_PARTIAL_NO_CASE
            );

    if ( rc == SCESTATUS_SUCCESS ||
         rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SceJetDelete(
            hSectionSap,
            ObjectName,
            TRUE,
            SCEJET_DELETE_PARTIAL_NO_CASE
            );

        if ( rc == SCESTATUS_SUCCESS ||
             rc == SCESTATUS_RECORD_NOT_FOUND ) {
            //
            // Raise a N.C. status for the object
            //
            rc = ScepObjectSetKeySetting(
                    hSectionSap,
                    ObjectName,
                    StatusToRaise,  //SCE_STATUS_NOT_CONFIGURED,
                    IsContainer,
                    NULL,
                    0,
                    TRUE
                    );
        }

    }

    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);
}


SCESTATUS
ScepObjectAdjustNode(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN SE_OBJECT_TYPE ObjectType,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bAdd,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Add a new object to SMP and SAP sections

Arguements:

    hSectionSmp - the SMP section handle

    hSectionSap - the SAP section handle

    others see ScepUpdateObjectInfo

Return Value:

    SCESTATUS
*/
{

    if ( hSectionSmp == NULL || hSectionSap == NULL ||
         ObjectName == NULL || NameLen == 0 ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS    rc=SCESTATUS_SUCCESS;
    WCHAR       Delim;

    switch ( ObjectType) {
    case SE_REGISTRY_KEY:
    case SE_FILE_OBJECT:
        Delim = L'\\';
        break;
/*
    case SE_DS_OBJECT:
        Delim = L',';
        break;
*/
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    INT         i, Level=0, ParentLevel=0;
    BYTE        ParentStatus;

    //
    // get total number levels of the objectname
    //
    ScepObjectTotalLevel(ObjectName, Delim, &Level);

    //
    // allocate temp buffer
    //
    PWSTR ParentName = (PWSTR)ScepAlloc(0, (NameLen+1)*sizeof(WCHAR));

    if ( ParentName == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // loop through each parent of the object to turn of IGNORE status
    //
    ParentName[0] = L'\0';

    rc = ScepObjectAdjustParentStatus(
                hSectionSmp,
                hSectionSap,
                ObjectName,
                NameLen,
                Delim,
                Level,
                bAdd ? (BYTE)SCE_OBJECT_TURNOFF_IGNORE : 0, // if TRUE, turn off parent ignore status, otherwise, just get the parent
                &ParentLevel,
                &ParentStatus,
                ParentName   // ParentName
                );


    if ( rc != SCESTATUS_SUCCESS ) {
         //
         // error occurs when turning off IGNORE
         //
         ScepFree(ParentName);
         return(rc);
    }

    BYTE retStat = SCE_STATUS_NOT_ANALYZED;

    BOOL        HasChild;

    rc = ScepObjectHasAnyChild(
               hSectionSmp,
               ObjectName,
               NameLen,
               Delim,
               &HasChild
               );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( bAdd ) {

            //
            // ****when bAdd = TRUE, add the node.
            // there are the following cases to consider regarding the SAP entries:
            //
            //  1. tree path is empty to the root (the first object added in this path)
            //        C.C. all parent nodes if they don't exist
            //        N.A. the object
            //        return status N.A.
            //  2. have parent node but no child node (the new node is a leaf node)
            //        if the closest parent is in OVERWRITE status
            //            if the closet parent is new added (N.A. status)
            //               add the node, N.A. the object
            //               return status N.A.
            //            else
            //               if new node status is CHECK
            //                  delete all SAP mismatches for children under the new node,
            //                  determine MATCH/MISMATCH of the new node
            //               if new node status is OVERWRITE
            //                  determine MATCH/MISMATCH of the new node, everthing else stays unchanged
            //               return status GOOD or MISMATCH
            //        if the closest parent is CHECK
            //            C.C. all nodes in the path to the parent,
            //            add the node, N.A. the object
            //            return status N.A.
            //  3. have child node but no parent node
            //         new node's status (CHECK or OVERWRITE ) does not make difference
            //         if new status is IGNORE,
            //            delete all children in SMP and SAP,
            //            add the node and N.C. the object
            //            return status N.C.
            //         else
            //            delete all children in SAP,
            //            add the node,
            //            raise all SMP node and children as N.A.
            //            return status N.A
            //
            //  4. have both parent and child
            //         combine rules for 2 and 3 except:
            //              if parent's status is OVERWRITE and new node status is CHECK
            //                  ONLY delete SAP mismatches for children between the new node and the child node
            //

            //
            // decide child objects
            //
            if ( ConfigStatus == SCE_STATUS_IGNORE ) {
                //
                // delete all children objects from template and analysis database
                //
                rc = ScepObjectDeleteScepAndAllChildren(
                            hSectionSmp,
                            hSectionSap,
                            ObjectName,
                            IsContainer,
                            SCE_STATUS_NOT_ANALYZED
                            );

            } else {

                if ( ParentLevel > 0 && ParentStatus == SCE_STATUS_OVERWRITE ) {

                    //
                    // check if this parent was added (N.A. status)
                    //
                    BYTE oldStatus = ScepGetObjectAnalysisStatus(hSectionSap,
                                                                ParentName,
                                                                FALSE
                                                               );

                    if ( oldStatus == SCE_STATUS_NOT_ANALYZED ) {
                        //
                        // parent was also new added
                        // add the node, N.A. the object
                        //
                        rc = ScepObjectSetKeySetting(
                                hSectionSap,
                                ObjectName,
                                SCE_STATUS_NOT_ANALYZED,
                                TRUE,
                                NULL,
                                0,
                                TRUE
                                );
                    } else {

                        //
                        // closest parent has OVERWRITE status
                        //

                        if ( ConfigStatus == SCE_STATUS_CHECK ||
                             ConfigStatus == SCE_STATUS_NO_AUTO_INHERIT ) {

                            //
                            // delete all SAP children except explicitly specified
                            //
                            if ( !HasChild ) {
                                //
                                // no child - delete everything under the SAP
                                //
                                rc = SceJetDelete(
                                        hSectionSap,
                                        ObjectName,
                                        TRUE,
                                        SCEJET_DELETE_PARTIAL_NO_CASE
                                        );
                            } else {

                                //
                                // here is the problem: should only delete SAP entry between
                                // the new node and its child(ren)
                                // and raise C.C. for nodes in between
                                //
                                //         p
                                //        /
                                //       .
                                //      N
                                //     / |
                                //     . C
                                //    / \
                                //    .  C
                                //    /|
                                //   C C
                                //
                                //

                                rc = ScepObjectRaiseChildrenInBetween(
                                             hSectionSmp,
                                             hSectionSap,
                                             ObjectName,
                                             NameLen,
                                             IsContainer,
                                             SCE_STATUS_CHILDREN_CONFIGURED,
                                             FALSE
                                             );
                            }
                        }

                        //
                        // determine the current node's status, MATCH or MISMATCH
                        //

                        if ( rc == SCESTATUS_SUCCESS ||
                             rc == SCESTATUS_RECORD_NOT_FOUND ) {

                            if ( oldStatus == SCE_STATUS_ERROR_NOT_AVAILABLE  ) {

                                //
                                // Leave Error status alone
                                //
                                rc = ScepObjectSetKeySetting(
                                        hSectionSap,
                                        ObjectName,
                                        oldStatus,
                                        TRUE,
                                        NULL,
                                        0,
                                        TRUE
                                        );
                            } else {

                                //
                                // should compare with SAP to decide mismatch status
                                //
                                rc = ScepObjectCompareKeySetting(
                                        hSectionSap,
                                        ObjectName,
                                        ObjectType,
                                        TRUE,
                                        pSD,
                                        SeInfo,
                                        NULL,
                                        &retStat
                                        );
                            }
                        }
                    }

                } else if ( !HasChild ) {
                    //
                    // there is no child but there may be a parent
                    // if there is a parent, parent's stauts is check
                    //
                    if ( ParentLevel > 0 ) {
                        // C.C. all nodes in the path to the parent,
                        // (if there is child, it's already CCed)
                        // add the node, N.A. the object
                        i = ParentLevel+1;

                    } else {
                        //
                        // no parent was found, no child - the first node
                        //
                        if ( ObjectType == SE_DS_OBJECT ) {
                            //
                            // Ds objects should start with the level for the local domain
                            //
                            PSCE_OBJECT_LIST pDsRoot=NULL;
                            rc = ScepEnumerateDsObjectRoots(NULL, &pDsRoot);

                            if ( rc == SCESTATUS_SUCCESS && pDsRoot != NULL ) {
                                ScepObjectTotalLevel(pDsRoot->Name, Delim, &ParentLevel);

                                ScepFreeObjectList(pDsRoot);
                                pDsRoot = NULL;

                                i = ParentLevel+1;

                            }

                        } else {
                            //
                            // other type starting with level 1
                            //
                            i = 1;
                        }
                    }

                    //
                    // process each node in between the new node and its closest parent
                    //
                    if ( rc == SCESTATUS_SUCCESS ) {
                        rc = ScepObjectRaiseNodesInPath(
                                    hSectionSap,
                                    ObjectName,
                                    NameLen,
                                    i,
                                    Level,
                                    Delim,
                                    SCE_STATUS_CHILDREN_CONFIGURED
                                    );
                    }

                    //
                    // N.A. the object
                    //
                    if ( rc == SCESTATUS_SUCCESS ) {
                        rc = ScepObjectSetKeySetting(
                                hSectionSap,
                                ObjectName,
                                SCE_STATUS_NOT_ANALYZED,
                                IsContainer,
                                NULL,
                                0,
                                TRUE
                                );
                    }

                } else {
                    //
                    // there is child
                    //
                    if ( ConfigStatus == SCE_STATUS_OVERWRITE ) {
                        //
                        // if there is a parent, it must be in CHECK status
                        // nodes between this node and its children
                        // should all be N.A.
                        //
                        rc = ScepObjectRaiseChildrenInBetween(
                                     hSectionSmp,
                                     hSectionSap,
                                     ObjectName,
                                     NameLen,
                                     IsContainer,
                                     SCE_STATUS_NOT_ANALYZED,
                                     FALSE
                                     );
                    }

                    //
                    // N.A. the object
                    //
                    if ( rc == SCESTATUS_SUCCESS ) {
                        rc = ScepObjectSetKeySetting(
                                hSectionSap,
                                ObjectName,
                                SCE_STATUS_NOT_ANALYZED,
                                IsContainer,
                                NULL,
                                0,
                                TRUE
                                );
                    }
                }
            }

            //
            // add the SMP entry
            //
            if ( rc == SCESTATUS_SUCCESS ) {
                rc = ScepObjectSetKeySetting(
                        hSectionSmp,
                        ObjectName,
                        ConfigStatus,
                        IsContainer,
                        pSD,
                        SeInfo,
                        TRUE
                        );
            }

        } else {

            //
            // when bAdd = FALSE, remove the node
            // there are the following cases to consider regarding the SAP entries:
            //
            //  1. if there is no existing child under this node
            //        if no parent, or parent N.A., or parent not OVERWRITE
            //           find junction point with other siblings
            //           remove all SAP below junction point (if not exist, use root/parent)
            //           if no juction point and no parent
            //              N.C. the root
            //           return status N.C.
            //        else { parent in overwrite } if ( TNA/TI/TC) }
            //           delete all SAP below this object
            //           N.A. the object
            //           return status N.A.
            //        else ( parent in overwrite and TO )
            //           N.A. the object
            //           return status N.A.
            //  2. have existing child(ren) - note multiple branches
            //        if no parent
            //            if object status was OVERWRITE
            //               delete SAP entries between this node and all children
            //               C.C. all branch nodes in between
            //            C.C. this object
            //            return status C.C.
            //        else { there is a parent }
            //            if (parent OVERWRITE, object N.A. OVERWRITE) or
            //               (parent not N.A., parent OVERWRITE, object not N.A., object OVERWRITE)
            //               N.A. object
            //               return N.A.
            //            else if parent CHECK, object OVERWRITE
            //               delete SAP entries between this node and all children
            //               C.C. all branch nodes in between
            //               C.C. object
            //               return C.C.
            //            else if (parent OVERWRITE, object CHECK) or
            //                    (parent N.A., parent OVERWRITE, object not N.A., object OVERWRITE)
            //               delete SAP entries between this node and all children
            //               N.A. all branch nodes in between
            //               N.A. object
            //               return N.A.
            //            else { must be parent CHECK, object CHECK }
            //               C.C. object
            //               return C.C
            //

            //
            // check if this parent was added (N.A. status)
            //
            BYTE oldParentFlag = ScepGetObjectAnalysisStatus(hSectionSap,
                                                            ParentName,
                                                            FALSE
                                                           );
            BYTE oldObjectFlag = ScepGetObjectAnalysisStatus(hSectionSap,
                                                             ObjectName,
                                                             FALSE
                                                            );
            if ( !HasChild ) {

                if ( ParentLevel <= 0 ||
                     oldParentFlag == SCE_STATUS_NOT_ANALYZED ||
                     ParentStatus != SCE_STATUS_OVERWRITE ) {

                    //
                    // find junction point with other siblings
                    //
                    INT JuncLevel=0;

                    rc = ScepObjectAdjustParentStatus(
                                hSectionSmp,
                                hSectionSap,
                                ObjectName,
                                NameLen,
                                Delim,
                                Level,
                                SCE_OBJECT_SEARCH_JUNCTION,
                                &JuncLevel,
                                NULL,
                                NULL
                                );

                    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( JuncLevel == 0 ) {
                        JuncLevel = ParentLevel;
                    }

                    if ( SCESTATUS_SUCCESS == rc ) {
                        //
                        // remove all SAP below junction point
                        // (if not exist, use root/parent)
                        //
                        rc = ScepObjectRaiseNodesInPath(
                                    hSectionSap,
                                    ObjectName,
                                    NameLen,
                                    (JuncLevel > 0) ? JuncLevel+1 : 1,
                                    Level,
                                    Delim,
                                    (BYTE)SCE_NO_VALUE
                                    );

                        if ( SCESTATUS_SUCCESS == rc ) {
                            //
                            // delete everything under this deleted node
                            //
                            rc = SceJetDelete(
                                      hSectionSap,
                                      ObjectName,
                                      TRUE,
                                      SCEJET_DELETE_PARTIAL_NO_CASE
                                      );
                        }
                    }

                    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( SCESTATUS_SUCCESS == rc ) {

                        if ( JuncLevel <= 0 ) {
                            //
                            // if no juction point and no parent, N.C. the root
                            // use the ParentName buffer
                            //
                            if ( ObjectType == SE_FILE_OBJECT ) {
                                if ( ParentName[0] == L'\0' ) {
                                    //
                                    // there is no parent
                                    //
                                    ParentName[0] = ObjectName[0];
                                    ParentName[1] = ObjectName[1];
                                }
                                ParentName[2] = L'\\';
                                ParentName[3] = L'\0';
                            } else {
                                // reg keys
                                PWSTR pTemp = wcschr(ParentName, L'\\');
                                if ( pTemp ) {
                                    ParentName[pTemp-ParentName] = L'\0';

                                } else if ( ParentName[0] == L'\0' ) {

                                    pTemp = wcschr(ObjectName, L'\\');
                                    if ( pTemp ) {

                                        wcsncpy(ParentName, ObjectName, pTemp-ObjectName);
                                        ParentName[pTemp-ObjectName] = L'\0';

                                    } else {
                                        wcscpy(ParentName, ObjectName);
                                    }
                                }
                            }

                            rc = ScepObjectSetKeySetting(
                                    hSectionSap,
                                    ParentName,
                                    SCE_STATUS_NOT_CONFIGURED,
                                    TRUE,
                                    NULL,
                                    0,
                                    TRUE
                                    );
                        }
                    }

                    retStat = SCE_STATUS_NOT_CONFIGURED;

                } else {

                    if ( ConfigStatus != SCE_STATUS_OVERWRITE ) {
                        //
                        // delete all SAP below this object
                        //
                        rc = SceJetDelete(
                                hSectionSap,
                                ObjectName,
                                TRUE,
                                SCEJET_DELETE_PARTIAL_NO_CASE
                                );
                    }

                    if ( SCESTATUS_SUCCESS == rc ) {

                        //
                        // N.A. the object
                        //
                        rc = ScepObjectSetKeySetting(
                                hSectionSap,
                                ObjectName,
                                SCE_STATUS_NOT_ANALYZED,
                                IsContainer,
                                NULL,
                                0,
                                TRUE
                                );
                    }

                    retStat = SCE_STATUS_NOT_ANALYZED;
                }

            } else if ( ParentLevel <= 0 ||
                        ( ParentStatus != SCE_STATUS_OVERWRITE &&
                          ConfigStatus == SCE_STATUS_OVERWRITE) ) {

                // no parent, or parent check, object overwrite

                if ( ConfigStatus == SCE_STATUS_OVERWRITE ) {
                    //
                    // delete SAP entries between this node and all children
                    // C.C. all branch nodes in between
                    //
                    rc = ScepObjectRaiseChildrenInBetween(
                                hSectionSmp,
                                hSectionSap,
                                ObjectName,
                                NameLen,
                                IsContainer,
                                SCE_STATUS_CHILDREN_CONFIGURED,
                                FALSE
                                );
                }

                if ( SCESTATUS_SUCCESS == rc ) {

                    // C.C. this object
                    rc = ScepObjectSetKeySetting(
                            hSectionSap,
                            ObjectName,
                            SCE_STATUS_CHILDREN_CONFIGURED,
                            IsContainer,
                            NULL,
                            0,
                            TRUE
                            );
                }

                retStat = SCE_STATUS_CHILDREN_CONFIGURED;

            } else {
                //
                // have both parent and children
                //

                if ( ParentStatus == SCE_STATUS_OVERWRITE &&
                     ConfigStatus == SCE_STATUS_OVERWRITE &&
                     ( oldObjectFlag == SCE_STATUS_NOT_ANALYZED ||
                       (oldParentFlag != SCE_STATUS_NOT_ANALYZED &&
                        oldObjectFlag != SCE_STATUS_NOT_ANALYZED )
                     ) ) {
                    //
                    // (parent OVERWRITE, object N.A. OVERWRITE) or
                    // (parent not N.A., parent OVERWRITE, object not N.A., object OVERWRITE)
                    // N.A. the object
                    //
                    retStat = SCE_STATUS_NOT_ANALYZED;

                } else if ( ParentStatus == SCE_STATUS_OVERWRITE &&
                            ( ConfigStatus != SCE_STATUS_OVERWRITE ||
                              ( oldParentFlag == SCE_STATUS_NOT_ANALYZED &&
                                oldObjectFlag != SCE_STATUS_NOT_ANALYZED &&
                                ConfigStatus == SCE_STATUS_OVERWRITE ))
                          ) {
                    //
                    // (parent OVERWRITE, object CHECK) or
                    // (parent N.A., parent OVERWRITE, object not N.A., object OVERWRITE)
                    //
                    // delete SAP entries between this node and all children
                    // N.A. all branch nodes in between
                    //

                    rc = ScepObjectRaiseChildrenInBetween(
                                hSectionSmp,
                                hSectionSap,
                                ObjectName,
                                NameLen,
                                IsContainer,
                                SCE_STATUS_NOT_ANALYZED,
                                FALSE
                                );

                    // N.A. object
                    retStat = SCE_STATUS_NOT_ANALYZED;

                } else {
                    //
                    // must be parent CHECK, object CHECK }
                    // C.C. object
                    //

                    retStat = SCE_STATUS_NOT_ANALYZED;
                }

                if ( SCESTATUS_SUCCESS == rc ) {
                    rc = ScepObjectSetKeySetting(
                            hSectionSap,
                            ObjectName,
                            retStat,
                            IsContainer,
                            NULL,
                            0,
                            TRUE
                            );
                }
            }
            //
            // remove the SMP entry
            //
            if ( rc == SCESTATUS_SUCCESS ) {

                rc = SceJetDelete(
                        hSectionSmp,
                        ObjectName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
            }
        }
    }

    ScepFree(ParentName);

    if ( pAnalysisStatus ) {
        *pAnalysisStatus = retStat;
    }

    return(rc);
}


SCESTATUS
ScepObjectRaiseNodesInPath(
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN INT StartLevel,
    IN INT EndLevel,
    IN WCHAR Delim,
    IN BYTE Status
    )
{
    BOOL        LastOne=FALSE;
    SCESTATUS   rc = SCESTATUS_SUCCESS;
    PWSTR NodeName=NULL;

    //
    // process each node in between the start level and end level
    //
    for ( INT i=StartLevel; rc==SCESTATUS_SUCCESS && i < EndLevel; i++ ) {

        if ( NodeName == NULL ) {

            NodeName = (PWSTR)ScepAlloc(0, (NameLen+1)*sizeof(WCHAR));
            if ( NodeName == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                break;
            }
        }

        //
        // get level i full name
        //
        memset(NodeName, '\0', (NameLen+1)*sizeof(WCHAR));

        rc = ScepGetFullNameInLevel(
                    ObjectName,
                    i,
                    Delim,
                    FALSE,
                    NodeName,
                    &LastOne
                    );

        if ( rc == SCESTATUS_SUCCESS) {

            if (  Status != (BYTE)SCE_NO_VALUE ) {
                //
                // raise the status
                //

                rc = ScepObjectSetKeySetting(
                        hSectionSap,
                        NodeName,
                        Status,
                        TRUE,
                        NULL,
                        0,
                        TRUE
                        );
            } else {

                //
                // remove the raise
                //
                rc = SceJetDelete(
                        hSectionSap,
                        NodeName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
            }

        }

        if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            break;
        }

    }

    if ( NodeName ) {
        ScepFree(NodeName);
    }

    return rc;
}


SCESTATUS
ScepObjectTotalLevel(
    IN PWSTR ObjectName,
    IN WCHAR Delim,
    OUT PINT pLevel
    )
/*
Routine Description:

    Count total levels of the object name, for example, c:\winnt\system32
    will return level of 3

Arguements:

    ObjectName - the object's name in full path

    Delim       - the delimiter to look for

    pLevel      - the output level

Return Value:

    SCESTATUS
*/
{
    PWSTR pStart;

    if ( ObjectName == NULL || pLevel == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    pStart = ObjectName;
    *pLevel = 0;

    while (pStart) {

        (*pLevel)++;
        pStart = wcschr(pStart, Delim);

        if ( pStart != NULL && *(pStart+1) != L'\0' )
            pStart++;
        else
            break;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepObjectCompareKeySetting(
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pScepSD,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Compare an object's setting with info in the section.

Arguements:

    hSectionSap - the SAP section handle

    others see ScepUpdateObjectInfo

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    BYTE SapStatus;
    PSECURITY_DESCRIPTOR pSapSD = NULL;
    SECURITY_INFORMATION SapSeInfo;
    DWORD Win32rc;
    BYTE CompareStatus=0;


    rc = ScepObjectGetKeySetting(
            hSectionSap,
            ObjectName,
            &SapStatus,
            NULL,
            &pSapSD,
            &SapSeInfo
            );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // SAP record exists. was mismatched
        //
        Win32rc = ScepCompareObjectSecurity(
                        ObjectType,
                        IsContainer,
                        pSD,
                        pSapSD,
                        SeInfo,
                        &CompareStatus
                        );

        if ( Win32rc != NO_ERROR ) {
            rc = ScepDosErrorToSceStatus(Win32rc);

        } else if ( !CompareStatus ) {
            //
            // new setting is same as the SAP setting - matched
            // delete the SAP entry
            //
            rc = SceJetDelete(
                 hSectionSap,
                 ObjectName,
                 FALSE,
                 SCEJET_DELETE_LINE_NO_CASE
                 );

            if ( pAnalysisStatus ) {
                *pAnalysisStatus = SCE_STATUS_GOOD;
            }

        } else {
            //
            // still mismatched, just update the SMP entry (outside)
            //
            rc = ScepObjectSetKeySetting(
                    hSectionSap,
                    ObjectName,
                    CompareStatus, // SCE_STATUS_MISMATCH,
                    IsContainer,
                    pSapSD,
                    SapSeInfo,
                    TRUE
                    );
            if ( pAnalysisStatus ) {
                *pAnalysisStatus = CompareStatus;  // SapStatus;
            }

        }

        if ( pSapSD ) {
            ScepFree(pSapSD);
        }

    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SCESTATUS_SUCCESS;
        //
        // no SAP record exist. was matched
        //
        Win32rc = ScepCompareObjectSecurity(
                        ObjectType,
                        IsContainer,
                        pSD,
                        pScepSD,
                        SeInfo,
                        &CompareStatus
                        );

        if ( Win32rc != NO_ERROR ) {
            rc = ScepDosErrorToSceStatus(Win32rc);

        } else if ( CompareStatus ) {
            //
            // new setting is different from the SMP setting
            // create SAP entry using the SMP setting
            //
            rc = ScepObjectSetKeySetting(
                    hSectionSap,
                    ObjectName,
                    CompareStatus, // SCE_STATUS_MISMATCH,
                    IsContainer,
                    pScepSD,
                    SeInfo,
                    TRUE
                    );
            if ( pAnalysisStatus ) {
                *pAnalysisStatus = CompareStatus;  // SCE_STATUS_MISMATCH;
            }

        } else {

            if ( pAnalysisStatus ) {
                *pAnalysisStatus = SCE_STATUS_GOOD;
            }
        }

    }

    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
        rc = SCESTATUS_SUCCESS;
    }
    return(rc);
}


SCESTATUS
ScepObjectAdjustParentStatus(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN WCHAR Delim,
    IN INT Level,
    IN BYTE Flag,
    OUT PINT ParentLevel,
    OUT PBYTE ParentStatus OPTIONAL,
    OUT PWSTR ParentName OPTIONAL
    )
/*
Routine Description:

    delete the ignored parent in the object's path (should only have one)
    The following actions are taken when a IGNORE node is found:
       (it should have N.C.ed in SAP but no children has N.C record)
       delete all children in SMP and SAP
          (force to have only no or one IGNORE in the path)
       delete the SMP entry ( turn the IGNORE status to CHECK ?)
       There should be no other nodes under a IGNORE node. But if there are,
          delete them.
       raise SAP status as "Not analyzed"

Arguments:

    hSectionSmp - the SMP section handle

    hSectionSap - the SAP section handle

    ObjectName - the object's full name

    NameLen  - the length of the name

    Delim - the delimiter to look for

    Level - the total level of the object name

    ParentLevel - output of its closest parent level

    ParentStatus - output of its closest parent status

Return Value:

    SCE status
*/
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    INT i;
    PWSTR Name=NULL;
    BOOL LastOne;
    DWORD ParentLen;
    BYTE Status;
    PSECURITY_DESCRIPTOR pScepSD=NULL;
    SECURITY_INFORMATION SeInfo;

    Name = (PWSTR)ScepAlloc(0, (NameLen+2)*sizeof(WCHAR));

    if ( Name == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    *ParentLevel = 0;

    for ( i=Level-1; i>=1; i-- ) {
        //
        // get level i full name
        //
        memset(Name, '\0', (NameLen+2)*sizeof(WCHAR));

        rc = ScepGetFullNameInLevel(
                    ObjectName,
                    i,
                    Delim,
                    (Flag & SCE_OBJECT_SEARCH_JUNCTION) ? TRUE : FALSE,
                    Name,
                    &LastOne
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            //
            // search and get information of this path
            //
            if ( Flag & SCE_OBJECT_SEARCH_JUNCTION ) {

                DWORD Count=0;

                rc = SceJetGetLineCount(
                            hSectionSmp,
                            Name,
                            FALSE,
                            &Count
                            );

                if ( rc == SCESTATUS_SUCCESS &&
                     Count > 1 ) {
                    //
                    // there are other children under this node
                    // this is the junction point
                    //
                    *ParentLevel = i;
                    break;
                }
                //
                // dont' care error
                //
                rc = SCESTATUS_SUCCESS;

            } else {

                ParentLen = wcslen(Name);
                Status = (BYTE)-1;

                rc = ScepObjectGetKeySetting(
                        hSectionSmp,
                        Name,
                        &Status,
                        NULL,
                        &pScepSD,
                        &SeInfo
                        );

                if ( rc == SCESTATUS_SUCCESS ) {

                    //
                    // find a parent.
                    //
                    *ParentLevel = i;
                    if ( ParentStatus ) {
                        *ParentStatus = Status;
                    }
                    if ( ParentName ) {
                        wcscpy(ParentName, Name);
                    }

                    if ( (Flag & SCE_OBJECT_TURNOFF_IGNORE) &&
                         Status == SCE_STATUS_IGNORE ) {
                        //
                        // delete all SMP and SAP under this node
                        //
                        rc = ScepObjectDeleteScepAndAllChildren(
                                    hSectionSmp,
                                    hSectionSap,
                                    Name,
                                    TRUE,
                                    SCE_STATUS_NOT_ANALYZED
                                    );
    /*
                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // change its status to CHECK,
                            //
                            rc = ScepObjectSetKeySetting(
                                    hSectionSmp,
                                    Name,
                                    SCE_STATUS_CHECK,
                                    TRUE,
                                    pScepSD,
                                    SeInfo,
                                    TRUE
                                    );
                        }
    */
                        //
                        // all other nodes are deleted. should break out of the loop
                        //
                    }

                    if ( pScepSD ) {
                        ScepFree(pScepSD);
                        pScepSD = NULL;
                    }

                    if ( !(Flag & SCE_OBJECT_TURNOFF_IGNORE) ||
                         Status == SCE_STATUS_IGNORE ) {

                        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
                            rc = SCESTATUS_SUCCESS;

                        break;
                    }
                }
            }
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS;
        }

        //
        // process next parent
        //

        if ( rc != SCESTATUS_SUCCESS  )
            break;
    }

    ScepFree(Name);

    return(rc);
}

SCESTATUS
ScepObjectHasAnyChild(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN WCHAR Delim,
    OUT PBOOL bpHasChild
    )
/*
Routine Description:

    Detect if the object has child objects in the section

Arguements:

    hSection - the section handle

    ObjectName - the object name

    NameLen - the name length

    Delim - the delimeter to look for

    bpHasChild - output TRUE if the object has a child in the section

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    PWSTR pTemp=NULL;

    if ( hSection == NULL || ObjectName == NULL ||
         NameLen == 0 || Delim == L'\0' || bpHasChild == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    pTemp = (PWSTR)ScepAlloc(0, (NameLen+2)*sizeof(WCHAR));
    if ( pTemp != NULL ) {

        wcscpy(pTemp, ObjectName);
        pTemp[NameLen] = Delim;
        pTemp[NameLen+1] = L'\0';

        rc = SceJetSeek(
               hSection,
               pTemp,
               (NameLen+1)*sizeof(WCHAR),
               SCEJET_SEEK_GE_NO_CASE
               );

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            *bpHasChild = FALSE;
            rc = SCESTATUS_SUCCESS;

        } else if ( rc == SCESTATUS_SUCCESS ) {
            *bpHasChild = TRUE;
        }

        ScepFree(pTemp);

    } else
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

    return(rc);
}


SCESTATUS
ScepObjectRaiseChildrenInBetween(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN BOOL IsContainer,
    IN BYTE Status,
    IN BOOL bChangeStatusOnly
    )
/*
Routine Description:

    Delete any SAP entries for objects between Name and its children in SMP table
    and raise SAP entries for bridge nodes to the Status specified.

    For example, in the picture below, every SAP entry in the 1. level and 2. level
    , except the C nodes, should be deleted from SAP. Then 1. and 2. nodes are
    raised as Status.

         p
        /
       .
      N     <----
     / |
    1. C
    / \
   2.  C
    /|
   C C

Arguments:

    hSectionSmp - the SMP section handle

    hSection - the SAP section handle

    Name - the object name

    NameLen - the length of the name

    Status - the object's status to raise


Return Value:

    SCE status
*/
{
    SCESTATUS rc;

    PWSTR *pSmpNames=NULL;
    DWORD *pSmpNameLen=NULL;
    DWORD cntNames=0;
    BOOL bFirst=TRUE;
    WCHAR Delim=L'\\';

    DWORD DirLen = wcslen(ObjectName);

    if ( ObjectName[DirLen-1] != Delim ) {
        DirLen++;
    }

    PWSTR DirName = (PWSTR)ScepAlloc(0, (DirLen+1)*sizeof(WCHAR));

    if ( DirName == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    }

    wcscpy(DirName, ObjectName);

    if ( DirName[DirLen-1] != Delim ) {
        DirName[DirLen-1] = Delim;
    }

    //
    // get all children of DirName in SMP
    //
    rc = SceJetGetLineCount(
                    hSectionSmp,
                    DirName,
                    FALSE,
                    &cntNames);

    DWORD index=0;

    if ( rc == SCESTATUS_SUCCESS ) {

        pSmpNames = (PWSTR *)ScepAlloc(LPTR, cntNames*sizeof(PWSTR));
        pSmpNameLen = (DWORD *)ScepAlloc(LPTR, cntNames*sizeof(DWORD));

        if ( pSmpNames != NULL && pSmpNameLen != NULL ) {

            //
            // get each name loaded into this array
            //
            PWSTR Buffer=NULL;
            DWORD KeyLen;

            rc = SceJetGetValue(
                        hSectionSmp,
                        SCEJET_PREFIX_MATCH_NO_CASE,
                        DirName,
                        NULL,
                        0,
                        &KeyLen,
                        NULL,
                        0,
                        NULL
                        );

            bFirst = TRUE;

            while ( rc == SCESTATUS_SUCCESS ) {

                Buffer = (PWSTR)ScepAlloc(LPTR, (KeyLen+1)*sizeof(WCHAR));

                if ( Buffer == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }

                rc = SceJetGetValue(
                            hSectionSmp,
                            SCEJET_CURRENT,
                            NULL,
                            Buffer,
                            KeyLen*sizeof(WCHAR),
                            NULL,
                            NULL,
                            0,
                            NULL
                            );

                if ( rc == SCESTATUS_SUCCESS ) {

                    if ( !bFirst ||
                         _wcsicmp(DirName, Buffer) != 0 ) {
                        //
                        // ignore the object itself
                        //
                        pSmpNames[index] = Buffer;
                        pSmpNameLen[index] = wcslen(Buffer);

                        Buffer = NULL;
                        index++;
                    }

                    bFirst = FALSE;

                } else {

                    ScepFree(Buffer);
                    Buffer = NULL;
                    break;

                }

                //
                // read next line
                //
                rc = SceJetGetValue(
                            hSectionSmp,
                            SCEJET_NEXT_LINE,
                            NULL,
                            NULL,
                            0,
                            &KeyLen,
                            NULL,
                            0,
                            NULL
                            );
            }

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // should have one or more children but if it's 0
        // delete everything in SAP
        //
        if ( cntNames == 0 || pSmpNames == NULL ||
             pSmpNameLen == NULL ||
             pSmpNameLen[0] == 0 || pSmpNames[0] == NULL ) {

            rc = SceJetDelete(
                    hSectionSap,
                    DirName,
                    TRUE,
                    SCEJET_DELETE_PARTIAL_NO_CASE
                    );

        } else if ( !bChangeStatusOnly ) {

            //
            // get each name loaded into this array
            //
            PWSTR Buffer=NULL;
            DWORD KeyLen;

            rc = SceJetGetValue(
                        hSectionSap,
                        SCEJET_PREFIX_MATCH_NO_CASE,
                        DirName,
                        NULL,
                        0,
                        &KeyLen,
                        NULL,
                        0,
                        NULL
                        );

            bFirst = TRUE;
            index = 0;

            while ( rc == SCESTATUS_SUCCESS ) {

                Buffer = (PWSTR)ScepAlloc(LPTR, (KeyLen+1)*sizeof(WCHAR));

                if ( Buffer == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }

                rc = SceJetGetValue(
                            hSectionSap,
                            SCEJET_CURRENT,
                            NULL,
                            Buffer,
                            KeyLen*sizeof(WCHAR),
                            NULL,
                            NULL,
                            0,
                            NULL
                            );

                if ( rc == SCESTATUS_SUCCESS &&
                     (!bFirst ||
                      _wcsicmp(DirName, Buffer) != 0) ) {
                    //
                    // ignore the object itself
                    // compare with the next child in SMP
                    // if it's before the next child, should delete it
                    //
                    int ci = _wcsnicmp(Buffer, pSmpNames[index], pSmpNameLen[index]);

                    while ( rc == SCESTATUS_SUCCESS &&
                            ci > 0 ) {
                        //
                        // this is the component or next one, move on to next one
                        //
                        index++;

                        if ( index >= cntNames || pSmpNames[index] == NULL ||
                             pSmpNameLen[index] == 0 ) {
                            //
                            // no more SMP child. We are done.
                            //
                            rc = SCESTATUS_RECORD_NOT_FOUND;

                        } else {

                            //
                            // already bigger than this child
                            //

                            ci = _wcsnicmp(Buffer, pSmpNames[index], pSmpNameLen[index]);
                        }
                    }

                    if ( ci < 0 ) {

                        SceJetDelete(
                            hSectionSap,
                            NULL, // delete the current line
                            FALSE,
                            SCEJET_DELETE_LINE
                            );

                    }
                }

                bFirst = FALSE;

                ScepFree(Buffer);
                Buffer = NULL;

                if ( rc == SCESTATUS_SUCCESS ) {

                    //
                    // read next line
                    //
                    rc = SceJetGetValue(
                                hSectionSap,
                                SCEJET_NEXT_LINE,
                                NULL,
                                NULL,
                                0,
                                &KeyLen,
                                NULL,
                                0,
                                NULL
                                );
                }
            }

        }
    }

    //
    // raise SAP entries for branch nodes between ObjectName and
    // SMP names as Status, then free smp names array
    //
    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    SCESTATUS rc2 = rc;
    INT StartLevel=0, EndLevel=0;

    if ( pSmpNames ) {

        ScepObjectTotalLevel(ObjectName, Delim, &StartLevel);
        StartLevel++;

        for ( index=0; index<cntNames; index++) {
            if ( pSmpNames[index] ) {

                if ( SCESTATUS_SUCCESS == rc2 ) {
                    //
                    // get this object level
                    //
                    ScepObjectTotalLevel(pSmpNames[index], Delim, &EndLevel);

                    rc2 = ScepObjectRaiseNodesInPath(
                                hSectionSap,
                                pSmpNames[index],
                                pSmpNameLen[index],
                                StartLevel,
                                EndLevel,
                                Delim,
                                Status
                                );

                    if ( rc2 == SCESTATUS_RECORD_NOT_FOUND ) {
                        rc2 = SCESTATUS_SUCCESS;
                    }
                    if ( rc2 != SCESTATUS_SUCCESS ) {
                        rc = rc2;
                    }
                }

                ScepFree(pSmpNames[index]);
            }
        }

        ScepFree(pSmpNames);
    }

    if ( pSmpNameLen ) {
        ScepFree(pSmpNameLen);
    }

    ScepFree(DirName);

    return rc;
}


SCESTATUS
ScepGetFullNameInLevel(
    IN PCWSTR ObjectFullName,
    IN DWORD  Level,
    IN WCHAR  Delim,
    IN BOOL bWithLastDelim,
    OUT PWSTR Buffer,
    OUT PBOOL LastOne
    )
/* ++
Routine Description:

    This routine parses a full path name and returns the component for the
    level. For example, a object name "c:\winnt\system32" will return c: for
    level 1, winnt for level 2, and system32 for level 3. This routine is
    used when add a object to the security tree.

Arguments:

    ObjectFullName - The full path name of the object

    Level - the level of component to return

    Delim - the deliminator to look for

    Buffer - The address of buffer for the full path name to the level

    LastOne - Flag to indicate if the component is the last one

Return value:

    SCESTATUS

-- */
{
    PWSTR  pTemp, pStart;
    DWORD i;
    ULONG Len = 0;

    if ( ObjectFullName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // loop through the object name to find the level
    // if there is no such level, return INVALID_PARAMETER
    //
    pStart = (PWSTR)ObjectFullName;

    for ( i=0; i<Level; i++) {

        pTemp = wcschr(pStart, Delim);

        if ( i == Level-1 ) {
            //
            // find the right level
            //
            if ( pTemp == NULL ) {
                wcscpy(Buffer, ObjectFullName);
                if ( bWithLastDelim ) {
                    Len = wcslen(ObjectFullName);
                if (Buffer[Len - 1] != Delim)
                    Buffer[Len] = Delim;
                }
                *LastOne = TRUE;
            } else {
                Len = (DWORD)(pTemp - ObjectFullName);

                if ( bWithLastDelim ) {
                    Len++;
                }
                wcsncpy(Buffer, ObjectFullName, Len);

                if ( *(pTemp+1) == L'\0' )
                    *LastOne = TRUE;
                else
                    *LastOne = FALSE;
            }
        } else {
            if ( pTemp == NULL )
                return(SCESTATUS_INVALID_PARAMETER);
            else
                pStart = pTemp + 1;
        }
    }

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepUpdateLocalTable(
    IN PSCECONTEXT       hProfile,
    IN AREA_INFORMATION  Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD             dwMode
    )
{

    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( Area & AREA_SECURITY_POLICY ) {

        rc = ScepUpdateSystemAccess(hProfile,
                                    pInfo,
                                    NULL,
                                    NULL,
                                    dwMode
                                    );

        if ( rc == SCESTATUS_SUCCESS) {
            //
            // Update system auditing section
            //
            rc = ScepUpdateSystemAuditing(hProfile,
                                          pInfo,
                                          NULL,
                                          NULL,
                                          dwMode);

            if ( rc == SCESTATUS_SUCCESS) {
                //
                // Update log sections
                //
                rc = ScepUpdateLogs(hProfile,
                                    pInfo,
                                    NULL,
                                    NULL,
                                    dwMode
                                    );

                if ( rc == SCESTATUS_SUCCESS && pInfo->pKerberosInfo ) {
                    //
                    // Update kerberos policy
                    //
                    rc = ScepUpdateKerberos(hProfile,
                                            pInfo->pKerberosInfo,
                                            NULL,
                                            NULL,
                                            dwMode
                                            );
                }
                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // update registry values
                    //
                    rc = ScepUpdateLocalRegValues(hProfile,
                                                  pInfo,
                                                  dwMode
                                                  );

                }
                //
                // Note: policy attachment is not updated through this API
                //
            }
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            return(rc);
        }
    }

    if ( Area & AREA_PRIVILEGES ) {
        //
        // update user rights
        //
        rc = ScepUpdateLocalPrivileges(
                    hProfile,
                    pInfo->OtherInfo.smp.pPrivilegeAssignedTo,
                    dwMode
                    );

    }

    return rc;
}


SCESTATUS
ScepUpdateLocalSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update each key in the Keys array based on the editing rule. SMP entry is
    updated with the new value. SAP entry is either deleted, or created, depending
    on the new computed analysis status.

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    Keys     - the lookup keys array

    cKeys    - the number of keys in the array

    SecitonName - the section name to work on

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;

    DWORD       i;
    UINT        Offset;
    DWORD       val;


    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                SectionName,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( !( dwMode & SCE_UPDATE_DIRTY_ONLY) ) {

            SceJetDelete(hSectionSmp, NULL, FALSE, SCEJET_DELETE_SECTION);
        }

        for ( i=0; i<cKeys; i++) {

            //
            // get settings in AccessLookup table
            //

            Offset = Keys[i].Offset;

            switch ( Keys[i].BufferType ) {
            case 'B':
                break;

            case 'D':

                val = *((DWORD *)((CHAR *)pInfo+Offset));

                if ( val != SCE_NO_VALUE ) {
                    //
                    // something changed for this one
                    //
                    if ( ( dwMode & SCE_UPDATE_DIRTY_ONLY ) &&
                         ( val == SCE_DELETE_VALUE ) ) {

                        rc = SceJetDelete(
                                hSectionSmp,
                                Keys[i].KeyString,
                                FALSE,
                                SCEJET_DELETE_LINE_NO_CASE
                                );
                    } else {

                        //
                        // update the SMP entry
                        //
                        rc = ScepCompareAndSaveIntValue(
                                    hSectionSmp,
                                    Keys[i].KeyString,
                                    FALSE,
                                    SCE_NO_VALUE,
                                    val
                                    );
                    }

                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        //
                        // if not find for delete, ignore the error
                        //
                        rc = SCESTATUS_SUCCESS;
                    }
                }
                break;

            default:
                break;
            }

            if ( rc != SCESTATUS_SUCCESS ) {
                break;
            }
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);

}


SCESTATUS
ScepUpdateLocalRegValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD dwMode
    )
{
    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pInfo->RegValueCount == 0 ||
         pInfo->aRegValues == NULL ) {
        //
        // impossible to have a empty buffer to update
        // this buffer should contain all available registry values to configure/analyze
        //
        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    DWORD i;

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szRegistryValues,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( !(dwMode & SCE_UPDATE_DIRTY_ONLY) ) {

            SceJetDelete(hSectionSmp, NULL, FALSE, SCEJET_DELETE_SECTION);
        }

        for (i=0; i<pInfo->RegValueCount; i++ ) {

            if ( !(pInfo->aRegValues[i].FullValueName) ) {
                continue;
            }

            if ( ( dwMode & SCE_UPDATE_DIRTY_ONLY) &&
                 (pInfo->aRegValues[i].ValueType == SCE_DELETE_VALUE) ) {

                rc = SceJetDelete(
                        hSectionSmp,
                        pInfo->aRegValues[i].FullValueName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
            } else {

                //
                // update the SMP entry
                //
                rc = ScepSaveRegValueEntry(
                            hSectionSmp,
                            pInfo->aRegValues[i].FullValueName,
                            pInfo->aRegValues[i].Value,
                            pInfo->aRegValues[i].ValueType,
                            0
                            );
            }

            if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                //
                // if not find for delete, ignore the error
                //
                rc = SCESTATUS_SUCCESS;
            }

            if ( SCESTATUS_SUCCESS != rc ) {
                break;
            }

        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);
}


SCESTATUS
ScepUpdateLocalPrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pNewPriv,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update privileges

Arguements:

    hProfile - the jet database handle

    pNewPriv    - the changed info buffer

    pBufScep - the original SMP priv buffer

Return Value:

    SCESTATUS
*/
{
    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    LSA_HANDLE LsaHandle=NULL;
    SCESTATUS rc;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        return(ScepDosErrorToSceStatus(rc));
    }

    PSCESECTION hSectionSmp=NULL;

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szPrivilegeRights,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( !(dwMode & SCE_UPDATE_DIRTY_ONLY) ) {

            SceJetDelete(hSectionSmp, NULL, FALSE, SCEJET_DELETE_SECTION);
        }

        PSCE_PRIVILEGE_ASSIGNMENT pPriv;

        for ( pPriv=pNewPriv; pPriv != NULL; pPriv = pPriv->Next ) {

            //
            // Process each privilege in the new list
            //
            if ( pPriv->Name == NULL ) {
                continue;
            }

            if ( ( dwMode & SCE_UPDATE_DIRTY_ONLY) &&
                 ( pPriv->Status == SCE_DELETE_VALUE) ) {

                rc = SceJetDelete(
                            hSectionSmp,
                            pPriv->Name,
                            FALSE,
                            SCEJET_DELETE_LINE_NO_CASE
                            );
            } else {

                rc = ScepWriteNameListValue(
                        LsaHandle,
                        hSectionSmp,
                        pPriv->Name,
                        pPriv->AssignedTo,
                        SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT | SCE_WRITE_LOCAL_TABLE,
                        0
                        );

            }

            if ( rc == SCESTATUS_RECORD_NOT_FOUND )
                rc = SCESTATUS_SUCCESS;

            if ( rc != SCESTATUS_SUCCESS) {
                break;
            }

        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);
}


DWORD
ScepConvertNameListFormat(
    IN LSA_HANDLE LsaHandle,
    IN PSCE_NAME_LIST pInList,
    IN DWORD FromFormat,
    IN DWORD ToFormat,
    OUT PSCE_NAME_LIST *ppOutList
    )
{
    if (LsaHandle == NULL || ppOutList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppOutList = NULL;

    PSCE_NAME_LIST pList;
    DWORD rc = ERROR_SUCCESS;
    PWSTR   SidString=NULL;

    for ( pList=pInList; pList != NULL; pList=pList->Next ) {

        if ( pList->Name == NULL ) {
            continue;
        }

        if ( wcschr(pList->Name, L'\\') ) {

            rc = ScepLookupNameAndAddToSidStringList(
                                                    LsaHandle,
                                                    ppOutList,
                                                    pList->Name,
                                                    wcslen(pList->Name)
                                                    );
        } else if ( ScepLookupNameTable( pList->Name, &SidString ) ) {

            rc = ScepAddTwoNamesToNameList(
                                          ppOutList,
                                          FALSE,
                                          NULL,
                                          0,
                                          SidString,
                                          wcslen(SidString)
                                          );
        } else {

            rc = ScepAddToNameList(ppOutList, pList->Name, 0);

        }




        if ( rc != ERROR_SUCCESS ) {
            break;
        }
    }

    if ( rc != ERROR_SUCCESS &&
         (*ppOutList ) ) {
        ScepFreeNameList(*ppOutList);
        *ppOutList = NULL;
    }

    return(rc);
}

DWORD
ScepConvertPrivilegeList(
    IN LSA_HANDLE LsaHandle,
    IN PSCE_PRIVILEGE_ASSIGNMENT pFromList,
    IN DWORD FromFormat,
    IN DWORD ToFormat,
    OUT PSCE_PRIVILEGE_ASSIGNMENT *ppToList
    )
{

    if ( LsaHandle == NULL || pFromList == NULL || ppToList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( FromFormat != 0 ||
         ToFormat != SCE_ACCOUNT_SID_STRING ) {
        return(ERROR_NOT_SUPPORTED);
    }

    //
    // only support name->sid string convert, for now.
    //
    DWORD rc = ERROR_SUCCESS;
    PSCE_PRIVILEGE_ASSIGNMENT pPriv, pPriv2;
    PSCE_NAME_LIST pTempList=NULL;

    for ( pPriv=pFromList; pPriv != NULL; pPriv=pPriv->Next ) {

        if ( pPriv->Name == NULL ) {
            continue;
        }

        rc = ScepConvertNameListFormat(LsaHandle,
                                         pPriv->AssignedTo,
                                         FromFormat,
                                         ToFormat,
                                         &pTempList
                                        );

        if ( rc != ERROR_SUCCESS ) {
            break;
        }

        //
        // a sce_privilege_assignment structure. allocate buffer
        //
        pPriv2 = (PSCE_PRIVILEGE_ASSIGNMENT)ScepAlloc( LMEM_ZEROINIT,
                                                       sizeof(SCE_PRIVILEGE_ASSIGNMENT) );
        if ( pPriv2 == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPriv2->Name = (PWSTR)ScepAlloc( (UINT)0, (wcslen(pPriv->Name)+1)*sizeof(WCHAR));
        if ( pPriv2->Name == NULL ) {
            ScepFree(pPriv2);
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy(pPriv2->Name, pPriv->Name);
        pPriv2->Value = pPriv->Value;
        pPriv2->Status = pPriv->Status;

        pPriv2->AssignedTo = pTempList;
        pTempList = NULL;

        pPriv2->Next = *ppToList;
        *ppToList = pPriv2;

    }

    if ( pTempList ) {
        ScepFreeNameList(pTempList);
    }

    if ( rc != ERROR_SUCCESS &&
         (*ppToList) ) {
        //
        // free the output list
        //
        ScepFreePrivilege(*ppToList);
        *ppToList = NULL;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\errlog.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    errlog.c

Abstract:

    Routines to handle error log information

Author:

    Jin Huang (jinhuang) 9-Nov-1996

Revision History:

--*/

#include "headers.h"
#include "serverp.h"
#include <winnls.h>
#include <alloca.h>

#pragma hdrstop
#define SCESRV_LOG_PATH  L"\\security\\logs\\scesrv.log"

extern HINSTANCE MyModuleHandle;
HANDLE  Thread hMyLogFile=INVALID_HANDLE_VALUE;

BOOL
ScepCheckLogging(
    IN INT ErrLevel,
    IN DWORD rc
    );

SCESTATUS
ScepSetVerboseLog(
    IN INT dbgLevel
    )
{
    DWORD dValue;

    if ( dbgLevel > 0 ) {
        gDebugLevel = dbgLevel;

    } else {

        //
        // load value from registry
        //
        if ( ScepRegQueryIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                L"DebugLevel",
                &dValue
                ) == SCESTATUS_SUCCESS )
            gDebugLevel = (INT)dValue;
        else
            gDebugLevel = 1;
    }

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepEnableDisableLog(
   IN BOOL bOnOff
   )
{
   bLogOn = bOnOff;

   if ( INVALID_HANDLE_VALUE != hMyLogFile ) {
       CloseHandle( hMyLogFile );
   }

   //
   // Reset the LogFileName buffer and return
   //

   hMyLogFile = INVALID_HANDLE_VALUE;

   return(SCESTATUS_SUCCESS);
}



SCESTATUS
ScepLogInitialize(
   IN PCWSTR logname
   )
/* ++
Routine Description:

   Open the log file specified and save the name and its handle in global
   variables.

Arguments:

   logname - log file name

Return value:

   SCESTATUS error code

-- */
{
    DWORD  rc=NO_ERROR;

    if ( !bLogOn ) {
        return(rc);
    }

    if ( logname && wcslen(logname) > 3 ) {

        hMyLogFile = CreateFile(logname,
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if ( INVALID_HANDLE_VALUE != hMyLogFile ) {

            DWORD dwBytesWritten;

            SetFilePointer (hMyLogFile, 0, NULL, FILE_BEGIN);

            CHAR TmpBuf[3];
            TmpBuf[0] = (CHAR)0xFF;
            TmpBuf[1] = (CHAR)0xFE;
            TmpBuf[2] = '\0';

            WriteFile (hMyLogFile, (LPCVOID)TmpBuf, 2,
                       &dwBytesWritten,
                       NULL);

            SetFilePointer (hMyLogFile, 0, NULL, FILE_END);

        }

    } else {
        hMyLogFile = INVALID_HANDLE_VALUE;
    }

    BOOL bOpenGeneral = FALSE;

    if ( INVALID_HANDLE_VALUE == hMyLogFile ) {

        //
        // use the general server log
        //
        LPTSTR dName=NULL;
        DWORD dirSize=0;

        DWORD rc = ScepGetNTDirectory(
                            &dName,
                            &dirSize,
                            SCE_FLAG_WINDOWS_DIR
                            );

        if ( ERROR_SUCCESS == rc && dName ) {

            LPTSTR windirName = (LPTSTR)ScepAlloc(0, (dirSize+wcslen(SCESRV_LOG_PATH)+1)*sizeof(TCHAR));

            if ( windirName ) {

                wcscpy(windirName, dName);
                wcscat(windirName, SCESRV_LOG_PATH);

                //
                // only keep current log transaction. if other threads are holding
                // on this log, it won't be deleted. It's ok (will be deleted later).
                //
                DeleteFile(windirName);

                hMyLogFile = CreateFile(windirName,
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       OPEN_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL);

                if ( hMyLogFile != INVALID_HANDLE_VALUE ) {

                    DWORD dwBytesWritten;

                    SetFilePointer (hMyLogFile, 0, NULL, FILE_BEGIN);

                    CHAR TmpBuf[3];
                    TmpBuf[0] = (CHAR)0xFF;
                    TmpBuf[1] = (CHAR)0xFE;
                    TmpBuf[2] = '\0';

                    WriteFile (hMyLogFile, (LPCVOID)TmpBuf, 2,
                               &dwBytesWritten,
                               NULL);

                    SetFilePointer (hMyLogFile, 0, NULL, FILE_END);
                }

                ScepFree(windirName);

                bOpenGeneral = TRUE;

            }
        }

        if ( dName ) {
            ScepFree(dName);
        }

    }

    if ( hMyLogFile == INVALID_HANDLE_VALUE ) {

        //
        // Open file fails. return error
        //

        if (logname != NULL)
            rc = ERROR_INVALID_NAME;
    }

    //
    // log a separator to the file
    //
    ScepLogOutput3(0, 0, SCEDLL_SEPARATOR);

    if ( bOpenGeneral && logname ) {
        //
        // the log file provided is not valid, log it
        //
        ScepLogOutput3(0, 0, IDS_ERROR_OPEN_LOG, logname);
    }

    //
    // Write date/time information to the begining of the log file or to screen
    //
    TCHAR pvBuffer[100];

    pvBuffer[0] = L'\0';
    rc = ScepGetTimeStampString(pvBuffer);

    if ( pvBuffer[0] != L'\0' )
        ScepLogOutput(0, pvBuffer);

    return(rc);
}


SCESTATUS
ScepLogOutput2(
   IN INT     ErrLevel,
   IN DWORD   rc,
   IN PWSTR   fmt,
   ...
  )
/* ++

Routine Description:

   This routine adds the information (variable arguments) to the end of the log file or
   prints to screen

Arguments:

   ErrLevel - the error level of this error (to determine if the error needs to be outputted)

   rc    - Win32 error code

   fmt   - the format of the error information

   ...  - variable argument list

Return value:

   SCESTATUS error code

-- */
{
    PWSTR              buf=NULL;
    va_list            args;

    if ( !ScepCheckLogging(ErrLevel, rc) ) {
        //
        // no log
        //
        return(SCESTATUS_SUCCESS);
    }
    //
    // check arguments
    //
    if ( !fmt )
        return(SCESTATUS_SUCCESS);

    //
    // safely allocate the buffer on stack (or heap)
    //
    SafeAllocaAllocate( buf, SCE_BUF_LEN*sizeof(WCHAR) );
    if ( buf == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    va_start( args, fmt );
    _vsnwprintf( buf, SCE_BUF_LEN - 1, fmt, args );
    va_end( args );

    SCESTATUS rCode = ScepLogOutput(rc, buf);

    SafeAllocaFree( buf );

    return rCode;
}


SCESTATUS
ScepLogOutput(
    IN DWORD rc,
    IN LPTSTR buf
    )
{
    if ( !buf ) {
        return(SCESTATUS_SUCCESS);
    }

    LPVOID     lpMsgBuf=NULL;
    TCHAR      strLevel[32];
    INT        idLevel=0;

    if ( rc != NO_ERROR ) {

        //
        // determine if this is warning, or error
        //
        if ( rc == ERROR_FILE_NOT_FOUND ||
             rc == ERROR_PATH_NOT_FOUND ||
             rc == ERROR_ACCESS_DENIED ||
             rc == ERROR_CANT_ACCESS_FILE ||
             rc == ERROR_SHARING_VIOLATION ||
             rc == ERROR_INVALID_OWNER ||
             rc == ERROR_INVALID_PRIMARY_GROUP ||
             rc == ERROR_INVALID_HANDLE ||
             rc == ERROR_INVALID_SECURITY_DESCR ||
             rc == ERROR_INVALID_ACL ||
             rc == ERROR_SOME_NOT_MAPPED ) {
            //
            // this is warning
            //
            idLevel = IDS_WARNING;
        } else {
            //
            // this is error
            //
            idLevel = IDS_ERROR;
        }

        strLevel[0] = L'\0';

        if ( idLevel > 0 ) {

            LoadString( MyModuleHandle,
                        idLevel,
                        strLevel,
                        31
                        );
        }

        //
        // get error description of rc
        //

        FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL,
                       rc,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                       (LPTSTR)&lpMsgBuf,
                       0,
                       NULL
                    );
    }

    if ( hMyLogFile != INVALID_HANDLE_VALUE ) {

        //
        // The log file is initialized
        //
        if ( rc != NO_ERROR ) {
            if ( lpMsgBuf != NULL )
                ScepWriteVariableUnicodeLog( hMyLogFile, TRUE, L"%s %d: %s %s",
                                             strLevel, rc, (PWSTR)lpMsgBuf, buf );
            else
                ScepWriteVariableUnicodeLog( hMyLogFile, TRUE, L"%s %d: %s",
                                             strLevel, rc, buf );
        } else {
            if ( lpMsgBuf != NULL )
                ScepWriteVariableUnicodeLog( hMyLogFile, TRUE, L"%s %s",
                                             (PWSTR)lpMsgBuf, buf );
            else
                ScepWriteSingleUnicodeLog( hMyLogFile, TRUE, buf );
        }

    }

    if ( lpMsgBuf != NULL )
        LocalFree(lpMsgBuf);

    return(SCESTATUS_SUCCESS);
}


BOOL
ScepCheckLogging(
    IN INT ErrLevel,
    IN DWORD rc
    )
{

    DWORD      dValue;

    if ( rc )
        gWarningCode = rc;

    if ( !bLogOn ) {
        return(FALSE);
    }

    if ( gDebugLevel < 0 ) {
        //
        // load value from registry
        //
        if ( ScepRegQueryIntValue(
                HKEY_LOCAL_MACHINE,
                SCE_ROOT_PATH,
                L"DebugLevel",
                &dValue
                ) == SCESTATUS_SUCCESS )
            gDebugLevel = (INT)dValue;
        else
            gDebugLevel = 1;
    }
    //
    // return if the error level is higher than required
    //
    if ( ErrLevel > gDebugLevel ) {
        return(FALSE);
    } else {
        return(TRUE);
    }
}


SCESTATUS
ScepLogOutput3(
   IN INT     ErrLevel,
   IN DWORD   rc,
   IN UINT nId,
   ...
  )
/* ++

Routine Description:

   This routine load resource and adds error info (variable arguments)
   to the end of the log file or prints to screen

Arguments:

   ErrLevel - the error level of this error (to determine if the error needs to be outputted)

   rc    - Win32 error code

   nId   - the resource string ID

   ...  - variable argument list

Return value:

   SCESTATUS error code

-- */
{
    WCHAR              szTempString[256];
    PWSTR              buf=NULL;
    va_list            args;

    if ( !ScepCheckLogging(ErrLevel, rc) ) {
        //
        // no log
        //
        return(SCESTATUS_SUCCESS);
    }

    if ( nId > 0 ) {

        szTempString[0] = L'\0';

        LoadString( MyModuleHandle,
                    nId,
                    szTempString,
                    256
                    );

        //
        // safely allocate the buffer on stack (or heap)
        //
        SafeAllocaAllocate( buf, SCE_BUF_LEN*sizeof(WCHAR) );
        if ( buf == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }

        //
        // get the arguments
        //
        va_start( args, nId );
        _vsnwprintf( buf, SCE_BUF_LEN - 1, szTempString, args );
        va_end( args );

        //
        // log it and free
        //
        SCESTATUS rCode = ScepLogOutput(rc, buf);

        SafeAllocaFree( buf );

        return rCode;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepLogWriteError(
    IN PSCE_ERROR_LOG_INFO  pErrlog,
    IN INT ErrLevel
    )
/* ++
Routine Description:

   This routine outputs the error message in each node of the SCE_ERROR_LOG_INFO
   list to the log file

Arguments:

    pErrlog - the error list

Return value:

   None

-- */
{
    PSCE_ERROR_LOG_INFO  pErr;

    if ( !bLogOn ) {
        return(SCESTATUS_SUCCESS);
    }

    for ( pErr=pErrlog; pErr != NULL; pErr = pErr->next )
        if ( pErr->buffer != NULL )
            ScepLogOutput2( ErrLevel, pErr->rc, pErr->buffer );

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepLogClose()
/* ++
Routine Description:

   Close the log file if there is one opened. Clear the log varialbes

Arguments:

   None

Return value:

   None

--*/
{

    if ( !bLogOn ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( hMyLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( hMyLogFile );
    }

    //
    // Reset the log handle
    //

    hMyLogFile = INVALID_HANDLE_VALUE;

    return(SCESTATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\kerberos.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    kerberos.h

Abstract:

    Headers of apis for kerberos policy

Author:

    Jin Huang (jinhuang) 17-Dec-1997 created

Revision History:

    jinhuang 28-Jan-1998 splitted to client-server

--*/

#ifndef _sce_kerberos_
#define _sce_kerberos_

#ifdef __cplusplus
extern "C" {
#endif

SCESTATUS
ScepGetKerberosPolicy(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_KERBEROS_TICKET_INFO * ppKerberosInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepConfigureKerberosPolicy(
    IN PSCECONTEXT hProfile,
    IN PSCE_KERBEROS_TICKET_INFO pKerberosInfo,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepAnalyzeKerberosPolicy(
    IN PSCECONTEXT hProfile OPTIONAL,
    IN PSCE_KERBEROS_TICKET_INFO pKerInfo,
    IN DWORD Options
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\inftojet.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    inftojet.c

Abstract:

    Routines to convert security profiles in INF format to JET format.

Author:

    Jin Huang (jinhuang) 23-Jan-1997

Revision History:

--*/

#include "serverp.h"
#include "infp.h"
#include "pfp.h"
#include "regvalue.h"
#pragma hdrstop

//#define SCE_DBG 1
#define SCE_PRIV_ADD                TEXT("Add:")
#define SCE_PRIV_REMOVE             TEXT("Remove:")

#define SCE_OBJECT_FLAG_OBJECTS              1
#define SCE_OBJECT_FLAG_OLDSDDL              2
#define SCE_OBJECT_FLAG_UNKNOWN_VERSION      4

//
// Forward references
//
SCEINF_STATUS
SceInfpGetOneObject(
    IN PINFCONTEXT pInfLine,
    IN DWORD ObjectFlag,
    OUT PWSTR *Name,
    OUT PWSTR *Value,
    OUT PDWORD ValueLen
    );

#define SCE_CONVERT_INF_MULTISZ         0x01
#define SCE_CONVERT_INF_PRIV            0x02
#define SCE_CONVERT_INF_GROUP           0x04
#define SCE_CONVERT_INF_NEWVERSION      0x08
#define SCE_CONVERT_INF_REGVALUE        0x10

SCESTATUS
SceConvertpInfKeyValue(
    IN PCWSTR InfSectionName,
    IN HINF   hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN DWORD dwConvertOption,
    IN LONG GpoID,
    OUT PSCE_NAME_LIST *pKeyList
    );

SCESTATUS
SceConvertpInfObject(
    IN PCWSTR InfSectionName,
    IN UINT ObjectType,
    IN DWORD ObjectFlag,
    IN HINF   hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID
    );

SCESTATUS
SceConvertpInfDescription(
    IN HINF hInf,
    IN PSCECONTEXT hProfile
    );

SCESTATUS
SceConvertpAttachmentSections(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID,
    IN SCE_ATTACHMENT_TYPE aType
    );

SCESTATUS
SceConvertpWMIAttachmentSections(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID
    );

SCESTATUS
SceConvertpOneAttachmentSection(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN PWSTR SectionName,
    IN DWORD dwTableOption,
    IN LONG GpoID
    );

SCESTATUS
ScepBuildNewPrivilegeList(
    IN LSA_HANDLE *pPolicyHandle,
    IN PWSTR PrivName,
    IN PWSTR mszUsers,
    IN ULONG dwBuildOption,
    OUT PWSTR *pmszNewUsers,
    OUT DWORD *pNewLen
    );

SCESTATUS
ScepAddToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PWSTR Name,
    IN DWORD Len,
    IN DWORD PrivValue
    );


//
// Function definitions
//
SCESTATUS
SceJetConvertInfToJet(
    IN PCWSTR InfFile,
    IN LPSTR JetDbName,
    IN SCEJET_CREATE_TYPE Flags,
    IN DWORD Options,
    IN AREA_INFORMATION Area
    )
/**++

Function Description:

   This function converts a SCP profile in INF format to a Jet database format
   for the area provided. The SCP profile information is converted into the
   local policy table (SMP) in the Jet database.

   If the Jet database already exists, Flags is used to decide either overwrite,
   reuse, or just error out. All possible errors occur inside the routine are
   saved in the optional Errlog if Errlog is not NULL


Arguments:

   InfFile        - The Inf file name to convert from

   JetDbName      - the SCP profile in Jet format to convert into

   Flags          - Used when there is a duplicated Jet database
                        SCEJET_OVERWRITE
                        SCEJET_OPEN
                        0
   Options        - the conversion options

   Area           - the area to convert

Return Value:


-- **/
{
    PSCECONTEXT     hProfile=NULL;
    SCESTATUS       rc;
    PSCE_NAME_LIST  pProfileList=NULL,
                    pProfile=NULL;
    DWORD           Count;
    PSECURITY_DESCRIPTOR pSD=NULL;
    SECURITY_INFORMATION SeInfo;
    HINF            hInf=NULL;
    RPC_STATUS      RpcStatus=RPC_S_OK;

    INT Revision = 0;
    DWORD ObjectFlag=0;
    INFCONTEXT  InfLine;
    DWORD dwConvertOption=0;

    if ( InfFile == NULL ||
         JetDbName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // open the inf profile
    //
    rc = SceInfpOpenProfile(
                InfFile,
                &hInf
                );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                     SCEDLL_ERROR_OPEN,
                     (PWSTR)InfFile);
        return(rc);

    }

    LONG   GpoID=0;

    //
    // create/open the Jet database
    //
    DWORD dwNewOption = 0;

    // MREGE_POLICY option allows opening the temp merge policy table to build new policy
    // TATTOO option allows creating/opening the tattoo table into SAP context
    if ( Options & SCE_POLICY_TEMPLATE )
        dwNewOption |= SCE_TABLE_OPTION_MERGE_POLICY | SCE_TABLE_OPTION_TATTOO;
    // this check handles setup case (to create/open tattoo table)
    else {
        if ( (Options & SCE_SYSTEM_DB) )
            dwNewOption |= SCE_TABLE_OPTION_TATTOO;
        // dc demote should reset account policy and user rights at reboot (from tattoo table)
        if ( Options & SCE_DC_DEMOTE )
            dwNewOption |= SCE_TABLE_OPTION_DEMOTE_TATTOO;
    }

    rc = SceJetCreateFile(JetDbName,
                             Flags,
                             dwNewOption,
                             &hProfile);

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_ERROR_CREATE, L"database");

        goto CleanUp;

    }

    if ( Options & SCE_SYSTEM_DB ) {

        //
        // set Admin F, CO F to the database (protected)
        //
        rc = ConvertTextSecurityDescriptor (
                        L"D:P(A;;GA;;;CO)(A;;GR;;;WD)(A;;GA;;;BA)(A;;GA;;;SY)",
                        &pSD,
                        &Count,   // temp var for SDsize
                        &SeInfo
                        );
        if ( rc == NO_ERROR ) {

            ScepChangeAclRevision(pSD, ACL_REVISION);

            //
            // use current token as the owner (because this database is
            // to be created
            //

            HANDLE      Token=NULL;

            if (!OpenThreadToken( GetCurrentThread(),
                                   TOKEN_QUERY,
                                   FALSE,
                                   &Token)) {
                if (!OpenProcessToken( GetCurrentProcess(),
                                      TOKEN_QUERY,
                                      &Token)) {

                    ScepLogOutput3(1, GetLastError(), SCEDLL_ERROR_QUERY_INFO, L"TOKEN");
                }
            }

            if ( Token ) {

                PSECURITY_DESCRIPTOR pNewSD=NULL;

                //
                // RtlNewSecurityObjectEx must be called on the process context (system)
                // because it will try to get process information inside the api.
                //
                RpcRevertToSelf();

                rc = RtlNtStatusToDosError(
                        RtlNewSecurityObjectEx(
                                NULL,
                                pSD,
                                &pNewSD,
                                NULL, // GUID
                                FALSE,
                                SEF_DACL_AUTO_INHERIT |
                                SEF_AVOID_OWNER_CHECK |
                                SEF_AVOID_PRIVILEGE_CHECK,
                                Token,
                                &FileGenericMapping
                                ));

                RpcStatus = RpcImpersonateClient( NULL );

                if ( RpcStatus == RPC_S_OK ) {

                    if ( rc == NO_ERROR ) {

                        if ( !SetFileSecurityA (
                                    JetDbName,
                                    SeInfo,
                                    pNewSD
                                    ) ) {
                            rc = GetLastError();
                            ScepLogOutput3(1, rc,
                                          SCEDLL_ERROR_SET_SECURITY, L"database");
                        }
                        ScepFree(pNewSD);

                    } else {

                        ScepLogOutput3(1, rc,
                                      SCEDLL_ERROR_BUILD_SD, L"database");
                    }

                } else {
                    if ( rc == NO_ERROR ) {

                        ScepFree(pNewSD);
                    }

                    ScepLogOutput3(1, I_RpcMapWin32Status(RpcStatus),
                                  SCEDLL_ERROR_BUILD_SD, L"database");
                }

                CloseHandle(Token);
            }

            ScepFree(pSD);

        } else
            ScepLogOutput3(1, rc, SCEDLL_ERROR_BUILD_SD, L"database");
    }

    if ( RpcStatus != RPC_S_OK ) {
        goto CleanUp;
    }

    if ( !(Options & SCE_POLICY_TEMPLATE) ) {
        //
        // if not in the middle of policy propagation, use Jet transaction
        // otherwise, use the temp table concept.
        //
        SceJetStartTransaction( hProfile );

        //
        //If it is in demote or snapshot mode delete local policy.
        //
        if ( (Options & SCE_DC_DEMOTE) &&
             (Options & SCE_SYSTEM_DB) ) {

            ScepDeleteInfoForAreas(
                      hProfile,
                      SCE_ENGINE_SMP,
                      AREA_ALL
                      );

            ScepDeleteInfoForAreas(
                  hProfile,
                  SCE_ENGINE_SAP, // tattoo
                  AREA_ALL
                  );

        } else if ( Options & SCE_GENERATE_ROLLBACK ) {
            ScepDeleteInfoForAreas(
                      hProfile,
                      SCE_ENGINE_SMP,
                      AREA_ALL
                      );
        }

    } else if ( Options & SCE_POLICY_FIRST ) {

        //
        // The ENGINE_SCP table points to the new merge table
        // instead of the existing one.
        //
        // delete everything in SCP then
        // copy Tattoo to SCP
        //

        rc = ScepDeleteInfoForAreas(
                  hProfile,
                  SCE_ENGINE_SCP,
                  AREA_ALL
                  );

        if ( rc != SCESTATUS_SUCCESS && rc != SCESTATUS_RECORD_NOT_FOUND ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                         SCEDLL_ERROR_DELETE, L"SCP");

            goto CleanUp;
        }

        //
        // delete GPO table to start over
        //

        SceJetDeleteAll( hProfile,
                         "SmTblGpo",
                         SCEJET_TABLE_GPO
                       );

        PSCE_ERROR_LOG_INFO  Errlog=NULL;

        ScepLogOutput3(2, rc, SCEDLL_COPY_LOCAL);

        // copy from tattoo table to effective policy table
        rc = ScepCopyLocalToMergeTable( hProfile,
                                          Options,
                                          (ProductType == NtProductLanManNt) ? SCE_LOCAL_POLICY_DC : 0,
                                          &Errlog );

        ScepLogWriteError( Errlog,1 );
        ScepFreeErrorLog( Errlog );
        Errlog = NULL;

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                         SCEDLL_ERROR_COPY);

            goto CleanUp;
        }

        //
        // now, migrate database if tattoo table doesn't exist (in existing database)
        // this could happen if someone manually copied a database to the system
        // database location, or if the database failed to be migrated in setup
        //

        if ( hProfile->JetSapID == JET_tableidNil ) {
            SceJetCreateTable(
                    hProfile,
                    "SmTblTattoo",
                    SCEJET_TABLE_TATTOO,
                    SCEJET_CREATE_IN_BUFFER,
                    NULL,
                    NULL
                    );
        }
    }

    TCHAR  szGpoName[MAX_PATH];

    szGpoName[0] = L'\0';
    szGpoName[1] = L'\0';
    szGpoName[2] = L'\0';

    if ( Options & SCE_POLICY_TEMPLATE ) {
        //
        // get the GPO path and GPOID
        //
        GetPrivateProfileString(TEXT("Version"),
                                TEXT("GPOPath"),
                                TEXT(""),
                                szGpoName,
                                MAX_PATH,
                                InfFile
                               );

        if ( szGpoName[0] != L'\0' ) {

            PWSTR pTemp = wcschr(szGpoName, L'\\');

            if ( pTemp ) {
                *pTemp = L'\0';
            }

            GpoID = SceJetGetGpoIDByName(hProfile,
                                      szGpoName,
                                      TRUE   // add if it's not there
                                      );
            //
            // if GpoID is -1, an error occurred
            //
            if ( GpoID < 0 ) {

                rc = GetLastError();

                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepLogOutput3( 1, ScepDosErrorToSceStatus(rc),
                                   SCEDLL_ERROR_CONVERT, (PWSTR)szGpoName);
                    goto CleanUp;
                }
            }
        }
    }

    //
    // query the version # to determine if the SDDL string should be migrated
    //

    if ( SetupFindFirstLine(hInf,L"Version",L"Revision",&InfLine) ) {
        if ( !SetupGetIntField(&InfLine, 1, (INT *)&Revision) ) {
            Revision = 0;
        }
    }

    if ( Revision == 0 ) ObjectFlag = SCE_OBJECT_FLAG_OLDSDDL;

    if ( Revision > SCE_TEMPLATE_MAX_SUPPORTED_VERSION ) {

        dwConvertOption = SCE_CONVERT_INF_NEWVERSION;
        ObjectFlag |= SCE_OBJECT_FLAG_UNKNOWN_VERSION;

    }

    //
    // process each area
    //
    if ( Area & AREA_SECURITY_POLICY ) {

        if ( !( Options & SCE_NO_DOMAIN_POLICY) ) {

            // System Access section
            rc = SceConvertpInfKeyValue(
                        szSystemAccess,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szSystemAccess);
                goto CleanUp;
            }
        }

//
//      configure event log settings in setup too
//      since local policy table is not used in policy prop anymore
//
//        if ( !(Options & SCE_SYSTEM_DB) ||
//             (Options & SCE_POLICY_TEMPLATE) ) {

            // System Log section
            rc = SceConvertpInfKeyValue(
                        szAuditSystemLog,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szAuditSystemLog);
                goto CleanUp;
            }

            // Security Log section
            rc = SceConvertpInfKeyValue(
                        szAuditSecurityLog,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szAuditSecurityLog);
                goto CleanUp;
            }

            // Application Log section
            rc = SceConvertpInfKeyValue(
                        szAuditApplicationLog,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szAuditApplicationLog);
                goto CleanUp;
            }
//        }

        // Audit Event section
        rc = SceConvertpInfKeyValue(
                    szAuditEvent,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption,
                    GpoID,
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szAuditEvent);
            goto CleanUp;
        }

        if ( !( Options & SCE_NO_DOMAIN_POLICY) &&
             (ProductType == NtProductLanManNt) &&
             !( Options & SCE_DC_DEMOTE) ) {

            // Kerberos section
            rc = SceConvertpInfKeyValue(
                        szKerberosPolicy,
                        hInf,
                        hProfile,
                        dwNewOption,
                        dwConvertOption,
                        GpoID,
                        NULL
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szKerberosPolicy);
                goto CleanUp;
            }
        }

        // registry values
        rc = SceConvertpInfKeyValue(
                    szRegistryValues,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption | SCE_CONVERT_INF_MULTISZ | SCE_CONVERT_INF_REGVALUE,
                    GpoID,
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szRegistryValues);
            goto CleanUp;
        }

        rc = SceConvertpAttachmentSections(hInf,
                                           hProfile,
                                           (Options & SCE_POLICY_TEMPLATE) ? TRUE : FALSE,
                                           GpoID,
                                           SCE_ATTACHMENT_POLICY);

        if ( rc != SCESTATUS_SUCCESS ) {

            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_SAP_ERROR_ENUMERATE, L"policy attachments.");

            goto CleanUp;
        }
    }

    if ( Area & AREA_REGISTRY_SECURITY ) {
        //
        // Object type - Registry
        //
        rc = SceConvertpInfObject(
                    szRegistryKeys,
                    1,
                    ObjectFlag | SCE_OBJECT_FLAG_OBJECTS,
                    hInf,
                    hProfile,
                    dwNewOption,
                    GpoID
                    );
        if ( rc != SCESTATUS_SUCCESS ) {

            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szRegistryKeys);
            goto CleanUp;
        }
    }

    if ( Area & AREA_FILE_SECURITY ) {

        // File security
        rc = SceConvertpInfObject(
                    szFileSecurity,
                    2,
                    ObjectFlag | SCE_OBJECT_FLAG_OBJECTS,
                    hInf,
                    hProfile,
                    dwNewOption,
                    GpoID
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szFileSecurity);
            goto CleanUp;
        }
    }

#if 0
    //
    // DS object security
    //
    rc = SceConvertpInfObject(
                szDSSecurity,
                3,
                ObjectFlag | SCE_OBJECT_FLAG_OBJECTS,
                hInf,
                hProfile,
                dwNewOption,
                GpoID
                );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szDSSecurity);
        goto CleanUp;
    }
#endif

    if ( Area & AREA_SYSTEM_SERVICE ) {

        //
        // Service General Settings
        //
        rc = SceConvertpInfObject(
                    szServiceGeneral,
                    0,
                    ObjectFlag,
                    hInf,
                    hProfile,
                    dwNewOption,
                    GpoID
                    );

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szServiceGeneral);
            goto CleanUp;
        }

        //
        // each service's specific settings
        //
        rc = SceConvertpAttachmentSections(hInf,
                                           hProfile,
                                           dwNewOption,
                                           GpoID,
                                           SCE_ATTACHMENT_SERVICE);
        if ( rc != SCESTATUS_SUCCESS ) {

            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_SAP_ERROR_ENUMERATE, L"service attachments.");

            goto CleanUp;
        }
    }

    if ( (Area & AREA_ATTACHMENTS) ) {

        //
        // each service's specific settings
        //
        rc = SceConvertpWMIAttachmentSections(hInf,
                                           hProfile,
                                           dwNewOption,
                                           GpoID
                                           );
        if ( rc != SCESTATUS_SUCCESS ) {

            goto CleanUp;
        }
    }

    if ( Area & AREA_PRIVILEGES ) {
        //
        // Multi-Sz type - privilege/rights
        //
        rc = SceConvertpInfKeyValue(
                    szPrivilegeRights,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption | SCE_CONVERT_INF_MULTISZ | SCE_CONVERT_INF_PRIV,
                    GpoID,
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szPrivilegeRights);
            goto CleanUp;
        }
    }

    if ( Area & AREA_GROUP_MEMBERSHIP ) {
        // group membership
        rc = SceConvertpInfKeyValue(
                    szGroupMembership,
                    hInf,
                    hProfile,
                    dwNewOption,
                    dwConvertOption | SCE_CONVERT_INF_MULTISZ | SCE_CONVERT_INF_GROUP,
                    GpoID,
                    NULL
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                          SCEDLL_ERROR_CONVERT_SECTION, (PWSTR)szGroupMembership);
            goto CleanUp;
        }
    }

    //
    // if there is a description, convert it.
    //
    SceConvertpInfDescription(
                hInf,
                hProfile);

    if ( !(Options & SCE_POLICY_TEMPLATE) ) {
        //
        // Commit changes
        //
        SceJetCommitTransaction( hProfile, 0 );

    } else if ( Options & SCE_POLICY_LAST ) {
        //
        // update the LastUsedMergeTable field
        //

        DWORD dwThisTable = hProfile->Type & 0xF0L;

        if ( SCEJET_MERGE_TABLE_1 == dwThisTable ||
             SCEJET_MERGE_TABLE_2 == dwThisTable ) {

            rc = SceJetSetValueInVersion(
                        hProfile,
                        "SmTblVersion",
                        "LastUsedMergeTable",
                        (PWSTR)&dwThisTable,
                        4,
                        JET_prepReplace
                        );
        }

    }

CleanUp:

    //
    // close the inf profile
    //
    SceInfpCloseProfile(hInf);

    if ( pProfileList != NULL ) {
        ScepFreeNameList(pProfileList);
    }

    //
    // Rollback
    //
    if ( !(Options & SCE_POLICY_TEMPLATE) &&
         (RpcStatus == RPC_S_OK) &&
         (rc != SCESTATUS_SUCCESS) ) {

        SceJetRollback( hProfile, 0 );
    }

    //
    // Close the JET database
    //

    SceJetCloseFile( hProfile, TRUE, FALSE );

    if ( RpcStatus != RPC_S_OK ) {
        rc = I_RpcMapWin32Status(RpcStatus);
    }

    return(rc);

}


SCESTATUS
SceConvertpAttachmentSections(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID,
    IN SCE_ATTACHMENT_TYPE aType
    )
{
    SCESTATUS rc;
    PSCE_SERVICES    pServiceList=NULL, pNode;

    rc = ScepEnumServiceEngines( &pServiceList, aType );

    if ( rc == SCESTATUS_SUCCESS ) {

       for ( pNode=pServiceList; pNode != NULL; pNode=pNode->Next) {

           rc = SceConvertpOneAttachmentSection(hInf,
                                                hProfile,
                                                pNode->ServiceName,
                                                dwTableOption,
                                                GpoID
                                               );
           if ( rc != SCESTATUS_SUCCESS ) {
               ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                             SCEDLL_ERROR_CONVERT_SECTION, pNode->ServiceName );
               break;
           }
       }

       SceFreePSCE_SERVICES(pServiceList);

    } else if ( rc == SCESTATUS_PROFILE_NOT_FOUND ||
                rc == SCESTATUS_RECORD_NOT_FOUND ) {
        // if no service exist, just ignore
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);
}


SCESTATUS
SceConvertpWMIAttachmentSections(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID
    )
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    INFCONTEXT  InfLine;
    WCHAR SectionName[513];
    DWORD DataSize=0;

    if ( SetupFindFirstLine(hInf, szAttachments,NULL,&InfLine) ) {

        do {

            memset(SectionName, '\0', 513*sizeof(WCHAR));

            // get each attachment section name
            if(SetupGetStringField(&InfLine, 0, SectionName, 512, &DataSize) ) {

                rc = SceConvertpOneAttachmentSection(hInf,
                                                     hProfile,
                                                     SectionName,
                                                     dwTableOption,
                                                     GpoID
                                                    );

                if ( rc != SCESTATUS_SUCCESS ) {
                   ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                 SCEDLL_ERROR_CONVERT_SECTION, SectionName );
                   break;
                }

            } else {
                rc = ScepDosErrorToSceStatus(GetLastError());
            }

        } while ( rc == SCESTATUS_SUCCESS &&
                  SetupFindNextLine(&InfLine, &InfLine));
    }

    return(rc);

}

SCESTATUS
SceConvertpOneAttachmentSection(
    IN HINF hInf,
    IN PSCECONTEXT hProfile,
    IN PWSTR SectionName,
    IN DWORD dwTableOption,
    IN LONG GpoID
    )
{

    SCESTATUS rc;
    PSCESVC_CONFIGURATION_INFO pServiceInfo=NULL;

    //
    // read inf info for the service
    //
    rc = SceSvcpGetInformationTemplate(
            hInf,
            SectionName,
            NULL,  // not a single key
            &pServiceInfo
            );

    if ( rc == SCESTATUS_SUCCESS && pServiceInfo != NULL ) {
       //
       // write the information to SCP or SMP table
       //

       if ( dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY ) {

           rc = SceSvcpSetInfo(
                    hProfile,
                    SceSvcInternalUse,
                    SectionName,
                    NULL,
                    TRUE,    // to support incremental template, DO NOT overwrite the whole section
                    GpoID,
                    pServiceInfo
                    );
       } else {
           rc = SceSvcpSetInfo(
                    hProfile,
                    SceSvcConfigurationInfo,
                    SectionName,
                    NULL,
                    TRUE,    // to support incremental template, DO NOT overwrite the whole section
                    0,
                    pServiceInfo
                    );
       }

       //
       // free buffer
       //
       SceSvcpFreeMemory(pServiceInfo);
       pServiceInfo = NULL;

    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
       rc = SCESTATUS_SUCCESS;
    }

    return(rc);
}


SCESTATUS
SceConvertpInfKeyValue(
    IN PCWSTR InfSectionName,
    IN HINF   hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN DWORD dwConvertOption,
    IN LONG GpoID,
    OUT PSCE_NAME_LIST *pKeyList OPTIONAL
    )
/* ++
Routine Description:

    This routine converts INF sections which are in a key=value format. Value
    could be in MultiSz format (dwConvertOption & SCE_CONVERT_INF_MULTISZ).
    The optional pKeyList is a list of all keys in the section. This option
    is used when dynamic sections are converted.

Arguments:

    InfSectionName  - the INF section name to convert

    hInf            - the Inf file handle

    hprofile        - the Jet database context

    dwTableOption   - SCE_TABLE_OPTION_MERGE_POLICY = within policy propagation
                      SCE_TABLE_OPTION_TATTOO - system db (in setup)

    dwConvertOption - SCE_CONVERT_INF_MULTISZ - MultiSz type value
                      SCE_CONVERT_INF_PRIV    - user right section
                      SCE_CONVERT_INF_GROUP   - group membership section

    GpoID           - the group policy ID for this item

    pKeyList        - a list of all keys in the section.

Return Value:

-- */
{
    SCESTATUS    rc;
    DOUBLE      SectionID;
    PSCESECTION hSection=NULL;
    PSCESECTION hSectionTattoo=NULL;
    INFCONTEXT  InfLine;
    WCHAR       Keyname[SCE_KEY_MAX_LENGTH];
    PWSTR       pSidStr=NULL;
    PWSTR       pKeyStr=NULL;
    PWSTR       StrValue=NULL;
    DWORD       ValueLen=0;
    LSA_HANDLE  LsaPolicy=NULL;
    DWORD Len=0;


    if ( InfSectionName == NULL ||
         hInf == INVALID_HANDLE_VALUE ||
         hProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get section's ID. if the section does not exist, add it to the section table
    //
    rc = SceJetGetSectionIDByName(
                hProfile,
                InfSectionName,
                &SectionID
                );
    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SceJetAddSection(
                    hProfile,
                    InfSectionName,
                    &SectionID
                    );
    }
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_ERROR_QUERY_INFO, (PWSTR)InfSectionName );
        return(rc);
    }

    if ( SetupFindFirstLine(hInf,InfSectionName,NULL,&InfLine) ) {

        if ( dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY ) {

            //
            // open the SCP section
            //
            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_SCP,
                        &hSection
                        );
        } else {

            //
            // open SMP table
            //
            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_SMP,
                        &hSection
                        );

            //
            // open the tattoo (in order to update tattoo value in setup)
            // do not care error
            //
            if ( dwTableOption & SCE_TABLE_OPTION_TATTOO )
                SceJetOpenSection(hProfile, SectionID,
                                  SCEJET_TABLE_TATTOO,
                                  &hSectionTattoo);

        }

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_OPEN, (PWSTR)InfSectionName);

            if (hSection != NULL )
                SceJetCloseSection( &hSection, TRUE);
            if (hSectionTattoo != NULL )
                SceJetCloseSection( &hSectionTattoo, TRUE);

            return(rc);
        }

        //
        // Open LSA policy handle for group name lookup, if any
        // if policy handle can't be opened, import name format
        //

        if ( dwConvertOption & SCE_CONVERT_INF_GROUP ) {

            ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaPolicy,
                    TRUE
                    );
        }

        //
        // process each line in the section and save to the scp table.
        // Each INF line has a key and a value.
        //

        do {

            memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(TCHAR));
            rc = SCESTATUS_BAD_FORMAT;

            if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) ) {

                //
                // check if newer version (keys) are passed
                //
                if ( (dwConvertOption & SCE_CONVERT_INF_NEWVERSION) ) {

                    if ( dwConvertOption & SCE_CONVERT_INF_PRIV )  {

                        //
                        // user rights from new version
                        // filter out all unknown rights
                        //
                        if ( -1 == ScepLookupPrivByName(Keyname) ) {

                            rc = SCESTATUS_SUCCESS;
                            goto NextLine;
                        }

                    } else if ( dwConvertOption & SCE_CONVERT_INF_REGVALUE ) {
                        //
                        // convert registry values, should check number of fields
                        //
                        if ( SetupGetFieldCount( &InfLine ) < 2 ) {

                            rc = SCESTATUS_SUCCESS;
                            goto NextLine;
                        }
                    }
                }

                if ( (dwConvertOption & SCE_CONVERT_INF_GROUP) &&
                     ( (dwConvertOption & SCE_CONVERT_INF_NEWVERSION) ||
                       (Keyname[0] != L'*') ) ) {
                    //
                    // this is a group in name format
                    //

                    PWSTR pTemp = (PWSTR)Keyname;
                    //
                    // search for the suffix (szMembers or szMemberof or szPrivileges)
                    //
                    while ( pTemp = wcsstr(pTemp, szMembers) ) {
                        if ( *(pTemp+wcslen(szMembers)) != L'\0') {
                            pTemp++;
                            ValueLen = 0;
                        } else {
                            break;
                        }
                    }

                    if ( pTemp == NULL ) {

                        pTemp = (PWSTR)Keyname;

                        while ( pTemp = wcsstr(pTemp, szMemberof) ) {
                            if ( *(pTemp+wcslen(szMemberof)) != L'\0') {
                                pTemp++;
                                ValueLen = 1;
                            } else {
                                break;
                            }
                        }

                        if ( pTemp == NULL ) {

                            pTemp = (PWSTR)Keyname;

                            while ( pTemp = wcsstr(pTemp, szPrivileges) ) {
                                if ( *(pTemp+wcslen(szPrivileges)) != L'\0') {
                                    pTemp++;
                                    ValueLen = 2;
                                } else {
                                    break;
                                }
                            }
                        }
                    }

                    if ( pTemp == NULL ) {
                        //
                        // this is an unknown group format, just import the keyname
                        // for supported version; for new version template, ignore
                        // this line
                        //
                        if ( (dwConvertOption & SCE_CONVERT_INF_NEWVERSION) ) {
                            rc = SCESTATUS_SUCCESS;
                            goto NextLine;
                        }

                    } else if ( Keyname[0] != L'*' ) {

                        *pTemp = L'\0';

                        PWSTR pTemp1 = wcschr(Keyname, L'\\');
                        Len=0;

                        if ( pTemp1 && LsaPolicy ) {

                            //
                            // convert group name (domain\account) into *SID format
                            //

                            ScepConvertNameToSidString(
                                        LsaPolicy,
                                        Keyname,
                                        FALSE,
                                        &pSidStr,
                                        &Len
                                        );

                        } else if ( !pTemp1 ) {

                            if ( !ScepLookupNameTable( Keyname, &pSidStr ) ) {
                                //
                                // check in the constant SID table first
                                //
                                pSidStr = NULL;

                                if ( LsaPolicy) {
                                    //
                                    // free text group name, resolve it
                                    //

                                    ScepConvertNameToSidString(
                                                LsaPolicy,
                                                Keyname,
                                                FALSE,
                                                &pSidStr,
                                                &Len
                                                );
                                }

                            } else {

                                Len = wcslen(pSidStr);
                            }
                        }

                        //
                        // restore the "_"
                        //
                        *pTemp = L'_';

                        if ( pSidStr ) {
                            //
                            // add the suffix
                            //
                            pKeyStr = (PWSTR)ScepAlloc(0, (Len+wcslen(pTemp)+1)*sizeof(WCHAR));

                            if ( pKeyStr ) {

                                wcscpy(pKeyStr, pSidStr);
                                wcscat(pKeyStr, pTemp);

                            } else {
                                //
                                // use the name instead - out of memory will be caught later
                                //
                            }

                            ScepFree(pSidStr);
                            pSidStr = NULL;
                        }
                    }
                }

                if ( ((dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                      SetupGetMultiSzField(&InfLine, 1, NULL, 0, &ValueLen)) ||
                     (!(dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                      SetupGetStringField(&InfLine, 1, NULL, 0, &ValueLen)) ) {

                    if ( ValueLen > 1 ) {
                        StrValue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                    (ValueLen+1)*sizeof(TCHAR));

                        if( StrValue == NULL ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        } else if( ((dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                                    SetupGetMultiSzField(&InfLine, 1, StrValue, ValueLen, NULL)) ||
                                (!(dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                                 SetupGetStringField(&InfLine,1,StrValue,ValueLen,NULL)) ) {

                            //
                            // if dealing with registry values only, do the following:
                            // compress regtype into one CHAR instead of many WCHARS
                            // (can canonicalize REG_QWORD value later by arithmetic padding etc.- doesn't
                            // make sense now since registry api's treat REG_QWORD as a string anyway)
                            //

                            if ( dwConvertOption & SCE_CONVERT_INF_REGVALUE ) {

                                DWORD   LenStrValue = wcslen(StrValue);

                                if (LenStrValue > 1) {
                                    *((CHAR *)StrValue) = (CHAR) (_wtol(StrValue) + '0');
                                    memmove( StrValue+1,
                                             StrValue + LenStrValue,
                                             sizeof(WCHAR) * (ValueLen - LenStrValue));
                                    ValueLen -= (LenStrValue - 1);
                                }
                            }

                            rc = SCESTATUS_SUCCESS;

                        } else {
                            ScepFree(StrValue);
                            StrValue = NULL;
                        }

                    } else {
                        rc = SCESTATUS_SUCCESS;
                        ValueLen = 0;
                    }

                    PWSTR NewValue=NULL;
                    DWORD NewLen=0;

                    if ( rc == SCESTATUS_SUCCESS ) {

                        if ( (dwConvertOption & SCE_CONVERT_INF_MULTISZ) &&
                             StrValue != NULL &&
                             (dwConvertOption & SCE_CONVERT_INF_PRIV) &&
                             ( _wcsicmp(SCE_PRIV_ADD, StrValue) == 0 ||
                               _wcsicmp(SCE_PRIV_REMOVE, StrValue) == 0) ) {
                            //
                            // another format for user rights (ADD: REMOVE:...)
                            //

                            rc = ScepBuildNewPrivilegeList(&LsaPolicy,
                                                           Keyname,
                                                           StrValue,
                                                           SCE_BUILD_ENUMERATE_PRIV,
                                                           &NewValue,
                                                           &NewLen);
                            if ( rc == SCESTATUS_SUCCESS ) {

                                ScepFree(StrValue);
                                StrValue = NewValue;
                                ValueLen = NewLen;
                            }

                        }
                    }

                    if ( ( rc == SCESTATUS_SUCCESS) &&
                         !(dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) &&
                         StrValue &&
                         ( (dwConvertOption & SCE_CONVERT_INF_PRIV) ||
                           (dwConvertOption & SCE_CONVERT_INF_GROUP)) ) {
                        //
                        // convert any free text format accounts from account domain
                        // to sid format if it's resolvable.
                        //
                        NewValue = NULL;
                        NewLen = 0;

                        rc = ScepConvertFreeTextAccountToSid(&LsaPolicy,
                                                            StrValue,
                                                            ValueLen,
                                                            &NewValue,
                                                            &NewLen);

                        if ( ( rc == SCESTATUS_SUCCESS) &&
                             NewValue ) {

                            ScepFree(StrValue);
                            StrValue = NewValue;
                            ValueLen = NewLen;
                        }

                    }

                    if ( rc == SCESTATUS_SUCCESS ) {

                        //
                        // write this line to JET database
                        // within policy propagation, write the GPOID too
                        //
                        rc = SceJetSetLine(
                                     hSection,
                                     pKeyStr ? pKeyStr : Keyname,
                                     FALSE,
                                     StrValue,
                                     ValueLen*sizeof(TCHAR),
                                     (dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) ? GpoID : 0
                                     );

                        if ( rc != SCESTATUS_SUCCESS ) {
                            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                           SCEDLL_ERROR_WRITE_INFO, Keyname);
                        }

                        //
                        // if this is not policy propagation and it's the system db,
                        // check if the tattoo value exists and if so, update it
                        // but if this is in dc demotion, always import them into the
                        // tattoo table so at reboot when policy propagates, it would
                        // reset the system settings to a standalone server
                        //
                        if ( !(dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) &&
                             (dwTableOption & SCE_TABLE_OPTION_TATTOO) &&
                             hSectionTattoo ) {

                            if ( pKeyStr )
                                Len = wcslen(pKeyStr);
                            else
                                Len = wcslen(Keyname);

                            if ( (dwTableOption & SCE_TABLE_OPTION_DEMOTE_TATTOO) ||
                                 (SCESTATUS_SUCCESS == SceJetSeek(
                                                            hSectionTattoo,
                                                            pKeyStr ? pKeyStr : Keyname,
                                                            Len*sizeof(WCHAR),
                                                            SCEJET_SEEK_EQ_NO_CASE)) ) {

                                SceJetSetLine(
                                     hSectionTattoo,
                                     pKeyStr ? pKeyStr : Keyname,
                                     FALSE,
                                     StrValue,
                                     ValueLen*sizeof(TCHAR),
                                     0
                                     );

                            }

                        }

                        ScepFree(StrValue);
                        StrValue = NULL;

                        if (pKeyList != NULL) {
                            if ( (rc=ScepAddToNameList(pKeyList, Keyname,0)) != NO_ERROR ) {

                                ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_ADD, Keyname);
                                rc = ScepDosErrorToSceStatus(rc);
                                ScepFreeNameList(*pKeyList);
                            }
                        }
                    }
                }

                if ( pKeyStr ) {
                    ScepFree(pKeyStr);
                    pKeyStr = NULL;
                }
NextLine:
                if  (rc != SCESTATUS_SUCCESS)
                    ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                                   SCEDLL_ERROR_CONVERT, Keyname);
            }

        } while( rc == SCESTATUS_SUCCESS && SetupFindNextLine(&InfLine, &InfLine));


        SceJetCloseSection( &hSection, TRUE);
        if ( hSectionTattoo )
            SceJetCloseSection( &hSectionTattoo, TRUE);

    }

    if ( LsaPolicy ) {
        LsaClose(LsaPolicy);
    }

    return(rc);
}


SCESTATUS
ScepBuildNewPrivilegeList(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR PrivName,
    IN PWSTR mszUsers,
    IN ULONG dwBuildOption,
    OUT PWSTR *pmszNewUsers,
    OUT DWORD *pNewLen
    )
{
    if ( pPolicyHandle == NULL ||
         PrivName == NULL || mszUsers == NULL ||
         pmszNewUsers == NULL || pNewLen == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    *pNewLen = 0;
    *pmszNewUsers = NULL;

    //
    // lookup the priv first
    //

    DWORD PrivValue = ScepLookupPrivByName(PrivName);
    if ( PrivValue == -1 || PrivValue >= 64 ) {
        return(SCESTATUS_INVALID_DATA);
    }

    NTSTATUS NtStatus=STATUS_SUCCESS;

    if ( *pPolicyHandle == NULL ) {

        NtStatus = ScepOpenLsaPolicy(
                        MAXIMUM_ALLOWED, //GENERIC_ALL,
                        pPolicyHandle,
                        TRUE
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            return(ScepDosErrorToSceStatus(RtlNtStatusToDosError(NtStatus)));
        }
    }

    PSCE_PRIVILEGE_VALUE_LIST pAccountList=NULL;

    if ( dwBuildOption & SCE_BUILD_ENUMERATE_PRIV ) {

        NtStatus = ScepBuildAccountsToRemove(
                        *pPolicyHandle,
                        (PrivValue < 32) ? (1 << PrivValue) : 0,
                        (PrivValue >= 32) ? (1 << (PrivValue-32)) : 0,
                        SCE_BUILD_IGNORE_UNKNOWN | SCE_BUILD_ACCOUNT_SID_STRING,
                        NULL,
                        0,
                        NULL,
                        &pAccountList
                        );
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( NT_SUCCESS(NtStatus) ) {
        //
        // pAccountList can be NULL (no users are assigned of this privilege)
        //
        PWSTR pCurr = mszUsers;
        BOOL bMode = FALSE;  // add
        DWORD Len;
        DWORD SidStrLen;
        PWSTR CurrSidString=NULL;
        PSCE_PRIVILEGE_VALUE_LIST pTemp, pParent;
        BOOL    bFreeCurrSidString = FALSE;

        while ( pCurr && *pCurr != L'\0' ) {

            Len = wcslen(pCurr);

            if ( _wcsicmp(SCE_PRIV_ADD, pCurr) == 0 ) {
                bMode = FALSE; // add
            } else if ( _wcsicmp(SCE_PRIV_REMOVE, pCurr) == 0 ) {
                bMode = TRUE; // remove
            } else {
                //
                // get SID string for the account if it's a name
                //
                if (*pCurr == L'*') {
                    CurrSidString = pCurr;
                    SidStrLen = Len;
                }
                else if (SCESTATUS_SUCCESS == ScepConvertNameToSidString(
                                                                        *pPolicyHandle,
                                                                        pCurr,
                                                                        FALSE,
                                                                        &CurrSidString,
                                                                        &SidStrLen
                                                                        )) {
                    bFreeCurrSidString = TRUE;
                }
                else {
                    CurrSidString = pCurr;
                    SidStrLen = Len;
                }


                for ( pTemp=pAccountList, pParent=NULL; pTemp != NULL;
                      pParent=pTemp, pTemp = pTemp->Next ) {
                    if ( _wcsicmp(pTemp->Name, CurrSidString) == 0 ) {
                        break;
                    }
                }

                if ( bMode == FALSE ) {
                    if ( pTemp == NULL ) {
                        // add this one in
                        rc = ScepAddToPrivilegeList(&pAccountList, CurrSidString, SidStrLen, 0);
                    }
                } else {
                    if ( pTemp ) {
                        // remove this one out
                        if ( pParent ) {
                            pParent->Next = pTemp->Next;
                        } else {
                            pAccountList = pTemp->Next;
                        }
                        // free this one
                        pTemp->Next = NULL;
                        ScepFreePrivilegeValueList(pTemp);
                        pTemp = NULL;
                    }
                }
            }

            //
            // free CurrSidString if it's allocated
            // (BVT: have to be careful here - MULTI_SZ potentially being freed many times)
            //
            if ( bFreeCurrSidString ) {
                LocalFree(CurrSidString);
                CurrSidString = NULL;
                bFreeCurrSidString = FALSE;
            }
            SidStrLen = 0;

            if ( SCESTATUS_SUCCESS != rc ) {
                break;
            }
            // move to next element
            pCurr += Len + 1;
        }

        if ( SCESTATUS_SUCCESS == rc ) {

            DWORD TotalLen = 0;
            for ( pTemp=pAccountList; pTemp != NULL; pTemp = pTemp->Next ) {
                pTemp->PrivLowPart = wcslen(pTemp->Name);
                TotalLen += pTemp->PrivLowPart+1;
            }

            *pmszNewUsers = (PWSTR)ScepAlloc(0, (TotalLen+1)*sizeof(WCHAR));

            if (*pmszNewUsers ) {

                *pNewLen = TotalLen;
                TotalLen = 0;

                for ( pTemp=pAccountList; pTemp != NULL && TotalLen <= *pNewLen;
                      pTemp = pTemp->Next ) {

                    wcscpy(*pmszNewUsers+TotalLen, pTemp->Name);
                    TotalLen += pTemp->PrivLowPart;
                    *(*pmszNewUsers+TotalLen) = L'\0';
                    TotalLen++;
                }
                *(*pmszNewUsers+TotalLen) = L'\0';

            } else {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }
        }

    } else {
        rc = ScepDosErrorToSceStatus(RtlNtStatusToDosError(NtStatus));
    }

    return(rc);

}


SCESTATUS
SceConvertpInfObject(
    IN PCWSTR InfSectionName,
    IN UINT ObjectType,
    IN DWORD ObjectFlag,
    IN HINF   hInf,
    IN PSCECONTEXT hProfile,
    IN DWORD dwTableOption,
    IN LONG GpoID
    )
/* ++
Routine Description:

    This routine converts INF sections which are in object-security format,
    for example, Registry Keys and File Security sections. These sections
    must have 3 fields on each line. The first field is the object's name,
    the second field is a status flag, and the third field is the security
    descriptor text. The infomration saved in the Jet database for each
    object is the object's name as the key, and the text format security
    descriptor plus 1 byte status flag as the value.

Arguments:

    InfSectionName  - the INF section name to convert

    ObjectType      - The object's type
                          1 = Registry
                          2 = File
                          3 = DS object

    hInf            - the Inf file handle

    hprofile        - the Jet database context

Return Value:

-- */
{

    SCESTATUS    rc;
    DOUBLE      SectionID;
    PSCESECTION hSection=NULL;
    PSCESECTION hSectionTattoo=NULL;
    INFCONTEXT  InfLine;
    PWSTR       TempName=NULL;
    PWSTR       Name=NULL;
    PWSTR       Value=NULL;
    DWORD       ValueLen;
    SCEINF_STATUS InfErr;
    TCHAR       ObjName[MAX_PATH];


    if ( InfSectionName == NULL ||
         hInf == INVALID_HANDLE_VALUE ||
         hProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get section's ID. if the section does not exist, add it to the section table
    //
    rc = SceJetGetSectionIDByName(
                hProfile,
                InfSectionName,
                &SectionID
                );
    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SceJetAddSection(
                    hProfile,
                    InfSectionName,
                    &SectionID
                    );
    }
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_SCP_ERROR_ADD, (PWSTR)InfSectionName);
        return(rc);
    }

    if ( SetupFindFirstLine(hInf,InfSectionName,NULL,&InfLine) ) {

        //
        // open the section
        //
        if ( dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY ) {

            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_SCP,
                        &hSection
                        );
        } else {
            //
            // SMP exists, also open the SMP section
            //
            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_SMP,
                        &hSection
                        );

            if ( dwTableOption & SCE_TABLE_OPTION_TATTOO ) {
                //
                // if it's in setup, should check if tattoo table needs to be updated
                // do not care error
                //
                SceJetOpenSection(
                            hProfile,
                            SectionID,
                            SCEJET_TABLE_TATTOO,
                            &hSectionTattoo
                            );
            }
        }
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_OPEN, (PWSTR)InfSectionName);

            if ( hSection )
                SceJetCloseSection( &hSection, TRUE);
            if ( hSectionTattoo )
                SceJetCloseSection( &hSectionTattoo, TRUE);

            return(rc);
        }

        //
        // process each line in the section and save to the scp table.
        //

        BOOL bIgnore;

        do {
            //
            // Get string fields. Don't care the key name or if it exist.
            // Must have at least 3 fields each line.
            //

            bIgnore = FALSE;

            InfErr = SceInfpGetOneObject(&InfLine,
                                    ObjectFlag,
                                    &TempName,
                                    &Value,
                                    &ValueLen
                                  );
            rc = ScepDosErrorToSceStatus(InfErr);

            if ( rc == SCESTATUS_SUCCESS && TempName != NULL ) {

                //
                // check to see if the object name needs translated
                //
                if ( ObjectType == 3 ) {
                    //
                    // DS object
                    //
                    rc = ScepConvertLdapToJetIndexName(TempName, &Name);

                } else if ( ObjectType == 2 && TempName[0] == L'\\' ) {
                    //
                    // do not support UNC name format
                    //
                    rc = SCESTATUS_INVALID_DATA;

                } else if ( ObjectType == 2 && wcschr(TempName, L'%') != NULL ) {

                    //
                    // translate the name
                    //
                    rc = ScepTranslateFileDirName( TempName, &Name);

                    if ( rc == ERROR_PATH_NOT_FOUND ) {
                        if ( ObjectFlag & SCE_OBJECT_FLAG_UNKNOWN_VERSION )
                            bIgnore = TRUE;
                        rc = SCESTATUS_INVALID_DATA;

                    } else if ( rc != NO_ERROR )
                        rc = ScepDosErrorToSceStatus(rc);

                } else {
                    Name = TempName;
                    TempName = NULL;
                }

                //
                // write this line to JET database
                //
                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // convert to lowercase
                    //
                    Name = _wcslwr(Name);

                    //
                    // within policy propagation, write the GPOID too
                    //
                    rc = SceJetSetLine(
                                 hSection,
                                 Name,
                                 TRUE,
                                 Value,
                                 ValueLen*sizeof(TCHAR),
                                 (dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) ? GpoID : 0
                                 );

                    if ( hSectionTattoo &&
                         !(dwTableOption & SCE_TABLE_OPTION_MERGE_POLICY) &&
                         (dwTableOption & SCE_TABLE_OPTION_TATTOO ) ) {
                        //
                        // if it's in setup (not policy prop) and tattoo table exists
                        // check if tattoo value exists for this one and if so, update it
                        // do not care error
                        //
                        if ( SCESTATUS_SUCCESS == SceJetSeek(
                                                        hSectionTattoo,
                                                        Name,
                                                        wcslen(Name)*sizeof(WCHAR),
                                                        SCEJET_SEEK_EQ_NO_CASE) ) {

                            SceJetSetLine(
                                 hSectionTattoo,
                                 Name,
                                 TRUE,
                                 Value,
                                 ValueLen*sizeof(TCHAR),
                                 0
                                 );

                        }
                    }

                }
                if ( rc != SCESTATUS_SUCCESS) {
                    ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                   SCEDLL_ERROR_CONVERT, TempName );
                }
                ScepFree(Value);
                Value = NULL;

                ScepFree(TempName);
                TempName = NULL;

                ScepFree(Name);
                Name = NULL;

            } else if ( (ObjectFlag & SCE_OBJECT_FLAG_UNKNOWN_VERSION) &&
                        rc == SCESTATUS_SUCCESS && TempName == NULL ) {
                //
                // this one is ignored because it came from a newer version
                // of template.
                //

            } else {

                ObjName[0] = L'\0';
                SetupGetStringField(&InfLine,1,ObjName,MAX_PATH,&ValueLen);

                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                              SCEDLL_ERROR_CONVERT, ObjName );
            }

            //
            // for a newer version template, if a env variable can't be resolved
            // it will be ignored.
            //
            if ( bIgnore ) rc = SCESTATUS_SUCCESS;

            if ( SCESTATUS_INVALID_DATA == rc ) {
                //
                // if a environment variable or other invalid data is found
                // in the template, will continue to process other areas/items
                // but the error will be eventually returned to the caller
                //
                gbInvalidData = TRUE;
                rc = SCESTATUS_SUCCESS;
            }

            if ( rc != SCESTATUS_SUCCESS )
                break; // do..while loop

        } while( SetupFindNextLine(&InfLine,&InfLine) );

        SceJetCloseSection( &hSection, TRUE);
        if ( hSectionTattoo ) SceJetCloseSection( &hSectionTattoo, TRUE);

    }

    return(rc);

}


SCEINF_STATUS
SceInfpGetOneObject(
    IN PINFCONTEXT pInfLine,
    IN DWORD ObjectFlag,
    OUT PWSTR *Name,
    OUT PWSTR *Value,
    OUT PDWORD ValueLen
    )
/* ++
Routine Description:

   This routine retrieves security setting for one object (a registry key,
   or a file) from the INF file (SCP type). Each object in these sections
   is represented by one line. Each object has 3 fields, a name, status flag,
   and a security setting.

Arguments:

   pInfLine  - Current line context from the INF file for one object

    Name      - The object name

    Value     - The status flag ( 1 byte) plus the security descriptor in text

    ValueLen  - the length of the value

Return value:

   SCESTATUS - SCEINF_SUCCESS
              SCEINF_WARNING
              SCEINF_NOT_ENOUGH_MEMORY
              SCEINF_INVALID_PARAMETER
              SCEINF_CORRUPT_PROFILE
              SCEINF_INVALID_DATA
-- */
{
    SCEINF_STATUS  rc=ERROR_BAD_FORMAT;
    DWORD         cFields;
    INT           Keyvalue1=0;
    DWORD         Keyvalue2=0;
    DWORD         DataSize;
    PWSTR         SDspec=NULL;
    DWORD         Len=0;

    //
    // The Registry/File INF layout must have 3 fields for each line.
    // The first field is the key/file name, the 2nd field is the security descriptor index
    // for workstations, and the 3rd field is the security descriptor index for servers
    //

    if ( Name == NULL || Value == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *Name = NULL;
    *Value = NULL;
    *ValueLen = 0;

    cFields = SetupGetFieldCount( pInfLine );

    if ( cFields < 3 ) {
        if ( ObjectFlag & SCE_OBJECT_FLAG_UNKNOWN_VERSION ) {
            return(ERROR_SUCCESS);
        } else {
            return(ERROR_INVALID_DATA);
        }

    } else if(SetupGetStringField(pInfLine,1,NULL,0,&DataSize) && DataSize > 0 ) {

        *Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                     (DataSize+1)*sizeof(TCHAR) );
        if( *Name == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        } else {

            //
            // the first field is the key/file name. the status is ERROR_BAD_FORMAT now
            //

            if(SetupGetStringField(pInfLine,1,*Name,DataSize,NULL)) {
#ifdef SCE_DBG
                ScepLogOutput2(0,0, L"Read %s", *Name );
#endif
                //
                // The 2nd field is the status
                // The 3rd field (and all fields after) is the security descriptor text
                //
                if ( SetupGetIntField(pInfLine, 2, (INT *)&Keyvalue1) &&
//                     SetupGetStringField(pInfLine, 3, NULL, 0, &Keyvalue2) ) {
                     SetupGetMultiSzField(pInfLine, 3, NULL, 0, &Keyvalue2) ) {

                    *Value = (PWSTR)ScepAlloc( 0, (Keyvalue2+2)*sizeof(WCHAR));

                    //
                    // add this object
                    //
                    if ( *Value == NULL ) {

                        rc = ERROR_NOT_ENOUGH_MEMORY;
//                    } else if ( SetupGetStringField(pInfLine, 3, (*Value)+1, Keyvalue2, NULL) ) {
                    } else if ( SetupGetMultiSzField(pInfLine, 3, (*Value)+1, Keyvalue2, NULL) ) {

                        if ( ObjectFlag & SCE_OBJECT_FLAG_OBJECTS ) {

                            if ( Keyvalue1 > SCE_STATUS_NO_AUTO_INHERIT ||
                                 Keyvalue1 < SCE_STATUS_CHECK ) {

                                Keyvalue1 = SCE_STATUS_CHECK;
                            }

                            *((BYTE *)(*Value)) = (BYTE)Keyvalue1;

                            *((CHAR *)(*Value)+1) = '1';   //always treat as container

                        } else {
                            //
                            // services
                            //
                            if ( Keyvalue1 > SCE_STARTUP_DISABLED ||
                                 Keyvalue1 < SCE_STARTUP_BOOT ) {
                                //
                                // default
                                //
                                Keyvalue1 = SCE_STARTUP_MANUAL;
                            }

                            *((BYTE *)(*Value)) = 0;  // always set status to 0

                            *((BYTE *)(*Value)+1) = (BYTE)Keyvalue1;

                        }
                        //
                        // convert the multi-sz delimiter to space, if there is any
                        //
                        if ( cFields > 3 ) {
                            ScepConvertMultiSzToDelim( (*Value+1), Keyvalue2, L'\0', L' ');
                        }

                        if ( ObjectFlag & SCE_OBJECT_FLAG_OLDSDDL ) {
                            //
                            // convert old SDDL string to new one
                            //
                            ScepConvertToSDDLFormat( (*Value+1), Keyvalue2 );
                        }

                        *ValueLen = Keyvalue2+1;
                        rc = ERROR_SUCCESS;

                    } else {
                        ScepFree(*Value);
                        *Value = NULL;
                        rc = ERROR_INVALID_DATA;
                    }
                }
            }

            // if error, free the memory allocated
            if ( rc != ERROR_SUCCESS ) {
                ScepFree(*Name);
                *Name = NULL;
            }
        }

    }
    if ( rc == ERROR_SUCCESS) {
        //
        // conver the object name to upper case
        //
//        _wcsupr(*Name);  should not do this..
    }
    return(rc);

}

SCESTATUS
SceConvertpInfDescription(
    IN HINF hInf,
    IN PSCECONTEXT hProfile
    )
{
    INFCONTEXT InfLine;
    SCESTATUS   rc=SCESTATUS_SUCCESS;
    WCHAR      Description[513];
    DWORD      Len=0;
    DWORD      DataSize=0;
    DWORD      i, cFields;


    if ( hInf == INVALID_HANDLE_VALUE ||
         hProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }


    if ( SetupFindFirstLine(hInf,szDescription,NULL,&InfLine) ) {

        memset(Description, '\0', 513*sizeof(WCHAR));

        // get description from Inf
        do {
            cFields = SetupGetFieldCount( &InfLine );

            for ( i=0; i<cFields && rc==SCESTATUS_SUCCESS; i++) {
                if(SetupGetStringField(&InfLine, i+1, Description+Len, 512-Len, &DataSize) ) {

                    Len += DataSize;
                    if ( Len >= 512 ) {
                        Len = 512;
                        Description[512] = L'\0';
                        break;
                    }
                    if ( i == cFields-1 )
                        Description[Len-1] = L' ';
                    else
                        Description[Len-1] = L',';
                } else
                    rc = SCESTATUS_INVALID_DATA;
            }
            if ( Len >= 512 )
                break;

        } while ( rc == SCESTATUS_SUCCESS &&
                  SetupFindNextLine(&InfLine, &InfLine));

        if ( rc == SCESTATUS_SUCCESS && Description[0] ) {
            //
            // save description to Jet
            // NOTE: Jet requires long value update must be done in a transaction
            //
            rc = SceJetStartTransaction( hProfile );

            if ( SCESTATUS_SUCCESS == rc ) {

                Description[Len] = L'\0';

                rc = SceJetSetValueInVersion(
                        hProfile,
                        "SmTblVersion",
                        "ProfileDescription",
                        (PWSTR)Description,
                        Len*sizeof(WCHAR),
                        JET_prepReplace
                        );
                if ( SCESTATUS_SUCCESS == rc ) {

                    SceJetCommitTransaction( hProfile, 0 );

                } else {

                    SceJetRollback( hProfile, 0 );

                }
            }
        }
    }

    return(rc);

}

SCESTATUS
ScepConvertFreeTextAccountToSid(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR mszAccounts,
    IN ULONG dwLen,
    OUT PWSTR *pmszNewAccounts,
    OUT DWORD *pNewLen
    )
{

    if ( pPolicyHandle == NULL ||
         pmszNewAccounts == NULL || pNewLen == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    *pNewLen = 0;
    *pmszNewAccounts = NULL;

    PWSTR pCurr = mszAccounts;
    DWORD cnt=0;

    //
    // count how many entries in the list
    //
    while ( pCurr && *pCurr != L'\0' ) {
        cnt++;
        pCurr += wcslen(pCurr)+1;
    }

    if ( cnt == 0 ) {
        return(SCESTATUS_SUCCESS);
    }

    NTSTATUS NtStatus=STATUS_SUCCESS;

    if ( *pPolicyHandle == NULL ) {

        NtStatus = ScepOpenLsaPolicy(
                        MAXIMUM_ALLOWED, //GENERIC_ALL,
                        pPolicyHandle,
                        TRUE
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            return(ScepDosErrorToSceStatus(RtlNtStatusToDosError(NtStatus)));
        }
    }

    //
    // allocate temp buffer for the sid string pointers
    //
    PWSTR *pSidStrs = (PWSTR *)ScepAlloc(LPTR, cnt*sizeof(PWSTR));

    if ( pSidStrs == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    DWORD *pSidLen = (DWORD *)ScepAlloc(LPTR, cnt*sizeof(DWORD));

    if ( pSidLen == NULL ) {
        ScepFree(pSidStrs);
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    BOOL *pSidFree = (BOOL *)ScepAlloc(LPTR, cnt*sizeof(BOOL));

    if ( pSidFree == NULL ) {
        ScepFree(pSidStrs);
        ScepFree(pSidLen);
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    pCurr = mszAccounts;
    DWORD i = 0;
    BOOL bConvert=FALSE;
    PWSTR SidString, pTemp;
    DWORD StrLen;
    SCESTATUS rc;


    while ( pCurr && *pCurr != L'\0' &&
            ( i < cnt ) ) {

        pSidStrs[i] = pCurr;
        pSidFree[i] = FALSE;
        pSidLen[i] = wcslen(pCurr);
        pTemp = pCurr + pSidLen[i] + 1;

        if ( *pCurr != L'*' && wcschr(pCurr, L'\\') == 0 ) {
            //
            // this is a name format and it's an isolated name
            // let's resolve it to a SID string
            //
            SidString = NULL;
            StrLen = 0;

            rc = ScepConvertNameToSidString( *pPolicyHandle,
                                             pCurr,
                                             FALSE, //TRUE,
                                             &SidString,
                                             &StrLen
                                           );

            if ( rc == SCESTATUS_SUCCESS &&
                 SidString ) {

                //
                // got a sid string
                //
                pSidStrs[i] = SidString;
                pSidLen[i] = StrLen;
                pSidFree[i] = TRUE;

                bConvert = TRUE;
            }
        }

        i ++;
        pCurr = pTemp;

    }

    //
    // now we need to build the new string
    //
    rc = SCESTATUS_SUCCESS;

    if ( bConvert ) {

        DWORD dwTotal=0;

        for ( i=0; i<cnt; i++ ) {

            dwTotal += pSidLen[i];
            dwTotal ++;  // for the NULL terminator
        }

        if ( dwTotal ) {
            dwTotal ++;  // for the last NULL terminator

            *pmszNewAccounts = (PWSTR)ScepAlloc(LPTR, dwTotal*sizeof(WCHAR));

            if ( *pmszNewAccounts ) {

                pCurr = *pmszNewAccounts;

                for ( i=0; i<cnt; i++ ) {

                    wcsncpy(pCurr, pSidStrs[i], pSidLen[i]);

                    pCurr += pSidLen[i];
                    *pCurr = L'\0';
                    pCurr++;
                }

                *pNewLen = dwTotal;

            } else {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }
        }
    }

    for ( i=0; i<cnt; i++ ) {

        if ( pSidFree[i] && pSidStrs[i] ) {
            ScepFree(pSidStrs[i]);
        }
    }

    ScepFree(pSidStrs);
    ScepFree(pSidLen);
    ScepFree(pSidFree);

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\pfp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    pfp.h

Abstract:

    Headers of jet database read/write

Author:

    Jin Huang (jinhuang) 09-Dec-1996

Revision History:

--*/

#ifndef _pfp_
#define _pfp_

#ifdef __cplusplus
extern "C" {
#endif

SCESTATUS
ScepStartANewSection(
    IN PSCECONTEXT hProfile,
    IN OUT PSCESECTION *hSection,
    IN SCEJET_TABLE_TYPE ProfileType,
    IN PCWSTR SectionName
    );

SCESTATUS
ScepOpenSectionForName(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    IN PCWSTR     SectionName,
    OUT PSCESECTION *phSection
    );

SCESTATUS
ScepGetPrivileges(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN DWORD dwAccountFormat,
   OUT PVOID *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
ScepAddToPrivList(
    IN PSCE_NAME_STATUS_LIST *pPrivList,
    IN DWORD Rights,
    IN PWSTR Name,
    IN DWORD Len
    );

SCESTATUS
ScepAddSidToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PSID pSid,
    IN BOOL bReuseBuffer,
    IN DWORD PrivValue,
    OUT BOOL *pbBufferUsed
    );

SCESTATUS
ScepCompareAndSaveIntValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN BOOL bReplaceExistOnly,
    IN DWORD BaseValue,
    IN DWORD CurrentValue
    );

SCESTATUS
ScepCompareAndSaveStringValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PWSTR BaseValue,
    IN PWSTR CurrentValue,
    IN DWORD CurrentLen
    );

SCESTATUS
ScepSaveObjectString(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN BOOL  IsContainer,
    IN BYTE  Flag,
    IN PWSTR Value,
    IN DWORD ValueLen
    );

SCESTATUS
ScepWriteAUserSetting(
    IN PSCESECTION hSectionList,
    IN PWSTR UserName,
    IN PSCESECTION hSection,
    IN PSCE_USER_SETTING pPerUserSetting
    );

#define SCE_WRITE_EMPTY_LIST        0x1
#define SCE_WRITE_CONVERT           0x2
#define SCE_WRITE_LOCAL_TABLE       0x4

SCESTATUS
ScepWriteNameListValue(
    IN LSA_HANDLE LsaPolicy OPTIONAL,
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSCE_NAME_LIST NameList,
    IN DWORD dwWriteOption,
    IN INT Status
    );

SCESTATUS
ScepWriteNameStatusListValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSCE_NAME_STATUS_LIST NameList,
    IN BOOL SaveEmptyList,
    IN INT Status
    );

SCESTATUS
ScepWriteSecurityDescriptorValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo
    );

#define SCE_LOCAL_POLICY_MIGRATE        1L
#define SCE_LOCAL_POLICY_DC             2L

SCESTATUS
ScepCopyLocalToMergeTable(
    IN PSCECONTEXT hProfile,
    IN DWORD Options,
    IN DWORD CopyOptions,
    OUT PSCE_ERROR_LOG_INFO *pErrlog
    );

SCESTATUS
ScepGetSingleServiceSetting(
    IN PSCESECTION hSection,
    IN PWSTR ServiceName,
    OUT PSCE_SERVICES *pOneService
    );

SCESTATUS
ScepSetSingleServiceSetting(
    IN PSCESECTION hSection,
    IN PSCE_SERVICES pOneService
    );

SCESTATUS
ScepCompareSingleServiceSetting(
    IN PSCE_SERVICES pNode1,
    IN PSCE_SERVICES pNode2,
    OUT PBOOL pIsDifferent
    );

SCESTATUS
ScepCopyObjects(
    IN PSCECONTEXT hProfile,
    IN SCETYPE  ProfileType,
    IN PWSTR InfFile,
    IN PCWSTR SectionName,
    IN AREA_INFORMATION Area,
    IN OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetFixValueSection(
    IN PSCECONTEXT  hProfile,
    IN PCWSTR      SectionName,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN SCETYPE ProfileType,
    OUT PVOID pProfileInfo,
    OUT PSCESECTION *phSection,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

#define SCEBROWSE_DOMAIN_POLICY     0x1
#define SCEBROWSE_MULTI_SZ          0x2

SCESTATUS
ScepBrowseTableSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PCWSTR SectionName,
    IN DWORD Options
    );

#define SCE_ERROR_STRING           TEXT("$#?Error?#$")

SCESTATUS
ScepTattooCheckAndUpdateArray(
    IN OUT SCE_TATTOO_KEYS *pTattooKeys,
    IN OUT DWORD *pcTattooKeys,
    IN PWSTR KeyName,
    IN DWORD ConfigOptions,
    IN DWORD dwValue
    );

SCESTATUS
ScepTattooOpenPolicySections(
    IN PSCECONTEXT hProfile,
    IN PCWSTR SectionName,
    OUT PSCESECTION *phSectionDomain,
    OUT PSCESECTION *phSectionTattoo
    );

SCESTATUS
ScepTattooManageOneStringValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN PWSTR Value,
    IN DWORD ValueLen,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneIntValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN DWORD Value,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneIntValueWithDependency(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR DependentKeyName,
    IN DWORD DependentKeyLen OPTIONAL,
    IN PWSTR SaveKeyName,
    IN DWORD Value,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneRegistryValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN PSCE_REGISTRY_VALUE_INFO pOneRegValue,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneMemberListValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR GroupName,
    IN DWORD GroupLen OPTIONAL,
    IN PSCE_NAME_LIST pNameList,
    IN BOOL bDeleteOnly,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageOneServiceValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR ServiceName,
    IN DWORD ServiceLen OPTIONAL,
    IN PSCE_SERVICES pServiceNode,
    IN DWORD rc
    );

SCESTATUS
ScepTattooManageValues(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN SCE_TATTOO_KEYS *pTattooKeys,
    IN DWORD cTattooKeys,
    IN DWORD rc
    );

BOOL
ScepTattooIfQueryNeeded(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD Len,
    OUT BOOL *pbDomainExist,
    OUT BOOL *pbTattooExist
    );

SCESTATUS
ScepDeleteOneSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE tblType,
    IN PCWSTR SectionName
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\pfget.cpp ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    pfget.cpp

Abstract:

    Routines to get information from jet database (configuration/analysis
    info).

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

    jinhuang 26-Jan-1998 splitted to client-server

--*/

#include "serverp.h"
#include <io.h>
#include "pfp.h"
#include "kerberos.h"
#include "regvalue.h"
#include <sddl.h>
#pragma hdrstop

//#define SCE_DBG 1
#define SCE_INTERNAL_NP         0x80
#define SCE_ALLOC_MAX_NODE      10

typedef struct _SCE_BROWSE_CALLBACK_VALUE {

    DWORD Len;
    UCHAR *Value;

} SCE_BROWSE_CALLBACK_VALUE;


//
// Forward references
//

SCESTATUS
ScepGetSystemAccess(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_PROFILE_INFO   pProfileInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetVariableValue(
    IN PSCESECTION hSection,
    IN SCETYPE ProfileType,
    IN PCWSTR KeyName,
    OUT PWSTR *Value,
    OUT PDWORD ValueLen
    );

SCESTATUS
ScepAddToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PWSTR Name,
    IN DWORD Len,
    IN DWORD PrivValue
    );

SCESTATUS
ScepGetGroupMembership(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetGroupMembershipFromOneTable(
    IN LSA_HANDLE  LsaPolicy,
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetObjectList(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );
SCESTATUS
ScepGetDsRoot(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepBuildDsTree(
    OUT PSCE_OBJECT_CHILD_LIST *TreeRoot,
    IN ULONG Level,
    IN WCHAR Delim,
    IN PCWSTR ObjectFullName
    );

SCESTATUS
ScepGetObjectFromOneTable(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetObjectChildrenFromOneTable(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    IN SCE_SUBOBJECT_TYPE Option,
    OUT PVOID *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

BYTE
ScepGetObjectStatusFlag(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN AREA_INFORMATION Area,
   IN PWSTR ObjectPrefix,
   IN BOOL bLookForParent
   );

SCESTATUS
ScepGetAuditing(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   OUT PSCE_PROFILE_INFO pProfileInfo,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
ScepGetPrivilegesFromOneTable(
   IN LSA_HANDLE LsaPolicy,
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN DWORD dwAccountFormat,
   OUT PVOID *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   );

SCESTATUS
ScepGetSystemServices(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    OUT PSCE_SERVICES *pServiceList,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

BOOL
ScepSearchItemInChildren(
    IN PWSTR ItemName,
    IN DWORD NameLen,
    IN PSCE_OBJECT_CHILDREN_NODE *pArrObject,
    IN DWORD arrCount,
    OUT LONG *pFindIndex
    );


DWORD
ScepAddItemToChildren(
    IN PSCE_OBJECT_CHILDREN_NODE ThisNode OPTIONAL,
    IN PWSTR ItemName,
    IN DWORD NameLen,
    IN BOOL  IsContainer,
    IN BYTE  Status,
    IN DWORD ChildCount,
    IN OUT PSCE_OBJECT_CHILDREN_NODE **ppArrObject,
    IN OUT DWORD *pArrCount,
    IN OUT DWORD *pMaxCount,
    IN OUT LONG *pFindIndex
    );

//
// function definitions
//

SCESTATUS
ScepGetDatabaseInfo(
    IN  PSCECONTEXT         hProfile,
    IN  SCETYPE             ProfileType,
    IN  AREA_INFORMATION    Area,
    IN  DWORD               dwAccountFormat,
    OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    IN  OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/**++

Function Description:

   This function reads all or part of information from a SCP/SAP/SMP profile
   depending on the ProfileType, into the InfoBuffer. ProfileType is saved in
   the ppInfoBuffer's Type field.

   A handle to the profile (Jet database) is passed into the routine every
   time this routine is called. Area specifies one or more pre-defined security
   areas to get information. One area's information may be saved in multiple
   sections in the profile.

   The memory related to the area(s) will be reset/freed before loading
   information from the profile. If the return code is SCESTATUS_SUCCESS, then
   the output InfoBuffer contains the requested information. Otherwise,
   InfoBuffer contains nothing for the area(s) specified.

Arguments:

   hProfile    -   The handle to the profile to read from.

   ProfileType -   value to indicate engine type.
                    SCE_ENGINE_SCP
                    SCE_ENGINE_SAP
                    SCE_ENGINE_SMP

   Area -          area(s) for which to get information from
                     AREA_SECURITY_POLICY
                     AREA_PRIVILEGES
                     AREA_GROUP_MEMBERSHIP
                     AREA_REGISTRY_SECURITY
                     AREA_SYSTEM_SERVICE
                     AREA_FILE_SECURITY

   ppInfoBuffer -  The address of SCP/SAP/SMP buffers. If it is NULL, a buffer
                   will be created which must be freed by LocalFree. The
                   output is the information requested if successful, or
                   nothing if fail.

   Errlog     -    A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return Value:

   SCESTATUS_SUCCESS
   SCESTATUS_PROFILE_NOT_FOUND
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_BAD_FORMAT
   SCESTATUS_INVALID_DATA

-- **/
{

    SCESTATUS     rc=SCESTATUS_SUCCESS;
    DWORD         Len;
    BOOL          bBufAlloc=FALSE;
    NT_PRODUCT_TYPE theType;

    //
    // if the JET database is not opened then return
    //

    if ( hProfile == NULL ) {

        return( SCESTATUS_INVALID_PARAMETER );
    }

    //
    // address for InfoBuffer cannot be NULL
    //
    if ( ppInfoBuffer == NULL ) {
        return( SCESTATUS_INVALID_PARAMETER );
    }

    //
    // check scetype
    //
    if ( ProfileType > SCE_ENGINE_SMP ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // check to see if there is a SMP or SCP table
    //
    if ( hProfile->JetSmpID == JET_tableidNil ||
         hProfile->JetScpID == JET_tableidNil ) {
        return(SCESTATUS_PROFILE_NOT_FOUND);
    }

    if ( ProfileType == SCE_ENGINE_GPO &&
         hProfile->JetScpID == hProfile->JetSmpID ) {
        //
        // there is no domain GPO policy
        //
        return(SCESTATUS_PROFILE_NOT_FOUND);
    }
    //
    // design on this part is changed.
    // if there is no SAP table which means the system has not been
    // analyzed based on the template in SMP, return error and UI
    // will display "no analysis is performed"
    //
    if ( ProfileType == SCE_ENGINE_SAP &&
          hProfile->JetSapID == JET_tableidNil) {

        return(SCESTATUS_PROFILE_NOT_FOUND);
    }

    //
    // create buffer if it is NULL
    //
    if ( *ppInfoBuffer == NULL) {
        //
        // allocate memory
        //
        Len = sizeof(SCE_PROFILE_INFO);
        *ppInfoBuffer = (PSCE_PROFILE_INFO)ScepAlloc( (UINT)0, Len);
        if ( *ppInfoBuffer == NULL ) {

            return( SCESTATUS_NOT_ENOUGH_RESOURCE );
        }
        memset(*ppInfoBuffer, '\0', Len);
        bBufAlloc = TRUE;

        (*ppInfoBuffer)->Type = ( ProfileType==SCE_ENGINE_GPO) ? SCE_ENGINE_SCP : ProfileType;

    }

/*
// Design changed. Checking is moved above creating the buffer.

    if ( ProfileType == SCE_ENGINE_SAP &&
          hProfile->JetSapID == JET_tableidNil) {
        //
        // if no SAP table is there, which means configuration is done
        // but analysis is not done, we treat it as everything is fine
        // reset the buffer to SCE_NO_VALUE
        //
        ScepResetSecurityPolicyArea(*ppInfoBuffer);

//        return(SCESTATUS_PROFILE_NOT_FOUND);
        return(SCESTATUS_SUCCESS);
    }
*/
    //
    // Free related memory and reset the buffer before parsing
    // there is a problem here for now. it clears the handle and
    // filename too. So comment it out.

    SceFreeMemory( (PVOID)(*ppInfoBuffer), (DWORD)Area );

    //
    // system access
    //

    if ( Area & AREA_SECURITY_POLICY ) {

        rc = ScepGetSystemAccess(
                    hProfile,
                    ProfileType,
                    *ppInfoBuffer,
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // system auditing
        //
        rc = ScepGetAuditing(hProfile,
                             ProfileType,
                            *ppInfoBuffer,
                            Errlog
                          );

        if( rc != SCESTATUS_SUCCESS )
                goto Done;

#if _WIN32_WINNT>=0x0500
        if ( RtlGetNtProductType(&theType) ) {

            if ( theType == NtProductLanManNt ) {

                rc = ScepGetKerberosPolicy(
                                    hProfile,
                                    ProfileType,
                                    &((*ppInfoBuffer)->pKerberosInfo),
                                    Errlog
                                  );

                if ( rc != SCESTATUS_SUCCESS )
                    goto Done;
            }
        }
#endif
        //
        // registry values
        //
        rc = ScepGetRegistryValues(
                            hProfile,
                            ProfileType,
                            &((*ppInfoBuffer)->aRegValues),
                            &((*ppInfoBuffer)->RegValueCount),
                            Errlog
                          );

        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // privilege/rights
    //

    if ( Area & AREA_PRIVILEGES ) {
        //
        // SCP/SMP/SAP privilegeAssignedTo are all in the same address in the
        // SCE_PROFILE_INFO structure.
        //
        rc = ScepGetPrivileges(
                    hProfile,
                    ProfileType,
                    dwAccountFormat,
                    (PVOID *)&( (*ppInfoBuffer)->OtherInfo.scp.u.pPrivilegeAssignedTo ),
                    Errlog
                    );

        if( rc != SCESTATUS_SUCCESS )
            goto Done;
    }


    //
    // group memberships
    //

    if ( (Area & AREA_GROUP_MEMBERSHIP) &&
         (ProfileType != SCE_ENGINE_GPO) ) {

        rc = ScepGetGroupMembership(
                      hProfile,
                      ProfileType,
                      &((*ppInfoBuffer)->pGroupMembership),
                      Errlog
                      );

        if( rc != SCESTATUS_SUCCESS )
                goto Done;
    }

    //
    // registry keys security
    //

    if ( (Area & AREA_REGISTRY_SECURITY) &&
        (ProfileType != SCE_ENGINE_GPO) ) {

        rc = ScepGetObjectList(
                   hProfile,
                   ProfileType,
                   szRegistryKeys,
                   &((*ppInfoBuffer)->pRegistryKeys.pOneLevel),
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

    }

    //
    // file security
    //

    if ( (Area & AREA_FILE_SECURITY) &&
         (ProfileType != SCE_ENGINE_GPO) ) {

        rc = ScepGetObjectList(
                   hProfile,
                   ProfileType,
                   szFileSecurity,
                   &((*ppInfoBuffer)->pFiles.pOneLevel),
                   Errlog
                   );

        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // DS object security
    //
#if 0

#if _WIN32_WINNT>=0x0500
    if ( (Area & AREA_DS_OBJECTS) &&
        (ProfileType != SCE_ENGINE_GPO) &&
        RtlGetNtProductType(&theType) ) {

        if ( theType == NtProductLanManNt ) {
            rc = ScepGetDsRoot(
                       hProfile,
                       ProfileType,
                       szDSSecurity,
                       &((*ppInfoBuffer)->pDsObjects.pOneLevel),
                       Errlog
                       );

            if ( rc != SCESTATUS_SUCCESS )
                goto Done;
        }
    }
#endif
#endif

    if ( (Area & AREA_SYSTEM_SERVICE) &&
         (ProfileType != SCE_ENGINE_GPO) ) {

        rc = ScepGetSystemServices(
                   hProfile,
                   ProfileType,
                   &((*ppInfoBuffer)->pServices),
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

    }

Done:

    if ( rc != SCESTATUS_SUCCESS ) {

        //
        // need free memory because some fatal error happened
        //

        if ( bBufAlloc ) {
            SceFreeProfileMemory(*ppInfoBuffer);
            *ppInfoBuffer = NULL;
        } else
            SceFreeMemory( (PVOID)(*ppInfoBuffer), (DWORD)Area );

    }
    return(rc);
}


SCESTATUS
ScepGetSystemAccess(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_PROFILE_INFO   pProfileInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves system access area information from the Jet database
   and stores in the output buffer pProfileInfo. System access information
   includes information in [System Access] sections.

Arguments:

   hProfile     -  The profile handle context

   pProfileinfo -  the output buffer to hold profile info (SCP or SAP).

   Errlog       -  A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    SCESTATUS                rc;
    PSCESECTION              hSection=NULL;

    SCE_KEY_LOOKUP AccessKeys[] = {
        {(PWSTR)TEXT("MinimumPasswordAge"),     offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),    'D'},
        {(PWSTR)TEXT("MaximumPasswordAge"),     offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),    'D'},
        {(PWSTR)TEXT("MinimumPasswordLength"),  offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength), 'D'},
        {(PWSTR)TEXT("PasswordComplexity"),     offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),    'D'},
        {(PWSTR)TEXT("PasswordHistorySize"),    offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),   'D'},
        {(PWSTR)TEXT("LockoutBadCount"),        offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),       'D'},
        {(PWSTR)TEXT("ResetLockoutCount"),      offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),     'D'},
        {(PWSTR)TEXT("LockoutDuration"),        offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),       'D'},
        {(PWSTR)TEXT("RequireLogonToChangePassword"),offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword),'D'},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire"),offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire),'D'},
        {(PWSTR)TEXT("ClearTextPassword"),      offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),     'D'},
        {(PWSTR)TEXT("LSAAnonymousNameLookup"), offsetof(struct _SCE_PROFILE_INFO, LSAAnonymousNameLookup),     'D'},
        {(PWSTR)TEXT("EnableAdminAccount"),    offsetof(struct _SCE_PROFILE_INFO, EnableAdminAccount),     'D'},
        {(PWSTR)TEXT("EnableGuestAccount"),    offsetof(struct _SCE_PROFILE_INFO, EnableGuestAccount),     'D'}
        };

    DWORD cKeys = sizeof(AccessKeys) / sizeof(SCE_KEY_LOOKUP);

    DWORD         DataSize=0;
    PWSTR         Strvalue=NULL;
    DWORD                  SDsize=0;
    PSECURITY_DESCRIPTOR   pTempSD=NULL;


    if ( pProfileInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepGetFixValueSection(
               hProfile,
               szSystemAccess,
               AccessKeys,
               cKeys,
               ProfileType,
               (PVOID)pProfileInfo,
               &hSection,
               Errlog
               );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // get new administrator for SCP and SMP types
    //
    rc = ScepGetVariableValue(
            hSection,
            ProfileType,
            L"NewAdministratorName",
            &Strvalue,
            &DataSize
            );
    if ( rc != SCESTATUS_RECORD_NOT_FOUND &&
         rc != SCESTATUS_SUCCESS ) {

        ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                             Errlog, SCEERR_QUERY_VALUE,
                             L"NewAdministratorName"
                           );
        goto Done;
    }
    rc = SCESTATUS_SUCCESS;

    if ( Strvalue ) {
        if ( Strvalue[0] != L'\0') {
            pProfileInfo->NewAdministratorName = Strvalue;
        } else {
            pProfileInfo->NewAdministratorName = NULL;
            ScepFree(Strvalue);
        }
        Strvalue = NULL;
    }

    //
    // NewGuestName
    //

    rc = ScepGetVariableValue(
            hSection,
            ProfileType,
            L"NewGuestName",
            &Strvalue,
            &DataSize
            );
    if ( rc != SCESTATUS_RECORD_NOT_FOUND &&
         rc != SCESTATUS_SUCCESS ) {

        ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                             Errlog, SCEERR_QUERY_VALUE,
                             L"NewGuestName"
                           );
        goto Done;
    }
    rc = SCESTATUS_SUCCESS;

    if ( Strvalue ) {
        if ( Strvalue[0] != L'\0') {
            pProfileInfo->NewGuestName = Strvalue;
        } else {
            pProfileInfo->NewGuestName = NULL;
            ScepFree(Strvalue);
        }
        Strvalue = NULL;
    }

Done:

    SceJetCloseSection(&hSection, TRUE);

    if ( pTempSD != NULL )
        ScepFree(pTempSD);

    if ( Strvalue != NULL )
        ScepFree( Strvalue );

    return(rc);
}


SCESTATUS
ScepGetFixValueSection(
    IN PSCECONTEXT  hProfile,
    IN PCWSTR      SectionName,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN SCETYPE ProfileType,
    OUT PVOID pInfo,
    OUT PSCESECTION *phSection,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
-- */
{
    SCESTATUS                rc;
    DWORD                   i;
    TCHAR                   Value[25];
    DWORD                   RetValueLen;
    LONG                    Keyvalue;



    rc = ScepOpenSectionForName(
                hProfile,
                (ProfileType==SCE_ENGINE_GPO)? SCE_ENGINE_SCP : ProfileType,
                SectionName,
                phSection
                );
    if ( SCESTATUS_SUCCESS != rc ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog, SCEERR_OPEN,
                             SectionName
                           );
        return(rc);
    }

    JET_COLUMNID  ColGpoID = 0;
    JET_ERR       JetErr;
    LONG          GpoID=0;
    DWORD         Actual;

    if ( ProfileType == SCE_ENGINE_GPO ) {
        JET_COLUMNDEF ColumnGpoIDDef;

        JetErr = JetGetTableColumnInfo(
                        (*phSection)->JetSessionID,
                        (*phSection)->JetTableID,
                        "GpoID",
                        (VOID *)&ColumnGpoIDDef,
                        sizeof(JET_COLUMNDEF),
                        JET_ColInfo
                        );
        if ( JET_errSuccess == JetErr ) {
            ColGpoID = ColumnGpoIDDef.columnid;
        }
    }

    //
    // get each key in the access array
    //
    for ( i=0; i<cKeys; i++ ) {

        memset(Value, '\0', 50);
        RetValueLen = 0;

        rc = SceJetGetValue(
                *phSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                (PWSTR)(Keys[i].KeyString),
                NULL,
                0,
                NULL,
                Value,
                48,
                &RetValueLen
                );

        if ( RetValueLen > 0 )
            Value[RetValueLen/2] = L'\0';

        if ( rc == SCESTATUS_SUCCESS ) {

            GpoID = 1;
            if ( ProfileType == SCE_ENGINE_GPO ) {

                //
                // query if the setting comes from a GPO
                // get GPO ID field from the current line
                //
                GpoID = 0;

                if ( ColGpoID > 0 ) {

                    JetErr = JetRetrieveColumn(
                                    (*phSection)->JetSessionID,
                                    (*phSection)->JetTableID,
                                    ColGpoID,
                                    (void *)&GpoID,
                                    4,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                }
            }

            if ( GpoID > 0 && RetValueLen > 0 && Value[0] != L'\0' )
                Keyvalue = _wtol(Value);
            else
                Keyvalue = SCE_NO_VALUE;

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS; // it is OK not find a record
            Keyvalue = SCE_NO_VALUE;
        } else {
            ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                 Errlog,
                                 SCEERR_QUERY_VALUE,
                                 Keys[i].KeyString
                               );
            goto Done;
        }
#ifdef SCE_DBG
        printf("Get info %s (%d) for ", Value, Keyvalue);
        wprintf(L"%s. rc=%d, Return Length=%d\n",
                Keys[i].KeyString, rc, RetValueLen);
#endif

        switch (Keys[i].BufferType ) {
        case 'B':
            *((BOOL *)((CHAR *)pInfo+Keys[i].Offset)) = (Keyvalue == 1) ? TRUE : FALSE;
            break;
        case 'D':
            *((DWORD *)((CHAR *)pInfo+Keys[i].Offset)) = Keyvalue;
            break;
        default:
            rc = SCESTATUS_INVALID_DATA;
            ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                 Errlog,
                                 SCEERR_CANT_FIND_DATATYPE,
                                 Keys[i].KeyString
                               );
            goto Done;
        }
    }

Done:
    //
    // close the section
    //
    if ( rc != SCESTATUS_SUCCESS ) {

        SceJetCloseSection(phSection, TRUE);
    }

    return(rc);

}


SCESTATUS
ScepGetVariableValue(
    IN PSCESECTION hSection,
    IN SCETYPE ProfileType,
    IN PCWSTR KeyName,
    OUT PWSTR *Value,
    OUT PDWORD ValueLen
    )
/* ++
-- */
{

    SCESTATUS   rc;

    rc = SceJetGetValue(
            hSection,
            SCEJET_EXACT_MATCH_NO_CASE,
            (PWSTR)KeyName,
            NULL,
            0,
            NULL,
            NULL,
            0,
            ValueLen
            );

    if ( rc == SCESTATUS_SUCCESS && *ValueLen > 0 ) {

        LONG          GpoID=1;

        if ( ProfileType == SCE_ENGINE_GPO ) {

            JET_COLUMNDEF ColumnGpoIDDef;
            JET_COLUMNID  ColGpoID = 0;
            JET_ERR       JetErr;
            DWORD         Actual;


            JetErr = JetGetTableColumnInfo(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            "GpoID",
                            (VOID *)&ColumnGpoIDDef,
                            sizeof(JET_COLUMNDEF),
                            JET_ColInfo
                            );

            GpoID = 0;

            if ( JET_errSuccess == JetErr ) {
                ColGpoID = ColumnGpoIDDef.columnid;
                //
                // query if the setting comes from a GPO
                // get GPO ID field from the current line
                //
                JetErr = JetRetrieveColumn(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                ColGpoID,
                                (void *)&GpoID,
                                4,
                                &Actual,
                                0,
                                NULL
                                );

            }
        }

        if ( GpoID > 0 ) {

            //
            // if DataSize = 0 then the security descriptor is NULL also
            //
            *Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, *ValueLen+2);

            if( *Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

            } else {
                rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        (PWSTR)KeyName,
                        NULL,
                        0,
                        NULL,
                        *Value,
                        *ValueLen,
                        ValueLen
                        );
            }

        } else {

            rc = SCESTATUS_RECORD_NOT_FOUND;
        }

    }

    return(rc);

}


SCESTATUS
ScepGetPrivileges(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN DWORD dwAccountFormat,
   OUT PVOID *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
{
   SCESTATUS rc;

   LSA_HANDLE LsaHandle=NULL;

   rc = RtlNtStatusToDosError(
             ScepOpenLsaPolicy(
                   MAXIMUM_ALLOWED,
                   &LsaHandle,
                   TRUE
                   ));

   if ( ERROR_SUCCESS != rc ) {
       ScepBuildErrorLogInfo(
                   rc,
                   Errlog,
                   SCEDLL_LSA_POLICY
                   );
       return(ScepDosErrorToSceStatus(rc));
   }

   PSCE_PRIVILEGE_ASSIGNMENT pTempList=NULL, pNode, pPriv, pParent, pTemp;

    rc = ScepGetPrivilegesFromOneTable(
                   LsaHandle,
                   hProfile,
                   ProfileType,
                   dwAccountFormat,
                   pPrivileges,
                   Errlog
                   );

    if ( SCESTATUS_SUCCESS == rc && SCE_ENGINE_SAP == ProfileType ) {
        //
        // get the remaining stuff from SMP
        //
        rc = ScepGetPrivilegesFromOneTable(
                    LsaHandle,
                    hProfile,
                    SCE_ENGINE_SCP, // SCE_ENGINE_SMP,
                    dwAccountFormat,
                    (PVOID *)&pTempList,
                    Errlog
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // add non-exist nodes to pPrivileges
            //
            pNode=pTempList;
            pParent=NULL;

            while ( pNode ) {
                //
                // if this node does not exist in the SAP
                // this node is analyzed with "match" status
                // if it already exists in SAP, it is a "mismatched" item
                // duplication is prevented by the last argument TRUE
                //
                for ( pPriv=(PSCE_PRIVILEGE_ASSIGNMENT)(*pPrivileges);
                      pPriv != NULL; pPriv=pPriv->Next ) {
                    if ( pPriv->Status & SCE_INTERNAL_NP &&
                         _wcsicmp( pPriv->Name, pNode->Name) == 0 )
                        break;
                }
                if ( pPriv ) {
                    //
                    // find the entry in SAP, mismatched item
                    //
                    if ( pPriv->Status & SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                        pPriv->Status = SCE_STATUS_ERROR_NOT_AVAILABLE;
                    } else {
                        pPriv->Status = SCE_STATUS_MISMATCH;
                    }

                    pParent = pNode;
                    pNode = pNode->Next;

                } else {
                    //
                    // does not exist in SAP.
                    // just move this node to SAP, with status SCE_STATUS_GOOD
                    //
                    if ( pParent )
                        pParent->Next = pNode->Next;
                    else
                        pTempList = pNode->Next;

                    pTemp = pNode;
                    pNode=pNode->Next;

                    pTemp->Next = (PSCE_PRIVILEGE_ASSIGNMENT)(*pPrivileges);
                    *((PSCE_PRIVILEGE_ASSIGNMENT *)pPrivileges) = pTemp;
                }
            }
            //
            // priv exist in analysis but not in template
            //
            for ( pPriv=(PSCE_PRIVILEGE_ASSIGNMENT)(*pPrivileges);
                  pPriv != NULL; pPriv=pPriv->Next ) {
                if ( pPriv->Status & SCE_INTERNAL_NP )
                    pPriv->Status = SCE_STATUS_NOT_CONFIGURED;
            }

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            rc = SCESTATUS_SUCCESS;

        } else {
            //
            // pPrivileges will be freed outside
            //
        }

        if ( pTempList )
            ScepFreePrivilege(pTempList);
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);
}


SCESTATUS
ScepGetPrivilegesFromOneTable(
   IN LSA_HANDLE LsaPolicy,
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN DWORD dwAccountFormat,
   OUT PVOID *pPrivileges,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

Arguments:

Return Value:


-- */
{
    SCESTATUS      rc;
    PSCESECTION    hSection=NULL;
    WCHAR         KeyName[36];
    PWSTR         Value=NULL;

    PSCE_PRIVILEGE_ASSIGNMENT   pPrivilegeAssigned=NULL;
    PSCE_PRIVILEGE_VALUE_LIST   pPrivilegeList=NULL;

    DWORD         KeyLen=0;
    DWORD         ValueLen;
    DWORD         Len;
    PWSTR         pTemp;
    DWORD         PrivValue;


    if ( pPrivileges == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    rc = ScepOpenSectionForName(
            hProfile,
            (ProfileType==SCE_ENGINE_GPO)? SCE_ENGINE_SCP : ProfileType,
            szPrivilegeRights,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog, SCEERR_OPEN,
                             szPrivilegeRights
                           );
        return(rc);
    }

    JET_COLUMNID  ColGpoID = 0;
    JET_ERR       JetErr;
    LONG GpoID;


    if ( ProfileType == SCE_ENGINE_GPO ) {

        JET_COLUMNDEF ColumnGpoIDDef;

        JetErr = JetGetTableColumnInfo(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        "GpoID",
                        (VOID *)&ColumnGpoIDDef,
                        sizeof(JET_COLUMNDEF),
                        JET_ColInfo
                        );
        if ( JET_errSuccess == JetErr ) {
            ColGpoID = ColumnGpoIDDef.columnid;
        }
    }

    //
    // goto the first line of this section
    //
//    memset(KeyName, '\0', 72);   KeyName will be manually terminated later
    rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                KeyName,
                70,
                &KeyLen,
                NULL,
                0,
                &ValueLen
                );
    while ( rc == SCESTATUS_SUCCESS ||
            rc == SCESTATUS_BUFFER_TOO_SMALL ) {

        //
        // terminate the string
        //
        KeyName[KeyLen/2] = L'\0';

        //
        // lookup privilege's value
        // ignore unknown privileges
        //
        if ( ( PrivValue = ScepLookupPrivByName(KeyName) ) == -1 ) {
            ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                 Errlog,
                                 SCEERR_INVALID_PRIVILEGE,
                                 KeyName
                               );

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_NEXT_LINE,
                        NULL,
                        KeyName,
                        70,
                        &KeyLen,
                        NULL,
                        0,
                        &ValueLen
                        );
            continue;
//            rc = SCESTATUS_INVALID_DATA;
//            goto Done;
        }

        GpoID = 1;

        if ( ProfileType == SCE_ENGINE_GPO ) {

            GpoID = 0;

            if ( ColGpoID > 0 ) {

                DWORD Actual;

                JetErr = JetRetrieveColumn(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                ColGpoID,
                                (void *)&GpoID,
                                4,
                                &Actual,
                                0,
                                NULL
                                );
            }
        }

        if ( ProfileType == SCE_ENGINE_GPO &&
             GpoID <= 0 ) {
            //
            // not domain GPO settings
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_NEXT_LINE,
                        NULL,
                        KeyName,
                        70,
                        &KeyLen,
                        NULL,
                        0,
                        &ValueLen
                        );
            continue;
        }

        //
        // allocate memory for the group name and value string
        //
        Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

        if ( Value == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;

        }
        //
        // Get the group and its value
        //
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    Value,
                    ValueLen,
                    &ValueLen
                    );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

        //
        // create a node for this privilege
        //
        if ( ProfileType == SCE_ENGINE_SAP ||
             ProfileType == SCE_ENGINE_SMP ||
             ProfileType == SCE_ENGINE_GPO ||
             ProfileType == SCE_ENGINE_SCP ) {

            //
            // a sce_privilege_assignment structure. allocate buffer
            //
            pPrivilegeAssigned = (PSCE_PRIVILEGE_ASSIGNMENT)ScepAlloc( LMEM_ZEROINIT,
                                                                     sizeof(SCE_PRIVILEGE_ASSIGNMENT) );
            if ( pPrivilegeAssigned == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }
            pPrivilegeAssigned->Name = (PWSTR)ScepAlloc( (UINT)0, (wcslen(KeyName)+1)*sizeof(WCHAR));
            if ( pPrivilegeAssigned->Name == NULL ) {
                ScepFree(pPrivilegeAssigned);
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }

            wcscpy(pPrivilegeAssigned->Name, KeyName);
            pPrivilegeAssigned->Value = PrivValue;

            if ( SCE_ENGINE_SAP == ProfileType )
                pPrivilegeAssigned->Status = SCE_INTERNAL_NP;
            else
                pPrivilegeAssigned->Status = SCE_STATUS_GOOD;
        }

        //
        // add the multi-sz value string to the node, depending on the value type
        //
        PSID pSid=NULL;
        BOOL bBufferUsed;

        pTemp = Value;
        if (pTemp != NULL && pTemp[0] == L'\0' && ValueLen > 1) {
            pTemp ++;
        }

        while ( rc == SCESTATUS_SUCCESS && pTemp != NULL && pTemp[0]) {
            Len = wcslen(pTemp);

            if ( (ProfileType == SCE_ENGINE_SAP) &&
                 (_wcsicmp( SCE_ERROR_STRING, pTemp) == 0)  ) {
                //
                // this is an errored item
                //
                pPrivilegeAssigned->Status |= SCE_STATUS_ERROR_NOT_AVAILABLE;
                break;
            }

            //
            // convert pTemp (may be a name, or *SID format) to the right
            // format (SID_STRING, Name, or ACCOUNT_SID)
            //
            switch ( dwAccountFormat ) {
            case SCE_ACCOUNT_SID:

                if ( pTemp[0] == L'*' ) {
                    //
                    // this is the *SID format, convert to SID
                    //
                    if ( !ConvertStringSidToSid( pTemp+1, &pSid) ) {
                        //
                        // if failed to convert from sid string to sid,
                        // treat it as any name
                        //
                        rc = GetLastError();
                    }
                } else {
                    //
                    // lookup name for a sid
                    //
                    rc = RtlNtStatusToDosError(
                              ScepConvertNameToSid(
                                   LsaPolicy,
                                   pTemp,
                                   &pSid
                                   ));
                }

                if ( ERROR_SUCCESS == rc && pSid ) {

                    if ( ProfileType == SCE_ENGINE_SAP ||
                         ProfileType == SCE_ENGINE_SMP ||
                         ProfileType == SCE_ENGINE_GPO ||
                         ProfileType == SCE_ENGINE_SCP ) {

                        rc = ScepAddSidToNameList(
                                     &(pPrivilegeAssigned->AssignedTo),
                                     pSid,
                                     TRUE, // reuse the buffer
                                     &bBufferUsed
                                     );

                    } else {
                        //
                        // add to privilege list (as Sid)
                        //
                        rc = ScepAddSidToPrivilegeList(
                                      &pPrivilegeList,
                                      pSid,
                                      TRUE, // reuse the buffer
                                      PrivValue,
                                      &bBufferUsed
                                      );
                    }

                    if ( rc == ERROR_SUCCESS && bBufferUsed ) {
                        pSid = NULL;
                    }

                    rc = ScepDosErrorToSceStatus(rc);

                } else {
                    //
                    // add as name format
                    //
                    if ( ProfileType == SCE_ENGINE_SAP ||
                         ProfileType == SCE_ENGINE_SMP ||
                         ProfileType == SCE_ENGINE_GPO ||
                         ProfileType == SCE_ENGINE_SCP ) {

                        rc = ScepAddToNameList(&(pPrivilegeAssigned->AssignedTo), pTemp, Len );
                        rc = ScepDosErrorToSceStatus(rc);

                    } else {
                        //
                        // pPrivilegeList is a privilege_value list for each user/group.
                        // the LowValue and HighValue fields are combination of all privileges assigned to the user
                        //
                        rc = ScepAddToPrivilegeList(&pPrivilegeList, pTemp, Len, PrivValue);
                    }
                }

                if ( pSid ) {
                    LocalFree(pSid);
                    pSid = NULL;
                }

                break;

            default:

                if ( (dwAccountFormat != SCE_ACCOUNT_SID_STRING) &&
                     (pTemp[0] == L'*') ) {
                    //
                    // this is a *SID format, must be converted into Domain\Account format
                    //
                    if ( ProfileType == SCE_ENGINE_SAP ||
                         ProfileType == SCE_ENGINE_SMP ||
                         ProfileType == SCE_ENGINE_GPO ||
                         ProfileType == SCE_ENGINE_SCP ) {

                        rc = ScepLookupSidStringAndAddToNameList(
                                     LsaPolicy,
                                     &(pPrivilegeAssigned->AssignedTo),
                                     pTemp, // +1,
                                     Len    // -1
                                     );
                    } else {
                        //
                        // add to privilege value list
                        //
                        PWSTR strName=NULL;
                        DWORD strLen=0;

                        if ( ConvertStringSidToSid( pTemp+1, &pSid) ) {

                            rc = RtlNtStatusToDosError(
                                     ScepConvertSidToName(
                                            LsaPolicy,
                                            pSid,
                                            TRUE,       // want domain\account format
                                            &strName,
                                            &strLen
                                            ));
                            LocalFree(pSid);
                            pSid = NULL;

                        } else {
                            rc = GetLastError();
                        }

                        if ( rc == ERROR_SUCCESS ) {
                            //
                            // add the name to the privilege list
                            //
                            rc = ScepAddToPrivilegeList(&pPrivilegeList, strName, strLen, PrivValue);
                        } else {
                            //
                            // if couldn't lookup for the name, add *SID to the list
                            //
                            rc = ScepAddToPrivilegeList(&pPrivilegeList, pTemp, Len, PrivValue);
                        }

                        if ( strName ) {
                            ScepFree(strName);
                            strName = NULL;
                        }
                    }
                } else {

                    if ( ProfileType == SCE_ENGINE_SAP ||
                         ProfileType == SCE_ENGINE_SMP ||
                         ProfileType == SCE_ENGINE_GPO ||
                         ProfileType == SCE_ENGINE_SCP ) {

                        rc = ScepDosErrorToSceStatus(
                                 ScepAddToNameList(&(pPrivilegeAssigned->AssignedTo),
                                                   pTemp,
                                                   Len ));

                    } else {
                        //
                        // pPrivilegeList is a privilege_value list for each user/group.
                        // the LowValue and HighValue fields are combination of all privileges assigned to the user
                        //
                        rc = ScepAddToPrivilegeList(&pPrivilegeList, pTemp, Len, PrivValue);
#ifdef SCE_DBG
                        wprintf(L"\tAdd Priv %d for %s (%d bytes)\n", PrivValue, pTemp, Len);
#endif
                    }
                }
                break;
            }

            pTemp += Len +1;
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ERROR_WRITE_FAULT,
                                     Errlog,
                                     SCEERR_ADD,
                                     KeyName
                                   );
            }
        }

        //
        // Free memory
        //
        if ( rc != SCESTATUS_SUCCESS ) {
            if ( pPrivilegeAssigned != NULL )
                ScepFreePrivilege(pPrivilegeAssigned);

            if ( pPrivilegeList != NULL )
                ScepFreePrivilegeValueList(pPrivilegeList);

            goto Done;
        }

        //
        // link this to the PSCE_PRIVILEGE_ASSIGNMENT list in pPrivileges
        //
        if ( ProfileType == SCE_ENGINE_SAP ||
             ProfileType == SCE_ENGINE_SMP ||
             ProfileType == SCE_ENGINE_GPO ||
             ProfileType == SCE_ENGINE_SCP ) {

            pPrivilegeAssigned->Next = *((PSCE_PRIVILEGE_ASSIGNMENT *)pPrivileges);
            *((PSCE_PRIVILEGE_ASSIGNMENT *)pPrivileges) = pPrivilegeAssigned;
            pPrivilegeAssigned = NULL;

        }

        ScepFree(Value);
        Value = NULL;

        //
        // read next line
        //
//        memset(KeyName, '\0', 72);  KeyName will be manually terminated
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_NEXT_LINE,
                    NULL,
                    KeyName,
                    70,
                    &KeyLen,
                    NULL,
                    0,
                    &ValueLen
                    );
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    if ( rc == SCESTATUS_SUCCESS ) {

       if ( ProfileType == SCE_ENGINE_SCP_INTERNAL ||
            ProfileType == SCE_ENGINE_SMP_INTERNAL )
           *((PSCE_PRIVILEGE_VALUE_LIST *)pPrivileges) = pPrivilegeList;

    }

Done:

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    if ( Value != NULL )
        ScepFree(Value);

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    return(rc);

}


SCESTATUS
ScepAddToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PWSTR Name,
    IN DWORD Len,
    IN DWORD PrivValue
    )
{
    PSCE_PRIVILEGE_VALUE_LIST  pPriv,
                               LastOne=NULL;


    if ( pPrivilegeList == NULL || Name == NULL || Len == 0 )
        return(SCESTATUS_INVALID_PARAMETER);

    for ( pPriv = *pPrivilegeList;
          pPriv != NULL;
          LastOne=pPriv, pPriv = pPriv->Next ) {

        if ( ( wcslen(pPriv->Name) == Len ) &&
             ( _wcsnicmp( pPriv->Name, Name, Len ) == 0 ) ) {
            if ( PrivValue < 32 ) {

                pPriv->PrivLowPart |= (1 << PrivValue);
            } else {
                pPriv->PrivHighPart |= (1 << (PrivValue-32) );
            }
            break;
        }
    }
    if ( pPriv == NULL ) {
        //
        // Create a new one
        //
        pPriv = (PSCE_PRIVILEGE_VALUE_LIST)ScepAlloc( LMEM_ZEROINIT,
                                                sizeof(SCE_PRIVILEGE_VALUE_LIST));
        if ( pPriv == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        pPriv->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));
        if ( pPriv->Name == NULL ) {
            ScepFree(pPriv);
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        wcsncpy(pPriv->Name, Name, Len);

        if ( PrivValue < 32 ) {

            pPriv->PrivLowPart |= (1 << PrivValue);
        } else {
            pPriv->PrivHighPart |= (1 << (PrivValue-32) );
        }

        //
        // link to the list
        //
        if ( LastOne != NULL )
            LastOne->Next = pPriv;
        else
            *pPrivilegeList = pPriv;

    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepAddSidToPrivilegeList(
    OUT PSCE_PRIVILEGE_VALUE_LIST  *pPrivilegeList,
    IN PSID pSid,
    IN BOOL bReuseBuffer,
    IN DWORD PrivValue,
    OUT BOOL *pbBufferUsed
    )
{

    if ( pPrivilegeList == NULL || pbBufferUsed == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    *pbBufferUsed = FALSE;

    if ( pSid == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( !ScepValidSid(pSid) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCE_PRIVILEGE_VALUE_LIST  pPriv,
                               LastOne=NULL;

    //
    // check if the sid is already in the list
    //
    for ( pPriv = *pPrivilegeList;
          pPriv != NULL;
          LastOne=pPriv, pPriv = pPriv->Next ) {

        if ( pPriv->Name == NULL ) {
            continue;
        }

        if ( ScepValidSid( (PSID)(pPriv->Name) ) &&
             RtlEqualSid( (PSID)(pPriv->Name), pSid ) ) {

            if ( PrivValue < 32 ) {

                pPriv->PrivLowPart |= (1 << PrivValue);
            } else {
                pPriv->PrivHighPart |= (1 << (PrivValue-32) );
            }

            break;
        }
    }

    if ( pPriv == NULL ) {
        //
        // Create a new one
        //
        pPriv = (PSCE_PRIVILEGE_VALUE_LIST)ScepAlloc( LMEM_ZEROINIT,
                                                sizeof(SCE_PRIVILEGE_VALUE_LIST));
        if ( pPriv == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        if ( bReuseBuffer ) {

            pPriv->Name = (PWSTR)pSid;
            *pbBufferUsed = TRUE;

        } else {

            DWORD Length = RtlLengthSid ( pSid );

            pPriv->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, Length);
            if ( pPriv->Name == NULL ) {
                ScepFree(pPriv);
                return(SCESTATUS_NOT_ENOUGH_RESOURCE);
            }

            RtlCopySid( Length, (PSID)(pPriv->Name), pSid );

        }

        if ( PrivValue < 32 ) {

            pPriv->PrivLowPart |= (1 << PrivValue);
        } else {
            pPriv->PrivHighPart |= (1 << (PrivValue-32) );
        }

        //
        // link to the list
        //
        if ( LastOne != NULL )
            LastOne->Next = pPriv;
        else
            *pPrivilegeList = pPriv;

    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepGetGroupMembership(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
{
    SCESTATUS rc;
    DWORD OneStatus;

    PSCE_GROUP_MEMBERSHIP pTempList=NULL, pNode, pGroup2,
                            pParent, pTemp;

    LSA_HANDLE LsaHandle=NULL;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        ScepBuildErrorLogInfo(
                    rc,
                    Errlog,
                    SCEDLL_LSA_POLICY
                    );
        return(ScepDosErrorToSceStatus(rc));
    }

    //
    // get groups from the requested table first
    //
    rc = ScepGetGroupMembershipFromOneTable(
                LsaHandle,
                hProfile,
                ProfileType,
                pGroupMembership,
                Errlog
                );
    //
    // return all groups if it is requested for SAP entry
    //
    if ( SCESTATUS_SUCCESS == rc && SCE_ENGINE_SAP == ProfileType ) {
        //
        // get the remaining stuff from SMP
        //
        rc = ScepGetGroupMembershipFromOneTable(
                    LsaHandle,
                    hProfile,
                    SCE_ENGINE_SCP,   //SCE_ENGINE_SMP,
                    &pTempList,
                    Errlog
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // add non-exist nodes to pObjectRoots
            //
            pNode=pTempList;
            pParent=NULL;

            while ( pNode ) {
                //
                // if this node does not exist in the SAP
                // this node is analyzed with "match" status
                // if it already exists in SAP, it is a "mismatched" item
                // duplication is prevented by the last argument TRUE
                //
                for ( pGroup2=*pGroupMembership; pGroup2 != NULL; pGroup2=pGroup2->Next ) {
                    if ( (pGroup2->Status & SCE_INTERNAL_NP) &&
                         _wcsicmp( pGroup2->GroupName, pNode->GroupName) == 0 )
                        break;
                }
                if ( pGroup2 ) {
                    //
                    // find the entry in SAP, mismatched item
                    // maybe pMembers, or pMemberOf
                    // or not analyzed item, or error items
                    //
                    OneStatus = pGroup2->Status;
                    pGroup2->Status = 0;

                    if ( (OneStatus & SCE_GROUP_STATUS_NOT_ANALYZED) ) {
                        // this item is added after last inspection
                        pGroup2->Status = SCE_GROUP_STATUS_NOT_ANALYZED;

                    } else if ( (OneStatus & SCE_GROUP_STATUS_ERROR_ANALYZED) ) {

                        // this item errored when analyzing
                        pGroup2->Status = SCE_GROUP_STATUS_ERROR_ANALYZED;

                    } else {
                        if ( pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS ) {
                            pGroup2->Status |= SCE_GROUP_STATUS_NC_MEMBERS;
                        } else {
                            if ( !(OneStatus & SCE_GROUP_STATUS_NC_MEMBERS) ) {
                                pGroup2->Status |= SCE_GROUP_STATUS_MEMBERS_MISMATCH;
                            } else {
                                // a matched members, pGroup2->pMembers should be NULL;
                                if ( pGroup2->pMembers ) {
                                    ScepFreeNameList(pGroup2->pMembers);
                                }
                                pGroup2->pMembers = pNode->pMembers;
                                pNode->pMembers = NULL;
                            }
                        }

                        if ( pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF ) {
                            pGroup2->Status |= SCE_GROUP_STATUS_NC_MEMBEROF;
                        } else {
                            if ( !(OneStatus & SCE_GROUP_STATUS_NC_MEMBEROF) ) {
                                pGroup2->Status |= SCE_GROUP_STATUS_MEMBEROF_MISMATCH;
                            } else {
                                // a matched memberof, pGroup2->pMemberOf should be NULL;
                                if ( pGroup2->pMemberOf ) {
                                    ScepFreeNameList(pGroup2->pMemberOf);
                                }
                                pGroup2->pMemberOf = pNode->pMemberOf;
                                pNode->pMemberOf = NULL;
                            }
                        }
                    }
                    pParent = pNode;
                    pNode = pNode->Next;

                } else {
                    //
                    // does not exist in SAP.
                    // this is a matched item on pMembers, and/or pMemberOf
                    // just move this node to SAP, with status NC_MEMBERS, or NC_MEMBEROF, or 0
                    //
                    if ( pParent )
                        pParent->Next = pNode->Next;
                    else
                        pTempList = pNode->Next;

                    pTemp = pNode;
                    pNode=pNode->Next;

                    pTemp->Next = *pGroupMembership;
                    *pGroupMembership = pTemp;
                }
            }
            //
            // group exist in analysis but not in template
            //
            for ( pGroup2=*pGroupMembership; pGroup2 != NULL; pGroup2=pGroup2->Next ) {
                if ( pGroup2->Status & SCE_INTERNAL_NP )
                    pGroup2->Status = SCE_GROUP_STATUS_NC_MEMBERS | SCE_GROUP_STATUS_NC_MEMBEROF;
            }

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            rc = SCESTATUS_SUCCESS;

        } else {
            //
            // pGroupMembership will be freed outside
            //
        }

        if ( pTempList ) {
            ScepFreeGroupMembership(pTempList);
        }
    }

    //
    // now the group name may be in *SID format, conver it now to name
    //
    if ( SCESTATUS_SUCCESS == rc && *pGroupMembership ) {

        for ( pGroup2=*pGroupMembership; pGroup2 != NULL; pGroup2=pGroup2->Next ) {
            if ( pGroup2->GroupName == NULL ) {
                continue;
            }

            if ( pGroup2->GroupName[0] == L'*' ) {
                //
                // *SID format, convert it
                //
                PSID pSid=NULL;

                if ( ConvertStringSidToSid( (pGroup2->GroupName)+1, &pSid) ) {

                    PWSTR strName=NULL;
                    DWORD strLen=0;

                    if (NT_SUCCESS( ScepConvertSidToName(
                                        LsaHandle,
                                        pSid,
                                        TRUE,       // want domain\account format
                                        &strName,
                                        &strLen
                                        )) && strName ) {

                        ScepFree(pGroup2->GroupName);
                        pGroup2->GroupName = strName;
                        strName = NULL;
                    }

                    LocalFree(pSid);
                    pSid = NULL;
                }
            }
        }
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);

}


SCESTATUS
ScepGetGroupMembershipFromOneTable(
    IN LSA_HANDLE  LsaPolicy,
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    OUT PSCE_GROUP_MEMBERSHIP *pGroupMembership,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves group membership information from the Jet databasae
   and stores in the output buffer pGroupMembership. Group membership information
   is in [Group Membership] section.

Arguments:

   hProfile      - the profile handle context

   ProfileType   - Type of the Profile
                        SCE_ENGINE_SAP
                        SCE_ENGINE_SMP
                        SCE_ENGINE_SCP

   pGroupMembership - the output buffer to hold group membership info.

   Errlog    - the error list for errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA

-- */
{
    SCESTATUS      rc;
    PSCESECTION    hSection=NULL;
    PSCE_GROUP_MEMBERSHIP   pGroup=NULL;
    DWORD         GroupLen, ValueLen;
    PWSTR         GroupName=NULL;
    PWSTR         Value=NULL;
    DWORD         ValueType;
    ULONG         Len;
    PWSTR         pTemp;


    if ( pGroupMembership == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            szGroupMembership,
            &hSection
            );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_OPEN,
                             szGroupMembership
                           );
        return(rc);
    }

    //
    // goto the first line of this section
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                NULL,
                0,
                &GroupLen,
                NULL,
                0,
                &ValueLen
                );
    while ( rc == SCESTATUS_SUCCESS ) {

        //
        // allocate memory for the group name and value string
        //
        GroupName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, GroupLen+2);
        Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

        if ( GroupName == NULL || Value == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;

        }
        //
        // Get the group and its value
        //
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    GroupName,
                    GroupLen,
                    &GroupLen,
                    Value,
                    ValueLen,
                    &ValueLen
                    );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

        GroupName[GroupLen/2] = L'\0';
        Value[ValueLen/2] = L'\0';

#ifdef SCE_DBG
    wprintf(L"rc=%d, group membership: %s=%s\n", rc, GroupName, Value);
#endif

        if (pTemp = ScepWcstrr(GroupName, szMembers) )
            ValueType = 0;
        else if (pTemp = ScepWcstrr(GroupName, szMemberof) )
            ValueType = 1;
        else if (pTemp = ScepWcstrr(GroupName, szPrivileges) )
            ValueType = 2;

        if ( pTemp == NULL ) {
            ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                                 Errlog,
                                 SCEERR_CANT_FIND_KEYWORD,
                                 GroupName
                               );
            rc = SCESTATUS_INVALID_DATA;
            goto NextLine;  //Done;
        }

        Len = (DWORD)(pTemp - GroupName);

        //
        // if this is the first group, or a different group, create another node
        // Note, the group name may be in SID string format now.
        // Will be converted later (in the calling function) because we don't want
        // to lookup for the same group name several times (each group may have
        // multiple records).
        //
        if ( *pGroupMembership == NULL ||
             _wcsnicmp((*pGroupMembership)->GroupName, GroupName, Len) != 0 ||
             (*pGroupMembership)->GroupName[Len] != L'\0' ) {
            //
            // a new group. allocate buffer
            //
            pGroup = (PSCE_GROUP_MEMBERSHIP)ScepAlloc( LMEM_ZEROINIT, sizeof(SCE_GROUP_MEMBERSHIP) );
            if ( pGroup == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }
            pGroup->GroupName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));
            if ( pGroup->GroupName == NULL ) {
                ScepFree(pGroup);
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }
            //
            // get right case for group name
            //
            wcsncpy(pGroup->GroupName, GroupName, Len);

            // do not care return codes
            ScepGetGroupCase(pGroup->GroupName, Len);

            pGroup->Next = *pGroupMembership;

//            if ( SCE_ENGINE_SAP == ProfileType )
                pGroup->Status = SCE_GROUP_STATUS_NC_MEMBERS | SCE_GROUP_STATUS_NC_MEMBEROF;
//            else
//                pGroup->Status = 0;
            if ( SCE_ENGINE_SAP == ProfileType )
                pGroup->Status |= SCE_INTERNAL_NP;

        }

        //
        // add the multi-sz value string to the group node, depending on the value type
        //
        pTemp = Value;
        while ( rc == SCESTATUS_SUCCESS && pTemp != NULL && pTemp[0] ) {
            while ( *pTemp && L' ' == *pTemp ) {
                pTemp++;
            }

            if ( SCE_ENGINE_SAP == ProfileType ) {
                if ( !(*pTemp) ) {
                    // this is an not analyzed item
                    pGroup->Status = SCE_GROUP_STATUS_NOT_ANALYZED |
                                     SCE_INTERNAL_NP;

                    break;
                } else if ( _wcsicmp(SCE_ERROR_STRING, pTemp) == 0 ) {
                    // this is error item
                    pGroup->Status = SCE_GROUP_STATUS_ERROR_ANALYZED |
                                     SCE_INTERNAL_NP;

                    break;
                }
            }

            if ( !(*pTemp) ) {
                // empty string is not allowed
                break;
            }

            Len = wcslen(pTemp);

            if ( ValueType != 0 && ValueType != 1 ) {
#if 0
                //
                // privilege with optional via group name
                //
                Status = (*((CHAR *)pTemp)-'0')*10 + ((*((CHAR *)pTemp+1)) - '0');

                PWSTR strName=NULL;
                DWORD strLen=0;

                if ( pTemp[1] == L'*' ) {
                    //
                    // convert the SID string into name format
                    //
                    PSID pSid=NULL;

                    if ( ConvertStringSidToSid( pTemp+2, &pSid) ) {

                        rc = RtlNtStatusToDosError(
                                 ScepConvertSidToName(
                                        LsaPolicy,
                                        pSid,
                                        TRUE,       // want domain\account format
                                        &strName,
                                        &strLen
                                        ));
                        LocalFree(pSid);
                        pSid = NULL;

                    } else {
                        rc = GetLastError();
                    }
                }

                if ( ERROR_SUCCESS == rc  && strName ) {
                    rc = ScepAddToNameStatusList(&(pGroup->pPrivilegesHeld),
                                                 strName,
                                                 strLen,
                                                 Status);
                } else {
                    //
                    // if failed to convert, or it's a name format already
                    // just add it to the list
                    //
                    rc = ScepAddToNameStatusList(&(pGroup->pPrivilegesHeld),
                                                 pTemp+1, Len-1, Status);
                }

                if ( strName ) {
                    ScepFree(strName);
                    strName = NULL;
                }
#endif
            } else {
                //
                // members (0) of memberof (1)
                //
                if ( pTemp[0] == L'*' ) {
                    //
                    // *SID format, convert to name, and add to the list
                    //
                    rc = ScepLookupSidStringAndAddToNameList(LsaPolicy,
                                                             (ValueType == 0) ?
                                                               &(pGroup->pMembers):
                                                               &(pGroup->pMemberOf),
                                                             pTemp, // +1,
                                                             Len    // -1
                                                            );

                } else {

                    rc = ScepAddToNameList((ValueType == 0) ?
                                              &(pGroup->pMembers):
                                              &(pGroup->pMemberOf),
                                            pTemp,
                                            Len );
                }
            }

#ifdef SCE_DBG
            wprintf(L"Add %s to group list\n", pTemp);
#endif
            pTemp += Len +1;
        }

        //
        // Free memory
        //
        if ( rc != SCESTATUS_SUCCESS && pGroup != *pGroupMembership ) {

            pGroup->Next = NULL;
            ScepFreeGroupMembership( pGroup );
            goto Done;
        }

        switch ( ValueType ) {
        case 0: // members
            pGroup->Status &= ~SCE_GROUP_STATUS_NC_MEMBERS;
            break;
        case 1:
            pGroup->Status &= ~SCE_GROUP_STATUS_NC_MEMBEROF;
            break;
        }
        *pGroupMembership = pGroup;

NextLine:

        ScepFree(GroupName);
        GroupName = NULL;

        ScepFree(Value);
        Value = NULL;

        //
        // read next line
        //
        rc = SceJetGetValue(
                    hSection,
                    SCEJET_NEXT_LINE,
                    NULL,
                    NULL,
                    0,
                    &GroupLen,
                    NULL,
                    0,
                    &ValueLen
                    );
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

Done:

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    if ( GroupName != NULL )
        ScepFree(GroupName);

    if ( Value != NULL )
        ScepFree(Value);

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    return(rc);

}


SCESTATUS
ScepOpenSectionForName(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    IN PCWSTR     SectionName,
    OUT PSCESECTION *phSection
    )
{
    SCESTATUS      rc;
    DOUBLE        SectionID;
    SCEJET_TABLE_TYPE  tblType;

    //
    // table type
    //
    switch ( ProfileType ) {
    case SCE_ENGINE_SCP:
    case SCE_ENGINE_SCP_INTERNAL:
        tblType = SCEJET_TABLE_SCP;
        break;

    case SCE_ENGINE_SMP:
    case SCE_ENGINE_SMP_INTERNAL:
        tblType = SCEJET_TABLE_SMP;
        break;

    case SCE_ENGINE_SAP:
        tblType = SCEJET_TABLE_SAP;
        break;

    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get section id
    //
    rc = SceJetGetSectionIDByName(
                hProfile,
                SectionName,
                &SectionID
                );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetOpenSection(
                hProfile,
                SectionID,
                tblType,
                phSection
                );
    return(rc);

}


SCESTATUS
ScepGetDsRoot(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
DS object root has only one entry, which is the DS domain name
So the list contains only one entry.
The format of the DS domain name is dc=<domain>,dc=<domain1>,...o=internet,
which is the DNS name of the DS domain in LDAP format

*/
{
    SCESTATUS rc;
    PSCESECTION hSection=NULL;
    PSCE_OBJECT_LIST pDsRoot=NULL;
    PWSTR JetName=NULL;
    BOOL IsContainer, LastOne;
    DWORD Count, ValueLen;
    BYTE Status;
    WCHAR         StatusFlag=L'\0';


    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            SectionName,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_OPEN,
                             SectionName
                           );
        return(rc);
    }

    rc = ScepLdapOpen(NULL);

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = ScepEnumerateDsObjectRoots(
                    NULL,
                    &pDsRoot
                    );
        ScepLdapClose(NULL);
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( pDsRoot == NULL ) {
            rc = SCESTATUS_PROFILE_NOT_FOUND;

        } else {
            //
            // Convert domain root
            //
            rc = ScepConvertLdapToJetIndexName(
                    pDsRoot->Name,
                    &JetName
                    );
        }
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // goto the line matching the domain root
        //
        rc = SceJetSeek(
                hSection,
                JetName,
                wcslen(JetName)*sizeof(WCHAR),
                SCEJET_SEEK_GE
                );

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            if ( ProfileType == SCE_ENGINE_SAP ) {
                //
                // the domain is not in the table, try another one
                //
                SceJetCloseSection(&hSection, FALSE);

                rc = ScepOpenSectionForName(
                        hProfile,
                        SCE_ENGINE_SCP,  // SCE_ENGINE_SMP,
                        SectionName,
                        &hSection
                        );
                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // get count under the domain
                    //
                    Count = 0;
                    rc = SceJetGetLineCount(
                                    hSection,
                                    JetName,
                                    FALSE,
                                    &Count);

                    if ( rc == SCESTATUS_SUCCESS  ||
                         rc == SCESTATUS_RECORD_NOT_FOUND ) {

                        if ( rc == SCESTATUS_SUCCESS )
                            pDsRoot->Status = SCE_STATUS_CHECK;
                        else
                            pDsRoot->Status = SCE_STATUS_NOT_CONFIGURED;
                        pDsRoot->IsContainer = TRUE;
                        pDsRoot->Count = Count;

                        *pObjectRoots = pDsRoot;
                        pDsRoot = NULL;

                        rc = SCESTATUS_SUCCESS;
                    }

                }
            }
            rc = SCESTATUS_SUCCESS;

        } else if ( rc == SCESTATUS_SUCCESS ) {
            //
            // something of the domain exist, get value and count of the domain
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_EXACT_MATCH,
                        JetName,
                        NULL,
                        0,
                        NULL,
                        (PWSTR)&StatusFlag,   // two bytes buffer
                        2,
                        &ValueLen
                        );

            if ( rc == SCESTATUS_SUCCESS ||
                 rc == SCESTATUS_BUFFER_TOO_SMALL ||
                 rc == SCESTATUS_RECORD_NOT_FOUND ) {

                if ( rc != SCESTATUS_RECORD_NOT_FOUND ) {
                    LastOne = TRUE;
                    Status = *((BYTE *)&StatusFlag);
                    IsContainer = *((CHAR *)&StatusFlag+1) != '0' ? TRUE : FALSE;

                } else {
                    LastOne = FALSE;
                    IsContainer = TRUE;
                    if ( ProfileType == SCE_ENGINE_SAP )
                        Status = SCE_STATUS_GOOD;
                    else
                        Status = SCE_STATUS_CHECK;
                }
                //
                // get count under the domain
                //
                rc = SceJetGetLineCount(
                                hSection,
                                JetName,
                                FALSE,
                                &Count);

                if ( rc == SCESTATUS_SUCCESS ) {

                    if ( LastOne )
                        Count--;

                    if ( !IsContainer && Count > 0 ) {
                        IsContainer = TRUE;
                    }

                    //
                    // the proper domain name is in pDsRoot
                    //
                    pDsRoot->Status = Status;
                    pDsRoot->IsContainer = IsContainer;
                    pDsRoot->Count = Count;

                    *pObjectRoots = pDsRoot;
                    pDsRoot = NULL;
                }

            }

        }
        if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
            rc = SCESTATUS_SUCCESS;
        }
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc),
                             Errlog, SCEERR_QUERY_INFO,
                             L"SCP/SMP");
        }

        if ( JetName != NULL ) {
            ScepFree(JetName);
        }

    } else {
        ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc),
                             Errlog, SCEERR_QUERY_INFO,
                             SectionName);
    }

    ScepFreeObjectList(pDsRoot);

    SceJetCloseSection(&hSection, TRUE);

    return(rc);
}


SCESTATUS
ScepGetObjectList(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves registry or files security information from the JET
   database for the root only. To get detail under a root object, call
   ScepGetChildrentObject.

   For Profiletype "SCE_ENGINE_SAP" (analysis info), a combination of SMP and SAP
   are returned for a complete set of "analyzed" objects.

Arguments:

   hProfile     - the profile handle context

   ProfileType  - value to indicate engine type.
                      SCE_ENGINE_SCP
                      SCE_ENGINE_SAP
                      SCE_ENGINE_SMP

   SectionName   - The section name for the objects to retrieve.

   pObjectRoots  - The output list of object roots

   Errlog   - the cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */

{
    SCESTATUS rc;
    PSCE_OBJECT_LIST pTempList=NULL,
                    pNode;

    //
    // get roots from the first table first
    //
    rc = ScepGetObjectFromOneTable(
                hProfile,
                ProfileType,
                SectionName,
                pObjectRoots,
                Errlog
                );
    //
    // Ds objects only return the domain name, no need to search SMP
    //
    if ( rc == SCESTATUS_SUCCESS && ProfileType == SCE_ENGINE_SAP ) {
        //
        // get the stuff from SMP
        //
        rc = ScepGetObjectFromOneTable(
                    hProfile,
                    SCE_ENGINE_SCP,  // SCE_ENGINE_SMP,
                    SectionName,
                    &pTempList,
                    Errlog
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // add non-exist nodes to pObjectRoots
            //
            for ( pNode=pTempList; pNode != NULL; pNode = pNode->Next ) {

                //
                // if this node does not exist in the SAP
                // this node is analyzed with "match" status and
                // no bad children under the node
                // duplication is prevented by the last argument
                //
                rc = ScepAddToObjectList(pObjectRoots, pNode->Name, 0,
                                        pNode->IsContainer, SCE_STATUS_GOOD, 0, SCE_CHECK_DUP);

                if ( rc != ERROR_SUCCESS ) {
                    ScepBuildErrorLogInfo( rc,
                                     Errlog,
                                     SCEERR_ADD,
                                     pNode->Name
                                   );
                    //
                    // only the following two errors could be returned
                    //
                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        break;
                    } else
                        rc = SCESTATUS_INVALID_PARAMETER;
                }

            }

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            rc = SCESTATUS_SUCCESS;

        } else {
            //
            // pObjectRoots will be freed outside
            //
        }

        if ( pTempList ) {
            ScepFreeObjectList(pTempList);

        }

    }

    return(rc);
}


SCESTATUS
ScepGetObjectFromOneTable(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    IN PCWSTR      SectionName,
    OUT PSCE_OBJECT_LIST *pObjectRoots,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

   This routine retrieves registry or files security information from the JET
   database for the root only. To get detail under a root object, call
   ScepGetChildrentObject.

Arguments:

   hProfile     - the profile handle context

   ProfileType  - value to indicate engine type.
                      SCE_ENGINE_SCP
                      SCE_ENGINE_SAP
                      SCE_ENGINE_SMP

   SectionName   - The section name for the objects to retrieve.

   pObjectRoots  - The output list of object roots

   Errlog   - the cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{

    SCESTATUS      rc;
    PSCESECTION    hSection=NULL;
    DWORD         ObjectLen=0;
    WCHAR         ObjectName[21];
    WCHAR         StatusFlag=L'\0';
    BYTE          Status=0;
    BOOL          IsContainer=TRUE;
    DWORD         Len, Count;
    WCHAR         Buffer[21];
    BOOL          LastOne;
    DWORD         ValueLen=0;


    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            SectionName,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_OPEN,
                             SectionName
                           );
        return(rc);
    }

    //
    // goto the first line of this section
    //
    rc = SceJetSeek(
                hSection,
                NULL,
                0,
                SCEJET_SEEK_GE
                );

    while ( rc == SCESTATUS_SUCCESS ||
            rc == SCESTATUS_BUFFER_TOO_SMALL ) {

        memset(ObjectName, '\0', 21*sizeof(WCHAR));
        memset(Buffer, '\0', 21*sizeof(WCHAR));

        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    ObjectName,
                    20*sizeof(WCHAR),
                    &ObjectLen,
                    (PWSTR)&StatusFlag,   // two bytes buffer
                    2,
                    &ValueLen
                    );
#ifdef SCE_DBG
    wprintf(L"ObjectLen=%d, StatusFlag=%x, ValueLen=%d, rc=%d, ObjectName=%s \n",
             ObjectLen, StatusFlag, ValueLen, rc, ObjectName);
#endif
        if ( rc != SCESTATUS_SUCCESS && rc != SCESTATUS_BUFFER_TOO_SMALL ) {
            ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                 Errlog,
                                 SCEERR_QUERY_VALUE,
                                 SectionName
                               );
            break;
        }
        //
        // get first component of the object
        //
        if ( ObjectLen <= 40 )
            ObjectName[ObjectLen/sizeof(WCHAR)] = L'\0';

        rc = ScepGetNameInLevel(
                    ObjectName,
                    1,
                    L'\\',
                    Buffer,
                    &LastOne
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            Len = wcslen(Buffer);

            if ( LastOne ) {

                Status = *((BYTE *)&StatusFlag);
                IsContainer = *((CHAR *)&StatusFlag+1) != '0' ? TRUE : FALSE;

            } else {
                IsContainer = TRUE;
                if ( ProfileType == SCE_ENGINE_SAP )
                    Status = SCE_STATUS_GOOD;
                else
                    Status = SCE_STATUS_CHECK;
            }

#ifdef SCE_DBG
        printf("\nStatus=%d, StatusFlag=%x, Len=%d, Buffer=%ws\n", Status, StatusFlag, Len, Buffer);
#endif
            //
            // get count of this object
            //
            rc = SceJetGetLineCount(
                            hSection,
                            Buffer,
                            FALSE,
                            &Count);

            if ( rc == SCESTATUS_SUCCESS  ||
                 rc == SCESTATUS_RECORD_NOT_FOUND ) {

                if ( LastOne )
                    Count--;

                if ( !IsContainer && Count > 0 ) {
                    IsContainer = TRUE;
                }

                //
                // the root of registry and file are always upper cased
                //
                _wcsupr(Buffer);

                rc = ScepAddToObjectList(pObjectRoots, Buffer, Len,
                                        IsContainer, Status, Count, 0);

                if ( rc != ERROR_SUCCESS ) {
                    ScepBuildErrorLogInfo( rc,
                                     Errlog,
                                     SCEERR_ADD,
                                     Buffer
                                   );
                    // only the following two errors could be returned
                    if ( rc == ERROR_NOT_ENOUGH_MEMORY )
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    else
                        rc = SCESTATUS_INVALID_PARAMETER;
                }
            }

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // seek to the next one
                //
                Buffer[Len-1] = (WCHAR)( Buffer[Len-1] + 1);

                rc = SceJetSeek(
                    hSection,
                    Buffer,
                    Len*sizeof(TCHAR),
                    SCEJET_SEEK_GT_NO_CASE
                    );

                if ( rc != SCESTATUS_SUCCESS && rc != SCESTATUS_RECORD_NOT_FOUND )
                    ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                         Errlog,
                                         SCEERR_QUERY_VALUE,
                                         SectionName
                                       );

            }
        }
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    return(rc);

}


SCESTATUS
ScepGetAuditing(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   OUT PSCE_PROFILE_INFO pProfileInfo,
   OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
   )
/* ++
Routine Description:

   This routine retrieves system auditing information from the JET database
   and stores in the output buffer pProfileInfo. The auditing information
   is stored in [System Log], [Security Log], [Application Log], [Audit Event],
   [Audit Registry], and [Audit File] sections.

Arguments:

   hProfile - the profile handle context

   pProfileInfo  - the output buffer to hold profile info.

   Errlog   - The cummulative error list to hold errors encountered in this routine.

Return value:

   SCESTATUS - SCESTATUS_SUCCESS
              SCESTATUS_NOT_ENOUGH_RESOURCE
              SCESTATUS_INVALID_PARAMETER
              SCESTATUS_BAD_FORMAT
              SCESTATUS_INVALID_DATA
-- */
{

    SCESTATUS            rc;
    SCE_KEY_LOOKUP       LogKeys[]={
        {(PWSTR)TEXT("MaximumLogSize"),         offsetof(struct _SCE_PROFILE_INFO, MaximumLogSize),          'D'},
        {(PWSTR)TEXT("AuditLogRetentionPeriod"),offsetof(struct _SCE_PROFILE_INFO, AuditLogRetentionPeriod), 'D'},
        {(PWSTR)TEXT("RetentionDays"),          offsetof(struct _SCE_PROFILE_INFO, RetentionDays),           'D'},
        {(PWSTR)TEXT("RestrictGuestAccess"),    offsetof(struct _SCE_PROFILE_INFO, RestrictGuestAccess),     'D'}
        };

    SCE_KEY_LOOKUP       EventKeys[]={
        {(PWSTR)TEXT("AuditSystemEvents"),  offsetof(struct _SCE_PROFILE_INFO, AuditSystemEvents),   'D'},
        {(PWSTR)TEXT("AuditLogonEvents"),   offsetof(struct _SCE_PROFILE_INFO, AuditLogonEvents),    'D'},
        {(PWSTR)TEXT("AuditObjectAccess"),  offsetof(struct _SCE_PROFILE_INFO, AuditObjectAccess),   'D'},
        {(PWSTR)TEXT("AuditPrivilegeUse"),  offsetof(struct _SCE_PROFILE_INFO, AuditPrivilegeUse),   'D'},
        {(PWSTR)TEXT("AuditPolicyChange"),  offsetof(struct _SCE_PROFILE_INFO, AuditPolicyChange),   'D'},
        {(PWSTR)TEXT("AuditAccountManage"), offsetof(struct _SCE_PROFILE_INFO, AuditAccountManage),  'D'},
        {(PWSTR)TEXT("AuditProcessTracking"),offsetof(struct _SCE_PROFILE_INFO, AuditProcessTracking),'D'},
        {(PWSTR)TEXT("AuditDSAccess"),      offsetof(struct _SCE_PROFILE_INFO, AuditDSAccess),       'D'},
        {(PWSTR)TEXT("AuditAccountLogon"),  offsetof(struct _SCE_PROFILE_INFO, AuditAccountLogon),   'D'}};

    DWORD cKeys = sizeof(EventKeys) / sizeof(SCE_KEY_LOOKUP);

    PCWSTR              szAuditLog;
    DWORD               i, j;
    PSCESECTION          hSection=NULL;


    if ( hProfile == NULL ||
         pProfileInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }


    for ( i=0; i<3; i++) {

        //
        // Get Event Log setting for system log, security log and application log
        //

        switch (i) {
        case 0:
            szAuditLog = szAuditSystemLog;
            break;
        case 1:
            szAuditLog = szAuditSecurityLog;
            break;
        default:
            szAuditLog = szAuditApplicationLog;
            break;
        }

        //
        // get DWORD values for the section
        //
        rc = ScepGetFixValueSection(
                   hProfile,
                   szAuditLog,
                   LogKeys,
                   4,
                   ProfileType,
                   (PVOID)pProfileInfo,
                   &hSection,
                   Errlog
                   );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

        // close the section
        SceJetCloseSection( &hSection, FALSE );

        //
        // update the Offset for next section
        //
        for ( j=0; j<4; j++ )
            LogKeys[j].Offset += sizeof(DWORD);
    }

    //
    // Get Audit Event info
    //
    //
    // get DWORD values for the section
    //
    rc = ScepGetFixValueSection(
               hProfile,
               szAuditEvent,
               EventKeys,
               cKeys,
               ProfileType,
               (PVOID)pProfileInfo,
               &hSection,
               Errlog
               );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    // close the section
    SceJetCloseSection( &hSection, TRUE );

Done:

    // close the section
    if ( rc != SCESTATUS_SUCCESS )
        SceJetCloseSection( &hSection, TRUE );

    return(rc);
}

//////////////////////////////
// helper APIs
//////////////////////////////

SCESTATUS
ScepGetUserSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR Name,
    OUT PVOID *ppInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Function Description:

    This routine get a dynamic section's information for a security area.
    Dynamic sections are those created dynamically, based on other sections'
    related information. Dynamic sections in a profile include User Security
    Profiles for SCP and User Settings for SAP/SMP. Name contains the section's
    identifier, either the section's name, or a partial name (e.g., a user
    name) for the section. The output must be casted to different structure,
    depending on the ProfileType and Area.

    The output buffer contains one instance of the requested information,
    e.g., one user security profile or one user's setting. To get all dynamic
    sections, this routine must be called repeatly. The output buffer must
    be freed by LocalFree after its use.

Arguments:

    hProfile    - The handle of the profile

    ProfileType - The type of the profile to read

    Name        - The dynamic section's identifier

    ppInfo      - Output buffer (PSCE_USER_PROFILE or PSCE_USER_SETTING)

    Errlog      - The error log buffer

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_BAD_FORMAT
    SCESTATUS_INVALID_DATA

-- */

{
    //
    // not support area
    // if need this area later, refer to usersav directory for archived code
    //
    return(SCESTATUS_SERVICE_NOT_SUPPORT);

}


SCESTATUS
ScepGetObjectChildren(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    IN SCE_SUBOBJECT_TYPE Option,
    OUT PVOID *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
Routine Description

    This routine is the same as ScepGetObjectChildrenFromOneTable, except when
    ProfileType is SCE_ENGINE_SAP, in which case, object children in SMP is also
    looked up and returned so the returned list contains the complete set of
    the objects analyzed.

Arguments:

    See ScepGetObjectChildrenFromOneTable

Return Value:

    See ScepGetObjectChildrenFromOneTable
*/
{
    SCESTATUS rc;

    rc = ScepGetObjectChildrenFromOneTable(
                      hProfile,
                      ProfileType,
                      Area,
                      ObjectPrefix,
                      Option,
                      Buffer,
                      Errlog
                      );

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        rc = SCESTATUS_SUCCESS;
    }

    if ( rc == SCESTATUS_SERVICE_NOT_SUPPORT &&
         ProfileType == SCE_ENGINE_SAP &&
         Option == SCE_IMMEDIATE_CHILDREN ) {

        return( SCESTATUS_RECORD_NOT_FOUND);  // no acl support, do not allow children
    }

    if ( rc == SCESTATUS_SUCCESS &&
         ProfileType == SCE_ENGINE_SAP &&
         Option == SCE_IMMEDIATE_CHILDREN ) {

        PSCE_OBJECT_CHILDREN pTempList=NULL;
        PSCE_OBJECT_CHILDREN_NODE *pArrObject=NULL;
        DWORD arrCount=0, MaxCount=0;
        LONG FindIndex;

        if ( *Buffer ) {
            arrCount = ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount;
            MaxCount = ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount;
            pArrObject = &(((PSCE_OBJECT_CHILDREN)(*Buffer))->arrObject);
        }

        //
        // get object children from SMP table too
        //
        rc = ScepGetObjectChildrenFromOneTable(
                          hProfile,
                          SCE_ENGINE_SCP,  //SCE_ENGINE_SMP,
                          Area,
                          ObjectPrefix,
                          Option,
                          (PVOID *)(&pTempList),
                          Errlog
                          );

        if ( rc == SCESTATUS_SUCCESS && pTempList ) {
            //
            // add non-exist nodes to Buffer
            //
            DWORD i;
            PSCE_OBJECT_CHILDREN_NODE *pTmpObject= &(pTempList->arrObject);

            for ( i=0; i<pTempList->nCount; i++ ) {

                //
                // if this node does not exist in the SAP
                // this node is analyzed with "match" status and
                // no bad children under the node
                // duplication is prevented by the last argument
                //
                if ( pTmpObject[i] == NULL ||
                     pTmpObject[i]->Name == NULL ) {
                    continue;
                }

                FindIndex = -1;
                pTmpObject[i]->Status = SCE_STATUS_GOOD;

                rc = ScepAddItemToChildren(
                            pTmpObject[i],
                            pTmpObject[i]->Name,
                            0,
                            pTmpObject[i]->IsContainer,
                            pTmpObject[i]->Status,
                            pTmpObject[i]->Count,
                            &pArrObject,
                            &arrCount,
                            &MaxCount,
                            &FindIndex
                            );

                if ( rc == ERROR_SUCCESS ) {
                    //
                    // successfully added
                    //
                    pTmpObject[i] = NULL;
                } else if ( rc == ERROR_DUP_NAME ) {
                    //
                    // node already exist, ignore the error
                    //
                    rc = ERROR_SUCCESS;

                } else {
                    ScepBuildErrorLogInfo( rc,
                                     Errlog,
                                     SCEERR_ADD,
                                     pTmpObject[i]->Name
                                   );
                    //
                    // only the following two errors could be returned
                    //
                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        break;
                    } else
                        rc = SCESTATUS_INVALID_PARAMETER;
                }

            }

        } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

            rc = SCESTATUS_SUCCESS;

        }

        if ( pTempList ) {
            ScepFreeObjectChildren(pTempList);
        }

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // detect if status of this container or any of its "immediate" parent
            // is in "auto-inherit" status. If so, query from the system to
            // get good items.
            //

            BYTE ParentStatus = ScepGetObjectStatusFlag(
                                           hProfile,
                                           SCE_ENGINE_SCP,   //SCE_ENGINE_SMP,
                                           Area,
                                           ObjectPrefix,
                                           TRUE);

            BYTE AnalysisStatus = ScepGetObjectStatusFlag(
                                           hProfile,
                                           SCE_ENGINE_SAP,
                                           Area,
                                           ObjectPrefix,
                                           FALSE);
            //
            // compute the status to be used for all enumerated objects
            //
            BYTE NewStatus;

            if ( AnalysisStatus == SCE_STATUS_ERROR_NOT_AVAILABLE ||
                 AnalysisStatus == SCE_STATUS_NOT_ANALYZED ) {

                NewStatus = SCE_STATUS_NOT_ANALYZED;

            } else if ( ParentStatus == SCE_STATUS_OVERWRITE ) {

                NewStatus = SCE_STATUS_GOOD;
            } else {
                NewStatus = SCE_STATUS_NOT_CONFIGURED;
            }

            //
            // even though there is no parent in SMP, still return all objects
            //
//            if ( (BYTE)-1 != ParentStatus ) {

                // if any child is found for this level
                // get the remaining "good" status nodes from system
                //

                PWSTR           WildCard=NULL;
                DWORD           BufSize;

                switch ( Area ) {
                case AREA_FILE_SECURITY:

                    struct _wfinddata_t FileInfo;
                    intptr_t            hFile;
                    BOOL            BackSlashExist;

                    BufSize = wcslen(ObjectPrefix)+4;
                    WildCard = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                    if ( !WildCard ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        break;
                    }
                    BackSlashExist = ScepLastBackSlash(ObjectPrefix);
                    if ( BackSlashExist )
                        swprintf(WildCard, L"%s*.*", ObjectPrefix);
                    else
                        swprintf(WildCard, L"%s\\*.*", ObjectPrefix);

                    hFile = _wfindfirst(WildCard, &FileInfo);

                    ScepFree(WildCard);
                    WildCard = NULL;

                    if ( hFile != -1 ) {
                        do {
                            if ( wcscmp(L"..", FileInfo.name) == 0 ||
                                 wcscmp(L".", FileInfo.name) == 0 )
                                continue;

                            FindIndex = -1;

                            rc = ScepAddItemToChildren(
                                        NULL,
                                        FileInfo.name,
                                        0,
                                        (FileInfo.attrib & _A_SUBDIR) ? TRUE : FALSE,
                                        NewStatus,
                                        0,
                                        &pArrObject,
                                        &arrCount,
                                        &MaxCount,
                                        &FindIndex
                                        );

                            if ( rc == ERROR_DUP_NAME ) {
                                rc = ERROR_SUCCESS;
                            } else if ( rc != ERROR_SUCCESS ) {
                                ScepBuildErrorLogInfo( rc,
                                                 Errlog,
                                                 SCEERR_ADD,
                                                 FileInfo.name
                                               );
                                //
                                // only the following two errors could be returned
                                //
                                if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                    break;
                                } else
                                    rc = SCESTATUS_INVALID_PARAMETER;
                            }

                        } while ( _wfindnext(hFile, &FileInfo) == 0 );

                        _findclose(hFile);
                    }

                    break;
                case AREA_REGISTRY_SECURITY:

                    HKEY            hKey;
                    DWORD           index;
                    DWORD           EnumRc;
                    //
                    // open the key (on a 64-bit platform, 64-bit
                    // registry only will be done if SCE_ENGINE_SAP)
                    //
                    rc = ScepOpenRegistryObject(
                                SE_REGISTRY_KEY,
                                ObjectPrefix,
                                KEY_READ,
                                &hKey
                                );

                    if ( rc == ERROR_SUCCESS ) {
                        index = 0;
                        //
                        // enumerate all subkeys of the key
                        //
                        do {
                            WildCard = (PWSTR)ScepAlloc(LMEM_ZEROINIT, MAX_PATH*sizeof(WCHAR));
                            if ( WildCard == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                break;
                            }
                            BufSize = MAX_PATH;

                            EnumRc = RegEnumKeyEx(hKey,
                                            index,
                                            WildCard,
                                            &BufSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);

                            if ( EnumRc == ERROR_SUCCESS ) {
                                index++;
                                //
                                // add the name to the object list
                                //
                                FindIndex = -1;
                                rc = ScepAddItemToChildren(
                                            NULL,
                                            WildCard,
                                            BufSize,
                                            TRUE,
                                            NewStatus,
                                            0,
                                            &pArrObject,
                                            &arrCount,
                                            &MaxCount,
                                            &FindIndex
                                            );

                                if ( rc == ERROR_DUP_NAME ) {
                                    rc = ERROR_SUCCESS;
                                } else if ( rc != ERROR_SUCCESS ) {
                                    ScepBuildErrorLogInfo( rc,
                                                     Errlog,
                                                     SCEERR_ADD,
                                                     WildCard
                                                   );
                                    //
                                    // only the following two errors could be returned
                                    //
                                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                        break;
                                    } else
                                        rc = SCESTATUS_INVALID_PARAMETER;
                                }
                            }

                            ScepFree(WildCard);
                            WildCard = NULL;

                        } while ( EnumRc != ERROR_NO_MORE_ITEMS );

                        RegCloseKey(hKey);

                    } else {
                        rc = ScepDosErrorToSceStatus(rc);
                    }

                    break;
#if 0
                case AREA_DS_OBJECTS:

                    PSCE_NAME_LIST  pTemp, pList=NULL;

                    rc = ScepLdapOpen(NULL);

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // detect if the Ds object exist
                        //
                        rc = ScepDsObjectExist(ObjectPrefix);

                        if ( rc == SCESTATUS_SUCCESS ) {

                            rc = ScepEnumerateDsOneLevel(ObjectPrefix, &pList);
                            //
                            // add each one to the object list
                            //
                            for (pTemp=pList; pTemp != NULL; pTemp = pTemp->Next ) {
                                //
                                // look for the first ldap component
                                //
                                WildCard = wcschr(pTemp->Name, L',');
                                if ( WildCard ) {
                                    BufSize = (DWORD)(WildCard - pTemp->Name);
                                } else {
                                    BufSize = 0;
                                }

                                rc = ScepAddItemToChildren(
                                            NULL,
                                            pTemp->Name,
                                            BufSize,
                                            TRUE,
                                            NewStatus,
                                            0,
                                            &pArrObject,
                                            &arrCount,
                                            &MaxCount,
                                            &FindIndex
                                            );

                                if ( rc != ERROR_SUCCESS ) {
                                    ScepBuildErrorLogInfo( rc,
                                                     Errlog,
                                                     SCEERR_ADD,
                                                     pTemp->Name
                                                   );
                                    //
                                    // only the following two errors could be returned
                                    //
                                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                        break;
                                    } else
                                        rc = SCESTATUS_INVALID_PARAMETER;
                                }
                            }
                            if ( pList ) {
                                //
                                // free the list
                                //
                                ScepFreeNameList(pList);
                            }
                        }
                        ScepLdapClose(NULL);
                    }
                    break;
#endif

                }
                //
                // ignore other errors except out of memory
                //
                if ( rc != SCESTATUS_NOT_ENOUGH_RESOURCE ) {
                    rc = SCESTATUS_SUCCESS;
                }
//            }

        }
/*
        if ( *Buffer ) {
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount = arrCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount = MaxCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->arrObject = pArrObject;
        }
*/
        if ( pArrObject ) {
            *Buffer = (PVOID)((PBYTE)pArrObject - 2*sizeof(DWORD));
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount = arrCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount = MaxCount;
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            //
            // free Buffer
            //
            ScepFreeObjectChildren((PSCE_OBJECT_CHILDREN)(*Buffer));
            *Buffer = NULL;
        }
    }

    if ( (SCESTATUS_SUCCESS == rc) &&
         (*Buffer == NULL) ) {
        //
        // get nothing
        //
        rc = SCESTATUS_RECORD_NOT_FOUND;
    }

    return(rc);
}


BYTE
ScepGetObjectStatusFlag(
   IN PSCECONTEXT hProfile,
   IN SCETYPE ProfileType,
   IN AREA_INFORMATION Area,
   IN PWSTR ObjectPrefix,
   IN BOOL bLookForParent
   )
/*
Routine Description:

    To find the status for the closest parent  node (immediate/non immediate)
    for the Object in the table.

Arguments:

    hProfile - the databaes handle

    ProfileType - the table type

    Area - the area information

    ObjectPrefix - the object's full name

Return Value:

    Byte - the status flag for the nearest parent if one is found

*/
{
    LPCTSTR SectionName;
    PSCESECTION hSection=NULL;
    WCHAR Delim;
    BYTE Status=(BYTE)-1;

    SCESTATUS rc;
    PWSTR JetName=NULL;


    switch ( Area) {
    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        JetName = ObjectPrefix;
        Delim = L'\\';
        break;
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        JetName = ObjectPrefix;
        Delim = L'\\';
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        Delim = L',';
        rc = ScepConvertLdapToJetIndexName(
                ObjectPrefix,
                &JetName
                );
        if ( rc != SCESTATUS_SUCCESS ) {
            return (BYTE)-1;
        }
        break;
#endif
    default:
        return (BYTE)-1;
    }

    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            SectionName,
            &hSection
            );
    if ( SCESTATUS_SUCCESS == rc ) {

        Status = ScepGetObjectAnalysisStatus(hSection,
                                             JetName,
                                             bLookForParent
                                            );
    }

    SceJetCloseSection(&hSection, TRUE);

    if ( JetName != ObjectPrefix ) {
        ScepFree(JetName);
    }

    if ( SCESTATUS_SUCCESS == rc ) {
        return Status;
    }

    return (BYTE)-1;
}

SCESTATUS
ScepGetObjectChildrenFromOneTable(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    IN SCE_SUBOBJECT_TYPE Option,
    OUT PVOID *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

    This routine is used for Registry and File Security ONLY.

    This routine takes a object prefix ( e.g., a parent nodes full path name)
    and outputs all files and sub directories under the object, or the immediate
    children under the object, based on Option. When all files and sub
    directories are outputted, the output information is in a n-tree structure
    (SCE_OBJECT_TREE). If only the immediate children are outputted, the
    output information is in a list structure (SCE_OBJECT_CHILDREN). The output buffer
    must be freed by LocalFree after its use.

Arguments:

    hProfile    - The handle to the profile

    ProifleType - The type of the profile to read

    Area        - The security area to read info
                    AREA_REGISTRY_SECURITY
                    AREA_FILE_SECURITY

    ObjectPrefix- The parent nodes full path name (e.g., c:\winnt)

    Option      - The option for output information. Valid values are
                    SCE_ALL_CHILDREN
                    SCE_IMMEDIATE_CHILDREN

    Buffer      - The output buffer.

    Errlog      - The error log buffer.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_BAD_FORMAT
    SCESTATUS_INVALID_DATA
-- */
{
    SCESTATUS       rc = SCESTATUS_SUCCESS;
    PCWSTR          SectionName=NULL;
    PWSTR           JetName;
    WCHAR           Delim=L'\\';


    if ( ObjectPrefix == NULL || ObjectPrefix[0] == L'\0' )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( Option == SCE_ALL_CHILDREN &&
         ProfileType == SCE_ENGINE_SAP )
        return(SCESTATUS_INVALID_PARAMETER);


    switch (Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        JetName = ObjectPrefix;
        break;

    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        JetName = ObjectPrefix;

        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        Delim = L',';

        rc = ScepConvertLdapToJetIndexName(
                ObjectPrefix,
                &JetName
                );
        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
        *Buffer = NULL;
        break;
#endif

    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD           PrefixLen;
    PWSTR           NewPrefix;
    PWSTR           ObjectName=NULL;
    PWSTR           Value=NULL;
    DWORD           ObjectLen, ValueLen;
    PWSTR           Buffer1=NULL;

    //
    // make a new prefix to force a Delim at the end
    //
    PrefixLen = wcslen(JetName);

    if ( Option != SCE_ALL_CHILDREN ) {

        if ( JetName[PrefixLen-1] != Delim )
            PrefixLen++;

        NewPrefix = (PWSTR)ScepAlloc(0, (PrefixLen+1)*sizeof(WCHAR));

        if ( NewPrefix == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

        } else {
            wcscpy(NewPrefix, JetName);
            NewPrefix[PrefixLen-1] = Delim;
            NewPrefix[PrefixLen] = L'\0';
        }
    } else
        NewPrefix = JetName;

    if ( rc != SCESTATUS_SUCCESS ) {
        if ( Area == AREA_DS_OBJECTS )
            ScepFree(JetName);

        return(rc);
    }

    PSCESECTION      hSection=NULL;
    DWORD            i;
    PSCE_OBJECT_CHILDREN_NODE *pArrObject=NULL;
    DWORD            arrCount=0;
    DWORD            MaxCount=0;
    LONG             LastIndex=-1;
    LONG             FindIndex=-1;

    //
    // open the section
    //
    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( ProfileType == SCE_ENGINE_SAP &&
             Option != SCE_ALL_CHILDREN &&
             PrefixLen > 2 ) {

            //
            // find if this drive support ACL
            //
            WCHAR StatusFlag=L'\0';
            WCHAR SaveChr = NewPrefix[3];

            NewPrefix[3] = L'\0';

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_EXACT_MATCH_NO_CASE,
                        NewPrefix,
                        NULL,
                        0,
                        NULL,
                        (PWSTR)&StatusFlag,   // two bytes buffer
                        2,
                        &i
                        );

            NewPrefix[3] = SaveChr;

            if ( SCESTATUS_SUCCESS == rc ||
                 SCESTATUS_BUFFER_TOO_SMALL == rc ) {

                i = *((BYTE *)&StatusFlag);

                if ( i == (BYTE)SCE_STATUS_NO_ACL_SUPPORT ||
                     i == (DWORD)SCE_STATUS_NO_ACL_SUPPORT ) {

                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                } else {

                    rc = SCESTATUS_SUCCESS;
                }
            } else {
                rc = SCESTATUS_SUCCESS;
            }
        }
    } else {

        ScepBuildErrorLogInfo( ERROR_INVALID_HANDLE,
                            Errlog,
                            SCEERR_OPEN,
                            SectionName
                          );
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        DWORD           Level;
        PWSTR           pTemp;
        DWORD           SDsize=0;

        pTemp = wcschr(JetName, Delim);
        Level=1;
        while ( pTemp ) {
            pTemp++;
            if ( pTemp[0] != 0 )
                Level++;
            pTemp = wcschr(pTemp, Delim);
        }
        Level++;


        if ( Option == SCE_ALL_CHILDREN ) {
            //
            // find the first record in the section
            //
            rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH_NO_CASE,
                JetName,
                NULL,
                0,
                &SDsize,  // temp use for ObjectLen,
                NULL,
                0,
                &i       // temp use for ValueLen
                );
        } else {
            //
            // find the first record matching prefix in the section
            //
            rc = SceJetSeek(
                    hSection,
                    NewPrefix,
                    PrefixLen*sizeof(TCHAR),
                    SCEJET_SEEK_GE_NO_CASE
                    );

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // start the Ldap server
                //
                if ( Area == AREA_DS_OBJECTS) {

                    rc = ScepLdapOpen(NULL);

                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepBuildErrorLogInfo( 0,
                                Errlog,
                                SCEERR_CONVERT_LDAP,
                                L""
                                );
                    }
                }

                if ( rc == SCESTATUS_SUCCESS ) {
                    rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        &SDsize,  // temp use for ObjectLen,
                        NULL,
                        0,
                        &i        // temp use for ValueLen
                        );
                }
            }

        }

        DWORD Count=0;
        BYTE            Status;
        BOOL            IsContainer;
        SCEJET_FIND_TYPE FindFlag;

        while ( rc == SCESTATUS_SUCCESS ) {

            //
            // allocate memory for the group name and value string
            //
            ObjectName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, SDsize+2);  // ObjectLen
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, i+2);  //ValueLen

            if ( ObjectName == NULL || Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;

            }
            //
            // Get the group and its value
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        ObjectName,
                        SDsize,
                        &ObjectLen,
                        Value,
                        i,
                        &ValueLen
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                     Errlog,
                                     SCEERR_QUERY_VALUE,
                                     SectionName
                                   );
                goto Done;
            }

            //
            // teminate the string
            //
            if ( ObjectLen > SDsize )
                ObjectLen = SDsize;
            if ( ValueLen > i )
                ValueLen = i;

            ObjectName[ObjectLen/2] = L'\0';
            Value[ValueLen/2] = L'\0';

            if ( Option == SCE_ALL_CHILDREN ) {
                //
                // add this object to the object tree
                //

                PSECURITY_DESCRIPTOR pTempSD=NULL;
                SECURITY_INFORMATION SeInfo;

                //
                // use i temperatorily
                //
                i = ConvertTextSecurityDescriptor(
                                   Value+1,
                                   &pTempSD,
                                   &SDsize,
                                   &SeInfo
                                   );

                if ( i == NO_ERROR ) {

                    if ( Area != AREA_DS_OBJECTS ) {
                        ScepChangeAclRevision(pTempSD, ACL_REVISION);
                    }

                    Status = *((BYTE *)Value);
                    IsContainer = *((CHAR *)Value+1) != '0' ? TRUE : FALSE;

                    if ( Area == AREA_DS_OBJECTS && *Buffer == NULL ) {
                        //
                        // build the first node separately because the first node
                        // is always the domain name with its DNS name as full name
                        //
                        rc = ScepBuildDsTree(
                                (PSCE_OBJECT_CHILD_LIST *)Buffer,
                                Level-1,
                                Delim,
                                JetName
                                );
                        if ( rc == SCESTATUS_SUCCESS ) {

                            if ( _wcsicmp(ObjectName, JetName) == 0 ) {
                                //
                                // exact match
                                //
                                (*((PSCE_OBJECT_TREE *)Buffer))->IsContainer = IsContainer;
                                (*((PSCE_OBJECT_TREE *)Buffer))->Status = Status;
                                (*((PSCE_OBJECT_TREE *)Buffer))->pSecurityDescriptor = pTempSD;
                                (*((PSCE_OBJECT_TREE *)Buffer))->SeInfo = SeInfo;

                            } else {

                                rc = ScepBuildObjectTree(
                                        NULL,
                                        (PSCE_OBJECT_CHILD_LIST *)Buffer,
                                        Level-1,
                                        Delim,
                                        ObjectName,
                                        IsContainer,
                                        Status,
                                        pTempSD,
                                        SeInfo
                                        );
                            }
                        }

                    } else {

                        rc = ScepBuildObjectTree(
                                NULL,
                                (PSCE_OBJECT_CHILD_LIST *)Buffer,
                                (Area == AREA_DS_OBJECTS) ? Level : 1,
                                Delim,
                                ObjectName,
                                IsContainer,
                                Status,
                                pTempSD,
                                SeInfo
                                );
                    }
                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc),
                                             Errlog,
                                             SCEERR_BUILD_OBJECT
                                           );
                        ScepFree(pTempSD);
                    }

                } else {
                    ScepBuildErrorLogInfo( i,
                                         Errlog,
                                         SCEERR_BUILD_SD,
                                         ObjectName  // Value+1
                                       );
                    rc = ScepDosErrorToSceStatus(i);
                }
                FindFlag = SCEJET_NEXT_LINE;

            } else {

                INT             CompFlag;
                DWORD           ListHeadLen;

                // verify it is within the right range
                CompFlag = _wcsnicmp(ObjectName, NewPrefix, PrefixLen);

                if ( pArrObject != NULL && LastIndex >= 0 && LastIndex < (LONG)arrCount ) {
                    ListHeadLen = wcslen(pArrObject[LastIndex]->Name);

                } else
                    ListHeadLen = 0;

                if ( (CompFlag == 0 && PrefixLen == ObjectLen/2) ||
                     CompFlag < 0 ) {
                    // CompFlag < 0 should be impossible!!!
                    // if it is the exact match with ObjectPrefix, ignore
                    //
                    // Every next level node is returned in the ObjectList
                    // with either
                    //    Count=0 ( no sub children ), or
                    //    Count > 0 && Status=SCE_STATUS_GOOD (this one is good)
                    //                 Status=mismatch/unknown/ignore/check
                    // should not count the object itself
                    //
                    rc = SceJetMoveNext(hSection);

                } else if (CompFlag > 0 ) {

                    rc = SCESTATUS_RECORD_NOT_FOUND;

                } else if (pArrObject != NULL && LastIndex >= 0 && LastIndex < (LONG)arrCount &&
                         PrefixLen+ListHeadLen < ObjectLen/2 &&
                         ObjectName[PrefixLen+ListHeadLen] == Delim &&
                         _wcsnicmp( pArrObject[LastIndex]->Name, ObjectName+PrefixLen,
                                    ListHeadLen ) == 0 ) {
                    //
                    // if the list is not NULL, check the list head (new added item)
                    // to see if the ObjectName is already in. If yes, skip
                    //
                    Buffer1 = (PWSTR)ScepAlloc(0, (ListHeadLen+PrefixLen+2)*sizeof(WCHAR));

                    if ( Buffer1 == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                    } else {

                        swprintf(Buffer1, L"%s%s", NewPrefix, pArrObject[LastIndex]->Name);
                        Buffer1[PrefixLen+ListHeadLen] = (WCHAR) (Delim + 1);
                        Buffer1[PrefixLen+ListHeadLen+1] = L'\0';
                        //
                        // skip the block
                        //
                        rc = SceJetSeek(
                                hSection,
                                Buffer1,
                                (PrefixLen+ListHeadLen+1)*sizeof(TCHAR),
                                SCEJET_SEEK_GE_DONT_CARE  //SCEJET_SEEK_GE_NO_CASE
                                );

                        ScepFree(Buffer1);
                        Buffer1 = NULL;

                    }

                } else {

                    DWORD           Len;
                    BOOL            LastOne;

                    //
                    // searching for the right level component
                    //
                    PWSTR pStart = ObjectName;

                    for ( i=0; i<Level; i++) {

                        pTemp = wcschr(pStart, Delim);

                        if ( i == Level-1 ) {
                            //
                            // find the right level
                            //
                            if ( pTemp == NULL ) {
                                LastOne = TRUE;
                                Len = ObjectLen/2; // wcslen(pStart); from begining
                            } else {
                                Len = (DWORD)(pTemp - ObjectName);  // pStart; from begining
                                if ( *(pTemp+1) == L'\0' )
                                    LastOne = TRUE;
                                else
                                    LastOne = FALSE;
                            }
                            SDsize = (DWORD)(pStart - ObjectName);
                        } else {
                            if ( pTemp == NULL ) {
                                rc = SCESTATUS_INVALID_PARAMETER;
                                break;
                            } else
                                pStart = pTemp + 1;
                        }
                    }

                    if ( rc == SCESTATUS_SUCCESS && Len > SDsize ) {

                        Buffer1 = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));

                        if ( Buffer1 == NULL )
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        else {
                            // wcsncpy(Buffer1, pStart, Len );
                            wcsncpy(Buffer1, ObjectName, Len);

                            Count = 1;

                            if ( LastOne ) {

                                Count = 0;

                                Status = *((BYTE *)Value);
                                IsContainer = *((CHAR *)Value+1) != '0' ? TRUE : FALSE;

                            } else {
                                IsContainer = TRUE;

                                if ( ProfileType == SCE_ENGINE_SAP )
                                    Status = SCE_STATUS_GOOD;
                                else
                                    Status = SCE_STATUS_CHECK;
                            }

                        }
                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                             Errlog,
                                             SCEERR_PROCESS_OBJECT,
                                             ObjectName
                                           );
                    } else if ( Buffer1 != NULL) {
                        //
                        // check to see if Buffer1 is already in the list
                        //

                        i=0;  // temp. use of i for skip flag
                        if ( pArrObject && LastIndex >= 0 && LastIndex < (LONG)arrCount ) {

                            if ( ScepSearchItemInChildren(Buffer1+SDsize,
                                                          Len-SDsize,
                                                          pArrObject,
                                                          arrCount,
                                                          &FindIndex
                                                          )
                                                       ) {

                                //
                                // Buffer1 is already in the list, skip the block
                                // use pStart temporarily
                                //

                                pStart = (PWSTR)ScepAlloc(0, (Len+2)*sizeof(WCHAR));
                                if ( pStart == NULL ) {
                                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                                } else {
                                    //
                                    // skip the block
                                    //

                                    wcscpy(pStart, Buffer1);
                                    pStart[Len] = (WCHAR) ( Delim+1);
                                    pStart[Len+1] = L'\0';

                                    rc = SceJetSeek(
                                            hSection,
                                            pStart,
                                            (Len+1)*sizeof(TCHAR),
                                            SCEJET_SEEK_GE_DONT_CARE  //cannot use GT cause it will skip the section
                                            );

                                    ScepFree(pStart);
                                    pStart = NULL;

                                    i=1;
                                    LastIndex = FindIndex;
                                }
                            }
                        }

                        if ( 0 == i && SCESTATUS_SUCCESS == rc ) {

                            //
                            // get count
                            //
                            pStart = (PWSTR)ScepAlloc(0, (Len+2)*sizeof(WCHAR));
                            if ( pStart == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                            } else {

                                wcscpy(pStart, Buffer1);
                                pStart[Len] = Delim;
                                pStart[Len+1] = L'\0';

                                rc = SceJetGetLineCount(
                                                hSection,
                                                pStart,
                                                FALSE,
                                                &Count);

                                if ( rc == SCESTATUS_SUCCESS  ||
                                     rc == SCESTATUS_RECORD_NOT_FOUND ) {

                                    if ( !IsContainer && Count > 0 ) {
                                        IsContainer = TRUE;
                                    }

                                    //
                                    // make buffer1 approprate case
                                    //
                                    switch (Area) {
                                    case AREA_REGISTRY_SECURITY:
                                        rc = ScepGetRegKeyCase(Buffer1, SDsize, Len-SDsize);
                                        break;
                                    case AREA_FILE_SECURITY:
                                        rc = ScepGetFileCase(Buffer1, SDsize, Len-SDsize);
                                        break;
                                    case AREA_DS_OBJECTS:
                                        //
                                        // need convert name first from o=,dc=,cn= to cn=,dc=,o=
                                        //
                                        pTemp=NULL;
                                        rc = ScepConvertJetNameToLdapCase(
                                                         Buffer1,
                                                         TRUE,  // Last component only
                                                         SCE_CASE_PREFERED, // right case
                                                         &pTemp
                                                         );

                                        if ( rc != ERROR_FILE_NOT_FOUND && pTemp != NULL ) {

                                            rc = ScepAddItemToChildren(NULL,
                                                                       pTemp,
                                                                      wcslen(pTemp),
                                                                      IsContainer,
                                                                      Status,
                                                                      Count,
                                                                      &pArrObject,
                                                                      &arrCount,
                                                                      &MaxCount,
                                                                      &FindIndex
                                                                      );

                                            if ( rc != ERROR_SUCCESS ) {
                                                ScepBuildErrorLogInfo( rc,
                                                                 Errlog,
                                                                 SCEERR_ADD,
                                                                 pTemp
                                                               );
                                            } else {
                                                LastIndex = FindIndex;
                                            }

                                            ScepFree(pTemp);
                                            pTemp = NULL;
                                        }
                                        rc = ScepDosErrorToSceStatus(rc);

                                        break;
                                    }
/*
                                    if ( rc == SCESTATUS_PROFILE_NOT_FOUND ) {
                                        //
                                        // if the object does not exist, do not add
                                        //
                                        rc = SCESTATUS_SUCCESS;

                                    } else if ( Area != AREA_DS_OBJECTS ) {
*/
                                    if ( rc != SCESTATUS_PROFILE_NOT_FOUND &&
                                         Area != AREA_DS_OBJECTS ) {

                                        rc = ScepAddItemToChildren(NULL,
                                                                   Buffer1+SDsize,
                                                                  Len-SDsize,
                                                                  IsContainer,
                                                                  Status,
                                                                  Count,
                                                                  &pArrObject,
                                                                  &arrCount,
                                                                  &MaxCount,
                                                                  &FindIndex
                                                                  );

                                        if ( rc != ERROR_SUCCESS ) {
                                            ScepBuildErrorLogInfo( rc,
                                                             Errlog,
                                                             SCEERR_ADD,
                                                             Buffer1
                                                           );
                                            rc = ScepDosErrorToSceStatus(rc);
                                        } else {
                                            LastIndex = FindIndex;
                                        }
                                    }
                                }

                                if ( rc == SCESTATUS_SUCCESS ) {
                                    //
                                    // seek to the original one
                                    //
        //                            Buffer1[Len-1] = (WCHAR) (Buffer1[Len-1] + 1);
                                    rc = SceJetSeek(
                                            hSection,
                                            Buffer1,
                                            Len*sizeof(TCHAR),
                                            SCEJET_SEEK_GE_NO_CASE
                                            );
                                    //
                                    // should be success, move to next line
                                    //
                                    rc = SceJetMoveNext(hSection);

                                } else if ( rc == SCESTATUS_PROFILE_NOT_FOUND ) {

                                    pStart[Len] = (WCHAR) ( Delim+1);
                                    pStart[Len+1] = L'\0';

                                    rc = SceJetSeek(
                                            hSection,
                                            pStart,
                                            (Len+1)*sizeof(TCHAR),
                                            SCEJET_SEEK_GE_DONT_CARE  //cannot use GT cause it will skip the section
                                            );

                                }

                                ScepFree(pStart);
                                pStart = NULL;

                            }
                        }

                        ScepFree(Buffer1);
                        Buffer1 = NULL;

                    } else
                        rc = SceJetMoveNext(hSection);
                }
                FindFlag = SCEJET_CURRENT;
            }

            ScepFree(ObjectName);
            ObjectName = NULL;

            ScepFree(Value);
            Value = NULL;

            if ( rc != SCESTATUS_SUCCESS )
                break;

            //
            // read next line
            //
            rc = SceJetGetValue(
                        hSection,
                        FindFlag,
                        NULL,
                        NULL,
                        0,
                        &SDsize,  // temp use for ObjectLen
                        NULL,
                        0,
                        &i        // temp use for ValueLen
                        );
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

    }

Done:

    if ( Area == AREA_DS_OBJECTS ) {

        if ( Area == AREA_DS_OBJECTS ) {
            if ( JetName != NULL )
                ScepFree(JetName);
        }

        ScepLdapClose(NULL);
    }

    if ( Option != SCE_ALL_CHILDREN ) {
        ScepFree(NewPrefix);
    }

    if ( Buffer1 != NULL )
        ScepFree(Buffer1);

    if ( ObjectName != NULL )
        ScepFree(ObjectName);

    if ( Value != NULL )
        ScepFree(Value);

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    SceJetCloseSection( &hSection, TRUE);

    if ( ( rc == SCESTATUS_SUCCESS ) &&
         ( Option != SCE_ALL_CHILDREN ) ) {

        if ( pArrObject ) {
            *Buffer = (PVOID)((PBYTE)pArrObject-sizeof(DWORD)*2);

            ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount = arrCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount = MaxCount;
        } else {
            *Buffer = NULL;
        }
/*
        *Buffer = ScepAlloc(0, sizeof(SCE_OBJECT_CHILDREN));

        if ( *Buffer ) {

            ((PSCE_OBJECT_CHILDREN)(*Buffer))->nCount = arrCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->MaxCount = MaxCount;
            ((PSCE_OBJECT_CHILDREN)(*Buffer))->arrObject = pArrObject;

        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
*/
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free (PVOID *)Buffer
        //
        if ( Option == SCE_ALL_CHILDREN ) {
            // OBJECT_CHILD_LIST structure
            ScepFreeObject2Security((PSCE_OBJECT_CHILD_LIST)(*Buffer), FALSE);
        } else if ( pArrObject ) {
            // OBJECT_CHILDREN structure
            ScepFreeObjectChildren((PSCE_OBJECT_CHILDREN)((PBYTE)pArrObject-sizeof(DWORD)*2));
        }
        *Buffer = NULL;

    }

    return(rc);
}


SCESTATUS
ScepBuildDsTree(
    OUT PSCE_OBJECT_CHILD_LIST *TreeRoot,
    IN ULONG Level,
    IN WCHAR Delim,
    IN PCWSTR ObjectFullName
    )
{
    TCHAR                   Buffer[MAX_PATH];
    BOOL                    LastOne=FALSE;
    SCESTATUS                rc;

    if ( TreeRoot == NULL || ObjectFullName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    memset(Buffer, '\0', MAX_PATH*sizeof(TCHAR));

    rc = ScepGetNameInLevel(ObjectFullName,
                           Level,
                           Delim,
                           Buffer,
                           &LastOne);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    *TreeRoot = (PSCE_OBJECT_CHILD_LIST)ScepAlloc(LPTR, sizeof(SCE_OBJECT_CHILD_LIST));
    if ( *TreeRoot == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    PSCE_OBJECT_TREE Node;

    //
    // allocate buffer for the node
    //
    Node = (PSCE_OBJECT_TREE)ScepAlloc((UINT)0, sizeof(SCE_OBJECT_TREE));
    if ( Node == NULL ) {
        ScepFree(*TreeRoot);
        *TreeRoot = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // allocate buffer for the object name
    //
    Node->Name = (PWSTR)ScepAlloc((UINT)0,
                                       (wcslen(Buffer)+1) * sizeof(TCHAR));
    if ( Node->Name != NULL ) {

        Node->ObjectFullName = (PWSTR)ScepAlloc( 0, (wcslen(ObjectFullName)+1)*sizeof(TCHAR));

        if ( Node->ObjectFullName != NULL ) {
            //
            // initialize
            //
            wcscpy(Node->Name, Buffer);
            wcscpy(Node->ObjectFullName, ObjectFullName);

            Node->ChildList = NULL;
            Node->Parent = NULL;
            Node->pApplySecurityDescriptor = NULL;

            Node->pSecurityDescriptor = NULL;
            Node->SeInfo = 0;
            Node->IsContainer = TRUE;
            Node->Status = SCE_STATUS_CHECK;

            (*TreeRoot)->Node = Node;

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            ScepFree( Node->Name );
            ScepFree( Node );
            ScepFree( *TreeRoot );
            *TreeRoot = NULL;
        }
    } else {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        ScepFree( Node );
        ScepFree( *TreeRoot );
        *TreeRoot = NULL;
    }

    return(rc);

}


SCESTATUS
ScepGetObjectSecurity(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    OUT PSCE_OBJECT_SECURITY *ObjSecurity
    )
/*
    Get security for a single object
*/
{
    SCESTATUS        rc;
    PCWSTR          SectionName=NULL;
    PSCESECTION      hSection=NULL;
    PWSTR           Value=NULL;
    DWORD           ValueLen;
    PSECURITY_DESCRIPTOR pTempSD=NULL;
    SECURITY_INFORMATION SeInfo;
    DWORD           SDsize, Win32Rc;


    if ( hProfile == NULL || ObjectName == NULL ||
         ObjSecurity == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    switch (Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        break;
    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        break;
#endif
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = SceJetGetValue(
            hSection,
            SCEJET_EXACT_MATCH_NO_CASE,
            ObjectName,
            NULL,
            0,
            NULL,
            NULL,
            0,
            &ValueLen
            );

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // allocate memory for value string
            //
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

            if ( Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;

            }
            //
            // Get the value
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        Value,
                        ValueLen,
                        &ValueLen
                        );

            if ( rc == SCESTATUS_SUCCESS ) {

                //
                // convert security descriptor
                //

                Win32Rc = ConvertTextSecurityDescriptor(
                                   Value+1,
                                   &pTempSD,
                                   &SDsize,
                                   &SeInfo
                                   );
                if ( Win32Rc == NO_ERROR ) {

                    if ( Area != AREA_DS_OBJECTS ) {
                        ScepChangeAclRevision(pTempSD, ACL_REVISION);
                    }
                    //
                    // allocate output buffer (SCE_OBJECT_SECURITY)
                    //
                    *ObjSecurity = (PSCE_OBJECT_SECURITY)ScepAlloc(0, sizeof(SCE_OBJECT_SECURITY));
                    if ( *ObjSecurity == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        goto Done;
                    }
                    (*ObjSecurity)->Name = (PWSTR)ScepAlloc(0, (wcslen(ObjectName)+1)*sizeof(TCHAR));
                    if ( (*ObjSecurity)->Name == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        ScepFree(*ObjSecurity);
                        *ObjSecurity = NULL;
                        goto Done;
                    }
/*
                    (*ObjSecurity)->SDspec = (PWSTR)ScepAlloc(0, ValueLen);
                    if ( (*ObjSecurity)->SDspec == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        ScepFree((*ObjSecurity)->Name);
                        ScepFree(*ObjSecurity);
                        *ObjSecurity = NULL;
                        goto Done;
                    }
*/
                    //
                    // build the structure
                    //
                    (*ObjSecurity)->Status = *((BYTE *)Value);
                    (*ObjSecurity)->IsContainer = *((CHAR *)Value+1) != '0' ? TRUE : FALSE;

                    wcscpy( (*ObjSecurity)->Name, ObjectName);
                    (*ObjSecurity)->pSecurityDescriptor = pTempSD;
                    pTempSD = NULL;
                    (*ObjSecurity)->SeInfo = SeInfo;
//                    wcscpy( (*ObjSecurity)->SDspec, Value+1);
//                    (*ObjSecurity)->SDsize = ValueLen/2-1;

                } else
                    rc = ScepDosErrorToSceStatus(Win32Rc);
            }

        }
    }

Done:

    SceJetCloseSection( &hSection, TRUE);

    if ( pTempSD )
        ScepFree(pTempSD);
    if ( Value )
        ScepFree(Value);

    return(rc);
}


SCESTATUS
ScepGetSystemServices(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE      ProfileType,
    OUT PSCE_SERVICES *pServiceList,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*
Routine Description:

    Read all services defined in the Jet table into the service list

Arguments:

    hProfile - the jet profile handle

    ProfileType - The table to read from
                      SCE_ENGINE_SCP
                      SCE_ENGINE_SAP
                      SCE_ENGINE_SMP

    pServiceList - The service list to output

    Errlog - the error messages to output

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS error codes

*/
{
    SCESTATUS rc;
    DWORD   Win32Rc;
    PSCESECTION hSection=NULL;
    DWORD   ServiceLen=0, ValueLen=0;
    PWSTR   ServiceName=NULL,
            Value=NULL;
    PSECURITY_DESCRIPTOR pTempSD=NULL;
    SECURITY_INFORMATION SeInfo;
    DWORD   SDsize;
    PSCE_SERVICES  ServiceNode;
    PSCE_SERVICES  pServices=NULL, pNode, pParent;


    if ( hProfile == NULL ||
         pServiceList == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // open the section
    //
    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                szServiceGeneral,
                &hSection
                );

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog,
                             SCEERR_OPEN,
                             szServiceGeneral
                           );
        return(rc);
    }

    //
    // enumerate all service names from the system.
    // do not care the error code
    //
    SceEnumerateServices(&pServices, TRUE);

    //
    // goto the first line of this section
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                NULL,
                0,
                &ServiceLen,
                NULL,
                0,
                &ValueLen
                );
    while ( rc == SCESTATUS_SUCCESS ) {

        //
        // allocate memory for the service name and value string
        //
        ServiceName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ServiceLen+2);
        if ( ServiceName != NULL ) {

            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);
            if ( Value != NULL ) {
                //
                // Get the service and its value
                //
                rc = SceJetGetValue(
                            hSection,
                            SCEJET_CURRENT,
                            NULL,
                            ServiceName,
                            ServiceLen,
                            &ServiceLen,
                            Value,
                            ValueLen,
                            &ValueLen
                            );
                if ( rc == SCESTATUS_SUCCESS ) {

                    ServiceName[ServiceLen/2] = L'\0';
                    Value[ValueLen/2] = L'\0';

#ifdef SCE_DBG
    wprintf(L"rc=%d, service: %s=%s\n", rc, ServiceName, Value);
#endif
                    //
                    // convert to security descriptor
                    //
                    Win32Rc = ConvertTextSecurityDescriptor(
                                       Value+1,
                                       &pTempSD,
                                       &SDsize,
                                       &SeInfo
                                       );
                    if ( Win32Rc == NO_ERROR ) {

                        ScepChangeAclRevision(pTempSD, ACL_REVISION);
                        //
                        // create this service node
                        //
                        ServiceNode = (PSCE_SERVICES)ScepAlloc( LMEM_FIXED, sizeof(SCE_SERVICES) );

                        if ( ServiceNode != NULL ) {
                            //
                            // find the right name for the service
                            //
                            for ( pNode=pServices, pParent=NULL; pNode != NULL;
                                  pParent=pNode, pNode=pNode->Next ) {

                                if ( _wcsicmp(pNode->ServiceName, ServiceName) == 0 ) {
                                    break;
                                }
                            }
                            if ( pNode != NULL ) {
                                //
                                // got it
                                //
                                ServiceNode->ServiceName = pNode->ServiceName;
                                ServiceNode->DisplayName = pNode->DisplayName;
                                //
                                // free the node
                                //
                                if ( pParent != NULL ) {
                                    pParent->Next = pNode->Next;
                                } else {
                                    pServices = pNode->Next;
                                }
                                // General is NULL becuase the enumerate call asks only for names
                                ScepFree(pNode);
                                pNode = NULL;

                            } else {
                                //
                                // did not find it
                                //
                                ServiceNode->ServiceName = ServiceName;
                                ServiceNode->DisplayName = NULL;

                                ServiceName = NULL;
                            }

                            ServiceNode->Status = *((BYTE *)Value);
                            ServiceNode->Startup = *((BYTE *)Value+1);
                            ServiceNode->General.pSecurityDescriptor = pTempSD;
                            ServiceNode->SeInfo = SeInfo;
                            ServiceNode->Next = *pServiceList;

                            *pServiceList = ServiceNode;

                            //
                            // DO NOT free the following buffers
                            //
                            pTempSD = NULL;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            ScepFree(pTempSD);
                        }

                    } else {
                        ScepBuildErrorLogInfo( Win32Rc,
                                             Errlog,
                                             SCEERR_BUILD_SD,
                                             ServiceName
                                           );
                        rc = ScepDosErrorToSceStatus(Win32Rc);
                    }
                }
                ScepFree(Value);

            } else
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

            //
            // ServiceName could be used in the service node
            //
            if ( ServiceName )
                ScepFree(ServiceName);

        } else
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // read next line
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_NEXT_LINE,
                        NULL,
                        NULL,
                        0,
                        &ServiceLen,
                        NULL,
                        0,
                        &ValueLen
                        );
        }
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free the service list
        //
        SceFreePSCE_SERVICES(*pServiceList);
        *pServiceList = NULL;
    }

    SceFreePSCE_SERVICES(pServices);

    return(rc);
}



SCESTATUS
ScepCopyObjects(
    IN PSCECONTEXT hProfile,
    IN SCETYPE     ProfileType,
    IN PWSTR InfFile,
    IN PCWSTR SectionName,
    IN AREA_INFORMATION Area,
    IN OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/* ++
Routine Description:

    This routine copies registry/file/ds/service object in SMP table to the specified
    inf template.

Arguments:

    hProfile    - The handle to the profile

    InfFile     - The INF template name

    SectionName - the section name where data is stored

    Area        - The security area to read info
                    AREA_REGISTRY_SECURITY
                    AREA_FILE_SECURITY
                    AREA_DS_OBJECTS

    Errlog      - The error log buffer.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_BAD_FORMAT
    SCESTATUS_INVALID_DATA
-- */
{
    SCESTATUS       rc = SCESTATUS_SUCCESS;
    PSCESECTION      hSection=NULL;

    PWSTR           ObjectName=NULL;
    PWSTR           Value=NULL;
    DWORD           ObjectLen, ValueLen;

    BYTE            Status;
    PWSTR           NewValue=NULL;

    DWORD           Count=0;
    WCHAR           KeyName[10];


    if ( InfFile == NULL || hProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // open the section
    //
    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // empty the section first.
        //
        WritePrivateProfileSection(
                            SectionName,
                            NULL,
                            (LPCTSTR)InfFile);
        //
        // find the first record in the section
        //
        rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                NULL,
                0,
                &ObjectLen,
                NULL,
                0,
                &ValueLen
                );

        while ( rc == SCESTATUS_SUCCESS ) {

            Count++;
            //
            // allocate memory for the group name and value string
            //
            ObjectName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ObjectLen+2);
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

            if ( ObjectName == NULL || Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;

            }
            //
            // Get the group and its value
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        ObjectName,
                        ObjectLen,
                        &ObjectLen,
                        Value,
                        ValueLen,
                        &ValueLen
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                     Errlog,
                                     SCEERR_QUERY_VALUE,
                                     SectionName
                                   );
                goto Done;
            }

#ifdef SCE_DBG
            wprintf(L"Addr: %x %x, %s=%s\n", ObjectName, Value, ObjectName, Value+1);
#endif

            if ( Area == AREA_SYSTEM_SERVICE )
                Status = *((BYTE *)Value+1);
            else
                Status = *((BYTE *)Value);

            NewValue = (PWSTR)ScepAlloc(0, ObjectLen+ValueLen+18);

            if ( NewValue == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;
            }

            swprintf(NewValue, L"\"%s\", %d, \"%s\"\0", ObjectName, Status, Value+1);
            swprintf(KeyName, L"%x\0", Count);

            //
            // write this line to the inf file
            //
            if ( !WritePrivateProfileString(
                            SectionName,
                            KeyName,
                            NewValue,
                            InfFile
                            ) ) {
                ScepBuildErrorLogInfo( GetLastError(),
                                     Errlog,
                                     SCEERR_WRITE_INFO,
                                     ObjectName
                                   );
                rc = ScepDosErrorToSceStatus(GetLastError());
            }

            ScepFree(ObjectName);
            ObjectName = NULL;

            ScepFree(Value);
            Value = NULL;

            ScepFree(NewValue);
            NewValue = NULL;

            if ( rc != SCESTATUS_SUCCESS )
                break;

            //
            // read next line
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_NEXT_LINE,
                        NULL,
                        NULL,
                        0,
                        &ObjectLen,
                        NULL,
                        0,
                        &ValueLen
                        );
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

    } else
        ScepBuildErrorLogInfo( ERROR_INVALID_HANDLE,
                             Errlog,
                             SCEERR_OPEN,
                             SectionName
                           );

Done:

    if ( ObjectName != NULL )
        ScepFree(ObjectName);

    if ( Value != NULL )
        ScepFree(Value);

    if ( NewValue != NULL )
        ScepFree(NewValue);
    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    SceJetCloseSection( &hSection, TRUE);

    return(rc);
}


SCESTATUS
ScepGetAnalysisSummary(
    IN PSCECONTEXT Context,
    IN AREA_INFORMATION Area,
    OUT PDWORD pCount
    )
{
    SCESTATUS        rc=SCESTATUS_INVALID_PARAMETER;
    DWORD           count;
    DWORD           total=0;
    PSCESECTION      hSection=NULL;

    if ( Context == NULL || pCount == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    *pCount = 0;

    if ( Area & AREA_SECURITY_POLICY ) {
        //
        // system access
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szSystemAccess,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;

        //
        // System Log
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szAuditSystemLog,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
        //
        // Security Log
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szAuditSecurityLog,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
        //
        // Application Log
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szAuditApplicationLog,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
        //
        // Event Audit
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szAuditEvent,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

    if ( Area & AREA_PRIVILEGES ) {
        //
        // Privileges
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szPrivilegeRights,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

    if ( Area & AREA_GROUP_MEMBERSHIP) {
        //
        // Group Membership
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szGroupMembership,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

    if ( Area & AREA_SYSTEM_SERVICE ) {
        //
        // system service
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szServiceGeneral,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

    if ( Area & AREA_REGISTRY_SECURITY ) {
        //
        // Registry security
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szRegistryKeys,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }
    if ( Area & AREA_FILE_SECURITY ) {
        //
        // File Security
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    szFileSecurity,
                    &hSection
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            rc = SceJetGetLineCount(
                        hSection,
                        NULL,
                        FALSE,
                        &count
                        );
        }
        SceJetCloseSection( &hSection, TRUE);

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        total += count;
    }

#if 0
#if _WIN32_WINNT>=0x0500
    if ( Area & AREA_DS_OBJECTS &&
         RtlGetNtProductType(&theType) ) {

        if ( theType == NtProductLanManNt ) {
            //
            // DS object security
            //
            rc = ScepOpenSectionForName(
                        Context,
                        SCE_ENGINE_SAP,
                        szDSSecurity,
                        &hSection
                        );
            if ( rc == SCESTATUS_SUCCESS ) {
                rc = SceJetGetLineCount(
                            hSection,
                            NULL,
                            FALSE,
                            &count
                            );
            }
            SceJetCloseSection( &hSection, TRUE);

            if ( rc != SCESTATUS_SUCCESS )
                return(rc);

            total += count;
        }
    }
#endif
#endif

    *pCount = total;

    return(rc);
}


SCESTATUS
ScepBrowseTableSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PCWSTR SectionName,
    IN DWORD Options
    )
{
    SCESTATUS rc;
    PSCESECTION hSection=NULL;

    SceClientBrowseCallback(
            0,
            (PWSTR)SectionName,
            NULL,
            NULL
            );

    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            SectionName,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    JET_ERR       JetErr;

    //
    // goto the first line of this section
    //
    DWORD KeyLen, ValueLen, Actual;
    LONG GpoID=0;
    PWSTR KeyName=NULL;
    PWSTR Value=NULL;
    TCHAR GpoName[MAX_PATH];

    SCE_BROWSE_CALLBACK_VALUE  ValBuf;
    ValBuf.Len = 0;
    ValBuf.Value = NULL;

    rc = SceJetGetValue(
                hSection,
                SCEJET_PREFIX_MATCH,
                NULL,
                NULL,
                0,
                &KeyLen,
                NULL,
                0,
                &ValueLen
                );

    while ( rc == SCESTATUS_SUCCESS ) {

        //
        // get GPO ID field from the current line
        //
        GpoID = 0;

        if ( hSection->JetColumnGpoID > 0 ) {

            JetErr = JetRetrieveColumn(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            hSection->JetColumnGpoID,
                            (void *)&GpoID,
                            4,
                            &Actual,
                            0,
                            NULL
                            );
        }


        if ( (Options & SCEBROWSE_DOMAIN_POLICY) &&
             (GpoID <= 0) ) {
            //
            // do not need this line, continue to next line
            //
        } else {

            KeyName = (PWSTR)ScepAlloc(LMEM_ZEROINIT, KeyLen+2);

            //
            // allocate memory for the group name and value string
            //
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

            if ( KeyName == NULL || Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                goto Done;

            }

            //
            // Get the key and value
            //
            DWORD NewKeyLen, NewValueLen;

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        KeyName,
                        KeyLen,
                        &NewKeyLen,
                        Value,
                        ValueLen,
                        &NewValueLen
                        );

            if ( rc != SCESTATUS_SUCCESS )
                goto Done;

            //
            // terminate the string
            //
            KeyName[KeyLen/2] = L'\0';

            Value[ValueLen/2] = L'\0';

            GpoName[0] = L'\0';

            if ( hSection->JetColumnGpoID > 0 && GpoID > 0 ) {

                Actual = MAX_PATH;
                SceJetGetGpoNameByID(
                            hProfile,
                            GpoID,
                            GpoName,
                            &Actual,
                            NULL,
                            NULL
                            );
            }

            if ( Value && Value[0] != L'\0' &&
                 ( Options & SCEBROWSE_MULTI_SZ) ) {
                     
                if (0 == _wcsicmp( KeyName, szLegalNoticeTextKeyName) ) {

                    //
                    // check for commas and escape them with "," 
                    // k=7,a",",b,c
                    // pValueStr will be a,\0b\0c\0\0 which we should make
                    // a","\0b\0c\0\0
                    //

                    DWORD dwCommaCount = 0;

                    for ( DWORD dwIndex = 1; dwIndex < ValueLen/2 ; dwIndex++) {
                        if ( Value[dwIndex] == L',' )
                            dwCommaCount++;
                    }

                    if ( dwCommaCount > 0 ) {

                        //
                        // in this case we have to escape commas
                        //

                        PWSTR   pszValueEscaped;
                        DWORD   dwBytes = (ValueLen/2 + 1 + (dwCommaCount*2))*sizeof(WCHAR);

                        pszValueEscaped = (PWSTR)ScepAlloc(LMEM_ZEROINIT, dwBytes);

                        if (pszValueEscaped) {

                            memset(pszValueEscaped, '\0', dwBytes);
                            ValueLen = 2 * ScepEscapeString(Value,
                                                        ValueLen/2,
                                                        L',',
                                                        L'"',
                                                        pszValueEscaped
                                                       );

                            ScepFree(Value);
                            
                            Value = pszValueEscaped;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            goto Done;
                        }
                    }
                }
                                
                ScepConvertMultiSzToDelim(Value+1, ValueLen/2-1, L'\0', L',');

            }

            __try {

                ValBuf.Len = Value ? (ValueLen+2) : 0 ;
                ValBuf.Value = (UCHAR *)Value;

                SceClientBrowseCallback(
                        GpoID,
                        KeyName,
                        GpoName,
                        (SCEPR_SR_SECURITY_DESCRIPTOR *)&ValBuf
                        );
            } __except(EXCEPTION_EXECUTE_HANDLER) {

            }

            ScepFree(Value);
            Value = NULL;

            ScepFree(KeyName);
            KeyName = NULL;
        }

        //
        // read next line
        //

        rc = SceJetGetValue(
                    hSection,
                    SCEJET_NEXT_LINE,
                    NULL,
                    NULL,
                    0,
                    &KeyLen,
                    NULL,
                    0,
                    &ValueLen
                    );
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

Done:

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    if ( Value != NULL )
        ScepFree(Value);

    if ( KeyName != NULL )
        ScepFree(KeyName);

    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    return(rc);
}


BOOL
ScepSearchItemInChildren(
    IN PWSTR ItemName,
    IN DWORD NameLen,
    IN PSCE_OBJECT_CHILDREN_NODE *pArrObject,
    IN DWORD arrCount,
    OUT LONG *pFindIndex
    )
/*
Routine Description:

    Search the item name in the array specified. If found, the index to the
    array is returned in pFindIndex.

Return Value:

    TRUE    - find it
    FALSE   - doesn't find it
*/
{
    if ( pFindIndex == NULL ) {
        return(FALSE);
    }

    //
    // note pFindIndex stores the closest node, not necessary mean
    // the index is the match.
    //
    *pFindIndex = -1;

    if ( ItemName == NULL ||
         pArrObject == NULL ||
         arrCount == 0 ) {
        return(FALSE);
    }

    DWORD idxStart=0;
    DWORD idxEnd=arrCount-1;

    DWORD theIndex;
    INT CompFlag=-1;

    do {

        //
        // choose the middle
        //
        theIndex = (idxStart + idxEnd)/2;

        if ( pArrObject[theIndex] == NULL ||
             pArrObject[theIndex]->Name == NULL ) {
            //
            // this is a bad node, check the start node
            //
            while ( (pArrObject[idxStart] == NULL ||
                     pArrObject[idxStart]->Name == NULL) &&
                    idxStart <= idxEnd ) {

                idxStart++;
            }

            if ( idxStart <= idxEnd ) {

                //
                // check the start node
                //
                CompFlag = _wcsicmp(ItemName, pArrObject[idxStart]->Name);
                *pFindIndex = idxStart;

                if ( CompFlag == 0 ) {
                    // find it
                    break;

                } else if ( CompFlag < 0 ) {
                    //
                    // the item is less than idxStart - no match
                    //
                    break;

                } else {
                    //
                    // the item is between theStart and idxEnd
                    //
                    if ( idxStart == idxEnd ) {
                        // empty now. quit
                        break;
                    } else {
                        idxStart++;
                    }
                }
            }

        } else {

            CompFlag = _wcsicmp(ItemName, pArrObject[theIndex]->Name);
            *pFindIndex = theIndex;

            if ( CompFlag == 0 ) {
                // find it
                break;

            } else if ( CompFlag < 0 ) {
                //
                // the item is between index idxStart and theIndex
                //
                if ( theIndex == idxStart ) {
                    // empty now. quit
                    break;
                } else {
                    idxEnd = theIndex-1;
                }
            } else {
                //
                // the item is between theIndex and idxEnd
                //
                if ( theIndex == idxEnd ) {
                    // empty now. quit
                    break;
                } else {
                    idxStart = theIndex+1;
                }
            }

        }

    } while ( idxStart <= idxEnd );

    if ( CompFlag == 0 ) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


DWORD
ScepAddItemToChildren(
    IN PSCE_OBJECT_CHILDREN_NODE ThisNode OPTIONAL,
    IN PWSTR ItemName,
    IN DWORD NameLen,
    IN BOOL  IsContainer,
    IN BYTE  Status,
    IN DWORD ChildCount,
    IN OUT PSCE_OBJECT_CHILDREN_NODE **ppArrObject,
    IN OUT DWORD *pArrCount,
    IN OUT DWORD *pMaxCount,
    IN OUT LONG *pFindIndex
    )
/*
Routine Description:

    Add a node to the children array. If the node is allocated, the pointer
    will be added to the array; otherwise, a new allocation is made for the
    new node.

    The node's name will be first checked in the array for duplicate. If
    pFindIndex is specified (not -1), the index will be first used to locate
    the node. If the new node's name is found in the array, it won't be
    added.

Return Value:

    ERROR_DUP_NAME    duplicate node name is found, node is not added to the array
    ERROR_SUCCESS     succeed
    other errors
*/
{

    if ( ItemName == NULL ||
         ppArrObject == NULL ||
         pArrCount == NULL ||
         pMaxCount == NULL ||
         pFindIndex == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD rc=ERROR_SUCCESS;

    if ( *ppArrObject == NULL ||
         *pArrCount == 0 ) {

        *pArrCount = 0;
        *pMaxCount = 0;
        *pFindIndex = -1;

    } else if ( ( *pFindIndex < 0 ) ||
         ( *pFindIndex >= (LONG)(*pArrCount) ) ||
         ( (*ppArrObject)[*pFindIndex] == NULL ) ||
         ( (*ppArrObject)[*pFindIndex]->Name == NULL) ) {

        //
        // should search for the closest node
        //
        if ( ScepSearchItemInChildren(
                    ItemName,
                    NameLen,
                    *ppArrObject,
                    *pArrCount,
                    pFindIndex
                    ) ) {

            return(ERROR_DUP_NAME);
        }
    }

    INT CompFlag=-1;

    if ( *pFindIndex >= 0 ) {

        //
        // check if the closest node matches the new node
        //
        CompFlag = _wcsicmp( ItemName, (*ppArrObject)[*pFindIndex]->Name );

        if ( CompFlag == 0 ) {
            return(ERROR_DUP_NAME);
        }
    }

    PSCE_OBJECT_CHILDREN_NODE pNodeToAdd;

    if ( ThisNode == NULL ) {
        //
        // allocate a new node
        //
        pNodeToAdd = (PSCE_OBJECT_CHILDREN_NODE)ScepAlloc(0, sizeof(SCE_OBJECT_CHILDREN_NODE));

        if ( NameLen == 0 ) {
            NameLen = wcslen(ItemName);
        }

        if ( pNodeToAdd ) {
            pNodeToAdd->Name = (PWSTR)ScepAlloc(0, (NameLen+1)*sizeof(WCHAR));

            if ( pNodeToAdd->Name ) {
                wcscpy(pNodeToAdd->Name, ItemName);
                pNodeToAdd->IsContainer = IsContainer;
                pNodeToAdd->Status = Status;
                pNodeToAdd->Count = ChildCount;

            } else {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                ScepFree(pNodeToAdd);
                pNodeToAdd = NULL;
            }
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {

        pNodeToAdd = ThisNode;
    }

    if ( ERROR_SUCCESS == rc ) {

        LONG idxAdd, i;

        if ( *pFindIndex >= 0 ) {

            if ( CompFlag < 0 ) {
                //
                // add the new node before pFindIndex
                //
                idxAdd = *pFindIndex;

            } else {
                //
                // add the new node after pFindIndex
                //
                idxAdd = *pFindIndex+1;
            }

        } else {
            idxAdd = 0;
        }

        if ( *pArrCount >= *pMaxCount ) {
            //
            // there is not enough array nodes to hold the new node
            //
            PSCE_OBJECT_CHILDREN_NODE *pNewArray;
            PBYTE pTmpBuffer;

            pTmpBuffer = (PBYTE)ScepAlloc(0, 2*sizeof(DWORD)+(*pMaxCount+SCE_ALLOC_MAX_NODE)*sizeof(PSCE_OBJECT_CHILDREN_NODE));

            if ( pTmpBuffer == NULL ) {

                rc = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                //
                // need to shift two DWORDs for the array start
                //
                pNewArray = (PSCE_OBJECT_CHILDREN_NODE *)(pTmpBuffer + 2*sizeof(DWORD));

                LONG idxStart1, idxEnd1, idxStart2, idxEnd2;

                if ( *pFindIndex >= 0 ) {

                    if ( CompFlag < 0 ) {
                        //
                        // add the new node before pFindIndex
                        //
                        idxEnd1 = *pFindIndex-1;
                        idxStart2 = *pFindIndex;

                    } else {
                        //
                        // add the new node after pFindIndex
                        //

                        idxEnd1 = *pFindIndex;
                        idxStart2 = *pFindIndex+1;
                    }

                    idxStart1 = 0;
                    idxEnd2 = *pArrCount-1;

                } else {
                    idxStart1 = -1;
                    idxEnd1 = -1;
                    idxStart2 = 0;
                    idxEnd2 = *pArrCount-1;
                }

                //
                // make the copy
                //
                LONG j=0;
                for ( i=idxStart1; i<=idxEnd1 && i>=0; i++ ) {
                    pNewArray[j++] = (*ppArrObject)[i];
                }

                pNewArray[idxAdd] = pNodeToAdd;
                j = idxAdd+1;

                for ( i=idxStart2; i<=idxEnd2 && i>=0; i++ ) {
                    pNewArray[j++] = (*ppArrObject)[i];
                }

                (*pMaxCount) += SCE_ALLOC_MAX_NODE;
                (*pArrCount)++;

                //
                // free the old list
                //
                if ( *ppArrObject ) {
                    ScepFree((PBYTE)(*ppArrObject)-2*sizeof(DWORD));
                }
                *ppArrObject = pNewArray;

                *pFindIndex = idxAdd;

            }

        } else {
            //
            // the buffer is big enough, just add the node to the buffer
            //

            //
            // make the copy
            //
            for ( i=*pArrCount-1; i>=idxAdd && i>=0; i-- ) {
                (*ppArrObject)[i+1] = (*ppArrObject)[i];
            }

            (*ppArrObject)[idxAdd] = pNodeToAdd;

            (*pArrCount)++;

            *pFindIndex = idxAdd;
        }
    }

    //
    // release memory if it fails
    //
    if ( ERROR_SUCCESS != rc &&
         pNodeToAdd &&
         pNodeToAdd != ThisNode ) {

        ScepFree(pNodeToAdd->Name);
        ScepFree(pNodeToAdd);
    }

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\kerberos.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    kerberos.cpp

Abstract:

    Routines to read/write/configure kerberos policy settings

    The following modules have links to kerberos policy
        scejet.c    <SceJetAddSection>
        inftojet.c  <SceConvertpInfKeyValue>
        pfget.c     <ScepGetKerberosPolicy>
        config.c    <ScepConfigureKerberosPolicy>
        analyze.c   <ScepAnalyzeKerberosPolicy>

Author:

    Jin Huang (jinhuang) 17-Dec-1997

Revision History:

    jinhuang 28-Jan-1998 splitted to client-server

--*/

#include "headers.h"
#include "serverp.h"
#include "kerberos.h"
#include "kerbcon.h"
#include "pfp.h"

#define MAXDWORD    0xffffffff

static  PWSTR KerbItems[] = {
        {(PWSTR)TEXT("MaxTicketAge")},
        {(PWSTR)TEXT("MaxRenewAge")},
        {(PWSTR)TEXT("MaxServiceAge")},
        {(PWSTR)TEXT("MaxClockSkew")},
        {(PWSTR)TEXT("TicketValidateClient")}
        };

#define MAX_KERB_ITEMS      5

#define IDX_KERB_MAX        0
#define IDX_KERB_RENEW      1
#define IDX_KERB_SERVICE    2
#define IDX_KERB_CLOCK      3
#define IDX_KERB_VALIDATE   4


SCESTATUS
ScepGetKerberosPolicy(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_KERBEROS_TICKET_INFO * ppKerberosInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves kerberos policy information from the Jet database
   and stores in the output buffer ppKerberosInfo.

Arguments:

   hProfile     -  The profile handle context

   ppKerberosInfo -  the output buffer to hold kerberos settings.

   Errlog       -  A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    SCESTATUS                rc;
    PSCESECTION              hSection=NULL;

    SCE_KEY_LOOKUP AccessKeys[] = {
        {(PWSTR)TEXT("MaxTicketAge"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxTicketAge),  'D'},
        {(PWSTR)TEXT("MaxRenewAge"),      offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxRenewAge),   'D'},
        {(PWSTR)TEXT("MaxServiceAge"),    offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxServiceAge),   'D'},
        {(PWSTR)TEXT("MaxClockSkew"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxClockSkew), 'D'},
        {(PWSTR)TEXT("TicketValidateClient"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, TicketValidateClient),  'D'}
    };

    DWORD cKeys = sizeof(AccessKeys) / sizeof(SCE_KEY_LOOKUP);
    SCE_KERBEROS_TICKET_INFO TicketInfo;

    if ( ppKerberosInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepGetFixValueSection(
               hProfile,
               szKerberosPolicy,
               AccessKeys,
               cKeys,
               ProfileType,
               (PVOID)&TicketInfo,
               &hSection,
               Errlog
               );
    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }
    //
    // copy the value in TicketInfo to ppKerberosInfo
    //
    if ( NULL == *ppKerberosInfo ) {
        *ppKerberosInfo = (PSCE_KERBEROS_TICKET_INFO)ScepAlloc(0, sizeof(SCE_KERBEROS_TICKET_INFO));
    }

    if ( *ppKerberosInfo ) {

       memcpy(*ppKerberosInfo, &TicketInfo, sizeof(SCE_KERBEROS_TICKET_INFO));

    } else {

       rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    SceJetCloseSection(&hSection, TRUE);

    return(rc);
}

#if _WIN32_WINNT>=0x0500

SCESTATUS
ScepConfigureKerberosPolicy(
    IN PSCECONTEXT hProfile,
    IN PSCE_KERBEROS_TICKET_INFO pKerberosInfo,
    IN DWORD ConfigOptions
    )
/* ++

Routine Description:

   This routine configure the kerberos policy settings in the area of security
   policy.

Arguments:

   pKerberosInfo - The buffer which contains kerberos policy settings

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
   if ( !pKerberosInfo ) {
      //
      // if no info to configure
      //
      return SCESTATUS_SUCCESS;
   }

   NTSTATUS                      NtStatus;
   LSA_HANDLE                    lsaHandle=NULL;
   DWORD                         rc = NO_ERROR;
   BOOL                          bDefaultUsed=FALSE;
   BOOL                          bDefined=FALSE;

   //
   // open LSA policy to configure kerberos policy
   //
   NtStatus = ScepOpenLsaPolicy(
               MAXIMUM_ALLOWED,
               &lsaHandle,
               TRUE
               );

   if (!NT_SUCCESS(NtStatus)) {

       lsaHandle = NULL;
       rc = RtlNtStatusToDosError( NtStatus );
       ScepLogOutput3( 1, rc, SCEDLL_LSA_POLICY);

       if ( ConfigOptions & SCE_RSOP_CALLBACK )

           ScepRsopLog(SCE_RSOP_KERBEROS_INFO, rc, NULL, 0, 0);

       return(ScepDosErrorToSceStatus(rc));
   }
   //
   // query current kerberos policy settings into pBuffer
   //
   PPOLICY_DOMAIN_KERBEROS_TICKET_INFO pBuffer=NULL;
   POLICY_DOMAIN_KERBEROS_TICKET_INFO TicketInfo;

   NtStatus = LsaQueryDomainInformationPolicy(
                  lsaHandle,
                  PolicyDomainKerberosTicketInformation,
                  (PVOID *)&pBuffer
                  );

   if ( NT_SUCCESS(NtStatus) && pBuffer ) {
       //
       // transfer ticket info to TicketInfo buffer
       //
       TicketInfo.AuthenticationOptions = pBuffer->AuthenticationOptions;
       TicketInfo.MaxTicketAge = pBuffer->MaxTicketAge;
       TicketInfo.MaxRenewAge = pBuffer->MaxRenewAge;
       TicketInfo.MaxServiceTicketAge = pBuffer->MaxServiceTicketAge;
       TicketInfo.MaxClockSkew = pBuffer->MaxClockSkew;

       //
       // free the buffer
       //
       LsaFreeMemory((PVOID)pBuffer);

   } else {
       //
       // no kerberos policy is configured yet because by default it's not created.
       // let's create it now. set a default ticket info
       //
       TicketInfo.AuthenticationOptions = POLICY_KERBEROS_VALIDATE_CLIENT;

       TicketInfo.MaxTicketAge.QuadPart = (LONGLONG) KERBDEF_MAX_TICKET*60*60 * 10000000L;
       TicketInfo.MaxRenewAge.QuadPart = (LONGLONG) KERBDEF_MAX_RENEW*24*60*60 * 10000000L;
       TicketInfo.MaxServiceTicketAge.QuadPart = (LONGLONG) KERBDEF_MAX_SERVICE*60 * 10000000L;
       TicketInfo.MaxClockSkew.QuadPart = (LONGLONG) KERBDEF_MAX_CLOCK*60 * 10000000L;

       bDefaultUsed = TRUE;
   }
   pBuffer = &TicketInfo;

  //
  // process each field in pKerberosInfo
  //
  BOOL bFlagSet=FALSE;
  ULONG lOptions=0;
  ULONG lValue=0;

  SCE_TATTOO_KEYS *pTattooKeys=NULL;
  DWORD           cTattooKeys=0;

  PSCESECTION hSectionDomain=NULL;
  PSCESECTION hSectionTattoo=NULL;

#define MAX_KERB_KEYS           5


  //
  // if in policy propagation, open the policy sections
  // since kerberos policy is only available on DCs and kerberos policy (account policy)
  // can't be reset to local settings on each DC, there is no point to query/save
  // the tattoo values
  //
/* do not take tattoo value for kerberos
  if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
       hProfile ) {

      pTattooKeys = (SCE_TATTOO_KEYS *)ScepAlloc(LPTR,MAX_KERB_KEYS*sizeof(SCE_TATTOO_KEYS));

      if ( !pTattooKeys ) {
          ScepLogOutput3(1, ERROR_NOT_ENOUGH_MEMORY, SCESRV_POLICY_TATTOO_ERROR_CREATE);
      }
  }
*/
  if ( pKerberosInfo->MaxRenewAge != SCE_NO_VALUE ) {
      ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                               (PWSTR)L"MaxRenewAge", ConfigOptions,
                               KERBDEF_MAX_RENEW);
  }

  if ( pKerberosInfo->MaxRenewAge == SCE_FOREVER_VALUE ) {

      if ( pBuffer->MaxRenewAge.HighPart != MINLONG ||
           pBuffer->MaxRenewAge.LowPart != 0  ) {
          //
          // Maximum LARGE_INTEGER .ie. never
          //

          pBuffer->MaxRenewAge.HighPart = MINLONG;
          pBuffer->MaxRenewAge.LowPart = 0;
          bFlagSet = TRUE;

      }
      bDefined = TRUE;

  } else if ( SCE_NO_VALUE != pKerberosInfo->MaxRenewAge ) {

     //
     // ticket is renewable, the max age is stored in MaxRenewAge
     // using days
     //

      lValue = (DWORD) (pBuffer->MaxRenewAge.QuadPart /
                                     (LONGLONG)(10000000L) );
      lValue /= 3600;
      lValue /= 24;

      if ( lValue != pKerberosInfo->MaxRenewAge ) {

          pBuffer->MaxRenewAge.QuadPart = (LONGLONG)pKerberosInfo->MaxRenewAge*24*3600 * 10000000L;
          bFlagSet = TRUE;

      }

      bDefined = TRUE;
  }

  //
  // validate client ?
  //

  if ( pKerberosInfo->TicketValidateClient != SCE_NO_VALUE ) {

     if ( pKerberosInfo->TicketValidateClient ) {
        lOptions |= POLICY_KERBEROS_VALIDATE_CLIENT;
     }

     ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                              (PWSTR)L"TicketValidateClient", ConfigOptions,
                              KERBDEF_VALIDATE);

     if ( ( pBuffer->AuthenticationOptions & POLICY_KERBEROS_VALIDATE_CLIENT ) !=
          ( lOptions & POLICY_KERBEROS_VALIDATE_CLIENT ) ) {


         pBuffer->AuthenticationOptions = lOptions;
         bFlagSet = TRUE;
     }
     bDefined = TRUE;
  }

  //
  // max ticket age
  //
  if ( pKerberosInfo->MaxTicketAge != SCE_NO_VALUE ) {
      ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                               (PWSTR)L"MaxTicketAge", ConfigOptions,
                               KERBDEF_MAX_TICKET);
      bDefined = TRUE;
  }

  if ( pKerberosInfo->MaxTicketAge == SCE_FOREVER_VALUE ) {

      if ( pBuffer->MaxTicketAge.HighPart != MINLONG ||
           pBuffer->MaxTicketAge.LowPart != 0  ) {
          //
          // Maximum LARGE_INTEGER .ie. never
          //

          pBuffer->MaxTicketAge.HighPart = MINLONG;
          pBuffer->MaxTicketAge.LowPart = 0;
          bFlagSet = TRUE;
      }

      bDefined = TRUE;

  }  else if ( pKerberosInfo->MaxTicketAge != SCE_NO_VALUE ) {
      // in hours


      lValue = (DWORD) (pBuffer->MaxTicketAge.QuadPart /
                                     (LONGLONG)(10000000L) );
      lValue /= 3600;

      if ( lValue != pKerberosInfo->MaxTicketAge ) {

          pBuffer->MaxTicketAge.QuadPart = (LONGLONG)pKerberosInfo->MaxTicketAge*60*60 * 10000000L;
          bFlagSet = TRUE;
      }

      bDefined = TRUE;
  }

  //
  // max service ticket age
  //
  if ( pKerberosInfo->MaxServiceAge != SCE_NO_VALUE ) {
      ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                               (PWSTR)L"MaxServiceAge", ConfigOptions,
                               KERBDEF_MAX_SERVICE);
      bDefined = TRUE;
  }

  if ( pKerberosInfo->MaxServiceAge == SCE_FOREVER_VALUE ) {

      if ( pBuffer->MaxServiceTicketAge.HighPart != MINLONG ||
           pBuffer->MaxServiceTicketAge.LowPart != 0  ) {
          //
          // Maximum LARGE_INTEGER .ie. never
          //

          pBuffer->MaxServiceTicketAge.HighPart = MINLONG;
          pBuffer->MaxServiceTicketAge.LowPart = 0;
          bFlagSet = TRUE;
      }

      bDefined = TRUE;

  }  else if ( pKerberosInfo->MaxServiceAge != SCE_NO_VALUE ) {
      // in minutes


      lValue = (DWORD) (pBuffer->MaxServiceTicketAge.QuadPart /
                                     (LONGLONG)(10000000L) );
      lValue /= 60;

      if ( lValue != pKerberosInfo->MaxServiceAge ) {

          pBuffer->MaxServiceTicketAge.QuadPart = (LONGLONG)pKerberosInfo->MaxServiceAge*60 * 10000000L;
          bFlagSet = TRUE;
      }

      bDefined = TRUE;
  }

  //
  // max clock
  //
  if ( pKerberosInfo->MaxClockSkew != SCE_NO_VALUE ) {
      ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                               (PWSTR)L"MaxClockSkew", ConfigOptions,
                               KERBDEF_MAX_CLOCK);
      bDefined = TRUE;
  }

  if ( pKerberosInfo->MaxClockSkew == SCE_FOREVER_VALUE ) {

      if ( pBuffer->MaxClockSkew.HighPart != MINLONG ||
           pBuffer->MaxClockSkew.LowPart != 0  ) {

          //
          // Maximum LARGE_INTEGER .ie. never
          //

          pBuffer->MaxClockSkew.HighPart = MINLONG;
          pBuffer->MaxClockSkew.LowPart = 0;
          bFlagSet = TRUE;
      }
      bDefined = TRUE;

  }  else if ( pKerberosInfo->MaxClockSkew != SCE_NO_VALUE ) {
      // in minutes

      lValue = (DWORD) (pBuffer->MaxClockSkew.QuadPart /
                                     (LONGLONG)(10000000L) );
      lValue /= 60;

      if ( lValue != pKerberosInfo->MaxClockSkew ) {

          pBuffer->MaxClockSkew.QuadPart = (LONGLONG)pKerberosInfo->MaxClockSkew*60 * 10000000L;
          bFlagSet = TRUE;
      }
      bDefined = TRUE;
  }

  if ( bFlagSet || (bDefaultUsed && bDefined) ) {
     //
     // if anything for kerberos to configure
     //
      NtStatus = LsaSetDomainInformationPolicy(
               lsaHandle,
               PolicyDomainKerberosTicketInformation,
               (PVOID)pBuffer
               );
      rc = RtlNtStatusToDosError( NtStatus );

      if ( rc != NO_ERROR ) {
           ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_KERBEROS);
      } else {
           ScepLogOutput3(1, 0, SCEDLL_SCP_KERBEROS);
      }
  }

  if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
       hProfile && pTattooKeys && cTattooKeys ) {

      ScepTattooOpenPolicySections(
                    hProfile,
                    szKerberosPolicy,
                    &hSectionDomain,
                    &hSectionTattoo
                    );
      ScepLogOutput3(3,0,SCESRV_POLICY_TATTOO_ARRAY,cTattooKeys);
      //
      // some policy is different than the system setting
      // check if we should save the existing setting as the tattoo value
      // also remove reset'ed tattoo policy
      //
      ScepTattooManageValues(hSectionDomain, hSectionTattoo, pTattooKeys, cTattooKeys, rc);

      if ( hSectionDomain ) SceJetCloseSection(&hSectionDomain,TRUE);
      if ( hSectionTattoo ) SceJetCloseSection(&hSectionTattoo,TRUE);
  }

  if ( pTattooKeys ) ScepFree(pTattooKeys);

  if ( ConfigOptions & SCE_RSOP_CALLBACK )

      ScepRsopLog(SCE_RSOP_KERBEROS_INFO, rc, NULL, 0, 0);

   //
   // close LSA policy
   //
   LsaClose( lsaHandle );

   return(ScepDosErrorToSceStatus(rc));
}


SCESTATUS
ScepAnalyzeKerberosPolicy(
    IN PSCECONTEXT hProfile OPTIONAL,
    IN PSCE_KERBEROS_TICKET_INFO pKerInfo,
    IN DWORD Options
    )
/* ++

Routine Description:

   This routine queries the system kerberos policy settings and compare them
   with the template settings.

Arguments:

   hProfile - the profile context

   pKerInfo - The buffer which contains kerberos settings to compare with or
                the buffer to query system settings into

   Options  - the option(s) for the analysis, e.g., SCE_SYSTEM_SETTINGS

Return value:


-- */
{
    NTSTATUS                      NtStatus;
    LSA_HANDLE                    lsaHandle=NULL;
    DWORD                         rc32 = NO_ERROR;
    SCESTATUS                     rc=SCESTATUS_SUCCESS;
    PPOLICY_DOMAIN_KERBEROS_TICKET_INFO pBuffer=NULL;
    DWORD dValue;
    PSCESECTION hSection=NULL;
    POLICY_DOMAIN_KERBEROS_TICKET_INFO KerbTicketInfo;

    if ( !pKerInfo ) {
        //
        // if no template info, do not analyze
        //
        if ( Options & SCE_SYSTEM_SETTINGS ) {
            return SCESTATUS_INVALID_PARAMETER;
        } else {
            return SCESTATUS_SUCCESS;
        }
    }


    //
    // open LSA policy to configure kerberos policy
    //
    NtStatus = ScepOpenLsaPolicy(
               MAXIMUM_ALLOWED,
               &lsaHandle,
               TRUE
               );

    if (!NT_SUCCESS(NtStatus)) {

        lsaHandle = NULL;
        rc32 = RtlNtStatusToDosError( NtStatus );
        ScepLogOutput3( 1, rc32, SCEDLL_LSA_POLICY);

        return(ScepDosErrorToSceStatus(rc32));
    }

    if ( !(Options & SCE_SYSTEM_SETTINGS) ) {

        //
        // Prepare kerberos section
        //
        rc = ScepStartANewSection(
                 hProfile,
                 &hSection,
                 (Options & SCE_GENERATE_ROLLBACK) ? SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                 szKerberosPolicy
                 );
    }

    if ( rc != SCESTATUS_SUCCESS ) {
      ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                    SCEDLL_SAP_START_SECTION, (PWSTR)szKerberosPolicy);

    } else {

        DWORD KerbValues[MAX_KERB_ITEMS];

        for ( dValue=0; dValue<MAX_KERB_ITEMS; dValue++ ) {
            KerbValues[dValue] = SCE_ERROR_VALUE;
        }

        //
        // query current kerberos policy settings into pBuffer
        //
        NtStatus = LsaQueryDomainInformationPolicy(
                      lsaHandle,
                      PolicyDomainKerberosTicketInformation,
                      (PVOID *)&pBuffer
                      );

        if ( STATUS_NOT_FOUND == NtStatus ) {

            //
            // there is no Kerberos policy
            //
            KerbTicketInfo.AuthenticationOptions = POLICY_KERBEROS_VALIDATE_CLIENT;

            KerbTicketInfo.MaxTicketAge.QuadPart = (LONGLONG) KERBDEF_MAX_TICKET*60*60 * 10000000L;
            KerbTicketInfo.MaxRenewAge.QuadPart = (LONGLONG) KERBDEF_MAX_RENEW*24*60*60 * 10000000L;
            KerbTicketInfo.MaxServiceTicketAge.QuadPart = (LONGLONG) KERBDEF_MAX_SERVICE*60 * 10000000L;
            KerbTicketInfo.MaxClockSkew.QuadPart = (LONGLONG) KERBDEF_MAX_CLOCK*60 * 10000000L;

            pBuffer = &KerbTicketInfo;
            NtStatus = STATUS_SUCCESS;
        }

        rc = ScepDosErrorToSceStatus(
                      RtlNtStatusToDosError( NtStatus ));

        if ( NT_SUCCESS(NtStatus) && pBuffer ) {

            //
            // analyze kerberos values
            // max ticket age
            //
            if ( pBuffer->MaxTicketAge.HighPart == MINLONG &&
                 pBuffer->MaxTicketAge.LowPart == 0 ) {
                //
                // Maximum password age value is MINLONG,0
                //
                dValue = SCE_FOREVER_VALUE;

            }  else {

                dValue = (DWORD) ( pBuffer->MaxTicketAge.QuadPart /
                                    (LONGLONG)(10000000L) );
                //
                // using hours
                //
                //           dValue /= 24;

                dValue /= 3600;

            }

            rc = SCESTATUS_SUCCESS;

            if ( Options & SCE_SYSTEM_SETTINGS ) {

                pKerInfo->MaxTicketAge = dValue;

            } else {

                rc = ScepCompareAndSaveIntValue(
                        hSection,
                        L"MaxTicketAge",
                        (Options & SCE_GENERATE_ROLLBACK),
                        pKerInfo->MaxTicketAge,
                        dValue);
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                KerbValues[IDX_KERB_MAX] = 1;


                if ( pBuffer->MaxRenewAge.HighPart == MINLONG &&
                     pBuffer->MaxRenewAge.LowPart == 0 ) {
                    //
                    // Maximum age value is MINLONG,0
                    //
                    dValue = SCE_FOREVER_VALUE;

                }  else {

                    dValue = (DWORD) ( pBuffer->MaxRenewAge.QuadPart /
                                                   (LONGLONG)(10000000L) );
                    //
                    // using days
                    //
                    dValue /= 3600;
                    dValue /= 24;

                }

                if ( Options & SCE_SYSTEM_SETTINGS ) {

                    pKerInfo->MaxRenewAge = dValue;

                } else {

                    rc = ScepCompareAndSaveIntValue(
                            hSection,
                            L"MaxRenewAge",
                            (Options & SCE_GENERATE_ROLLBACK),
                            pKerInfo->MaxRenewAge,
                            dValue);
                }

                if ( SCESTATUS_SUCCESS == rc ) {

                    KerbValues[IDX_KERB_RENEW] = 1;

                    if ( pBuffer->MaxServiceTicketAge.HighPart == MINLONG &&
                         pBuffer->MaxServiceTicketAge.LowPart == 0 ) {
                        //
                        // Maximum age value is MINLONG,0
                        //
                        dValue = SCE_FOREVER_VALUE;

                    }  else {

                        dValue = (DWORD) ( pBuffer->MaxServiceTicketAge.QuadPart /
                                                       (LONGLONG)(10000000L) );
                        //
                        // using minutes
                        //
                        dValue /= 60;

                    }

                    if ( Options & SCE_SYSTEM_SETTINGS ) {

                        pKerInfo->MaxServiceAge = dValue;

                    } else {

                        rc = ScepCompareAndSaveIntValue(
                                hSection,
                                L"MaxServiceAge",
                                (Options & SCE_GENERATE_ROLLBACK),
                                pKerInfo->MaxServiceAge,
                                dValue);
                    }

                    if ( SCESTATUS_SUCCESS == rc ) {

                        KerbValues[IDX_KERB_SERVICE] = 1;

                        if ( pBuffer->MaxClockSkew.HighPart == MINLONG &&
                             pBuffer->MaxClockSkew.LowPart == 0 ) {
                            //
                            // Maximum age value is MINLONG,0
                            //
                            dValue = SCE_FOREVER_VALUE;

                        }  else {

                            dValue = (DWORD) ( pBuffer->MaxClockSkew.QuadPart /
                                                           (LONGLONG)(10000000L) );
                            //
                            // using minutes
                            //
                            dValue /= 60;

                        }

                        if ( Options & SCE_SYSTEM_SETTINGS ) {

                            pKerInfo->MaxClockSkew = dValue;

                        } else {

                            rc = ScepCompareAndSaveIntValue(
                                    hSection,
                                    L"MaxClockSkew",
                                    (Options & SCE_GENERATE_ROLLBACK),
                                    pKerInfo->MaxClockSkew,
                                    dValue);
                        }

                        if ( SCESTATUS_SUCCESS == rc ) {

                            KerbValues[IDX_KERB_CLOCK] = 1;

                            //
                            // validate client
                            //
                            dValue = ( pBuffer->AuthenticationOptions & POLICY_KERBEROS_VALIDATE_CLIENT ) ? 1 : 0;

                            if ( Options & SCE_SYSTEM_SETTINGS ) {

                                pKerInfo->TicketValidateClient = dValue;

                            } else {

                                rc = ScepCompareAndSaveIntValue(
                                          hSection,
                                          L"TicketValidateClient",
                                          (Options & SCE_GENERATE_ROLLBACK),
                                          pKerInfo->TicketValidateClient,
                                          dValue);
                            }

                            if ( SCESTATUS_SUCCESS == rc ) {

                                KerbValues[IDX_KERB_VALIDATE] = 1;
                            }
                        }
                    }
                }
            }

            if ( !(Options & SCE_SYSTEM_SETTINGS) ) {

                if ( rc == SCESTATUS_SUCCESS ) {

                    ScepLogOutput3( 1, 0, SCEDLL_SAP_KERBEROS);
                } else {
                    ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                         SCEDLL_SAP_ERROR_KERBEROS);
                }
            }

            if ( pBuffer != &KerbTicketInfo ) {

                //
                // free the buffer
                //
                LsaFreeMemory((PVOID)pBuffer);
            }
        }

        if ( !(Options & SCE_SYSTEM_SETTINGS) ) {

            if ( SCESTATUS_SUCCESS != rc &&
                 !(Options & SCE_GENERATE_ROLLBACK) ) {

                for ( dValue=0; dValue<MAX_KERB_ITEMS; dValue++ ) {
                    if ( KerbValues[dValue] == SCE_ERROR_VALUE ) {

                        ScepCompareAndSaveIntValue(
                                  hSection,
                                  KerbItems[dValue],
                                  FALSE,
                                  SCE_NO_VALUE,
                                  SCE_ERROR_VALUE
                                  );
                    }
                }
            }

            //
            // close the section
            //

            SceJetCloseSection(&hSection, TRUE);

        }
    }

    LsaClose( lsaHandle );

    if ( ( rc == SCESTATUS_PROFILE_NOT_FOUND) ||
        ( rc == SCESTATUS_RECORD_NOT_FOUND) ) {
       rc = SCESTATUS_SUCCESS;
    }

    return(rc);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\misc.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    misc.cpp

Abstract:

    SCE Engine miscellaneous APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997 created

--*/
#include "headers.h"
#include "serverp.h"
#include <ntregapi.h>
#include <userenv.h>
#include <ntlsa.h>
#include <io.h>
#pragma hdrstop

extern "C" {
#include "dumpnt.h"

}

//#define SCE_DBG      1

NTSTATUS
ScepGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    );

DWORD
ScepGetEnvVarsFromProfile(
    IN PWSTR UserProfileName,
    IN PCWSTR VarName1,
    IN PCWSTR VarName2 OPTIONAL,
    OUT PWSTR *StrValue
    );



NTSTATUS
ScepOpenSamDomain(
    IN ACCESS_MASK  ServerAccess,
    IN ACCESS_MASK  DomainAccess,
    OUT PSAM_HANDLE pServerHandle,
    OUT PSAM_HANDLE pDomainHandle,
    OUT PSID        *DomainSid,
    OUT PSAM_HANDLE pBuiltinDomainHandle OPTIONAL,
    OUT PSID        *BuiltinDomainSid OPTIONAL
    )
/*
Routine Description

    This routine opens the local SAM server for account domain and builtin
    domain. The domain handles and their SIDs are returned.

*/
{
    NTSTATUS                     NtStatus;

    PPOLICY_ACCOUNT_DOMAIN_INFO  PolicyAccountDomainInfo=NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO  PolicyPrimaryDomainInfo=NULL;
    UNICODE_STRING               AccountDomainName;
    OBJECT_ATTRIBUTES            ObjectAttributes;
    SID_IDENTIFIER_AUTHORITY     NtAuthority = SECURITY_NT_AUTHORITY;

    if ( !pServerHandle || !pDomainHandle || !DomainSid ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // initialize output buffers
    //
    *pServerHandle = NULL;
    *pDomainHandle = NULL;
    *DomainSid = NULL;

    if ( pBuiltinDomainHandle ) {
        *pBuiltinDomainHandle = NULL;
    }
    if ( BuiltinDomainSid ) {
        *BuiltinDomainSid = NULL;
    }

    //
    // Get information for the account domain
    //

    NtStatus = ScepGetLsaDomainInfo(
                   &PolicyAccountDomainInfo,
                   &PolicyPrimaryDomainInfo
                   );

    if (!NT_SUCCESS(NtStatus)) {
        return( NtStatus );
    }
    AccountDomainName = PolicyAccountDomainInfo->DomainName;

    //
    // Connect to the local SAM server
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );

    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  pServerHandle,
                  ServerAccess,
                  &ObjectAttributes
                  );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Lookup the DomainSid for AccountDomainName
        //

        NtStatus = SamLookupDomainInSamServer(
                      *pServerHandle,
                      &AccountDomainName,
                      DomainSid
                      );

        if ( NT_SUCCESS(NtStatus) ) {
            //
            // open the account domain
            //
            NtStatus = SamOpenDomain(
                          *pServerHandle,
                          DomainAccess,
                          *DomainSid,
                          pDomainHandle
                          );
            if ( NT_SUCCESS(NtStatus) && BuiltinDomainSid != NULL ) {
                //
                // build the builtin domain sid
                //
                NtStatus = RtlAllocateAndInitializeSid(
                                &NtAuthority,
                                1,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                BuiltinDomainSid
                                );

                if ( NT_SUCCESS(NtStatus) && pBuiltinDomainHandle != NULL ) {
                    //
                    // open the builtin domain
                    //
                    NtStatus = SamOpenDomain(
                                    *pServerHandle,
                                    DomainAccess,
                                    *BuiltinDomainSid,
                                    pBuiltinDomainHandle
                                    );
                }
            }
        }
    }

    //
    // free memory and clean up
    //
    if ( PolicyAccountDomainInfo != NULL ) {
        LsaFreeMemory( PolicyAccountDomainInfo );
    }
    if ( PolicyPrimaryDomainInfo != NULL ) {
        LsaFreeMemory( PolicyPrimaryDomainInfo );
    }

    if ( !NT_SUCCESS(NtStatus)) {

        SamCloseHandle( *pDomainHandle );
        *pDomainHandle = NULL;

        if ( pBuiltinDomainHandle ) {
            SamCloseHandle( *pBuiltinDomainHandle );
            *pBuiltinDomainHandle = NULL;
        }
        SamCloseHandle( *pServerHandle );
        *pServerHandle = NULL;

        SamFreeMemory(*DomainSid);
        *DomainSid = NULL;

        if ( BuiltinDomainSid ) {
            SamFreeMemory(*BuiltinDomainSid);
            *BuiltinDomainSid = NULL;
        }

    }
    return(NtStatus);

}



NTSTATUS
ScepLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSCE_NAME_LIST NameList,
    OUT PUNICODE_STRING *Names,
    OUT PULONG *RIDs,
    OUT PSID_NAME_USE *Use,
    OUT PULONG CountOfName
    )
/* ++
Routine Description:

    This routine looks up one or more names in the SAM account domain and
    returns the relative IDs for each name in the list. The name list may
    be user list, group list, or alias list.

Arguments:

    DomainHandle - SAM handle to the account domain

    NameList    -- The list of names

    Names        - Translated UNICODE_STRING names. The name list must be freed by

    RIDs        -- List of relative IDs for each name

    Use         -- List of type for each name

    CoutnOfName  - The number of names in the list

Return value:

    NTSTATUS
-- */
{
    PSCE_NAME_LIST   pUser;
    ULONG           cnt;
    NTSTATUS        NtStatus=ERROR_SUCCESS;
    PUNICODE_STRING pUnicodeName=NULL;


    UNICODE_STRING uName;
    LPTSTR pTemp;

    //
    // Count how many names in the list
    //

    for (pUser=NameList, cnt=0;
         pUser != NULL;
         pUser = pUser->Next) {

        if ( pUser->Name == NULL ) {
            continue;
        }
        //
        // note, this may be bigger than supposed to
        //
        cnt++;
    }

    if ( cnt > 0 ) {
        //
        // Allocate memory for UNICODE_STRING names
        //
        pUnicodeName = (PUNICODE_STRING)RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            cnt * sizeof (UNICODE_STRING)
                            );
        if ( pUnicodeName == NULL ) {
            NtStatus = STATUS_NO_MEMORY;
            cnt = 0;
            goto Done;
        }

        //
        // Initialize each UNICODE_STRING
        //
        for (pUser=NameList, cnt=0;
             pUser != NULL;
             pUser = pUser->Next) {

            if ( pUser->Name == NULL ) {
                continue;
            }

            pTemp = wcschr(pUser->Name, L'\\');

            if ( pTemp ) {

                uName.Buffer = pUser->Name;
                uName.Length = ((USHORT)(pTemp-pUser->Name))*sizeof(TCHAR);

                if ( !ScepIsDomainLocal(&uName) ) {
                    ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pUser->Name);
                    continue;
                }
                pTemp++;
            } else {
                pTemp = pUser->Name;
            }

            RtlInitUnicodeString(&(pUnicodeName[cnt]), pTemp);

            cnt++;
        }

        // lookup
        NtStatus = SamLookupNamesInDomain(
                        DomainHandle,
                        cnt,
                        pUnicodeName,
                        RIDs,
                        Use
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, pUnicodeName);
            pUnicodeName = NULL;
        }
    }
Done:

    *CountOfName = cnt;
    *Names = pUnicodeName;

    return(NtStatus);
}


NTSTATUS
ScepGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.

    PolicyPrimaryDomainInfo - Receives a pointer to a
        POLICY_PRIMARY_DOMAIN_INFO structure containing the Primary
        domain info.


Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS Status, IgnoreStatus;

    LSA_HANDLE PolicyHandle;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;

    //
    // Open the policy database
    //

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( NULL,
                            &PolicyObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );
    if ( NT_SUCCESS(Status) ) {

        //
        // Query the account domain information
        //

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            (PVOID *)PolicyAccountDomainInfo );

        if ( NT_SUCCESS(Status) ) {

            //
            // Query the Primary domain information
            //

            Status = LsaQueryInformationPolicy( PolicyHandle,
                                                PolicyPrimaryDomainInformation,
                                                (PVOID *)PolicyPrimaryDomainInfo );
        }

        IgnoreStatus = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(Status);
}



VOID
ScepConvertLogonHours(
    IN PSCE_LOGON_HOUR   pLogonHours,
    OUT PUCHAR LogonHourBitMask
    )
/* ++
Routine Description:

    This routine converted the logon hour range in hours (for example, 7-20)
    to logon hour bit mask (for example, 0001 1111 1111 1111 1000 0000,
    for one day).


Arguments:

    pLogonHours      -  The logon hour range (in hours)

    LogonHourBitMask -  The converted logon hour bit mask. Each bit represents
                        an hour. There are total 21 bytes (21*8 bits in this
                        argument, which represents a week (7 * 24 = 21 * 8).
Return value:

    None
-- */
{   PSCE_LOGON_HOUR  pTemp;
    CHAR            BitMask[3]={0,0,0};
    ULONG           j;

    for ( pTemp=pLogonHours; pTemp != NULL; pTemp=pTemp->Next ) {

        for (j=pTemp->Start; j<pTemp->End; j++)
            BitMask[j / 8] |= 1 << (j % 8);
    }

    for ( j=0; j<7; j++ )
        strncpy((CHAR *)&(LogonHourBitMask[j*3]), BitMask,3);

}


DWORD
ScepConvertToSceLogonHour(
    IN PUCHAR LogonHourBitMask,
    OUT PSCE_LOGON_HOUR *pLogonHours
    )
/* ++
Routine Description:

    This routine converted the logon hour bit mask (for example,
    0001 1111 1111 1111 1000 0000 for one day) to SCE_LOGON_HOUR type,
    which stores the logon hour range (start, end).


Arguments:

    LogonHourBitMask -  The logon hour bit mask to convert. Each bit represents
                        an hour. There are total 21 bytes (21*8 bits in this
                        argument, which represents a week (7 * 24 = 21 * 8).

    pLogonHours      -  The logon hour range (in hours)

Return value:

    None
-- */
{
    BOOL    findStart = TRUE;
    DWORD   i, j, rc=NO_ERROR;
    DWORD   start=0,
            end=0;
    LONG   value;

    PSCE_LOGON_HOUR pLogon=NULL;

    if (pLogonHours == NULL )
        return(ERROR_INVALID_PARAMETER);


    for ( i=3; i<6; i++)
        for ( j=0; j<8; j++) {
            if ( findStart )
                value = 1;
            else
                value = 0;

            if ( (LogonHourBitMask[i] & (1 << j)) == value ) {

                if ( findStart ) {
                    start = (i-3)*8 + j;
                    findStart = FALSE;
                } else {
                    end = (i-3)*8 + j;
                    findStart = TRUE;
                }
                if ( findStart ) {
                    //
                    // find a pair
                    //
                    pLogon = (PSCE_LOGON_HOUR)ScepAlloc( (UINT)0, sizeof(SCE_LOGON_HOUR));
                    if ( pLogon == NULL ) {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                        return(rc);
                    }
                    pLogon->Start = start;
                    pLogon->End = end;
                    pLogon->Next = *pLogonHours;
                    *pLogonHours = pLogon;
                    pLogon = NULL;

                }

            }

        }

    if ( findStart == FALSE ) {
        // find start but not end, which means end=24
        end = 24;
        pLogon = (PSCE_LOGON_HOUR)ScepAlloc( (UINT)0, sizeof(SCE_LOGON_HOUR));
        if ( pLogon == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            return(rc);
        }
        pLogon->Start = start;
        pLogon->End = end;
        pLogon->Next = *pLogonHours;
        *pLogonHours = pLogon;
        pLogon = NULL;

    }

    return(rc);
}



NTSTATUS
ScepGetGroupsForAccount(
    IN SAM_HANDLE       DomainHandle,
    IN SAM_HANDLE       BuiltinDomainHandle,
    IN SAM_HANDLE       UserHandle,
    IN PSID             AccountSid,
    OUT PSCE_NAME_LIST   *GroupList
    )
/* ++
Routine Description:

    This routine queries the user's group membership.

Arguments:

    DomainHandle    - The SAM handle of the SAM account domain

    BuiltindomainHandle - The SAM builtin domain handle

    UserHandle - The SAM account handle for the user

    AccountSid - The SID for the user

    GroupList       - The list of groups the user belongs to

Return value:

    NTSTATUS

-- */
{
    NTSTATUS            NtStatus=ERROR_SUCCESS;

    ULONG               GroupCount=0,
                        AliasCount=0;
    PULONG              Aliases=NULL;
    PGROUP_MEMBERSHIP   GroupAttributes=NULL;
    PULONG              GroupIds=NULL;
    PUNICODE_STRING     Names=NULL;
    PSID_NAME_USE       Use=NULL;

    DWORD               i;


    NtStatus = SamGetGroupsForUser(
                    UserHandle,
                    &GroupAttributes,
                    &GroupCount
                    );

    if ( GroupCount == 0 )
        NtStatus = ERROR_SUCCESS;

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    //
    // See what local groups the account belongs to.
    // account domain
    //

    NtStatus = SamGetAliasMembership(
                    DomainHandle,
                    1,
                    &AccountSid,
                    &AliasCount,
                    &Aliases );

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    if ( AliasCount != 0 || GroupCount != 0 ) {

        //
        // process each group's name in account domain
        //

        GroupIds = (PULONG)ScepAlloc((UINT)0,
                     (GroupCount+AliasCount)*sizeof(ULONG));

        if ( GroupIds == NULL ) {
            NtStatus = STATUS_NO_MEMORY;
            goto Done;
        }

        for ( i=0; i<GroupCount; i++)
            GroupIds[i] = GroupAttributes[i].RelativeId;

        for ( i=0; i<AliasCount; i++)
            GroupIds[i+GroupCount] = Aliases[i];

    }

    SamFreeMemory(GroupAttributes);
    GroupAttributes = NULL;

    SamFreeMemory(Aliases);
    Aliases = NULL;

    if ( AliasCount != 0 || GroupCount != 0 ) {

        // lookup names
        NtStatus = SamLookupIdsInDomain(
                        DomainHandle,
                        GroupCount+AliasCount,
                        GroupIds,
                        &Names,
                        &Use
                        );

        if ( !NT_SUCCESS(NtStatus) )
            goto Done;
    }

    for ( i=0; i<GroupCount+AliasCount; i++) {
        if ( GroupIds[i] == DOMAIN_GROUP_RID_USERS )
            continue;
        switch (Use[i]) {
        case SidTypeGroup:
        case SidTypeAlias:
        case SidTypeWellKnownGroup:
            if ( ScepAddToNameList(GroupList, Names[i].Buffer, Names[i].Length/2) != NO_ERROR) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }
            break;
        default:
            break;
        }
    }

    if ( GroupIds ) {
        ScepFree(GroupIds);
        GroupIds = NULL;
    }

    if ( Names ) {
        SamFreeMemory(Names);
        Names = NULL;
    }

    if ( Use ) {
        SamFreeMemory(Use);
        Use = NULL;
    }

    //
    // check the builtin domain for alias membership
    //

    AliasCount=0;
    NtStatus = SamGetAliasMembership(
                    BuiltinDomainHandle,
                    1,
                    &AccountSid,
                    &AliasCount,
                    &Aliases );

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    if ( AliasCount > 0 ) {

        NtStatus = SamLookupIdsInDomain(
                        BuiltinDomainHandle,
                        AliasCount,
                        Aliases,
                        &Names,
                        &Use
                        );

        if ( !NT_SUCCESS(NtStatus) )
            goto Done;
    }

    for ( i=0; i<AliasCount; i++) {
        if ( Aliases[i] == DOMAIN_GROUP_RID_USERS )
            continue;

        switch (Use[i]) {
        case SidTypeGroup:
        case SidTypeAlias:
        case SidTypeWellKnownGroup:
            if ( ScepAddToNameList(GroupList, Names[i].Buffer, Names[i].Length/2) != NO_ERROR) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }
            break;
        default:
            break;
        }
    }

Done:

    if ( GroupAttributes != NULL )
        SamFreeMemory(GroupAttributes);

    if ( Aliases != NULL )
        SamFreeMemory(Aliases);

    if ( GroupIds != NULL )
        ScepFree(GroupIds);

    if ( Names != NULL )
        SamFreeMemory(Names);

    if ( Use != NULL )
        SamFreeMemory(Use);

    return(NtStatus);

}



ACCESS_MASK
ScepGetDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN SECURITY_INFORMATION SecurityInfo
    )
/*++
Routine Description:

    Gets the access required to open object to be able to set or get the
    specified security info.

Arguments:

    OpenType  - Flag indicating if the object is to be opened to read or
                write the DACL

    SecurityInfo - The Security information to read/write.

Return value:

    Access mask

-- */
{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    return (DesiredAccess);
}


SCESTATUS
ScepGetProfileOneArea(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN DWORD dwAccountFormat,
    OUT PSCE_PROFILE_INFO *ppInfoBuffer
    )
/* ++
Routine Description:

    A wrapper routine for GetDatabaseInfo except it get information
    for one area at a call. This routine also logs the errors occur inside
    GetSecrityProfileInfo

Arguments:

    hProfile    - Handle to a profile

    ProfileType - The type of the profile

    Area - The security area to read info from

    ppInfoBuffer - output buffer for the info

Return value:

    SCESTATUS returned from GetDatabaseInfo

-- */
{
    SCESTATUS rc;
    PSCE_ERROR_LOG_INFO  pErrlog=NULL;


    rc = ScepGetDatabaseInfo(
        hProfile,
        ProfileType,
        Area,
        dwAccountFormat,
        ppInfoBuffer,
        &pErrlog
        );

    ScepLogWriteError( pErrlog, 1 );
    ScepFreeErrorLog( pErrlog );

    return(rc);
}


SCESTATUS
ScepGetOneSection(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR Name,
    IN SCETYPE ProfileType,
    OUT PVOID *ppInfo
    )
/* ++
Routine Description:

    This routine reads information for one or more Area and logs errors to
    the log file. This routine should be only used by the SCP engine and
    the SAP engine.

Arguments:

    hProfile    - Handle to a profile

    ProfileType - The type of the profile

    Area - The security area to read info from

    Subarea - The subarea to read info from

    ppInfo - output buffer for the info

Return value:

    SCESTATUS

-- */
{
    SCESTATUS rc;
    PSCE_ERROR_LOG_INFO  pErrlog=NULL;

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( Area == AREA_REGISTRY_SECURITY ||
         Area == AREA_FILE_SECURITY ||
         Area == AREA_DS_OBJECTS ) {

        rc = ScepGetObjectChildren(
                hProfile,
                ProfileType,
                Area,
                Name,
                SCE_ALL_CHILDREN,
                ppInfo,
                &pErrlog
                );
    } else {
        rc = ScepGetUserSection(
                hProfile,
                ProfileType,
                Name,
                ppInfo,
                &pErrlog
                );
    }

    ScepLogWriteError( pErrlog, 1 );
    ScepFreeErrorLog( pErrlog );

    return(rc);
}


NTSTATUS
ScepGetUserAccessAddress(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSID AccountSid,
    OUT PACCESS_MASK *pUserAccess,
    OUT PACCESS_MASK *pEveryone
    )
{
    NTSTATUS                NtStatus;
    PACL                    pAcl;
    BOOLEAN                 aclPresent, tFlag;
    DWORD                   i;
    PVOID                   pAce;
    PSID                    pSid;
    ACCESS_MASK             access;
    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    PSID EveryoneSid=NULL;


    if ( AccountSid == NULL || pUserAccess == NULL || pEveryone == NULL )
        return(STATUS_INVALID_PARAMETER);

    *pUserAccess = NULL;
    *pEveryone = NULL;

    if ( pSecurityDescriptor == NULL )
        return(STATUS_SUCCESS);

    NtStatus = RtlGetDaclSecurityDescriptor(
                pSecurityDescriptor,
                &aclPresent,
                &pAcl,
                &tFlag);

    if ( NT_SUCCESS(NtStatus) )

        NtStatus = RtlAllocateAndInitializeSid(
                        &WorldAuth,
                        1,
                        SECURITY_CREATOR_OWNER_RID,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        &EveryoneSid );

    if ( NT_SUCCESS(NtStatus) ) {

        if ( pAcl != NULL && aclPresent ) {

            for ( i=0; i < pAcl->AceCount; i++) {
                NtStatus = RtlGetAce( pAcl, i, &pAce );
                if ( !NT_SUCCESS( NtStatus ) )
                    break;

                access = 0;
                pSid = NULL;

                switch ( ((PACE_HEADER)pAce)->AceType ) {
                case ACCESS_ALLOWED_ACE_TYPE:
                    pSid = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                    access = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

                    if ( EqualSid( AccountSid, pSid ) )
                         *pUserAccess = &(((PACCESS_ALLOWED_ACE)pAce)->Mask);

                    else if ( EqualSid( EveryoneSid, pSid) )
                        *pEveryone = &(((PACCESS_ALLOWED_ACE)pAce)->Mask);

                    break;

                case ACCESS_DENIED_ACE_TYPE:
// do not look for denied ace type because it is not used here
//                    pSid = (PSID)&((PACCESS_DENIED_ACE)pAce)->SidStart;
//                    access = ((PACCESS_DENIED_ACE)pAce)->Mask;
                    break;
                default:
                    break;
                }

                if ( *pUserAccess != NULL && *pEveryone != NULL )
                    // stop the loop because both are found
                    break;
            }
        }
    }

    //
    // free EveryoneSid
    //
    if (EveryoneSid) {
        RtlFreeSid(EveryoneSid);
        EveryoneSid = NULL;
    }
    return(NtStatus);
}

BOOL
ScepLastBackSlash(
    IN PWSTR Name
    )
{
    if (Name == NULL )
        return(FALSE);

    if ( Name[wcslen(Name)-1] == L'\\')
        return(TRUE);
    else
        return(FALSE);

}


DWORD
ScepGetUsersHomeDirectory(
    IN UNICODE_STRING AssignedHomeDir,
    IN PWSTR UserProfileName,
    OUT PWSTR *UserHomeDir
    )
/*++
Routine Description:

    This routine gets user's default home directory. The home directory is
    determined 1) if it is assigned in the user's object (user profile), 2)
    if there is a HomePath environment variable defined for the user, and
    3). Harcoded.

Arguments:

    AssignedHomeDir - The home directory explicitly assigned in the user's
                      object.

    UserProfileName - The user's environment profile name

    UserHomeDir - The returned home directory for the user

Return Value:

    Win32 error code.

--*/
{
    DWORD                Win32rc=NO_ERROR;
    PWSTR                StrValue=NULL;

    PWSTR                SystemRoot=NULL;
    DWORD                DirSize=0;

    *UserHomeDir = NULL;

    //
    // if there is a home directory assigned in the user profile, use it.
    //
    if ( AssignedHomeDir.Length > 0 && AssignedHomeDir.Buffer != NULL ) {
        *UserHomeDir = (PWSTR)ScepAlloc( LMEM_ZEROINIT, AssignedHomeDir.Length+2);
        if ( *UserHomeDir == NULL )
            return(ERROR_NOT_ENOUGH_MEMORY);

        wcsncpy(*UserHomeDir, AssignedHomeDir.Buffer, AssignedHomeDir.Length/2);
        return(NO_ERROR);
    }

    //
    // Home directory is NULL in user profile, the HomePath environment
    // is searched.
    //

    Win32rc = ScepGetNTDirectory( &SystemRoot, &DirSize, SCE_FLAG_WINDOWS_DIR );
    if ( Win32rc != NO_ERROR ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_QUERY_INFO, L"%WinDir%");
        return(Win32rc);
    }

    Win32rc = ScepGetEnvVarsFromProfile(
                        UserProfileName,
                        L"HomePath",
                        NULL,
                        &StrValue
                        );

    if ( Win32rc == NO_ERROR && StrValue != NULL ) {
        *UserHomeDir = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (wcslen(StrValue)+3)*sizeof(WCHAR));
        if ( *UserHomeDir == NULL )
            Win32rc = ERROR_NOT_ENOUGH_MEMORY;
        else {
            swprintf(*UserHomeDir+1, L":%s", StrValue);
            **UserHomeDir = SystemRoot[0];
        }
    } else
        Win32rc = NO_ERROR; // do not care if can't get environment variable's value

    if ( SystemRoot != NULL )
        ScepFree(SystemRoot);

    if ( StrValue != NULL )
        ScepFree( StrValue );

    return(Win32rc);
}


DWORD
ScepGetEnvVarsFromProfile(
    IN PWSTR UserProfileName,
    IN PCWSTR VarName1,
    IN PCWSTR VarName2 OPTIONAL,
    OUT PWSTR *StrValue
    )
{
    DWORD     rc;
    DWORD     RegType;


    rc = SceAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, NULL);

    if ( rc == ERROR_SUCCESS ) {
        rc = RegLoadKey(HKEY_USERS, L"TEMP", UserProfileName);

        if ( rc == ERROR_SUCCESS ) {
            rc = ScepRegQueryValue(
                     HKEY_USERS,
                     L"TEMP\\Environment",
                     VarName1,
                     (PVOID *)StrValue,
                     &RegType
                     );

            if ( rc != ERROR_SUCCESS && VarName2 != NULL ) {
                rc = ScepRegQueryValue(
                         HKEY_USERS,
                         L"TEMP\\Environment",
                         VarName2,
                         (PVOID *)StrValue,
                         &RegType
                         );
            }

            RegUnLoadKey(HKEY_USERS, L"TEMP");

        } else { //if ( rc == ERROR_ALREADY_IN_USE) {
            //
            // this profile already in use. Open the one in HKEY_CURRENT_USER
            //
            rc = ScepRegQueryValue(
                      HKEY_CURRENT_USER,
                      L"Environment",
                      VarName1,
                      (PVOID *)StrValue,
                      &RegType
                      );

            if ( rc != ERROR_SUCCESS && VarName2 != NULL ) {
                rc = ScepRegQueryValue(
                         HKEY_CURRENT_USER,
                         L"Environment",
                         VarName2,
                         (PVOID *)StrValue,
                         &RegType
                         );
            }

        }
        SceAdjustPrivilege(SE_RESTORE_PRIVILEGE, FALSE, NULL);
    }

    return(rc);
}


DWORD
ScepGetUsersTempDirectory(
    IN PWSTR UserProfileName,
    OUT PWSTR *UserTempDir
    )
/*++
Routine Description:

    This routine returns the user's temp directory. Temp directory for a
    user is determined 1) environment variable "TEMP" or "TMP" defined
    in the user's environment profile, or 2) Harcoded to %systemDrive%\TEMP

Arguments:

    UserProfileName - The user's environment profile name

    UserTempDir  - The returned temp directory for the user

Return Value:

    Win32 error code

--*/
{
    DWORD   rc=NO_ERROR;
    PWSTR   StrValue=NULL;

    PWSTR   SystemRoot=NULL;
    DWORD   DirSize=0;


    //
    // query the TEMP/TMP environment variable(s)
    //
    if ( UserProfileName != NULL ) {
        ScepGetEnvVarsFromProfile(
                UserProfileName,
                L"TEMP",
                L"TMP",
                &StrValue
                );
    }
    if ( StrValue != NULL ) {
        //
        // find the setting for temp dir
        //

        if ( wcsstr(_wcsupr(StrValue), L"%") != NULL ) {

            rc = ScepTranslateFileDirName( StrValue, UserTempDir );
        }
        if ( rc == NO_ERROR ) {
            ScepFree(StrValue);
        } else
            *UserTempDir = StrValue;

        StrValue = NULL;

    } else {
        //
        // hardcoded to %SystemDrive%\TEMP
        //
        rc = ScepGetNTDirectory( &SystemRoot, &DirSize, SCE_FLAG_WINDOWS_DIR );
        if ( rc != NO_ERROR ) {
            ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_INFO, L"%WinDir%");
            return(rc);
        }
        *UserTempDir = (PWSTR)ScepAlloc( 0, 8*sizeof(WCHAR));
        if ( *UserTempDir == NULL )
            rc = ERROR_NOT_ENOUGH_MEMORY;
        else {
            swprintf(*UserTempDir+1, L":\\TEMP");
            **UserTempDir = SystemRoot[0];
        }
    }

    if (SystemRoot != NULL )
        ScepFree(SystemRoot);

    return(rc);
}


SCESTATUS
ScepGetRegKeyCase(
    IN PWSTR ObjName,
    IN DWORD BufOffset,
    IN DWORD BufLen
    )
{
    DWORD Win32rc;
    HKEY hKey=NULL;

    PWSTR Buffer=NULL;
    TCHAR Buffer1[MAX_PATH];
    DWORD BufSize, index;
    FILETIME        LastWriteTime;


    if ( BufOffset <= 0 || BufLen <= 0 ) {
        _wcsupr(ObjName);
        return(SCESTATUS_SUCCESS);
    }

    Buffer = (PWSTR)ScepAlloc(LMEM_ZEROINIT, BufOffset*sizeof(WCHAR));

    if ( Buffer != NULL ) {

        wcsncpy(Buffer, ObjName, BufOffset-1);

        Win32rc = ScepOpenRegistryObject(
                        SE_REGISTRY_KEY,
                        Buffer,
                        KEY_READ,
                        &hKey
                        );
        if ( Win32rc == NO_ERROR ) {

            index = 0;
            //
            // enumerate all subkeys of the key
            //
            do {
                memset(Buffer1, '\0', MAX_PATH*sizeof(WCHAR));
                BufSize = MAX_PATH;

                Win32rc = RegEnumKeyEx(hKey,
                                index,
                                Buffer1,
                                &BufSize,
                                NULL,
                                NULL,
                                NULL,
                                &LastWriteTime);

                if ( Win32rc == ERROR_SUCCESS ) {
                    index++;
                    //
                    // find if the subkey matches the object name
                    //
                    if ( _wcsicmp(ObjName+BufOffset, Buffer1) == 0 )
                        break;
                }

            } while ( Win32rc != ERROR_NO_MORE_ITEMS );

            RegCloseKey(hKey);

            if ( Win32rc == ERROR_SUCCESS ) {
                //
                // find it
                //
                if ( BufSize > BufLen )
                    BufSize = BufLen;

                wcsncpy(ObjName+BufOffset, Buffer1, BufSize);
                *(ObjName+BufOffset+BufSize) = L'\0';

            } else if ( Win32rc == ERROR_NO_MORE_ITEMS) {
                //
                // does not find it
                //
                Win32rc = ERROR_FILE_NOT_FOUND;
            }

        }
        ScepFree(Buffer);

    } else
        Win32rc = ERROR_NOT_ENOUGH_MEMORY;

    if ( Win32rc != NO_ERROR ) {
        //
        // convert everything to uppercase
        //
        _wcsupr(ObjName+BufOffset);
    }

    return(ScepDosErrorToSceStatus(Win32rc));

}


SCESTATUS
ScepGetFileCase(
    IN PWSTR ObjName,
    IN DWORD BufOffset,
    IN DWORD BufLen
    )
{

    intptr_t            hFile;
    struct _wfinddata_t    FileInfo;

    hFile = _wfindfirst(ObjName, &FileInfo);

    if ( hFile != -1 ) {

        wcsncpy(ObjName+BufOffset, FileInfo.name, BufLen);

        _findclose(hFile);

    } else
        return(ScepDosErrorToSceStatus(GetLastError()));

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepGetGroupCase(
    IN OUT PWSTR GroupName,
    IN DWORD Length
    )
{
    NTSTATUS                        NtStatus;

    SAM_HANDLE                      ServerHandle=NULL,
                                    DomainHandle=NULL,
                                    BuiltinDomainHandle=NULL,
                                    ThisDomain=NULL,
                                    GroupHandle=NULL;

    PSID                            DomainSid=NULL,
                                    BuiltinDomainSid=NULL;
    UNICODE_STRING                  Name;
    PULONG              GrpId=NULL;
    PSID_NAME_USE       GrpUse=NULL;
    PVOID               pNameInfo=NULL;

    NtStatus = ScepOpenSamDomain(
                        SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                        DOMAIN_READ | DOMAIN_EXECUTE,
                        &ServerHandle,
                        &DomainHandle,
                        &DomainSid,
                        &BuiltinDomainHandle,
                        &BuiltinDomainSid
                       );
    if ( NT_SUCCESS(NtStatus) ) {

        RtlInitUnicodeString(&Name, GroupName);

        NtStatus = SamLookupNamesInDomain(
                        DomainHandle,
                        1,
                        &Name,
                        &GrpId,
                        &GrpUse
                        );
        ThisDomain = DomainHandle;

        if ( NtStatus == STATUS_NONE_MAPPED ) {
            //
            // not found in account domain. Lookup in the builtin domain
            //
            NtStatus = SamLookupNamesInDomain(
                            BuiltinDomainHandle,
                            1,
                            &Name,
                            &GrpId,
                            &GrpUse
                            );
            ThisDomain=BuiltinDomainHandle;
        }

        if ( NT_SUCCESS(NtStatus) ) {

            switch ( GrpUse[0] ) {
            case SidTypeGroup:
                NtStatus = SamOpenGroup(
                                ThisDomain,
                                GROUP_READ | GROUP_EXECUTE,
                                GrpId[0],
                                &GroupHandle
                                );
                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = SamQueryInformationGroup(
                                    GroupHandle,
                                    GroupNameInformation,
                                    &pNameInfo
                                    );
                }

                break;
            case SidTypeAlias:
                NtStatus = SamOpenAlias(
                                ThisDomain,
                                ALIAS_READ | ALIAS_EXECUTE,
                                GrpId[0],
                                &GroupHandle
                                );
                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = SamQueryInformationAlias(
                                    GroupHandle,
                                    AliasNameInformation,
                                    &pNameInfo
                                    );
                }
                break;
            default:
                NtStatus = STATUS_NONE_MAPPED;
                break;
            }

            if ( NT_SUCCESS(NtStatus) ) {
                //
                // get name information
                //
                if ( ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Buffer != NULL &&
                     ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Length > 0 ) {

                   if ( Length > (DWORD)(((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Length/2) ) {

                       wcsncpy(GroupName, ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Buffer,
                                   ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Length/2);
                   } else {
                       wcsncpy(GroupName, ((PGROUP_NAME_INFORMATION)pNameInfo)->Name.Buffer,
                                   Length);
                   }

                } else
                    NtStatus = STATUS_NONE_MAPPED;

                SamFreeMemory(pNameInfo);
            }

            if (GroupHandle)
                SamCloseHandle(GroupHandle);

            SamFreeMemory(GrpId);
            SamFreeMemory(GrpUse);
        }
        SamCloseHandle( DomainHandle );
        SamCloseHandle( BuiltinDomainHandle );
        SamCloseHandle( ServerHandle );

        SamFreeMemory(DomainSid);
        RtlFreeSid(BuiltinDomainSid);
    }

    return(ScepDosErrorToSceStatus( RtlNtStatusToDosError(NtStatus) ));
}



VOID
ScepPrintSecurityDescriptor(
   IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
   IN BOOL ToDumpSD
   )
{
    if (pSecurityDescriptor != NULL) {

        if ( ToDumpSD )
            DumpSECURITY_DESCRIPTOR(pSecurityDescriptor);
        else
            printf("Security Descriptor\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\pfset.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    pfset.cpp

Abstract:

    Routines to set info to the jet database.

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#include "headers.h"
#include "serverp.h"
#include "pfp.h"
#include "regvalue.h"
#pragma hdrstop

//#define SCE_DBG 1

SCESTATUS
ScepOpenPrevPolicyContext(
    IN PSCECONTEXT hProfile,
    OUT PSCECONTEXT *phPrevProfile
    );

SCESTATUS
ScepClosePrevPolicyContext(
    IN OUT PSCECONTEXT *phProfile
    );


SCESTATUS
ScepStartANewSection(
    IN PSCECONTEXT hProfile,
    IN OUT PSCESECTION *hSection,
    IN SCEJET_TABLE_TYPE ProfileType,
    IN PCWSTR SectionName
    )
/* ++
Routine Description:

    This routine open a JET section by Name. If the section exists, it is
    opened, else it is created.

Arguments:

    hProfile - The JET database handle

    hSection - the JET section handle to return

    ProfileType - the table to open

    SectionName - the JET section name

Return Value:

    SCESTATUS_SUCCESS

    SCESTATUS returned from  SceJetCloseSection,
                            SceJetAddSection,
                            SceJetOpenSection

-- */
{
    SCESTATUS  rc=SCESTATUS_SUCCESS;
    DOUBLE    SectionID;

    if ( *hSection != NULL ) {
        //
        // free the previous used section
        //
        rc = SceJetCloseSection( hSection, FALSE );
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // SceJetAddSection will seek for the section name first.
        // if a match is found, the section id is returned, else add it.
        // this is good for SAP profile.
        //
        rc = SceJetAddSection(
                hProfile,
                SectionName,
                &SectionID
                );
        if ( rc == SCESTATUS_SUCCESS ) {

            rc = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        ProfileType,
                        hSection
                        );
        }
    }
    return( rc );

}


SCESTATUS
ScepCompareAndSaveIntValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN BOOL bReplaceExistOnly,
    IN DWORD BaseValue,
    IN DWORD CurrentValue
    )
/* ++
Routine Description:

    This routine compares DWORD value system settings with the baseline profile
    settings. If there is mismatch or unknown, the entry is saved in the SAP
    profile.

Arguments:

    hSection - The JET section context

    Name    - The entry name

    BaseLine- The baseline profile value to compare with

    CurrentValue - The current system setting (DWORD value)

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS  rc;
    TCHAR     StrValue[12];

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( CurrentValue == SCE_NO_VALUE ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( ( CurrentValue == BaseValue) &&
         ( BaseValue != SCE_NO_VALUE) &&
         ( BaseValue != SCE_SNAPSHOT_VALUE) ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( bReplaceExistOnly &&
         (BaseValue == SCE_NO_VALUE) ) {
        return(SCESTATUS_SUCCESS);
    }

    memset(StrValue, '\0', 24);

    //
    // either mismatched/unknown
    // Save this entry
    //
    swprintf(StrValue, L"%d", CurrentValue);

    rc = SceJetSetLine( hSection, Name, FALSE, StrValue, wcslen(StrValue)*2, 0);

    switch ( BaseValue ) {
    case SCE_SNAPSHOT_VALUE:

        ScepLogOutput2(2, 0, StrValue);
        break;

    case SCE_NO_VALUE:

        if ( CurrentValue == SCE_ERROR_VALUE ) {
            ScepLogOutput3(2, 0, SCEDLL_STATUS_ERROR, Name);
        } else {
            ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
        }
        break;

    default:

        ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        break;
    }

#ifdef SCE_DBG
   wprintf(L"rc=%d, Section: %d, %s=%d\n", rc, (DWORD)(hSection->SectionID), Name, CurrentValue);
#endif
    return(rc);

}


SCESTATUS
ScepCompareAndSaveStringValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PWSTR BaseValue,
    IN PWSTR CurrentValue,
    IN DWORD CurrentLen
    )
/* ++
Routine Description:

    This routine compares system settings in string with the baseline profile
    settings. If there is mismatch or unknown, the entry is saved in the SAP
    profile.

Arguments:

    hSection - The section handle

    Name    - The entry name

    BaseLine- The baseline profile value to compare with

    CurrentValue - The current system setting

    CurrentLen - The length of the current setting

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS  rc;

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( CurrentValue == NULL )
        return(SCESTATUS_SUCCESS);

    rc = SceJetSetLine( hSection, Name, FALSE, CurrentValue, CurrentLen, 0);

    if ( BaseValue ) {
        if ( (ULONG_PTR)BaseValue == SCE_SNAPSHOT_VALUE ) {

            ScepLogOutput2(2, 0, CurrentValue);
        } else {

            ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        }
    } else {
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
    }

#ifdef SCE_DBG
    wprintf(L"rc=%d, Section: %d, %s=%s\n", rc, (DWORD)(hSection->SectionID), Name, CurrentValue);
#endif

    return(rc);

}


SCESTATUS
ScepSaveObjectString(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN BOOL  IsContainer,
    IN BYTE  Flag,
    IN PWSTR Value OPTIONAL,
    IN DWORD ValueLen
    )
/* ++
Routine Description:

    This routine writes registry/file settings to the JET section. Registry/
    file setting includes a flag (mismatch/unknown) and the security
    descriptor in text format. The object setting is saved in the format of
    1 byte flag followed by the Value.

Arguments:

    hSection - the JET section handle

    Name    - The entry name

    IsContainer - TRUE = The object is a container
                  FALSE = The object is not a container

    Flag - the flag for object's setting
                1 - Mismatch
                0 - Unknown

    Value - The security descriptor in text

    ValueLen - the length of the text security descriptor

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER

    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS rc;
    DWORD    Len;
    PWSTR    ValueToSet=NULL;


    if ( hSection == NULL ||
         Name == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Value != NULL )
        Len = ( ValueLen+1)*sizeof(WCHAR);
    else
        Len = sizeof(WCHAR);

    ValueToSet = (PWSTR)ScepAlloc( (UINT)0, Len+sizeof(WCHAR) );

    if ( ValueToSet == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    //
    // The first byte is the flag, the second byte is IsContainer (1,0)
    //
    *((BYTE *)ValueToSet) = Flag;

    *((CHAR *)ValueToSet+1) = IsContainer ? '1' : '0';

    if ( Value != NULL ) {
        swprintf(ValueToSet+1, L"%s", Value );
        ValueToSet[ValueLen+1] = L'\0';  //terminate this string
    } else {
        ValueToSet[1] = L'\0';
    }

    rc = SceJetSetLine( hSection, Name, FALSE, ValueToSet, Len, 0);

    switch ( Flag ) {
    case SCE_STATUS_CHILDREN_CONFIGURED:
    case SCE_STATUS_NOT_CONFIGURED:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
        break;
    case SCE_STATUS_ERROR_NOT_AVAILABLE:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_ERROR, Name);
        break;
    case SCE_STATUS_GOOD:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_MATCH, Name);
        break;
    case SCE_STATUS_NEW_SERVICE:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NEW, Name);
        break;
    case SCE_STATUS_NO_ACL_SUPPORT:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NOACL, Name);
        break;
    default:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        break;
    }

#ifdef SCE_DBG
    wprintf(L"rc=%d, Section: %d, %s=%s\n", rc, (DWORD)(hSection->SectionID), Name, ValueToSet);
#endif
    ScepFree( ValueToSet );

    return( rc );
}


SCESTATUS
ScepWriteNameListValue(
    IN LSA_HANDLE LsaPolicy OPTIONAL,
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSCE_NAME_LIST NameList,
    IN DWORD dwWriteOption,
    IN INT Status
    )
/* ++
Routine Description:

    This routine writes a key with a list of value to the JET section. The list
    of values is saved in a MULTI-SZ format which is separated by a NULL char and
    terminated by 2 NULLs. If the list is NULL, nothing is saved unless
    SaveEmptyList is set to TRUE, where a NULL value is saved with the key.

Arguments:

    hSection - the JET hsection handle

    Name - The key name

    NameList - the list of values

    SaveEmptyList - TRUE = save NULL value if the list is empty
                    FALSE = DO NOT save if the list is empty

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE

    SCESTATUS returned from SceJetSetLine

-- */
{   SCESTATUS    rc=SCESTATUS_SUCCESS;
    DWORD       TotalSize=0;
    PWSTR       Value=NULL;
    PSCE_NAME_LIST pName;
    PWSTR       pTemp=NULL;
    DWORD       Len;
    DWORD               i=0,j;
    DWORD               cntAllocated=0;
    SCE_TEMP_NODE       *tmpArray=NULL, *pa=NULL;
    PWSTR       SidString = NULL;


    for ( pName=NameList; pName != NULL; pName = pName->Next ) {

        if ( pName->Name == NULL ) {
            continue;
        }

        if ( dwWriteOption & SCE_WRITE_CONVERT ) {

            if ( i >= cntAllocated ) {
                //
                // array is not enough, reallocate
                //
                tmpArray = (SCE_TEMP_NODE *)ScepAlloc(LPTR, (cntAllocated+16)*sizeof(SCE_TEMP_NODE));

                if ( tmpArray ) {

                    //
                    // move pointers from the old array to the new array
                    //

                    if ( pa ) {
                        for ( j=0; j<cntAllocated; j++ ) {
                            tmpArray[j].Name = pa[j].Name;
                            tmpArray[j].Len = pa[j].Len;
                            tmpArray[j].bFree = pa[j].bFree;
                        }
                        ScepFree(pa);
                    }
                    pa = tmpArray;
                    tmpArray = NULL;


                    cntAllocated += 16;

                } else {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }
            }

            if ( LsaPolicy && wcschr(pName->Name, L'\\') ) {

                //
                // check if the name has a '\' in it, it should be translated to
                // *SID
                //
                pTemp = NULL;
                ScepConvertNameToSidString(LsaPolicy, pName->Name, FALSE, &pTemp, &Len);

                if ( pTemp ) {
                    pa[i].Name = pTemp;
                    pa[i].bFree = TRUE;
                } else {
                    pa[i].Name = pName->Name;
                    pa[i].bFree = FALSE;
                    Len= wcslen(pName->Name);
                }

            }

            else if (dwWriteOption & SCE_WRITE_LOCAL_TABLE &&
                     ScepLookupNameTable( pName->Name, &SidString ) ) {

                pa[i].Name = SidString;
                pa[i].bFree = TRUE;
                Len = wcslen(SidString);

            }

            else {
                pa[i].Name = pName->Name;
                pa[i].bFree = FALSE;
                Len = wcslen(pName->Name);
            }
            pa[i].Len = Len;

            TotalSize += Len + 1;
            i++;
        } else {

            TotalSize += wcslen(pName->Name)+1;
        }
    }

    TotalSize ++;

    if ( SCESTATUS_SUCCESS == rc ) {

        if ( TotalSize > 1 ) {
            Value = (PWSTR)ScepAlloc( 0, (TotalSize+1)*sizeof(WCHAR));
            if ( Value == NULL )
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        if ( TotalSize > 1 ) {

            pTemp = Value;

            if ( dwWriteOption & SCE_WRITE_CONVERT ) {

                for (j=0; j<i; j++) {
                    if ( pa[j].Name ) {

                        if ( Status == 3 ) {
                            ScepLogOutput2(2, 0, pa[j].Name);
                        }

                        wcsncpy(pTemp, pa[j].Name, pa[j].Len);
                        pTemp += pa[j].Len;
                        *pTemp = L'\0';
                        pTemp++;
                    }
                }

            } else {

                for ( pName=NameList; pName != NULL; pName = pName->Next ) {

                    if ( pName->Name == NULL ) {
                        continue;
                    }
                    if ( Status == 3 ) {
                        ScepLogOutput2(2, 0, pName->Name);
                    }

                    Len = wcslen(pName->Name);
                    wcsncpy(pTemp, pName->Name, Len);
                    pTemp += Len;
                    *pTemp = L'\0';
                    pTemp++;
                }
            }

            *pTemp = L'\0';

        } else
            TotalSize = 0;

        if ( TotalSize > 0 || (dwWriteOption & SCE_WRITE_EMPTY_LIST) ) {
            rc = SceJetSetLine(
                        hSection,
                        Name,
                        FALSE,
                        Value,
                        TotalSize*sizeof(WCHAR),
                        0
                        );

            switch ( Status ) {
            case 1:
                ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
                break;
            case 3:  // no analyze, already printed
                break;

            case 2:
                ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
                break;
            }

#ifdef SCE_DBG
            if ( Value != NULL )
                wprintf(L"rc=%d, Section: %d, %s=%s\n", rc, (DWORD)(hSection->SectionID), Name, Value);
            else
                wprintf(L"rc=%d, Section: %d, %s=", rc, (DWORD)(hSection->SectionID), Name);
#endif
        }

        if ( Value != NULL )
            ScepFree(Value);
    }

    if ( pa ) {

        for ( j=0; j<i; j++ ) {
            if ( pa[j].Name && pa[j].bFree ) {
                ScepFree(pa[j].Name);
            }
        }
        ScepFree(pa);
    }

    return(rc);
}


SCESTATUS
ScepWriteNameStatusListValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSCE_NAME_STATUS_LIST NameList,
    IN BOOL SaveEmptyList,
    IN INT Status
    )
/* ++
Routine Description:

    This routine writes a key with a list of values to the JET section. The list
    of values is saved in a MULTI-SZ format which is separated by a NULL char and
    terminated by 2 NULLs. If the list is NULL, nothing is saved unless
    SaveEmptyList is set to TRUE, where a NULL value is saved with the key.

    The format in each string in the MULTI-SZ value is a 2 bytes Status field
    followed by the Name field. This structure is primarily used for privileges

Arguments:

    hSection - the JET hsection handle

    Name - The key name

    NameList - the list of values

    SaveEmptyList - TRUE = save NULL value if the list is empty
                    FALSE = DO NOT save if the list is empty

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE

    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS    rc=SCESTATUS_SUCCESS;
    DWORD       TotalSize=0;
    PWSTR       Value=NULL;
    PSCE_NAME_STATUS_LIST pName;
    PWSTR       pTemp=NULL;
    DWORD       Len;


    for ( pName=NameList; pName != NULL; pName = pName->Next ) {
        //
        // Privilege value is stored in 2 bytes
        //
        TotalSize += 2;
        if ( pName->Name != NULL)
            TotalSize += wcslen(pName->Name);
        TotalSize ++;
    }
    TotalSize ++;

    if ( TotalSize > 1 ) {
        Value = (PWSTR)ScepAlloc( 0, (TotalSize+1)*sizeof(WCHAR));
        if ( Value == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        pTemp = Value;
        for ( pName=NameList; pName != NULL; pName = pName->Next ) {
            swprintf(pTemp, L"%02d", pName->Status);
            pTemp += 2;
            if ( pName->Name != NULL ) {
                Len = wcslen(pName->Name);
                wcsncpy(pTemp, pName->Name, Len);
                pTemp += Len;
            }
            *pTemp = L'\0';
            pTemp++;
        }
        *pTemp = L'\0';

    } else
        TotalSize = 0;

    if ( TotalSize > 0 || SaveEmptyList ) {
        rc = SceJetSetLine(
                    hSection,
                    Name,
                    FALSE,
                    Value,
                    TotalSize*sizeof(WCHAR),
                    0
                    );

        if ( Status == 1 )
            ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        else if ( Status == 2 ) {
            ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
        }

#ifdef SCE_DBG
        wprintf(L"rc=%d, Section: %d, %s=%s\n", rc, (DWORD)(hSection->SectionID), Name, Value);
#endif
        if ( Value != NULL )
            ScepFree(Value);
    }

    return(rc);
}


SCESTATUS
ScepWriteSecurityDescriptorValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo
    )
/* ++
Routine Description:

    This routine writes a key with security descriptor value to the JET section.
    The security descriptor is converted into text format based on the secrurity
    information passed in.

Arguments:

    hSection - the JET hsection handle

    Name - The key name

    pSD  - The security descriptor

    SeInfo - the part of the security information to save

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE

    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    PWSTR SDspec=NULL;
    ULONG SDsize = 0;


    if ( hSection == NULL || Name == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pSD != NULL && SeInfo != 0 ) {

        rc = ConvertSecurityDescriptorToText (
                    pSD,
                    SeInfo,
                    &SDspec,
                    &SDsize
                    );
        if ( rc == NO_ERROR ) {
            rc = ScepCompareAndSaveStringValue(
                        hSection,
                        Name,
                        NULL,
                        SDspec,
                        SDsize*sizeof(WCHAR)
                        );
            ScepFree(SDspec);
        }
    }
#ifdef SCE_DBG
    wprintf(L"SD==>rc=%d, Section: %d, %s\n", rc, (DWORD)(hSection->SectionID), Name);
#endif
    return(rc);
}


SCESTATUS
ScepDuplicateTable(
    IN PSCECONTEXT hProfile,
    IN SCEJET_TABLE_TYPE TableType,
    IN LPSTR DupTableName,
    OUT PSCE_ERROR_LOG_INFO *pErrlog
    )
/* ++
Routine Description:

    This routine copies table structure and data from a SCP/SMP/SAP table to
    a table specified by DupTableName. This is used for the SAP table backup.

Arguments:

    hProfile - the JET database handle

    TableType - the table type -SCEJET_TABLE_SCP
                                SCEJET_TABLE_SAP
                                SCEJET_TABLE_SMP

    DupTableName - The new table's name

    pErrlog - the error list

Return Value:

    SCESTATUS_SUCCESS

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc;

    SCECONTEXT   hProfile2;
    PSCESECTION  hSection1=NULL;
    PSCESECTION  hSection2=NULL;

    DOUBLE      SectionID=0, SaveID=0;
    DWORD       Actual;

    PWSTR       KeyName=NULL;
    PWSTR       Value=NULL;
    DWORD       KeyLen=0;
    DWORD       ValueLen=0;


    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // Create a SCP section handle. the section ID is a dummy one
    //
    rc = SceJetOpenSection(
                hProfile,
                (DOUBLE)1,
                TableType,
                &hSection1
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                              SCEERR_OPEN, L"SectionID 1");
        return(rc);
    }

    memset(&hProfile2, '\0', sizeof(SCECONTEXT));

    hProfile2.JetSessionID = hProfile->JetSessionID;
    hProfile2.JetDbID = hProfile->JetDbID;

    //
    // Delete the dup table then create it
    //
    SceJetDeleteTable(
            &hProfile2,
            DupTableName,
            TableType
            );
    rc = SceJetCreateTable(
            &hProfile2,
            DupTableName,
            TableType,
            SCEJET_CREATE_IN_BUFFER,
            NULL,
            NULL
            );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                               SCEERR_CREATE, L"backup table");
        goto Cleanup;
    }
    //
    // Move to the first line of the SCP table
    //
    JetErr = JetMove(hSection1->JetSessionID, hSection1->JetTableID, JET_MoveFirst, 0);

    while (JetErr == SCESTATUS_SUCCESS ) {

        //
        // get section ID
        //
        JetErr = JetRetrieveColumn(
                    hSection1->JetSessionID,
                    hSection1->JetTableID,
                    hSection1->JetColumnSectionID,
                    (void *)&SectionID,
                    8,
                    &Actual,
                    0,
                    NULL
                    );

        if ( JetErr != JET_errSuccess ) {
            ScepBuildErrorLogInfo( ERROR_READ_FAULT, pErrlog,
                                  SCEERR_QUERY_INFO,
                                  L"sectionID");
            rc = SceJetJetErrorToSceStatus(JetErr);
            break;
        }
#ifdef SCE_DBG
    printf("SectionID=%d, JetErr=%d\n", (DWORD)SectionID, JetErr);
#endif
        //
        // Prepare this Scep section
        //
        if ( SectionID != SaveID ) {
            SaveID = SectionID;
            //
            // Prepare this section
            //
            rc = SceJetOpenSection(
                        &hProfile2,
                        SectionID,
                        TableType,
                        &hSection2
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                                     SCEERR_OPEN_ID,
                                     (DWORD)SectionID);
                break;
            }
        }

        //
        // get buffer size for key and value
        //
        rc = SceJetGetValue(
                    hSection1,
                    SCEJET_CURRENT,
                    NULL,
                    NULL,
                    0,
                    &KeyLen,
                    NULL,
                    0,
                    &ValueLen);

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                  SCEERR_QUERY_VALUE, L"current row");
            break;
        }

        //
        // allocate memory
        //
        if ( KeyLen > 0 ) {
            KeyName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, KeyLen+2);
            if ( KeyName == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                break;
            }
        }
        if ( ValueLen > 0 ) {
            Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);
            if ( Value == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                break;
            }
        }
        //
        // get key and value
        //
        rc = SceJetGetValue(
                    hSection1,
                    SCEJET_CURRENT,
                    NULL,
                    KeyName,
                    KeyLen,
                    &KeyLen,
                    Value,
                    ValueLen,
                    &ValueLen);

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                  SCEERR_QUERY_VALUE,
                                  L"current row");
            break;
        }
#ifdef SCE_DBG
wprintf(L"\t%s=%s, rc=%d\n", KeyName, Value, rc);
#endif
        //
        // set this line to the dup table
        //
        rc = SceJetSetLine(
                    hSection2,
                    KeyName,
                    TRUE,
                    Value,
                    ValueLen,
                    0
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                 SCEERR_WRITE_INFO,
                                 KeyName);
            break;
        }
        ScepFree(KeyName);
        KeyName = NULL;

        ScepFree(Value);
        Value = NULL;

        //
        // Move to next line in the SCP table
        //
        JetErr = JetMove(hSection1->JetSessionID, hSection1->JetTableID, JET_MoveNext, 0);

    }

Cleanup:
    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // error occurs. Clean up the dup table
        //
#ifdef SCE_DBG
        printf("Error occurs. delete the dup table.\n");
#endif
        SceJetDeleteTable(
            &hProfile2,
            DupTableName,
            TableType
            );
    }

    if ( KeyName != NULL )
        ScepFree(KeyName);

    if ( Value != NULL )
        ScepFree(Value);

    SceJetCloseSection(&hSection1, TRUE);
    SceJetCloseSection(&hSection2, TRUE);

    return(rc);

}


SCESTATUS
ScepAddToPrivList(
    IN PSCE_NAME_STATUS_LIST *pPrivList,
    IN DWORD Rights,
    IN PWSTR Name,
    IN DWORD Len
    )
/* ++
Routine Description:

    This routine adds a privilege with optional group name to the list of
    privilege assignments

Arguments:

    pPrivList - the privilege list to add to. The structure of this list is
                    Status -- The privilege value
                    Name   -- The group's name where the priv is assigned
                              if Name is NULL, the privilege is directly assigned

    Rights    - The privilege(s) assigned through group Name

    Name      - The group's name

    Len       - The group's name length

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_NOT_ENOUGH_RESOURCE

-- */
{
    PSCE_NAME_STATUS_LIST pTemp;
    LONG                i;


    if ( pPrivList == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    for ( i=31; i>=0; i-- )
        if ( Rights & (1 << i) ) {
            for ( pTemp=*pPrivList; pTemp != NULL; pTemp = pTemp->Next ) {
                if ( (DWORD)i == pTemp->Status )
                    break;

            }
            if ( pTemp == NULL ) {
                //
                // add this one
                //
                pTemp = (PSCE_NAME_STATUS_LIST)ScepAlloc( LMEM_ZEROINIT, sizeof(SCE_NAME_STATUS_LIST));
                if ( pTemp == NULL )
                    return(SCESTATUS_NOT_ENOUGH_RESOURCE);

                if ( Name != NULL && Len > 0 ) {
                    pTemp->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));
                    if ( pTemp->Name == NULL) {
                        ScepFree(pTemp);
                        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
                    }
                    wcsncpy(pTemp->Name, Name, Len);
                }
#ifdef SCE_DBG
                wprintf(L"Add %d %s to privilege list\n", i, pTemp->Name);
#endif

                pTemp->Status = i;

                pTemp->Next = *pPrivList;
                *pPrivList = pTemp;
                pTemp = NULL;
            }
        }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepOpenPrevPolicyContext(
    IN PSCECONTEXT hProfile,
    OUT PSCECONTEXT *phPrevProfile
    )
{

    if ( hProfile == NULL || phPrevProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }


    *phPrevProfile = (PSCECONTEXT)LocalAlloc( LMEM_ZEROINIT, sizeof(SCECONTEXT));
    if ( *phPrevProfile == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    memcpy( *phPrevProfile, hProfile, sizeof(SCECONTEXT));

    DWORD ScpType = hProfile->Type;
    (*phPrevProfile)->Type &= ~(SCEJET_MERGE_TABLE_2 | SCEJET_MERGE_TABLE_1);

    SCESTATUS rc;
    //
    // now open the previous policy table
    //
    if ( ( ScpType & SCEJET_MERGE_TABLE_2 ) ) {
        //
        // the second table is the current one
        // so the first table is the previous one
        //
        rc = SceJetOpenTable(
                        *phPrevProfile,
                        "SmTblScp",
                        SCEJET_TABLE_SCP,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );
        (*phPrevProfile)->Type |= SCEJET_MERGE_TABLE_1;

    } else {
        rc = SceJetOpenTable(
                        *phPrevProfile,
                        "SmTblScp2",
                        SCEJET_TABLE_SCP,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );
        (*phPrevProfile)->Type |= SCEJET_MERGE_TABLE_2;
    }
/*
    if (  SCESTATUS_SUCCESS == rc ) {

        JET_COLUMNID  ColGpoID = (JET_COLUMNID)JET_tableidNil;
        JET_ERR       JetErr;
        JET_COLUMNDEF ColumnGpoIDDef;

        JetErr = JetGetTableColumnInfo(
                        (*phPrevProfile)->JetSessionID,
                        (*phPrevProfile)->JetScpID,
                        "GpoID",
                        (VOID *)&ColumnGpoIDDef,
                        sizeof(JET_COLUMNDEF),
                        JET_ColInfo
                        );
        if ( JET_errSuccess == JetErr ) {
            ColGpoID = ColumnGpoIDDef.columnid;

        } // else ignore error

        // temp storage for the column ID
        (*phPrevProfile)->JetSapValueID = ColGpoID;

    }
*/
    if ( rc != SCESTATUS_SUCCESS ) {

        LocalFree(*phPrevProfile);
        *phPrevProfile = NULL;
    }

    return(rc);
}

SCESTATUS
ScepClosePrevPolicyContext(
    IN OUT PSCECONTEXT *phProfile
    )
{
    if ( phProfile && *phProfile ) {

        //
        // just free the table because all other info are copied from the
        // current policy context and will be freed there
        //

        if ( (*phProfile)->JetScpID != JET_tableidNil ) {

            if ( (*phProfile)->JetScpID != (*phProfile)->JetSmpID ) {
                JetCloseTable(
                            (*phProfile)->JetSessionID,
                            (*phProfile)->JetScpID
                            );
            }
        }

        LocalFree(*phProfile);
        *phProfile = NULL;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
ScepCopyLocalToMergeTable(
    IN PSCECONTEXT hProfile,
    IN DWORD Options,
    IN DWORD CopyOptions,
    OUT PSCE_ERROR_LOG_INFO *pErrlog
    )
/* ++
Routine Description:

    This routine populate data from SCP table into SMP table. All data except
    those in the account profiles section(s) in SCP table will be copied over
    to SMP table. Account profiles section is converted into User List section
    format.

Arguments:

    hProfile - the JET database handle

Return Value:

    SCESTATUS_SUCCESS

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc;

    PSCESECTION  hSectionScp=NULL;
    PSCESECTION  hSectionSmp=NULL;
    PSCESECTION  hSectionPrevScp=NULL;
    PSCECONTEXT  hPrevProfile=NULL;
    DOUBLE      SectionID=0, SavedID=0;
    DWORD       Actual;
    BOOL        bCopyIt=FALSE;
    BOOL        bCopyThisLine;
    BOOL        bConvert=FALSE; // to convert privilege accounts

    PWSTR       KeyName=NULL;
    PWSTR       Value=NULL;
    DWORD       KeyLen=0;
    DWORD       ValueLen=0;

    WCHAR            SectionName[256];

    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( hProfile->JetScpID == hProfile->JetSmpID ) {
        // if it's the same table, return - shouldn't happen
        return(SCESTATUS_SUCCESS);
    }

    if ( hProfile->JetSapID == JET_tableidNil ) {
        // tattoo table doesn't exist, return - shouldn't happen
        return(SCESTATUS_SUCCESS);
    }

    //
    // get previous policy propagation info (if any)
    //

    if ( !(CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
        rc = ScepOpenPrevPolicyContext(hProfile, &hPrevProfile);
        if ( SCESTATUS_RECORD_NOT_FOUND == rc ||
             SCESTATUS_PROFILE_NOT_FOUND == rc ) {
            //
            // the table doesn't exist - no previous policy prop
            // do not need to copy anything, just quit
            //
            return(SCESTATUS_SUCCESS);
        }
    }

    //
    // Create a SMP section handle. the section ID is a dummy one
    //
    rc = SceJetOpenSection(
                hProfile,
                (DOUBLE)1,
                (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ? SCEJET_TABLE_SMP : SCEJET_TABLE_TATTOO,
                &hSectionSmp
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                              SCEERR_OPEN,
                              (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ? L"SMP" : L"TATTOO");

        if (hPrevProfile) ScepClosePrevPolicyContext(&hPrevProfile);

        return(rc);
    }

    LSA_HANDLE  LsaPolicy=NULL;
    PWSTR       pszNewValue=NULL;
    DWORD       NewLen=0;

    //
    // Move to the first line of the SCP table
    //
    JetErr = JetMove(hSectionSmp->JetSessionID, hSectionSmp->JetTableID, JET_MoveFirst, 0);

    while (JetErr == SCESTATUS_SUCCESS ) {
        //
        // get section ID
        //
        JetErr = JetRetrieveColumn(
                    hSectionSmp->JetSessionID,
                    hSectionSmp->JetTableID,
                    hSectionSmp->JetColumnSectionID,
                    (void *)&SectionID,
                    8,
                    &Actual,
                    0,
                    NULL
                    );

        if ( JetErr != JET_errSuccess ) {
            ScepBuildErrorLogInfo( ERROR_READ_FAULT, pErrlog,
                                   SCEERR_QUERY_INFO, L"sectionID");
            rc = SceJetJetErrorToSceStatus(JetErr);
            break;
        }
#ifdef SCE_DBG
    printf("SectionID=%d, JetErr=%d\n", (DWORD)SectionID, JetErr);
#endif
        if ( SectionID != SavedID ) {
            //
            // a new section. Look for the section's name to see if this section
            // is to be converted
            //
            SavedID = SectionID;

            Actual = 510;

            memset(SectionName, '\0', 512);
            rc = SceJetGetSectionNameByID(
                        hProfile,
                        SectionID,
                        SectionName,
                        &Actual
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo( ERROR_BAD_FORMAT, pErrlog,
                                     SCEERR_CANT_FIND_SECTION,
                                     (DWORD)SectionID
                                     );
                break;
            }
            if ( Actual > 0 )
                SectionName[Actual/sizeof(TCHAR)] = L'\0';
#ifdef SCE_DBG
    wprintf(L"SectionName=%s\n", SectionName);
#endif
            //
            // Compare section name with domain sections to convert
            //

            bCopyIt = TRUE;
            bConvert = FALSE;

            if ( (CopyOptions & SCE_LOCAL_POLICY_DC) ) {

                //
                // do not copy user rights if it's on a domain controller
                //
                if ( _wcsicmp(szPrivilegeRights, SectionName) == 0 ||
                     _wcsicmp(szSystemAccess, SectionName) == 0 ||
                     _wcsicmp(szKerberosPolicy, SectionName) == 0 ||
                     _wcsicmp(szAuditEvent, SectionName) == 0 ||
                    _wcsicmp(szGroupMembership, SectionName) == 0 ) {
                    bCopyIt = FALSE;

                } else if ( (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
                    //
                    // migrate registry values only
                    //
                    if ( _wcsicmp(szRegistryValues, SectionName) != 0 )
                        bCopyIt = FALSE;
                }

            } else if ( (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {

                //
                // non DCs, should migrate all local policies
                //
                if ( _wcsicmp(szPrivilegeRights, SectionName) == 0 ) {
                    bConvert = TRUE;
                } else if ( (_wcsicmp(szSystemAccess, SectionName) != 0) &&
                            (_wcsicmp(szKerberosPolicy, SectionName) != 0) &&
                            (_wcsicmp(szRegistryValues, SectionName) != 0) &&
                            (_wcsicmp(szAuditEvent, SectionName) != 0) ) {
                    bCopyIt = FALSE;
                }
            }

/*
            if ( ( Options & SCE_NOCOPY_DOMAIN_POLICY) &&
                 ( (_wcsicmp(szSystemAccess, SectionName) == 0) ||
                   (_wcsicmp(szKerberosPolicy, SectionName) == 0) ) ) {

                bCopyIt = FALSE;

            } else if ( (_wcsicmp(szGroupMembership, SectionName) == 0) ||
                        (_wcsicmp(szRegistryKeys, SectionName) == 0) ||
                        (_wcsicmp(szFileSecurity, SectionName) == 0) ||
                        (_wcsicmp(szServiceGeneral, SectionName) == 0) ||
                        (_wcsicmp(szAuditApplicationLog, SectionName) == 0) ||
                        (_wcsicmp(szAuditSecurityLog, SectionName) == 0) ||
                        (_wcsicmp(szAuditSystemLog, SectionName) == 0) ||
                        (_wcsicmp(szAttachments, SectionName) == 0) ||
                        (_wcsicmp(szDSSecurity, SectionName) == 0)
                      ) {
                // do not copy areas other than account policy and local policy
                bCopyIt = FALSE;

            } else {

                bCopyIt = TRUE;
*/
            if ( bCopyIt ) {
                //
                // Prepare this Scep section
                //
                rc = SceJetOpenSection(
                            hProfile,
                            SectionID,
                            (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ? SCEJET_TABLE_TATTOO : SCEJET_TABLE_SCP,
                            &hSectionScp
                            );
                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepBuildErrorLogInfo( ScepSceStatusToDosError(rc), pErrlog,
                                         SCEERR_OPEN_ID,
                                         (DWORD)SectionID);
                    break;
                }

                if ( (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
                    //
                    // open current policy propagation table
                    // do not care error here
                    //
                    SceJetOpenSection(
                            hProfile,
                            SectionID,
                            SCEJET_TABLE_SCP,
                            &hSectionPrevScp
                            );
/*              // should always copy tattoo value to the merged table
                // even if the setting doesn't exist in previous policy prop
                // this is to handle the dependent settings such as
                // retention perild and retention days
                } else if ( hPrevProfile ) {
                    //
                    // open previous policy propagation table
                    // do not care error here
                    //

                    SceJetOpenSection(
                            hPrevProfile,
                            SectionID,
                            SCEJET_TABLE_SCP,
                            &hSectionPrevScp
                            );
*/
                }
            }

        }

        if ( bCopyIt ) {
            //
            // get buffer size for key and value
            //
            rc = SceJetGetValue(
                        hSectionSmp,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        &KeyLen,
                        NULL,
                        0,
                        &ValueLen);

            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                      SCEERR_QUERY_VALUE, L"current row");
                break;
            }

            //
            // allocate memory
            //
            if ( KeyLen > 0 ) {
                KeyName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, KeyLen+2);
                if ( KeyName == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }
            }
            if ( ValueLen > 0 ) {
                Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);
                if ( Value == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }
            }
            //
            // get key and value
            //
            rc = SceJetGetValue(
                        hSectionSmp,
                        SCEJET_CURRENT,
                        NULL,
                        KeyName,
                        KeyLen,
                        &KeyLen,
                        Value,
                        ValueLen,
                        &ValueLen);

            if ( rc != SCESTATUS_SUCCESS ) {
                ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                      SCEERR_QUERY_VALUE, L"current row");
                break;
            }
#ifdef SCE_DBG
    wprintf(L"\t%s=%s, rc=%d\n", KeyName, Value, rc);
#endif
            bCopyThisLine = TRUE;

            //
            // check if this key exist in the previous prop
            //
            if ( hSectionPrevScp ) {

                rc = SceJetSeek(
                            hSectionPrevScp,
                            KeyName,
                            KeyLen,
                            SCEJET_SEEK_EQ_NO_CASE
                            );
                if ( SCESTATUS_RECORD_NOT_FOUND == rc ||
                     (hSectionPrevScp->JetColumnGpoID == 0) ) {

                    bCopyThisLine = FALSE;

                } else if ( SCESTATUS_SUCCESS == rc && (CopyOptions & SCE_LOCAL_POLICY_MIGRATE) ) {
                    //
                    // found. Let's check if this setting was from a GPO
                    // if in migration (build tattoo), a setting was not
                    // defined in GPO doesn't need a tattoo value
                    //
                    // for policy prop case, there may be undo settings in
                    // previous policy prop and they weren't reset successfully
                    // in previous prop. In this case, we still want to continue
                    // reset these settings. So these settings should be copied
                    // from the tattoo table to this policy table regardless if
                    // there is a domain setting defined for it in the previous
                    // policy propagation.
                    //
                    LONG GpoID = 0;
                    ULONG Actual;

                    (void)JetRetrieveColumn(
                                hSectionPrevScp->JetSessionID,
                                hSectionPrevScp->JetTableID,
                                hSectionPrevScp->JetColumnGpoID,
                                (void *)&GpoID,
                                4,
                                &Actual,
                                0,
                                NULL
                                );

                    if ( GpoID == 0 ) {
                        //
                        // this is not a setting from a GPO
                        //
                        bCopyThisLine = FALSE;
                    }
                }
                rc = SCESTATUS_SUCCESS;
            }

            if ( bCopyThisLine ) {

                if ( bConvert ) {

                    rc = ScepConvertFreeTextAccountToSid(
                                &LsaPolicy,
                                Value,
                                ValueLen/sizeof(WCHAR),
                                &pszNewValue,
                                &NewLen
                                );

                    if ( rc == SCESTATUS_SUCCESS &&
                         pszNewValue ) {

                        ScepFree(Value);
                        Value = pszNewValue;
                        ValueLen = NewLen*sizeof(WCHAR);

                        pszNewValue = NULL;
                    } // if failed to convert, just use the name format
                }

                //
                // set this line to the SCP table
                //
                rc = SceJetSetLine(
                            hSectionScp,
                            KeyName,
                            TRUE,
                            Value,
                            ValueLen,
                            0
                            );
                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepBuildErrorLogInfo(ScepSceStatusToDosError(rc), pErrlog,
                                          SCEERR_WRITE_INFO,
                                         KeyName);
                    break;
                }
            }

            ScepFree(KeyName);
            KeyName = NULL;

            ScepFree(Value);
            Value = NULL;

        }
        //
        // Move to next line in the SCP table
        //
        JetErr = JetMove(hSectionSmp->JetSessionID, hSectionSmp->JetTableID, JET_MoveNext, 0);

    }


    if ( KeyName != NULL )
        ScepFree(KeyName);

    if ( Value != NULL )
        ScepFree(Value);

    SceJetCloseSection(&hSectionScp, TRUE);
    SceJetCloseSection(&hSectionSmp, TRUE);
    if ( hSectionPrevScp ) {
        SceJetCloseSection(&hSectionPrevScp, TRUE);
    }

    if (hPrevProfile)
        ScepClosePrevPolicyContext(&hPrevProfile);

    if ( LsaPolicy ) {
        LsaClose(LsaPolicy);
    }

    return(rc);

}


SCESTATUS
ScepWriteObjectSecurity(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PSCE_OBJECT_SECURITY ObjSecurity
    )
/*
    Get security for a single object
*/
{
    SCESTATUS        rc;
    PCWSTR          SectionName=NULL;
    PSCESECTION      hSection=NULL;
    DWORD           SDsize, Win32Rc;
    PWSTR           SDspec=NULL;

    if ( hProfile == NULL ||
         ObjSecurity == NULL ||
         ObjSecurity->Name == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    switch (Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        break;
    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        break;
#endif
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepOpenSectionForName(
                hProfile,
                ProfileType,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // convert security descriptor
        //
        Win32Rc = ConvertSecurityDescriptorToText (
                            ObjSecurity->pSecurityDescriptor,
                            ObjSecurity->SeInfo,
                            &SDspec,
                            &SDsize
                            );

        if ( Win32Rc == NO_ERROR ) {

            if ( Area == AREA_DS_OBJECTS ) {
                //
                // ds needs to convert name
                //
                rc = ScepDosErrorToSceStatus(
                         ScepSaveDsStatusToSection(
                               ObjSecurity->Name,
                               ObjSecurity->IsContainer,
                               ObjSecurity->Status,
                               SDspec,
                               SDsize
                               ) );
            } else {
                rc = ScepSaveObjectString(
                            hSection,
                            ObjSecurity->Name,
                            ObjSecurity->IsContainer,
                            ObjSecurity->Status,
                            SDspec,
                            SDsize
                            );
            }
        } else
            rc = ScepDosErrorToSceStatus(Win32Rc);
    }

    SceJetCloseSection( &hSection, TRUE);

    if (SDspec)
        ScepFree(SDspec);

    return(rc);
}

SCESTATUS
ScepTattooCheckAndUpdateArray(
    IN OUT SCE_TATTOO_KEYS *pTattooKeys,
    IN OUT DWORD *pcTattooKeys,
    IN PWSTR KeyName,
    IN DWORD ConfigOptions,
    IN DWORD dwValue
    )
/*
Description:

    Add a new entry into the array which holds system (tatto) values for the settings

    The input/output buffer pTattooKeys is allocated outside this routine.

*/
{
    if ( pTattooKeys == NULL || pcTattooKeys == NULL ||
         KeyName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !(ConfigOptions & SCE_POLICY_TEMPLATE) ) {
        return(SCESTATUS_SUCCESS);
    }

    pTattooKeys[*pcTattooKeys].KeyName = KeyName;
    pTattooKeys[*pcTattooKeys].KeyLen = wcslen(KeyName);
    pTattooKeys[*pcTattooKeys].DataType = 'D';
    pTattooKeys[*pcTattooKeys].SaveValue = dwValue;
    pTattooKeys[*pcTattooKeys].Value = NULL;

//    ScepLogOutput3(3,0, SCESRV_POLICY_TATTOO_ADD, KeyName, *pcTattooKeys);

    (*pcTattooKeys)++;

    return(SCESTATUS_SUCCESS);
}

SCESTATUS
ScepTattooOpenPolicySections(
    IN PSCECONTEXT hProfile,
    IN PCWSTR SectionName,
    OUT PSCESECTION *phSectionDomain,
    OUT PSCESECTION *phSectionTattoo
    )
/*
Open the table/sections for the merged policy and the undo settings
*/
{

    if ( hProfile == NULL || SectionName == NULL ||
         phSectionDomain == NULL || phSectionTattoo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rCode;
    DOUBLE SectionID;

    *phSectionDomain = NULL;
    *phSectionTattoo = NULL;

    //
    // open the section for both tattoo table and effective policy table
    // get section id first
    //
    rCode = SceJetGetSectionIDByName(
                hProfile,
                SectionName,
                &SectionID
                );
    if ( rCode == SCESTATUS_SUCCESS ) {

        // open effective policy table
        rCode = SceJetOpenSection(
                    hProfile,
                    SectionID,
                    SCEJET_TABLE_SCP,
                    phSectionDomain
                    );
        if ( rCode == SCESTATUS_SUCCESS ) {

            // open tattoo table
            rCode = SceJetOpenSection(
                        hProfile,
                        SectionID,
                        SCEJET_TABLE_TATTOO,
                        phSectionTattoo
                        );
            if ( rCode != SCESTATUS_SUCCESS ) {

                SceJetCloseSection(phSectionDomain, TRUE);
                *phSectionDomain = NULL;
            }
        }
    }

    //
    // log tattoo process
    //
    if ( rCode != 0 )
        ScepLogOutput3(1, 0,
                   SCESRV_POLICY_TATTOO_PREPARE,
                   ScepSceStatusToDosError(rCode),
                   SectionName);

    return(rCode);
}

SCESTATUS
ScepTattooManageOneStringValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN PWSTR Value,
    IN DWORD ValueLen,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         KeyName == NULL || Value == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    PWSTR pNewValue=NULL;
    DWORD NewLen=ValueLen;
    SCESTATUS  rCode;

    if (Value && (ValueLen == 0) ) NewLen = wcslen(Value);

    if ( NewLen ) {
        //
        // the buffer passed may not be NULL terminated
        //
        pNewValue = (PWSTR)ScepAlloc(LPTR,(NewLen+1)*sizeof(WCHAR));
        if ( pNewValue == NULL ) return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        wcsncpy(pNewValue, Value, NewLen);
    }

    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = KeyName;
    theKey.KeyLen = (KeyLen == 0) ? wcslen(KeyName) : KeyLen;
    theKey.Value = pNewValue;
    theKey.SaveValue = NewLen;
    theKey.DataType = 'S';

    rCode = ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc);

    if ( pNewValue ) ScepFree(pNewValue);

    return(rCode);
}

SCESTATUS
ScepTattooManageOneIntValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN DWORD Value,
    IN DWORD rc
    )
{

    if ( hSectionDomain == NULL || hSectionTattoo == NULL || KeyName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = KeyName;
    theKey.KeyLen = (KeyLen == 0) ? wcslen(KeyName) : KeyLen;
    theKey.SaveValue = Value;
    theKey.DataType = 'D';
    theKey.Value = NULL;

    return(ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc));

}

SCESTATUS
ScepTattooManageOneIntValueWithDependency(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR DependentKeyName,
    IN DWORD DependentKeyLen OPTIONAL,
    IN PWSTR SaveKeyName,
    IN DWORD Value,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         SaveKeyName == NULL || DependentKeyName == NULL)
        return(SCESTATUS_INVALID_PARAMETER);

    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = DependentKeyName;
    theKey.KeyLen = (DependentKeyLen == 0) ? wcslen(DependentKeyName) : DependentKeyLen;
    theKey.SaveValue = Value;
    theKey.DataType = 'L';
    theKey.Value = SaveKeyName;

    return(ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc));

}

SCESTATUS
ScepTattooManageOneRegistryValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD KeyLen OPTIONAL,
    IN PSCE_REGISTRY_VALUE_INFO pOneRegValue,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         KeyName == NULL || pOneRegValue == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SCESTATUS  rCode;


    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = KeyName;
    theKey.KeyLen = (KeyLen == 0) ? wcslen(KeyName) : KeyLen;
    theKey.Value = (PWSTR)pOneRegValue;
    theKey.SaveValue = 0;
    theKey.DataType = 'R';

    rCode = ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc);

    return(rCode);
}

SCESTATUS
ScepTattooManageOneMemberListValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR GroupName,
    IN DWORD GroupLen OPTIONAL,
    IN PSCE_NAME_LIST pNameList,
    IN BOOL bDeleteOnly,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         GroupName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SCESTATUS  rCode;
    SCE_TATTOO_KEYS theKey;
    DWORD Len=GroupLen;

    if ( Len == 0 ) Len = wcslen(GroupName);
    Len += wcslen(szMembers);

    PWSTR KeyString = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));
    if ( KeyString != NULL ) {

        swprintf(KeyString, L"%s%s", GroupName, szMembers);

        theKey.KeyName = KeyString;
        theKey.KeyLen = Len;
        theKey.Value = (PWSTR)pNameList;
        theKey.SaveValue = bDeleteOnly ? 1 : 0;
        theKey.DataType = 'M';

        rCode = ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc);

        ScepFree(KeyString);

    } else {
        rCode = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }
    return(rCode);
}

SCESTATUS
ScepTattooManageOneServiceValue(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR ServiceName,
    IN DWORD ServiceLen OPTIONAL,
    IN PSCE_SERVICES pServiceNode,
    IN DWORD rc
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         ServiceName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    SCESTATUS  rCode;


    SCE_TATTOO_KEYS theKey;
    theKey.KeyName = ServiceName;
    theKey.KeyLen = (ServiceLen == 0) ? wcslen(ServiceName) : ServiceLen;
    theKey.Value = (PWSTR)pServiceNode;
    theKey.SaveValue = 0;
    theKey.DataType = 'V';

    rCode = ScepTattooManageValues(hSectionDomain, hSectionTattoo, &theKey, 1, rc);

    return(rCode);
}

SCESTATUS
ScepTattooManageValues(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN SCE_TATTOO_KEYS *pTattooKeys,
    IN DWORD cTattooKeys,
    IN DWORD rc
    )
/*
Description:

    For each setting in the array, do the following:

    1) Check if the setting come from domain
    2) Check if there is a tattoo value already exist
    3) Save the new value from the array to the tattoo table if it doesn't exist
    4) Delete the tattoo value if the setting didn't come from domain and
       it has been reset successfully
*/
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL ||
         pTattooKeys == NULL || cTattooKeys == 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS     rCode=SCESTATUS_SUCCESS;
    SCESTATUS     rc2;
    BOOL          bTattooExist,bDomainExist;
    PWSTR         KeyString=NULL;
    PWSTR pTempKey;

    for ( DWORD i=0; i<cTattooKeys; i++) {

        if ( pTattooKeys[i].KeyName == NULL ) continue;
        if ( pTattooKeys[i].DataType == 'L' && pTattooKeys[i].Value == NULL ) continue;

        //
        // check if this setting exists in the tattoo table
        //
        bTattooExist = FALSE;
        rc2 = SCESTATUS_SUCCESS;

        if ( SCESTATUS_SUCCESS == SceJetSeek(
                                    hSectionTattoo,
                                    pTattooKeys[i].KeyName,
                                    pTattooKeys[i].KeyLen*sizeof(WCHAR),
                                    SCEJET_SEEK_EQ_NO_CASE
                                    ) ) {
            bTattooExist = TRUE;
        }

        //
        // check if the setting exists in the effective table
        //

        bDomainExist = FALSE;

        if ( SCESTATUS_SUCCESS == SceJetSeek(
                                    hSectionDomain,
                                    pTattooKeys[i].KeyName,
                                    pTattooKeys[i].KeyLen*sizeof(WCHAR),
                                    SCEJET_SEEK_EQ_NO_CASE
                                    ) ) {
            if ( !bTattooExist ) {
                //
                // if there is no tattoo value but there is a setting in domain table
                // this setting must come from domain
                //
                bDomainExist = TRUE;

            } else if ( hSectionDomain->JetColumnGpoID > 0 ) {

                //
                // check if GpoID > 0
                //

                LONG GpoID = 0;
                DWORD Actual;
                JET_ERR JetErr;

                JetErr = JetRetrieveColumn(
                                hSectionDomain->JetSessionID,
                                hSectionDomain->JetTableID,
                                hSectionDomain->JetColumnGpoID,
                                (void *)&GpoID,
                                4,
                                &Actual,
                                0,
                                NULL
                                );
                if ( JET_errSuccess != JetErr ) {
                    //
                    // if the column is nil (no value), it will return warning
                    // but the buffer pGpoID is trashed
                    //
                    GpoID = 0;
                }

                if ( GpoID > 0 ) {
                    bDomainExist = TRUE;
                }
            }

        }

        //
        // check if we need to save the tatto value or delete the tattoo value
        //
        if ( bDomainExist ) {

            pTempKey = pTattooKeys[i].KeyName;
            BOOL bSave = FALSE;

            if ( pTattooKeys[i].DataType == 'M' && pTattooKeys[i].SaveValue == 1 ) {
                //
                // delete only for group membership, don't do anything in this case
                //
            } else if ( !bTattooExist ) {
                //
                // domain setting is defined (the first time)
                // save the tattoo value
                //
                switch ( pTattooKeys[i].DataType ) {
                case 'D':
                    if ( pTattooKeys[i].SaveValue != SCE_NO_VALUE ) {

                        rc2 = ScepCompareAndSaveIntValue(hSectionTattoo,
                                        pTattooKeys[i].KeyName,
                                        FALSE,
                                        SCE_SNAPSHOT_VALUE,
                                        pTattooKeys[i].SaveValue
                                        );
                        bSave = TRUE;
                    }
                    break;
                case 'L':  // dependency DWORD type
                    pTempKey = pTattooKeys[i].Value;

                    if ( pTattooKeys[i].SaveValue != SCE_NO_VALUE ) {
                        rc2 = ScepCompareAndSaveIntValue(hSectionTattoo,
                                        pTattooKeys[i].Value,
                                        FALSE,
                                        SCE_SNAPSHOT_VALUE,
                                        pTattooKeys[i].SaveValue
                                        );
                        bSave = TRUE;
                    }

                    break;
                case 'S':
                    if ( pTattooKeys[i].Value ) {

                        rc2 = ScepCompareAndSaveStringValue(hSectionTattoo,
                                        pTattooKeys[i].KeyName,
                                        (PWSTR)(ULONG_PTR)SCE_SNAPSHOT_VALUE,
                                        pTattooKeys[i].Value,
                                        pTattooKeys[i].SaveValue*sizeof(WCHAR)
                                        );
                        bSave = TRUE;
                    }
                    break;
                case 'R': // registry values
                    if ( ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value ) {

                        if ( REG_DWORD == ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->ValueType ) {

                            DWORD RegData = _wtol(((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value);

                            rc2 = ScepSaveRegistryValue(hSectionTattoo,
                                                        pTattooKeys[i].KeyName,
                                                        REG_DWORD,
                                                        (PWSTR)&RegData,
                                                        sizeof(DWORD),
                                                        0
                                                        );
                        } else {

                            rc2 = ScepSaveRegistryValue(hSectionTattoo,
                                                        pTattooKeys[i].KeyName,
                                                        ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->ValueType,
                                                        ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value,
                                                        wcslen(((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value)*sizeof(WCHAR),
                                                        0
                                                        );
                        }
                        bSave = TRUE;
                    }
                    break;
                case 'M': // group member list
                    // allow empty member list to be saved
                    rc2 = ScepWriteNameListValue(
                            NULL,
                            hSectionTattoo,
                            pTattooKeys[i].KeyName,
                            (PSCE_NAME_LIST)(pTattooKeys[i].Value),
                            SCE_WRITE_EMPTY_LIST,
                            3
                            );
                    bSave = TRUE;

                    break;
                case 'V': // service

                    if ( pTattooKeys[i].Value ) {

                        rc2 = ScepSetSingleServiceSetting(
                                  hSectionTattoo,
                                  (PSCE_SERVICES)(pTattooKeys[i].Value)
                                  );
                        bSave = TRUE;

                    } else {
                        rc2 = SCESTATUS_INVALID_PARAMETER;
                    }
                    break;
                default:
                    rc2 = SCESTATUS_INVALID_PARAMETER;
                    break;
                }

                if ( rc2 != SCESTATUS_SUCCESS ) {

                    ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_SETTING,
                                   ScepSceStatusToDosError(rc2), pTempKey);
                    rCode = rc2;
                } else if ( bSave ) {
                    ScepLogOutput3(2, 0, SCESRV_POLICY_TATTOO_CHECK, pTempKey);
                }

            } else {

                //
                // check if there is any value to save
                //
                switch ( pTattooKeys[i].DataType ) {
                case 'D':
                case 'L':
                    if ( pTattooKeys[i].SaveValue != SCE_NO_VALUE )
                        bSave = TRUE;
                    break;
                case 'S':
                case 'V':
                    if ( pTattooKeys[i].Value ) bSave = TRUE;
                    break;
                case 'R':
                    if ( ((PSCE_REGISTRY_VALUE_INFO)(pTattooKeys[i].Value))->Value )
                        bSave = TRUE;
                    break;
                }

                if ( bSave )
                    ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_EXIST, pTempKey);
            }

        } else {
            pTempKey = (pTattooKeys[i].DataType == 'L') ? pTattooKeys[i].Value : pTattooKeys[i].KeyName;

            if ( bTattooExist && ERROR_SUCCESS == rc ) {
                //
                // no domain setting defined
                // tattoo setting has been reset, delete the tattoo value
                // for dependency type, delete the right key
                //
                rc2 = SceJetDelete(hSectionTattoo,
                                pTempKey,
                                FALSE,
                                SCEJET_DELETE_LINE_NO_CASE);

                if ( rc2 == SCESTATUS_RECORD_NOT_FOUND) rc2 = SCESTATUS_SUCCESS;

                if ( rc2 != SCESTATUS_SUCCESS ) {

                    ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_REMOVE, ScepSceStatusToDosError(rc2), pTempKey);
                    rCode = rc2;
                } else {
                    ScepLogOutput3(2, 0, SCESRV_POLICY_TATTOO_REMOVE_SETTING, pTempKey);
                }
            } else if ( bTattooExist ) {
                //
                // undo value wan't reset properly
                //
                ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_RESET, pTempKey, rc );
            } else {
                //
                // there is no undo value
                //

//                ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_NONEXIST, pTempKey );
            }
        }
    }

    return(rCode);

}

BOOL
ScepTattooIfQueryNeeded(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN PWSTR KeyName,
    IN DWORD Len,
    OUT BOOL *pbDomainExist,
    OUT BOOL *pbTattooExist
    )
{
    if ( hSectionDomain == NULL || hSectionTattoo == NULL || KeyName == NULL || Len == 0 ) {
        return FALSE;
    }

    //
    // check if this setting exists in the tattoo table
    //
    BOOL bTattooExist = FALSE;

    if ( SCESTATUS_SUCCESS == SceJetSeek(
                                hSectionTattoo,
                                KeyName,
                                Len*sizeof(WCHAR),
                                SCEJET_SEEK_EQ_NO_CASE
                                ) ) {
        bTattooExist = TRUE;
    }

    //
    // check if the setting exists in the effective table
    //

    BOOL bDomainExist = FALSE;

    if ( SCESTATUS_SUCCESS == SceJetSeek(
                                hSectionDomain,
                                KeyName,
                                Len*sizeof(WCHAR),
                                SCEJET_SEEK_EQ_NO_CASE
                                ) ) {
        if ( !bTattooExist ) {
            //
            // if there is no tattoo value but there is a setting in domain table
            // this setting must come from domain
            //
            bDomainExist = TRUE;

        } else if ( hSectionDomain->JetColumnGpoID > 0 ) {

            //
            // check if GpoID > 0
            //

            LONG GpoID = 0;
            DWORD Actual;
            JET_ERR JetErr;

            JetErr = JetRetrieveColumn(
                            hSectionDomain->JetSessionID,
                            hSectionDomain->JetTableID,
                            hSectionDomain->JetColumnGpoID,
                            (void *)&GpoID,
                            4,
                            &Actual,
                            0,
                            NULL
                            );
            if ( JET_errSuccess != JetErr ) {
                //
                // if the column is nil (no value), it will return warning
                // but the buffer pGpoID is trashed
                //
                GpoID = 0;
            }

            if ( GpoID > 0 ) {
                bDomainExist = TRUE;
            }
        }
    }

    //
    // check if we need to save the tatto value or delete the tattoo value
    //
    if ( pbDomainExist ) *pbDomainExist = bDomainExist;
    if ( pbTattooExist ) *pbTattooExist = bTattooExist;

    if ( bDomainExist && !bTattooExist )
        return TRUE;

    return FALSE;
}


SCESTATUS
ScepDeleteOneSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE tblType,
    IN PCWSTR SectionName
    )
{
    PSCESECTION  hSection=NULL;
    SCESTATUS    rc;

    rc = ScepOpenSectionForName(
                 hProfile,
                 tblType,
                 SectionName,
                 &hSection
                 );

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = SceJetDelete( hSection, NULL, FALSE,SCEJET_DELETE_SECTION );

        SceJetCloseSection(&hSection, TRUE );

    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\regvalue.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    kerberos.h

Abstract:

    Headers of apis for registry values

Author:

    Jin Huang (jinhuang) 07-Jan-1998 created

Revision History:

--*/

#ifndef _sce_registryValue_
#define _sce_registryValue_

#ifdef __cplusplus
extern "C" {
#endif

#define SCEREG_VALUE_SNAPSHOT   1
#define SCEREG_VALUE_ANALYZE    2
#define SCEREG_VALUE_FILTER     3
#define SCEREG_VALUE_SYSTEM     4
#define SCEREG_VALUE_ROLLBACK   5

SCESTATUS
ScepGetRegistryValues(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_REGISTRY_VALUE_INFO * ppRegValues,
    OUT LPDWORD pValueCount,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepConfigureRegistryValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_REGISTRY_VALUE_INFO pRegValues,
    IN DWORD ValueCount,
    IN PSCE_ERROR_LOG_INFO *pErrLog,
    IN DWORD ConfigOptions,
    OUT PBOOL pAnythingSet
    );

SCESTATUS
ScepAnalyzeRegistryValues(
    IN PSCECONTEXT hProfile,
    IN DWORD dwAnalFlag,
    IN PSCE_PROFILE_INFO pSmpInfo
    );

SCESTATUS
ScepAnalyzeOneRegistryValue(
    IN PSCESECTION hSection OPTIONAL,
    IN DWORD dwAnalFlag,
    IN OUT PSCE_REGISTRY_VALUE_INFO pOneRegValue
    );

SCESTATUS
ScepSaveRegistryValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN DWORD RegType,
    IN PWSTR CurrentValue,
    IN DWORD CurrentBytes,
    IN DWORD Status
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\regvalue.cpp ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    regvalue.cpp

Abstract:

    Routines to read/write/configure registry value settings

    The following modules have links to registry values
        scejet.c    <SceJetAddSection>
        inftojet.c  <SceConvertpInfKeyValue>
        pfget.c     <ScepGetRegistryValues>
        config.c    <ScepConfigureRegistryValues>
        analyze.c   <ScepAnalyzeRegistryValues>

Author:

    Jin Huang (jinhuang) 07-Jan-1998

Revision History:

--*/


#include "headers.h"
#include "serverp.h"
#include "regvalue.h"
#include "pfp.h"


DWORD
ScepUnescapeAndAddCRLF(
    IN  PWSTR   pszSource,
    IN  OUT PWSTR   pszDest
    );

DWORD
ScepEscapeAndRemoveCRLF(
    IN  const PWSTR   pszSource,
    IN  const DWORD   dwSourceSize,
    IN  OUT PWSTR   pszDest
    );

SCESTATUS
ScepSaveRegistryValueToBuffer(
    IN DWORD RegType,
    IN PWSTR Value,
    IN DWORD dwBytes,
    IN OUT PSCE_REGISTRY_VALUE_INFO pRegValues
    );

SCESTATUS
ScepEnumAllRegValues(
    IN OUT PDWORD  pCount,
    IN OUT PSCE_REGISTRY_VALUE_INFO    *paRegValues
    );

DWORD
ScepAnalyzeOneRegistryValueNoValidate(
    IN HKEY hKey,
    IN PWSTR ValueName,
    IN PSCESECTION hSection OPTIONAL,
    IN DWORD dwAnalFlag,
    IN OUT PSCE_REGISTRY_VALUE_INFO pOneRegValue
    );

SCESTATUS
ScepGetRegistryValues(
    IN PSCECONTEXT  hProfile,
    IN SCETYPE ProfileType,
    OUT PSCE_REGISTRY_VALUE_INFO * ppRegValues,
    OUT LPDWORD pValueCount,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
/*++
Routine Description:

   This routine retrieves registry values to secure from the Jet database
   and stores in the output buffer ppRegValues

Arguments:

   hProfile     -  The profile handle context

   ppRegValues  -  the output array of registry values.

   pValueCount  -  the buffer to hold number of elements in the array

   Errlog       -  A buffer to hold all error codes/text encountered when
                   parsing the INF file. If Errlog is NULL, no further error
                   information is returned except the return DWORD

Return value:

   SCESTATUS -  SCESTATUS_SUCCESS
               SCESTATUS_NOT_ENOUGH_RESOURCE
               SCESTATUS_INVALID_PARAMETER
               SCESTATUS_BAD_FORMAT
               SCESTATUS_INVALID_DATA

--*/

{
    if ( !hProfile || !ppRegValues || !pValueCount ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS               rc;
    PSCESECTION             hSection=NULL;

    LPTSTR                  KeyName=NULL;
    DWORD                   KeyLen;

    DWORD                   i,j;
    LPTSTR                  ValueStr=NULL;
    LPTSTR                  Value=NULL;
    DWORD                   ValueLen;
    LONG                    dType;
    DWORD                   Status;
    DWORD                   dCount;


    rc = ScepOpenSectionForName(
                hProfile,
                (ProfileType==SCE_ENGINE_GPO) ? SCE_ENGINE_SCP : ProfileType,
                szRegistryValues,
                &hSection
                );
    if ( SCESTATUS_SUCCESS != rc ) {
        ScepBuildErrorLogInfo( ERROR_INVALID_DATA,
                             Errlog, SCEERR_OPEN,
                             szRegistryValues
                           );
        return(rc);
    }
    //
    // get total number of values in this section
    //
    *ppRegValues = NULL;

    rc = SceJetGetLineCount(
            hSection,
            NULL,
            FALSE,
            pValueCount
            );
    if ( SCESTATUS_SUCCESS == rc && *pValueCount > 0 ) {

        //
        // allocate memory for all objects
        //
        *ppRegValues = (PSCE_REGISTRY_VALUE_INFO)ScepAlloc( LMEM_ZEROINIT,
                                                 *pValueCount*sizeof(SCE_REGISTRY_VALUE_INFO) );
        if ( *ppRegValues ) {

            //
            // goto the first line of this section
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_PREFIX_MATCH,
                        NULL,
                        NULL,
                        0,
                        &KeyLen,
                        NULL,
                        0,
                        &ValueLen
                        );
            i=0;

            JET_COLUMNID  ColGpoID = 0;
            JET_ERR       JetErr;
            LONG          GpoID=0;
            DWORD         Actual;

            if ( ProfileType == SCE_ENGINE_GPO ) {
                JET_COLUMNDEF ColumnGpoIDDef;

                JetErr = JetGetTableColumnInfo(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                "GpoID",
                                (VOID *)&ColumnGpoIDDef,
                                sizeof(JET_COLUMNDEF),
                                JET_ColInfo
                                );
                if ( JET_errSuccess == JetErr ) {
                    ColGpoID = ColumnGpoIDDef.columnid;
                }
            }
            //
            // this count is for SCE_ENGINE_GPO type
            //
            dCount=0;

            while ( rc == SCESTATUS_SUCCESS ||
                    rc == SCESTATUS_BUFFER_TOO_SMALL ) {
                //
                // Get string key and a int value.
                //
                if ( i >= *pValueCount ) {
                    //
                    // more lines than allocated
                    //
                    rc = SCESTATUS_INVALID_DATA;
                    ScepBuildErrorLogInfo(ERROR_INVALID_DATA,
                                         Errlog,
                                         SCEERR_MORE_OBJECTS,
                                         *pValueCount
                                         );
                    break;
                }

                GpoID = 1;
                if ( ProfileType == SCE_ENGINE_GPO ) {

                    GpoID = 0;

                    if ( ColGpoID > 0 ) {

                        //
                        // query if the setting comes from a GPO
                        // get GPO ID field from the current line
                        //
                        JetErr = JetRetrieveColumn(
                                        hSection->JetSessionID,
                                        hSection->JetTableID,
                                        ColGpoID,
                                        (void *)&GpoID,
                                        4,
                                        &Actual,
                                        0,
                                        NULL
                                        );

                    }
                }

                if ( GpoID <= 0 ) {
                    //
                    // read next line
                    //
                    rc = SceJetGetValue(
                                hSection,
                                SCEJET_NEXT_LINE,
                                NULL,
                                NULL,
                                0,
                                &KeyLen,
                                NULL,
                                0,
                                &ValueLen
                                );
                    continue;
                }

                dCount++;

                //
                // allocate memory for the group name and value string
                //
                KeyName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, KeyLen+2);

                if ( KeyName ) {

                    Value = (PWSTR)ScepAlloc(LMEM_ZEROINIT, ValueLen+2);

                    if ( Value ) {

                        rc = SceJetGetValue(
                                hSection,
                                SCEJET_CURRENT,
                                NULL,
                                KeyName,
                                KeyLen,
                                &KeyLen,
                                Value,
                                ValueLen,
                                &ValueLen
                                );

                        if ( rc == SCESTATUS_SUCCESS ||
                             rc == SCESTATUS_BUFFER_TOO_SMALL ) {

                            rc = SCESTATUS_SUCCESS;

                            if ( ValueLen > 0 )
                                Value[ValueLen/2] = L'\0';

                            KeyName[KeyLen/2] = L'\0';

                            if ( ValueLen > 0 && Value[0] != L'\0' ) {
                                //
                                // the first ansi character is the value type,
                                // second ansi character is the status (if in SAP)
                                // should be terminated by L'\0'
                                //
                                //dType = _wtol(Value);
                                dType = *((CHAR *)Value) - '0';
                                if ( *((CHAR *)Value+1) >= '0' ) {
                                    Status = *((CHAR *)Value+1) - '0';
                                } else {
                                    Status = 0;
                                }

//                                if ( *(Value+2) ) { // a char and a null delimiter
                                if ( ValueLen > 4 ) { // a char and a null delimiter
                                    //
                                    // the second field and after is the registry value
                                    // convert the multi-sz delimeter to ,
                                    //

                                    if ( dType == REG_MULTI_SZ &&
                                         (0 == _wcsicmp( KeyName, szLegalNoticeTextKeyName) ) ) {

                                        //
                                        // check for commas and escape them with "," so the UI etc.
                                        // understands this, since, at this point for lines such as
                                        // k=7,a",",b,c
                                        // pValueStr will be a,\0b\0c\0\0 which we should make
                                        // a","\0b\0c\0\0
                                        //

                                        DWORD dwCommaCount = 0;
                                        DWORD i = 0;

                                        for ( i=2; i< ValueLen/2 ; i++) {
                                            if ( Value[i] == L',' )
                                                dwCommaCount++;
                                        }

                                        if ( dwCommaCount > 0 ) {

                                            //
                                            // in this case we have to escape commas
                                            //

                                            PWSTR   pszValueEscaped;
                                            DWORD   dwBytes = (ValueLen/2 + 1 + dwCommaCount*2) * sizeof(WCHAR);

                                            pszValueEscaped = (PWSTR)ScepAlloc(LMEM_ZEROINIT, dwBytes);

                                            if (pszValueEscaped) {

                                                memset(pszValueEscaped, '\0', dwBytes);
                                                ValueLen = 2 * ScepEscapeString(Value,
                                                                            ValueLen/2,
                                                                            L',',
                                                                            L'"',
                                                                            pszValueEscaped
                                                                           );

                                                ScepFree(Value);

                                                Value = pszValueEscaped;

                                            } else {
                                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                            }
                                        }
                                    }

                                    ScepConvertMultiSzToDelim(Value+2, ValueLen/2-2, L'\0', L',');


                                    ValueStr = (PWSTR)ScepAlloc(0, (ValueLen/2-1)*sizeof(WCHAR));

                                    if ( ValueStr ) {

                                        wcscpy(ValueStr, Value+2);
                                        ValueStr[ValueLen/2-2] = L'\0';

                                    } else {
                                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                    }
                                } // else no value available


                                //
                                // assign name to the output buffer
                                //
                                (*ppRegValues)[i].FullValueName = KeyName;
                                KeyName = NULL;

                                (*ppRegValues)[i].ValueType = dType;

                                (*ppRegValues)[i].Value = ValueStr;
                                (*ppRegValues)[i].Status = Status;

                                ValueStr = NULL;

                                //
                                // increment the count
                                //
                                i++;

                            } else {
                                // shouldn't be possible to get into this loop
                                // if it does, ignore this one
                                rc = SCESTATUS_INVALID_DATA;
                            }

                        } else if ( rc != SCESTATUS_RECORD_NOT_FOUND ){
                            ScepBuildErrorLogInfo( ERROR_READ_FAULT,
                                                 Errlog,
                                                 SCEERR_QUERY_VALUE,
                                                 szRegistryValues
                                               );
                        }

                        if ( Value ) {
                            ScepFree(Value);
                            Value = NULL;
                        }

                        if ( ValueStr ) {
                            ScepFree(ValueStr);
                            ValueStr = NULL;
                        }

                    } else {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    }

                    //
                    // remember to free the KeyName
                    //
                    if ( KeyName ) {
                        ScepFree(KeyName);
                        KeyName = NULL;
                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                    //
                    // read next line
                    //
                    rc = SceJetGetValue(
                                hSection,
                                SCEJET_NEXT_LINE,
                                NULL,
                                NULL,
                                0,
                                &KeyLen,
                                NULL,
                                0,
                                &ValueLen
                                );
                } else {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                }

            }

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ||
         rc == SCESTATUS_BUFFER_TOO_SMALL ) {
        rc = SCESTATUS_SUCCESS;
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free memory
        //
        ScepFreeRegistryValues( ppRegValues, *pValueCount );
        *ppRegValues = NULL;

    } else if ( ProfileType == SCE_ENGINE_GPO &&
                *pValueCount > dCount ) {
        //
        // reallocate the output buffer
        //

        if ( dCount > 0 ) {

            PSCE_REGISTRY_VALUE_INFO pTempRegValues = *ppRegValues;

            //
            // allocate memory for all objects
            //
            *ppRegValues = (PSCE_REGISTRY_VALUE_INFO)ScepAlloc( LMEM_ZEROINIT,
                                                     dCount*sizeof(SCE_REGISTRY_VALUE_INFO) );
            if ( *ppRegValues ) {

                for ( i=0,j=0; i<*pValueCount; i++ ) {

                    if ( pTempRegValues[i].Value ) {
                        (*ppRegValues)[j].FullValueName = pTempRegValues[i].FullValueName;
                        (*ppRegValues)[j].Value = pTempRegValues[i].Value;
                        (*ppRegValues)[j].ValueType = pTempRegValues[i].ValueType;
                        (*ppRegValues)[j].Status = pTempRegValues[i].Status;
                        j++;

                    } else if ( pTempRegValues[i].FullValueName ) {
                        ScepFree( pTempRegValues[i].FullValueName );
                    }
                }

                ScepFree( pTempRegValues );

                *pValueCount = dCount;

            } else {

                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                *pValueCount = 0;
            }

        } else {

            //
            // no registry value from the GPO settings are found
            //
            ScepFreeRegistryValues( ppRegValues, *pValueCount );
            *ppRegValues = NULL;
            *pValueCount = 0;
        }

    }

    //
    // close the section
    //
    SceJetCloseSection(&hSection, TRUE);

    return(rc);
}


SCESTATUS
ScepConfigureRegistryValues(
    IN PSCECONTEXT hProfile OPTIONAL,
    IN PSCE_REGISTRY_VALUE_INFO pRegValues,
    IN DWORD ValueCount,
    IN PSCE_ERROR_LOG_INFO *pErrLog,
    IN DWORD ConfigOptions,
    OUT PBOOL pAnythingSet
    )
/* ++

Routine Description:

   This routine configure registry values in the area of security
   policy.

Arguments:

   pRegValues - The array of registry values to configure

   ValueCount - the number of values to configure

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
   if ( !pRegValues || ValueCount == 0 ) {
      //
      // if no info to configure
      //
      return SCESTATUS_SUCCESS;
   }

   DWORD           rc;
   SCESTATUS       Saverc=SCESTATUS_SUCCESS;

   PWSTR           pStart, pTemp, pValue;
   HKEY            hKey=NULL;
   HKEY            hKeyRoot;
   PSCESECTION     hSectionDomain=NULL;
   PSCESECTION     hSectionTattoo=NULL;
   SCE_REGISTRY_VALUE_INFO OneRegValue;


   if ( pAnythingSet )
       *pAnythingSet = FALSE;

   if ( (ConfigOptions & SCE_POLICY_TEMPLATE) && hProfile ) {
       ScepTattooOpenPolicySections(
                     hProfile,
                     szRegistryValues,
                     &hSectionDomain,
                     &hSectionTattoo
                     );
   }

   for ( DWORD i=0; i<ValueCount; i++ ) {

       if ( !pRegValues[i].FullValueName ||
            !pRegValues[i].Value ) {
           //
           // no value to configure
           //
           continue;
       }

       ScepLogOutput3(2, 0, SCEDLL_SCP_CONFIGURE, pRegValues[i].FullValueName);

       //
       // look for the first \\
       //
       pStart = wcschr(pRegValues[i].FullValueName, L'\\') ;
       if ( !pStart ) {
           Saverc = SCESTATUS_INVALID_DATA;

           if ( pErrLog ) {
               ScepBuildErrorLogInfo(Saverc,pErrLog, SCEDLL_SCP_ERROR_CONFIGURE,
                                     pRegValues[i].FullValueName);
           } else {
               ScepLogOutput3(1, Saverc, SCEDLL_SCP_ERROR_CONFIGURE, pRegValues[i].FullValueName);
           }

           if ( ConfigOptions & SCE_RSOP_CALLBACK )

               ScepRsopLog(SCE_RSOP_REGISTRY_VALUE_INFO, Saverc, pRegValues[i].FullValueName, 0, 0);

           continue;
       }
       //
       // find the root key
       //
       if ( (7 == pStart-pRegValues[i].FullValueName) &&
            (0 == _wcsnicmp(L"MACHINE", pRegValues[i].FullValueName, 7)) ) {

           hKeyRoot = HKEY_LOCAL_MACHINE;

       } else if ( (5 == pStart-pRegValues[i].FullValueName) &&
                   (0 == _wcsnicmp(L"USERS", pRegValues[i].FullValueName, 5)) ) {
           hKeyRoot = HKEY_USERS;

       } else if ( (12 == pStart-pRegValues[i].FullValueName) &&
                   (0 == _wcsnicmp(L"CLASSES_ROOT", pRegValues[i].FullValueName, 12)) ) {
           hKeyRoot = HKEY_CLASSES_ROOT;

       } else {
           Saverc = SCESTATUS_INVALID_DATA;
           if ( pErrLog ) {
               ScepBuildErrorLogInfo(Saverc,pErrLog, SCEDLL_SCP_ERROR_CONFIGURE,
                                     pRegValues[i].FullValueName);
           } else {
               ScepLogOutput3(1, Saverc, SCEDLL_SCP_ERROR_CONFIGURE, pRegValues[i].FullValueName);
           }

           if ( ConfigOptions & SCE_RSOP_CALLBACK )

               ScepRsopLog(SCE_RSOP_REGISTRY_VALUE_INFO, Saverc, pRegValues[i].FullValueName, 0, 0);

           continue;
       }
       //
       // find the value name
       //
       pValue = pStart+1;

       do {
           pTemp = wcschr(pValue, L'\\');
           if ( pTemp ) {
               pValue = pTemp+1;
           }
       } while ( pTemp );

       if ( pValue == pStart+1 ) {
           Saverc = SCESTATUS_INVALID_DATA;
           if ( pErrLog ) {
               ScepBuildErrorLogInfo(Saverc,pErrLog, SCEDLL_SCP_ERROR_CONFIGURE,
                                     pRegValues[i].FullValueName);
           } else {
               ScepLogOutput3(1, Saverc, SCEDLL_SCP_ERROR_CONFIGURE, pRegValues[i].FullValueName);
           }

           if ( ConfigOptions & SCE_RSOP_CALLBACK )

               ScepRsopLog(SCE_RSOP_REGISTRY_VALUE_INFO, Saverc, pRegValues[i].FullValueName, 0, 0);

           continue;
       }

       //
       // terminate the subkey for now
       //
       *(pValue-1) = L'\0';

       //
       // set the value
       // always create the key if it does not exist.
       //
       rc = RegCreateKeyEx(hKeyRoot,
                            pStart+1,
                            0,
                            NULL,
                            0,
                            KEY_READ | KEY_SET_VALUE,
                            NULL,
                            &hKey,
                            NULL
                            );

       if ( rc == ERROR_SUCCESS ||
            rc == ERROR_ALREADY_EXISTS ) {
/*
       if(( rc = RegOpenKeyEx(hKeyRoot,
                              pStart+1,
                              0,
                              KEY_SET_VALUE,
                              &hKey
                              )) == ERROR_SUCCESS ) {
*/

           //
           // restore the char
           //
           *(pValue-1) = L'\\';

           OneRegValue.FullValueName = NULL;
           OneRegValue.Value = NULL;

           BOOL bLMSetting = FALSE;

           if ( (REG_DWORD == pRegValues[i].ValueType) &&
                _wcsicmp(L"MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\LmCompatibilityLevel", pRegValues[i].FullValueName) == 0 ) {

               //
               // check if in setup upgrade
               //
               DWORD dwInSetup=0;
               DWORD dwUpgraded=0;

               ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           TEXT("SystemSetupInProgress"),
                           &dwInSetup
                           );

               if ( dwInSetup ) {

                   //
                   // if system is upgraded, the state is stored in registry
                   // by SCE client at very beginning of GUI setup
                   //

                   ScepRegQueryIntValue(
                           HKEY_LOCAL_MACHINE,
                           SCE_ROOT_PATH,
                           TEXT("SetupUpgraded"),
                           (DWORD *)&dwUpgraded
                           );

                   if ( dwUpgraded ) {

                       //
                       // in setup upgrade, we need to do special check about
                       // this setting
                       //
                       bLMSetting = TRUE;
                   }
               }
           }


           //
           // if in policy propagation, query the existing value
           //
           if ( ( (ConfigOptions & SCE_POLICY_TEMPLATE) && hProfile ) ||
                bLMSetting ) {

               OneRegValue.FullValueName = pRegValues[i].FullValueName;
               OneRegValue.ValueType = pRegValues[i].ValueType;
               OneRegValue.Status = 0;

               DWORD rc2 = ScepAnalyzeOneRegistryValueNoValidate(
                                              hKey,
                                              pValue,
                                              NULL,
                                              SCEREG_VALUE_SYSTEM,
                                              &OneRegValue
                                              );
               if ( ERROR_SUCCESS != rc2 ) {
                   if ( !bLMSetting ) {

                       ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_QUERY, rc2, pRegValues[i].FullValueName);

                   } else if ( ERROR_FILE_NOT_FOUND != rc2 ) {

                       ScepLogOutput3(1, 0, SCESRV_SETUPUPD_ERROR_LMCOMPAT, rc2, pRegValues[i].FullValueName);
                   }
               }
           }

           if ( REG_DWORD == pRegValues[i].ValueType ) {
               //
               // REG_DWORD type, value is a dword
               //
               LONG RegValue = _wtol(pRegValues[i].Value);

               if ( !bLMSetting || OneRegValue.Value == NULL ||
                    _wtol(OneRegValue.Value) <= RegValue ) {

                   rc = RegSetValueEx( hKey,
                                       pValue,
                                       0,
                                       REG_DWORD,
                                       (BYTE *)&RegValue,
                                       sizeof(DWORD)
                                     );
               } else {

                   //
                   // for LMCompatibility level, if in setup, set this value only if
                   // current system setting is less than configuration, or not defined
                   //
                   ScepLogOutput3(2, 0, SCESRV_SETUPUPD_IGNORE_LMCOMPAT, pRegValues[i].FullValueName);
               }

           } else if ( -1 == pRegValues[i].ValueType ) {
               //
               // delete the registry value
               //
               rc = RegDeleteValue(hKey, pValue);
               //
               // if the value doesn't exist, ignore the error
               //
               if ( ERROR_FILE_NOT_FOUND == rc )
                   rc = ERROR_SUCCESS;

           } else {

               PBYTE           pRegBytes=NULL;
               DWORD           nLen;

               nLen = wcslen(pRegValues[i].Value);

               if ( REG_MULTI_SZ == pRegValues[i].ValueType || REG_QWORD == pRegValues[i].ValueType) {
                   //
                   // translate the comma delimited string to multi-sz string
                   //

                   //
                   // LegalNoticeText is special cased i.e. \0 should be converted to \r\n
                   // and commas should be unescaped before writing this value into the registry
                   //

                   BOOL bIsLegalNoticeText = FALSE;

                   if ( !(REG_MULTI_SZ == pRegValues[i].ValueType &&
                        (0 == _wcsicmp(szLegalNoticeTextKeyName, pRegValues[i].FullValueName ) ) ) ) {

                        pRegBytes = (PBYTE)ScepAlloc(0, (nLen+2)*sizeof(WCHAR));

                        if ( pRegBytes ) {

                            wcscpy((PWSTR)pRegBytes, pRegValues[i].Value);
                            ((PWSTR)pRegBytes)[nLen] = L'\0';
                            ((PWSTR)pRegBytes)[nLen+1] = L'\0';

                            ScepConvertMultiSzToDelim((PWSTR)pRegBytes,
                                                      nLen+1,
                                                      L',',
                                                      L'\0'
                                                     );
                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    else {

                        DWORD dwCommaCount = 0;
                        DWORD dwBytes;

                        bIsLegalNoticeText = TRUE;

                        for ( DWORD dwIndex = 0; dwIndex <= nLen; dwIndex++) {
                            if ( pRegValues[i].Value[dwIndex] == L',' )
                                dwCommaCount++;
                        }

                        dwBytes = (nLen + dwCommaCount + 2)*sizeof(WCHAR);

                        pRegBytes = (PBYTE)ScepAlloc(0, dwBytes);

                        if ( pRegBytes ) {

                            memset(pRegBytes, '\0', dwBytes);
                            //
                            // unescape the "," and add \r\n wherever there is a ,
                            //

                            nLen = ScepUnescapeAndAddCRLF( pRegValues[i].Value, (PWSTR) pRegBytes);

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    }

                    if ( rc == NO_ERROR ) {

                        //
                        // engine/UI treat LegalNoticeText as REG_MULTI_SZ but
                        // we force it to be REG_SZ for compatibility sake
                        //

                        rc = RegSetValueEx( hKey,
                                            pValue,
                                            0,
                                            bIsLegalNoticeText ? REG_SZ : pRegValues[i].ValueType,
                                            pRegBytes,
                                            (nLen+2)*sizeof(WCHAR)
                                          );

                        ScepFree(pRegBytes);

                    }

               } else if ( REG_BINARY == pRegValues[i].ValueType ) {

                   if ( nLen > 0 ) {

                       //
                       // binary type, translate the unicode string to binary data
                       // 4 bytes (2 wchars) to 1 byte
                       //

                       DWORD           newLen;
                       newLen = nLen/2;

                       if ( nLen % 2 ) {
                           newLen++;   // pad a leading 0
                       }

                       pRegBytes = (PBYTE)ScepAlloc(0, newLen);

                       if ( pRegBytes ) {

                           BYTE dByte;

                           for ( INT j=newLen-1; j>=0; j-- ) {

                               if ( nLen % 2 ) {
                                   // odd number of chars
                                   dByte = (pRegValues[i].Value[j*2]-L'0') % 16;
                                   if ( j*2 >= 1 ) {
                                       dByte += ((pRegValues[i].Value[j*2-1]-L'0') % 16) * 16;
                                   }
                               } else {
                                   // even number of chars
                                   dByte = (pRegValues[i].Value[j*2+1]-L'0') % 16;
                                   dByte += ((pRegValues[i].Value[j*2]-L'0') % 16) * 16;
                               }
                                pRegBytes[j] = dByte;
                           }

                           rc = RegSetValueEx( hKey,
                                               pValue,
                                               0,
                                               REG_BINARY,
                                               pRegBytes,
                                               newLen
                                             );

                           ScepFree(pRegBytes);

                       } else {
                           rc = ERROR_NOT_ENOUGH_MEMORY;
                       }
                   }

               } else {
                   //
                   // sz type, expand_sz
                   //

                   rc = RegSetValueEx( hKey,
                                       pValue,
                                       0,
                                       pRegValues[i].ValueType,
                                       (BYTE *)(pRegValues[i].Value),
                                       (nLen)*sizeof(WCHAR)
                                     );
               }
           }

           //
           // manage the tattoo value
           //
           if ( (ConfigOptions & SCE_POLICY_TEMPLATE) && hProfile ) {
               //
               // if can't query system setting (OneRegValue.Value == NULL)
               // (may be because they are deleted e.g. demotion)
               // we still need to delete the tattoo values
               //
               ScepTattooManageOneRegistryValue(hSectionDomain,
                                                hSectionTattoo,
                                                pRegValues[i].FullValueName,
                                                0,
                                                &OneRegValue,
                                                rc
                                                );
           }

           if ( OneRegValue.Value ) ScepFree(OneRegValue.Value);

           RegCloseKey( hKey );

       }

       if ( NO_ERROR != rc ) {

           if ( pErrLog ) {
               ScepBuildErrorLogInfo(rc,pErrLog, SCEDLL_ERROR_SET_INFO,
                                     pRegValues[i].FullValueName);

           }

           if ( ERROR_FILE_NOT_FOUND != rc &&
                ERROR_PATH_NOT_FOUND != rc ) {

               ScepLogOutput3(1, rc, SCEDLL_ERROR_SET_INFO, pRegValues[i].FullValueName);
               Saverc = ScepDosErrorToSceStatus(rc);
           }

       }

       if ( ConfigOptions & SCE_RSOP_CALLBACK )

           ScepRsopLog(SCE_RSOP_REGISTRY_VALUE_INFO, rc, pRegValues[i].FullValueName, 0, 0);

       if ( pAnythingSet ) {
           *pAnythingSet = TRUE;
       }
   }

   if ( hSectionDomain ) SceJetCloseSection(&hSectionDomain, TRUE);
   if ( hSectionTattoo ) SceJetCloseSection(&hSectionTattoo, TRUE);

   return(Saverc);
}


DWORD
ScepUnescapeAndAddCRLF(
    IN  PWSTR   pszSource,
    IN  OUT PWSTR   pszDest
    )
/* ++

Routine Description:

   Primarily used just before configuration

   Unescapes commas i.e. a","\0b\0c\0\0 -> a,\0b\0c\0\0

   Also replaces , with \r\n


Arguments:

    pszSource       -   The source string

    dwSourceChars   -   The number of chars in pszSource

    pszDest       -   The destination string

Return value:

   Number of characters copied to the destination

-- */
{

    DWORD   dwCharsCopied = 0;

    while (pszSource[0] != L'\0') {

        if (0 == wcsncmp(pszSource, L"\",\"", 3)) {

            pszDest[0] = L',';
            ++dwCharsCopied;

            ++pszDest;
            pszSource +=3;

        }
        else if (pszSource[0] == L',') {

            pszDest[0] = L'\r';
            pszDest[1] = L'\n';
            dwCharsCopied +=2;

            pszDest +=2 ;
            ++pszSource;

        }
        else {

            pszDest[0] = pszSource[0];
            ++dwCharsCopied;

            ++pszDest;
            ++pszSource;
        }
    }

    pszDest = L'\0';
    ++dwCharsCopied;

    return dwCharsCopied;
}


DWORD
ScepEscapeAndRemoveCRLF(
    IN  const PWSTR   pszSource,
    IN  const DWORD   dwSourceSize,
    IN  OUT PWSTR   pszDest
    )
/* ++

Routine Description:

   Primarily used before analysis

   Escapes commas i.e. a,\0b\0c\0\0 -> a","\0b\0c\0\0

   Also replaces \r\n with ,

   This routine is the inverse of ScepUnescapeAndAddCRLF


Arguments:

    pszSource       -   The source string

    dwSourceChars   -   The number of chars in pszSource

    pszDest       -   The destination string

Return value:

   Number of characters copied to the destination

-- */

{

    DWORD   dwSourceIndex = 0;
    DWORD   dwCopiedChars = 0;

    while (dwSourceIndex < dwSourceSize) {

        if (0 == wcsncmp(pszSource + dwSourceIndex, L"\r\n", 2)) {

            pszDest[0] = L',';

            ++pszDest;
            ++dwCopiedChars;
            dwSourceIndex +=2;

        }
        else if (pszSource[dwSourceIndex] == L',') {

            pszDest[0] = L'"';
            pszDest[1] = L',';
            pszDest[2] = L'"';

            pszDest +=3 ;
            dwCopiedChars +=3 ;
            ++dwSourceIndex;

        }
        else {

            pszDest[0] = pszSource[dwSourceIndex];

            ++pszDest;
            ++dwCopiedChars;
            ++dwSourceIndex;
        }
    }

    pszDest = L'\0';

    return dwCopiedChars;
}


SCESTATUS
ScepAnalyzeRegistryValues(
    IN PSCECONTEXT hProfile,
    IN DWORD dwAnalFlag,
    IN PSCE_PROFILE_INFO pSmpInfo
    )
/* ++

Routine Description:

   This routine analyze registry values in the area of security
   policy.

Arguments:

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
   if ( !pSmpInfo ) {
       return SCESTATUS_INVALID_PARAMETER;
   }

   if ( (dwAnalFlag != SCEREG_VALUE_SYSTEM) && !hProfile ) {
       return SCESTATUS_INVALID_PARAMETER;
   }

   SCESTATUS       Saverc=SCESTATUS_SUCCESS;

   if ( dwAnalFlag != SCEREG_VALUE_ROLLBACK ) {
       Saverc = ScepEnumAllRegValues(
                &(pSmpInfo->RegValueCount),
                &(pSmpInfo->aRegValues)
                );
   }

   if ( Saverc != SCESTATUS_SUCCESS ) {
       return(Saverc);
   }

   if ( pSmpInfo->RegValueCount == 0 ||
        pSmpInfo->aRegValues == NULL ) {
      //
      // if no info to configure
      //
      return SCESTATUS_SUCCESS;
   }

   DWORD           rc;
   DWORD           i;
   PSCESECTION     hSection=NULL;
   SCEJET_TABLE_TYPE tblType;

   if ( dwAnalFlag != SCEREG_VALUE_SYSTEM ) {
       //
       // query value from system doesn't require accessing the database
       //
       switch ( dwAnalFlag ) {
       case SCEREG_VALUE_SNAPSHOT:
       case SCEREG_VALUE_FILTER:
       case SCEREG_VALUE_ROLLBACK:
           tblType = SCEJET_TABLE_SMP;
           break;
       default:
           tblType = SCEJET_TABLE_SAP;
           break;
       }
       //
       // Prepare a new section
       // for delay filter mode, data is written to the SMP (local) table
       // when the setting is different from the effective setting (changed outside GPO)
       //
       Saverc = ScepStartANewSection(
                   hProfile,
                   &hSection,
                   tblType,
                   szRegistryValues
                   );
       if ( Saverc != SCESTATUS_SUCCESS ) {
           ScepLogOutput3(1, ScepSceStatusToDosError(Saverc),
                          SCEDLL_SAP_START_SECTION, (PWSTR)szRegistryValues);
           return(Saverc);
       }
   }

   for ( i=0; i<pSmpInfo->RegValueCount; i++ ) {

       if ( dwAnalFlag == SCEREG_VALUE_SYSTEM ) {
           //
           // mark the status field
           //
           (pSmpInfo->aRegValues)[i].Status = SCE_STATUS_ERROR_NOT_AVAILABLE;

       }

       if ( !((pSmpInfo->aRegValues)[i].FullValueName) ) {
           continue;
       }

       ScepLogOutput3(2, 0, SCEDLL_SAP_ANALYZE, (pSmpInfo->aRegValues)[i].FullValueName);


       rc = ScepAnalyzeOneRegistryValue(
                        hSection,
                        dwAnalFlag,
                        &((pSmpInfo->aRegValues)[i])
                        );

       if ( SCESTATUS_INVALID_PARAMETER == rc ||
            SCESTATUS_INVALID_DATA == rc ) {
           continue;
       }

       if ( SCESTATUS_SUCCESS != rc ) {
           Saverc = rc;

           break;
       }
   }

   //
   // close the section
   //

   SceJetCloseSection( &hSection, TRUE);

   return(Saverc);

}

SCESTATUS
ScepAnalyzeOneRegistryValue(
    IN PSCESECTION hSection OPTIONAL,
    IN DWORD dwAnalFlag,
    IN OUT PSCE_REGISTRY_VALUE_INFO pOneRegValue
    )
{
    SCESTATUS       Saverc=SCESTATUS_SUCCESS;
    PWSTR           pStart, pTemp, pValue;
    HKEY            hKey=NULL, hKeyRoot;
    DWORD           rc=0;


    if ( pOneRegValue == NULL ||
         pOneRegValue->FullValueName == NULL ) {
        return(SCESTATUS_INVALID_DATA);
    }

    if ( hSection == NULL &&
         (SCEREG_VALUE_ANALYZE == dwAnalFlag ||
          SCEREG_VALUE_ROLLBACK == dwAnalFlag) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // look for the first \\
    //
    pStart = wcschr(pOneRegValue->FullValueName, L'\\') ;

    if ( !pStart ) {
        //
        // if it's in snapshot mode, ignore bogus reg value names
        //
        Saverc = SCESTATUS_INVALID_DATA;
        if ( SCEREG_VALUE_ANALYZE == dwAnalFlag ) {

           //
           // error analyzing the value, save it
           //
           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    pOneRegValue->ValueType,
                    NULL,
                    0,
                    SCE_STATUS_ERROR_NOT_AVAILABLE
                    );
        }
        return(Saverc);
    }

    //
    // find the root key
    //
    if ( (7 == pStart-pOneRegValue->FullValueName) &&
        (0 == _wcsnicmp(L"MACHINE", pOneRegValue->FullValueName, 7)) ) {

       hKeyRoot = HKEY_LOCAL_MACHINE;

    } else if ( (5 == pStart-pOneRegValue->FullValueName) &&
               (0 == _wcsnicmp(L"USERS", pOneRegValue->FullValueName, 5)) ) {
       hKeyRoot = HKEY_USERS;

    } else if ( (12 == pStart-pOneRegValue->FullValueName) &&
               (0 == _wcsnicmp(L"CLASSES_ROOT", pOneRegValue->FullValueName, 12)) ) {
       hKeyRoot = HKEY_CLASSES_ROOT;

    } else {

       //
       // if it's in snapshot mode, ignore bogus reg value names
       //
       Saverc = SCESTATUS_INVALID_DATA;
       if ( SCEREG_VALUE_ANALYZE == dwAnalFlag ) {
           //
           // error analyzing the value, save it
           //
           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    pOneRegValue->ValueType,
                    NULL,
                    0,
                    SCE_STATUS_ERROR_NOT_AVAILABLE
                    );
       }
       return(Saverc);
   }

   //
   // find the value name
   //
   pValue = pStart+1;

   do {
       pTemp = wcschr(pValue, L'\\');
       if ( pTemp ) {
           pValue = pTemp+1;
       }
   } while ( pTemp );

   if ( pValue == pStart+1 ) {

       //
       // if it's in snapshot mode, ignore bogus reg value names
       //
       Saverc = SCESTATUS_INVALID_DATA;
       if ( SCEREG_VALUE_ANALYZE == dwAnalFlag ) {

           //
           // error analyzing the value, save it
           //
           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    pOneRegValue->ValueType,
                    NULL,
                    0,
                    SCE_STATUS_ERROR_NOT_AVAILABLE
                    );
       }
       return(Saverc);
   }

   //
   // terminate the subkey for now
   //
   *(pValue-1) = L'\0';

   if(( rc = RegOpenKeyEx(hKeyRoot,
                          pStart+1,
                          0,
                          KEY_READ,
                          &hKey
                          )) == ERROR_SUCCESS ) {

       //
       // resotre the char
       //
       *(pValue-1) = L'\\';

       rc = ScepAnalyzeOneRegistryValueNoValidate(hKey,
                                                 pValue,
                                                 hSection,
                                                 dwAnalFlag,
                                                 pOneRegValue
                                               );
       //
       // close the key
       //
       RegCloseKey(hKey);

   } else {

       //
       // error analyzing the value, or it doesn't exist, save it
       //
       if ( (SCEREG_VALUE_ANALYZE == dwAnalFlag) ||
            (SCEREG_VALUE_ROLLBACK == dwAnalFlag) ) {

           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    (SCEREG_VALUE_ANALYZE == dwAnalFlag) ? pOneRegValue->ValueType : -1,
                    NULL,
                    0,
                    (SCEREG_VALUE_ANALYZE == dwAnalFlag) ? SCE_STATUS_ERROR_NOT_AVAILABLE : 0
                    );
       }

       if ( rc == ERROR_FILE_NOT_FOUND ||
            rc == ERROR_PATH_NOT_FOUND ||
            rc == ERROR_INVALID_HANDLE ||
            rc == ERROR_ACCESS_DENIED ) {

           rc = ERROR_SUCCESS;
       }
   }

   if ( rc != NO_ERROR ) {
       ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_ANALYZE, pOneRegValue->FullValueName);

       Saverc = ScepDosErrorToSceStatus(rc);
   }

   return(Saverc);

}

DWORD
ScepAnalyzeOneRegistryValueNoValidate(
    IN HKEY hKey,
    IN PWSTR ValueName,
    IN PSCESECTION hSection OPTIONAL,
    IN DWORD dwAnalFlag,
    IN OUT PSCE_REGISTRY_VALUE_INFO pOneRegValue
    )
/*
Query and/or compare one registry value without validating the value name, etc.
The validation should be done outside of this routine.

This routine is primarily defined for sharing in both configuration and analysis.

*/
{
   if ( hKey == NULL || ValueName == NULL || pOneRegValue == NULL )
       return(ERROR_INVALID_PARAMETER);

   DWORD           rc;
   DWORD           dSize=0;
   DWORD           RegType=pOneRegValue->ValueType;
   DWORD           RegData=0;
   PWSTR           strValue=NULL;
   BOOL            bIsLegalNoticeText = FALSE;


   if ( SCEREG_VALUE_SYSTEM == dwAnalFlag ) {
       //
       // reset the status field, it's not error'ed
       //
       pOneRegValue->Status = 0;
   }

   if(( rc = RegQueryValueEx(hKey,
                             ValueName,
                             0,
                             &RegType,
                             NULL,
                             &dSize
                             )) == ERROR_SUCCESS ) {

       //
       // we treat REG_DWORD_BIG_ENDIAN the same as REG_DWORD
       //
       if ( RegType == REG_DWORD_BIG_ENDIAN ) {
           RegType = REG_DWORD;
       }

       if ( 0 == _wcsicmp( pOneRegValue->FullValueName, szLegalNoticeTextKeyName)) {

           bIsLegalNoticeText = TRUE;

           RegType = REG_MULTI_SZ;

       } else if (  RegType != pOneRegValue->ValueType ) {
           //
           // if it's a wrong type, we assure it's not the value we found
           //
           rc = ERROR_FILE_NOT_FOUND;

       }

       if ( ERROR_SUCCESS == rc ) {

           switch (RegType) {
           case REG_DWORD:

               dSize = sizeof(DWORD);
               rc = RegQueryValueEx(hKey,
                                      ValueName,
                                      0,
                                      &RegType,
                                      (BYTE *)&RegData,
                                      &dSize
                                     );
               break;
           default:

               //
               // can be REG_BINARY, REG_MULTI_SZ, REG_SZ, and REG_EXPAND_SZ
               // everything else is treated as REG_SZ
               //

               strValue = (PWSTR)ScepAlloc(0, dSize + 4);
               dSize += 2;

               if ( strValue ) {

                   memset(strValue, 0, dSize + 4 - 2);
                   rc = RegQueryValueEx(hKey,
                                          ValueName,
                                          0,
                                          &RegType,
                                          (BYTE *)strValue,
                                          &dSize
                                         );

                   if (bIsLegalNoticeText) {
                       RegType = REG_MULTI_SZ;
                   }

               } else {
                   rc = ERROR_NOT_ENOUGH_MEMORY;
               }

               break;
           }
       }
   }

   if ( rc == NO_ERROR ) {

       DWORD dwStatus = SCE_STATUS_NOT_CONFIGURED;
       if ( SCEREG_VALUE_SNAPSHOT == dwAnalFlag ||
            SCEREG_VALUE_ROLLBACK == dwAnalFlag )
           dwStatus = 0;

       switch ( RegType ) {
       case REG_DWORD:
       case REG_DWORD_BIG_ENDIAN:

           if ( pOneRegValue->Value == NULL ||
                (SCEREG_VALUE_SNAPSHOT == dwAnalFlag)  ) {

               if ( SCEREG_VALUE_SYSTEM == dwAnalFlag ) {
                   //
                   // add the value to OneRegValue buffer
                   //
                   rc = ScepSaveRegistryValueToBuffer(
                                REG_DWORD,
                                (PWSTR)&RegData,
                                sizeof(DWORD),
                                pOneRegValue
                                );

               } else if ( SCEREG_VALUE_FILTER != dwAnalFlag ) {

                   //
                   // not configured, or snapshot the current value
                   //
                   rc = ScepSaveRegistryValue(
                                hSection,
                                pOneRegValue->FullValueName,
                                REG_DWORD,
                                (PWSTR)&RegData,
                                sizeof(DWORD),
                                dwStatus
                                );
               } // else for the delay filter, only query the reg values configured

           } else if ( (LONG)RegData != _wtol(pOneRegValue->Value) ) {

               rc = ScepSaveRegistryValue(
                            hSection,
                            pOneRegValue->FullValueName,
                            REG_DWORD,
                            (PWSTR)&RegData,
                            sizeof(DWORD),
                            0
                            );
           }
           break;

       case REG_BINARY:

           DWORD           nLen;
           if ( pOneRegValue->Value ) {
               nLen = wcslen(pOneRegValue->Value);
           } else {
               nLen = 0;
           }

           if ( pOneRegValue->Value == NULL ||
                (SCEREG_VALUE_SNAPSHOT == dwAnalFlag) ||
                nLen == 0 ) {

               if ( SCEREG_VALUE_SYSTEM == dwAnalFlag ) {

                   //
                   // add the value to OneRegValue buffer
                   //
                   rc = ScepSaveRegistryValueToBuffer(
                                RegType,
                                strValue,
                                dSize,
                                pOneRegValue
                                );

               } else if ( SCEREG_VALUE_FILTER != dwAnalFlag ) {
                   //
                   // not configured, or snapshot the current value
                   //
                   rc = ScepSaveRegistryValue(
                                hSection,
                                pOneRegValue->FullValueName,
                                RegType,
                                strValue,
                                dSize,
                                dwStatus
                                );
               }

           } else if ( strValue ) {

               DWORD           newLen;

               newLen = nLen/2;

               if ( nLen % 2 ) {
                   newLen++;   // pad a leading 0
               }

               PBYTE pRegBytes = (PBYTE)ScepAlloc(0, newLen);

               if ( pRegBytes ) {

                   BYTE dByte;

                   for ( INT j=newLen-1; j>=0; j-- ) {

                       if ( nLen % 2 ) {
                           // odd number of chars
                           dByte = (pOneRegValue->Value[j*2]-L'0') % 16;
                           if ( j*2 >= 1 ) {
                               dByte += ((pOneRegValue->Value[j*2-1]-L'0') % 16) * 16;
                           }
                       } else {
                           // even number of chars
                           dByte = (pOneRegValue->Value[j*2+1]-L'0') % 16;
                           dByte += ((pOneRegValue->Value[j*2]-L'0') % 16) * 16;
                       }
                        pRegBytes[j] = dByte;
                   }

                   if ( memcmp(strValue, pRegBytes, dSize) == 0 ) {

                       //
                       // matched, do not do anything
                       //

                   } else {

                       //
                       // mismatched, save the binary data
                       //
                       rc = ScepSaveRegistryValue(
                                    hSection,
                                    pOneRegValue->FullValueName,
                                    RegType,
                                    strValue,
                                    dSize,
                                    0
                                    );
                   }

                   ScepFree(pRegBytes);

               } else {
                   //
                   // out of memory
                   //
                   rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
               }

           } else {

               //
               // mismatched, save the binary data
               //
               rc = ScepSaveRegistryValue(
                            hSection,
                            pOneRegValue->FullValueName,
                            RegType,
                            strValue,
                            dSize,
                            0
                            );
           }
           break;

       case REG_MULTI_SZ:
       case REG_QWORD:

           if ( strValue ) {

               if ( !(RegType == REG_MULTI_SZ &&
                    (0 == _wcsicmp( pOneRegValue->FullValueName, szLegalNoticeTextKeyName) ) ) ) {

                   ScepConvertMultiSzToDelim(strValue, dSize/2, L'\0', L',');

               }
               else {

                   DWORD dwCommaCount = 0;
                   PWSTR strValueNew;
                   DWORD dwBytes;

                   for (DWORD dwIndex=0; dwIndex < dSize/2; dwIndex++) {
                       if ( strValue[dwIndex] == L',' )
                           dwCommaCount++;
                   }

                   dwBytes = (dSize/2+dwCommaCount * 2 + 1) * sizeof(WCHAR);
                   strValueNew = (PWSTR)ScepAlloc(0, dwBytes);

                   if (strValueNew) {

                       memset(strValueNew, '\0', dwBytes);

                       dSize = 2 + 2 * ScepEscapeAndRemoveCRLF( strValue, dSize/2, strValueNew);

                       ScepFree(strValue);

                       strValue = strValueNew;
                   }
                   else {

                       rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                       break;

                   }

               }

           }
           // fall through
       default:

           if ( pOneRegValue->Value == NULL ||
                (SCEREG_VALUE_SNAPSHOT == dwAnalFlag) ) {

               if ( SCEREG_VALUE_SYSTEM == dwAnalFlag ) {

                   //
                   // add the value to OneRegValue buffer
                   //
                   rc = ScepSaveRegistryValueToBuffer(
                                RegType,
                                strValue,
                                dSize,
                                pOneRegValue
                                );

               } else if ( SCEREG_VALUE_FILTER != dwAnalFlag ) {
                   rc = ScepSaveRegistryValue(
                                hSection,
                                pOneRegValue->FullValueName,
                                RegType,
                                strValue,
                                dSize,
                                dwStatus
                                );
               }
           } else if ( strValue && bIsLegalNoticeText &&
                       (pOneRegValue->ValueType != RegType)) {
               //
               // legalnotice text special case
               // must be old template is used
               // each comma is escaped with two quotes
               //

               DWORD Len = wcslen(pOneRegValue->Value);
               PWSTR NewValue = (PWSTR)ScepAlloc(LPTR, Len*3*sizeof(WCHAR));

               if ( NewValue ) {

                   ScepEscapeAndRemoveCRLF(pOneRegValue->Value, Len, NewValue);

                   if ( _wcsicmp(NewValue, strValue) != 0 ) {
                       //
                       // mismatched, save the item to the database
                       //
                       rc = ScepSaveRegistryValue(
                                    hSection,
                                    pOneRegValue->FullValueName,
                                    RegType,
                                    strValue,
                                    dSize,
                                    0
                                    );
                   }

                   ScepFree(NewValue);

               } else {
                   rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
               }


           } else if ( strValue &&
                _wcsicmp(pOneRegValue->Value, strValue) == 0 ) {
               //
               // matched, do not do anything
               //
           } else {
               //
               // mismatched, save the item to the database
               //
               rc = ScepSaveRegistryValue(
                            hSection,
                            pOneRegValue->FullValueName,
                            RegType,
                            strValue,
                            dSize,
                            0
                            );
           }
           break;
       }

       rc = ScepSceStatusToDosError(rc);

   } else {

       //
       // error analyzing the value, or it doesn't exist, save it
       // if the registry value doesn't exist, doesn't mean it's 0
       // just log an "not available" status in this case
       //
       if ( (SCEREG_VALUE_ANALYZE == dwAnalFlag) ||
            (SCEREG_VALUE_ROLLBACK == dwAnalFlag) ) {

           ScepSaveRegistryValue(
                    hSection,
                    pOneRegValue->FullValueName,
                    (SCEREG_VALUE_ANALYZE == dwAnalFlag) ? pOneRegValue->ValueType : -1,
                    NULL,
                    0,
                    (SCEREG_VALUE_ANALYZE == dwAnalFlag) ? SCE_STATUS_ERROR_NOT_AVAILABLE : 0
                    );
       }

       if ( rc == ERROR_FILE_NOT_FOUND ||
            rc == ERROR_PATH_NOT_FOUND ||
            rc == ERROR_INVALID_HANDLE ||
            rc == ERROR_ACCESS_DENIED ) {

           rc = ERROR_SUCCESS;
       }
   }

   //
   // free buffer
   //
   if ( strValue ) {
       ScepFree(strValue);
       strValue = NULL;
   }

   return(rc);

}


SCESTATUS
ScepSaveRegistryValue(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN DWORD RegType,
    IN PWSTR CurrentValue,
    IN DWORD CurrentBytes,
    IN DWORD Status
    )
/* ++
Routine Description:

    This routine compares system settings in string with the baseline profile
    settings. If there is mismatch or unknown, the entry is saved in the SAP
    profile.

Arguments:

    hSection - The section handle

    Name    - The entry name

    RegType  - the registry value type

    CurrentValue - The current system setting

    CurrentBytes - The length of the current setting

    Status - the status of this registry vlue analyzed

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS  rc;

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( CurrentValue == NULL &&
         REG_DWORD == RegType &&
         Status == 0 ) {
        //
        // only return if it's a DWORD type and saving for mismatch status
        // for other types, NULL should be treated as ""
        return(SCESTATUS_SUCCESS);
    }

    //
    // build a buffer containing type and value
    // note MULTI_SZ must be converted to null delimited
    //

    if ( REG_DWORD == RegType ) {

        TCHAR StrValue[20];
        memset(StrValue, '\0', 40);

        *((CHAR *)StrValue) = (BYTE)RegType + '0';

        if ( Status == 0) {
           *((CHAR *)StrValue+1) = SCE_STATUS_MISMATCH + '0';
        } else {
            *((CHAR *)StrValue+1) = (BYTE)Status + '0';
        }
        StrValue[1] = L'\0';

        if ( CurrentValue ) {
            swprintf(StrValue+2, L"%d", *CurrentValue);
        }
        rc = SceJetSetLine( hSection, Name, FALSE, StrValue, (2+wcslen(StrValue+2))*2, 0);

    } else {

        PWSTR StrValue;

        if ( (CurrentBytes % 2) && REG_BINARY == RegType ) {
            StrValue = (PWSTR)ScepAlloc(0, CurrentBytes+9);
        }
        else {
            StrValue = (PWSTR)ScepAlloc(0, CurrentBytes+8);   // 4 wide chars: one for type, one delim, and two NULL
        }

        if ( StrValue ) {

            memset(StrValue, 0, sizeof(StrValue));
            *((CHAR *)StrValue) = (BYTE)RegType + '0';

            if ( Status == 0) {
               *((CHAR *)StrValue+1) = SCE_STATUS_MISMATCH + '0';
            } else {
                *((CHAR *)StrValue+1) = (BYTE)Status + '0';
            }
            StrValue[1] = L'\0';

            if ( CurrentValue ) {
                if (REG_BINARY == RegType && CurrentBytes == 1) {
                    swprintf(StrValue+2, L"%d", *CurrentValue);
                }
                else {
                    memcpy(StrValue+2, (PBYTE)CurrentValue, CurrentBytes);
                }
            }

            if ( (CurrentBytes % 2) && REG_BINARY == RegType ) {
                StrValue[CurrentBytes/2+3] = L'\0';
                StrValue[CurrentBytes/2+4] = L'\0';
            }
            else {
                StrValue[CurrentBytes/2+2] = L'\0';
                StrValue[CurrentBytes/2+3] = L'\0';
            }

            if ( REG_MULTI_SZ == RegType || REG_QWORD == RegType ) {
                //
                // convert the , to null
                //
                ScepConvertMultiSzToDelim(StrValue+2, CurrentBytes/2, L',', L'\0');

            }

            if ( (CurrentBytes % 2) && REG_BINARY == RegType ) {
                rc = SceJetSetLine( hSection, Name, FALSE, StrValue, CurrentBytes+7, 0);
            }
            else {
                rc = SceJetSetLine( hSection, Name, FALSE, StrValue, CurrentBytes+6, 0);
            }

            ScepFree(StrValue);

        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    switch (Status) {
    case SCE_STATUS_ERROR_NOT_AVAILABLE:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_ERROR, Name);
        break;
    case SCE_STATUS_NOT_CONFIGURED:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, Name);
        break;
    default:
        ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, Name);
        break;
    }

    return(rc);

}

SCESTATUS
ScepSaveRegistryValueToBuffer(
    IN DWORD RegType,
    IN PWSTR Value,
    IN DWORD dwBytes,
    IN OUT PSCE_REGISTRY_VALUE_INFO pRegValues
    )
/* ++
Routine Description:

    This routine saves the registry value to the buffer

Arguments:

    RegType  - the registry value type

    Value - The current system setting

    dwBytes - The length of the current setting

    pRegValues - the buffer for this registry value to save to

-- */
{
    SCESTATUS  rc=SCESTATUS_SUCCESS;

    if ( pRegValues == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Value == NULL || dwBytes == 0 ) {
        // nothing to save
        return(SCESTATUS_SUCCESS);
    }

    //
    // build a buffer containing type and value
    // note MULTI_SZ must be converted to null delimited
    //

    if ( REG_DWORD == RegType ) {

        TCHAR StrValue[20];
        DWORD   *pdwValue = (DWORD *)Value;
        memset(StrValue, '\0', 40);

        _ultow(*pdwValue, StrValue, 10);

        PWSTR pValue = (PWSTR)ScepAlloc(0, (wcslen(StrValue)+1)*2);

        if ( pValue ) {

            wcscpy(pValue, StrValue);

            pRegValues->Value = pValue;
            pRegValues->ValueType = RegType;

        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }

    } else {

        PWSTR StrValue;

        if ( (dwBytes % 2) && REG_BINARY == RegType ) {
            StrValue = (PWSTR)ScepAlloc(LPTR, dwBytes+5);
        } else {
            StrValue = (PWSTR)ScepAlloc(LPTR, dwBytes+4);   // 2 wide chars: two NULL
        }

        if ( StrValue ) {

            if (REG_BINARY == RegType && dwBytes == 1) {
                swprintf(StrValue, L"%d", *Value);
            } else {
                memcpy(StrValue, (PBYTE)Value, dwBytes);
            }

            if ( (dwBytes % 2) && REG_BINARY == RegType ) {
                StrValue[dwBytes/2+1] = L'\0';
                StrValue[dwBytes/2+2] = L'\0';
            }
            else {
                StrValue[dwBytes/2+0] = L'\0';
                StrValue[dwBytes/2+1] = L'\0';
            }


            pRegValues->Value = StrValue;
            pRegValues->ValueType = RegType;

        } else {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    return(rc);

}


SCESTATUS
ScepEnumAllRegValues(
    IN OUT PDWORD  pCount,
    IN OUT PSCE_REGISTRY_VALUE_INFO    *paRegValues
    )
/*
Routine Description:

    Enumerate all registry values supported by SCE from registry.

Arguments:

    pCount          - the number of reg values to output

    paRegValues     - the array of registry values to output

Return Value:


*/
{
   DWORD   Win32Rc;
   HKEY    hKey=NULL;
   PSCE_NAME_STATUS_LIST pnsList=NULL;
   DWORD   nAdded=0;


   Win32Rc = RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     SCE_ROOT_REGVALUE_PATH,
                     0,
                     KEY_READ,
                     &hKey
                     );

   DWORD cSubKeys = 0;
   DWORD nMaxLen;

   if ( Win32Rc == ERROR_SUCCESS ) {

      //
      // enumerate all subkeys of the key
      //

      Win32Rc = RegQueryInfoKey (
                                hKey,
                                NULL,
                                NULL,
                                NULL,
                                &cSubKeys,
                                &nMaxLen,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );
   }

   if ( Win32Rc == ERROR_SUCCESS && cSubKeys > 0 ) {

      PWSTR   szName = (PWSTR)ScepAlloc(0, (nMaxLen+2)*sizeof(WCHAR));

      if ( !szName ) {
         Win32Rc = ERROR_NOT_ENOUGH_MEMORY;

      } else {

         DWORD   BufSize;
         DWORD   index = 0;

         do {

            BufSize = nMaxLen+1;
            Win32Rc = RegEnumKeyEx(
                                  hKey,
                                  index,
                                  szName,
                                  &BufSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

            if ( ERROR_SUCCESS == Win32Rc ) {

               index++;

               //
               // get the full registry key name and Valuetype
               //
               cSubKeys = REG_SZ;

               //
               // query ValueType, if error, default REG_SZ
               //
               ScepRegQueryIntValue( hKey,
                                    szName,
                                    SCE_REG_VALUE_TYPE,
                                    &cSubKeys
                                    );

               if ( cSubKeys < REG_SZ || cSubKeys > REG_MULTI_SZ ) {
                  cSubKeys = REG_SZ;
               }

               //
               // convert the path name
               //
               ScepConvertMultiSzToDelim(szName, BufSize, L'/', L'\\');

               //
               // compare with the input array, if not exist,
               // add it
               //
               for ( DWORD i=0; i<*pCount; i++ ) {
                  if ( (*paRegValues)[i].FullValueName &&
                       _wcsicmp(szName, (*paRegValues)[i].FullValueName) == 0 ) {
                     break;
                  }
               }

               if ( i >= *pCount ) {
                  //
                  // did not find a match, add it
                  //
                  if ( SCESTATUS_SUCCESS != ScepAddToNameStatusList(&pnsList,
                                                                   szName,
                                                                   BufSize,
                                                                   cSubKeys) ) {

                     Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                     break;
                  }
                  nAdded++;
               }

            } else if ( ERROR_NO_MORE_ITEMS != Win32Rc ) {
               break;
            }

         } while ( Win32Rc != ERROR_NO_MORE_ITEMS );

         if ( Win32Rc == ERROR_NO_MORE_ITEMS ) {
            Win32Rc = ERROR_SUCCESS;
         }


         //
         // free the enumeration buffer
         //
         ScepFree(szName);
      }
   }

   if ( hKey ) {

      RegCloseKey(hKey);
   }


   if ( ERROR_SUCCESS == Win32Rc ) {
      //
      // add the name list to the output arrays
      //
      DWORD nNewCount = *pCount + nAdded;
      PSCE_REGISTRY_VALUE_INFO aNewArray;

      if ( nNewCount ) {

         aNewArray = (PSCE_REGISTRY_VALUE_INFO)ScepAlloc(0, nNewCount*sizeof(SCE_REGISTRY_VALUE_INFO));

         if ( aNewArray ) {

            DWORD i;
            for ( i=0; i<*pCount; i++ ) {
               aNewArray[i].FullValueName = (*paRegValues)[i].FullValueName;
               aNewArray[i].Value = (*paRegValues)[i].Value;
               aNewArray[i].ValueType = (*paRegValues)[i].ValueType;
            }

            i=0;
            for ( PSCE_NAME_STATUS_LIST pns=pnsList;
                pns; pns=pns->Next ) {

               if ( pns->Name && i < nAdded ) {

                  aNewArray[*pCount+i].FullValueName = pns->Name;
                  pns->Name = NULL;
                  aNewArray[*pCount+i].Value = NULL;
                  aNewArray[*pCount+i].ValueType = pns->Status;

                  i++;

               }
            }

            //
            // free the original array
            // all components in the array are already transferred to the new array
            //
            ScepFree(*paRegValues);
            *pCount = nNewCount;
            *paRegValues = aNewArray;

         } else {

            Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
   }

   if ( ERROR_FILE_NOT_FOUND == Win32Rc ||
        ERROR_PATH_NOT_FOUND == Win32Rc ) {
       //
       // no value has been registered
       //
       Win32Rc = ERROR_SUCCESS;
   }

   //
   // free the name status list
   //
   SceFreeMemory(pnsList, SCE_STRUCT_NAME_STATUS_LIST);

   return( ScepDosErrorToSceStatus(Win32Rc) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\polsrv.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    polsvr.cpp

Abstract:

    Server routines to get policy notification

Author:

    Jin Huang (jinhuang) 17-Jun-1998

Revision History:

-*/

#include "headers.h"
#include "serverp.h"
#include "pfp.h"
#include "scesetup.h"
#include "queue.h"
#include <sddl.h>
#include <ntldap.h>

//#include <gpedit.h>
//#include <initguid.h>
//#include <gpeditp.h>
#include <io.h>

#pragma hdrstop

DWORD
ScepNotifyGetAuditPolicies(
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    OUT BOOL *pbChanged
    );

DWORD
ScepNotifyPrivilegeChanges(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID AccountSid,
    IN BOOL bAccountDeleted,
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN OUT PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    OUT BOOL *pbChanged
    );

SCESTATUS
ScepNotifySaveFixValueSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName
    );

SCESTATUS
ScepNotifySavedAuditPolicy(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo
    );

SCESTATUS
ScepNotifySavedPrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivList,
    IN PSCE_PRIVILEGE_ASSIGNMENT pMergedList
    );

SCESTATUS
ScepNotifySavedSystemAccess(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo
    );

//*************************************************
DWORD
ScepNotifyGetChangedPolicies(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    OUT BOOL *pbChanged
    )
/*
Routine Description:

    Determine if policy has been changed in this notification (DbType and ObjectType).

    If the effective policy buffer (pScpInfo) exists, should compare with
    effective policy buffer because that's the last policy configured
    on the system which may come from a domain GPO. If There is no effective
    policy (such as in seutp clean install), the local policy should be
    used to compare.

Arguments:

    pSmpInfo    - local policy

    pScpInfo    - effective policy

    pbChanged   - if the policy is changed, it's set to TRUE

*/
{

    if ( pSmpInfo == NULL || pbChanged == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbChanged = FALSE;

    DWORD rc=ERROR_INVALID_PARAMETER;

    switch ( DbType) {
    case SecurityDbLsa:

        //
        // LSA policy changes
        //

        if ( ObjectType == SecurityDbObjectLsaPolicy ) {
            //
            // maybe audit policy is changed
            //

            rc = ScepNotifyGetAuditPolicies(pSmpInfo, pScpInfo, bSaveToLocal, pbChanged);

        } else {
            //
            // account policy is changed (user rights)
            //
            rc = ScepNotifyPrivilegeChanges(DeltaType,
                                            ObjectSid,
                                            FALSE,
                                            pSmpInfo,
                                            pScpInfo,
                                            bSaveToLocal,
                                            ExplicitLowRight,
                                            ExplicitHighRight,
                                            pbChanged);

        }

        break;

    case SecurityDbSam:

        //
        // SAM password and account policy changes
        //
        if ( ObjectType == SecurityDbObjectSamDomain ) {

            rc = ScepAnalyzeSystemAccess(pSmpInfo,
                                         pScpInfo,
                                         SCEPOL_SAVE_BUFFER |
                                          (bSaveToLocal ? SCEPOL_SAVE_DB : 0 ),
                                         pbChanged,
                                         NULL
                                        );

            ScepNotifyLogPolicy(rc, FALSE, L"Query/compare system access", DbType, ObjectType, NULL);

        } else {

            //
            // account is deleted. Should delete it from user rights
            //
            rc = ScepNotifyPrivilegeChanges(DeltaType,
                                            ObjectSid,
                                            TRUE,
                                            pSmpInfo,
                                            pScpInfo,
                                            bSaveToLocal,
                                            ExplicitLowRight,
                                            ExplicitHighRight,
                                            pbChanged);
        }

        break;

    default:

        rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}


DWORD
ScepNotifyGetAuditPolicies(
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    OUT BOOL *pbChanged
    )
/*
Routine Description:

    Determine if audit policy has been changed in this notification.

    If the effective policy buffer (pScpInfo) exists, should compare with
    effective policy buffer because that's the last policy configured
    on the system which may come from a domain GPO. If There is no effective
    policy (such as in seutp clean install), the local policy should be
    used to compare.

Arguments:

    pSmpInfo    - local policy

    pScpInfo    - effective policy

    pbChanged   - if the audit policy is changed, it's set to TRUE

*/
{

    LSA_HANDLE      lsaHandle=NULL;
    NTSTATUS        status;
    DWORD           rc;

    //
    // check if auditing policy is defined in the storage
    //

    PSCE_PROFILE_INFO pTmpInfo;

    if ( pScpInfo ) {
        pTmpInfo = pScpInfo;
    } else {
        pTmpInfo = pSmpInfo;
    }

    DWORD *pdwTemp = (DWORD *)&(pTmpInfo->AuditSystemEvents);
    BOOL bDefined=FALSE;

    for ( DWORD i=0; i<9; i++ ) {
        if ( *pdwTemp != SCE_NO_VALUE ) {
            bDefined = TRUE;
            break;
        }
        pdwTemp++;
    }

    if ( !bDefined ) {
        ScepNotifyLogPolicy(0, FALSE, L"No audit policy is defined", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );
        return ERROR_SUCCESS;
    }

    //
    // open Lsa policy for read/write
    //

    ScepNotifyLogPolicy(0, FALSE, L"Open LSA", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );

    status = ScepOpenLsaPolicy(
                    POLICY_VIEW_AUDIT_INFORMATION |
                    POLICY_AUDIT_LOG_ADMIN,
                    &lsaHandle,
                    TRUE
                    );

    if ( !NT_SUCCESS(status) ) {

        lsaHandle = NULL;
        rc = RtlNtStatusToDosError( status );

        ScepNotifyLogPolicy(rc, FALSE, L"Open failed", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );

        return(rc);
    }

    PPOLICY_AUDIT_EVENTS_INFO pAuditEvent=NULL;

    //
    // Query audit event information
    //

    status = LsaQueryInformationPolicy( lsaHandle,
                                      PolicyAuditEventsInformation,
                                      (PVOID *)&pAuditEvent
                                    );
    rc = RtlNtStatusToDosError( status );

    ScepNotifyLogPolicy(rc, FALSE, L"Query Audit", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );

    if ( NT_SUCCESS( status ) ) {

        //
        // restore the auditing mode
        //
        DWORD *pdwAuditAddr=&(pTmpInfo->AuditSystemEvents);
        DWORD *pdwLocalAudit=&(pSmpInfo->AuditSystemEvents);

        DWORD dwVal;

        for ( ULONG i=0; i<pAuditEvent->MaximumAuditEventCount && i<9; i++ ) {
            //
            // because secedit buffer is not defined in the exact same sequence as
            // POLICY_AUDIT_EVENT_TYPE, have to case this
            //
            dwVal = pAuditEvent->AuditingMode ? pAuditEvent->EventAuditingOptions[i] : 0;
            switch ( i ) {
            case AuditCategoryDetailedTracking:
                if ( pTmpInfo->AuditProcessTracking != SCE_NO_VALUE &&
                     pTmpInfo->AuditProcessTracking != dwVal ) {
                    // save the setting in local policy table
                    pSmpInfo->AuditProcessTracking = dwVal;
                    *pbChanged = TRUE;
                } else if ( bSaveToLocal ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pSmpInfo->AuditProcessTracking = SCE_NO_VALUE;
                }
                break;
            case AuditCategoryPolicyChange:
                if ( pTmpInfo->AuditPolicyChange != SCE_NO_VALUE &&
                     pTmpInfo->AuditPolicyChange != dwVal ) {
                    pSmpInfo->AuditPolicyChange = dwVal;
                    *pbChanged = TRUE;
                } else if ( bSaveToLocal ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pSmpInfo->AuditPolicyChange = SCE_NO_VALUE;
                }
                break;
            case AuditCategoryAccountManagement:
                if ( pTmpInfo->AuditAccountManage != SCE_NO_VALUE &&
                     pTmpInfo->AuditAccountManage != dwVal ) {
                    pSmpInfo->AuditAccountManage = dwVal;
                    *pbChanged = TRUE;
                } else if ( bSaveToLocal ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pSmpInfo->AuditAccountManage = SCE_NO_VALUE;
                }
                break;
            default:
                if ( pdwAuditAddr[i] != SCE_NO_VALUE &&
                     pdwAuditAddr[i] != dwVal ) {
                    pdwLocalAudit[i] = dwVal;
                    *pbChanged = TRUE;
                } else if ( bSaveToLocal ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pdwLocalAudit[i] = SCE_NO_VALUE;
                }
                break;
            }
        }

        LsaFreeMemory((PVOID)pAuditEvent);
    }

    LsaClose( lsaHandle );

    return(rc);

}


DWORD
ScepNotifyPrivilegeChanges(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID AccountSid,
    IN BOOL bAccountDeleted,
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN OUT PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    IN BOOL *pbChanged
    )
/*
Routine Description:

    Determine if user rights has been changed in this notification.

    If the effective policy buffer (pScpInfo) exists, should compare with
    effective policy buffer because that's the last policy configured
    on the system which may come from a domain GPO. If There is no effective
    policy (such as in seutp clean install), the local policy should be
    used to compare.

    User rights should all come in the exact same format as defined in policy
    storage (for example, SID string or free text names). There is no account
    lookup in the query.

Arguments:

    pSmpInfo    - local policy

    pScpInfo    - effective policy

    pbChanged   - if the user rights is changed, it's set to TRUE

*/
{
    if ( AccountSid == NULL || pSmpInfo == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // open Lsa policy
    //
    LSA_HANDLE      lsaHandle=NULL;
    NTSTATUS        NtStatus;
    DWORD           rc=0;

    //
    // open Lsa policy for read/write
    //

    ScepNotifyLogPolicy(0, FALSE, L"Open LSA", SecurityDbLsa, SecurityDbObjectLsaAccount, NULL );

//    GENERIC_READ | GENERIC_EXECUTE |  bug in LsaOpenPolicy, can't pass in generic access

    NtStatus = ScepOpenLsaPolicy(
                    POLICY_VIEW_LOCAL_INFORMATION |
                    POLICY_LOOKUP_NAMES,
                    &lsaHandle,
                    TRUE
                    );

    if ( !NT_SUCCESS(NtStatus) ) {

        lsaHandle = NULL;
        ScepNotifyLogPolicy(RtlNtStatusToDosError(NtStatus),
                            FALSE,
                            L"Open Failed",
                            SecurityDbLsa,
                            SecurityDbObjectLsaAccount,
                            NULL );
        return ( RtlNtStatusToDosError( NtStatus ) );

    }

    ScepNotifyLogPolicy(0,
                        FALSE,
                        L"Open completed",
                        SecurityDbLsa,
                        SecurityDbObjectLsaAccount,
                        NULL );

    PWSTR StringSid=NULL;
    DWORD StringLen=0;

    //
    // convert sid to sid string
    //
    ScepConvertSidToPrefixStringSid(AccountSid, &StringSid);

    ScepNotifyLogPolicy(0, FALSE, L"Convert to string SID", SecurityDbLsa, SecurityDbObjectLsaAccount, StringSid );

    LPTSTR AccountName = NULL;
    DWORD  Len=0;

    if ( !bAccountDeleted ) {

        //
        // translate account sid to name
        //

        BOOL bFromAccountDomain = ScepIsSidFromAccountDomain( AccountSid );

        NtStatus = ScepConvertSidToName(
                            lsaHandle,
                            AccountSid,
                            bFromAccountDomain,
                            &AccountName,
                            &Len
                            );

        rc = RtlNtStatusToDosError(NtStatus);

        ScepNotifyLogPolicy(rc,
                            FALSE,
                            L"Get Account Name",
                            SecurityDbLsa,
                            SecurityDbObjectLsaAccount,
                            AccountName ? AccountName : StringSid);

    }

    DWORD dwPrivLowHeld, dwPrivHighHeld;

    if ( AccountName || StringSid ) {

        NtStatus = STATUS_SUCCESS;
        //
        // find out the account name pointer (without domain prefix)
        //
        PWSTR pNameStart = NULL;

        if ( AccountName ) {
            pNameStart = wcschr(AccountName, L'\\');

            if ( pNameStart ) {
                //
                // domain relative account, check if this is from a foreign domain
                //
                UNICODE_STRING u;
                u.Buffer = AccountName;
                u.Length = ((USHORT)(pNameStart-AccountName))*sizeof(WCHAR);

                if ( ScepIsDomainLocal(&u) ) {
                    //
                    // local domain (builtin, account, ...)
                    // this can be used to match free text accounts
                    //
                    pNameStart++;
                } else {
                    //
                    // account from a foreign domain
                    // do not allow mapping of free text accounts
                    //
                    pNameStart = NULL;
                }
            } else pNameStart = AccountName;
        }

        if ( StringSid ) StringLen = wcslen(StringSid);

        if ( DeltaType == SecurityDbDelete ) {

            dwPrivLowHeld = 0;
            dwPrivHighHeld = 0;

        } else if ( ExplicitLowRight != 0 ||
                    ExplicitHighRight != 0 ) {

            dwPrivLowHeld = ExplicitLowRight;
            dwPrivHighHeld = ExplicitHighRight;

        } else {

            //
            // get all privileges assigned to this account
            //

            NtStatus = ScepGetAccountExplicitRight(
                                lsaHandle,
                                AccountSid,
                                &dwPrivLowHeld,
                                &dwPrivHighHeld
                                );
        }

        rc = RtlNtStatusToDosError(NtStatus);

        WCHAR Msg[50];
        swprintf(Msg, L"Get Priv/Right %8x %8x\0", dwPrivHighHeld, dwPrivLowHeld);

        ScepNotifyLogPolicy(rc,
                            FALSE,
                            Msg,
                            SecurityDbLsa,
                            SecurityDbObjectLsaAccount,
                            AccountName ? AccountName : StringSid );

        if ( NT_SUCCESS(NtStatus) ) {

            //
            // loop through each privilege defined in SCE to add/remove the account
            //
            PSCE_PRIVILEGE_ASSIGNMENT pTemp, pTemp2;
            PSCE_NAME_LIST pName, pParent, pName2, pParent2;
            INT i;

            for ( pTemp2=pSmpInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                  pTemp2 != NULL; pTemp2=pTemp2->Next ) {
                pTemp2->Status = SCE_STATUS_NOT_CONFIGURED;
            }

            if ( pScpInfo && bSaveToLocal ) {
                //
                // !!!do this only when save to database!!!
                // if there is effective policy, compare with effective rights
                // modify both effective policy list and local policy list
                //
                for ( pTemp=pScpInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                      pTemp != NULL; pTemp=pTemp->Next ) {

                    pTemp->Status = 0;

                    i = ScepLookupPrivByName(pTemp->Name);

                    if ( i > -1 ) {

                        //
                        // find the local policy match
                        //
                        for ( pTemp2=pSmpInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                              pTemp2 != NULL; pTemp2=pTemp2->Next ) {
                            if ( _wcsicmp(pTemp->Name, pTemp2->Name) == 0 ) {
                                // find it
                                break;
                            }
                        }

                        //
                        // compare with effective policy
                        // try to find in string sid first, then full account name,
                        // and last free text account
                        //
                        for ( pName=pTemp->AssignedTo, pParent=NULL;
                              pName != NULL; pParent=pName, pName = pName->Next ) {
                            if ( (StringSid && _wcsicmp(StringSid, pName->Name) == 0) ||
                                 (AccountName && _wcsicmp(AccountName, pName->Name) == 0) ||
                                 (pNameStart && _wcsicmp(pNameStart, pName->Name) == 0) ) {
                                // find it
                                break;
                            }
                        }

                        //
                        // also find the match in local policy (if there is any)
                        // try to find in string sid first, then full account name,
                        // and last free text account
                        //
                        if ( pTemp2 ) {

                            pTemp2->Status = 0;

                            for ( pName2=pTemp2->AssignedTo, pParent2=NULL;
                                  pName2 != NULL; pParent2=pName2, pName2 = pName2->Next ) {
                                if ( (StringSid && _wcsicmp(StringSid, pName2->Name) == 0) ||
                                     (AccountName && _wcsicmp(AccountName, pName2->Name) == 0) ||
                                     (pNameStart && _wcsicmp(pNameStart, pName2->Name) == 0) ) {
                                    // find it
                                    break;
                                }
                            }
                        } else {
                            pName2 = NULL;
                            pParent2 = NULL;
                        }

                        //
                        // now adjust the lists
                        //
                        if ( ( ( i < 32 ) && ( dwPrivLowHeld & (1 << i) ) ) ||
                             ( ( i >= 32 ) && ( dwPrivHighHeld & (1 << (i-32) ) ) ) ) {

                            if ( pName == NULL ) {
                                //
                                // add this node to effective list
                                //
                                rc = ScepAddToNameList(&(pTemp->AssignedTo),
                                                       StringSid ? StringSid : AccountName,
                                                       StringSid ? StringLen : Len);

                                *pbChanged = TRUE;
                                pTemp->Status = SCE_STATUS_MISMATCH;

                                if ( rc != ERROR_SUCCESS ) {
                                    break;
                                }
                            }
                            if ( (pTemp2 != NULL) && (pName2 == NULL) ) {
                                //
                                // should add this node to local policy node
                                //
                                rc = ScepAddToNameList(&(pTemp2->AssignedTo),
                                                        StringSid ? StringSid : AccountName,
                                                        StringSid ? StringLen : Len);

                                *pbChanged = TRUE;
                                pTemp2->Status = SCE_STATUS_MISMATCH;

                                if ( rc != ERROR_SUCCESS ) {
                                    break;
                                }
                            }

                        } else {

                            if ( pName ) {

                                //
                                // should remove it from effective list
                                //
                                if ( pParent ) {
                                    pParent->Next = pName->Next;
                                } else {
                                    pTemp->AssignedTo = pName->Next;
                                }

                                pName->Next = NULL;
                                ScepFree(pName->Name);
                                ScepFree(pName);
                                pName = NULL;

                                *pbChanged = TRUE;
                                pTemp->Status = SCE_STATUS_MISMATCH;
                            }

                            if ( pTemp2 && pName2 ) {
                                //
                                // should remove it from local list
                                //
                                if ( pParent2 ) {
                                    pParent2->Next = pName2->Next;
                                } else {
                                    pTemp2->AssignedTo = pName2->Next;
                                }

                                pName2->Next = NULL;
                                ScepFree(pName2->Name);
                                ScepFree(pName2);
                                pName2 = NULL;

                                *pbChanged = TRUE;
                                pTemp2->Status = SCE_STATUS_MISMATCH;
                            }
                        }

                        if ( i < 32 ) {

                            dwPrivLowHeld &= ~(1 << i);
                        } else {
                            dwPrivHighHeld &= ~(1 << (i-32) );
                        }
                    }
                }
            }

            for ( pTemp=pSmpInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                  pTemp != NULL; pTemp=pTemp->Next ) {

                if ( pTemp->Status != SCE_STATUS_NOT_CONFIGURED ) {
                    //
                    // this one was already checked in previous loop
                    //
                    continue;
                }

                //
                // when get here, this privilege must not be found
                // in the effective right list (or the effective
                // right list is NULL)
                //
                pTemp->Status = 0;

                i = ScepLookupPrivByName(pTemp->Name);

                if ( i > -1 ) {

                    //
                    // detect if anything changed (with the local policy)
                    //

                    for ( pName=pTemp->AssignedTo, pParent=NULL;
                          pName != NULL; pParent=pName, pName = pName->Next ) {
                        if ( (StringSid && _wcsicmp(StringSid, pName->Name) == 0) ||
                             (AccountName && _wcsicmp(AccountName, pName->Name) == 0) ||
                             (pNameStart && _wcsicmp(pNameStart, pName->Name) == 0) ) {
                            // find it
                            break;
                        }
                    }

                   if ( ( ( i < 32 ) && ( dwPrivLowHeld & (1 << i) ) ) ||
                        ( ( i >= 32 ) && ( dwPrivHighHeld & (1 << (i-32) ) ) ) ) {

                       if ( pName == NULL ) {
                           //
                           // should add this node
                           //
                           rc = ScepAddToNameList(&(pTemp->AssignedTo),
                                                   StringSid ? StringSid : AccountName,
                                                   StringSid ? StringLen : Len);

                           *pbChanged = TRUE;
                           pTemp->Status = SCE_STATUS_MISMATCH;

                           if ( rc != ERROR_SUCCESS ) {
                               break;
                           }
                       }

                   } else {

                       if ( pName ) {

                           //
                           // should remove it
                           //
                           if ( pParent ) {
                               pParent->Next = pName->Next;
                           } else {
                               pTemp->AssignedTo = pName->Next;
                           }

                           pName->Next = NULL;
                           ScepFree(pName->Name);
                           ScepFree(pName);
                           pName = NULL;

                           *pbChanged = TRUE;
                           pTemp->Status = SCE_STATUS_MISMATCH;
                       }
                   }

                   if ( i < 32 ) {

                       dwPrivLowHeld &= ~(1 << i);
                   } else {
                       dwPrivHighHeld &= ~(1 << (i-32) );
                   }

                }
            }

#if 0
            //
            // if the privilege is not covered by the template/db,
            // do not trap it becuase user explicitly exclude this one.
            //
            if ( rc == ERROR_SUCCESS &&
                 ( dwPrivLowHeld || dwPrivHighHeld ) ) {

                //
                // other new privileges added which are not in the template
                //

                for ( i=0; i<cPrivCnt; i++) {

                    if ( ( ( i < 32 ) && ( dwPrivLowHeld & (1 << i) ) ) ||
                         ( ( i >= 32 ) && ( dwPrivHighHeld & (1 << (i-32) ) ) ) ) {

                        //
                        // add this account/right to the list
                        //

                        rc = ERROR_NOT_ENOUGH_MEMORY;

                        pTemp = (PSCE_PRIVILEGE_ASSIGNMENT)ScepAlloc( LMEM_ZEROINIT,
                                                                      sizeof(SCE_PRIVILEGE_ASSIGNMENT) );
                        if ( pTemp ) {
                            pTemp->Name = (PWSTR)ScepAlloc( (UINT)0, (wcslen(SCE_Privileges[i].Name)+1)*sizeof(WCHAR));

                            if ( pTemp->Name != NULL ) {

                                wcscpy(pTemp->Name, SCE_Privileges[i].Name);
                                pTemp->Status = SCE_STATUS_GOOD;
                                pTemp->AssignedTo = NULL;

                                rc = ScepAddToNameList(&(pTemp->AssignedTo),
                                                        StringSid ? StringSid : AccountName,
                                                        StringSid ? StringLen : Len);

                                *pbChanged = TRUE;

                                if ( rc != ERROR_SUCCESS ) {

                                    ScepFree(pTemp->Name);
                                }

                            }

                            if ( ERROR_SUCCESS != rc ) {

                                ScepFree(pTemp);
                            }

                        }

                        if ( ERROR_SUCCESS == rc ) {
                            //
                            // add this node to the list
                            //
                            pTemp->Next = pSceInfo->OtherInfo.smp.pPrivilegeAssignedTo;
                            pSceInfo->OtherInfo.smp.pPrivilegeAssignedTo = pTemp;
                            pTemp = NULL;

                        } else {

                            break;
                        }

                    }

                } // loop to the next privilege
            }  // there are new privileges added to the template
#endif

            ScepNotifyLogPolicy(rc,
                                FALSE,
                                L"Rights Modified",
                                SecurityDbLsa,
                                SecurityDbObjectLsaAccount,
                                AccountName ? AccountName : StringSid);

        } // success getting current privileges assigned to the account
    }

    if ( AccountName ) {
        LocalFree(AccountName);
    }

    if ( StringSid ) {
        LocalFree(StringSid);
    }

    LsaClose( lsaHandle );

    return rc;
}


DWORD
ScepNotifySaveChangedPolicies(
    IN PSCECONTEXT hProfile,
    IN SECURITY_DB_TYPE DbType,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pMergedInfo OPTIONAL
    )
{

    if ( hProfile == NULL || pInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS    rc;

    rc = SceJetStartTransaction( hProfile );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Area & AREA_SECURITY_POLICY ) {

            //
            // handle auditing policy
            //

            if ( DbType == SecurityDbLsa ) {
                rc = ScepNotifySavedAuditPolicy(hProfile,
                                                pInfo
                                               );
            } else {
                rc = ScepNotifySavedSystemAccess(hProfile,
                                                pInfo
                                               );
            }
        }

        if ( (SCESTATUS_SUCCESS == rc) &&
             (Area & AREA_PRIVILEGES) ) {

            //
            // handle user rights.
            //

            rc = ScepNotifySavedPrivileges(hProfile,
                                           pInfo->OtherInfo.smp.pPrivilegeAssignedTo,
                                           pMergedInfo ? pMergedInfo->OtherInfo.smp.pPrivilegeAssignedTo : NULL
                                          );
        }

        if ( rc == SCESTATUS_SUCCESS ) {
           //
           // needs return code for commiting the transaction
           //
           rc = SceJetCommitTransaction(hProfile, 0);

        }
        if ( rc != SCESTATUS_SUCCESS ) {

            SceJetRollback(hProfile, 0);
        }
    }


    return( ScepSceStatusToDosError(rc) );
}


SCESTATUS
ScepNotifySavedAuditPolicy(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo
    )
{
    SCE_KEY_LOOKUP       EventKeys[]={
        {(PWSTR)TEXT("AuditSystemEvents"),  offsetof(struct _SCE_PROFILE_INFO, AuditSystemEvents),   'D'},
        {(PWSTR)TEXT("AuditLogonEvents"),   offsetof(struct _SCE_PROFILE_INFO, AuditLogonEvents),    'D'},
        {(PWSTR)TEXT("AuditObjectAccess"),  offsetof(struct _SCE_PROFILE_INFO, AuditObjectAccess),   'D'},
        {(PWSTR)TEXT("AuditPrivilegeUse"),  offsetof(struct _SCE_PROFILE_INFO, AuditPrivilegeUse),   'D'},
        {(PWSTR)TEXT("AuditPolicyChange"),  offsetof(struct _SCE_PROFILE_INFO, AuditPolicyChange),   'D'},
        {(PWSTR)TEXT("AuditAccountManage"), offsetof(struct _SCE_PROFILE_INFO, AuditAccountManage),  'D'},
        {(PWSTR)TEXT("AuditProcessTracking"),offsetof(struct _SCE_PROFILE_INFO, AuditProcessTracking),'D'},
        {(PWSTR)TEXT("AuditDSAccess"),      offsetof(struct _SCE_PROFILE_INFO, AuditDSAccess),       'D'},
        {(PWSTR)TEXT("AuditAccountLogon"),  offsetof(struct _SCE_PROFILE_INFO, AuditAccountLogon),   'D'}};

    DWORD cKeys = sizeof(EventKeys) / sizeof(SCE_KEY_LOOKUP);


    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    return( ScepNotifySaveFixValueSection(
                hProfile,
                pInfo,
                EventKeys,
                cKeys,
                szAuditEvent
                ) );
}

SCESTATUS
ScepNotifySavedSystemAccess(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo
    )
{
    SCE_KEY_LOOKUP AccessKeys[] = {
        {(PWSTR)TEXT("MinimumPasswordAge"),     offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),    'D'},
        {(PWSTR)TEXT("MaximumPasswordAge"),     offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),    'D'},
        {(PWSTR)TEXT("MinimumPasswordLength"),  offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength), 'D'},
        {(PWSTR)TEXT("PasswordComplexity"),     offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),    'D'},
        {(PWSTR)TEXT("PasswordHistorySize"),    offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),   'D'},
        {(PWSTR)TEXT("LockoutBadCount"),        offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),       'D'},
        {(PWSTR)TEXT("ResetLockoutCount"),      offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),     'D'},
        {(PWSTR)TEXT("LockoutDuration"),        offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),       'D'},
        {(PWSTR)TEXT("RequireLogonToChangePassword"),offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword),'D'},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire"),offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire),'D'},
        {(PWSTR)TEXT("ClearTextPassword"),      offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),     'D'}
        };
    DWORD cKeys = sizeof(AccessKeys) / sizeof(SCE_KEY_LOOKUP);


    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    return( ScepNotifySaveFixValueSection(
                hProfile,
                pInfo,
                AccessKeys,
                cKeys,
                szSystemAccess
                ) );
}


SCESTATUS
ScepNotifySaveFixValueSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName
    )
{

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL, hSectionScp=NULL;

    DWORD       i;
    UINT        Offset;
    DWORD       valNewScep;

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                SectionName,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        DWORD dwThisTable = hProfile->Type & 0xF0L;

        if ( SCEJET_MERGE_TABLE_1 == dwThisTable ||
             SCEJET_MERGE_TABLE_2 == dwThisTable ) {

            if ( SCESTATUS_SUCCESS != ScepOpenSectionForName(
                                        hProfile,
                                        SCE_ENGINE_SCP,
                                        SectionName,
                                        &hSectionScp
                                        ) ) {
                hSectionScp = NULL;
            }
        }

        for ( i=0; i<cKeys; i++) {

            //
            // get settings in AccessLookup table
            //

            Offset = Keys[i].Offset;

            switch ( Keys[i].BufferType ) {
            case 'B':
                break;

            case 'D':

                valNewScep = *((DWORD *)((CHAR *)pInfo+Offset));

                //
                // update the SMP entry
                //
                rc = ScepCompareAndSaveIntValue(
                            hSectionSmp,
                            Keys[i].KeyString,
                            FALSE,
                            SCE_NO_VALUE,
                            valNewScep
                            );

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    //
                    // if not find for delete, ignore the error
                    //
                    rc = SCESTATUS_SUCCESS;

                } else if ( SCESTATUS_SUCCESS == rc &&
                            hSectionScp ) {

                    //
                    // update the SCP entry, ignore error
                    //
                    ScepCompareAndSaveIntValue(
                            hSectionScp,
                            Keys[i].KeyString,
                            FALSE,
                            SCE_NO_VALUE,
                            valNewScep
                            );
                }

                break;

            default:
                break;
            }

            if ( rc != SCESTATUS_SUCCESS ) {
                break;
            }
        }

        if ( hSectionScp ) {
            SceJetCloseSection(&hSectionScp, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);

}


SCESTATUS
ScepNotifySavedPrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivList,
    IN PSCE_PRIVILEGE_ASSIGNMENT pMergedList OPTIONAL
    )
/*
Routine Description:

    Update privileges from

Arguements:

    hProfile - the jet database handle

    pPrivList    - the changed privilege buffer

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL, hSectionScp=NULL;
    PSCE_PRIVILEGE_ASSIGNMENT pPriv;

    if ( hProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pPrivList == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    LSA_HANDLE lsaHandle=NULL;

/*  no need to lookup account in save
    rc = RtlNtStatusToDosError(
            ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &lsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {

        lsaHandle = NULL;

        ScepNotifyLogPolicy(rc, FALSE, L"Open failed", SecurityDbLsa, SecurityDbObjectLsaPolicy, NULL );

        return(ScepDosErrorToSceStatus(rc));
    }
*/
    //
    // open smp section for privileges
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szPrivilegeRights,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        // if SCP is different then SMP, open it

        DWORD dwThisTable = hProfile->Type & 0xF0L;


        if ( SCEJET_MERGE_TABLE_1 == dwThisTable ||
             SCEJET_MERGE_TABLE_2 == dwThisTable ) {

            if ( SCESTATUS_SUCCESS != ScepOpenSectionForName(
                                        hProfile,
                                        SCE_ENGINE_SCP,
                                        szPrivilegeRights,
                                        &hSectionScp
                                        ) ) {
                hSectionScp = NULL;
            }
        }

        for ( pPriv=pPrivList; pPriv != NULL; pPriv = pPriv->Next ) {
            //
            // Process each privilege in the new list
            // Update SMP with new value
            //
            if ( pPriv->Status == SCE_STATUS_MISMATCH ) {

                //
                // this is in name format, should convert it
                //
                rc = ScepWriteNameListValue(
                        lsaHandle,
                        hSectionSmp,
                        pPriv->Name,
                        pPriv->AssignedTo,
                        SCE_WRITE_EMPTY_LIST, //  | SCE_WRITE_CONVERT, no need to lookup
                        0
                        );

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS) {
                    break;
                }
            }
        }

        if ( hSectionScp && pMergedList ) {

            for ( pPriv=pMergedList; pPriv != NULL; pPriv = pPriv->Next ) {
                //
                // Process each privilege in the new list
                // Update SCP with new value, don't care error
                //
                if ( pPriv->Status == SCE_STATUS_MISMATCH ) {

                    //
                    // this is in name format, convert it
                    //
                    rc = ScepWriteNameListValue(
                            lsaHandle,
                            hSectionScp,
                            pPriv->Name,
                            pPriv->AssignedTo,
                            SCE_WRITE_EMPTY_LIST, // no need to lookup | SCE_WRITE_CONVERT,
                            0
                            );

                    rc = SCESTATUS_SUCCESS;

                }
            }

        }

        if ( hSectionScp ) {
            SceJetCloseSection(&hSectionScp, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    if ( lsaHandle ) {
        LsaClose(lsaHandle);
    }

    return(rc);

}

DWORD
ScepNotifyGetDefaultGPOTemplateName(
    UNICODE_STRING DnsDomainName,
    IN BOOL bDomainPolicy,
    IN DWORD dwInSetup,
    OUT LPTSTR *pTemplateName
    )
/*
Return the GPO template name to use

In NT4 upgrade, because DS is not created yet, a temporary file is used in
%windir%\security\filtemp.inf

In NT5 upgrade, because network is not running in setup (sysvol share is not
accessible), the GPO template is referenced with absolute path, e.g.
%windir%\sysvol\sysvol\<dns name>\.... If sysvol path can't be queried,
the temporary file as in NT4 case is used.

Outside setup when DS/network is running, the GPO template is referenced with
the DNS UNC path, e.g, \\<computername>\sysvol\<dns name>\...


*/
{

    if ( ( dwInSetup != SCEGPO_INSETUP_NT4 &&
           ( DnsDomainName.Buffer == NULL ||
             DnsDomainName.Length == 0)) ||
           pTemplateName == NULL ) {

        return(ERROR_INVALID_PARAMETER);
    }
    //
    // we have to replace the first DNS name with computer name
    // because it might point to a remote machine where
    // we don't have write access.
    //


    TCHAR Buffer[MAX_PATH+1];
    DWORD dSize=MAX_PATH;
    PWSTR SysvolPath=NULL;

    Buffer[0] = L'\0';
    BOOL bDefaultToNT4 = FALSE;

    if ( dwInSetup == SCEGPO_INSETUP_NT5 ) {
        //
        // query the sysvol path from netlogon\parameters\sysvol registry value
        //

        DWORD RegType;
        DWORD rc = ScepRegQueryValue(HKEY_LOCAL_MACHINE,
                               L"System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
                               L"Sysvol",
                               (PVOID *)&SysvolPath,
                               &RegType
                              );

        if ( ERROR_SUCCESS != rc || SysvolPath == NULL || RegType != REG_SZ) {

            bDefaultToNT4 = TRUE;
            if ( SysvolPath ) {
                ScepFree(SysvolPath);
                SysvolPath = NULL;
            }
        }
    }

    if ( dwInSetup ) {
        // get %windir% directory
        GetSystemWindowsDirectory(Buffer, MAX_PATH);

    } else {
        // get computer name
        GetComputerName(Buffer, &dSize);
    }

    Buffer[MAX_PATH] = L'\0';

    dSize = wcslen(Buffer);

    DWORD Len;
    DWORD rc=ERROR_SUCCESS;


    if ( dwInSetup == SCEGPO_INSETUP_NT4 ||
        (dwInSetup == SCEGPO_INSETUP_NT5 && bDefaultToNT4) ) {
        //
        // in setup, use the temp GPO file name
        //

        Len = dSize + wcslen(TEXT("\\security\\filtemp.inf"));

        *pTemplateName = (PWSTR)LocalAlloc(LPTR, (Len+2)*sizeof(TCHAR));

        if ( *pTemplateName ) {

            swprintf(*pTemplateName, L"%s\\security\\filtemp.inf\0", Buffer);

            //
            // create the registry value for post setup
            //

            ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                                SCE_ROOT_PATH,
                                TEXT("PolicyChangedInSetup"),
                                1
                                );

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        return rc;
    }

    if ( dwInSetup ) {
        //
        // in NT5 setup upgrade, should use SysvolPath
        //
        dSize = wcslen(SysvolPath);
        Len = dSize + 1;

    } else {

        Len = 2 + dSize + wcslen(TEXT("\\sysvol\\"));
    }

    Len +=  (   DnsDomainName.Length/sizeof(TCHAR) +
                wcslen(TEXT("\\Policies\\{}\\Machine\\")) +
                wcslen(GPTSCE_TEMPLATE) );

    if ( bDomainPolicy ) {

        Len += wcslen(STR_DEFAULT_DOMAIN_GPO_GUID);

    } else {

        Len += wcslen(STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID);
    }

    PWSTR GpoTemplateName = (PWSTR)LocalAlloc(LPTR, (Len+2)*sizeof(TCHAR));

    if ( GpoTemplateName ) {

        DWORD indx=0;

        if ( dwInSetup ) {
            swprintf(GpoTemplateName, L"%s\\", SysvolPath);
            indx = 1;
        } else {
            swprintf(GpoTemplateName, L"\\\\%s\\sysvol\\", Buffer);
            indx = 10;
        }

        wcsncpy(GpoTemplateName+indx+dSize, DnsDomainName.Buffer, DnsDomainName.Length/2);

        if ( bDomainPolicy ) {
            swprintf(GpoTemplateName+indx+dSize+DnsDomainName.Length/2,
                     L"\\Policies\\{%s}\\Machine\\%s\0",
                     STR_DEFAULT_DOMAIN_GPO_GUID, GPTSCE_TEMPLATE );

        } else {
            swprintf(GpoTemplateName+indx+dSize+DnsDomainName.Length/2,
                     L"\\Policies\\{%s}\\Machine\\%s\0",
                     STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID, GPTSCE_TEMPLATE );

        }

        if ( 0xFFFFFFFF == GetFileAttributes(GpoTemplateName) ) {

            rc = ERROR_OBJECT_NOT_FOUND;

            LocalFree(GpoTemplateName);
            GpoTemplateName = NULL;

        }

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // free the buffers if it fails
    //
    if ( SysvolPath ) {
        ScepFree(SysvolPath);
    }

    *pTemplateName = GpoTemplateName;

    return rc;

}

DWORD
ScepNotifySaveNotifications(
    IN PWSTR TemplateName,
    IN SECURITY_DB_TYPE  DbType,
    IN SECURITY_DB_OBJECT_TYPE  ObjectType,
    IN SECURITY_DB_DELTA_TYPE  DeltaType,
    IN PSID ObjectSid OPTIONAL
    )
{
    if ( TemplateName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD rc=ERROR_SUCCESS;

    if ( SecurityDbLsa == DbType &&
         SecurityDbObjectLsaPolicy == ObjectType ) {
        //
        // LSA policy changes
        //

        if ( !WritePrivateProfileString(L"Policies",
                                        L"LsaPolicy",
                                        L"1",
                                        TemplateName
                                       ) ) {
            rc = GetLastError();
        }

    } else if ( SecurityDbSam == DbType &&
                ObjectType != SecurityDbObjectSamUser &&
                ObjectType != SecurityDbObjectSamGroup &&
                ObjectType != SecurityDbObjectSamAlias ) {

        //
        // if it's not for deleted account, update the SAM policy section
        //

        if ( !WritePrivateProfileString(L"Policies",
                                        L"SamPolicy",
                                        L"1",
                                        TemplateName
                                       ) ) {
            rc = GetLastError();
        }

    } else if ( ObjectSid &&
                (SecurityDbLsa == DbType || SecurityDbSam == DbType ) ) {

        //
        // account policy is changed (user rights)
        // get all privileges assigned to this account
        //

        DWORD dwPrivLowHeld=0, dwPrivHighHeld=0;

        if ( DeltaType == SecurityDbDelete ) {

            dwPrivLowHeld = 0;
            dwPrivHighHeld = 0;

        } else {

            LSA_HANDLE      lsaHandle=NULL;

            NTSTATUS NtStatus = ScepOpenLsaPolicy(
                                    POLICY_VIEW_LOCAL_INFORMATION |
                                        POLICY_LOOKUP_NAMES,
                                    &lsaHandle,
                                    TRUE
                                    );

            if ( NT_SUCCESS(NtStatus) ) {

                NtStatus = ScepGetAccountExplicitRight(
                                    lsaHandle,
                                    ObjectSid,
                                    &dwPrivLowHeld,
                                    &dwPrivHighHeld
                                    );
                LsaClose( lsaHandle );
            }
        }

        PWSTR SidString=NULL;

        if ( ConvertSidToStringSid(ObjectSid,
                                   &SidString
                                  ) &&
             SidString ) {

            TCHAR tmpBuf[40];
            swprintf(tmpBuf, L"%d %d %d\0", (DWORD)DeltaType, dwPrivLowHeld, dwPrivHighHeld);

            if ( !WritePrivateProfileString(L"Accounts",
                                            SidString,
                                            tmpBuf,
                                            TemplateName
                                           ) ) {
                rc = GetLastError();
            }

            LocalFree(SidString);

        } else {
            rc = GetLastError();
        }

    }

    return rc;
}


DWORD
ScepNotifyUpdateGPOVersion(
    IN PWSTR GpoTemplateName,
    IN BOOL bDomainPolicy
    )
/*
Update the version # (in DS and gpt.ini) for machine policy change
property gPCMachineExtensionNames is not changed because security extension
guid should already be there (by default).

*/
{
    if ( GpoTemplateName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD rc=ERROR_SUCCESS;

    //
    // get the current version from gpt.ini
    //
    // build full path of gpt.ini first
    //
    PWSTR pTemp = wcsstr( GpoTemplateName, L"\\Machine\\");

    if ( pTemp == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    PWSTR pszVersionFile = (PWSTR)LocalAlloc(0, (pTemp-GpoTemplateName+wcslen(TEXT("\\gpt.ini"))+1)*sizeof(WCHAR));

    if ( pszVersionFile == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcsncpy(pszVersionFile, GpoTemplateName, (size_t)(pTemp-GpoTemplateName));
    pszVersionFile[pTemp-GpoTemplateName] = L'\0';

    wcscat(pszVersionFile, TEXT("\\gpt.ini"));

    DWORD dwVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, pszVersionFile);

    if ( dwVersion == 0 ) {
        //
        // couldn't find version #, this is bad
        //
        rc = ERROR_FILE_NOT_FOUND;

    } else {

        //
        // bind to DS, get DS root
        //

        PLDAP phLdap = ldap_open(NULL, LDAP_PORT);

        if ( phLdap == NULL ) {

            rc = ERROR_FILE_NOT_FOUND;

        } else {
            rc = ldap_bind_s(phLdap,
                            NULL,
                            NULL,
                            LDAP_AUTH_SSPI);

            if ( rc == ERROR_SUCCESS ) {

                LDAPMessage *Message = NULL;          // for LDAP calls.
                PWSTR    Attribs[3];                  // for LDAP calls.
                LDAPMessage *Entry = NULL;
                PWSTR DsRootName=NULL;

                Attribs[0] = LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W;   // ntldap.h
                Attribs[1] = NULL;
                Attribs[2] = NULL;

                rc = ldap_search_s(phLdap,
                                  L"",
                                  LDAP_SCOPE_BASE,
                                  L"(objectClass=*)",
                                  Attribs,
                                  0,
                                  &Message);

                if( rc == ERROR_SUCCESS ) {

                    //
                    // read the first entry.
                    // we did base level search, we have only one entry.
                    // Entry does not need to be freed (it is freed with the message)
                    //
                    Entry = ldap_first_entry(phLdap, Message);
                    if(Entry != NULL) {

                        PWSTR *Values = ldap_get_values(phLdap, Entry, Attribs[0]);

                        if(Values != NULL) {

                            DsRootName = (PWSTR)LocalAlloc(0, (wcslen(Values[0])+1)*sizeof(WCHAR));

                            if ( DsRootName ) {
                                wcscpy(DsRootName, Values[0]);
                            } else {
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }

                            ldap_value_free(Values);
                        } else
                            rc = LdapMapErrorToWin32(phLdap->ld_errno);

                    } else
                        rc = LdapMapErrorToWin32(phLdap->ld_errno);

                    Entry = NULL;

                }

                //
                // ldap_search can return failure and still allocate the buffer
                //
                if ( Message ) {
                    ldap_msgfree(Message);
                    Message = NULL;
                }

                if ( DsRootName ) {
                    //
                    // query version from DS, if failed, query version from gpt.ini
                    //
                    Attribs[0] = L"distinguishedName";
                    Attribs[1] = L"versionNumber";
                    Attribs[2] = NULL;


                    WCHAR szFilter[128];

                    if ( bDomainPolicy ) {
                        swprintf(szFilter, L"( &(objectClass=groupPolicyContainer)(cn={%s}) )", STR_DEFAULT_DOMAIN_GPO_GUID);
                    } else {
                        swprintf(szFilter, L"( &(objectClass=groupPolicyContainer)(cn={%s}) )", STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID);
                    }

                    phLdap->ld_options = 0; // no chased referrel

                    rc = ldap_search_s(
                              phLdap,
                              DsRootName,
                              LDAP_SCOPE_SUBTREE,
                              szFilter,
                              Attribs,
                              0,
                              &Message);

                    if( rc == ERROR_SUCCESS ) {

                        //
                        // read the first entry.
                        // we did base level search, we have only one entry.
                        // Entry does not need to be freed (it is freed with the message)
                        //
                        Entry = ldap_first_entry(phLdap, Message);
                        if(Entry != NULL) {

                            PWSTR *Values = ldap_get_values(phLdap, Entry, Attribs[0]);

                            if(Values != NULL) {
                                if ( Values[0] == NULL ) {
                                    //
                                    // unknown error.
                                    //
                                    rc = ERROR_FILE_NOT_FOUND;
                                } else {

                                    PWSTR *pszVersions = ldap_get_values(phLdap, Entry, Attribs[1]);

                                    if ( pszVersions && pszVersions[0] ) {
                                        //
                                        // this is the version number
                                        //
                                        dwVersion = _wtol(pszVersions[0]);
                                    }

                                    if ( pszVersions ) {
                                        ldap_value_free(pszVersions);
                                    }

                                    //
                                    // Value[0] is the base GPO name,
                                    // now modify the version #
                                    //

                                    PLDAPMod        rgMods[2];
                                    LDAPMod         Mod;
                                    PWSTR           rgpszVals[2];
                                    WCHAR           szVal[32];
                                    USHORT uMachine, uUser;

                                    //
                                    // split the version # for machine and user
                                    //
                                    uUser = (USHORT) HIWORD(dwVersion);
                                    uMachine = (USHORT) LOWORD(dwVersion);

                                    dwVersion = (ULONG) MAKELONG (uMachine+1, uUser);

                                    rgMods[0] = &Mod;
                                    rgMods[1] = NULL;

                                    memset(szVal, '\0', 32*2);
                                    swprintf(szVal, L"%d", dwVersion);

                                    rgpszVals[0] = szVal;
                                    rgpszVals[1] = NULL;

                                    //
                                    // lets set version number back
                                    //
                                    Mod.mod_op      = LDAP_MOD_REPLACE;
                                    Mod.mod_values  = rgpszVals;
                                    Mod.mod_type    = L"versionNumber";

                                    //
                                    // Now, we'll do the write
                                    //
                                    rc = ldap_modify_s(phLdap,
                                                           Values[0],
                                                           rgMods
                                                           );

                                    if ( rc == ERROR_ALREADY_EXISTS )
                                        rc = ERROR_SUCCESS;

                                    if ( rc == ERROR_SUCCESS ) {
                                        //
                                        // update version in gpt.ini
                                        //
                                        WritePrivateProfileString (TEXT("General"), TEXT("Version"), szVal, pszVersionFile);

                                    }

                                }

                                ldap_value_free(Values);

                            } else
                                rc = LdapMapErrorToWin32(phLdap->ld_errno);
                        } else
                            rc = LdapMapErrorToWin32(phLdap->ld_errno);

                    }

                    LocalFree(DsRootName);

                    //
                    // ldap_search can return failure and still allocate the buffer
                    //
                    if ( Message ) {
                        ldap_msgfree(Message);
                        Message = NULL;
                    }
                }
            }

            ldap_unbind(phLdap);
        }
    }

    LocalFree(pszVersionFile);

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\scejet.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scejet.c

Abstract:

    Sce-Jet service APIs

Author:

    Jin Huang (jinhuang) 13-Jan-1997

Revision History:

--*/

#include "serverp.h"
#include <io.h>

#include <objbase.h>
#include <initguid.h>

#include <crtdbg.h>
#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>

//#define SCEJET_DBG    1

//
// should be controlled by critical section for static variables
//

static JET_INSTANCE    JetInstance=0;
static BOOL            JetInited=FALSE;
extern CRITICAL_SECTION JetSync;




#define SCE_JET_CORRUPTION_ERROR(Err) (Err == JET_errDatabaseCorrupted ||\
                                       Err == JET_errDiskIO ||\
                                       Err == JET_errReadVerifyFailure ||\
                                       Err == JET_errBadPageLink ||\
                                       Err == JET_errDbTimeCorrupted ||\
                                       Err == JET_errLogFileCorrupt ||\
                                       Err == JET_errCheckpointCorrupt ||\
                                       Err == JET_errLogCorruptDuringHardRestore ||\
                                       Err == JET_errLogCorruptDuringHardRecovery ||\
                                       Err == JET_errCatalogCorrupted ||\
                                       Err == JET_errDatabaseDuplicate)

DEFINE_GUID(CLSID_SceWriter,0x9cb9311a, 0x6b16, 0x4d5c, 0x85, 0x3e, 0x53, 0x79, 0x81, 0x38, 0xd5, 0x51);
// 9cb9311a-6b16-4d5c-853e-53798138d551

typedef struct _FIND_CONTEXT_ {
    DWORD           Length;
    WCHAR           Prefix[SCEJET_PREFIX_MAXLEN];
} SCEJET_FIND_CONTEXT;

//
// each thread has its own FindContext
//
SCEJET_FIND_CONTEXT Thread FindContext;


JET_ERR
SceJetpSeek(
    IN PSCESECTION hSection,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength,
    IN SCEJET_SEEK_FLAG SeekBit,
    IN BOOL bOkNoMatch
    );

JET_ERR
SceJetpCompareLine(
    IN PSCESECTION   hSection,
    IN JET_GRBIT    grbit,
    IN PWSTR        LinePrefix OPTIONAL,
    IN DWORD        PrefixLength,
    OUT INT         *Result,
    OUT DWORD       *ActualLength OPTIONAL
    );

JET_ERR
SceJetpMakeKey(
    IN JET_SESID SessionID,
    IN JET_TABLEID  TableID,
    IN DOUBLE SectionID,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength
    );

JET_ERR
SceJetpBuildUpperLimit(
    IN PSCESECTION hSection,
    IN PWSTR      LinePrefix,
    IN DWORD      Len,
    IN BOOL       bReserveCase
    );

SCESTATUS
SceJetpGetAvailableSectionID(
    IN PSCECONTEXT cxtProfile,
    OUT DOUBLE *SectionID
    );

SCESTATUS
SceJetpAddAllSections(
    IN PSCECONTEXT cxtProfile
    );

SCESTATUS
SceJetpConfigJetSystem(
    IN JET_INSTANCE *hinstance
    );

SCESTATUS
SceJetpGetValueFromVersion(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TableName,
    IN LPSTR ColumnName,
    OUT LPSTR Value OPTIONAL,
    IN DWORD  ValueLen, // number of bytes
    OUT PDWORD pRetLen
    );

SCESTATUS
SceJetpAddGpo(
    IN PSCECONTEXT cxtProfile,
    IN JET_TABLEID TableID,
    IN JET_COLUMNID GpoIDColumnID,
    IN PCWSTR      Name,
    OUT LONG       *pGpoID
    );

//
// Code to handle profile
//
SCESTATUS
SceJetOpenFile(
    IN LPSTR       ProfileFileName,
    IN SCEJET_OPEN_TYPE Flags,
    IN DWORD       dwTableOptions,
    OUT PSCECONTEXT  *cxtProfile
    )
/* ++
Routine Description:

    This routine opens the profile (database) and outputs the context handle.
    The information returned in the context handle include the Jet session ID,
    Jet database ID, Jet table ID for SCP table, Jet column ID for column
    "Name" and "Value" in the SCP table, and optional information for SAP and
    SMP table.

    If the context handle passed in contains not NULL information, this routine
    will close all tables and the database in the context (use the same session).

    The context handle must be freed by LocalFree after its use.

    A new jet session is created when the context handle is created.

Arguments:

    ProfileFileName - ASCII name of a database (profile)

    Flags           - flags to open the database

    cxtProfile      - the context handle (See SCECONTEXT structure)

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_BAD_FORMAT
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OTHER_ERROR

-- */
{
    JET_ERR     JetErr;
    SCESTATUS   rc;
    BOOL        FreeContext=FALSE;
    JET_GRBIT   JetDbFlag;
    DWORD dwScpTable=0;


    if ( ProfileFileName == NULL || cxtProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( *cxtProfile && ScepIsValidContext(*cxtProfile) ) {
        __try {
            //
            // Close previous opened database
            //
            rc = SceJetCloseFile(
                            *cxtProfile,
                            FALSE,
                            FALSE
                            );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // this is a invalid pointer
            //
            *cxtProfile = NULL;
        }
    }

    if ( *cxtProfile == NULL ) {
        //
        // no session
        //
        *cxtProfile = (PSCECONTEXT)LocalAlloc( LMEM_ZEROINIT, sizeof(SCECONTEXT));
        if ( *cxtProfile == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        (*cxtProfile)->Type = 0xFFFFFF02L;
        (*cxtProfile)->JetSessionID = JET_sesidNil;
        (*cxtProfile)->JetDbID = JET_dbidNil;
        (*cxtProfile)->OpenFlag = SCEJET_OPEN_READ_WRITE;
        (*cxtProfile)->JetScpID = JET_tableidNil;
        (*cxtProfile)->JetSapID = JET_tableidNil;
        (*cxtProfile)->JetSmpID = JET_tableidNil;
        (*cxtProfile)->JetTblSecID = JET_tableidNil;

        FreeContext = TRUE;

    }

    //
    // Begin a session
    //
    if ( (*cxtProfile)->JetSessionID == JET_sesidNil ) {
        JetErr = JetBeginSession(
                        JetInstance,
                        &((*cxtProfile)->JetSessionID),
                        NULL,
                        NULL
                        );
        rc = SceJetJetErrorToSceStatus(JetErr);
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    switch (Flags) {
    case SCEJET_OPEN_EXCLUSIVE:
    case SCEJET_OPEN_NOCHECK_VERSION:
        JetDbFlag = 0;  // read & write
//        JetDbFlag = JET_bitDbExclusive;
        (*cxtProfile)->OpenFlag = SCEJET_OPEN_EXCLUSIVE;
        break;
    case SCEJET_OPEN_READ_ONLY:
        JetDbFlag = JET_bitDbReadOnly;

        (*cxtProfile)->OpenFlag = Flags;
        break;
    default:
        JetDbFlag = 0;
        (*cxtProfile)->OpenFlag = SCEJET_OPEN_READ_WRITE;
        break;
    }

    //
    // Attach database
    //
    JetErr = JetAttachDatabase(
                    (*cxtProfile)->JetSessionID,
                    ProfileFileName,
                    JetDbFlag
                    );
#ifdef SCEJET_DBG
    printf("Attach database JetErr=%d\n", JetErr);
#endif
    if ( JetErr == JET_wrnDatabaseAttached )
        JetErr = JET_errSuccess;

    rc = SceJetJetErrorToSceStatus(JetErr);
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    //
    // Open database
    //
    JetErr = JetOpenDatabase(
                    (*cxtProfile)->JetSessionID,
                    ProfileFileName,
                    NULL,
                    &((*cxtProfile)->JetDbID),
                    JetDbFlag  //JET_bitDbExclusive
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);
#ifdef SCEJET_DBG
    printf("Open database %s return code %d (%d) \n", ProfileFileName, rc, JetErr);
#endif
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( Flags != SCEJET_OPEN_NOCHECK_VERSION ) {

        //
        // Check database format (for security manager, version#)
        //
        rc = SceJetCheckVersion( *cxtProfile, NULL );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

#ifdef SCEJET_DBG
    printf("Open: Version check OK\n");
#endif
    }

    //
    // Open section table. must be there
    //
    rc = SceJetOpenTable(
                    *cxtProfile,
                    "SmTblSection",
                    SCEJET_TABLE_SECTION,
                    Flags,
                    NULL
                    );

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    //
    // open smp table -- optional
    //
    rc = SceJetOpenTable(
                    *cxtProfile,
                    "SmTblSmp",
                    SCEJET_TABLE_SMP,
                    Flags,
                    NULL
                    );

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    //
    // get the last used merge table (SCP) to open
    // shouldn't fail
    // 1 - SmTblScp  2 - SmTblScp2  0 - no policy merge
    //
    DWORD Actual;

    rc = SceJetpGetValueFromVersion(
                *cxtProfile,
                "SmTblVersion",
                "LastUsedMergeTable",
                (LPSTR)&dwScpTable,
                4, // number of bytes
                &Actual
                );

    if ( (dwScpTable != SCEJET_MERGE_TABLE_1) &&
         (dwScpTable != SCEJET_MERGE_TABLE_2) ) {

        dwScpTable = SCEJET_LOCAL_TABLE;
    }

    rc = SCESTATUS_SUCCESS;
    (*cxtProfile)->Type &= 0xFFFFFF0FL;

    if ( dwTableOptions & SCE_TABLE_OPTION_MERGE_POLICY ) {
        //
        // in policy propagation
        //
        if ( ( dwScpTable == SCEJET_MERGE_TABLE_2 ) ) {
            //
            // the second table is already propped
            //
            rc = SceJetOpenTable(
                            *cxtProfile,
                            "SmTblScp",
                            SCEJET_TABLE_SCP,
                            Flags,
                            NULL
                            );
            (*cxtProfile)->Type |= SCEJET_MERGE_TABLE_1;

        } else {
            rc = SceJetOpenTable(
                            *cxtProfile,
                            "SmTblScp2",
                            SCEJET_TABLE_SCP,
                            Flags,
                            NULL
                            );
            (*cxtProfile)->Type |= SCEJET_MERGE_TABLE_2;
        }
    } else {

        switch ( dwScpTable ) {
        case SCEJET_MERGE_TABLE_2:
            //
            // the second table
            //
            rc = SceJetOpenTable(
                            *cxtProfile,
                            "SmTblScp2",
                            SCEJET_TABLE_SCP,
                            Flags,
                            NULL
                            );
            break;

        case SCEJET_MERGE_TABLE_1:

            rc = SceJetOpenTable(
                            *cxtProfile,
                            "SmTblScp",
                            SCEJET_TABLE_SCP,
                            Flags,
                            NULL
                            );

            break;

        default:
            //
            // open SMP table instead, because SCP table doesn't have information
            //
            (*cxtProfile)->JetScpID = (*cxtProfile)->JetSmpID;
            (*cxtProfile)->JetScpSectionID = (*cxtProfile)->JetSmpSectionID;
            (*cxtProfile)->JetScpNameID = (*cxtProfile)->JetSmpNameID;
            (*cxtProfile)->JetScpValueID = (*cxtProfile)->JetSmpValueID;
            (*cxtProfile)->JetScpGpoID = 0;

            break;
        }

        (*cxtProfile)->Type |= dwScpTable;
    }

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( dwTableOptions & SCE_TABLE_OPTION_TATTOO ) {

        rc = SceJetOpenTable(
                        *cxtProfile,
                        "SmTblTattoo",
                        SCEJET_TABLE_TATTOO,
                        Flags,
                        NULL
                        );

    } else {
        //
        // open sap table -- optional
        //
        rc = SceJetOpenTable(
                        *cxtProfile,
                        "SmTblSap",
                        SCEJET_TABLE_SAP,
                        Flags,
                        NULL
                        );
    }

Done:

    if ( rc != SCESTATUS_SUCCESS ) {
        SceJetCloseFile(
                *cxtProfile,
                FALSE,
                FALSE
                );

        if ( FreeContext == TRUE ) {
            if ( (*cxtProfile)->JetSessionID != JET_sesidNil ) {
                JetEndSession(
                    (*cxtProfile)->JetSessionID,
                    JET_bitForceSessionClosed
                    );
            }
            LocalFree(*cxtProfile);
            *cxtProfile = NULL;
        }
    }

    return(rc);

}


SCESTATUS
SceJetCreateFile(
    IN LPSTR        ProfileFileName,
    IN SCEJET_CREATE_TYPE    Flags,
    IN DWORD        dwTableOptions,
    OUT PSCECONTEXT  *cxtProfile
    )
/* ++
Routine Description:

    This routine creates a database (profile) and outputs the context handle.
    See comments in SceJetOpenFile for information contained in the context.

    If the database name already exists in the system, there are 3 options:
        Flags = SCEJET_OVERWRITE_DUP - the existing database will be erased and
                                          recreated.
        Flags = SCEJET_OPEN_DUP      - the existing database will be opened and
                                          format is checked
        Flags = SCEJET_OPEN_DUP_EXCLUSIVE - the existing database will be opened
                                            exclusively.
        Flags = SCEJET_RETURN_ON_DUP - a error code SCESTATUS_FILE_EXIST is returned.

    When creating the database, only SCP table is created initially. SAP and SMP
    tables will be created when analysis is performed.

    The context handle must be freed by LocalFree after its use.

Arguments:

    ProfileFileName - ASCII name of a database to create.

    Flags           - This flag is used when there is an duplicate database
                            SCEJET_OVERWRITE_DUP
                            SCEJET_OPEN_DUP
                            SCEJET_OPEN_DUP_EXCLUSIVE
                            SCEJET_RETURN_ON_DUP

    cxtProfile      - The context handle

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_PROFILE_NOT_FOUND
    SCESTATUS_OBJECT_EXIST
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_CANT_DELETE
    SCESTATUS_OTHER_ERROR

    SCESTATUS from SceJetOpenFile

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc=SCESTATUS_SUCCESS;
    BOOL        FreeContext=FALSE;
    DWORD       Len;
    FLOAT       Version=(FLOAT)1.2;
    JET_TABLEID TableID;
    JET_COLUMNID ColumnID;


    if ( ProfileFileName == NULL || cxtProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( *cxtProfile && ScepIsValidContext(*cxtProfile) ) {
        //
        // Close previous opened database
        //
        rc = SceJetCloseFile(
                        *cxtProfile,
                        FALSE,
                        FALSE
                        );
    } else {
        *cxtProfile = NULL;
    }

    if ( *cxtProfile == NULL ) {
        //
        // no session
        //
        *cxtProfile = (PSCECONTEXT)LocalAlloc( LMEM_ZEROINIT, sizeof(SCECONTEXT));
        if ( *cxtProfile == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        (*cxtProfile)->Type = 0xFFFFFF02L;
        (*cxtProfile)->JetSessionID = JET_sesidNil;
        (*cxtProfile)->JetDbID = JET_dbidNil;
        (*cxtProfile)->OpenFlag = SCEJET_OPEN_READ_WRITE;
        (*cxtProfile)->JetScpID = JET_tableidNil;
        (*cxtProfile)->JetSapID = JET_tableidNil;
        (*cxtProfile)->JetSmpID = JET_tableidNil;
        (*cxtProfile)->JetTblSecID = JET_tableidNil;

        FreeContext = TRUE;

    }

    (*cxtProfile)->Type &= 0xFFFFFF0FL;

    //
    // Begin a session
    //
    if ( (*cxtProfile)->JetSessionID == JET_sesidNil ) {
        JetErr = JetBeginSession(
                        JetInstance,
                        &((*cxtProfile)->JetSessionID),
                        NULL,
                        NULL
                        );
        rc = SceJetJetErrorToSceStatus(JetErr);
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }
    //
    // Create database
    //
    JetErr = JetCreateDatabase(
                    (*cxtProfile)->JetSessionID,
                    ProfileFileName,
                    NULL,
                    &((*cxtProfile)->JetDbID),
                    JET_bitDbExclusive
                    );
    if ( JET_errFileNotFound == JetErr ) {
        //
        // if no access to create a file in the path
        // ESENT returns this error. It's fixed in ESE98
        // we have to mask it to access denied error for now
        //
        JetErr = JET_errFileAccessDenied;
    }
#ifdef SCEJET_DBG
    printf("Create database %s JetErr = %d\n", ProfileFileName, JetErr);
#endif
    rc = SceJetJetErrorToSceStatus(JetErr);

    (*cxtProfile)->OpenFlag = SCEJET_OPEN_EXCLUSIVE;

    if ( rc == SCESTATUS_OBJECT_EXIST ) {
        switch ( Flags ) {
        case SCEJET_OVERWRITE_DUP:
            //
            // erase the database
            //

            JetDetachDatabase(
                    (*cxtProfile)->JetSessionID,
                    ProfileFileName
                    );

            if ( !DeleteFileA(ProfileFileName) &&
                 GetLastError() != ERROR_FILE_NOT_FOUND ) {

                ScepLogOutput3(1,GetLastError(), SCEDLL_ERROR_DELETE_DB );
            }

            //
            // if delete database failed, log the error but continue to
            // create the database. This call will fail with Jet error.
            //
            JetErr = JetCreateDatabase(
                            (*cxtProfile)->JetSessionID,
                            ProfileFileName,
                            NULL,
                            &((*cxtProfile)->JetDbID),
                            JET_bitDbExclusive
                            );
            if ( JET_errFileNotFound == JetErr ) {
                //
                // if no access to create a file in the path
                // ESENT returns this error. It's fixed in ESE98
                // we have to mask it to access denied error for now
                //
                JetErr = JET_errFileAccessDenied;
            }

            rc = SceJetJetErrorToSceStatus(JetErr);

            break;

        case SCEJET_OPEN_DUP:
            //
            // Open the database
            //
            rc = SceJetOpenFile(
                    ProfileFileName,
                    SCEJET_OPEN_READ_WRITE,
                    dwTableOptions,
                    cxtProfile
                    );
            goto Done;
            break;

        case SCEJET_OPEN_DUP_EXCLUSIVE:
            //
            // Open the database
            //
            rc = SceJetOpenFile(
                    ProfileFileName,
                    SCEJET_OPEN_EXCLUSIVE,
                    dwTableOptions,
                    cxtProfile
                    );
            goto Done;
            break;
        }
    }

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;
#ifdef SCEJET_DBG
    printf("Create/Open database\n");
#endif

    //
    // create required tables - SmTblVersion
    //

    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblVersion",
                    SCEJET_TABLE_VERSION,
                    SCEJET_CREATE_IN_BUFFER,
                    &TableID,
                    &ColumnID
                    );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    //
    // insert one record into the version table
    //
    JetErr = JetPrepareUpdate((*cxtProfile)->JetSessionID,
                              TableID,
                              JET_prepInsert
                              );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // set value "1.2" in "Version" column
        //

        JetErr = JetSetColumn(
                        (*cxtProfile)->JetSessionID,
                        TableID,
                        ColumnID,
                        (void *)&Version,
                        4,
                        0, //JET_bitSetOverwriteLV,
                        NULL
                        );

        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc != SCESTATUS_SUCCESS ) {
            //
            // if setting fails, cancel the prepared record
            //
            JetPrepareUpdate( (*cxtProfile)->JetSessionID,
                              TableID,
                              JET_prepCancel
                              );
        } else {

            //
            // Setting columns succeed. Update the record
            //
            JetErr = JetUpdate( (*cxtProfile)->JetSessionID,
                               TableID,
                               NULL,
                               0,
                               &Len
                               );
            rc = SceJetJetErrorToSceStatus(JetErr);
        }
    }

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

#ifdef SCEJET_DBG
    printf("create version table\n");
#endif
    //
    // create section table and insert pre-defined sections
    //
    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblSection",
                    SCEJET_TABLE_SECTION,
                    SCEJET_CREATE_IN_BUFFER,
                    NULL,
                    NULL
                    );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

#ifdef SCEJET_DBG
    printf("create section table\n");
#endif

    rc = SceJetpAddAllSections(
                *cxtProfile
                );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

#ifdef SCEJET_DBG
    printf("add sections\n");
#endif


    //
    // create scp table
    //
    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblScp",
                    SCEJET_TABLE_SCP,
                    SCEJET_CREATE_IN_BUFFER,
                    NULL,
                    NULL
                    );
#ifdef SCEJET_DBG
    printf("Create table scp %d\n", rc);
#endif
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( dwTableOptions & SCE_TABLE_OPTION_MERGE_POLICY ) {
        (*cxtProfile)->Type |= SCEJET_MERGE_TABLE_1;
    } else {
        (*cxtProfile)->Type |= SCEJET_LOCAL_TABLE;
    }

    //
    // create scp table
    //
    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblSmp",
                    SCEJET_TABLE_SMP,
                    SCEJET_CREATE_IN_BUFFER,
                    NULL,
                    NULL
                    );
#ifdef SCEJET_DBG
    printf("Create table smp %d\n", rc);
#endif

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblScp2",
                    SCEJET_TABLE_SCP,
                    SCEJET_CREATE_NO_TABLEID,
                    NULL,
                    NULL
                    );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    rc = SceJetCreateTable(
                    *cxtProfile,
                    "SmTblGpo",
                    SCEJET_TABLE_GPO,
                    SCEJET_CREATE_NO_TABLEID,
                    NULL,
                    NULL
                    );
    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( dwTableOptions & SCE_TABLE_OPTION_TATTOO ) {
        rc = SceJetCreateTable(
                        *cxtProfile,
                        "SmTblTattoo",
                        SCEJET_TABLE_TATTOO,
                        SCEJET_CREATE_IN_BUFFER,
                        NULL,
                        NULL
                        );
    }

Done:

    //
    // clearn up if error out
    //
    if ( rc != SCESTATUS_SUCCESS ) {

        SceJetCloseFile(
                *cxtProfile,
                FALSE,
                FALSE
                );
        if ( FreeContext == TRUE ) {
            if ( (*cxtProfile)->JetSessionID != JET_sesidNil ) {
                JetEndSession(
                    (*cxtProfile)->JetSessionID,
                    JET_bitForceSessionClosed
                    );
            }
            LocalFree(*cxtProfile);
            *cxtProfile = NULL;
        }
    }

    return(rc);

}


SCESTATUS
SceJetCloseFile(
    IN PSCECONTEXT   hProfile,
    IN BOOL         TermSession,
    IN BOOL         Terminate
    )
/* ++
Routine Description:

    This routine closes a context handle, which closes all tables opened in
    the database and then closes the database.

    Terminate parameter is ignored and Jet engine is not stoppped when this parameter
    is set to TRUE, because there might be other clients using Jet and Jet writer is
    dependent on it.

Arguments:

    hProfile    - The context handle

    Terminate   - TRUE = Terminate the Jet session and engine.

Return value:

    SCESTATUS_SUCCESS

-- */
{

    JET_ERR     JetErr;


    if ( hProfile == NULL )
        goto Terminate;

    CHAR szDbName[1025];

    //
    // Close SCP table if it is opened
    //
    if ( (hProfile->JetScpID != JET_tableidNil) ) {

        if ( hProfile->JetScpID != hProfile->JetSmpID ) {
            JetErr = JetCloseTable(
                        hProfile->JetSessionID,
                        hProfile->JetScpID
                        );
        }
        hProfile->JetScpID = JET_tableidNil;
    }
    //
    // Close SAP table if it is opened
    //
    if ( hProfile->JetSapID != JET_tableidNil ) {
        JetErr = JetCloseTable(
                    hProfile->JetSessionID,
                    hProfile->JetSapID
                    );
        hProfile->JetSapID = JET_tableidNil;
    }
    //
    // Close SMP table if it is opened
    //
    if ( hProfile->JetSmpID != JET_tableidNil ) {
        JetErr = JetCloseTable(
                    hProfile->JetSessionID,
                    hProfile->JetSmpID
                    );
        hProfile->JetSmpID = JET_tableidNil;
    }

    //
    // get database name
    // do not care if there is error
    //
    szDbName[0] = '\0';
    szDbName[1024] = '\0';

    if ( hProfile->JetDbID != JET_dbidNil ) {

        JetGetDatabaseInfo(hProfile->JetSessionID,
                           hProfile->JetDbID,
                           (void *)szDbName,
                           1024,
                           JET_DbInfoFilename
                           );

        //
        // Close the database
        //
        JetErr = JetCloseDatabase(
                        hProfile->JetSessionID,
                        hProfile->JetDbID,
                        0
                        );
        hProfile->JetDbID = JET_dbidNil;

        //
        // should detach the database if the database name is not NULL
        // the database is always attached when it's to open
        // do not care error
        //
        if ( szDbName[0] != '\0' ) {
            JetDetachDatabase(hProfile->JetSessionID, szDbName);
        }
    }

    if ( TermSession || Terminate ) {
        if ( hProfile->JetSessionID != JET_sesidNil ) {

            JetEndSession(
                hProfile->JetSessionID,
                JET_bitForceSessionClosed
                );
            hProfile->JetSessionID = JET_sesidNil;
        }

        hProfile->Type = 0;

        LocalFree(hProfile);
    }

Terminate:

/*
    if ( Terminate ) {

        JetTerm(JetInstance);
        JetInstance = 0;
        JetInited = FALSE;

    }
*/
    return(SCESTATUS_SUCCESS);

}


//
// Code to handle sections
//

SCESTATUS
SceJetOpenSection(
    IN PSCECONTEXT   hProfile,
    IN DOUBLE        SectionID,
    IN SCEJET_TABLE_TYPE        tblType,
    OUT PSCESECTION   *hSection
    )
/* ++
Routine Description:

    This routine saves table and section information in the section context
    handle for other section API's use. SCP, SAP, and SMP tables have the
    same section names. The table type indicates which table this section is
    in.

    The section context handle must be freed by LocalFree after its use.

Arguments:

    hProfile    - The profile context handle

    SectionID   - ID of the section to open

    tblType     - The type of the table for this section
                        SCEJET_TABLE_SCP
                        SCEJET_TABLE_SAP
                        SCEJET_TABLE_SMP

    hSection    - The seciton context handle

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_NOT_ENOUGH_RESOURCE

-- */
{
    if ( hProfile == NULL ||
         hSection == NULL ||
         SectionID == (DOUBLE)0 ||
         (tblType != SCEJET_TABLE_SCP &&
          tblType != SCEJET_TABLE_SAP &&
          tblType != SCEJET_TABLE_SMP &&
          tblType != SCEJET_TABLE_TATTOO) )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( hProfile->JetSessionID == JET_sesidNil ||
         hProfile->JetDbID == JET_dbidNil ||
         (tblType == SCEJET_TABLE_SCP && hProfile->JetScpID == JET_tableidNil ) ||
         (tblType == SCEJET_TABLE_SMP && hProfile->JetSmpID == JET_tableidNil ) ||
         (tblType == SCEJET_TABLE_SAP && hProfile->JetSapID == JET_tableidNil ) ||
         (tblType == SCEJET_TABLE_TATTOO && hProfile->JetSapID == JET_tableidNil ) )
        return(SCESTATUS_BAD_FORMAT);


    if ( *hSection == NULL ) {
        //
        // Allocate memory
        //
        *hSection = (PSCESECTION)LocalAlloc( (UINT)0, sizeof(SCESECTION));
        if ( *hSection == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
    }

    (*hSection)->SectionID = SectionID;

    //
    // assign other info to the section context
    //
    (*hSection)->JetSessionID = hProfile->JetSessionID;
    (*hSection)->JetDbID = hProfile->JetDbID;

    switch (tblType) {
    case SCEJET_TABLE_SCP:
        (*hSection)->JetTableID = hProfile->JetScpID;
        (*hSection)->JetColumnSectionID = hProfile->JetScpSectionID;
        (*hSection)->JetColumnNameID = hProfile->JetScpNameID;
        (*hSection)->JetColumnValueID = hProfile->JetScpValueID;
        (*hSection)->JetColumnGpoID = hProfile->JetScpGpoID;
        break;
    case SCEJET_TABLE_SAP:
    case SCEJET_TABLE_TATTOO:
        (*hSection)->JetTableID = hProfile->JetSapID;
        (*hSection)->JetColumnSectionID = hProfile->JetSapSectionID;
        (*hSection)->JetColumnNameID = hProfile->JetSapNameID;
        (*hSection)->JetColumnValueID = hProfile->JetSapValueID;
        (*hSection)->JetColumnGpoID = 0;
        break;
    default:
        (*hSection)->JetTableID = hProfile->JetSmpID;
        (*hSection)->JetColumnSectionID = hProfile->JetSmpSectionID;
        (*hSection)->JetColumnNameID = hProfile->JetSmpNameID;
        (*hSection)->JetColumnValueID = hProfile->JetSmpValueID;
        (*hSection)->JetColumnGpoID = 0;
        break;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceJetGetLineCount(
    IN PSCESECTION hSection,
    IN PWSTR      LinePrefix OPTIONAL,
    IN BOOL       bExactCase,
    OUT DWORD      *Count
    )
/* ++
Fucntion Description:

    This routine counts the number of lines matching the LinePrefix (Key)
    in the section. If LinePrefix is NULL, all lines is counted.

Arguments:

    hSection    - The context handle for the section.

    LinePrefix  - The whole or partial key to match. If NULL, all lines in the
                    section is counted.

    Count       - The output count.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS    rc;
    JET_ERR     JetErr;
    DWORD       Len;
    INT         Result=0;
    SCEJET_SEEK_FLAG  SeekFlag;


    if ( hSection == NULL || Count == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // initialize
    //
    *Count = 0;

    if ( LinePrefix == NULL ) {
        Len = 0;
        SeekFlag = SCEJET_SEEK_GE;
    } else {
        Len = wcslen(LinePrefix)*sizeof(WCHAR);

        if ( bExactCase )
            SeekFlag = SCEJET_SEEK_GE;
        else
            SeekFlag = SCEJET_SEEK_GE_NO_CASE;
    }

    //
    // seek the first occurance
    //

    rc = SceJetSeek(
                hSection,
                LinePrefix,
                Len,
                SeekFlag
                );

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        // no matching record is found
        return(SCESTATUS_SUCCESS);
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // Find the record or the next record
        // Define the upper index range
        //
        if ( Len <= 247 ) {

            JetErr = SceJetpBuildUpperLimit(
                            hSection,
                            LinePrefix,
                            Len,
                            bExactCase
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);
            if ( rc != SCESTATUS_SUCCESS )
                return(rc);

            //
            // count from the current position to the end of the range
            //
            JetErr = JetIndexRecordCount(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            (unsigned long *)Count,
                            (unsigned long)0xFFFFFFFF   // maximal count
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);

            //
            // reset the index range. don't care the error code returned
            //
            JetErr = JetSetIndexRange(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            JET_bitRangeRemove
                            );

        } else {
            //
            // Prefix is longer than 247. The index built does not contan all info
            // loop through each record to count
            //
            do {
                // current record is the same.
                *Count = *Count + 1;
                //
                // move to next record
                //
                JetErr = JetMove(hSection->JetSessionID,
                                 hSection->JetTableID,
                                 JET_MoveNext,
                                 0
                                 );
                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( rc == SCESTATUS_SUCCESS ) {
                    // check the record

                    JetErr = SceJetpCompareLine(
                                    hSection,
                                    JET_bitSeekGE,
                                    LinePrefix,
                                    Len,
                                    &Result,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);
                }

            } while ( rc == SCESTATUS_SUCCESS && Result == 0 );
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

    }

    return(rc);
}



SCESTATUS
SceJetDelete(
    IN PSCESECTION  hSection,
    IN PWSTR       LinePrefix,
    IN BOOL        bObjectFolder,
    IN SCEJET_DELETE_TYPE    Flags
    )
/* ++
Fucntion Description:

    This routine deletes the current record, prefix records, or the whole
    section, depending on the Flags.

Arguments:

    hSection    - The context handle of the section

    LinePrefix  - The prefix to start with for the deleted lines. This value
                  is only used when Flags is set to SCEJET_DELETE_PARTIAL

    Flags       - Options
                    SCEJET_DELETE_SECTION
                    SCEJET_DELETE_LINE
                    SCEJET_DELETE_PARTIAL

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_ACCESS_DEINED
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_OTHER_ERROR

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc;
    INT         Result = 0;
    PWSTR       TempPrefix=NULL;
    DWORD       Len;
    SCEJET_SEEK_FLAG  SeekFlag;
    PWSTR  NewPrefix=NULL;
    DOUBLE      SectionID;
    DWORD       Actual;


    if ( hSection == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Flags == SCEJET_DELETE_PARTIAL ||
         Flags == SCEJET_DELETE_PARTIAL_NO_CASE ) {

        if ( LinePrefix == NULL )
            return(SCESTATUS_INVALID_PARAMETER);

        Len = wcslen(LinePrefix);
        //
        // delete this node exact match first
        //
        if ( Flags == SCEJET_DELETE_PARTIAL )
            SeekFlag = SCEJET_SEEK_EQ;
        else
            SeekFlag = SCEJET_SEEK_EQ_NO_CASE;

        rc = SceJetSeek(hSection,
                        LinePrefix,
                        Len*sizeof(WCHAR),
                        SeekFlag
                        );

        if ( rc == SCESTATUS_SUCCESS ) {
            JetErr = JetDelete(hSection->JetSessionID, hSection->JetTableID);
            rc = SceJetJetErrorToSceStatus(JetErr);
        }

        if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc == SCESTATUS_SUCCESS ) {

            if ( bObjectFolder &&
                 LinePrefix[Len-1] != L'\\' ) {

                Len++;
                NewPrefix = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));

                if ( NewPrefix == NULL ) {
                    return(SCESTATUS_NOT_ENOUGH_RESOURCE);
                }
                wcscpy(NewPrefix, LinePrefix);
                NewPrefix[Len-1] = L'\\';
            }

        } else {
            return(rc);
        }

        Len = Len*sizeof(WCHAR);

    }

    if ( Flags == SCEJET_DELETE_LINE ||
         Flags == SCEJET_DELETE_LINE_NO_CASE ) {
        if ( LinePrefix == NULL ) {
            //
            // delete current line
            // check the current's sectionID before deleting
            //

            rc = SceJetJetErrorToSceStatus(JetRetrieveColumn(
                                                    hSection->JetSessionID,
                                                    hSection->JetTableID,
                                                    hSection->JetColumnSectionID,
                                                    (void *)&SectionID,
                                                    8,
                                                    &Actual,
                                                    0,
                                                    NULL
                                                    ));


            if (rc == SCESTATUS_SUCCESS && hSection->SectionID != SectionID)
                rc = SCESTATUS_RECORD_NOT_FOUND;

            if (rc == SCESTATUS_SUCCESS) {
                JetErr = JetDelete(hSection->JetSessionID, hSection->JetTableID);
                rc = SceJetJetErrorToSceStatus(JetErr);
            }

        } else {
            if ( Flags == SCEJET_DELETE_LINE )
                SeekFlag = SCEJET_SEEK_EQ;
            else
                SeekFlag = SCEJET_SEEK_EQ_NO_CASE;

            rc = SceJetSeek(hSection,
                               LinePrefix,
                               wcslen(LinePrefix)*sizeof(WCHAR),
                               SeekFlag
                               );
            if ( rc == SCESTATUS_SUCCESS ) {
                JetErr = JetDelete(hSection->JetSessionID, hSection->JetTableID);
                rc = SceJetJetErrorToSceStatus(JetErr);
            }

        }

        return(rc);
    }

    if ( Flags == SCEJET_DELETE_SECTION ||
         Flags == SCEJET_DELETE_PARTIAL ||
         Flags == SCEJET_DELETE_PARTIAL_NO_CASE ) {

        if ( Flags == SCEJET_DELETE_SECTION ) {
             //
            // delete the whole section
            // seek the first line of the section
            //
            TempPrefix = NULL;
            Len = 0;
            SeekFlag = SCEJET_SEEK_GE;
        } else {
            //
            // delete all lines begin with the prefix
            // seek the first line of the prefix
            //
            if ( NewPrefix ) {
                TempPrefix = NewPrefix;
            } else {
                TempPrefix = LinePrefix;
            }
            if ( Flags == SCEJET_DELETE_PARTIAL_NO_CASE )
                SeekFlag = SCEJET_SEEK_GE_NO_CASE;
            else
                SeekFlag = SCEJET_SEEK_GE;
        }

        rc = SceJetSeek(hSection, TempPrefix, Len, SeekFlag);

        if ( rc != SCESTATUS_SUCCESS ) {
            if ( NewPrefix ) {
                ScepFree(NewPrefix);
            }
            return(rc);
        }

        do {

            //
            // delete current line
            //
            JetErr = JetDelete(hSection->JetSessionID, hSection->JetTableID);
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc != SCESTATUS_SUCCESS )
                break;

            //
            // move cursor to next line
            //
            JetErr = JetMove(hSection->JetSessionID,
                             hSection->JetTableID,
                             JET_MoveNext,
                             0
                             );
            if ( JetErr == JET_errSuccess ) {
                //
                // compare section ID
                //
                JetErr = SceJetpCompareLine(
                                hSection,
                                JET_bitSeekGE,
                                TempPrefix,
                                Len,
                                &Result,
                                NULL
                                );

                if ( JetErr == JET_errSuccess && Result != 0 )
                    JetErr = JET_errRecordNotFound;

            }

            if ( JetErr == JET_errRecordDeleted ) {
                //
                // skip the deleted record
                //
                JetErr = JET_errSuccess;
                Result = 0;
            }
            rc = SceJetJetErrorToSceStatus(JetErr);


        } while ( rc == SCESTATUS_SUCCESS && Result == 0 );

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

        if ( NewPrefix ) {
            ScepFree(NewPrefix);
        }

        return(rc);
    }

    return(SCESTATUS_SUCCESS);
}

SCESTATUS
SceJetDeleteAll(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TblName OPTIONAL,
    IN SCEJET_TABLE_TYPE  TblType
    )
/* ++
Fucntion Description:

    This routine deletes everything in the table (specified by name or by type)

Arguments:

    cxtProfile  - The context handle of the database

    TblName     - optional table name to delete (if not to use the table id in context)

    TblType     - specify the table type to use the table id in context, ignored
                    if TblName is specified.

Return Value:

-- */
{
    JET_ERR     JetErr;
    SCESTATUS    rc;

    JET_TABLEID     tmpTblID;

    if ( cxtProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( TblName ) {

        JetErr = JetOpenTable(
                        cxtProfile->JetSessionID,
                        cxtProfile->JetDbID,
                        TblName,
                        NULL,
                        0,
                        0,
                        &tmpTblID
                        );
        if ( JET_errSuccess != JetErr ) {
            return(SceJetJetErrorToSceStatus(JetErr));
        }

    } else {

        switch ( TblType ) {
        case SCEJET_TABLE_SCP:
            tmpTblID = cxtProfile->JetScpID;
            break;
        case SCEJET_TABLE_SMP:
            tmpTblID = cxtProfile->JetSmpID;
            break;
        case SCEJET_TABLE_SAP:
        case SCEJET_TABLE_TATTOO:
            tmpTblID = cxtProfile->JetSapID;
            break;
        case SCEJET_TABLE_SECTION:
            tmpTblID = cxtProfile->JetTblSecID;
            break;
        default:
            return(SCESTATUS_INVALID_PARAMETER);
        }
    }

    //
    // move cursor to next line
    //
    JetErr = JetMove(cxtProfile->JetSessionID,
                     tmpTblID,
                     JET_MoveFirst,
                     0
                     );

    while ( JET_errSuccess == JetErr ) {

        //
        // delete current line
        //
        JetErr = JetDelete(cxtProfile->JetSessionID, tmpTblID);

        //
        // move cursor to next line
        //
        JetErr = JetMove(cxtProfile->JetSessionID,
                         tmpTblID,
                         JET_MoveNext,
                         0
                         );

    }

    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    if ( TblName ) {
        JetCloseTable(cxtProfile->JetSessionID, tmpTblID);
    }

    return(rc);
}


SCESTATUS
SceJetCloseSection(
    IN PSCESECTION   *hSection,
    IN BOOL         DestroySection
    )
/* ++
Fucntion Description:

    Closes a section context handle.

Arguments:

    hSection    - The section context handle to close

Return Value:

    SCE_SUCCESS

-- */
{
    if ( hSection == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( *hSection != NULL ) {
        (*hSection)->JetColumnSectionID = 0;
        (*hSection)->JetColumnNameID = 0;
        (*hSection)->JetColumnValueID = 0;

        (*hSection)->SectionID = (DOUBLE)0;

        if ( DestroySection ) {
            ScepFree(*hSection);
            *hSection = NULL;
        }

    }

    return(SCESTATUS_SUCCESS);
}


//
// Code to handle line
//
SCESTATUS
SceJetGetValue(
    IN PSCESECTION hSection,
    IN SCEJET_FIND_TYPE    Flags,
    IN PWSTR      LinePrefix OPTIONAL,
    IN PWSTR      ActualName  OPTIONAL,
    IN DWORD      NameBufLen,
    OUT DWORD      *RetNameLen OPTIONAL,
    IN PWSTR      Value       OPTIONAL,
    IN DWORD      ValueBufLen,
    OUT DWORD      *RetValueLen OPTIONAL
    )
/* ++
Fucntion Description:

    This routine retrieves a line from the opened section or close the
    previous search context. When Flag is SCEJET_EXACT_MATCH, this routine
    returns the exact matched line for LinePrefix (LinePrefix can't be NULL).
    If this routine is used to get multiple lines, a SCEJET_PREFIX_MATCH
    must be used for the Flags when the first time it is called. If LinePrefix
    is NULL, the first line in the section is returned; otherwise, the first
    line matching the prefix is returned. When continous call is made for the
    same prefix, use SCEJET_NEXT_LINE for the Flags. LinePrefix is not used
    for continous calls. When finish with the continuous calls, a
    SCEJET_CLOSE_VALUE must be used to close the search handle context.

    ActualName and Value contains the actual name and value stored in the
    database for the current line. If these two buffers are not big enough,
    an error will return SCE_BUFFER_TOO_SMALL.

    Passing NULL for ActualName or Value will return the required length for
    that buffer if the RetLength buffer is not NULL.

Arguments:

    hSection    - The context handle of the section

    LinePrefix  - The prefix for the line to start with. This is used only
                    when Flags is set to SCEJET_PREFIX_MATCH

    Flags       - Options for the operation
                    SCEJET_EXACT_MATCH
                    SCEJET_PREFIX_MATCH
                    SCEJET_NEXT_LINE
                    SCEJET_CLOSE_VALUE
                    SCEJET_CURRENT              -- get current record's value

    ActualName  - The buffer for column "Name"

    NameBufLen  - The buffer length of ActualName

    RetNameLen  - the required buffer length for "Name" column

    Value       - The buffer for column "Value"

    ValueBufLen - The buffer length of Value

    RetValueLen - The required buffer length for "Value" column


Return Value:

    SCESTATUS_SUCCESS if success
    SCESTATUS_RECORD_NOT_FOUND if no more match
    other errors:
        SCESTATUS_INVALID_PARAMETER
        SCESTATUS_BUFFER_TOO_SMALL
        SCESTATUS_OTHER_ERROR


-- */
{
    JET_ERR         JetErr;
    SCESTATUS        rc=SCESTATUS_SUCCESS;
    SCESTATUS        rc1;
    DWORD           Len=0;

    JET_RETINFO     RetInfo;
    WCHAR           Buffer[128];
    PVOID           pTemp=NULL;
    INT             Result=0;
    SCEJET_SEEK_FLAG   SeekFlag=SCEJET_SEEK_GT;


    if ( hSection == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( Flags == SCEJET_CLOSE_VALUE ) {
        //
        // close the index range
        //
        if ( FindContext.Length > 0 ) {
            memset(FindContext.Prefix, '\0', FindContext.Length);
            FindContext.Length = 0;
        }

        JetErr = JetSetIndexRange(
                     hSection->JetSessionID,
                     hSection->JetTableID,
                     JET_bitRangeRemove
                     );
        if ( JetErr != JET_errSuccess &&
             JetErr != JET_errKeyNotMade &&
             JetErr != JET_errNoCurrentRecord ) {

            return(SceJetJetErrorToSceStatus(JetErr));
        }
        return(SCESTATUS_SUCCESS);
    }

    //
    // when name/value is requested (not NULL), the return length buffer
    // cannot be NULL.
    // both return length buffer cannot be NULL at the same time
    //
    if ( (ActualName != NULL && RetNameLen == NULL) ||
         (Value != NULL && RetValueLen == NULL) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    switch ( Flags ) {

    case SCEJET_EXACT_MATCH:
    case SCEJET_EXACT_MATCH_NO_CASE:

        if ( LinePrefix == NULL )
            return(SCESTATUS_INVALID_PARAMETER);

        Len = wcslen(LinePrefix)*sizeof(WCHAR);

        if ( Flags == SCEJET_EXACT_MATCH )
            SeekFlag = SCEJET_SEEK_EQ;
        else
            SeekFlag = SCEJET_SEEK_EQ_NO_CASE;

        rc = SceJetSeek(
                    hSection,
                    LinePrefix,
                    Len,
                    SeekFlag
                    );
        break;


    case SCEJET_PREFIX_MATCH:
    case SCEJET_PREFIX_MATCH_NO_CASE:

        if ( LinePrefix != NULL ) {
            Len = wcslen(LinePrefix)*sizeof(WCHAR);

            if ( Len > SCEJET_PREFIX_MAXLEN )
                return(SCESTATUS_PREFIX_OVERFLOW);

        } else {
            Len = 0;
        }

        if ( Flags == SCEJET_PREFIX_MATCH )
            SeekFlag = SCEJET_SEEK_GE;
        else
            SeekFlag = SCEJET_SEEK_GE_NO_CASE;

        rc = SceJetSeek(
                        hSection,
                        LinePrefix,
                        Len,
                        SeekFlag
                        );

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // remember the find context
            //
            if ( Len > 247 ) {
                //
                // in reality JET doesn't allow keys of more than 255 bytes
                //
                wcsncpy(FindContext.Prefix, LinePrefix, SCEJET_PREFIX_MAXLEN-2);

                if ( Flags == SCEJET_PREFIX_MATCH_NO_CASE )
                    _wcslwr(FindContext.Prefix);

                FindContext.Length = Len;
            }
            //
            // set the upper range limit
            //
            JetErr = SceJetpBuildUpperLimit(
                        hSection,
                        LinePrefix,
                        Len,
                        (Flags == SCEJET_PREFIX_MATCH)
                        );
            rc = SceJetJetErrorToSceStatus(JetErr);
        }
        break;

    case SCEJET_NEXT_LINE:
        //
        // Move to next line
        //
        JetErr = JetMove(hSection->JetSessionID,
                        hSection->JetTableID,
                        JET_MoveNext,
                        0);
        //
        // compare to the prefix
        //
        if ( JetErr == JET_errSuccess && FindContext.Length > 0 ) {

#ifdef SCEJET_DBG
            printf("NextLine: Length is greater than 247\n");
#endif
            JetErr = SceJetpCompareLine(
                            hSection,
                            JET_bitSeekGE,
                            FindContext.Prefix,
                            FindContext.Length,
                            &Result,
                            NULL
                            );
            if ( JetErr == JET_errSuccess && Result != 0 )
                JetErr = JET_errRecordNotFound;

        }
        rc = SceJetJetErrorToSceStatus(JetErr);
        break;

    default:
        //
        // Everything else passed in is treated as the current line
        //
        rc = SCESTATUS_SUCCESS;
        break;
    }

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // Get this line's value
    //
    RetInfo.ibLongValue = 0;
    RetInfo.itagSequence = 1;
    RetInfo.cbStruct = sizeof(JET_RETINFO);

    if ( ActualName != NULL || RetNameLen != NULL ) {
        //
        // get name field (long binary)
        // if ActualName is NULL, then get the actual bytes
        //
        if ( ActualName != NULL ) {
            Len = NameBufLen;
            pTemp = (void *)ActualName;
        } else {
            Len = 256;
            pTemp = (void *)Buffer;
        }

        JetErr = JetRetrieveColumn(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        hSection->JetColumnNameID,
                        pTemp,
                        Len,
                        RetNameLen,
                        0,
                        &RetInfo
                        );
#ifdef SCEJET_DBG
        printf("\tJetErr=%d, Len=%d, RetNameLen=%d\n", JetErr, Len, *RetNameLen);
#endif
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_BUFFER_TOO_SMALL ) {
            //
            // if only length is requested, don't care buffer_too_small
            //
            if ( ActualName == NULL )
                rc = SCESTATUS_SUCCESS;
        }

        if ( rc != SCESTATUS_SUCCESS &&
             rc != SCESTATUS_BUFFER_TOO_SMALL )
            return(rc);
    }

    if ( Value != NULL || RetValueLen != NULL ) {
        //
        // Get value field
        // if Value is NULL, then get the actual bytes
        //

        if ( Value != NULL ) {
            Len = ValueBufLen;
            pTemp = (PVOID)Value;
        } else {
            Len = 256;
            pTemp = (PVOID)Buffer;
        }

        JetErr = JetRetrieveColumn(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        hSection->JetColumnValueID,
                        pTemp,
                        Len,
                        RetValueLen,
                        0,
                        &RetInfo
                        );
#ifdef SCEJET_DBG
        printf("\tJetErr=%d, Len=%d, RetValueLen=%d\n", JetErr, Len, *RetValueLen);
#endif
        rc1 = SceJetJetErrorToSceStatus(JetErr);

        if ( rc1 == SCESTATUS_BUFFER_TOO_SMALL ) {
            //
            // if only length is requested, don't care buffer_too_small
            //
            if ( Value == NULL )
                rc1 = SCESTATUS_SUCCESS;
        }

        if ( rc1 != SCESTATUS_SUCCESS &&
             rc1 != SCESTATUS_BUFFER_TOO_SMALL )
            return(rc1);

        //
        // rc is the status from retrieving Name field
        //
        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
        else
            return(rc1);
    }

    return(rc);
}


SCESTATUS
SceJetSetLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN BOOL       bReserveCase,
    IN PWSTR      Value,
    IN DWORD      ValueLen,
    IN LONG       GpoID
    )
/* ++
Fucntion Description:

    This routine writes the Name and Value to the section (hSection).
    If a exact matched name is found, overwrite, else insert a new
    record.

Arguments:

    hSection    - The context handle of the section

    Name        - The info set to Column "Name"

    Value       - The info set to Column "Value"

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OTHER_ERROR
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_DATA_OVERFLOW

-- */
{
    JET_ERR     JetErr;
    DWORD       Len;
    SCESTATUS    rc;
    DWORD       prep;
    JET_SETINFO SetInfo;
    PWSTR       LwrName=NULL;

    if ( hSection == NULL ||
         Name == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    Len = wcslen(Name)*sizeof(WCHAR);

    if ( Len <= 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( bReserveCase ) {
        LwrName = Name;

    } else {
        //
        // lower cased
        //
        LwrName = (PWSTR)ScepAlloc(0, Len+2);
        if ( LwrName == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        wcscpy(LwrName, Name);
        LwrName = _wcslwr(LwrName);

    }

    SetInfo.cbStruct = sizeof(JET_SETINFO);
    SetInfo.itagSequence = 1;
    SetInfo.ibLongValue = 0;

    //
    // check to see if the same key name already exists
    //
    JetErr = SceJetpSeek(
                    hSection,
                    LwrName,
                    Len,
                    SCEJET_SEEK_EQ,
                    FALSE
                    );

    if ( JetErr == JET_errSuccess ||
         JetErr == JET_errRecordNotFound ) {
        if ( JetErr == JET_errSuccess )
            // find a match. overwrite the value
            prep = JET_prepReplace;
        else
            // no match. prepare the record for insertion
            prep = JET_prepInsert;

        JetErr = JetBeginTransaction(hSection->JetSessionID);

        if ( JetErr == JET_errSuccess ) {
            JetErr = JetPrepareUpdate(hSection->JetSessionID,
                                      hSection->JetTableID,
                                      prep
                                      );
            if ( JetErr != JET_errSuccess ) {
                //
                // rollback the transaction
                //
                JetRollback(hSection->JetSessionID,0);
            }
        }
    }

    if ( JetErr != JET_errSuccess)
        return(SceJetJetErrorToSceStatus(JetErr));


    if ( prep == JET_prepInsert ) {
        //
        // set the sectionID column
        //
        JetErr = JetSetColumn(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        hSection->JetColumnSectionID,
                        (void *)&(hSection->SectionID),
                        8,
                        0, //JET_bitSetOverwriteLV,
                        NULL
                        );
        if ( JetErr == JET_errSuccess ) {
            //
            // set the new key in "Name" column
            //
            JetErr = JetSetColumn(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            hSection->JetColumnNameID,
                            (void *)LwrName,
                            Len,
                            0, //JET_bitSetOverwriteLV,
                            &SetInfo
                            );
        }

    }

    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // set value column
        //

        JetErr = JetSetColumn(
                        hSection->JetSessionID,
                        hSection->JetTableID,
                        hSection->JetColumnValueID,
                        (void *)Value,
                        ValueLen,
                        0, //JET_bitSetOverwriteLV,
                        &SetInfo
                        );
        if ( JetErr == JET_errSuccess ) {
            //
            // if GPO ID is provided and there is a GPOID column, set it
            //
            if ( GpoID > 0 && hSection->JetColumnGpoID > 0 ) {

                JetErr = JetSetColumn(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                hSection->JetColumnGpoID,
                                (void *)&GpoID,
                                sizeof(LONG),
                                0,
                                NULL
                                );
                if ( JET_errColumnNotUpdatable == JetErr ) {
                    JetErr = JET_errSuccess;
                }
            }
            // else
            // if can't find the column, ignore the error
            //

            if ( JET_errSuccess == JetErr ) {

                //
                // Setting columns succeed. Update the record
                //
                JetErr = JetUpdate(hSection->JetSessionID,
                                   hSection->JetTableID,
                                   NULL,
                                   0,
                                   &Len
                                   );

            }

        }
        rc = SceJetJetErrorToSceStatus(JetErr);

    }

    if ( rc == SCESTATUS_SUCCESS )
        JetCommitTransaction(hSection->JetSessionID, JET_bitCommitLazyFlush);

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // if setting fails, cancel the prepared record
        //
        JetPrepareUpdate(hSection->JetSessionID,
                          hSection->JetTableID,
                          JET_prepCancel
                          );
        //
        // Rollback the transaction
        //
        JetRollback(hSection->JetSessionID,0);

    }

    if ( LwrName != Name ) {
        ScepFree(LwrName);
    }

    return(rc);

}


//
// Exported helper APIs
//
SCESTATUS
SceJetCreateTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType,
    IN SCEJET_CREATE_FLAG nFlags,
    OUT JET_TABLEID *TableID OPTIONAL,
    OUT JET_COLUMNID *ColumnID OPTIONAL
    )
/* ++
Routine Description:

    This routine creates a table in the database opened in the context handle.
    SCP/SAP/SMP tables created in the database have 3 columns: Section, Name,
    and Value, with one index "SectionKey" which is Section+Name ascending.
    Version table has only one column "Version".

Arguments:

    cxtProfile  - The context handle

    tblName     - ASCII name of the table to create

    tblType     - The type of the table. It may be one of the following
                    SCEJET_TABLE_SCP
                    SCEJET_TABLE_SAP
                    SCEJET_TABLE_SMP
                    SCEJET_TABLE_VERSION
                    SCEJET_TABLE_SECTION
                    SCEJET_TABLE_TATTOO
                    SCEJET_TABLE_GPO

    TableID     - SmTblVersion table id when tblType = SCEJET_TABLE_VERSION.

    ColumnID    - The column ID for Version when tblType = SCEJET_TABLE_VERSION

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OBJECT_EXIST
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR


-- */
{
    JET_ERR             JetErr;
    SCESTATUS            rc;
    JET_TABLECREATE     TableCreate;
    JET_COLUMNCREATE    ColumnCreate[5];
    JET_INDEXCREATE     IndexCreate[2];
    DWORD               numColumns;


    if ( cxtProfile == NULL || tblName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( TableID ) {
        *TableID = JET_tableidNil;
    }

    if ( ColumnID ) {
        *ColumnID = 0;
    }

    switch ( tblType ) {
    case SCEJET_TABLE_VERSION:

        if ( TableID == NULL || ColumnID == NULL )
            return(SCESTATUS_INVALID_PARAMETER);
        //
        // There is only one column in this table
        //
        ColumnCreate[0].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[0].szColumnName = "Version";
        ColumnCreate[0].coltyp = JET_coltypIEEESingle;
        ColumnCreate[0].cbMax = 4;
        ColumnCreate[0].grbit = JET_bitColumnNotNULL;
        ColumnCreate[0].pvDefault = NULL;
        ColumnCreate[0].cbDefault = 0;
        ColumnCreate[0].cp = 0;
        ColumnCreate[0].columnid = 0;

        ColumnCreate[1].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[1].szColumnName = "AnalyzeTimeStamp";
        ColumnCreate[1].coltyp = JET_coltypBinary;
        ColumnCreate[1].cbMax = 16; // should be 8 bytes - change later
        ColumnCreate[1].grbit = 0;
        ColumnCreate[1].pvDefault = NULL;
        ColumnCreate[1].cbDefault = 0;
        ColumnCreate[1].cp = 0;
        ColumnCreate[1].columnid = 0;

        ColumnCreate[2].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[2].szColumnName = "ConfigTimeStamp";
        ColumnCreate[2].coltyp = JET_coltypBinary;
        ColumnCreate[2].cbMax = 16; // should be 8 bytes - change later
        ColumnCreate[2].grbit = 0;
        ColumnCreate[2].pvDefault = NULL;
        ColumnCreate[2].cbDefault = 0;
        ColumnCreate[2].cp = 0;
        ColumnCreate[2].columnid = 0;

        ColumnCreate[3].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[3].szColumnName = "LastUsedMergeTable";
        ColumnCreate[3].coltyp = JET_coltypLong;
        ColumnCreate[3].cbMax = 4;
        ColumnCreate[3].grbit = 0;
        ColumnCreate[3].pvDefault = NULL;
        ColumnCreate[3].cbDefault = 0;
        ColumnCreate[3].cp = 0;
        ColumnCreate[3].columnid = 0;

        ColumnCreate[4].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[4].szColumnName = "ProfileDescription";
        ColumnCreate[4].coltyp = JET_coltypLongBinary;
        ColumnCreate[4].cbMax = 1024;
        ColumnCreate[4].grbit = 0;
        ColumnCreate[4].pvDefault = NULL;
        ColumnCreate[4].cbDefault = 0;
        ColumnCreate[4].cp = 0;
        ColumnCreate[4].columnid = 0;

        //
        // Assign table info
        //
        TableCreate.cbStruct = sizeof(JET_TABLECREATE);
        TableCreate.szTableName = tblName;
        TableCreate.szTemplateTableName = NULL;
        TableCreate.ulPages = 1;
        TableCreate.ulDensity = 90;
        TableCreate.rgcolumncreate = ColumnCreate;
        TableCreate.cColumns = 5;
        TableCreate.rgindexcreate = NULL;
        TableCreate.cIndexes = 0;
        TableCreate.grbit = 0;
        TableCreate.tableid = 0;

        break;

    case SCEJET_TABLE_SCP:
    case SCEJET_TABLE_SAP:
    case SCEJET_TABLE_SMP:
    case SCEJET_TABLE_TATTOO:

        //
        // There are 3 columns in each table.
        // Assign each column info
        //
        ColumnCreate[0].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[0].szColumnName = "SectionID";
        ColumnCreate[0].coltyp = JET_coltypIEEEDouble;
        ColumnCreate[0].cbMax = 8;
        ColumnCreate[0].grbit = JET_bitColumnNotNULL;
        ColumnCreate[0].pvDefault = NULL;
        ColumnCreate[0].cbDefault = 0;
        ColumnCreate[0].cp = 0;
        ColumnCreate[0].columnid = 0;

        ColumnCreate[1].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[1].szColumnName = "Name";
        ColumnCreate[1].coltyp = JET_coltypLongBinary;
        ColumnCreate[1].cbMax = 1024;
        ColumnCreate[1].grbit = 0;  //JET_bitColumnNotNULL;
        ColumnCreate[1].pvDefault = NULL;
        ColumnCreate[1].cbDefault = 0;
        ColumnCreate[1].cp = 0;
        ColumnCreate[1].columnid = 0;

        ColumnCreate[2].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[2].szColumnName = "Value";
        ColumnCreate[2].coltyp = JET_coltypLongBinary;
        ColumnCreate[2].cbMax = (unsigned long)0x7FFFFFFF;    // 2GB
        ColumnCreate[2].grbit = 0;
        ColumnCreate[2].pvDefault = NULL;
        ColumnCreate[2].cbDefault = 0;
        ColumnCreate[2].cp = 0;
        ColumnCreate[2].columnid = 0;

        numColumns = 3;

        if ( tblType == SCEJET_TABLE_SCP ) {

            ColumnCreate[3].cbStruct = sizeof(JET_COLUMNCREATE);
            ColumnCreate[3].szColumnName = "GpoID";
            ColumnCreate[3].coltyp = JET_coltypLong;
            ColumnCreate[3].cbMax = 4;
            ColumnCreate[3].grbit = 0;
            ColumnCreate[3].pvDefault = NULL;
            ColumnCreate[3].cbDefault = 0;
            ColumnCreate[3].cp = 0;
            ColumnCreate[3].columnid = 0;

            numColumns = 4;
        }

        //
        // Assign index info - one index in each table.
        //
        memset(IndexCreate, 0, sizeof(JET_INDEXCREATE) );
        IndexCreate[0].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[0].szIndexName = "SectionKey";
        IndexCreate[0].szKey = "+SectionID\0+Name\0\0";
        IndexCreate[0].cbKey = 18;
        IndexCreate[0].grbit = 0; // JET_bitIndexPrimary; // | JET_bitIndexUnique;
        IndexCreate[0].ulDensity = 50;
        //
        // Assign table info
        //
        TableCreate.cbStruct = sizeof(JET_TABLECREATE);
        TableCreate.szTableName = tblName;
        TableCreate.szTemplateTableName = NULL;
        TableCreate.ulPages = 20;
        TableCreate.ulDensity = 50;
        TableCreate.rgcolumncreate = ColumnCreate;
        TableCreate.cColumns = numColumns;
        TableCreate.rgindexcreate = IndexCreate;
        TableCreate.cIndexes = 1;
        TableCreate.grbit = 0;
        TableCreate.tableid = 0;

        break;

    case SCEJET_TABLE_SECTION:
        //
        // There are 2 columns in this table.
        // Assign each column info
        //
        ColumnCreate[0].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[0].szColumnName = "SectionID";
        ColumnCreate[0].coltyp = JET_coltypIEEEDouble;
        ColumnCreate[0].cbMax = 8;
        ColumnCreate[0].grbit = JET_bitColumnNotNULL;
        ColumnCreate[0].pvDefault = NULL;
        ColumnCreate[0].cbDefault = 0;
        ColumnCreate[0].cp = 0;
        ColumnCreate[0].columnid = 0;

        ColumnCreate[1].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[1].szColumnName = "Name";
        ColumnCreate[1].coltyp = JET_coltypBinary;
        ColumnCreate[1].cbMax = 255;
        ColumnCreate[1].grbit = JET_bitColumnNotNULL;
        ColumnCreate[1].pvDefault = NULL;
        ColumnCreate[1].cbDefault = 0;
        ColumnCreate[1].cp = 0;
        ColumnCreate[1].columnid = 0;

        //
        // Assign index info - one index in each table.
        //
        memset(IndexCreate, 0, 2*sizeof(JET_INDEXCREATE) );
        IndexCreate[0].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[0].szIndexName = "SectionKey";
        IndexCreate[0].szKey = "+Name\0\0";
        IndexCreate[0].cbKey = 7;
        IndexCreate[0].grbit = JET_bitIndexPrimary; // | JET_bitIndexUnique;
        IndexCreate[0].ulDensity = 80;

        IndexCreate[1].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[1].szIndexName = "SecID";
        IndexCreate[1].szKey = "+SectionID\0\0";
        IndexCreate[1].cbKey = 12;
        IndexCreate[1].grbit = 0;
        IndexCreate[1].ulDensity = 80;
        //
        // Assign table info
        //
        TableCreate.cbStruct = sizeof(JET_TABLECREATE);
        TableCreate.szTableName = tblName;
        TableCreate.szTemplateTableName = NULL;
        TableCreate.ulPages = 10;
        TableCreate.ulDensity = 80;
        TableCreate.rgcolumncreate = ColumnCreate;
        TableCreate.cColumns = 2;
        TableCreate.rgindexcreate = IndexCreate;
        TableCreate.cIndexes = 2;
        TableCreate.grbit = 0;
        TableCreate.tableid = 0;

        break;

    case SCEJET_TABLE_GPO:
        //
        // There are 3 columns in this table.
        // Assign each column info
        //
        ColumnCreate[0].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[0].szColumnName = "GpoID";
        ColumnCreate[0].coltyp = JET_coltypLong;
        ColumnCreate[0].cbMax = 4;
        ColumnCreate[0].grbit = JET_bitColumnNotNULL;
        ColumnCreate[0].pvDefault = NULL;
        ColumnCreate[0].cbDefault = 0;
        ColumnCreate[0].cp = 0;
        ColumnCreate[0].columnid = 0;

        ColumnCreate[1].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[1].szColumnName = "Name";
        ColumnCreate[1].coltyp = JET_coltypBinary;
        ColumnCreate[1].cbMax = 255;
        ColumnCreate[1].grbit = JET_bitColumnNotNULL;
        ColumnCreate[1].pvDefault = NULL;
        ColumnCreate[1].cbDefault = 0;
        ColumnCreate[1].cp = 0;
        ColumnCreate[1].columnid = 0;

        ColumnCreate[2].cbStruct = sizeof(JET_COLUMNCREATE);
        ColumnCreate[2].szColumnName = "DisplayName";
        ColumnCreate[2].coltyp = JET_coltypBinary;
        ColumnCreate[2].cbMax = 255;
        ColumnCreate[2].grbit = 0;
        ColumnCreate[2].pvDefault = NULL;
        ColumnCreate[2].cbDefault = 0;
        ColumnCreate[2].cp = 0;
        ColumnCreate[2].columnid = 0;

        //
        // Assign index info - one index in each table.
        //
        memset(IndexCreate, 0, 2*sizeof(JET_INDEXCREATE) );
        IndexCreate[0].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[0].szIndexName = "SectionKey";
        IndexCreate[0].szKey = "+GpoID\0\0";
        IndexCreate[0].cbKey = 8;
        IndexCreate[0].grbit = JET_bitIndexPrimary; // | JET_bitIndexUnique;
        IndexCreate[0].ulDensity = 80;

        IndexCreate[1].cbStruct = sizeof(JET_INDEXCREATE);
        IndexCreate[1].szIndexName = "GpoName";
        IndexCreate[1].szKey = "+Name\0\0";
        IndexCreate[1].cbKey = 7;
        IndexCreate[1].grbit = 0;
        IndexCreate[1].ulDensity = 80;

        //
        // Assign table info
        //
        TableCreate.cbStruct = sizeof(JET_TABLECREATE);
        TableCreate.szTableName = tblName;
        TableCreate.szTemplateTableName = NULL;
        TableCreate.ulPages = 10;
        TableCreate.ulDensity = 80;
        TableCreate.rgcolumncreate = ColumnCreate;
        TableCreate.cColumns = 3;
        TableCreate.rgindexcreate = IndexCreate;
        TableCreate.cIndexes = 2;
        TableCreate.grbit = 0;
        TableCreate.tableid = 0;

        break;

    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // Create the table, column, and index together
    //
    JetErr = JetCreateTableColumnIndex(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetDbID,
                    &TableCreate
                    );

    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( SCESTATUS_OBJECT_EXIST == rc &&
         TableCreate.tableid != JET_tableidNil ) {
        rc = SCESTATUS_SUCCESS;

    } else if ( rc == SCESTATUS_SUCCESS &&
                TableCreate.tableid == JET_tableidNil ) {

        rc = SCESTATUS_OTHER_ERROR;
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // Save the tableid and columnid in the context
        //
        if ( SCEJET_CREATE_NO_TABLEID == nFlags ) {
            //
            // do not need table ID to be returned
            //
            if ( TableCreate.tableid != JET_tableidNil ) {
                JetCloseTable(
                    cxtProfile->JetSessionID,
                    TableCreate.tableid
                    );
            }

        } else {

            if ( tblType == SCEJET_TABLE_VERSION ) {

                *TableID = TableCreate.tableid;
                *ColumnID = ColumnCreate[0].columnid;

            } else if ( TableID ) {
                *TableID = TableCreate.tableid;

            } else {

                switch ( tblType ) {
                case SCEJET_TABLE_SCP:
                    cxtProfile->JetScpID = TableCreate.tableid;
                    cxtProfile->JetScpSectionID = ColumnCreate[0].columnid;
                    cxtProfile->JetScpNameID = ColumnCreate[1].columnid;
                    cxtProfile->JetScpValueID = ColumnCreate[2].columnid;
                    cxtProfile->JetScpGpoID = ColumnCreate[3].columnid;
                    break;
                case SCEJET_TABLE_SMP:
                    cxtProfile->JetSmpID = TableCreate.tableid;
                    cxtProfile->JetSmpSectionID = ColumnCreate[0].columnid;
                    cxtProfile->JetSmpNameID = ColumnCreate[1].columnid;
                    cxtProfile->JetSmpValueID = ColumnCreate[2].columnid;
                    break;
                case SCEJET_TABLE_SAP:
                case SCEJET_TABLE_TATTOO: // use the SAP handle
                    cxtProfile->JetSapID = TableCreate.tableid;
                    cxtProfile->JetSapSectionID = ColumnCreate[0].columnid;
                    cxtProfile->JetSapNameID = ColumnCreate[1].columnid;
                    cxtProfile->JetSapValueID = ColumnCreate[2].columnid;
                    break;
                case SCEJET_TABLE_SECTION:
                    cxtProfile->JetTblSecID = TableCreate.tableid;
                    cxtProfile->JetSecNameID = ColumnCreate[1].columnid;
                    cxtProfile->JetSecID = ColumnCreate[0].columnid;
                    break;
                }
            }

            if ( tblType != SCEJET_TABLE_VERSION ) {

                //
                // Set current index in this table
                //
                JetErr = JetSetCurrentIndex(
                                cxtProfile->JetSessionID,
                                TableCreate.tableid,
                                "SectionKey"
                                );
                rc = SceJetJetErrorToSceStatus(JetErr);
            }
        }
    }

    return(rc);
}


SCESTATUS
SceJetOpenTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType,
    IN SCEJET_OPEN_TYPE OpenType,
    OUT JET_TABLEID *TableID
    )
/* ++
Routine Description:

    This routine opens a table, gets column IDs for the column "Name" and
    "Value" and saves them in the context.

Arguments:

    cxtProfile  - The context handle

    tblName     - ASCII name of a table to open

    tblType     - The type of the table. It may be one of the following
                    SCEJET_TABLE_SCP
                    SCEJET_TABLE_SAP
                    SCEJET_TABLE_SMP
                    SCEJET_TABLE_VERSION
                    SCEJET_TABLE_SECTION
                    SCEJET_TABLE_GPO
                    SCEJET_TABLE_TATTOO
Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_BAD_FORMAT
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_OTHER_ERROR

-- */
{
    JET_ERR         JetErr;
    JET_TABLEID     *tblID;
    JET_TABLEID     tmpTblID;
    JET_COLUMNDEF   ColumnDef;
    JET_COLUMNID    NameID=0;
    JET_COLUMNID    ValueID=0;
    JET_COLUMNID    SectionID=0;
    JET_COLUMNID    GpoColID=0;
    SCESTATUS       rc;
    JET_GRBIT       grbit=0;

    if ( cxtProfile == NULL || tblName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    // get address of table id

    if ( TableID ) {
        tblID = TableID;

    } else {

        switch (tblType) {
        case SCEJET_TABLE_SCP:
            tblID = &(cxtProfile->JetScpID);
            break;
        case SCEJET_TABLE_SAP:
        case SCEJET_TABLE_TATTOO:
            tblID = &(cxtProfile->JetSapID);
            break;
        case SCEJET_TABLE_SMP:
            tblID = &(cxtProfile->JetSmpID);
            break;
        case SCEJET_TABLE_SECTION:
            tblID = &(cxtProfile->JetTblSecID);
            break;

        default:
            return(SCESTATUS_INVALID_PARAMETER);
        }
    }

    if ( OpenType == SCEJET_OPEN_READ_ONLY ) {
        grbit = JET_bitTableReadOnly;
    }

    // open this table
    JetErr = JetOpenTable(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetDbID,
                    tblName,
                    NULL,
                    0,
                    grbit,
                    &tmpTblID
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS )
        *tblID = tmpTblID;

    if ( TableID ) {
        return(rc);
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // SCP and SMP table must exist. SAP and Tattoo tables are optional.
        //
        if ( tblType != SCEJET_TABLE_SCP &&
             tblType != SCEJET_TABLE_SMP &&
             tblType != SCEJET_TABLE_SECTION &&
             ( rc == SCESTATUS_BAD_FORMAT ||
               rc == SCESTATUS_PROFILE_NOT_FOUND) ) {
            return(SCESTATUS_SUCCESS);
        }
        return(rc);
    }

    //
    // get column id for Column "SectionID"
    //
    JetErr = JetGetTableColumnInfo(
                    cxtProfile->JetSessionID,
                    *tblID,
                    "SectionID",
                    (VOID *)&ColumnDef,
                    sizeof(JET_COLUMNDEF),
                    0
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);
    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }
    SectionID = ColumnDef.columnid;

    //
    // get column id for Column "Name"
    //
    JetErr = JetGetTableColumnInfo(
                    cxtProfile->JetSessionID,
                    *tblID,
                    "Name",
                    (VOID *)&ColumnDef,
                    sizeof(JET_COLUMNDEF),
                    0
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);
    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }
    NameID = ColumnDef.columnid;

    if ( tblType == SCEJET_TABLE_SCP ||
         tblType == SCEJET_TABLE_SAP ||
         tblType == SCEJET_TABLE_SMP ||
         tblType == SCEJET_TABLE_TATTOO ) {

        //
        // get column id for Column "Value"
        //
        JetErr = JetGetTableColumnInfo(
                        cxtProfile->JetSessionID,
                        *tblID,
                        "Value",
                        (VOID *)&ColumnDef,
                        sizeof(JET_COLUMNDEF),
                        0
                        );
        rc = SceJetJetErrorToSceStatus(JetErr);
        if ( rc != SCESTATUS_SUCCESS ) {
            return(rc);
        }
        ValueID = ColumnDef.columnid;

        if ( tblType == SCEJET_TABLE_SCP ) {
            //
            // get column id for column GpoID
            //
            JetErr = JetGetTableColumnInfo(
                            cxtProfile->JetSessionID,
                            *tblID,
                            "GpoID",
                            (VOID *)&ColumnDef,
                            sizeof(JET_COLUMNDEF),
                            0
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);
            if ( rc != SCESTATUS_SUCCESS ) {
                return(rc);
            }
            GpoColID = ColumnDef.columnid;
        }
    }

    //
    // save the column ids
    //
    switch (tblType) {
    case SCEJET_TABLE_SCP:
        cxtProfile->JetScpSectionID = SectionID;
        cxtProfile->JetScpNameID = NameID;
        cxtProfile->JetScpValueID = ValueID;
        cxtProfile->JetScpGpoID = GpoColID;
        break;
    case SCEJET_TABLE_SAP:
    case SCEJET_TABLE_TATTOO:
        cxtProfile->JetSapSectionID = SectionID;
        cxtProfile->JetSapNameID = NameID;
        cxtProfile->JetSapValueID = ValueID;
        break;
    case SCEJET_TABLE_SMP:
        cxtProfile->JetSmpSectionID = SectionID;
        cxtProfile->JetSmpNameID = NameID;
        cxtProfile->JetSmpValueID = ValueID;
        break;
    case SCEJET_TABLE_SECTION:
        cxtProfile->JetSecID = SectionID;
        cxtProfile->JetSecNameID = NameID;
   }

    //
    // Set current index
    //

    JetErr = JetSetCurrentIndex(
                    cxtProfile->JetSessionID,
                    *tblID,
                    "SectionKey"
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);

    return(rc);

}


SCESTATUS
SceJetDeleteTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType
    )
{
    JET_ERR         JetErr;
    JET_TABLEID     *tblID;
    SCESTATUS        rc=SCESTATUS_SUCCESS;


    if ( cxtProfile == NULL || tblName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    // get address of table id
    switch (tblType) {
    case SCEJET_TABLE_SCP:
        tblID = &(cxtProfile->JetScpID);
        break;
    case SCEJET_TABLE_SAP:
    case SCEJET_TABLE_TATTOO:
        tblID = &(cxtProfile->JetSapID);
        break;
    case SCEJET_TABLE_SMP:
        tblID = &(cxtProfile->JetSmpID);
        break;
    case SCEJET_TABLE_SECTION:
        tblID = &(cxtProfile->JetTblSecID);
        break;
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    // close this table
    if ( *tblID != JET_tableidNil ) {
        JetErr = JetCloseTable(
                        cxtProfile->JetSessionID,
                        *tblID
                        );
        rc = SceJetJetErrorToSceStatus(JetErr);
        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

        *tblID = JET_tableidNil;

        //
        // reset each column id
        //
        switch (tblType) {
        case SCEJET_TABLE_SCP:
            cxtProfile->JetScpSectionID = 0;
            cxtProfile->JetScpNameID = 0;
            cxtProfile->JetScpValueID = 0;
            cxtProfile->JetScpGpoID = 0;
            break;
        case SCEJET_TABLE_SAP:
        case SCEJET_TABLE_TATTOO:
            cxtProfile->JetSapSectionID = 0;
            cxtProfile->JetSapNameID = 0;
            cxtProfile->JetSapValueID = 0;
            break;
        case SCEJET_TABLE_SMP:
            cxtProfile->JetSmpSectionID = 0;
            cxtProfile->JetSmpNameID = 0;
            cxtProfile->JetSmpValueID = 0;
            break;
        case SCEJET_TABLE_SECTION:
            cxtProfile->JetSecNameID = 0;
            cxtProfile->JetSecID = 0;
            break;
        }
    }

    JetErr = JetDeleteTable(cxtProfile->JetSessionID,
                            cxtProfile->JetDbID,
                            tblName
                            );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_BAD_FORMAT )
        rc = SCESTATUS_SUCCESS;

    return(rc);

}


SCESTATUS
SceJetCheckVersion(
    IN PSCECONTEXT   cxtProfile,
    OUT FLOAT *pVersion OPTIONAL
    )
/* ++
Routine Description:

    This routine checks the version table in the database to see if the
    database is for the security manager, also if the version # is the
    correct one.

    The version table is named "SmTblVersion" and has a Version column
    in it. The current version # is 1.2

Arguments:

    cxtProfile  - The profile context

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR
    SCESTATUS from SceJetOpenTable

-- */
{
    SCESTATUS        rc;
    FLOAT           Version=(FLOAT)1.0;
    DWORD           Actual;


    if ( cxtProfile == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = SceJetpGetValueFromVersion(
                cxtProfile,
                "SmTblVersion",
                "Version",
                (LPSTR)&Version,
                4, // number of bytes
                &Actual
                );

    if ( rc == SCESTATUS_SUCCESS ||
         rc == SCESTATUS_BUFFER_TOO_SMALL ) {

        if ( Version != (FLOAT)1.2 )
            rc = SCESTATUS_BAD_FORMAT;
        else
            rc = SCESTATUS_SUCCESS;
    }

    if ( pVersion ) {
        *pVersion = Version;
    }

    return(rc);
}


SCESTATUS
SceJetGetSectionIDByName(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR Name,
    OUT DOUBLE *SectionID OPTIONAL
    )
/* ++
Routine Description:

    This routine retrieve the section ID for the name in the Section table.
    If SectionID is NULL, this routine really does a seek by name. The cursor
    will be on the record if there is a successful match.

Arguments:

    cxtProfile  - The profile context handle

    Name        - The section name looked for

    SectionID   - The output section ID if there is a successful match

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;
    PWSTR     LwrName=NULL;
    DWORD     Len;

    if ( cxtProfile == NULL || Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( cxtProfile->JetTblSecID <= 0) {
        //
        // Section table is not opened yet
        //
        rc = SceJetOpenTable(
                        cxtProfile,
                        "SmTblSection",
                        SCEJET_TABLE_SECTION,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    //
    // set current index to SectionKey (the name)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                "SectionKey"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    Len = wcslen(Name);
    LwrName = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));

    if ( LwrName != NULL ) {

        wcscpy(LwrName, Name);
        LwrName = _wcslwr(LwrName);

        JetErr = JetMakeKey(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetTblSecID,
                    (VOID *)LwrName,
                    Len*sizeof(WCHAR),
                    JET_bitNewKey
                    );

        if ( JetErr == JET_errKeyIsMade ) {
            //
            // Only one key is needed, it may return this code, even on success.
            //
            JetErr = JET_errSuccess;
        }
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            JetErr = JetSeek(
                        cxtProfile->JetSessionID,
                        cxtProfile->JetTblSecID,
                        JET_bitSeekEQ
                        );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // find the section name, retrieve column SectionID
                //
                if ( SectionID != NULL) {
                    JetErr = JetRetrieveColumn(
                                    cxtProfile->JetSessionID,
                                    cxtProfile->JetTblSecID,
                                    cxtProfile->JetSecID,
                                    (void *)SectionID,
                                    8,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);
                }

            }

        }
        ScepFree(LwrName);

    } else
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

    return(rc);

}


SCESTATUS
SceJetGetSectionNameByID(
    IN PSCECONTEXT cxtProfile,
    IN DOUBLE SectionID,
    OUT PWSTR Name OPTIONAL,
    IN OUT LPDWORD pNameLen OPTIONAL
    )
/* ++
Routine Description:

    This routine retrieve the section name for the ID in the Section table.
    If Name is NULL, this routine really does a seek by ID. The cursor will
    be on the record if there is a successful match.

Arguments:

    cxtProfile  - The profile context handle

    SectionID   - The section ID looking for

    Name        - The optional output buffer for section name

    pNameLen  - The name buffer's length


Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;


    if ( cxtProfile == NULL || (Name != NULL && pNameLen == NULL) )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( cxtProfile->JetTblSecID <= 0) {
        //
        // Section table is not opened yet
        //
        rc = SceJetOpenTable(
                        cxtProfile,
                        "SmTblSection",
                        SCEJET_TABLE_SECTION,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    //
    // set current index to SecID (the ID)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                "SecID"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    JetErr = JetMakeKey(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                (VOID *)(&SectionID),
                8,
                JET_bitNewKey
                );

    if ( JetErr == JET_errKeyIsMade ) {
        //
        // Only one key is needed, it may return this code, even on success.
        //
        JetErr = JET_errSuccess;
    }
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        JetErr = JetSeek(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetTblSecID,
                    JET_bitSeekEQ
                    );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // find the section ID, retrieve column Name
            //
            if ( Name != NULL ) {
                JetErr = JetRetrieveColumn(
                            cxtProfile->JetSessionID,
                            cxtProfile->JetTblSecID,
                            cxtProfile->JetSecNameID,
                            (void *)Name,
                            *pNameLen,
                            &Actual,
                            0,
                            NULL
                            );
                *pNameLen = Actual;
                rc = SceJetJetErrorToSceStatus(JetErr);
            }
        }

    }

    return(rc);

}


SCESTATUS
SceJetAddSection(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR      Name,
    OUT DOUBLE *SectionID
    )
/* ++
Routine Description:

Arguments:

Return Value:

-- */
{
    SCESTATUS  rc;
    DWORD     Len;
    JET_ERR   JetErr;
    PWSTR     LwrName=NULL;


    if ( cxtProfile == NULL ||
         Name == NULL ||
        SectionID == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = SceJetGetSectionIDByName(
                    cxtProfile,
                    Name,
                    SectionID
                    );
    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        //
        // the record is not there. add it in
        // get the next available section ID first.
        //
        Len = wcslen(Name)*sizeof(WCHAR);
        LwrName = (PWSTR)ScepAlloc(0, Len+2);

        if ( LwrName != NULL ) {

            rc = SceJetpGetAvailableSectionID(
                        cxtProfile,
                        SectionID
                        );
            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // add a record to the section table
                //
                JetErr = JetPrepareUpdate(cxtProfile->JetSessionID,
                                          cxtProfile->JetTblSecID,
                                          JET_prepInsert
                                          );
                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // set SectionID and name
                    //

                    JetErr = JetSetColumn(
                                    cxtProfile->JetSessionID,
                                    cxtProfile->JetTblSecID,
                                    cxtProfile->JetSecID,
                                    (void *)SectionID,
                                    8,
                                    0, //JET_bitSetOverwriteLV,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // set Name column
                        //
                        wcscpy(LwrName, Name);
                        LwrName = _wcslwr(LwrName);

                        JetErr = JetSetColumn(
                                        cxtProfile->JetSessionID,
                                        cxtProfile->JetTblSecID,
                                        cxtProfile->JetSecNameID,
                                        (void *)LwrName,
                                        Len,
                                        0,
                                        NULL
                                        );
                        rc = SceJetJetErrorToSceStatus(JetErr);

                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        //
                        // if setting fails, cancel the prepared record
                        //
                        JetPrepareUpdate( cxtProfile->JetSessionID,
                                          cxtProfile->JetTblSecID,
                                          JET_prepCancel
                                          );
                    } else {

                        //
                        // Setting columns succeed. Update the record
                        //
                        JetErr = JetUpdate(cxtProfile->JetSessionID,
                                           cxtProfile->JetTblSecID,
                                           NULL,
                                           0,
                                           &Len
                                           );
                        rc = SceJetJetErrorToSceStatus(JetErr);
                    }
                }
            }
            ScepFree(LwrName);
        }
    }

    return(rc);
}


SCESTATUS
SceJetDeleteSectionID(
    IN PSCECONTEXT cxtProfile,
    IN DOUBLE SectionID,
    IN PCWSTR  Name
    )
/* ++
Routine Description:

    This routine deletes a record from the SmTblSection table. If SectionID
    is not 0, the record will be deleted by ID if there is a match on ID.
    Otherwise, the record will be deleted by Name if there is a match on Name.

Arguments:

    cxtProfile  - The profile context handle

    SectionID   - The SectionID to delete (if it is not 0)

    Name        - The section name to delete (if it is not NULL ).

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_OTHER_ERROR

    SCESTATUS from SceJetGetSectionIDByName
    SCESTATUS from SceJetGetSectionNameByID

-- */
{
    SCESTATUS    rc;
    JET_ERR     JetErr;


    if ( cxtProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);


    if ( SectionID > (DOUBLE)0 ) {
        //
        // delete by SectionID
        //
        rc = SceJetGetSectionNameByID(
                    cxtProfile,
                    SectionID,
                    NULL,
                    NULL
                    );

        if ( rc == SCESTATUS_SUCCESS ) {
            // find it
            JetErr = JetDelete(cxtProfile->JetSessionID, cxtProfile->JetTblSecID);
            rc = SceJetJetErrorToSceStatus(JetErr);

        }

        return(rc);

    }

    if ( Name != NULL && wcslen(Name) > 0 ) {
        //
        // delete by Name
        //
        rc = SceJetGetSectionIDByName(
                    cxtProfile,
                    Name,
                    NULL
                    );
        if ( rc == SCESTATUS_SUCCESS ) {
            // find it
            JetErr = JetDelete(cxtProfile->JetSessionID, cxtProfile->JetTblSecID);
            rc = SceJetJetErrorToSceStatus(JetErr);

        }

        return(rc);
    }

    return(SCESTATUS_INVALID_PARAMETER);

}


//
// Other private APIs
//
JET_ERR
SceJetpSeek(
    IN PSCESECTION hSection,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength,
    IN SCEJET_SEEK_FLAG SeekBit,
    IN BOOL bOkNoMatch
    )
/* ++
Routine Description:

    This routine seeks to the current key as built with SceJetpMakeKey.
    If there is no records start with the SectionID+LinePrefix, a
    JET_errRecordNotFound is returned. This is similar to exact or partial
    match search.

    There is a 255 bytes limit on Jet engine's index. If SectionID plus
    the line prefix is over this limit, this routine will scroll to the next
    record until find a line starting with SectionID + LinePrefix.

Arguments:

    hSection    - the context handle of the section

    LinePrefix  - The prefix for fields to start with

    PrefixLength- The length of the prefix in BYTES

    grbit       - The option for JetSeek

Return Value:

    JET_ERR returned from JetMakeKey,JetSeek,JetRetrieveColumn, JetMove

-- */
{
    JET_ERR     JetErr;
    INT         Result=0;
    JET_GRBIT   grbit;
    DWORD       Actual;

    //
    // make the key first
    //
    JetErr = SceJetpMakeKey(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->SectionID,
                    LinePrefix,
                    PrefixLength
                    );
    if ( JetErr != JET_errSuccess ) {
        return(JetErr);
    }
    //
    // Call Jet engine's JetSeek to take to the first line
    // to start with.
    //
    switch ( SeekBit ) {
    case SCEJET_SEEK_EQ:
        grbit = JET_bitSeekEQ;
        break;
    case SCEJET_SEEK_GT:
        if ( LinePrefix != NULL && PrefixLength > 247 )
            grbit = JET_bitSeekGE;
        else
            grbit = JET_bitSeekGT;
        break;
    default:
        grbit = JET_bitSeekGE;
    }
    JetErr = JetSeek(
                hSection->JetSessionID,
                hSection->JetTableID,
                grbit
                );

    if ( JetErr == JET_errSuccess ||
         JetErr == JET_wrnSeekNotEqual ) {

        if ( LinePrefix != NULL && PrefixLength > 247 ) {
            //
            // info is truncated
            // The current record may be before the actual one
            //
            do {
                //
                // check the current record
                //
                JetErr = SceJetpCompareLine(
                                hSection,
                                grbit,
                                LinePrefix,
                                PrefixLength,
                                &Result,
                                &Actual
                                );
                if ( JetErr == JET_errSuccess &&
                    ( Result < 0 || (Result == 0 && SeekBit == SCEJET_SEEK_GT) )) {
                    //
                    // current record's data is less than the prefix, move to next
                    //
                    JetErr = JetMove(hSection->JetSessionID,
                                     hSection->JetTableID,
                                     JET_MoveNext,
                                     0
                                     );
                    if ( JetErr == JET_errNoCurrentRecord )
                        JetErr = JET_errRecordNotFound;
                }
            } while ( JetErr == JET_errSuccess &&
                      ( (Result < 0 && SeekBit != SCEJET_SEEK_EQ) ||
                        (Result == 0 && SeekBit == SCEJET_SEEK_GT) ) );

            if ( SeekBit == SCEJET_SEEK_EQ && JetErr == JET_errSuccess &&
                 Result == 0 && Actual > PrefixLength ) {
                //
                // no exact match
                //
                return(JET_errRecordNotFound);

            } // for SEEK_GE check, see below

        } else {
            //
            // Prefix is not overlimit. Check the current record only.
            //
            if (SeekBit != SCEJET_SEEK_EQ)
                JetErr = SceJetpCompareLine(
                        hSection,
                        grbit,
                        LinePrefix,
                        PrefixLength,
                        &Result,
                        0
                        );
        }

        if ( JetErr == JET_errSuccess && Result > 0 ) {
            if ( SeekBit == SCEJET_SEEK_EQ ) {
                //
                // Prefix is less than the current line, which is OK if for SEEK_GE and SEEK_GT
                //
                return(JET_errRecordNotFound);

            } else if ( SeekBit == SCEJET_SEEK_GE && LinePrefix && PrefixLength && !bOkNoMatch ) {
                //
                return(JET_errRecordNotFound);
            }
        }

    }

    return(JetErr);
}


JET_ERR
SceJetpCompareLine(
    IN PSCESECTION   hSection,
    IN JET_GRBIT    grbit,
    IN PWSTR        LinePrefix OPTIONAL,
    IN DWORD        PrefixLength,
    OUT INT         *Result,
    OUT DWORD       *ActualLength OPTIONAL
    )
/* ++
Routine Description:

    This routine comapre the current line with the SectionID in the section
    handle and name column with LinePrefix if LinePrefix is not NULL. The
    purpose of this routine is to see if the cursor is still on a record
    which has the same sectionID and prefix.

    The comparsion result is output from Result. If JET_errSuccess returns
    and Result < 0, the current record is BEFORE the prefix; If Result = 0,
    the current record has the same key with prefix; If Result > 0, the
    current record is AFTER the prefix. If no more record is available to
    be compared, JET_errRecordNotFound returns. Any other error occurs inside
    the routine is returned.

Arguments:

    hSection    - the section handle

    LinePrefix  - The prefix to match

    PrefixLength - The number of BYTES in LinePrefix

Return Value:

    JET_errSuccess
    JET_errRecordNotFound
    JET_errOutOfMemory
    JET_ERR returned from JetRetrieveColumn

-- */
{
    JET_ERR     JetErr;
    DOUBLE      SectionID;
    DWORD       Actual;
    JET_RETINFO RetInfo;
    PWSTR       Buffer=NULL;

//    *Result = 0;
//    return(JET_errSuccess);
    //
    // Compare the section first
    //
    JetErr = JetRetrieveColumn(
                hSection->JetSessionID,
                hSection->JetTableID,
                hSection->JetColumnSectionID,
                (void *)&SectionID,
                8,
                &Actual,
                0,
                NULL
                );
    if ( JetErr == JET_errNoCurrentRecord )
        return(JET_errRecordNotFound);

    else if ( JetErr != JET_errSuccess )
        return(JetErr);

    if ( hSection->SectionID < SectionID ) {
        *Result = 1;
//        if ( grbit != JET_bitSeekGT )
            return(JET_errRecordNotFound);

    } else if ( hSection->SectionID == SectionID )
        *Result = 0;
    else
        *Result = -1;

    if ( *Result != 0 || grbit == JET_bitSeekGT )
        return(JetErr);

    //
    // check Name column
    //
    if ( LinePrefix != NULL && PrefixLength > 0 ) {
        RetInfo.ibLongValue = 0;
        RetInfo.cbStruct = sizeof(JET_RETINFO);
        RetInfo.itagSequence = 1;

        Buffer = (PWSTR)LocalAlloc(LMEM_ZEROINIT, PrefixLength+2);
        if ( Buffer == NULL )
            return(JET_errOutOfMemory);

        JetErr = JetRetrieveColumn(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->JetColumnNameID,
                    (void *)Buffer,
                    PrefixLength,
                    &Actual,
                    0,
                    &RetInfo
                    );

        if ( JetErr == JET_errNoCurrentRecord )
            JetErr = JET_errRecordNotFound;

        if ( JetErr != JET_errSuccess &&
             JetErr != JET_wrnBufferTruncated ) {

            if ( JetErr > 0 ) {
                // warnings, do not return equal
                JetErr = JET_errSuccess;
                *Result = 1;
            }
            LocalFree(Buffer);
            return(JetErr);
        }

        JetErr = JET_errSuccess;

        //
        // Compare the first PrefixLength bytes.
        //
        *Result = _wcsnicmp(Buffer,
                           LinePrefix,
                           PrefixLength/sizeof(WCHAR));
//printf("Compare %ws to %ws for Length %d: Result=%d\n", Buffer, LinePrefix, PrefixLength/2, *Result);
        LocalFree(Buffer);

        if ( ActualLength != NULL )
            *ActualLength = Actual;
    }

    return(JetErr);
}


JET_ERR
SceJetpMakeKey(
    IN JET_SESID SessionID,
    IN JET_TABLEID TableID,
    IN DOUBLE SectionID,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength
    )
/* ++
Routine Description:

    This routine constructs a normalized key value for Seek. It constructs
    the section name in the section context first. Then the LinePrefix is
    added if it is not NULL.

    The scp, sap and smp tables all have one index which is Section+Name.

Arguments:

    SessionID   - the Jet session ID

    TableID     - The Jet table ID to work in

    SectionID   - The ID in column "SectionID"

    LinePrefix  - The prefix for fields to start with

    PrefixLength- The length of the prefix in BYTES

Return Value:

    JET_ERR from JetMakeKey
-- */
{
    JET_ERR         JetErr;
    JET_GRBIT       grbit;


    if ( LinePrefix == NULL ) {
        grbit = JET_bitNewKey; // | JET_bitStrLimit;  having StrLimit set takes you to the next key
    } else {
        grbit = JET_bitNewKey;
    }

    //
    // Add section ID to the key
    //
    JetErr = JetMakeKey(
                SessionID,
                TableID,
                (VOID *)(&SectionID),
                8,
                grbit
                );

    if ( JetErr != JET_errSuccess )
        return(JetErr);

    //
    // add prefix to the key if it is not NULL
    //
    if ( LinePrefix != NULL ) {
        JetErr = JetMakeKey(
                    SessionID,
                    TableID,
                    (VOID *)LinePrefix,
                    PrefixLength,
                    JET_bitSubStrLimit
                    );
    }

    if ( JetErr == JET_errKeyIsMade ) {
        //
        // When 2 keys are provided, it may return this code, even on success.
        //
        JetErr = JET_errSuccess;
    }

    return(JetErr);

}


JET_ERR
SceJetpBuildUpperLimit(
    IN PSCESECTION hSection,
    IN PWSTR      LinePrefix,
    IN DWORD      Len,
    IN BOOL       bReserveCase
    )
/* ++
Function Descripton:

    This routine builts an upper index range based on a section and an
    optional prefix. If prefix is NULL, the upper limit is the next
    available sectionID. If prefix is not NULL, the upper limit is the
    last character 's next character in the key.

    For example, if prefix is a\b\c\d\e\f\g, the upper limit is then
    a\b\c\d\e\f\h. If prefix is over 247 (index limit), e.g.,

    aaa...\b..\c...\d...\e...\f\x\t\y\z

                              ^
                              |
                            the 247th byte.
    then the upper limit is built to aaa...\b..\c...\d...\e...\g

Arguments:

    hSection    - The seciton's handle

    LinePrefix  - The prefix

    Len         - The number of bytes in the prefix

Return Value:

    JET_ERR from SceJetpMakeKey, JetSetIndexRange

-- */
{
    JET_ERR     JetErr;
    DWORD       indx;
    WCHAR       UpperLimit[128];


    if ( Len == 0 ) {
        // no prefix. The upper limit is the next available section ID
        JetErr = SceJetpMakeKey(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->SectionID+(DOUBLE)1,
                    NULL,
                    0
                    );

    } else {

        memset(UpperLimit, 0, 128*sizeof(WCHAR));

        if ( Len < 247 )
            // prefix is not overlimit.
            // The upper limit is the last character + 1
            indx = Len / sizeof(WCHAR);
        else
            // prefix is overlimit (247)
            // built range on 247 bytes
            indx = 123;

        wcsncpy(UpperLimit, LinePrefix, indx);
        UpperLimit[indx] = L'\0';

        if ( !bReserveCase ) {
            _wcslwr(UpperLimit);
        }
        UpperLimit[indx-1] = (WCHAR) (UpperLimit[indx-1] + 1);

        JetErr = SceJetpMakeKey(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->SectionID,
                    UpperLimit,
                    Len
                    );
    }

    if ( JetErr != JET_errSuccess )
        return(JetErr);

    //
    // set upper limit
    //
    JetErr = JetSetIndexRange(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    JET_bitRangeUpperLimit //| JET_bitRangeInclusive
                    );

    return(JetErr);
}


SCESTATUS
SceJetJetErrorToSceStatus(
    IN JET_ERR  JetErr
    )
/* ++
Routine Description:

    This routine converts error returned from Jet engine (JET_ERR) to SCESTATUS.

Arguments:

    JetErr  - The error returned from Jet engine

Return Value:

    All available SCESTATUS error codes

-- */
{
    SCESTATUS rc;

    switch ( JetErr ) {
    case JET_errSuccess:
    case JET_wrnSeekNotEqual:
    case JET_wrnNoErrorInfo:
    case JET_wrnColumnNull:
    case JET_wrnColumnSetNull:
    case JET_wrnTableEmpty:
    case JET_errAlreadyInitialized:

        rc = SCESTATUS_SUCCESS;
        break;

    case JET_errDatabaseInvalidName:

        rc = SCESTATUS_INVALID_PARAMETER;
        break;

    case JET_errNoCurrentRecord:
    case JET_errRecordNotFound:

        rc = SCESTATUS_RECORD_NOT_FOUND;
        break;

    case JET_errColumnDoesNotFit:
    case JET_errColumnTooBig:

        rc = SCESTATUS_INVALID_DATA;
        break;

    case JET_errDatabaseDuplicate:
    case JET_errTableDuplicate:
    case JET_errColumnDuplicate:
    case JET_errIndexDuplicate:
    case JET_errKeyDuplicate:

        rc = SCESTATUS_OBJECT_EXIST;
        break;

    case JET_wrnBufferTruncated:

        rc = SCESTATUS_BUFFER_TOO_SMALL;
        break;

    case JET_errFileNotFound:
    case JET_errDatabaseNotFound:

        rc = SCESTATUS_PROFILE_NOT_FOUND;
        break;

    case JET_errObjectNotFound:
    case JET_errIndexNotFound:
    case JET_errColumnNotFound:
    case JET_errDatabaseCorrupted:

        rc = SCESTATUS_BAD_FORMAT;
        break;

    case JET_errTooManyOpenDatabases:
    case JET_errTooManyOpenTables:
    case JET_errDiskFull:
    case JET_errOutOfMemory:
    case JET_errVersionStoreOutOfMemory:

        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        break;

    case JET_errPermissionDenied:
    case JET_errFileAccessDenied:
    case JET_errTableInUse:
    case JET_errTableLocked:
    case JET_errWriteConflict:

        rc = SCESTATUS_ACCESS_DENIED;
        break;

    case JET_errFeatureNotAvailable:
    case JET_errQueryNotSupported:
    case JET_errSQLLinkNotSupported:
    case JET_errLinkNotSupported:
    case JET_errIllegalOperation:

        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
        break;

    default:
//printf("JetErr=%d\n", JetErr);
        rc = SCESTATUS_OTHER_ERROR;
        break;
    }
    return(rc);
}



SCESTATUS
SceJetpGetAvailableSectionID(
    IN PSCECONTEXT cxtProfile,
    OUT DOUBLE *SectionID
    )
/* ++
Routine Description:


Arguments:

    cxtProfile  - The profile context handle

    SectionID   - The output section ID


Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;


    if ( cxtProfile == NULL || SectionID == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( cxtProfile->JetTblSecID <= 0) {
        //
        // Section table is not opened yet
        //
        rc = SceJetOpenTable(
                        cxtProfile,
                        "SmTblSection",
                        SCEJET_TABLE_SECTION,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    *SectionID = (DOUBLE)0;

    //
    // set current index to SecID (the ID)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                "SecID"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // Move to the last record
    //
    JetErr = JetMove(
                  cxtProfile->JetSessionID,
                  cxtProfile->JetTblSecID,
                  JET_MoveLast,
                  0
                  );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // find the section ID, retrieve column Name
        //
        JetErr = JetRetrieveColumn(
                    cxtProfile->JetSessionID,
                    cxtProfile->JetTblSecID,
                    cxtProfile->JetSecID,
                    (void *)SectionID,
                    8,
                    &Actual,
                    0,
                    NULL
                    );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // The next available ID is current ID + 1
            //
            *SectionID = *SectionID + (DOUBLE)1;
        }
    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        *SectionID = (DOUBLE)1;
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);

}


SCESTATUS
SceJetpAddAllSections(
    IN PSCECONTEXT cxtProfile
    )
/* ++
Routine Description:

    This routine adds all pre-defined sections into the section table.
    This routine is used when creating the section table.

Arguments:

    cxtProfile - The profile context

Return Value:

    SCESTATUS from SceJetAddSection

-- */
{
    SCESTATUS rc;
    DOUBLE SectionID;


    rc = SceJetAddSection(
        cxtProfile,
        szSystemAccess,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szPrivilegeRights,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szGroupMembership,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAccountProfiles,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szRegistryKeys,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szFileSecurity,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szDSSecurity,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAuditSystemLog,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAuditSecurityLog,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAuditApplicationLog,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szAuditEvent,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szUserList,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szKerberosPolicy,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szServiceGeneral,
        &SectionID
        );
    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    rc = SceJetAddSection(
        cxtProfile,
        szRegistryValues,
        &SectionID
        );

    return(rc);
}


SCESTATUS
SceJetpConfigJetSystem(
    IN JET_INSTANCE *hinstance
    )
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    DWORD    Win32rc;
    JET_ERR  JetErr;

    DWORD    Len;
    PWSTR SysRoot=NULL;

    PWSTR ProfileLocation=NULL;
    CHAR FileName[512];

    PSECURITY_DESCRIPTOR pSD=NULL;
    SECURITY_INFORMATION SeInfo;
    DWORD SDsize;

    //
    // the default Jet working directory is always in %SystemRoot%\security
    // no matter who is logged on.
    // this way allows one jet working directory
    //
    Len =  0;
    Win32rc = ScepGetNTDirectory( &SysRoot, &Len, SCE_FLAG_WINDOWS_DIR );

    if ( Win32rc == NO_ERROR ) {

        if ( SysRoot != NULL ) {
            Len += 9;  // profile location

            ProfileLocation = (PWSTR)ScepAlloc( 0, (Len+1)*sizeof(WCHAR));

            if ( ProfileLocation == NULL ) {

                Win32rc = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                swprintf(ProfileLocation, L"%s\\Security", SysRoot );
                ProfileLocation[Len] = L'\0';
            }

            ScepFree(SysRoot);

        } else
            Win32rc = ERROR_INVALID_DATA;
    }

    if ( Win32rc == NO_ERROR ) {

#ifdef SCEJET_DBG
    wprintf(L"Default location: %s\n", ProfileLocation);
#endif
        //
        // convert WCHAR into ANSI
        //
        memset(FileName, '\0', 512);
        Win32rc = RtlNtStatusToDosError(
                      RtlUnicodeToMultiByteN(
                            (PCHAR)FileName,
                            512,
                            NULL,
                            ProfileLocation,
                            Len*sizeof(WCHAR)
                            ));

        if ( Win32rc == NO_ERROR ) {
            //
            // a backslash is required by Jet
            //
            strcat(FileName, "\\");

            //
            // set everyone change, admin full control to the directory
            // the directory is created in the function.
            //
            Win32rc = ConvertTextSecurityDescriptor (
                            L"D:P(A;CIOI;GRGW;;;WD)(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)",
                            &pSD,
                            &SDsize,
                            &SeInfo
                            );
            if ( Win32rc == NO_ERROR ) {

                ScepChangeAclRevision(pSD, ACL_REVISION);

                rc = ScepCreateDirectory(
                            ProfileLocation,
                            TRUE,      // a dir name
                            pSD        // take parent's security setting
                            );
#ifdef SCEJET_DBG
    if ( rc != SCESTATUS_SUCCESS )
        wprintf(L"Cannot create directory %s\n", ProfileLocation );
#endif

                if ( rc == SCESTATUS_SUCCESS ) {

                    __try {

                        JetErr = JetSetSystemParameter( hinstance, 0, JET_paramSystemPath, 0, (const char *)FileName );

                        rc = SceJetJetErrorToSceStatus(JetErr);

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        //
                        // esent is not loaded
                        //
                        rc = SCESTATUS_MOD_NOT_FOUND;
                    }
                }

                if ( rc == SCESTATUS_SUCCESS ) {

                    JetErr = JetSetSystemParameter( hinstance, 0, JET_paramTempPath, 0, (const char *)FileName );

                    if ( JetErr == JET_errSuccess ) {
                        JetErr = JetSetSystemParameter( hinstance, 0, JET_paramLogFilePath, 0, (const char *)FileName );

                        if ( JetErr == JET_errSuccess ) {
                            JetErr = JetSetSystemParameter( hinstance, 0, JET_paramDatabasePageSize, 4096, NULL );
                        }
                    }

                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // set log size to 1M
                        //
                        JetSetSystemParameter( hinstance, 0, JET_paramLogFileSize, 1024, NULL );
                        //
                        // defer the event log to when event log service is available
                        // (for example, in NT setup, there is no event log)
                        //
                        JetSetSystemParameter( hinstance, 0, JET_paramEventLogCache, 128, NULL );

                        JetSetSystemParameter( hinstance, 0, JET_paramMaxVerPages, 128, NULL );

                        //
                        // set minimize = maximum cache size to disable DBA in jet
                        // recommended setting for minimum is 4 * number of sessions
                        // maximum is up to the app (for performance)
                        //

                        JetSetSystemParameter( hinstance, 0, JET_paramMaxSessions, 64, NULL );

                        //
                        // performance is about 10% faster when using cache size 512 than 256
                        //

                        JetSetSystemParameter( hinstance, 0, JET_paramStartFlushThreshold, 50, NULL ); // sugguested by Exchange
                        JetSetSystemParameter( hinstance, 0, JET_paramStopFlushThreshold, 100, NULL ); // suggested by Exchange

                        //
                        // can't set to 512 because that's Jet's default value
                        // jet won't turn off DBA if value is set to 512.
                        //
                        JetSetSystemParameter( hinstance, 0, JET_paramCacheSizeMax, 496, NULL );  //256

                        JetSetSystemParameter( hinstance, 0, JET_paramCacheSizeMin, 496, NULL );  //256

                        //
                        // other system parameters, such as memory size in beta2
                        //
                        JetErr = JetSetSystemParameter( hinstance, 0, JET_paramCircularLog, 1, NULL );

                        JetErr = JetSetSystemParameter( hinstance, 0, JET_paramNoInformationEvent, 1, NULL );

                    }
                }

                ScepFree(pSD);

            }
        }

        ScepFree(ProfileLocation);
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = ScepDosErrorToSceStatus(Win32rc);
    }

    return(rc);
}



SCESTATUS
SceJetGetTimeStamp(
    IN PSCECONTEXT   cxtProfile,
    OUT PLARGE_INTEGER ConfigTimeStamp,
    OUT PLARGE_INTEGER AnalyzeTimeStamp
    )
/* ++
Routine Description:

    This routine queries the time stamp of last analysis.

    The time stamp is saved in the "SmTblVersion" table.

Arguments:

    cxtProfile  - The profile context

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR
    SCESTATUS from SceJetOpenTable

-- */
{
    SCESTATUS        rc=SCESTATUS_SUCCESS;
    DWORD           RetLen = 0;

    if (cxtProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // Open version table
    //
    if ( ConfigTimeStamp != NULL ) {

        rc = SceJetpGetValueFromVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "ConfigTimeStamp",
                    (CHAR*)ConfigTimeStamp, //TimeStamp,
                    8,  // 16, // number of bytes
                    &RetLen
                    );
        if ( rc == SCESTATUS_SUCCESS ||
             rc == SCESTATUS_BUFFER_TOO_SMALL )
            rc = SCESTATUS_SUCCESS;

        if ( RetLen < 8 ) {
            (*ConfigTimeStamp).LowPart = 0;
            (*ConfigTimeStamp).HighPart = 0;
        }
    }

    if ( AnalyzeTimeStamp != NULL ) {

        rc |= SceJetpGetValueFromVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "AnalyzeTimeStamp",
                    (CHAR*)AnalyzeTimeStamp, //TimeStamp,
                    8,  // 16, // number of bytes
                    &RetLen
                    );

        if ( rc == SCESTATUS_SUCCESS ||
             rc == SCESTATUS_BUFFER_TOO_SMALL )
            rc = SCESTATUS_SUCCESS;

        if ( RetLen < 8 ) {
            (*AnalyzeTimeStamp).LowPart = 0;
            (*AnalyzeTimeStamp).HighPart = 0;
        }
    }

    return(rc);
}



SCESTATUS
SceJetSetTimeStamp(
    IN PSCECONTEXT   cxtProfile,
    IN BOOL        Flag,
    IN LARGE_INTEGER NewTimeStamp
    )
/* ++
Routine Description:

    This routine sets the time stamp (LARGE_INTEGER) of a analysis.

    The time stamp is saved in the "SmTblVersion" table.

Arguments:

    cxtProfile  - The profile context

    Flag        - indicates analyze or configure
                    Flag = TRUE - AnalyzeTimeStamp
                    Flag = FALSE - ConfigTimeStamp

    NewTimeStamp - the new time stamp of a analysis

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR
    SCESTATUS from SceJetOpenTable

-- */
{
    SCESTATUS        rc;

#ifdef SCE_JETDBG
    CHAR            CharTimeStamp[17];

    sprintf(CharTimeStamp, "%08x%08x", NewTimeStamp.HighPart, NewTimeStamp.LowPart);
    CharTimeStamp[16] = '\0';

    printf("New time stamp is %s\n", CharTimeStamp);
#endif

    if ( cxtProfile == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // set
    //
    if ( Flag ) {

        rc = SceJetSetValueInVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "AnalyzeTimeStamp",
                    (PWSTR)(&NewTimeStamp), //(PWSTR)CharTimeStamp,
                    8, // 16, // number of bytes
                    JET_prepReplace
                    );
    } else {

        rc = SceJetSetValueInVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "ConfigTimeStamp",
                    (PWSTR)(&NewTimeStamp), //(PWSTR)CharTimeStamp,
                    8, // 16, // number of bytes
                    JET_prepReplace
                    );
    }
    return(rc);
}


SCESTATUS
SceJetGetDescription(
    IN PSCECONTEXT   cxtProfile,
    OUT PWSTR *Description
    )
/* ++
Routine Description:

    This routine queries the profile description from the "SmTblVersion" table.

Arguments:

    cxtProfile  - The profile context

    Description - The description buffer

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR
    SCESTATUS from SceJetOpenTable

-- */
{
    SCESTATUS        rc;
    DWORD           RetLen = 0;

    if ( cxtProfile == NULL || Description == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // Open version table
    //
    rc = SceJetpGetValueFromVersion(
                cxtProfile,
                "SmTblVersion",
                "ProfileDescription",
                NULL,
                0, // number of bytes
                &RetLen
                );

    if ( rc == SCESTATUS_BUFFER_TOO_SMALL ) {

        *Description = (PWSTR)ScepAlloc( LPTR, RetLen+2 );

        if ( *Description == NULL )
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        rc = SceJetpGetValueFromVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "ProfileDescription",
                    (LPSTR)(*Description),
                    RetLen, // number of bytes
                    &RetLen
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepFree( *Description );
            *Description = NULL;
        }
    }

    return(rc);
}


SCESTATUS
SceJetpGetValueFromVersion(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TableName,
    IN LPSTR ColumnName,
    OUT LPSTR Value OPTIONAL,
    IN DWORD  ValueLen, // number of bytes
    OUT PDWORD pRetLen
    )
{
    SCESTATUS   rc;
    JET_TABLEID     TableID;
    JET_ERR         JetErr;
    JET_COLUMNDEF   ColumnDef;

    //
    // Open version table
    //
    rc = SceJetOpenTable(
                    cxtProfile,
                    TableName,
                    SCEJET_TABLE_VERSION,
                    SCEJET_OPEN_READ_ONLY,
                    &TableID
                    );
    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // go to the first record
        //
        JetErr = JetMove(cxtProfile->JetSessionID,
                         TableID,
                         JET_MoveFirst,
                         0
                         );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS) {
            //
            // get column ID for "Version"
            //
            JetErr = JetGetTableColumnInfo(
                            cxtProfile->JetSessionID,
                            TableID,
                            ColumnName,
                            (VOID *)&ColumnDef,
                            sizeof(JET_COLUMNDEF),
                            0
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // retrieve the column
                //
                JetErr = JetRetrieveColumn(
                                cxtProfile->JetSessionID,
                                TableID,
                                ColumnDef.columnid,
                                (void *)Value,
                                ValueLen,
                                pRetLen,
                                0,
                                NULL
                                );
                rc = SceJetJetErrorToSceStatus(JetErr);
            }
        }
        JetCloseTable(cxtProfile->JetSessionID, TableID);
    }

    return(rc);

}


SCESTATUS
SceJetSetValueInVersion(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TableName,
    IN LPSTR ColumnName,
    IN PWSTR Value,
    IN DWORD ValueLen, // number of bytes
    IN DWORD Prep
    )
{
    SCESTATUS   rc;
    DWORD      Len;
    JET_TABLEID     TableID;
    JET_ERR         JetErr;
    JET_COLUMNDEF   ColumnDef;


    if ( cxtProfile == NULL || TableName == NULL || ColumnName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // Open version table
    //
    rc = SceJetOpenTable(
                    cxtProfile,
                    TableName,
                    SCEJET_TABLE_VERSION,
                    SCEJET_OPEN_READ_WRITE, // read and write
                    &TableID
                    );
    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // go to the first record
        //
        JetErr = JetMove(cxtProfile->JetSessionID,
                         TableID,
                         JET_MoveFirst,
                         0
                         );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS) {
            //
            // get column ID for "Version"
            //
            JetErr = JetGetTableColumnInfo(
                            cxtProfile->JetSessionID,
                            TableID,
                            ColumnName,
                            (VOID *)&ColumnDef,
                            sizeof(JET_COLUMNDEF),
                            0
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {

                JetErr = JetPrepareUpdate(cxtProfile->JetSessionID,
                                          TableID,
                                          Prep
                                          );
                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // set value
                    //

                    JetErr = JetSetColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)Value,
                                    ValueLen,
                                    0, //JET_bitSetOverwriteLV,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( rc != SCESTATUS_SUCCESS ) {
                        //
                        // if setting fails, cancel the prepared record
                        //
                        JetPrepareUpdate( cxtProfile->JetSessionID,
                                          TableID,
                                          JET_prepCancel
                                          );
                    } else {

                        //
                        // Setting columns succeed. Update the record
                        //
                        JetErr = JetUpdate( cxtProfile->JetSessionID,
                                           TableID,
                                           NULL,
                                           0,
                                           &Len
                                           );
                        rc = SceJetJetErrorToSceStatus(JetErr);
                    }
                }
            }
        }
        JetCloseTable(cxtProfile->JetSessionID, TableID);
    }

    return(rc);
}


SCESTATUS
SceJetSeek(
    IN PSCESECTION hSection,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength,
    IN SCEJET_SEEK_FLAG SeekBit
    )
{
    PWSTR LwrPrefix=NULL;
    SCESTATUS rc;
    SCEJET_SEEK_FLAG NewSeekBit;

    if ( hSection == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( LinePrefix != NULL && SeekBit > SCEJET_SEEK_GE ) {
        //
        // do lowercase search
        //
        LwrPrefix = (PWSTR)ScepAlloc(0, PrefixLength+sizeof(WCHAR));

        if ( LwrPrefix == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);

        } else {
            wcscpy(LwrPrefix, LinePrefix);
            LwrPrefix = _wcslwr(LwrPrefix);

            switch ( SeekBit ) {
            case SCEJET_SEEK_GT_NO_CASE:
                NewSeekBit = SCEJET_SEEK_GT;
                break;
            case SCEJET_SEEK_EQ_NO_CASE:
                NewSeekBit = SCEJET_SEEK_EQ;
                break;
            default:
                NewSeekBit = SCEJET_SEEK_GE;
                break;
            }

            rc = SceJetJetErrorToSceStatus(
                        SceJetpSeek(
                                    hSection,
                                    LwrPrefix,
                                    PrefixLength,
                                    NewSeekBit,
                                    (SeekBit == SCEJET_SEEK_GE_DONT_CARE)
                                    ));
            ScepFree(LwrPrefix);
        }
    } else {
        //
        // do case sensitive search, or NULL search
        //
        rc = SceJetJetErrorToSceStatus(
                    SceJetpSeek(
                                hSection,
                                LinePrefix,
                                PrefixLength,
                                SeekBit,
                                FALSE
                                ));
    }

    return(rc);

}

SCESTATUS
SceJetMoveNext(
    IN PSCESECTION hSection
    )
{
    JET_ERR  JetErr;
    INT      Result;

    if ( hSection == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // skip deleted records
    //
    do {
        JetErr = JetMove(hSection->JetSessionID,
                         hSection->JetTableID,
                         JET_MoveNext,
                         0
                         );
        if ( JetErr == JET_errSuccess ) {
            // compare section ID
            JetErr = SceJetpCompareLine(
                hSection,
                JET_bitSeekGE,
                NULL,
                0,
                &Result,
                NULL
                );
            if ( JetErr == JET_errSuccess && Result != 0 )
                JetErr = JET_errRecordNotFound;

        }

    } while ( JetErr == JET_errRecordDeleted );


    return(SceJetJetErrorToSceStatus(JetErr));

}

/*

SCESTATUS
SceJetRenameLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN PWSTR      NewName,
    IN BOOL       bReserveCase
    )
{
    PWSTR       LwrName=NULL;
    DWORD       Len;
    JET_ERR     JetErr;
    JET_SETINFO SetInfo;


    if ( !hSection || !Name || !NewName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    Len = wcslen(NewName)*sizeof(WCHAR);

    if ( Len <= 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( bReserveCase ) {
        LwrName = NewName;

    } else {
        //
        // lower cased
        //
        LwrName = (PWSTR)ScepAlloc(0, Len+2);
        if ( LwrName == NULL ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
        wcscpy(LwrName, NewName);
        LwrName = _wcslwr(LwrName);

    }

    SetInfo.cbStruct = sizeof(JET_SETINFO);
    SetInfo.itagSequence = 1;
    SetInfo.ibLongValue = 0;

    //
    // check to see if the same key name already exists
    //
    JetErr = SceJetSeek(
                    hSection,
                    Name,
                    wcslen(Name)*sizeof(WCHAR),
                    SCEJET_SEEK_EQ_NO_CASE
                    );

    if ( JetErr == JET_errSuccess ) {
        //
        // find a match. overwrite the value
        //
        JetErr = JetBeginTransaction(hSection->JetSessionID);

        if ( JetErr == JET_errSuccess ) {
            JetErr = JetPrepareUpdate(hSection->JetSessionID,
                                      hSection->JetTableID,
                                      JET_prepReplace
                                      );
            if ( JetErr == JET_errSuccess ) {
                //
                // set the new key in "Name" column
                //
                JetErr = JetSetColumn(
                                hSection->JetSessionID,
                                hSection->JetTableID,
                                hSection->JetColumnNameID,
                                (void *)LwrName,
                                Len,
                                JET_bitSetOverwriteLV,
                                &SetInfo
                                );
            }

            if ( JET_errSuccess == JetErr ) {
                //
                // commit the transaction
                //
                JetCommitTransaction(hSection->JetSessionID, JET_bitCommitLazyFlush);
            } else {
                //
                // rollback the transaction
                //
                JetRollback(hSection->JetSessionID,0);
            }
            JetPrepareUpdate(hSection->JetSessionID,
                              hSection->JetTableID,
                              JET_prepCancel
                              );
        }
    }

    if ( LwrName != NewName ) {
        ScepFree(LwrName);
    }

    return( SceJetJetErrorToSceStatus(JetErr) );
}
*/



SCESTATUS
SceJetRenameLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN PWSTR      NewName,
    IN BOOL       bReserveCase
    )
{
    PWSTR       Value=NULL;
    DWORD       ValueLen;
    SCESTATUS   rc;
    JET_ERR     JetErr;


    if ( !hSection || !Name || !NewName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                Name,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( SCESTATUS_SUCCESS == rc ) {
        //
        // continue only when this record is found.
        //
        if ( ValueLen ) {
            Value = (PWSTR)ScepAlloc(0, ValueLen+2);

            if ( Value ) {
                rc = SceJetGetValue(
                            hSection,
                            SCEJET_CURRENT,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            Value,
                            ValueLen,
                            &ValueLen
                            );
            } else
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }

        if ( SCESTATUS_SUCCESS == rc ) {

            JetErr = JetBeginTransaction(hSection->JetSessionID);

            if ( JetErr == JET_errSuccess ) {
                //
                // now delete this line
                //
                rc = SceJetDelete(hSection, NULL, FALSE, SCEJET_DELETE_LINE);

                if ( SCESTATUS_SUCCESS == rc ) {
                    //
                    // add the new line in.
                    //
                    rc = SceJetSetLine(
                            hSection,
                            NewName,
                            bReserveCase,
                            Value,
                            ValueLen,
                            0
                            );
                }

                if ( SCESTATUS_SUCCESS == rc ) {
                    //
                    // commit the transaction
                    //
                    JetCommitTransaction(hSection->JetSessionID, JET_bitCommitLazyFlush);
                } else {
                    //
                    // rollback the transaction
                    //
                    JetRollback(hSection->JetSessionID,0);
                }
            } else
                rc = SceJetJetErrorToSceStatus(JetErr);

        }
    }

    return( rc );
}

//////////////////////////////////////////////////////////////
//
//  Helpers
//
//////////////////////////////////////////////////////////////

VOID
SceJetInitializeData()
//
// only be called during server initialization code
//
{
   JetInited = FALSE;
   JetInstance = 0;
}

SCESTATUS
SceJetInitialize(
    OUT JET_ERR *pJetErr OPTIONAL
    )
/*
Routine Description:

    Initialize jet engine for sce server

Arguments:

    None

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc=SCESTATUS_SUCCESS;
    JET_ERR JetErr=0;

    //
    // cancel any pending timer queue
    //
    ScepServerCancelTimer();

    EnterCriticalSection(&JetSync);

    if ( !JetInited ) {

        //
        // set system configuration for Jet engine
        //
        rc = SceJetpConfigJetSystem( &JetInstance);
        if ( SCESTATUS_SUCCESS == rc ) {

            //
            // initialize jet engine
            //
            __try {

                JetErr = JetInit(&JetInstance);

                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( JetErr == JET_errSuccess ) {

                    JetInited = TRUE;

                    //
                    // if failed to initialize Jet writer (for backup/restore)
                    // don't fail the engine
                    //
                } else {

                    //
                    // this will happen only if jet cannot recover the
                    // database by itself (JetInit() claims to attempt recovery only)
                    // repair might help - so only spew out a message advising the user
                    //
                    // map error so setup/policy propagation clients
                    // can log events
                    //

//                    if ( SCE_JET_CORRUPTION_ERROR(JetErr) ) {

                        rc = SCESTATUS_JET_DATABASE_ERROR;

                        ScepLogOutput3(0, ERROR_DATABASE_FAILURE, SCEDLL_ERROR_RECOVER_DB );
//                    }
                    JetInstance = 0;
                }

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // for some reason, esent is not loaded
                //
                rc = SCESTATUS_MOD_NOT_FOUND;
                JetInstance = 0;
            }

        } else {
            JetInstance = 0;
        }
    }

    LeaveCriticalSection(&JetSync);

    if ( pJetErr ) *pJetErr = JetErr;

    return(rc);
}


SCESTATUS
SceJetTerminate(BOOL bCleanVs)
/*
Routine Description:

    Terminate jet engine

Arguments:

    bCleanVs  - if to clean up the version store completely

Return Value:

    SCESTATUS
*/
{

    EnterCriticalSection(&JetSync);

    //
    // destroy the jet backup/restore writer
    //
    if ( JetInited || JetInstance ) {

        if ( bCleanVs ) {
            //
            // clean up version store
            //
            JetTerm2(JetInstance, JET_bitTermComplete);
        } else {
            //
            // do not clean up version store
            //
            JetTerm(JetInstance);
        }
        JetInstance = 0;
        JetInited = FALSE;
    }

    LeaveCriticalSection(&JetSync);

    return(SCESTATUS_SUCCESS);
}

SCESTATUS
SceJetTerminateNoCritical(BOOL bCleanVs)
/*
Routine Description:

    Terminate jet engine, NOT critical sectioned!!!

Arguments:

    bCleanVs  - if to clean up the version store completely

Return Value:

    SCESTATUS
*/
{
    //
    // the critical section is entered outside of this function
    //
    // destroy the jet backup/restore writer
    //
    if ( JetInited || JetInstance ) {

        if ( bCleanVs ) {
            //
            // clean up version store
            //
            JetTerm2(JetInstance, JET_bitTermComplete);
        } else {
            //
            // do not clean up version store
            //
            JetTerm(JetInstance);
        }
        JetInstance = 0;
        JetInited = FALSE;
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceJetStartTransaction(
    IN PSCECONTEXT cxtProfile
    )
/*
Routine Description:

    Start a transaction on the session

Arguments:

    cxtProfile  - the database context

Return Value:

    SCESTATUS
*/
{
    JET_ERR  JetErr;

    if ( cxtProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    JetErr = JetBeginTransaction( cxtProfile->JetSessionID);

    return( SceJetJetErrorToSceStatus(JetErr));

}

SCESTATUS
SceJetCommitTransaction(
    IN PSCECONTEXT cxtProfile,
    IN JET_GRBIT grbit
    )
/*
Routine Description:

    Commit a transaction on the session

Arguments:

    cxtProfile  - the database context

    grbit       - flag for the commission

Return Value:

    SCESTATUS
*/
{
    JET_ERR     JetErr;

    if ( cxtProfile == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    JetErr = JetCommitTransaction(cxtProfile->JetSessionID, grbit );

    return( SceJetJetErrorToSceStatus(JetErr) );

}

SCESTATUS
SceJetRollback(
    IN PSCECONTEXT cxtProfile,
    IN JET_GRBIT grbit
    )
/*
Routine Description:

    Rollback a transaction on the session

Arguments:

    cxtProfile  - the database context

    grbit       - the flag for transaction rollback

Return Value:

    SCESTATUS
*/
{
    JET_ERR     JetErr;

    if ( cxtProfile == NULL )
        return(SCESTATUS_SUCCESS);

    __try {
        JetErr = JetRollback(cxtProfile->JetSessionID, grbit);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        JetErr = JET_errOutOfMemory;
    }
    return( SceJetJetErrorToSceStatus(JetErr) );

}


BOOL
SceJetDeleteJetFiles(
    IN PWSTR DbFileName
    )
{
   TCHAR TempFileName[MAX_PATH];
   PWSTR SysRoot=NULL;
   DWORD SysLen;
   DWORD rc;
   intptr_t            hFile;
   struct _wfinddata_t    fInfo;


   BOOL bRet = FALSE;

   EnterCriticalSection(&JetSync);

   if ( JetInited == FALSE ) {

       SysLen =  0;
       rc = ScepGetNTDirectory( &SysRoot, &SysLen, SCE_FLAG_WINDOWS_DIR );

       if ( rc == NO_ERROR && SysRoot != NULL ) {

           swprintf(TempFileName, L"%s\\Security\\res1.log\0", SysRoot);
           TempFileName[MAX_PATH-1] = L'\0';

           DeleteFile(TempFileName);

           swprintf(TempFileName, L"%s\\Security\\res2.log\0", SysRoot);
           TempFileName[MAX_PATH-1] = L'\0';

           DeleteFile(TempFileName);

           //
           // delete edb files
           //
           swprintf(TempFileName, L"%s\\Security\\edb*.*\0", SysRoot);
           TempFileName[MAX_PATH-1] = L'\0';

           hFile = _wfindfirst(TempFileName, &fInfo);

           if ( hFile != -1 ) {

               do {

                   swprintf(TempFileName, L"%s\\Security\\%s\0", SysRoot, fInfo.name);
                   TempFileName[MAX_PATH-1] = L'\0';

                   DeleteFile(TempFileName);

               } while ( _wfindnext(hFile, &fInfo) == 0 );

               _findclose(hFile);
           }

           //
           // delete temp files
           //
           swprintf(TempFileName, L"%s\\Security\\tmp*.edb\0", SysRoot);
           TempFileName[MAX_PATH-1] = L'\0';

           hFile = _wfindfirst(TempFileName, &fInfo);

           if ( hFile != -1 ) {

               do {

                   swprintf(TempFileName, L"%s\\Security\\%s\0", SysRoot, fInfo.name);
                   TempFileName[MAX_PATH-1] = L'\0';

                   DeleteFile(TempFileName);

               } while ( _wfindnext(hFile, &fInfo) == 0 );

               _findclose(hFile);
           }

           ScepFree(SysRoot);

           //
           // delete the database file if it's passed in.
           //
           if ( DbFileName ) {
               DeleteFile(DbFileName);
           }

           bRet = TRUE;

       }
   }

   LeaveCriticalSection(&JetSync);

   return(bRet);

}


SCESTATUS
SceJetSetCurrentLine(
    IN PSCESECTION hSection,
    IN PWSTR      Value,
    IN DWORD      ValueLen
    )
/* ++
Fucntion Description:

    This routine writes the Value to the current line in section (hSection).
    Make sure the cursor is on the right line before calling this API

Arguments:

    hSection    - The context handle of the section

    Value       - The info set to Column "Value"

    ValueLen    - The size of the value field.

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_OTHER_ERROR
    SCESTATUS_ACCESS_DENIED
    SCESTATUS_DATA_OVERFLOW

-- */
{
    JET_ERR     JetErr;
    DWORD       Len;
    SCESTATUS    rc;
    DWORD       prep;
    JET_SETINFO SetInfo;

    if ( hSection == NULL ||
         Value == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SetInfo.cbStruct = sizeof(JET_SETINFO);
    SetInfo.itagSequence = 1;
    SetInfo.ibLongValue = 0;

    prep = JET_prepReplace;

    JetErr = JetBeginTransaction(hSection->JetSessionID);

    if ( JetErr == JET_errSuccess ) {
        JetErr = JetPrepareUpdate(hSection->JetSessionID,
                                  hSection->JetTableID,
                                  prep
                                  );
        if ( JetErr != JET_errSuccess ) {
            //
            // rollback the transaction
            //
            JetRollback(hSection->JetSessionID,0);
        }
    }

    if ( JetErr != JET_errSuccess)
        return(SceJetJetErrorToSceStatus(JetErr));


    //
    // set value column
    //

    JetErr = JetSetColumn(
                    hSection->JetSessionID,
                    hSection->JetTableID,
                    hSection->JetColumnValueID,
                    (void *)Value,
                    ValueLen,
                    0, //JET_bitSetOverwriteLV,
                    &SetInfo
                    );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( JetErr == JET_errSuccess ) {
        //
        // Setting columns succeed. Update the record
        //
        JetErr = JetUpdate(hSection->JetSessionID,
                           hSection->JetTableID,
                           NULL,
                           0,
                           &Len
                           );
    } else {
        goto CleanUp;
    }

    if ( rc == SCESTATUS_SUCCESS )
        JetCommitTransaction(hSection->JetSessionID, JET_bitCommitLazyFlush);

CleanUp:

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // if setting fails, cancel the prepared record
        //
        JetPrepareUpdate(hSection->JetSessionID,
                          hSection->JetTableID,
                          JET_prepCancel
                          );
        //
        // Rollback the transaction
        //
        JetRollback(hSection->JetSessionID,0);

    }

    return(rc);

}


BOOL
ScepIsValidContext(
    PSCECONTEXT context
    )
{
    if ( context == NULL ) {
        return FALSE;
    }

    __try {

        if ( (context->Type & 0xFFFFFF02L) == 0xFFFFFF02L ) {

            return TRUE;

        } else {

            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        return FALSE;
    }

}


LONG
SceJetGetGpoIDByName(
    IN PSCECONTEXT cxtProfile,
    IN PWSTR       szGpoName,
    IN BOOL        bAdd
    )
/*
Routine Description:

    Search for a GPO by name in the GPO table. If bAdd is TRUE and the GPO name
    is not found, it will be added to the GPO table

Arguments:

    cxtProfile    - the database handle

    szGpoName   - the GPO name

    bAdd        - TRUE to add the GPO name to the GPO table if it's not found

Return Value:

    The GPO ID. If -1 is returned, GetLastError to get the SCE error code.

*/
{


    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;
    PWSTR     LwrName=NULL;
    DWORD     Len;

    if ( cxtProfile == NULL || szGpoName == NULL ||
         szGpoName[0] == L'\0' ) {

        SetLastError(SCESTATUS_INVALID_PARAMETER);
        return (-1);
    }

    JET_TABLEID  TableID;

    rc = SceJetOpenTable(
                    cxtProfile,
                    "SmTblGpo",
                    SCEJET_TABLE_GPO,
                    bAdd ? SCEJET_OPEN_READ_WRITE : SCEJET_OPEN_READ_ONLY,
                    &TableID
                    );

    if ( rc != SCESTATUS_SUCCESS ) {
        SetLastError(rc);
        return(-1);
    }

    JET_COLUMNDEF ColumnDef;
    LONG GpoID = 0;

    JetErr = JetGetTableColumnInfo(
                    cxtProfile->JetSessionID,
                    TableID,
                    "GpoID",
                    (VOID *)&ColumnDef,
                    sizeof(JET_COLUMNDEF),
                    JET_ColInfo
                    );

    if ( JET_errSuccess == JetErr ) {

        //
        // set current index to SectionKey (the name)
        //
        JetErr = JetSetCurrentIndex(
                    cxtProfile->JetSessionID,
                    TableID,
                    "GpoName"
                    );

    }

    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // search for the name
        //
        Len = wcslen(szGpoName);
        LwrName = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));

        if ( LwrName != NULL ) {

            wcscpy(LwrName, szGpoName);
            LwrName = _wcslwr(LwrName);

            JetErr = JetMakeKey(
                        cxtProfile->JetSessionID,
                        TableID,
                        (VOID *)LwrName,
                        Len*sizeof(WCHAR),
                        JET_bitNewKey
                        );

            if ( JetErr == JET_errKeyIsMade ) {
                //
                // Only one key is needed, it may return this code, even on success.
                //
                JetErr = JET_errSuccess;
            }
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {

                JetErr = JetSeek(
                            cxtProfile->JetSessionID,
                            TableID,
                            JET_bitSeekEQ
                            );
                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // find the Gpo name, retrieve gpo id
                    //
                    JetErr = JetRetrieveColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)&GpoID,
                                    4,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);

                } else if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {

                    GpoID = 0;
                    rc = SCESTATUS_SUCCESS;

                    if ( bAdd ) {

                        //
                        // if not found and add is requested
                        //
                        rc = SceJetpAddGpo(cxtProfile,
                                          TableID,
                                          ColumnDef.columnid,
                                          LwrName,
                                          &GpoID
                                         );
                    }

                }

            }

            ScepFree(LwrName);

        } else
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    JetCloseTable( cxtProfile->JetSessionID, TableID );

    if ( rc != SCESTATUS_SUCCESS ) {
        SetLastError(rc);
        GpoID = -1;
    }

    return(GpoID);

}


SCESTATUS
SceJetGetGpoNameByID(
    IN PSCECONTEXT cxtProfile,
    IN LONG GpoID,
    OUT PWSTR Name OPTIONAL,
    IN OUT LPDWORD pNameLen,
    OUT PWSTR DisplayName OPTIONAL,
    IN OUT LPDWORD pDispNameLen
    )
/* ++
Routine Description:

    This routine retrieve the GPO name for the ID in the GPO table.
    If Name is NULL, this routine really does a seek by ID. The cursor will
    be on the record if there is a successful match.

Arguments:

    cxtProfile  - The profile context handle

    GpoID       - The GPO ID looking for

    Name        - The optional output buffer for section name

    pNameLen    - The name buffer's length


Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_RECORD_NOT_FOUND
    SCESTATUS_BAD_FORMAT
    SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;


    if ( cxtProfile == NULL ||
         ( pDispNameLen == NULL && pNameLen == NULL) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( GpoID <= 0 ) {
        return(SCESTATUS_RECORD_NOT_FOUND);
    }

    //
    // reset buffers
    //
    if ( Name == NULL && pNameLen ) {
        *pNameLen = 0;
    }

    if ( DisplayName == NULL && pDispNameLen ) {
        *pDispNameLen = 0;
    }

    JET_TABLEID  TableID=0;

    //
    // Open GPO table
    //
    rc = SceJetOpenTable(
                    cxtProfile,
                    "SmTblGpo",
                    SCEJET_TABLE_GPO,
                    SCEJET_OPEN_READ_ONLY,
                    &TableID
                    );

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // set current index to SecID (the ID)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                TableID,
                "SectionKey"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {

        JetErr = JetMakeKey(
                    cxtProfile->JetSessionID,
                    TableID,
                    (void *)(&GpoID),
                    4,
                    JET_bitNewKey
                    );

        if ( JetErr == JET_errKeyIsMade ) {
            //
            // Only one key is needed, it may return this code, even on success.
            //
            JetErr = JET_errSuccess;
        }
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {

            JetErr = JetSeek(
                        cxtProfile->JetSessionID,
                        TableID,
                        JET_bitSeekEQ
                        );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {

                //
                // find the GPO ID, retrieve column Name if requested
                //

                if ( pNameLen != NULL ) {

                    JET_COLUMNDEF ColumnDef;

                    JetErr = JetGetTableColumnInfo(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    "Name",
                                    (VOID *)&ColumnDef,
                                    sizeof(JET_COLUMNDEF),
                                    JET_ColInfo
                                    );

                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( SCESTATUS_SUCCESS == rc ) {

                        JetErr = JetRetrieveColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)Name,
                                    *pNameLen,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                        *pNameLen = Actual;
                    }

                    rc = SceJetJetErrorToSceStatus(JetErr);
                }

                //
                // retrieve column DisplayName if requested
                //

                if ( ( SCESTATUS_SUCCESS == rc) &&
                     ( pDispNameLen != NULL) ) {

                    JET_COLUMNDEF ColumnDef;

                    JetErr = JetGetTableColumnInfo(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    "DisplayName",
                                    (VOID *)&ColumnDef,
                                    sizeof(JET_COLUMNDEF),
                                    JET_ColInfo
                                    );

                    rc = SceJetJetErrorToSceStatus(JetErr);

                    if ( SCESTATUS_SUCCESS == rc ) {

                        JetErr = JetRetrieveColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)DisplayName,
                                    *pDispNameLen,
                                    &Actual,
                                    0,
                                    NULL
                                    );
                        *pDispNameLen = Actual;
                    }

                    rc = SceJetJetErrorToSceStatus(JetErr);
                }
            }
        }

    }

    JetCloseTable( cxtProfile->JetSessionID, TableID);

    return(rc);

}


SCESTATUS
SceJetpAddGpo(
    IN PSCECONTEXT cxtProfile,
    IN JET_TABLEID TableID,
    IN JET_COLUMNID GpoIDColumnID,
    IN PCWSTR      Name,
    OUT LONG       *pGpoID
    )
/* ++
Routine Description:

Arguments:

Return Value:

-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Len;

    if ( cxtProfile == NULL ||
         Name == NULL ||
        pGpoID == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    *pGpoID = 0;

    //
    // get the next available GPO ID first.
    // set current index to the ID
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                TableID,
                "SectionKey"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // Move to the last record
    //
    JetErr = JetMove(
                  cxtProfile->JetSessionID,
                  TableID,
                  JET_MoveLast,
                  0
                  );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // find the GPO ID, retrieve column Name
        //
        JetErr = JetRetrieveColumn(
                    cxtProfile->JetSessionID,
                    TableID,
                    GpoIDColumnID,
                    (void *)pGpoID,
                    4,
                    &Len,
                    0,
                    NULL
                    );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // The next available ID is current ID + 1
            //
            *pGpoID = *pGpoID + 1;
        }

    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        *pGpoID = 1;
        rc = SCESTATUS_SUCCESS;
    }

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // add a record to the GPO table
        //
        JetErr = JetPrepareUpdate(cxtProfile->JetSessionID,
                                  TableID,
                                  JET_prepInsert
                                  );
        rc = SceJetJetErrorToSceStatus(JetErr);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // set GpoID
            //

            JetErr = JetSetColumn(
                            cxtProfile->JetSessionID,
                            TableID,
                            GpoIDColumnID,
                            (void *)pGpoID,
                            4,
                            0, //JET_bitSetOverwriteLV,
                            NULL
                            );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // set Name column
                //

                JET_COLUMNDEF ColumnDef;

                JetErr = JetGetTableColumnInfo(
                                cxtProfile->JetSessionID,
                                TableID,
                                "Name",
                                (VOID *)&ColumnDef,
                                sizeof(JET_COLUMNDEF),
                                JET_ColInfo
                                );

                rc = SceJetJetErrorToSceStatus(JetErr);

                if ( SCESTATUS_SUCCESS == rc ) {

                    Len = wcslen(Name)*sizeof(WCHAR);

                    JetErr = JetSetColumn(
                                    cxtProfile->JetSessionID,
                                    TableID,
                                    ColumnDef.columnid,
                                    (void *)Name,
                                    Len,
                                    0,
                                    NULL
                                    );
                    rc = SceJetJetErrorToSceStatus(JetErr);
                }

            }

            if ( rc != SCESTATUS_SUCCESS ) {
                //
                // if setting fails, cancel the prepared record
                //
                JetPrepareUpdate( cxtProfile->JetSessionID,
                                  TableID,
                                  JET_prepCancel
                                  );
            } else {

                //
                // Setting columns succeed. Update the record
                //
                JetErr = JetUpdate(cxtProfile->JetSessionID,
                                   TableID,
                                   NULL,
                                   0,
                                   &Len
                                   );
                rc = SceJetJetErrorToSceStatus(JetErr);
            }
        }
    }

    return(rc);
}

//
// request the GPO ID (if there is any) for the object
//
SCESTATUS
SceJetGetGpoID(
    IN PSCESECTION hSection,
    IN PWSTR      ObjectName,
    IN JET_COLUMNID JetColGpoID OPTIONAL,
    OUT LONG      *pGpoID
    )
{
    if ( hSection == NULL || ObjectName == NULL || pGpoID == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    *pGpoID = 0;

    JET_COLUMNID  ColGpoID = 0;

    if ( JetColGpoID == 0 ) {

        ColGpoID = hSection->JetColumnGpoID;
    } else {
        ColGpoID = JetColGpoID;
    }

    if ( ColGpoID > 0 ) {

        rc = SceJetSeek(
                    hSection,
                    ObjectName,
                    wcslen(ObjectName)*sizeof(WCHAR),
                    SCEJET_SEEK_EQ_NO_CASE
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            DWORD Actual;
            JET_ERR JetErr;

            JetErr = JetRetrieveColumn(
                            hSection->JetSessionID,
                            hSection->JetTableID,
                            ColGpoID,
                            (void *)pGpoID,
                            4,
                            &Actual,
                            0,
                            NULL
                            );
            if ( JET_errSuccess != JetErr ) {
                //
                // if the column is nil (no value), it will return warning
                // but the buffer pGpoID is trashed
                //
                *pGpoID = 0;
            }

            rc = SceJetJetErrorToSceStatus(JetErr);
        }

    } else {
        rc = SCESTATUS_RECORD_NOT_FOUND;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\queue.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    queue.h

Abstract:

    prototypes for queue algorithms and data structures to handle policy notifications

Author:

    Vishnu Patankar (vishnup) 15-Aug-2000 created

--*/

#ifndef _queuep_
#define _queuep_

#include "splay.h"

#ifdef __cplusplus
extern "C" {
#endif


#define SCE_QUEUE_INFO_SAM          1L
#define SCE_QUEUE_INFO_AUDIT        2L
#define SCE_QUEUE_INFO_RIGHTS       4L

typedef enum _NOTIFICATIONQ_OPERATION_TYPE {
    ScepNotificationEnqueue = 1,
    ScepNotificationDequeue,
    ScepNotificationRetry,
    ScepNotificationProcess
} NOTIFICATIONQ_OPERATION_TYPE, *PNOTIFICATIONQ_OPERATION_TYPE;

#define SCEP_NUM_NOTIFICATION_SECONDS   300
#define SCEP_NUM_SHUTDOWN_SECONDS       60
#define SCEP_NUM_CHECK_EMPTY_SECONDS    60
#define SCEP_NUM_REST_SECONDS           20


#define MAX_SID_LENGTH      SID_MAX_SUB_AUTHORITIES*sizeof(DWORD)+10

#define SCE_NOTIFICATION_PATH           \
            SCE_ROOT_PATH TEXT("\\Notifications")

typedef struct _SCESRV_POLQUEUE_ {

   DWORD                    dwPending;
   SECURITY_DB_TYPE         DbType;
   SECURITY_DB_OBJECT_TYPE  ObjectType;
   SECURITY_DB_DELTA_TYPE   DeltaType;
   DWORD                    ExplicitLowRight;
   DWORD                    ExplicitHighRight;
   CHAR                     Sid[MAX_SID_LENGTH];
   struct _SCESRV_POLQUEUE_   *Next;

} SCESRV_POLQUEUE, *PSCESRV_POLQUEUE;


NTSTATUS
ScepQueueStartSystemThread(
    );

DWORD
ScepNotificationQInitialize(
    );

DWORD
ScepNotificationQSystemThreadFunc(
    );

VOID
ScepNotificationQDequeue(
    );

DWORD
ScepNotificationQEnqueue(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    IN PSCESRV_POLQUEUE pRetryQNode OPTIONAL
    );

VOID
ScepNotificationQFree(
    );

DWORD
ScepNotificationQFlush(
    );

DWORD
ScepNotificationQUnFlush(
    );

VOID
ScepNotificationQNodeLog(
    IN PSCESRV_POLQUEUE pQNode,
    IN NOTIFICATIONQ_OPERATION_TYPE    NotificationOp
    );

DWORD
ScepGetQueueInfo(
    OUT DWORD *pdwInfo,
    IN OUT PSCEP_SPLAY_TREE pRootNode
    );

DWORD
ScepNotifyLogPolicy(
    IN DWORD ErrCode,
    IN BOOL  bLogTime,
    IN PWSTR Msg,
    IN DWORD DbType,
    IN DWORD ObjectType,
    IN PWSTR ObjectName OPTIONAL
    );

DWORD
ScepQueuePrepareShutdown(
    );

DWORD
ScepNotificationLogOpen(
   );

VOID
ScepNotificationLogClose(
   );

VOID
ScepBackupNotificationLogFile(
    );

VOID
ScepNotificationQCleanup(
    );

VOID
ScepNotificationQControl(
    IN DWORD Flag
    );

DWORD
ScepCheckAndWaitPolicyPropFinish();

//
// for debugging only
//

VOID
ScepDbgNotificationQDump(
    );

VOID
ScepDbgNotificationQDumpNode(
    IN PSCESRV_POLQUEUE pQNode
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\queue.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    queue algorithms and data structures to handle policy notifications

Author:

    Vishnu Patankar (vishnup) 15-Aug-2000 created

--*/
#include "serverp.h"
#include "sceutil.h"
#include "queue.h"
#include "sddl.h"

extern HINSTANCE MyModuleHandle;
static HANDLE  hNotificationThread = NULL;
static HANDLE  ghEventNotificationQEnqueue = NULL;
static HANDLE  ghEventPolicyPropagation = NULL;

static BOOL    gbShutdownForNotification = FALSE;
static HANDLE  hNotificationLogFile = INVALID_HANDLE_VALUE;

//
// turn-on logging until registry queried by system thread (at least until testing)
//

static DWORD gdwNotificationLog = 2;

BOOL bQueriedProductTypeForNotification = FALSE;
static NT_PRODUCT_TYPE ProductTypeForNotification;
static CRITICAL_SECTION NotificationQSync;

#define SCEP_MAX_RETRY_NOTIFICATIONQ_NODES 1000
#define SCEP_NOTIFICATION_RETRY_COUNT 10
#define SCEP_NOTIFICATION_LOGFILE_SIZE 0x1 << 20
#define SCEP_NOTIFICATION_EVENT_TIMEOUT_SECS 600
#define SCEP_MINIMUM_DISK_SPACE  5 * (0x1 << 20)

#define SCEP_NOTIFICATION_EVENT  L"E_ScepNotificationQEnqueue"
#define SCEP_POLICY_PROP_EVENT   L"E_ScepPolicyPropagation"

#define SCEP_IS_SAM_OBJECT(ObjectType) ((ObjectType == SecurityDbObjectSamUser ||\
                                         ObjectType == SecurityDbObjectSamGroup ||\
                                         ObjectType == SecurityDbObjectSamAlias) ?\
                                         TRUE : FALSE)

//
// queue head needs to be accessed in server.cpp
//
PSCESRV_POLQUEUE pNotificationQHead=NULL;
static PSCESRV_POLQUEUE pNotificationQTail=NULL;
static DWORD gdwNumNotificationQNodes = 0;
static DWORD gdwNumNotificationQRetryNodes = 0;

static BOOL gbSuspendQueue=FALSE;

PWSTR   OpTypeTable[] = {
    L"Enqueue",
    L"Dequeue",
    L"Retry",
    L"Process"
};

DWORD
ScepCheckAndWaitFreeDiskSpaceInSysvol();

//
// todo - consider exception handling in the enqueue routine (in case we claim a critsec and av)
//


DWORD
ScepNotificationQInitialize(
    )
/*
Routine Description:

    This function is called when SCE server data is initialized (system startup).

    This function initializes data/buffer/state related to queue
    management, for example, the queue, critical sections, global variables, etc.

    This function also checks for any saved queue items from previous system
    shutdown and initializes the queue with the saved items.

Arguments:

    None

Return Value:

    Win32 error code
*/
{

    DWORD   rc = ERROR_SUCCESS;

    //
    // initialize head and tail to reflect an empty queue
    //

    pNotificationQHead = NULL;
    pNotificationQTail = NULL;


    //
    // initialize the log file on DCs only (for perf reasons no need to do so for non-DCs)
    // (assuming that this routine is called before ScepQueueStartSystemThread)
    //

    if ( RtlGetNtProductType( &ProductTypeForNotification ) ) {

        if (ProductTypeForNotification != NtProductLanManNt )

            gdwNotificationLog = 0;

        bQueriedProductTypeForNotification = TRUE;

    }

    ScepNotificationLogOpen();

    //
    // this critical section is used to sequentialize writes to the queue
    // reads need not be protected against/from
    //

    ScepNotifyLogPolicy(0, TRUE, L"Initialize NotificationQSync", 0, 0, NULL );

    InitializeCriticalSection(&NotificationQSync);

    //
    // check for any saved queue items from previous system
    // initialize queue with these items from some persistent store
    //

    rc = ScepNotificationQUnFlush();

    ScepNotifyLogPolicy(rc, FALSE, L"Unflush Notification Queue", 0, 0, NULL );

    return rc;
}


NTSTATUS
ScepQueueStartSystemThread(
    )
/*
Routine Description:

    This function is called when SCE server is started (system startup) after
    RPC server starts listening.

    This function creates a worker thread. The worker thread manages the queue.
    If the thread fails to get created, an error is returned.

Arguments:

    None

Return Value:

    Dos error code

*/
{
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwThreadId = 0;
    WCHAR   pszMsg[MAX_PATH];


    //
    // ProductType of the machine is initialized into a thread global variable to be
    // used by policy filter. The type determines where to save the policy changes (DB or GP).
    // Based on the product type, different policy notification APIs are called.
    //

    if ( !bQueriedProductTypeForNotification && !RtlGetNtProductType( &ProductTypeForNotification ) ) {

        //
        // on failure, ProductTypeForNotification = NtProductWinNt, continue
        //

        ScepNotifyLogPolicy(ERROR_BAD_ENVIRONMENT, TRUE, L"Get product type", 0, 0, NULL );

    }

    if (ProductTypeForNotification == NtProductLanManNt ) {

        //
        // create an event which is signalled when a node is enqueued into the notification queue
        // this event helps the notification system thread to wait efficiently
        //

        ghEventNotificationQEnqueue = CreateEvent(
                                                         NULL,
                                                         FALSE,
                                                         FALSE,
                                                         SCEP_NOTIFICATION_EVENT
                                                         );

        if ( ghEventNotificationQEnqueue ) {

            ScepNotifyLogPolicy(0, FALSE, L"Successfully created event E_ScepNotificationQEnqueue ", 0, 0, NULL );

            //
            // create an event for policy propagation
            //

            ghEventPolicyPropagation = CreateEvent(
                                                 NULL,
                                                 FALSE,
                                                 FALSE,
                                                 SCEP_POLICY_PROP_EVENT
                                                 );

            if ( ghEventPolicyPropagation ) {

                ScepNotifyLogPolicy(0, FALSE, L"Successfully created event E_ScepPolicyPropagation", 0, 0, NULL );

                //
                // On domain controllers, create a worker thread that's always running in
                // services this thread constantly monitors notifications inserted into
                // the NotificationQ by LSA's threads and processes them
                //

                hNotificationThread = CreateThread(
                                                  NULL,
                                                  0,
                                                  (PTHREAD_START_ROUTINE)ScepNotificationQSystemThreadFunc,
                                                  NULL,
                                                  0,
                                                  (LPDWORD)&dwThreadId
                                                  );

                if (hNotificationThread) {

                    pszMsg[0] = L'\0';

                    swprintf(pszMsg, L"Thread %x", dwThreadId);

                    ScepNotifyLogPolicy(0, TRUE, L"Create Notification Thread Success", 0, 0, pszMsg );

                    CloseHandle(hNotificationThread);

                }

                else {

                    rc = GetLastError();

                    ScepNotifyLogPolicy(rc, TRUE, L"Create Notification Thread Failure", 0, 0, NULL );

                    ScepNotificationQCleanup();

                }
            }

            else {

                rc = GetLastError();

                ScepNotifyLogPolicy(rc, FALSE, L"Error creating event E_ScepPolicyPropagation", 0, 0, NULL );

                ScepNotificationQCleanup();

            }
        }

        else {

            rc = GetLastError();

            ScepNotifyLogPolicy(rc, FALSE, L"Error creating event E_ScepNotificationQEnqueue ", 0, 0, NULL );

            ScepNotificationQCleanup();

        }

    } else {

        ScepNotifyLogPolicy(0, FALSE, L"Policy filter is not designed for non domain controllers", 0, 0, NULL );

        //
        // if changed to DC, have to reboot so cleanup anyway
        //

        ScepNotificationQCleanup();

    }

    return rc;
}

DWORD
ScepQueuePrepareShutdown(
    )
/*
Routine Description:

    This function is called when SCE server is requested to shut down (system
    shutdown) after RPC server stops listening.

    This function waits for SCEP_NOTIFICATION_TIMEOUT period to allow the system thread
    finish up with the queue items. After the timeout, it kills the worker
    thread and saves the pending queue items.

Arguments:

    None

Return Value:

    Dos error code
*/
{

    ScepNotifyLogPolicy(0, TRUE, L"System shutdown", 0, 0, NULL );

    //
    // gracefully shutdown the notification system thread by setting a global
    //

    gbShutdownForNotification = TRUE;

    //
    // if notification thread is never initialized, there is no point to wait
    // which may delay services.exe shutdown
    //
    if ( ghEventNotificationQEnqueue ) {

        // sleep for 10 seconds first
        // then check the queue for empty
        Sleep( 10*000 );

        if ( pNotificationQHead ) {

            Sleep( SCEP_NUM_SHUTDOWN_SECONDS * 1000 );
        }
    }

/*
    ScepNotifyLogPolicy(0, FALSE, L"Terminating Notification Thread", 0, 0, NULL );
    rc = RtlNtStatusToDosError(NtTerminateThread(
            hNotificationThread,
            STATUS_SYSTEM_SHUTDOWN
            ));

    ScepNotifyLogPolicy(rc, FALSE, L"Terminated Notification Thread", 0, 0, NULL );


*/

    DeleteCriticalSection(&NotificationQSync);

    (void) ShutdownEvents();

    return ERROR_SUCCESS;
}

VOID
ScepNotificationQDequeue(
    )
/*
Routine Description:

    This function pops one node from the queue.

    The queue is a singly linked list ->->-> which pushes at tail(rightmost) and pops
    from the head(leftmost)

Arguments:

    None

Return Value:

    None
*/
{

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, TRUE, L"Entered NotificationQSync for Dequeueing", 0, 0, NULL );

    if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;

        if ( pNotificationQTail == pNotificationQHead ) {
            //
            // there is only one node in the queue
            //
            pNotificationQTail = NULL;
        }

        //
        // move head to the next one
        //
        pNotificationQHead = pNotificationQHead->Next;

        //
        // log and free the node
        //

        ScepNotificationQNodeLog(pQNode, ScepNotificationDequeue);

        ScepFree(pQNode);

        -- gdwNumNotificationQNodes;
    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync after Dequeueing", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return;
}

DWORD
ScepNotificationQEnqueue(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    IN PSCESRV_POLQUEUE pRetryQNode OPTIONAL
    )

/*
Description:

    This function is called to add a notification to the queue. Note that
    only two notifications for the same data are added to the queue.

    The operation is protected from other reads/writes.
    Access check is already done outside of this function.

    Either the created threads call this routine or the system calls this routine.
    In the former case, pQNode = NULL

Arguments:

    DbType              -   SAM or LSA
    DeltaType           -   type of change (add. delete etc.). For SAM accounts, we'll only get delete since
                            some user rights may have to be removed.
    ObjectType          -   SECURITY_DB_OBJECT_TYPE such as SAM group, LSA account etc.
    ObjectSid           -   sid of the object being notified (might be NULL if ObjectType ==
                            SecurityDbObjectLsaPolicy i.e. auditing info etc.)
    ExplicitLowRight    -   Bitmask of user rights (lower 32 rights)
    ExplicitHighRight   -   Bitmask of user rights (higher 32 rights)
    pRetryQNode         -   If caller is not the system thread ScepNotificationQSystemThreadFunc,
                            this parameter is NULL since memory needs to be allocated. If caller
                            is not the system thread, we only have to do pointer manipulations.

Return Value:

    Win32 error code
*/
{
    DWORD rc    =   ERROR_SUCCESS;

    //
    // on Whistler, only allow notifications on DCs
    // on Windows 2000, all products are allowed.
    //

    if (ProductTypeForNotification != NtProductLanManNt ) {

        //
        // what error is okay to return ?
        //

        return ERROR_SUCCESS;

    }

    //
    // check parameters
    //

    if ( DbType == SecurityDbLsa &&
         ObjectType == SecurityDbObjectLsaAccount &&
         ObjectSid == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( DbType == SecurityDbSam &&
         SCEP_IS_SAM_OBJECT(ObjectType) &&
         ObjectSid == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // if the number of retried notifications is over certain limit (this is yet to be finalized)
    //  -   on a PDC we consider a full sync at reboot, stall future notifications from happening,
    //      set some registry key to indicate that a full sync is needed at reboot
    //  -   on other DCs we continue as if nothing happened
    //

    if ( gdwNumNotificationQRetryNodes >= SCEP_MAX_RETRY_NOTIFICATIONQ_NODES ) {

        //
        // log an error
        // suggest to do a full sync ???
        //

        ScepNotifyLogPolicy(ERROR_NOT_ENOUGH_QUOTA, TRUE, L"Queue length is over the maximal limit.", 0, 0, NULL );

        return  ERROR_NOT_ENOUGH_QUOTA;
    }

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, TRUE, L"Entered NotificationQSync for Enqueueing", 0, 0, NULL );

    //
    // if we are enqueueing due to a retry
    //      dequeue it (adjust pointers only)
    //      do not free the memory associated with this node (will be reused in enqueue)
    //

    if ( pRetryQNode && pNotificationQHead ) {

        //
        // this code fragment is similar to a dequeue except that the node is not freed
        //

        if ( pNotificationQTail == pNotificationQHead ) {
            //
            // there is only one node in the queue
            //
            pNotificationQTail = NULL;
        }

        //
        // move head to the next one
        //
        pNotificationQHead = pNotificationQHead->Next;

        -- gdwNumNotificationQNodes;
    }

    //
    // check to see if there is a duplicate notification
    //

    PSCESRV_POLQUEUE pQNode = pNotificationQHead;
    PSCESRV_POLQUEUE pQNodeDuplicate1 = NULL;
    PSCESRV_POLQUEUE pQNodeDuplicate2 = NULL;
    DWORD dwMatchedInstance = 0;

    while ( pQNode ) {

        //
        // SAM notification
        //

        if ( DbType == SecurityDbSam &&
             pQNode->DbType == DbType &&
             SCEP_IS_SAM_OBJECT(ObjectType) &&
             SCEP_IS_SAM_OBJECT(pQNode->ObjectType) &&
             pQNode->ObjectType == ObjectType &&
             RtlEqualSid(ObjectSid, (PSID)(pQNode->Sid))) {

                dwMatchedInstance++;

        }

        //
        // LSA notification
        //

        else if ( DbType == SecurityDbLsa &&
                  pQNode->DbType == DbType &&
                  ObjectType == SecurityDbObjectLsaAccount &&
                  pQNode->ObjectType == ObjectType &&
                  ExplicitLowRight == pQNode->ExplicitLowRight &&
                  ExplicitHighRight == pQNode->ExplicitHighRight &&
                  RtlEqualSid(ObjectSid, (PSID)(pQNode->Sid))) {

                    dwMatchedInstance++;
        }

        if ( dwMatchedInstance == 1 )
            pQNodeDuplicate1 = pQNode;
        else if ( dwMatchedInstance == 2 )
            pQNodeDuplicate2 = pQNode;

        if ( dwMatchedInstance == 2 ) {

            break;

        }

        pQNode = pQNode->Next;
    }

    if ( !pQNode ) {

        //
        // did not find two instances of the same kind of notification
        // enqueue this notification
        //

        PSCESRV_POLQUEUE pNewItem = NULL;

        if (pRetryQNode == NULL) {

            pNewItem = (PSCESRV_POLQUEUE)ScepAlloc(0, sizeof(SCESRV_POLQUEUE));

            if ( pNewItem ) {
                //
                // initialize the new node
                //
                pNewItem->dwPending = 1;
                pNewItem->DbType = DbType;
                pNewItem->ObjectType = ObjectType;
                pNewItem->DeltaType = DeltaType;
                pNewItem->ExplicitLowRight = ExplicitLowRight;
                pNewItem->ExplicitHighRight = ExplicitHighRight;
                pNewItem->Next = NULL;

                if ( ObjectSid ) {

                    RtlCopySid (MAX_SID_LENGTH, (PSID)(pNewItem->Sid), ObjectSid);

                } else {

                    RtlZeroMemory(pNewItem->Sid, MAX_SID_LENGTH);

                }


            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;

            }
        }
        else {
            pNewItem = pRetryQNode;
            pNewItem->Next = NULL;
        }

        //
        // enqueue the notification
        //

        if (pNewItem) {

            if ( pNotificationQTail ) {

                pNotificationQTail->Next = pNewItem;
                pNotificationQTail = pNewItem;

            } else {

                pNotificationQHead = pNotificationQTail = pNewItem;

            }

            //
            // awake the notification system thread only if queue is non-empty
            // multiple signalling is fine since the event stays signalled
            //

            if ( !SetEvent( ghEventNotificationQEnqueue ) ) {

                rc = GetLastError();

                ScepNotifyLogPolicy(rc, FALSE, L"Error signaling event E_ScepNotificationQEnqueue", 0, 0, NULL );

            }

            ScepNotificationQNodeLog(pNewItem, pRetryQNode ? ScepNotificationRetry : ScepNotificationEnqueue);

            ++ gdwNumNotificationQNodes;

        } else {
            //
            // log the error
            //
            ScepNotifyLogPolicy(rc, FALSE, L"Error allocating buffer for the enqueue operation.", 0, 0, NULL );
        }
    }

    if (pRetryQNode ) {

        //
        // if duplicates, update the retry counts (should be same for instances of
        // the same notification
        //

        if ( pQNodeDuplicate1 ) {
            // increment the retry count if it has not been
            if ( pQNodeDuplicate1->dwPending <= 1 ) gdwNumNotificationQRetryNodes++;

            pQNodeDuplicate1->dwPending = pRetryQNode->dwPending;
        }

        if ( pQNodeDuplicate2 ) {

            // increment the retry count if it has not been
            if ( pQNodeDuplicate2->dwPending <= 1 ) gdwNumNotificationQRetryNodes++;

            pQNodeDuplicate2->dwPending = pRetryQNode->dwPending;
        }
    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for Enqueueing", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return(rc);
}

DWORD
ScepNotificationQSystemThreadFunc(
    )
/*
Description:

    The thread will iterate through the notification queue to process each
    notification (calling existing functions). If a notification fails to be
    processed, the notification is added back to the end of the queue.

    For certain errors, such as sysvol is not ready, or hard disk is full,
    the system thread will sleep for some time then restart the process.

    Each notification node in the queue will have a retry count. After the node
    is retried for SCEP_NOTIFICATION_RETRY_COUNT times, the node will be removed
    from the queue (so that policy propagation is not blocked forever) and the
    error will be logged to event log.

    The system thread should provide logging for the operations/status (success
    and failure).

    Read/Write to the queue should be protected from other reads/writes.

    ProductType of the machine should be initialized into a thread global variable to
    be used by policy filter. The type determines where to save the policy changes
    (DB or GP). Based on the product type, different policy notification APIs are called.

Arguments:

    None

Return Value:

    Win32 error code
*/
{


    //
    // loop through the queue
    // for each queue node, call the function to process
    // in Whistler, only process notification on DCs
    // in Windows 2000, process notificatioon on all products
    //

    PSCESRV_POLQUEUE    pQNode = pNotificationQHead;
    DWORD   dwMatchedInstance = 0;
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwLogSize=0;
    DWORD   dwProcessedNode=0;

    //
    // this thread is always running looking to process notifications in the queue
    //

    (void) InitializeEvents(L"SceSrv");

    while (1) {

        if (pQNode) {

            //
            // query registry flag for log level (until now it is set to 2 because if
            // anything bad happens before this, we need to log it)
            // query only if first node
            //

            if (ERROR_SUCCESS != ScepRegQueryIntValue(
                                                     HKEY_LOCAL_MACHINE,
                                                     SCE_ROOT_PATH,
                                                     TEXT("PolicyDebugLevel"),
                                                     &gdwNotificationLog
                                                     )) {
                //
                // set the value to 2, in case the registry value doesn't exist
                //

                gdwNotificationLog = 2;

            }

            //
            // get log file size
            //
            if (ERROR_SUCCESS != ScepRegQueryIntValue(
                                             HKEY_LOCAL_MACHINE,
                                             SCE_ROOT_PATH,
                                             TEXT("PolicyLogSize"),
                                             &dwLogSize
                                             )) {
                dwLogSize = 0;
            }

            //
            // minimum log size 1MB
            //
            if ( dwLogSize > 0 ) dwLogSize = dwLogSize * (1 << 10);  // number of KB
            if ( dwLogSize < SCEP_NOTIFICATION_LOGFILE_SIZE ) dwLogSize = SCEP_NOTIFICATION_LOGFILE_SIZE;

        } else {

            //
            // no notifications - wait efficiently/responsively for an enqueue event
            // it's an auto reset event - so will get reset after it goes past when signalled
            //

            //
            // timeout is SCEP_NOTIFICATION_EVENT_TIMEOUT_SECS since we need to periodically
            // check for system shutdown if there are no enqueue events at all
            //

            while (1) {

                rc = WaitForSingleObjectEx(
                                                ghEventNotificationQEnqueue,
                                                SCEP_NOTIFICATION_EVENT_TIMEOUT_SECS*1000,
                                                FALSE
                                                );
                if ( rc == -1 )
                    rc = GetLastError();

                if ( gbShutdownForNotification )
                    break;

                //
                // if event was signalled and wait happened successfully, move on
                //

                if ( rc == WAIT_OBJECT_0 )
                    break;

                //
                // if timeout, then continue waiting otherwise exit since some other wait status was returned
                //

                if ( rc != WAIT_TIMEOUT ) {

                    ScepNotifyLogPolicy(rc, TRUE, L"Unexpected wait status while notification system thread waits for E_ScepNotificationQEnqueue", 0, 0, NULL );
                    break;

                }

            }

            //
            // if error in waiting or system shutdown, break out of the outermost while
            // loop - system thread will eventually exit
            //

            if ( gbShutdownForNotification )
                break;

        }

        while ( pQNode ) {

            if ( gbShutdownForNotification )
                break;

            if ( dwProcessedNode >= 10 ) {

                if ( gdwNotificationLog && (hNotificationLogFile != INVALID_HANDLE_VALUE) ) {

                    //
                    // backup the log if it's over the limit and start afresh
                    //
                    if ( dwLogSize < GetFileSize(hNotificationLogFile, NULL) ) {

                        ScepBackupNotificationLogFile();

                    }

                    else {

                        //
                        // GetFileSize potentially mangles the file handle - so set it back to EOF
                        //

                        SetFilePointer (hNotificationLogFile, 0, NULL, FILE_END);

                    }
                }

                //
                // check free disk space
                //
                ScepCheckAndWaitFreeDiskSpaceInSysvol();

                dwProcessedNode = 0;

            }

            if ( pQNode->dwPending > 1 &&
                 ( gdwNumNotificationQNodes == 1 ||
                   (gdwNumNotificationQNodes == gdwNumNotificationQRetryNodes) ) ) {
                //
                // if this is a retried node, should sleep for some time before retry
                // if it's the only node or all nodes are retried.
                //
                ScepNotifyLogPolicy(0, FALSE, L"Retried node, taking a break.", 0, 0, NULL );

                Sleep( SCEP_NUM_REST_SECONDS * 1000 );
            }

            //
            // process this notification
            //

            rc = ScepNotifyProcessOneNodeDC(
                                           pQNode->DbType,
                                           pQNode->ObjectType,
                                           pQNode->DeltaType,
                                           pQNode->Sid,
                                           pQNode->ExplicitLowRight,
                                           pQNode->ExplicitHighRight
                                           );

            ScepNotificationQNodeLog(pQNode, ScepNotificationProcess);

            if (rc == ERROR_SUCCESS) {

                if (pQNode->dwPending > 1) {

                    //
                    // this was a retried node that is being dequeued
                    //

                    if ( gdwNumNotificationQRetryNodes > 0 )
                        -- gdwNumNotificationQRetryNodes;

                }

                ScepNotificationQDequeue();

            } else {

                //
                // For certain errors, such as sysvol is not ready or hard disk is full,
                // this thread will sleep for some time then restart the process (next node).
                //

                if (rc == ERROR_FILE_NOT_FOUND ||
                    rc == ERROR_OBJECT_NOT_FOUND ||
                    rc == ERROR_MOD_NOT_FOUND ||
                    rc == ERROR_EXTENDED_ERROR) {

                    ScepNotifyLogPolicy(rc, FALSE, L"Sleeping due to processing error", 0, 0, NULL );

                    Sleep( SCEP_NUM_NOTIFICATION_SECONDS * 1000 );

                }

                //
                // Each notification node in the queue will have a retry count.
                // After the node is retried for SCEP_NOTIFICATION_RETRY_COUNT times, the node
                // will be removed from the queue (so that policy propagation is not blocked
                // forever) and the error is logged
                //

                if ( pQNode->dwPending >= SCEP_NOTIFICATION_RETRY_COUNT) {

                    ScepNotifyLogPolicy(0, FALSE, L"Retry count exceeded", 0, 0, NULL );

                    //
                    // should log to the event log
                    //

                    if ( (pQNode->DbType == SecurityDbLsa &&
                          pQNode->ObjectType == SecurityDbObjectLsaAccount) ||
                         (pQNode->DbType == SecurityDbSam &&
                          (pQNode->ObjectType == SecurityDbObjectSamUser ||
                           pQNode->ObjectType == SecurityDbObjectSamGroup ||
                           pQNode->ObjectType == SecurityDbObjectSamAlias )) ) {
                        //
                        // user rights
                        //
                        UNICODE_STRING UnicodeStringSid;

                        UnicodeStringSid.Buffer = NULL;
                        UnicodeStringSid.Length = 0;
                        UnicodeStringSid.MaximumLength = 0;

                        if ( pQNode->Sid ) {
                            RtlConvertSidToUnicodeString(&UnicodeStringSid,
                                                  pQNode->Sid,
                                                  TRUE );

                        }

                        LogEvent(MyModuleHandle,
                                 STATUS_SEVERITY_ERROR,
                                 SCEEVENT_ERROR_QUEUE_RETRY_TIMEOUT,
                                 IDS_ERROR_SAVE_POLICY_GPO_ACCOUNT,
                                 rc,
                                 UnicodeStringSid.Buffer ? UnicodeStringSid.Buffer : L""
                                 );

                        RtlFreeUnicodeString( &UnicodeStringSid );

                    } else {
                        LogEvent(MyModuleHandle,
                                 STATUS_SEVERITY_ERROR,
                                 SCEEVENT_ERROR_QUEUE_RETRY_TIMEOUT,
                                 IDS_ERROR_SAVE_POLICY_GPO_OTHER,
                                 rc
                                 );
                    }

                    if ( gdwNumNotificationQRetryNodes > 0 )
                        -- gdwNumNotificationQRetryNodes;

                    ScepNotificationQDequeue();

                }
                else {

                    //
                    // this node is being retried
                    //

                    if ( pQNode->dwPending == 1 )
                        ++ gdwNumNotificationQRetryNodes;

                    ++ pQNode->dwPending;

                    ScepNotifyLogPolicy(0, FALSE, L"Retry count within bounds", 0, 0, NULL );

                    //
                    // no error can happen since only pointer manipulation for retry-enqueue
                    //

                    ScepNotificationQEnqueue(
                                            pQNode->DbType,
                                            pQNode->DeltaType,
                                            pQNode->ObjectType,
                                            pQNode->Sid,
                                            pQNode->ExplicitLowRight,
                                            pQNode->ExplicitHighRight,
                                            pQNode
                                            );

                }

            }

            pQNode = pNotificationQHead;
            dwProcessedNode++;

        }

        if ( gbShutdownForNotification )
            break;
        //
        // this thread has to keep being fed
        //      - some other thread might have enqueued new notification nodes
        //      - no other thread dequeues notification nodes (hence no need to protect reads)

        pQNode = pNotificationQHead;
    }

    //
    // should never get in here unless a shutdown happens
    // flush any queue items to some persistent store
    //

    rc = ScepNotificationQFlush();

    ScepNotifyLogPolicy(rc, TRUE, L"Flushing notification queue to disk", 0, 0, NULL );

    ScepNotificationQCleanup();

    ScepNotifyLogPolicy(0, FALSE, L"Notification thread exiting", 0, 0, NULL );

    ExitThread(rc);

    return ERROR_SUCCESS;
}

//
// todo - this routine really has not changed from polsrv.cpp
//

DWORD
ScepNotifyLogPolicy(
    IN DWORD ErrCode,
    IN BOOL  bLogTime,
    IN PWSTR Msg,
    IN DWORD DbType,
    IN DWORD ObjectType,
    IN PWSTR ObjectName OPTIONAL
    )
/*
Description:

    The main logging routine that logs notification information to
    %windir%\\security\\logs\\scepol.log.

Arguments:

    ErrCode     -   the error code to log
    bLogTime    -   if TRUE, log a timestamp
    Msg         -   the string message to log (not loczlized since it is detailed debugging)
    DbType      -   LSA/SAM
    ObjectType  -   SECURITY_DB_OBJECT_TYPE such as SAM group, LSA account etc.
    ObjectName  -   can be NULL - usually carries a message

Return Value:

    Win32 error code
*/
{

    switch ( gdwNotificationLog ) {
    case 0:
        // do not log anything
        return ERROR_SUCCESS;
        break;
    case 1:
        // log error only
        if ( ErrCode == 0 ) {
            return ERROR_SUCCESS;
        }
        break;
    default:
        break;
    }

    if (hNotificationLogFile != INVALID_HANDLE_VALUE) {

        //
        // print a time stamp
        //

        if ( bLogTime ) {

            LARGE_INTEGER CurrentTime;
            LARGE_INTEGER SysTime;
            TIME_FIELDS   TimeFields;
            NTSTATUS      NtStatus;

            NtStatus = NtQuerySystemTime(&SysTime);

            RtlSystemTimeToLocalTime (&SysTime,&CurrentTime);

            if ( NT_SUCCESS(NtStatus) &&
                 (CurrentTime.LowPart != 0 || CurrentTime.HighPart != 0) ) {

                memset(&TimeFields, 0, sizeof(TIME_FIELDS));

                RtlTimeToTimeFields (
                            &CurrentTime,
                            &TimeFields
                            );
                if ( TimeFields.Month > 0 && TimeFields.Month <= 12 &&
                     TimeFields.Day > 0 && TimeFields.Day <= 31 &&
                     TimeFields.Year > 1600 ) {

                    ScepWriteVariableUnicodeLog(hNotificationLogFile, TRUE,
                                                L"\r\n----------------%02d/%02d/%04d %02d:%02d:%02d",
                                                TimeFields.Month,
                                                TimeFields.Day,
                                                TimeFields.Year,
                                                TimeFields.Hour,
                                                TimeFields.Minute,
                                                TimeFields.Second);
                } else {
                    ScepWriteVariableUnicodeLog(hNotificationLogFile, TRUE,
                                                L"\r\n----------------%08x 08x",
                                                CurrentTime.HighPart,
                                                CurrentTime.LowPart);
                }
            } else {
                ScepWriteSingleUnicodeLog(hNotificationLogFile, TRUE, L"\r\n----------------Unknown time");
            }

        }

        //
        // print operation status code
        //
        if ( ErrCode ) {
            ScepWriteVariableUnicodeLog(hNotificationLogFile, FALSE,
                                        L"Thread %x\tError=%d",
                                        GetCurrentThreadId(),
                                        ErrCode
                                        );

        } else {
            ScepWriteVariableUnicodeLog(hNotificationLogFile, FALSE,
                                        L"Thread %x\t",
                                        GetCurrentThreadId()
                                        );
        }

        //
        // operation type
        //

        switch (DbType) {
        case SecurityDbLsa:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tLSA");
            break;
        case SecurityDbSam:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tSAM");
            break;
        default:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"");
            break;
        }

        //
        // print object type
        //

        switch (ObjectType) {
        case SecurityDbObjectLsaPolicy:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tPolicy");
            break;
        case SecurityDbObjectLsaAccount:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tAccount");
            break;
        case SecurityDbObjectSamDomain:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tDomain");
            break;
        case SecurityDbObjectSamUser:
        case SecurityDbObjectSamGroup:
        case SecurityDbObjectSamAlias:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\tAccount");
            break;
        default:
            ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"");
            break;
        }

        BOOL bCRLF;

        __try {

            //
            // print the name(s)
            //

            if ( Msg ) {
                bCRLF = FALSE;
            } else {
                bCRLF = TRUE;
            }
            if ( ObjectName ) {

                ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\t");
                ScepWriteSingleUnicodeLog(hNotificationLogFile, bCRLF, ObjectName);
            }

            if ( Msg ) {
                ScepWriteSingleUnicodeLog(hNotificationLogFile, FALSE, L"\t");
                ScepWriteSingleUnicodeLog(hNotificationLogFile, TRUE, Msg);
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            CloseHandle( hNotificationLogFile );

            hNotificationLogFile = INVALID_HANDLE_VALUE;

            return(ERROR_INVALID_PARAMETER);
        }

    } else {
        return(GetLastError());
    }

    return(ERROR_SUCCESS);
}


VOID
ScepNotificationQFree(
    )
/*
Routine Description:

    This function frees the notification queue.

Arguments:

    None

Return Value:

    None
*/
{

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, TRUE, L"Entered NotificationQSync for freeing queue", 0, 0, NULL );

    if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;
        PSCESRV_POLQUEUE pQNodeToFree = NULL;

        while ( pQNode ) {

            pQNodeToFree = pQNode;

            pQNode = pQNode->Next;

            ScepFree(pQNodeToFree);

        }

        pNotificationQHead = NULL;

    }

    pNotificationQTail = NULL;

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for freeing queue ", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return;
}

DWORD
ScepNotificationQFlush(
    )
/*
Routine Description:

    This function flushes the notification queue to some persistent store.

Arguments:

    None

Return Value:

    None
*/
{

    DWORD   rc = ERROR_SUCCESS;

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, TRUE, L"Entered NotificationQSync for flushing queue", 0, 0, NULL );

    if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;

        HKEY hKey = NULL;
        int i=1;
        HKEY hKeySub=NULL;
        WCHAR SubKeyName[10];

        rc = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                           SCE_NOTIFICATION_PATH,
                           0,
                           NULL, // LPTSTR lpClass,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE, // KEY_SET_VALUE,
                           NULL, // &SecurityAttributes,
                           &hKey,
                           NULL
                          );

        if ( ERROR_SUCCESS == rc ) {

            while ( pQNode ) {

                //
                // write pQNode to persistent store using available APIs
                //
                memset(SubKeyName, '\0', 20);
                swprintf(SubKeyName, L"%9d",i);

                rc = RegCreateKeyEx(
                           hKey,
                           SubKeyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hKeySub,
                           NULL
                          );

                if ( ERROR_SUCCESS == rc ) {
                    //
                    // save the node information as registry values
                    //

                    RegSetValueEx (hKeySub,
                                    L"Pending",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->dwPending),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"DbType",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->DbType),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"ObjectType",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->ObjectType),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"DeltaType",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->DeltaType),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"LowRight",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->ExplicitLowRight),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"HighRight",
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&(pQNode->ExplicitHighRight),
                                    sizeof(DWORD)
                                   );

                    RegSetValueEx (hKeySub,
                                    L"Sid",
                                    0,
                                    REG_BINARY,
                                    (BYTE *)&(pQNode->Sid),
                                    MAX_SID_LENGTH
                                   );

                } else {
                    //
                    // log the failure
                    //
                    ScepNotifyLogPolicy(rc, FALSE, L"Failed to save notification node.", pQNode->DbType, pQNode->ObjectType, NULL );
                }

                if ( hKeySub ) {

                    RegCloseKey( hKeySub );
                    hKeySub = NULL;
                }

                i++;
                pQNode = pQNode->Next;

            }

        } else {

            //
            // log the failure
            //
            ScepNotifyLogPolicy(rc, FALSE, L"Failed to open notification store.", 0, 0, SCE_NOTIFICATION_PATH );
        }

        if ( hKey ) {
            RegCloseKey(hKey);
        }

    } else {
        //
        // log the queue is empty
        //
        ScepNotifyLogPolicy(0, FALSE, L"Queue is empty.", 0, 0, NULL);
    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for flushing queue", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return rc;
}


DWORD
ScepNotificationQUnFlush(
    )
/*
Routine Description:

    This function initializes the notification queue from some persistent store
    such as registry/textfile.

Arguments:

    None

Return Value:

    None
*/
{

    DWORD   rc = ERROR_SUCCESS;

    DWORD DbType=0;
    DWORD DeltaType=0;
    DWORD ObjectType=0;
    CHAR  ObjectSid[MAX_SID_LENGTH];
    DWORD ExplicitLowRight=0;
    DWORD ExplicitHighRight=0;

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, FALSE, L"Entered NotificationQSync for unflushing queue", 0, 0, NULL );

    memset(ObjectSid, '\0', MAX_SID_LENGTH);

    HKEY hKey=NULL;

    rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                       SCE_NOTIFICATION_PATH,
                       0,
                       KEY_READ,
                       &hKey
                      );

    if ( ERROR_SUCCESS == rc ) {

        HKEY hKeySub=NULL;
        DWORD dwIndex=0;
        DWORD cbSubKey=10;
        WCHAR SubKeyName[10];
        DWORD cbData;
        DWORD dwPending=0;
        DWORD RegType;

        //
        // enumerate all subkeys and save each node
        //
        do {

            memset(SubKeyName, '\0', 20);
            cbSubKey = 10;

            rc = RegEnumKeyEx (hKey,
                               dwIndex,
                               SubKeyName,
                               &cbSubKey,
                               NULL,
                               NULL,
                               NULL,
                               NULL
                               );
            if ( ERROR_SUCCESS == rc ) {
                dwIndex++;

                //
                // open the sub key
                //
                rc = RegOpenKeyEx (hKey,
                                   SubKeyName,
                                   0,
                                   KEY_READ,
                                   &hKeySub
                                  );

                if ( ERROR_SUCCESS == rc ) {

                    //
                    // query all registry values
                    //
                    cbData = sizeof(DWORD);
                    rc = RegQueryValueEx (
                            hKeySub,
                            L"Pending",
                            NULL,
                            &RegType,
                            (LPBYTE)&dwPending,
                            &cbData
                            );

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"DbType",
                                NULL,
                                &RegType,
                                (LPBYTE)&DbType,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"ObjectType",
                                NULL,
                                &RegType,
                                (LPBYTE)&ObjectType,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"DeltaType",
                                NULL,
                                &RegType,
                                (LPBYTE)&DeltaType,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"LowRight",
                                NULL,
                                &RegType,
                                (LPBYTE)&ExplicitLowRight,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = sizeof(DWORD);
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"HighRight",
                                NULL,
                                &RegType,
                                (LPBYTE)&ExplicitHighRight,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {

                        cbData = MAX_SID_LENGTH;
                        rc = RegQueryValueEx (
                                hKeySub,
                                L"Sid",
                                NULL,
                                &RegType,
                                (LPBYTE)ObjectSid,
                                &cbData
                                );
                    }

                    if ( ERROR_SUCCESS == rc ) {
                        //
                        // add it to the queue
                        //

                        ScepNotificationQEnqueue(
                                                (SECURITY_DB_TYPE)DbType,
                                                (SECURITY_DB_DELTA_TYPE)DeltaType,
                                                (SECURITY_DB_OBJECT_TYPE)ObjectType,
                                                (PSID)ObjectSid,
                                                ExplicitLowRight,
                                                ExplicitHighRight,
                                                NULL
                                                );
                    }
                }


                if ( ERROR_SUCCESS != rc ) {
                    //
                    // log the error
                    //
                    ScepNotifyLogPolicy(rc, FALSE, L"Failed to query notification a node.", 0, 0, SubKeyName );
                }

                //
                // close handle
                //
                if ( hKeySub ) {
                    RegCloseKey(hKeySub);
                    hKeySub = NULL;
                }
            }

        } while ( rc != ERROR_NO_MORE_ITEMS );

    } else if ( ERROR_FILE_NOT_FOUND != rc ) {
        //
        // log the error
        //
        ScepNotifyLogPolicy(rc, FALSE, L"Failed to open the notification store", 0, 0, NULL );
    }

    if ( ERROR_FILE_NOT_FOUND == rc ) rc = ERROR_SUCCESS;

    //
    // close the handle
    //
    if ( hKey ) {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for unflushing queue", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return rc;
}


DWORD
ScepGetQueueInfo(
    OUT DWORD *pdwInfo,
    OUT PSCEP_SPLAY_TREE pRootNode
    )
/*
Routine Description:

    Loops through all pending notifications and returns the notification type & unique
    sid-list to the caller.

Arguments:

    dwInfo          -   bitmask of types SCE_QUEUE_INFO_SAM, SCE_QUEUE_INFO_AUDIT, SCE_QUEUE_INFO_RIGHTS
    pRootNode       -   the root node pointing to splay tree structure.

Return Value:

    Win32 error code
*/
{

    DWORD   dwInfo = 0;
    DWORD   rc = ERROR_SUCCESS;
    BOOL    bExists;

    if ( pdwInfo == NULL ||
         pRootNode == NULL )
        return ERROR_INVALID_PARAMETER;

    *pdwInfo = 0;

    if (ProductTypeForNotification != NtProductLanManNt ) {
        //
        // none DCs, the queue should always be empty.
        //
        ScepNotifyLogPolicy(0, TRUE, L"Wks/Srv Notification queue is empty", 0, 0, NULL );
        return rc;
    }

    PWSTR StringSid=NULL;

    ScepNotifyLogPolicy(0, TRUE, L"Building Notification queue info", 0, 0, NULL );

    EnterCriticalSection(&NotificationQSync);

    ScepNotifyLogPolicy(0, FALSE, L"Entered NotificationQSync for building queue info", 0, 0, NULL );

    if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;

        while ( pQNode ) {

            if ( (SCEP_IS_SAM_OBJECT(pQNode->ObjectType) ||
                  pQNode->ObjectType == SecurityDbObjectLsaAccount) ) {

                dwInfo |= SCE_QUEUE_INFO_RIGHTS;

            }

            else if ( pQNode->ObjectType == SecurityDbObjectSamDomain ) {

                dwInfo |= SCE_QUEUE_INFO_SAM;

            }

            else if ( pQNode->ObjectType == SecurityDbObjectLsaPolicy ) {

                dwInfo |= SCE_QUEUE_INFO_AUDIT;

            }


            if ( RtlValidSid( (PSID)pQNode->Sid )) {


                rc = ScepSplayInsert( (PVOID)(pQNode->Sid), pRootNode, &bExists );

                ConvertSidToStringSid( (PSID)(pQNode->Sid), &StringSid );

                if ( !bExists ) {
                    ScepNotifyLogPolicy(rc, FALSE, L"Add SID", 0, pQNode->ObjectType, StringSid );
                } else {
                    ScepNotifyLogPolicy(rc, FALSE, L"Duplicate SID", 0, pQNode->ObjectType, StringSid );
                }

                LocalFree(StringSid);
                StringSid = NULL;

                if (rc != ERROR_SUCCESS ) {
                    break;
                }

            } else {

                ScepNotifyLogPolicy(0, FALSE, L"Add Info", 0, pQNode->ObjectType, NULL );
            }

            pQNode = pQNode->Next;

        }

        if ( rc != ERROR_SUCCESS ) {

            ScepNotifyLogPolicy(rc, FALSE, L"Error building Notification queue info", 0, 0, NULL );

            ScepSplayFreeTree( &pRootNode, FALSE );

        } else {

            *pdwInfo = dwInfo;
        }

    }

    ScepNotifyLogPolicy(0, FALSE, L"Leaving NotificationQSync for building queue info", 0, 0, NULL );

    LeaveCriticalSection(&NotificationQSync);

    return rc;
}


VOID
ScepNotificationQNodeLog(
    IN PSCESRV_POLQUEUE pQNode,
    IN NOTIFICATIONQ_OPERATION_TYPE    NotificationOp
    )
/*
Routine Description:

    Dump the node info to the log file

Arguments:

    pQNode          -   pointer to node to dump
    NotificationOp  -   type of queue operation

Return Value:

    None
*/
{
    WCHAR   pwszTmpBuf[MAX_PATH*2];
    PWSTR   pszStringSid  = NULL;

    pwszTmpBuf[0] = L'\0';

    if ( pQNode == NULL ||
         gdwNotificationLog == 0 ||
         NotificationOp > ScepNotificationProcess ||
         NotificationOp < ScepNotificationEnqueue) {
        return;
    }

    switch (NotificationOp) {

    case ScepNotificationEnqueue:
        wcscpy(pwszTmpBuf, L"Enqueue");
        break;
    case ScepNotificationDequeue:
        wcscpy(pwszTmpBuf, L"Dequeue");
        break;
    case ScepNotificationRetry:
        wcscpy(pwszTmpBuf, L"Retry");
        break;
    case ScepNotificationProcess:
        wcscpy(pwszTmpBuf, L"Process");
        break;
    default:
        return;
    }

    ScepConvertSidToPrefixStringSid( (PSID)(pQNode->Sid), &pszStringSid );

    swprintf(pwszTmpBuf, L"Op: %s, Num Instances: %d, Num Retry Instances: %d, Retry count: %d, LowRight: %d, HighRight: %d, Sid: %s, DbType: %d, ObjectType: %d, DeltaType: %d",
             OpTypeTable[NotificationOp-1],
             gdwNumNotificationQNodes,
             gdwNumNotificationQRetryNodes,
             pQNode->dwPending,
             pQNode->ExplicitLowRight,
             pQNode->ExplicitHighRight,
             pszStringSid == NULL ? L"0" : pszStringSid,
             pQNode->DbType,
             pQNode->ObjectType,
             pQNode->DeltaType);

    ScepFree( pszStringSid );

    ScepNotifyLogPolicy(0, FALSE, L"", 0, 0, pwszTmpBuf );

    return;

}


DWORD
ScepNotificationLogOpen(
   )
/* ++
Routine Description:

   Open a handle to the notification log file %windir%\\security\\logs\\scepol.log
   and stash it in a global handle.

Arguments:

    None

Return value:

   Win32 error code

-- */
{
    DWORD  rc=NO_ERROR;

    if ( !gdwNotificationLog ) {
        return(rc);
    }

    //
    // build the log file name %windir%\security\logs\scepol.log
    //

    WCHAR LogName[MAX_PATH+51];

    LogName[0] = L'\0';
    GetSystemWindowsDirectory(LogName, MAX_PATH);
    LogName[MAX_PATH] = L'\0';

    wcscat(LogName, L"\\security\\logs\\scepol.log\0");

    hNotificationLogFile = CreateFile(LogName,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ,
                                      NULL,
                                      OPEN_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

    if ( INVALID_HANDLE_VALUE != hNotificationLogFile ) {

/*
        DWORD dwBytesWritten;

        SetFilePointer (hNotificationLogFile, 0, NULL, FILE_BEGIN);

        CHAR TmpBuf[3];
        TmpBuf[0] = (CHAR)0xFF;
        TmpBuf[1] = (CHAR)0xFE;
        TmpBuf[2] = '\0';

        WriteFile (hNotificationLogFile, (LPCVOID)TmpBuf, 2,
                   &dwBytesWritten,
                   NULL);
*/

        //
        // set to file end since we do not want to erase older logs unless we wrap around
        //

        SetFilePointer (hNotificationLogFile, 0, NULL, FILE_END);

    }


    if ( hNotificationLogFile == INVALID_HANDLE_VALUE ) {
        rc = GetLastError();
    }

    return rc;
}

VOID
ScepNotificationLogClose(
   )
/* ++
Routine Description:

   Close the handle to the notification log file %windir%\\security\\logs\\scepol.log.

Arguments:

    None

Return value:

   Win32 error code

-- */
{
   if ( INVALID_HANDLE_VALUE != hNotificationLogFile ) {
       CloseHandle( hNotificationLogFile );
   }

   hNotificationLogFile = INVALID_HANDLE_VALUE;

   return;
}


VOID
ScepBackupNotificationLogFile(
    )
/* ++
Routine Description:

   Backup the log file to %windir%\\security\\logs\\scepol.log.old and start afresh.

Arguments:

    None

Return value:

   None

-- */
{
    WCHAR LogName[MAX_PATH+51];
    WCHAR LogNameOld[MAX_PATH+51];

    LogName[0] = L'\0';
    GetSystemWindowsDirectory(LogName, MAX_PATH);

    LogName[MAX_PATH] = L'\0';

    wcscpy(LogNameOld, LogName);

    wcscat(LogName, L"\\security\\logs\\scepol.log\0");

    wcscat(LogNameOld, L"\\security\\logs\\scepol.log.old\0");

    EnterCriticalSection(&NotificationQSync);

    ScepNotificationLogClose();

    DWORD rc=0, rc2=0;

    if ( !CopyFile( LogName, LogNameOld, FALSE ) )
        rc = GetLastError();

    //
    // clear the file after handle is closed and then recreate the log file and handle
    //

    if ( !DeleteFile(LogName) )
        rc2 = GetLastError();

    ScepNotificationLogOpen();

    LeaveCriticalSection(&NotificationQSync);

    WCHAR Msg[50];
    swprintf(Msg, L"Wrapping log file: Copy(%d), Delete(%d)\0", rc, rc2);

    ScepNotifyLogPolicy(0, TRUE, Msg, 0, 0, NULL );

    return;
}


VOID
ScepNotificationQCleanup(
    )
/* ++
Routine Description:

   Perform cleanup operations

Arguments:

    None

Return value:

   None

-- */
{
    ScepNotificationQFree();

    if ( ghEventNotificationQEnqueue ) {
        CloseHandle( ghEventNotificationQEnqueue );
        ghEventNotificationQEnqueue = NULL;
    }

    if ( ghEventPolicyPropagation ) {
        CloseHandle( ghEventPolicyPropagation );
        ghEventPolicyPropagation = NULL;
    }

    ScepNotificationLogClose();

}

VOID
ScepNotificationQControl(
    IN DWORD Flag
    )
{
    if (ProductTypeForNotification == NtProductLanManNt ) {
        //
        // only control the queue process on DCs
        //
        BOOL b = (Flag > 0);

        if ( b != gbSuspendQueue ) {
            //
            // log it.
            //
            if ( !b ) {

                gbSuspendQueue = b;

                //
                // if the queue should be resumed, set the event
                //
                if ( !SetEvent( ghEventPolicyPropagation ) ) {

                    DWORD rc = GetLastError();

                    ScepNotifyLogPolicy(rc, FALSE, L"Error signaling event E_ScepPolicyPropagation", 0, 0, NULL );

                } else {
                    ScepNotifyLogPolicy(0, FALSE, L"Signaling event E_ScepPolicyPropagation", 0, 0, NULL );
                }

            } else {
                //
                // should reset the event before setting the global flag
                //
                ResetEvent( ghEventPolicyPropagation );

                gbSuspendQueue = b;

                ScepNotifyLogPolicy(0, FALSE, L"Resetting event E_ScepPolicyPropagation", 0, 0, NULL );
            }

            if ( b )
                ScepNotifyLogPolicy(0, FALSE, L"Suspend flag is set.", 0, 0, NULL );
            else
                ScepNotifyLogPolicy(0, FALSE, L"Resume flag is set", 0, 0, NULL );

        }

    }

    return;
}

DWORD
ScepCheckAndWaitPolicyPropFinish()
{

    DWORD rc=ERROR_SUCCESS;

    while (gbSuspendQueue ) {

        //
        // the queue should be suspended
        //
        rc = WaitForSingleObjectEx(
                                ghEventPolicyPropagation,
                                SCEP_NOTIFICATION_EVENT_TIMEOUT_SECS*1000,
                                FALSE
                                );
        if ( rc == -1 )
            rc = GetLastError();

        if ( gbShutdownForNotification )
            break;

        //
        // if event was signalled and wait happened successfully, move on
        //

        if ( rc == WAIT_OBJECT_0 ) {

            ScepNotifyLogPolicy(0, TRUE, L"Queue process is resumed from policy propagation", 0, 0, NULL );
            break;
        }

        //
        // if timeout, then continue waiting otherwise exit since some other wait status was returned
        //

        if ( rc != WAIT_TIMEOUT ) {

            ScepNotifyLogPolicy(rc, TRUE, L"Unexpected wait status while notification system thread waits for E_ScepPolicyPropagation", 0, 0, NULL );
            break;
        }
    }

    return rc;
}

DWORD
ScepCheckAndWaitFreeDiskSpaceInSysvol()
/*
Description:
    Saving policy into sysvol requires that some amount of disk space is available.
    If free disk space is below 5M, we should suspend the node processing and wait
    for disk space freed up.

*/
{
    //
    // Get the sysvol share path name in the format of \\ComputerName\Sysvol\
    //

    WCHAR Buffer[MAX_PATH+10];
    DWORD dSize=MAX_PATH+2;
    DWORD rc=ERROR_SUCCESS;
    ULARGE_INTEGER BytesCaller, BytesTotal, BytesFree;
    int cnt = 0;

    Buffer[0] = L'\\';
    Buffer[1] = L'\\';
    Buffer[2] = L'\0';

    if ( !GetComputerName(Buffer+2, &dSize) )
        return GetLastError();

    Buffer[MAX_PATH+2] = L'\0';

    wcscat(Buffer, TEXT("\\sysvol\\"));

    BytesCaller.QuadPart = 0;
    BytesTotal.QuadPart = 0;
    BytesFree.QuadPart = 0;

    while ( BytesCaller.QuadPart < SCEP_MINIMUM_DISK_SPACE &&
            cnt < 40 ) {

        if ( !GetDiskFreeSpaceEx(Buffer, &BytesCaller, &BytesTotal, &BytesFree) ) {

            rc = GetLastError();
            break;
        }

        if ( BytesCaller.QuadPart < SCEP_MINIMUM_DISK_SPACE ) {
            //
            // sleep for 15 minutes then check again
            //
            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_WARNING,
                     SCEEVENT_WARNING_LOW_DISK_SPACE,
                     IDS_FREE_DISK_SPACE,
                     BytesCaller.LowPart
                     );
            //
            // sleep for 15 minutes
            //
            Sleep(15*60*1000);

        }
        cnt++;
    }

    return rc;
}

VOID
ScepDbgNotificationQDump(
    )
/* ++
Routine Description:

   Dump the notification queue to console - could dump to disk if needed

Arguments:

    None

Return value:

   None

-- */
{

    EnterCriticalSection(&NotificationQSync);

    DWORD   dwNodeNum = 0;

    wprintf(L"\nTotal no. of queue nodes = %d", gdwNumNotificationQNodes);

        if ( pNotificationQHead ) {

        PSCESRV_POLQUEUE pQNode = pNotificationQHead;

        while ( pQNode ) {

            wprintf(L"\nNode no. %d", dwNodeNum++);

            ScepDbgNotificationQDumpNode(pQNode);

            pQNode = pQNode->Next;

        }
    }

    LeaveCriticalSection(&NotificationQSync);

}

VOID
ScepDbgNotificationQDumpNode(
    IN PSCESRV_POLQUEUE pQNode
    )
/*
Routine Description:

    Dump the node info to the console

Arguments:

    pQNode          -   pointer to node to dump

Return Value:

    None
*/
{
    WCHAR   pwszTmpBuf[MAX_PATH*2];
    PWSTR   pszStringSid  = NULL;

    pwszTmpBuf[0] = L'\0';

    if ( pQNode == NULL ) {
        return;
    }

    ScepConvertSidToPrefixStringSid( (PSID)(pQNode->Sid), &pszStringSid );

    swprintf(pwszTmpBuf, L"\nRetry count: %d, LowRight: %d, HighRight: %d, Sid: %s, DbType: %d, ObjectType: %d\n",
             pQNode->dwPending,
             pQNode->ExplicitLowRight,
             pQNode->ExplicitHighRight,
             pszStringSid == NULL ? L"0" : pszStringSid,
             pQNode->DbType,
             pQNode->ObjectType);


    wprintf(pwszTmpBuf);

    ScepFree( pszStringSid );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\scejetp.h ===
/*++
Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    scejetp.h

Abstract:

    Header for scejet.c - Sce-Jet service APIs

Author:


Revision History:


--*/

#ifndef _SCEJETP_
#define _SCEJETP_

#include <esent.h>

#ifdef __cplusplus
extern "C" {
#endif
//
// type used when open a table and a section
//
typedef enum _SCEJET_TABLE_TYPE {

    SCEJET_TABLE_SCP,
    SCEJET_TABLE_SAP,
    SCEJET_TABLE_SMP,
    SCEJET_TABLE_VERSION,
    SCEJET_TABLE_SECTION,
    SCEJET_TABLE_GPO,
    SCEJET_TABLE_TATTOO

} SCEJET_TABLE_TYPE;

typedef enum _SCEJET_CREATE_FLAG {

    SCEJET_CREATE_IN_BUFFER,
    SCEJET_CREATE_NO_TABLEID

} SCEJET_CREATE_FLAG;

//
// type used when open a database file
//
typedef enum _SCEJET_OPEN_TYPE {

    SCEJET_OPEN_READ_WRITE=0,
    SCEJET_OPEN_EXCLUSIVE,
    SCEJET_OPEN_READ_ONLY,
    SCEJET_OPEN_NOCHECK_VERSION

} SCEJET_OPEN_TYPE;

//
// type used when create a database file
//
typedef enum _SCEJET_CREATE_TYPE {

    SCEJET_RETURN_ON_DUP=0,
    SCEJET_OVERWRITE_DUP,
    SCEJET_OPEN_DUP,
    SCEJET_OPEN_DUP_EXCLUSIVE

} SCEJET_CREATE_TYPE;

//
// type used when delete lines
//
typedef enum _SCEJET_DELETE_TYPE {

    SCEJET_DELETE_LINE=0,
    SCEJET_DELETE_LINE_NO_CASE,
    SCEJET_DELETE_PARTIAL,
    SCEJET_DELETE_PARTIAL_NO_CASE,
    SCEJET_DELETE_SECTION

} SCEJET_DELETE_TYPE;

//
// type used when find a line
//
typedef enum _SCEJET_FIND_TYPE {
    SCEJET_CURRENT=0,
    SCEJET_EXACT_MATCH,
    SCEJET_PREFIX_MATCH,
    SCEJET_NEXT_LINE,
    SCEJET_CLOSE_VALUE,
    SCEJET_EXACT_MATCH_NO_CASE,
    SCEJET_PREFIX_MATCH_NO_CASE

} SCEJET_FIND_TYPE;


typedef enum _SCEJET_SEEK_FLAG {

    SCEJET_SEEK_GT=0,
    SCEJET_SEEK_EQ,
    SCEJET_SEEK_GE,
    SCEJET_SEEK_GT_NO_CASE,
    SCEJET_SEEK_EQ_NO_CASE,
    SCEJET_SEEK_GE_NO_CASE,
    SCEJET_SEEK_GE_DONT_CARE

} SCEJET_SEEK_FLAG;

#define SCEJET_PREFIX_MAXLEN     1024

typedef struct _SCE_CONTEXT {
    DWORD       Type;
    JET_SESID   JetSessionID;
    JET_DBID    JetDbID;
    SCEJET_OPEN_TYPE   OpenFlag;
    // scp table
    JET_TABLEID  JetScpID;
    JET_COLUMNID JetScpSectionID;
    JET_COLUMNID JetScpNameID;
    JET_COLUMNID JetScpValueID;
    JET_COLUMNID JetScpGpoID;
    // sap table
    JET_TABLEID  JetSapID;
    JET_COLUMNID JetSapSectionID;
    JET_COLUMNID JetSapNameID;
    JET_COLUMNID JetSapValueID;
    // smp table
    JET_TABLEID  JetSmpID;
    JET_COLUMNID JetSmpSectionID;
    JET_COLUMNID JetSmpNameID;
    JET_COLUMNID JetSmpValueID;
    // section table
    JET_TABLEID  JetTblSecID;
    JET_COLUMNID JetSecNameID;
    JET_COLUMNID JetSecID;
} SCECONTEXT, *PSCECONTEXT;

typedef struct _SCE_SECTION {
    JET_SESID   JetSessionID;
    JET_DBID    JetDbID;
    JET_TABLEID JetTableID;
    JET_COLUMNID JetColumnSectionID;
    JET_COLUMNID JetColumnNameID;
    JET_COLUMNID JetColumnValueID;
    JET_COLUMNID JetColumnGpoID;
    DOUBLE   SectionID;
} SCESECTION, *PSCESECTION;



//
// To Open existing profile database.
//
#define SCE_TABLE_OPTION_MERGE_POLICY           0x1
#define SCE_TABLE_OPTION_TATTOO                 0x2
#define SCE_TABLE_OPTION_DEMOTE_TATTOO          0x4

SCESTATUS
SceJetOpenFile(
    IN LPSTR        ProfileFileName,
    IN SCEJET_OPEN_TYPE Flags,
    IN DWORD        dwTableOptions,
    OUT PSCECONTEXT   *hProfile
    );

//
// To create a new profile
//
SCESTATUS
SceJetCreateFile(
    IN LPSTR      ProfileFileName,
    IN SCEJET_CREATE_TYPE    Flags,
    IN DWORD        dwTableOptions,
    OUT PSCECONTEXT *hProfile
    );

//
// close the profile database.
//
SCESTATUS
SceJetCloseFile(
    IN PSCECONTEXT   hProfile,
    IN BOOL         TermSession,
    IN BOOL         Terminate
    );

//
// To Open a section in the profile.
//
SCESTATUS
SceJetOpenSection(
    IN PSCECONTEXT    hProfile,
    IN DOUBLE        SectionID,
    IN SCEJET_TABLE_TYPE    tblType,
    OUT PSCESECTION   *hSection
    );

//
// To get line count in the section.
//
SCESTATUS
SceJetGetLineCount(
    IN PSCESECTION hSection,
    IN PWSTR      LinePrefix OPTIONAL,
    IN BOOL       bExactCase,
    OUT DWORD      *Count
    );

//
// To delete a section or current line
//
SCESTATUS
SceJetDelete(
    IN PSCESECTION  hSection,
    IN PWSTR        LinePrefix,
    IN BOOL         bObjectFolder,
    IN SCEJET_DELETE_TYPE   Flags
    );

SCESTATUS
SceJetDeleteAll(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TblName OPTIONAL,
    IN SCEJET_TABLE_TYPE  TblType
    );

//
// close a section context.
//
SCESTATUS
SceJetCloseSection(
    IN PSCESECTION   *hSection,
    IN BOOL         DestroySection
    );

//
// To get the line matching the name in the section.
//
SCESTATUS
SceJetGetValue(
    IN PSCESECTION hSection,
    IN SCEJET_FIND_TYPE    Flags,
    IN PWSTR      LinePrefix OPTIONAL,
    IN PWSTR      ActualName  OPTIONAL,
    IN DWORD      NameBufLen,
    OUT DWORD      *RetNameLen OPTIONAL,
    IN PWSTR      Value       OPTIONAL,
    IN DWORD      ValueBufLen,
    OUT DWORD      *RetValueLen OPTIONAL
    );

//
// To set a line in the section (placed alphabetically by the name)
//
SCESTATUS
SceJetSetLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN BOOL       bReserveCase,
    IN PWSTR      Value,
    IN DWORD      ValueLen,
    IN LONG       GpoID
    );

//
// other helper APIs
//

SCESTATUS
SceJetCreateTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType,
    IN SCEJET_CREATE_FLAG nFlags,
    IN JET_TABLEID *TableID OPTIONAL,
    IN JET_COLUMNID *ColumnID OPTIONAL
    );

SCESTATUS
SceJetOpenTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType,
    IN SCEJET_OPEN_TYPE OpenType,
    OUT JET_TABLEID *TableID
    );

SCESTATUS
SceJetDeleteTable(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR tblName,
    IN SCEJET_TABLE_TYPE tblType
    );

SCESTATUS
SceJetCheckVersion(
    IN PSCECONTEXT   cxtProfile,
    OUT FLOAT *pVersion OPTIONAL
    );

SCESTATUS
SceJetGetSectionIDByName(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR Name,
    OUT DOUBLE *SectionID
    );

SCESTATUS
SceJetGetSectionNameByID(
    IN PSCECONTEXT cxtProfile,
    IN DOUBLE SectionID,
    OUT PWSTR Name OPTIONAL,
    IN OUT LPDWORD pNameLen OPTIONAL
    );

SCESTATUS
SceJetAddSection(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR      Name,
    OUT DOUBLE *SectionID
    );

SCESTATUS
SceJetDeleteSectionID(
    IN PSCECONTEXT cxtProfile,
    IN DOUBLE SectionID,
    IN PCWSTR  Name
    );

SCESTATUS
SceJetGetTimeStamp(
    IN PSCECONTEXT   cxtProfile,
    OUT PLARGE_INTEGER ConfigTimeStamp,
    OUT PLARGE_INTEGER AnalyzeTimeStamp
    );

SCESTATUS
SceJetSetTimeStamp(
    IN PSCECONTEXT   cxtProfile,
    IN BOOL         Flag,
    IN LARGE_INTEGER NewTimeStamp
    );

SCESTATUS
SceJetGetDescription(
    IN PSCECONTEXT   cxtProfile,
    OUT PWSTR *Description
    );

SCESTATUS
SceJetStartTransaction(
    IN PSCECONTEXT cxtProfile
    );

SCESTATUS
SceJetCommitTransaction(
    IN PSCECONTEXT cxtProfile,
    IN JET_GRBIT grbit
    );

SCESTATUS
SceJetRollback(
    IN PSCECONTEXT cxtProfile,
    IN JET_GRBIT grbit
    );

SCESTATUS
SceJetSetValueInVersion(
    IN PSCECONTEXT cxtProfile,
    IN LPSTR TableName,
    IN LPSTR ColumnName,
    IN PWSTR Value,
    IN DWORD ValueLen, // number of bytes
    IN DWORD Prep
    );

SCESTATUS
SceJetSeek(
    IN PSCESECTION hSection,
    IN PWSTR LinePrefix,
    IN DWORD PrefixLength,
    IN SCEJET_SEEK_FLAG SeekBit
    );

SCESTATUS
SceJetMoveNext(
    IN PSCESECTION hSection
    );

SCESTATUS
SceJetJetErrorToSceStatus(
    IN JET_ERR  JetErr
    );

SCESTATUS
SceJetRenameLine(
    IN PSCESECTION hSection,
    IN PWSTR      Name,
    IN PWSTR      NewName,
    IN BOOL       bReserveCase
    );

SCESTATUS
SceJetInitialize(OUT JET_ERR *pJetErr OPTIONAL);


SCESTATUS
SceJetTerminate(BOOL bCleanVs);

SCESTATUS
SceJetTerminateNoCritical(BOOL bCleanVs);

VOID
SceJetInitializeData();

BOOL
SceJetDeleteJetFiles(
    IN PWSTR DbFileName OPTIONAL
    );

SCESTATUS
SceJetSetCurrentLine(
    IN PSCESECTION hSection,
    IN PWSTR      Value,
    IN DWORD      ValueLen
    );

#define SCEJET_MERGE_TABLE_1        0x10L
#define SCEJET_MERGE_TABLE_2        0x20L
#define SCEJET_LOCAL_TABLE          0x30L

BOOL
ScepIsValidContext(
    PSCECONTEXT context
    );

SCESTATUS
SceJetGetGpoNameByID(
    IN PSCECONTEXT cxtProfile,
    IN LONG GpoID,
    OUT PWSTR Name OPTIONAL,
    IN OUT LPDWORD pNameLen,
    OUT PWSTR DisplayName OPTIONAL,
    IN OUT LPDWORD pDispNameLen
    );

LONG
SceJetGetGpoIDByName(
    IN PSCECONTEXT cxtProfile,
    IN PWSTR       szGpoName,
    IN BOOL        bAdd
    );

SCESTATUS
SceJetGetGpoID(
    IN PSCESECTION hSection,
    IN PWSTR      ObjectName,
    IN JET_COLUMNID JetColGpoID OPTIONAL,
    OUT LONG      *pGpoID
    );

#ifdef __cplusplus
}
#endif

#endif  // _SCEJETP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\scep.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scep.h

Abstract:

    This module defines the data structures and function prototypes
    for the security managment utility

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#ifndef _scep_
#define _scep_

#include "splay.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// system variables
//

#define SCE_RENAME_ADMIN       1
#define SCE_RENAME_GUEST       2
#define SCE_DISABLE_ADMIN      3
#define SCE_DISABLE_GUEST      4

#define SCE_CASE_DONT_CARE    0
#define SCE_CASE_REQUIRED     1
#define SCE_CASE_PREFERED     2

typedef struct _LOCAL_ROOT {
   TCHAR drive[5];
   BOOL  boot;
   BOOL  aclSupport;
} LOCAL_ROOT;

typedef enum _SCE_ATTACHMENT_TYPE_ {

   SCE_ATTACHMENT_SERVICE,
   SCE_ATTACHMENT_POLICY

} SCE_ATTACHMENT_TYPE;

typedef enum _SECURITY_OPEN_TYPE
{
    READ_ACCESS_RIGHTS = 0,
    WRITE_ACCESS_RIGHTS,
    MODIFY_ACCESS_RIGHTS,
} SECURITY_OPEN_TYPE, *PSECURITY_OPEN_TYPE;

//
// data structures used for secmgr
//
typedef struct _SCE_OBJECT_TREE {
    PWSTR                       Name;
    PWSTR                       ObjectFullName;
    BOOL                        IsContainer;
    BYTE                        Status;
    SECURITY_INFORMATION        SeInfo;
    PSECURITY_DESCRIPTOR        pSecurityDescriptor;
    PSECURITY_DESCRIPTOR        pApplySecurityDescriptor;
    PWSTR                       *aChildNames;
    DWORD                       dwSize_aChildNames;
    struct _SCE_OBJECT_CHILD_LIST *ChildList;
    struct _SCE_OBJECT_TREE *Parent;
}SCE_OBJECT_TREE, *PSCE_OBJECT_TREE;


typedef struct _SCE_OBJECT_CHILD_LIST {

    PSCE_OBJECT_TREE                Node;
    struct _SCE_OBJECT_CHILD_LIST   *Next;

} SCE_OBJECT_CHILD_LIST, *PSCE_OBJECT_CHILD_LIST;

typedef enum _SCE_SUBOBJECT_TYPE {

    SCE_ALL_CHILDREN,
    SCE_IMMEDIATE_CHILDREN

} SCE_SUBOBJECT_TYPE;

//
// prototypes defined in misc.c
//

NTSTATUS
ScepOpenSamDomain(
    IN ACCESS_MASK  ServerAccess,
    IN ACCESS_MASK  DomainAccess,
    OUT PSAM_HANDLE pServerHandle,
    OUT PSAM_HANDLE pDomainHanele,
    OUT PSID        *DomainSid,
    OUT PSAM_HANDLE pBuiltinDomainHandle OPTIONAL,
    OUT PSID        *BuiltinDomainSid OPTIONAL
    );

NTSTATUS
ScepLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSCE_NAME_LIST NameList,
    OUT PUNICODE_STRING *Names,
    OUT PULONG *RIDs,
    OUT PSID_NAME_USE *Use,
    OUT PULONG CountOfName
    );


NTSTATUS
ScepGetLsaDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo,
    PPOLICY_PRIMARY_DOMAIN_INFO *PolicyPrimaryDomainInfo
    );

DWORD
ScepGetTempDirectory(
    IN PWSTR HomeDir,
    OUT PWSTR TempDirectory
    );

VOID
ScepConvertLogonHours(
    IN PSCE_LOGON_HOUR   pLogonHours,
    OUT PUCHAR LogonHourBitMask
    );

DWORD
ScepConvertToSceLogonHour(
    IN PUCHAR LogonHourBitMask,
    OUT PSCE_LOGON_HOUR   *pLogonHours
    );

NTSTATUS
ScepGetGroupsForAccount(
    IN SAM_HANDLE       DomainHandle,
    IN SAM_HANDLE       BuiltinDomainHandle,
    IN SAM_HANDLE       UserHandle,
    IN PSID             AccountSid,
    OUT PSCE_NAME_LIST      *GroupList
    );

ACCESS_MASK
ScepGetDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN SECURITY_INFORMATION SecurityInfo
    );

#define SCE_ACCOUNT_SID         0x1
#define SCE_ACCOUNT_SID_STRING  0x2

SCESTATUS
ScepGetProfileOneArea(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN DWORD dwAccountFormat,
    OUT PSCE_PROFILE_INFO *ppInfoBuffer
    );

SCESTATUS
ScepGetOneSection(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR Name,
    IN SCETYPE ProfileType,
    OUT PVOID *ppInfo
    );

NTSTATUS
ScepGetUserAccessAddress(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSID AccountSid,
    OUT PACCESS_MASK *pUserAccess,
    OUT PACCESS_MASK *pEveryone
    );

BOOL
ScepLastBackSlash(
    IN PWSTR Name
    );

DWORD
ScepGetUsersHomeDirectory(
    IN UNICODE_STRING AssignedHomeDir,
    IN PWSTR UserProfileName,
    OUT PWSTR *UserHomeDir
    );

DWORD
ScepGetUsersTempDirectory(
    IN PWSTR UserProfileName,
    OUT PWSTR *UserTempDir
    );

DWORD
ScepGetUsersProfileName(
    IN UNICODE_STRING AssignedProfile,
    IN PSID AccountSid,
    IN BOOL bDefault,
    OUT PWSTR *UserProfilePath
    );

SCESTATUS
ScepGetRegKeyCase(
    IN PWSTR ObjName,
    IN DWORD BufOffset,
    IN DWORD BufLen
    );

SCESTATUS
ScepGetFileCase(
    IN PWSTR ObjName,
    IN DWORD BufOffset,
    IN DWORD BufLen
    );

SCESTATUS
ScepGetGroupCase(
    IN OUT PWSTR GroupName,
    IN DWORD Length
    );

//
// prototypes defined in pfget.c
//

SCESTATUS
ScepGetUserSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR Name,
    OUT PVOID *ppInfo,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepWriteObjectSecurity(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PSCE_OBJECT_SECURITY ObjSecurity
    );

//
// function defined in inftojet.c
//

SCESTATUS
SceJetConvertInfToJet(
    IN PCWSTR InfFile,
    IN LPSTR JetDbName,
    IN SCEJET_CREATE_TYPE Flags,
    IN DWORD Options,
    IN AREA_INFORMATION Area
    );

SCESTATUS
ScepDeleteInfoForAreas(
    IN PSCECONTEXT hProfile,
    IN SCETYPE tblType,
    IN AREA_INFORMATION Area
    );
//
// analyze.cpp
//

DWORD
ScepCompareAndAddObject(
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo,
    IN BOOL AddObject,
    OUT PBYTE IsDifferent OPTIONAL
    );

DWORD
ScepGetNamedSecurityInfo(
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN SECURITY_INFORMATION ProfileSeInfo,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

DWORD
ScepSaveDsStatusToSection(
    IN PWSTR ObjectName,
    IN BOOL  IsContainer,
    IN BYTE  Flag,
    IN PWSTR Value,
    IN DWORD ValueLen
    );

SCESTATUS
ScepSaveMemberMembershipList(
    IN LSA_HANDLE LsaPolicy,
    IN PCWSTR szSuffix,
    IN PWSTR GroupName,
    IN DWORD GroupLen,
    IN PSCE_NAME_LIST pList,
    IN INT Status
    );

SCESTATUS
ScepRaiseErrorString(
    IN PSCESECTION hSectionIn OPTIONAL,
    IN PWSTR KeyName,
    IN PCWSTR szSuffix OPTIONAL
    );

// DsObject.cpp

SCESTATUS
ScepConfigureDsSecurity(
    IN PSCE_OBJECT_TREE   pObject
    );

DWORD
ScepAnalyzeDsSecurity(
    IN PSCE_OBJECT_TREE pObject
    );

SCESTATUS
ScepEnumerateDsObjectRoots(
    IN PLDAP pLdap OPTIONAL,
    OUT PSCE_OBJECT_LIST *pRoots
    );

DWORD
ScepConvertJetNameToLdapCase(
    IN PWSTR JetName,
    IN BOOL bLastComponent,
    IN BYTE bCase,
    OUT PWSTR *LdapName
    );

SCESTATUS
ScepLdapOpen(
    OUT PLDAP *pLdap OPTIONAL
    );

SCESTATUS
ScepLdapClose(
    IN OUT PLDAP *pLdap OPTIONAL
    );

SCESTATUS
ScepDsObjectExist(
    IN PWSTR ObjectName
    );

SCESTATUS
ScepEnumerateDsOneLevel(
    IN PWSTR ObjectName,
    OUT PSCE_NAME_LIST *pNameList
    );

// dsgroups.cpp

SCESTATUS
ScepConfigDsGroups(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepAnalyzeDsGroups(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership
    );

//
// editsave.cpp
//

BYTE
ScepGetObjectAnalysisStatus(
    IN PSCESECTION hSection,
    IN PWSTR KeyName,
    IN BOOL bLookForParent
    );

//
// config.cpp
//
#define SCE_BUILD_IGNORE_UNKNOWN        0x1
#define SCE_BUILD_ACCOUNT_SID           0x2
#define SCE_BUILD_ENUMERATE_PRIV        0x4
#define SCE_BUILD_ACCOUNT_SID_STRING    0x8

NTSTATUS
ScepBuildAccountsToRemove(
    IN LSA_HANDLE PolicyHandle,
    IN DWORD PrivLowMask,
    IN DWORD PrivHighMask,
    IN DWORD dwBuildRule,
    IN PSCE_PRIVILEGE_VALUE_LIST pTemplateList OPTIONAL,
    IN DWORD Options OPTIONAL,
    IN OUT PSCEP_SPLAY_TREE pIgnoreAccounts OPTIONAL,
    OUT PSCE_PRIVILEGE_VALUE_LIST *pRemoveList
    );

SCESTATUS
ScepEnumAttachmentSections(
    IN PSCECONTEXT cxtProfile,
    OUT PSCE_NAME_LIST *ppList
    );

SCESTATUS
ScepConvertFreeTextAccountToSid(
    IN OUT LSA_HANDLE *pPolicyHandle,
    IN PWSTR mszAccounts,
    IN ULONG dwLen,
    OUT PWSTR *pmszNewAccounts,
    OUT DWORD *pNewLen
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\scerpc_s_stub.c ===
#include "scerpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\scesrvrc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scesrvrc.h

Abstract:

    This module defines resource IDs for strings

Author:

    Jin Huang (Jinhuang) 17-Sept.-1997

Revision History:

--*/
#ifndef __scedllrc__
#define __scedllrc__

#include "commonrc.h"

#define SCEDLL_SCP_INIT_ERROR               7101
#define SCEDLL_SCP_INIT_SUCCESS             7102
#define SCEDLL_SCP_READ_PROFILE             7103

#define SCEDLL_SCP_BEGIN_POLICY             7104
#define SCEDLL_SCP_ACCESS_ERROR             7105
#define SCEDLL_SCP_ACCESS_SUCCESS           7106
#define SCEDLL_SCP_AUDIT_ERROR              7107
#define SCEDLL_SCP_AUDIT_SUCCESS            7108

#define SCEDLL_SCP_BEGIN_PRIVILEGES         7109
#define SCEDLL_SCP_PRIVILEGES_ERROR         7110
#define SCEDLL_SCP_PRIVILEGES_SUCCESS       7111

#define SCEDLL_SCP_BEGIN_USERSETTING        7112
#define SCEDLL_SCP_USERSETTING_ERROR        7113
#define SCEDLL_SCP_USERSETTING_SUCCESS      7114

#define SCEDLL_SCP_BEGIN_GROUPMGMT          7115
#define SCEDLL_SCP_GROUPMGMT_ERROR          7116
#define SCEDLL_SCP_GROUPMGMT_SUCCESS        7117

#define SCEDLL_SCP_BEGIN_REGISTRY           7118
#define SCEDLL_SCP_REGISTRY_ERROR           7119
#define SCEDLL_SCP_REGISTRY_SUCCESS         7120

#define SCEDLL_SCP_BEGIN_FILE               7121
#define SCEDLL_SCP_FILE_ERROR               7122
#define SCEDLL_SCP_FILE_SUCCESS             7123

#define SCEDLL_SCP_BEGIN_DS                 7124
#define SCEDLL_SCP_DS_ERROR                 7125
#define SCEDLL_SCP_DS_SUCCESS               7126

#define SCEDLL_SCP_BEGIN_GENERALSVC         7127
#define SCEDLL_SCP_GENERALSVC_ERROR         7128
#define SCEDLL_SCP_GENERALSVC_SUCCESS       7129

#define SCEDLL_SCP_BEGIN_ATTACHMENT         7130
#define SCEDLL_SCP_ATTACHMENT_ERROR         7131
#define SCEDLL_SCP_ATTACHMENT_SUCCESS       7132

#define SCEDLL_SCP_KERBEROS_ERROR           7133
#define SCEDLL_SCP_KERBEROS_SUCCESS         7134

#define SCEDLL_SCP_REGVALUES_ERROR          7135
#define SCEDLL_SCP_REGVALUES_SUCCESS        7136

#define SCEDLL_SCP_UNINIT                   7137

#define SCEDLL_SCP_ADMIN_NOT_ALLOWED        7138
#define SCEDLL_SCP_GUEST_NOT_ALLOWED        7139
#define SCEDLL_SCP_ADD                      7140
#define SCEDLL_SCP_ADDTO                    7141
#define SCEDLL_SCP_CANNOT_REMOVE            7142
#define SCEDLL_SCP_CONFIGURE                7143
#define SCEDLL_SCP_ERROR_ADD                7144
#define SCEDLL_SCP_ERROR_ADDTO              7145
#define SCEDLL_SCP_ERROR_ADMINISTRATOR      7146
#define SCEDLL_SCP_ERROR_CONFIGURE          7147
#define SCEDLL_SCP_ERROR_EVENT_AUDITING     7148
#define SCEDLL_SCP_ERROR_GUEST              7149
#define SCEDLL_SCP_ERROR_LOGSETTINGS        7150
#define SCEDLL_SCP_ERROR_KERBEROS           7151
#define SCEDLL_SCP_ERROR_LOCKOUT            7152
#define SCEDLL_SCP_ERROR_LOGOFF             7153
#define SCEDLL_SCP_ERROR_PASSWORD           7154
#define SCEDLL_SCP_ERROR_REMOVE             7155
#define SCEDLL_SCP_ERROR_UAS                7156
#define SCEDLL_SCP_ERROR_USERSETTINGS       7157
#define SCEDLL_SCP_EVENT_AUDITING           7158
#define SCEDLL_SCP_KERBEROS                 7159
#define SCEDLL_SCP_LOCKOUT                  7160
#define SCEDLL_SCP_LOGOFF                   7161
#define SCEDLL_SCP_LOGSETTINGS              7162
#define SCEDLL_SCP_NOT_SUPPORT              7163
#define SCEDLL_SCP_OTHER_POLICY             7164
#define SCEDLL_SCP_PASSWORD                 7165
#define SCEDLL_SCP_REMOVE                   7166
#define SCEDLL_SCP_RENAME_ADMIN             7167
#define SCEDLL_SCP_RENAME_GUEST             7168
#define SCEDLL_SCP_TAKE_OWNER               7169
#define SCEDLL_SCP_UAS                      7170
#define SCEDLL_SCP_USERSETTINGS             7171
#define SCEDLL_SCP_ERROR_REGVALUES          7172
#define SCEDLL_SCP_ERROR_STOP               7173
#define SCEDLL_SCP_ERROR_OPENFORSTOP        7174
#define SCEDLL_SCP_DISABLE_ADMIN            7175
#define SCEDLL_SCP_ENABLE_ADMIN             7176
#define SCEDLL_SCP_DISABLE_GUEST            7177
#define SCEDLL_SCP_ENABLE_GUEST             7178

#define SCEDLL_SAP_INIT_ERROR               7180
#define SCEDLL_SAP_INIT_SUCCESS             7181
#define SCEDLL_SAP_READ_PROFILE             7182

#define SCEDLL_SAP_BEGIN_POLICY             7183
#define SCEDLL_SAP_ACCESS_ERROR             7184
#define SCEDLL_SAP_ACCESS_SUCCESS           7185
#define SCEDLL_SAP_AUDIT_ERROR              7186
#define SCEDLL_SAP_AUDIT_SUCCESS            7187
#define SCEDLL_SAP_POLICY_ERROR             7188

#define SCEDLL_SAP_BEGIN_PRIVILEGES         7189
#define SCEDLL_SAP_PRIVILEGES_ERROR         7190
#define SCEDLL_SAP_PRIVILEGES_SUCCESS       7191

#define SCEDLL_SAP_BEGIN_USERSETTING        7192
#define SCEDLL_SAP_USERSETTING_ERROR        7193
#define SCEDLL_SAP_USERSETTING_SUCCESS      7194

#define SCEDLL_SAP_BEGIN_GROUPMGMT          7195
#define SCEDLL_SAP_GROUPMGMT_ERROR          7196
#define SCEDLL_SAP_GROUPMGMT_SUCCESS        7197

#define SCEDLL_SAP_BEGIN_REGISTRY           7198
#define SCEDLL_SAP_REGISTRY_ERROR           7199
#define SCEDLL_SAP_REGISTRY_SUCCESS         7200

#define SCEDLL_SAP_BEGIN_FILE               7201
#define SCEDLL_SAP_FILE_ERROR               7202
#define SCEDLL_SAP_FILE_SUCCESS             7203

#define SCEDLL_SAP_BEGIN_DS                 7204
#define SCEDLL_SAP_DS_ERROR                 7205
#define SCEDLL_SAP_DS_SUCCESS               7206

#define SCEDLL_SAP_BEGIN_GENERALSVC         7207
#define SCEDLL_SAP_GENERALSVC_ERROR         7208
#define SCEDLL_SAP_GENERALSVC_SUCCESS       7209

#define SCEDLL_SAP_BEGIN_ATTACHMENT         7210
#define SCEDLL_SAP_ATTACHMENT_ERROR         7211
#define SCEDLL_SAP_ATTACHMENT_SUCCESS       7212

#define SCEDLL_SAP_KERBEROS_ERROR           7213
#define SCEDLL_SAP_KERBEROS_SUCCESS         7214

#define SCEDLL_SAP_REGVALUES_ERROR          7215
#define SCEDLL_SAP_REGVALUES_SUCCESS        7216

#define SCEDLL_SAP_UNINIT                   7217

#define SCEDLL_SAP_ANALYZE                  7220
#define SCEDLL_SAP_ERROR_ACL                7221
#define SCEDLL_SAP_ERROR_ADD                7222
#define SCEDLL_SAP_ERROR_ADMINISTRATOR      7223
#define SCEDLL_SAP_ERROR_ANALYZE            7224
#define SCEDLL_SAP_ERROR_ENUMERATE          7225
#define SCEDLL_SAP_ERROR_EVENT_AUDITING     7226
#define SCEDLL_SAP_ERROR_GUEST              7227
#define SCEDLL_SAP_ERROR_KERBEROS           7228
#define SCEDLL_SAP_ERROR_LOCKOUT            7229
#define SCEDLL_SAP_ERROR_LOGOFF             7230
#define SCEDLL_SAP_ERROR_OUT                7231
#define SCEDLL_SAP_ERROR_PASSWORD           7232
#define SCEDLL_SAP_ERROR_SAVE               7233
#define SCEDLL_SAP_ERROR_SECURITY           7234
#define SCEDLL_SAP_ERROR_UAS                7235
#define SCEDLL_SAP_EVENT_AUDITING           7236
#define SCEDLL_SAP_IGNORE_TEMPLATE          7237
#define SCEDLL_SAP_KERBEROS                 7238
#define SCEDLL_SAP_LOCKOUT                  7239
#define SCEDLL_SAP_LOGOFF                   7240
#define SCEDLL_SAP_LOGSETTINGS              7241
#define SCEDLL_SAP_NOT_SUPPORT              7242
#define SCEDLL_SAP_OTHER_POLICY             7243
#define SCEDLL_SAP_PASSWORD                 7244
#define SCEDLL_SAP_START_SECTION            7245
#define SCEDLL_SAP_UAS                      7246
#define SCEDLL_SAP_ERROR_LSA_ANON_LOOKUP    7247

#define SCEDLL_ACCOUNT_DOMAIN               7250
#define SCEDLL_ADMIN_LOGON                  7251
#define SCEDLL_ADMINISTRATORS_SID           7252
#define SCEDLL_BEGIN_INIT                   7253
#define SCEDLL_BEGIN_RECOVERY               7254
#define SCEDLL_CANNOT_FIND                  7255
#define SCEDLL_CREATE_TABLE                 7256
#define SCEDLL_DELETE_TABLE                 7257
#define SCEDLL_ENGINE_STATUS_RESET          7258
#define SCEDLL_ERROR_ADJUST                 7259
#define SCEDLL_ERROR_ALIAS_MEMBER           7260
#define SCEDLL_ERROR_ALIAS_MEMBEROF         7261
#define SCEDLL_ERROR_ANALYZE_MEMBEROF       7262
#define SCEDLL_ERROR_ANALYZE_MEMBERS        7263
#define SCEDLL_ERROR_BUILD_SD               7264
#define SCEDLL_ERROR_COMPUTESD              7265
#define SCEDLL_ERROR_CONVERT                7266
#define SCEDLL_ERROR_CONVERT_LDAP           7267
#define SCEDLL_ERROR_CONVERT_SECTION        7268
#define SCEDLL_ERROR_CREATE                 7269
#define SCEDLL_ERROR_DELETE                 7270
#define SCEDLL_ERROR_GENERATE               7271
#define SCEDLL_ERROR_IGNORE_POLICY          7249
#define SCEDLL_ERROR_LOAD                   7272
#define SCEDLL_ERROR_LOOKUP                 7273
#define SCEDLL_ERROR_OPEN                   7274
#define SCEDLL_ERROR_PROCESS_UNICODE        7275
#define SCEDLL_ERROR_QUERY_EVENT_AUDITING   7276
#define SCEDLL_ERROR_QUERY_INFO             7277
#define SCEDLL_ERROR_QUERY_LOCKOUT          7278
#define SCEDLL_ERROR_QUERY_LOGOFF           7279
#define SCEDLL_ERROR_QUERY_LOGSETTINGS      7280
#define SCEDLL_ERROR_QUERY_PASSWORD         7281
#define SCEDLL_ERROR_QUERY_SECURITY         7282
#define SCEDLL_ERROR_QUERY_UAS              7283
#define SCEDLL_ERROR_QUERY_VOLUME           7284
#define SCEDLL_ERROR_SAVE_REGISTRY          7285
#define SCEDLL_ERROR_SET_INFO               7286
#define SCEDLL_ERROR_SET_SECURITY           7287
#define SCEDLL_ERROR_START_TRANS            7288
#define SCEDLL_ERROR_TAKE_OWNER             7289
#define SCEDLL_ERROR_USER_MEMBER            7290
#define SCEDLL_ERROR_WRITE_INFO             7291
#define SCEDLL_EVENT_IS_OFF                 7292
#define SCEDLL_EVENT_RESTORED               7293
#define SCEDLL_FIND_DBLOCATION              7294
#define SCEDLL_GENERATE_TEMPLATE            7295
#define SCEDLL_INVALID_GROUP                7296
#define SCEDLL_INVALID_PATH                 7297
#define SCEDLL_INVALID_SECURITY             7298
#define SCEDLL_INVALID_USER                 7299
#define SCEDLL_LOAD_ATTACHMENT              7300
#define SCEDLL_LOGFILE_INVALID              7301
#define SCEDLL_LSA_POLICY                   7302
#define SCEDLL_NO_ACL_SUPPORT               7303
#define SCEDLL_NO_DETAIL                    7304
#define SCEDLL_NO_MAPPINGS                  7305
#define SCEDLL_NOT_GROUP                    7306
#define SCEDLL_PROCESS_TEMPLATE             7307
#define SCEDLL_SEPARATOR                    7308
#define SCEDLL_TAB_SEPARATOR                7309
#define SCEDLL_TIMESTAMP_ERROR              7310
#define SCEDLL_TOTAL_TICKS_ERROR            7311
#define SCEDLL_UNKNOWN_DBLOCATION           7312
#define SCEDLL_UNKNOWN_LOGON_USER           7313
#define SCEDLL_USER_OBJECT                  7314
#define SCEDLL_USERRIGHT_NOT_DEFINED        7315
#define SCEDLL_PROCESS                      7316
#define SCEDLL_COPY_LOCAL                   7317
#define SCEDLL_ERROR_COPY                   7318
#define SCEDLL_ERROR_DELETE_DB              7319
#define SCEDLL_ERROR_RECOVER_DB             7320

#define SCEDLL_STATUS_ERROR                 7321
#define SCEDLL_STATUS_MATCH                 7322
#define SCEDLL_STATUS_MISMATCH              7323
#define SCEDLL_STATUS_NC                    7324
#define SCEDLL_STATUS_NEW                   7325
#define SCEDLL_STATUS_NOACL                 7326

#define SCESRV_ALIAS_NAME_SERVER_OPS        7370
#define SCESRV_ALIAS_NAME_ACCOUNT_OPS       7371
#define SCESRV_ALIAS_NAME_PRINT_OPS         7372
#define SCESRV_ALIAS_CREATE                 7373
#define SCESRV_ALIAS_UNSUPPORTED            7374

#define SCEDLL_COPY_DEFAULT                 7380
#define SCEDLL_ERROR_COPY_DEFAULT           7381

#define IDS_WARNING                         7385
#define IDS_ERROR                           7386

#define IDS_REGISTRY_DELAY_FILTER           7387
#define IDS_ERROR_LOOKUP                    7388
#define IDS_ERROR_CONVERT_SID               7389
#define IDS_COPY_DOMAIN_GPO                 7390
#define IDS_COPY_OU_GPO                     7391
#define IDS_COPY_PRIVILEGE_UPGRADE          7392
#define IDS_COPY_PRIVILEGE_FRESH            7393
#define IDS_ERROR_GET_PROCADDR              7394
#define IDS_COPY_ONE_PRIVILEGE              7395

#define IDS_NO_ANALYSIS                     7396
#define IDS_NO_ANALYSIS_FRESH               7397
#define IDS_ANALYSIS_MISMATCH               7398
#define IDS_ERROR_OPEN_LOG                  7399
#define IDS_ERROR_BIND                      7400
#define IDS_FAIL                            7401

#define SCESRV_POLICY_TATTOO_PREPARE        7405
#define SCESRV_POLICY_TATTOO_ERROR_RESET    7406
#define SCESRV_POLICY_TATTOO_CHECK          7407
#define SCESRV_POLICY_TATTOO_ERROR_CREATE   7408
#define SCESRV_POLICY_TATTOO_ERROR_SETTING  7409
#define SCESRV_POLICY_TATTOO_ERROR_QUERY    7410
#define SCESRV_POLICY_TATTOO_REMOVE_SETTING 7411
#define SCESRV_POLICY_TATTOO_EXIST          7412
#define SCESRV_POLICY_TATTOO_NONEXIST       7413
#define SCESRV_POLICY_TATTOO_QUERY          7414
#define SCESRV_POLICY_TATTOO_ADD            7415
#define SCESRV_POLICY_TATTOO_ERROR_REMOVE   7416
#define SCESRV_POLICY_TATTOO_ARRAY          7417

#define SCEDLL_SCP_BEGIN_REGISTRY_64KEY     7418
#define SCEDLL_SCP_BEGIN_REGISTRY_32KEY     7419

#define SCESRV_ENFORCE_DENY_LOCAL_RIGHT     7420
#define SCESRV_ENFORCE_DENY_NETWORK_RIGHT   7421
#define SCESRV_ENFORCE_NETWORK_RIGHT        7422
#define SCESRV_ENFORCE_LOCAL_RIGHT          7423
#define SCESRV_ERROR_ENFORCE_NETWORK_RIGHT  7424
#define SCESRV_ERROR_ENFORCE_LOCAL_RIGHT    7425

#define SCESRV_POLICY_PENDING_SAM           7430
#define SCESRV_POLICY_PENDING_AUDIT         7431
#define SCESRV_POLICY_PENDING_REMOVE_RIGHTS 7432
#define SCESRV_POLICY_PENDING_RIGHTS        7433
#define SCESRV_POLICY_PENDING_QUERY         7434
#define SCESRV_ERROR_PRIVATE_LSA            7435
#define SCESRV_ERROR_QUERY_ACCOUNT_RIGHTS   7436

#define IDS_ERROR_SAVE_POLICY_GPO_ACCOUNT   7437
#define IDS_ERROR_SAVE_POLICY_GPO_OTHER     7438
#define SCESRV_POLICY_ERROR_SPLAY_INITIALIZE  7439

#define SCEDLL_CONVERT_ROOT_NON_NTFS            7450
#define SCEDLL_CONVERT_ROOT_ERROR_QUERY_VOLUME  7451
#define SCEDLL_CONVERT_ROOT_NOT_FIXED_VOLUME    7452
#define SCEDLL_CONVERT_ROOT_NTFS_VOLUME         7453
#define SCEDLL_CONVERT_ERROR_PROFILES_DIR       7454
#define SCEDLL_CONVERT_SUCCESS_PROFILES_DIR     7455
#define SCEDLL_CONVERT_ERROR_TEMPLATE_APPLY     7456
#define SCEDLL_CONVERT_SUCCESS_TEMPLATE_APPLY   7457
#define SCEDLL_CONVERT_ERROR_DACL               7458
#define SCEDLL_CONVERT_ERROR_MARTA              7459
#define SCEDLL_CONVERT_ERROR_EVENT_WAIT         7460
#define SCEDLL_CONVERT_SUCCESS_EVENT_WAIT       7461
#define SCEDLL_CONVERT_SUCCESS_REGVAL_QUERY     7462
#define SCEDLL_CONVERT_ERROR_REGVAL_QUERY       7463
#define SCEDLL_CONVERT_OUT_OF_MEMORY            7464
#define SCEDLL_CONVERT_NOTEXIST_REGVAL          7465
#define SCEDLL_CONVERT_STATUS_CREATING_THREAD    7466
#define SCEDLL_CONVERT_SUCCESS_MARTA       7467

#define IDS_ERROR_CONVERT_PARAMETER         7470
#define IDS_ERROR_CONVERT_BAD_ENV_VAR       7471
#define IDS_INFO_CONVERT_DRIVE              7472
#define IDS_ERROR_CONVERT_PROD_TYPE         7473

#define SCEDLL_CONVERT_BAD_ENV_VAR          7474
#define SCEDLL_CONVERT_ERROR_DLL_FUNCTION   7475
#define SCEDLL_CONVERT_ERROR_DLL_LOAD       7476
#define SCEDLL_CONVERT_ERROR_EVENT_HANDLE   7477
#define SCEDLL_CONVERT_PROD_TYPE    7478

#define SCEDLL_ERROR_QUERYING_ACCOUNT_RIGHTS 7479
#define SCESRV_POLICY_TATTOO_NOT_REMOVE_MEMBERS  7480
#define IDS_FREE_DISK_SPACE                  7481

#define SCEDLL_SCP_ERROR_LSAPOLICY_QUERY        7490
#define SCEDLL_SCP_ERROR_LSAPOLICY_SET          7491
#define SCEDLL_SCP_ERROR_LSAPOLICY_BUILDDACL    7492
#define SCEDLL_SCP_ERROR_LSAPOLICY_SD_INIT      7493
#define SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ        7494
#define SCEDLL_SCP_INFO_LSAPOLICY_EXISTING_SDDL       7495
#define SCEDLL_SCP_INFO_LSAPOLICY_COMPUTED_SDDL       7496

#define SCEDLL_SCP_LSAPOLICY    7497
#define SCEDLL_SAP_LSAPOLICY    7498

#define SCEDLL_SCP_ERROR_DISABLE_ADMIN      7500
#define SCEDLL_SCP_ERROR_DISABLE_GUEST      7501
#define SCEDLL_SAP_ERROR_DISABLE_ADMIN      7502
#define SCEDLL_SAP_ERROR_DISABLE_GUEST      7503

#define SCEDLL_CANNOT_FIND_INDS             7505
#define SCEDLL_EMPTY_MEMBERSHIP             7506
#define SCEDLL_SCP_ERROR_NOREMOVE           7507

#define SCESRV_SETUPUPD_ERROR_LMCOMPAT      7508
#define SCESRV_SETUPUPD_IGNORE_LMCOMPAT     7509

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\service.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    Routines to configure/analyze general settings of services plus
    some helper APIs

Author:

    Jin Huang (jinhuang) 25-Jun-1997

Revision History:

--*/
#include "headers.h"
#include "serverp.h"
#include "service.h"
#include "pfp.h"

//#define SCESVC_DBG 1



SCESTATUS
ScepConfigureGeneralServices(
    IN PSCECONTEXT hProfile,
    IN PSCE_SERVICES pServiceList,
    IN DWORD ConfigOptions
    )
/*
Routine Descripton:

    Configure startup and security descriptor settings for the list of
    services passed in.

Arguments:

    pServiceList - the list of services to configure

Return Value:

    SCE status
*/
{
    SCESTATUS      SceErr=SCESTATUS_SUCCESS;
    PSCE_SERVICES  pNode;
    DWORD          nServices=0;
    BOOL           bDoneSettingSaclDacl = FALSE;
    NTSTATUS  NtStatus = 0;
    SID_IDENTIFIER_AUTHORITY IdAuth=SECURITY_NT_AUTHORITY;
    DWORD          rcSaveRsop = ERROR_SUCCESS;

    PSCESECTION    hSectionDomain=NULL;
    PSCESECTION    hSectionTattoo=NULL;
    PSCE_SERVICES  pServiceCurrent=NULL;
    DWORD          ServiceLen=0;


    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    if ( pServiceList != NULL ) {

        SC_HANDLE hScManager;
        //
        // open the manager
        //
        hScManager = OpenSCManager(
                        NULL,
                        NULL,
                        SC_MANAGER_ALL_ACCESS
//                        SC_MANAGER_CONNECT |
//                        SC_MANAGER_QUERY_LOCK_STATUS |
//                        SC_MANAGER_MODIFY_BOOT_CONFIG
                        );

        SC_HANDLE hService=NULL;
        DWORD rc=NO_ERROR;

        if ( NULL == hScManager ) {

            rc = GetLastError();
            ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, L"Service Control Manager");

            ScepPostProgress(TICKS_GENERAL_SERVICES,
                             AREA_SYSTEM_SERVICE,
                             NULL);

            return( ScepDosErrorToSceStatus(rc) );
        }

        LPQUERY_SERVICE_CONFIG pConfig=NULL;
        DWORD BytesNeeded;

        //
        // Adjust privilege for setting SACL
        //
        rc = SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, NULL );

        //
        // if can't adjust privilege, ignore (will error out later if SACL is requested)
        //

        if ( rc != NO_ERROR ) {

            ScepLogOutput3(1, rc, SCEDLL_ERROR_ADJUST, L"SE_SECURITY_PRIVILEGE");
            rc = NO_ERROR;
        }

        //
        // Adjust privilege for setting ownership (if required)
        //
        rc = SceAdjustPrivilege( SE_TAKE_OWNERSHIP_PRIVILEGE, TRUE, NULL );

        //
        // if can't adjust privilege, ignore (will error out later if acls need to be written)
        //

        if ( rc != NO_ERROR ) {

            ScepLogOutput3(1, rc, SCEDLL_ERROR_ADJUST, L"SE_TAKE_OWNERSHIP_PRIVILEGE");
            rc = NO_ERROR;
        }

        //
        // get AdminsSid in case need to take ownership later
        //
        NtStatus = RtlAllocateAndInitializeSid(
            &IdAuth,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            &AdminsSid );

        //
        // open the policy/tattoo tables
        //
        if ( ConfigOptions & SCE_POLICY_TEMPLATE ) {

            ScepTattooOpenPolicySections(
                          hProfile,
                          szServiceGeneral,
                          &hSectionDomain,
                          &hSectionTattoo
                          );
        }

        //
        // Loop through each service to set general setting
        //
        for ( pNode=pServiceList;
              pNode != NULL && rc == NO_ERROR; pNode = pNode->Next ) {
            //
            // print the service name
            //
            if ( nServices < TICKS_GENERAL_SERVICES ) {
                ScepPostProgress(1,
                             AREA_SYSTEM_SERVICE,
                             pNode->ServiceName);
                nServices++;
            }

            ScepLogOutput3(2,0, SCEDLL_SCP_CONFIGURE, pNode->ServiceName);

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                 ScepIsSystemShutDown() ) {

                rc = ERROR_NOT_SUPPORTED;
                break;
            }

            ServiceLen = 0;
            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                 hSectionDomain && hSectionTattoo ) {
                //
                // check if we need to query current setting for the service
                //
                ServiceLen = wcslen(pNode->ServiceName);

                if ( ScepTattooIfQueryNeeded(hSectionDomain, hSectionTattoo,
                                             pNode->ServiceName, ServiceLen, NULL, NULL ) ) {

                    rc = ScepQueryAndAddService(
                                hScManager,
                                pNode->ServiceName,
                                NULL,
                                &pServiceCurrent
                                );
                    if ( ERROR_SUCCESS != rc ) {
                        ScepLogOutput3(1,0,SCESRV_POLICY_TATTOO_ERROR_QUERY,rc,pNode->ServiceName);
                        rc = NO_ERROR;
                    } else {
                        ScepLogOutput3(3,0,SCESRV_POLICY_TATTOO_QUERY,pNode->ServiceName);
                    }
                }
            }

            bDoneSettingSaclDacl = FALSE;
            rcSaveRsop = ERROR_SUCCESS;
            //
            // open the service
            //
            hService = OpenService(
                            hScManager,
                            pNode->ServiceName,
                            SERVICE_QUERY_CONFIG |
                            SERVICE_CHANGE_CONFIG |
                            READ_CONTROL |
                            WRITE_DAC |
//                            WRITE_OWNER |               owner can't be set for a service
                            ACCESS_SYSTEM_SECURITY
                           );

            // if access was denied, try to take ownership
            // and try to open service again

            if (hService == NULL &&
                (ERROR_ACCESS_DENIED == (rc = GetLastError())) &&
                pNode->General.pSecurityDescriptor) {

                DWORD   rcTakeOwnership = NO_ERROR;

                if (AdminsSid) {

                    if ( NO_ERROR == (rcTakeOwnership = SetNamedSecurityInfo(
                        (LPWSTR)pNode->ServiceName,
                        SE_SERVICE,
                        OWNER_SECURITY_INFORMATION,
                        AdminsSid,
                        NULL,
                        NULL,
                        NULL
                        ))) {

                        //
                        // ownership changed, open service again and set SACL and DACL
                        // get a handle to set security
                        //


                        if ( hService = OpenService(
                                hScManager,
                                pNode->ServiceName,
                                READ_CONTROL |
                                WRITE_DAC |
                                ACCESS_SYSTEM_SECURITY
                                ))  {

                            if ( SetServiceObjectSecurity(
                                        hService,
                                        pNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                        pNode->General.pSecurityDescriptor
                                        ) )  {

                                bDoneSettingSaclDacl = TRUE;

                                CloseServiceHandle(hService);
                                hService = NULL;

                                //
                                // re-open the service only if there are other config info
                                // to set (startup type).
                                // So when NOSTARTTYPE is set, do not need to reopen the service
                                //
                                if (!(ConfigOptions & SCE_SETUP_SERVICE_NOSTARTTYPE)) {

                                    if (!(hService = OpenService(
                                                 hScManager,
                                                 pNode->ServiceName,
                                                 SERVICE_QUERY_CONFIG |
                                                 SERVICE_CHANGE_CONFIG
                                                 )) ) {

                                        rc = GetLastError();
                                    }
                                    else {

                                        //
                                        //clear any error we have seen so far since everything has succeeded
                                        //

                                        rc = NO_ERROR;
                                    }
                                }

                            } else {
                                //
                                // shouldn't fail here unless Service Control Manager
                                // fails for some reason.
                                //
                                rc = GetLastError();

                            }

                        } else {
                            //
                            // still fail to open the service to set DACL. this should
                            // not happen for admin logons since the current logon is
                            // one of the owner. But for normal user logon, this could
                            // fail (actually normal user logon should fail to set
                            // the owner

                            rc = GetLastError();

                        }

                    }

                } else {
                    //
                    // AdminSid failed to be initialized, get the error
                    //
                    rcTakeOwnership = RtlNtStatusToDosError(NtStatus);
                }

                if ( NO_ERROR != rcTakeOwnership || NO_ERROR != rc ) {
                    //
                    // log the error occurred in take ownership process
                    // reset error back to access denied so it will also be
                    // logged as failure to open the service
                    //

                    if (NO_ERROR != rcTakeOwnership)

                        ScepLogOutput3(2,rcTakeOwnership, SCEDLL_ERROR_TAKE_OWNER, (LPWSTR)pNode->ServiceName);

                    else

                        ScepLogOutput3(2, rc, SCEDLL_ERROR_OPEN, (LPWSTR)pNode->ServiceName);

                    rc = ERROR_ACCESS_DENIED;
                }

            }

            if ( hService != NULL ) {

                if (ConfigOptions & SCE_SETUP_SERVICE_NOSTARTTYPE) {
                    //
                    // do not configure service start type
                    //

                    if ( pNode->General.pSecurityDescriptor != NULL ) {

                        if ( !SetServiceObjectSecurity(
                                    hService,
                                    pNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                    pNode->General.pSecurityDescriptor
                                    ) ) {

                            rc = GetLastError();
                        }
                        else
                            bDoneSettingSaclDacl = TRUE;
                    }

                } else {

                    //
                    // query the length of config
                    //
                    if ( !QueryServiceConfig(
                                hService,
                                NULL,
                                0,
                                &BytesNeeded
                                ) ) {

                        rc = GetLastError();

                        if ( rc == ERROR_INSUFFICIENT_BUFFER ) {

                            pConfig = (LPQUERY_SERVICE_CONFIG)ScepAlloc(0, BytesNeeded);

                            if ( pConfig != NULL ) {
                                //
                                // the real query of config
                                //
                                if ( QueryServiceConfig(
                                            hService,
                                            pConfig,
                                            BytesNeeded,
                                            &BytesNeeded
                                            ) ) {
                                    rc = ERROR_SUCCESS;

                                    //
                                    // change pConfig->dwStartType to the new value
                                    //
                                    if ( pNode->Startup != (BYTE)(pConfig->dwStartType) ) {
                                        //
                                        // congigure the service startup
                                        //
                                        if ( !ChangeServiceConfig(
                                                    hService,
                                                    pConfig->dwServiceType,
                                                    pNode->Startup,
                                                    pConfig->dwErrorControl,
                                                    pConfig->lpBinaryPathName,
                                                    pConfig->lpLoadOrderGroup,
                                                    NULL,
                                                    pConfig->lpDependencies,
                                                    pConfig->lpServiceStartName,
                                                    NULL,
                                                    pConfig->lpDisplayName
                                                    ) ) {

                                            rc = GetLastError();

                                        }
                                    }

                                    if ( rc == NO_ERROR &&
                                        pNode->General.pSecurityDescriptor != NULL &&
                                        !bDoneSettingSaclDacl) {

                                        if ( !SetServiceObjectSecurity(
                                                    hService,
                                                    pNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                                    pNode->General.pSecurityDescriptor
                                                    ) ) {

                                            rc = GetLastError();
                                        }
                                        else
                                            bDoneSettingSaclDacl = TRUE;
                                    }

                                } else {

                                    rc = GetLastError();

                                    ScepLogOutput3(3,rc, SCEDLL_ERROR_QUERY_INFO, pNode->ServiceName);
                                }

                                ScepFree(pConfig);
                                pConfig = NULL;

                            } else {
                                //
                                // cannot allocate pConfig
                                //
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        } else {

                            ScepLogOutput3(3,rc, SCEDLL_ERROR_QUERY_INFO, pNode->ServiceName);
                        }

                    } else {
                        //
                        // should not fall in here
                        //
                        rc = ERROR_SUCCESS;
                    }
                }

                CloseServiceHandle (hService);
                hService = NULL;

                if ( rc != NO_ERROR ) {

                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_CONFIGURE, pNode->ServiceName);

                    rcSaveRsop = rc;

                    if ( ERROR_INVALID_OWNER == rc ||
                         ERROR_INVALID_PRIMARY_GROUP == rc ||
                         ERROR_INVALID_SECURITY_DESCR == rc ||
                         ERROR_INVALID_ACL == rc ||
                         ERROR_ACCESS_DENIED == rc ) {

                        gWarningCode = rc;
                        rc = NO_ERROR;
                    }

                } else if ( !(ConfigOptions & SCE_SETUP_SERVICE_NOSTARTTYPE) &&
                            pNode->Startup == SERVICE_DISABLED ) {
                    //
                    // if the service type is "disabled", we should also stop the service
                    //
                    if ( hService = OpenService(
                                        hScManager,
                                        pNode->ServiceName,
                                        SERVICE_STOP
                                        ))  {

                        SERVICE_STATUS ServiceStatus;

                        if (!ControlService(hService,
                                       SERVICE_CONTROL_STOP,
                                       &ServiceStatus
                                      )) {
                            if ( ERROR_SERVICE_NOT_ACTIVE != GetLastError() ) {
                                ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_STOP, pNode->ServiceName);
                            }
                        }

                        CloseServiceHandle (hService);
                        hService = NULL;

                    } else {
                        ScepLogOutput3(2, GetLastError(), SCEDLL_SCP_ERROR_OPENFORSTOP, pNode->ServiceName);
                    }

                }

            } else {
                //
                // cannot open the service or some error taking ownership
                //
                if (rc != NO_ERROR) {
                    ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, pNode->ServiceName);
                    // either of setting security/startup type failed - save it for RSOP log
                    rcSaveRsop = (rcSaveRsop == ERROR_SUCCESS ? rc: rcSaveRsop);
                    if ( rc ==  ERROR_SERVICE_DOES_NOT_EXIST )
                        rc = NO_ERROR;
                }
            }

            if (ConfigOptions & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_SERVICES_INFO,
                        rcSaveRsop != NO_ERROR ? rcSaveRsop : rc,
                        pNode->ServiceName,
                        0,
                        0);

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                 hSectionDomain && hSectionTattoo ) {
                //
                // manage the tattoo value of this one
                //

                ScepTattooManageOneServiceValue(
                                   hSectionDomain,
                                   hSectionTattoo,
                                   pNode->ServiceName,
                                   ServiceLen,
                                   pServiceCurrent,
                                   rc
                                   );
            }

            if ( pServiceCurrent ) {
                SceFreePSCE_SERVICES(pServiceCurrent);
                pServiceCurrent = NULL;
            }
        }

        CloseServiceHandle (hScManager);

        if (AdminsSid) {
            RtlFreeSid(AdminsSid);
            AdminsSid = NULL;
        }

        SceAdjustPrivilege( SE_TAKE_OWNERSHIP_PRIVILEGE, FALSE, NULL );
        SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, FALSE, NULL );

        SceErr = ScepDosErrorToSceStatus(rc);
    }

    if ( nServices < TICKS_GENERAL_SERVICES ) {

        ScepPostProgress(TICKS_GENERAL_SERVICES-nServices,
                         AREA_SYSTEM_SERVICE,
                         NULL);
    }

    SceJetCloseSection(&hSectionDomain, TRUE);
    SceJetCloseSection(&hSectionTattoo, TRUE);

    return(SceErr);

}


SCESTATUS
ScepAnalyzeGeneralServices(
    IN PSCECONTEXT hProfile,
    IN DWORD Options
    )
/*
Routine Description:

    Analyze all available services on the current system.

    The base profile (SCEP) is in hProfile

Arguments:

    hProfile - the database context handle

Return Value:

    SCE status
*/
{
    if ( hProfile == NULL ) {

        ScepPostProgress(TICKS_GENERAL_SERVICES,
                         AREA_SYSTEM_SERVICE,
                         NULL);

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    PSCE_SERVICES pServiceList=NULL;
    DWORD nServices=0;

    rc = SceEnumerateServices( &pServiceList, FALSE );
    rc = ScepDosErrorToSceStatus(rc);

    if ( rc == SCESTATUS_SUCCESS ) {

        PSCESECTION hSectionScep=NULL, hSectionSap=NULL;
        //
        // open the sap section. If it is not there, creates it
        //
        rc = ScepStartANewSection(
                    hProfile,
                    &hSectionSap,
                    (Options & SCE_GENERATE_ROLLBACK) ? SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                    szServiceGeneral
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            PSCE_SERVICES pNode = pServiceList;
            //
            // open SCEP section. should be success always because the StartANewSection
            // creates the section if it is not there
            //
            rc = ScepOpenSectionForName(
                        hProfile,
                        (Options & SCE_GENERATE_ROLLBACK) ? SCE_ENGINE_SMP : SCE_ENGINE_SCP,  // SCE_ENGINE_SMP,
                        szServiceGeneral,
                        &hSectionScep
                        );

            if ( rc == SCESTATUS_SUCCESS ) {

                //
                // analyze each service
                //
                PSCE_SERVICES pOneService=NULL;
                BOOL IsDifferent;

                for ( pNode=pServiceList;
                      pNode != NULL; pNode=pNode->Next ) {

                    ScepLogOutput3(2, 0, SCEDLL_SAP_ANALYZE, pNode->ServiceName);

                    if ( nServices < TICKS_SPECIFIC_SERVICES ) {

                        ScepPostProgress(1,
                                         AREA_SYSTEM_SERVICE,
                                         NULL);
                        nServices++;
                    }

                    //
                    // get setting from the SMP profile
                    //
                    rc = ScepGetSingleServiceSetting(
                                 hSectionScep,
                                 pNode->ServiceName,
                                 &pOneService
                                 );
                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // there is a SMP entry for the service, compare and save
                        //
                        rc = ScepCompareSingleServiceSetting(
                                        pOneService,
                                        pNode,
                                        &IsDifferent
                                        );

                        if ( rc == SCESTATUS_SUCCESS && IsDifferent ) {
                            //
                            // write the service as mismatch
                            //
                            pNode->Status = (Options & SCE_GENERATE_ROLLBACK) ? 0 : SCE_STATUS_MISMATCH;
                            pNode->SeInfo = pOneService->SeInfo;

                            rc = ScepSetSingleServiceSetting(
                                      hSectionSap,
                                      pNode
                                      );
                        }

                    } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

                        //
                        // this service is not defined
                        //
                        if ( !(Options & SCE_GENERATE_ROLLBACK) ) {
                            //
                            // save the record with not configured status
                            //
                            pNode->Status = SCE_STATUS_NOT_CONFIGURED;

                            rc = ScepSetSingleServiceSetting(
                                      hSectionSap,
                                      pNode
                                      );
                        } else {
                            //
                            // ignore this one
                            //
                            rc = SCESTATUS_SUCCESS;
                        }
                    }

                    SceFreePSCE_SERVICES(pOneService);
                    pOneService = NULL;

                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                       SCEDLL_SAP_ERROR_ANALYZE, pNode->ServiceName);

                        if ( SCESTATUS_ACCESS_DENIED == rc ) {
                            gWarningCode = ScepSceStatusToDosError(rc);

                            if ( !(Options & SCE_GENERATE_ROLLBACK) ) {

                                //
                                // raise a error status
                                //
                                pNode->Status = SCE_STATUS_ERROR_NOT_AVAILABLE;

                                rc = ScepSetSingleServiceSetting(
                                          hSectionSap,
                                          pNode
                                          );
                            }
                            rc = SCESTATUS_SUCCESS;
                        } else {

                            break;
                        }
                    }

                }

                SceJetCloseSection(&hSectionScep, TRUE);
            }

            if ( !(Options & SCE_GENERATE_ROLLBACK ) ) {

                //
                // raise any error item
                //
                for ( PSCE_SERVICES pNodeTmp=pNode; pNodeTmp != NULL; pNodeTmp = pNodeTmp->Next ) {

                    pNodeTmp->Status = SCE_STATUS_ERROR_NOT_AVAILABLE;

                    ScepSetSingleServiceSetting(
                              hSectionSap,
                              pNode
                              );
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }
        if ( rc != SCESTATUS_SUCCESS )
            ScepLogOutput3(1, ScepSceStatusToDosError(rc), SCEDLL_SAP_ERROR_OUT);

    }

    if ( nServices < TICKS_GENERAL_SERVICES ) {

        ScepPostProgress(TICKS_GENERAL_SERVICES-nServices,
                         AREA_SYSTEM_SERVICE,
                         NULL);
    }

    return(rc);

}


SCESTATUS
ScepGetSingleServiceSetting(
    IN PSCESECTION hSection,
    IN PWSTR ServiceName,
    OUT PSCE_SERVICES *pOneService
    )
/*
Routine Description:

    Get service settings for the service from the section

Arguments:

    hSection - the section handle

    ServiceName - the service name

    pOneService - the service settings

Return Value:

    SCE status
*/
{
    if ( hSection == NULL || ServiceName == NULL || pOneService == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    DWORD ValueLen;
    //
    // seek to the record and get length for name and value
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                ServiceName,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        PWSTR Value=NULL;

        //
        // allocate memory for the service name and value string
        //
        Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);
        if ( Value != NULL ) {
            //
            // Get the service and its value
            //
            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        Value,
                        ValueLen,
                        &ValueLen
                        );

            if ( rc == SCESTATUS_SUCCESS ) {

                Value[ValueLen/2] = L'\0';

                DWORD Win32Rc=NO_ERROR;
                PSECURITY_DESCRIPTOR pTempSD=NULL;
                DWORD SDsize=0;
                SECURITY_INFORMATION SeInfo=0;

                if ( ValueLen >= 2 && Value[1] != L'\0' ) {

                    //
                    // convert to security descriptor
                    //
                    Win32Rc = ConvertTextSecurityDescriptor(
                                       Value+1,
                                       &pTempSD,
                                       &SDsize,
                                       &SeInfo
                                       );
                }

                if ( Win32Rc == NO_ERROR ) {

                    ScepChangeAclRevision(pTempSD, ACL_REVISION);

                    //
                    // create this service node
                    //
                    *pOneService = (PSCE_SERVICES)ScepAlloc( LMEM_FIXED, sizeof(SCE_SERVICES) );

                    if ( *pOneService != NULL ) {

                        (*pOneService)->ServiceName = (PWSTR)ScepAlloc(LMEM_FIXED,
                                                  (wcslen(ServiceName)+1)*sizeof(WCHAR));
                        if ( (*pOneService)->ServiceName != NULL ) {

                            wcscpy( (*pOneService)->ServiceName, ServiceName);
                            (*pOneService)->DisplayName = NULL;
                            (*pOneService)->Status = *((BYTE *)Value);
                            (*pOneService)->Startup = *((BYTE *)Value+1);
                            (*pOneService)->General.pSecurityDescriptor = pTempSD;
                            (*pOneService)->SeInfo = SeInfo;
                            (*pOneService)->Next = NULL;

                            //
                            // DO NOT free the following buffers
                            //
                            pTempSD = NULL;

                        } else {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            ScepFree(*pOneService);
                        }

                    } else {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    }
                    if ( pTempSD != NULL ) {
                        ScepFree(pTempSD);
                    }

                } else {
                    rc = ScepDosErrorToSceStatus(Win32Rc);
                }
            }
            ScepFree(Value);

        } else
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    return(rc);
}


SCESTATUS
ScepCompareSingleServiceSetting(
    IN PSCE_SERVICES pNode1,
    IN PSCE_SERVICES pNode2,
    OUT PBOOL pIsDifferent
    )
/*
Routine Description:

    Comare two service settings.

Arguments:

    pNode1  - the first service

    pNode2  - the second service

    pIsDifferent    - output TRUE if different

Return Value:

    SCE status
*/
{
    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( pNode1->Startup == pNode2->Startup ) {

        BYTE resultSD = 0;
        rc = ScepCompareObjectSecurity(
                    SE_SERVICE,
                    FALSE,
                    pNode1->General.pSecurityDescriptor,
                    pNode2->General.pSecurityDescriptor,
                    pNode1->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                    &resultSD
                    );
        if ( resultSD ) {
            *pIsDifferent = TRUE;
        } else
            *pIsDifferent = FALSE;

    } else
        *pIsDifferent = TRUE;

    return(rc);
}


SCESTATUS
ScepSetSingleServiceSetting(
    IN PSCESECTION hSection,
    IN PSCE_SERVICES pOneService
    )
/*
Routine Description:

    Set service settings for the service from the section

Arguments:

    hSection - the section handle

    pOneService - the service settings

Return Value:

    SCE status
*/
{
    if ( hSection == NULL || pOneService == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;
    PWSTR SDspec=NULL;
    DWORD SDsize=0;


    if ( (pOneService->Status != SCE_STATUS_NOT_ANALYZED) &&
         (pOneService->Status != SCE_STATUS_ERROR_NOT_AVAILABLE) &&
         (pOneService->General.pSecurityDescriptor != NULL) ) {

        DWORD Win32Rc;

        Win32Rc = ConvertSecurityDescriptorToText (
                    pOneService->General.pSecurityDescriptor,
                    pOneService->SeInfo,
                    &SDspec,
                    &SDsize  // number of w-chars
                    );
        rc = ScepDosErrorToSceStatus(Win32Rc);

    }

    if ( rc == SCESTATUS_SUCCESS ) {

        PWSTR Value=NULL;
        DWORD ValueLen;

        ValueLen = (SDsize+1)*sizeof(WCHAR);

        Value = (PWSTR)ScepAlloc( (UINT)0, ValueLen+sizeof(WCHAR) );

        if ( Value != NULL ) {

            //
            // The first byte is status, the second byte is startup
            //
            *((BYTE *)Value) = pOneService->Status;

            *((BYTE *)Value+1) = pOneService->Startup;

            if ( SDspec != NULL ) {

                swprintf(Value+1, L"%s", SDspec );
            }

            Value[SDsize+1] = L'\0';  //terminate this string

            //
            // set the value
            //
            rc = SceJetSetLine(
                        hSection,
                        pOneService->ServiceName,
                        FALSE,
                        Value,
                        ValueLen,
                        0
                        );

            ScepFree( Value );

            switch ( pOneService->Status ) {
            case SCE_STATUS_ERROR_NOT_AVAILABLE:
                ScepLogOutput3(2, 0, SCEDLL_STATUS_ERROR, pOneService->ServiceName);

                break;

            case SCE_STATUS_NOT_CONFIGURED:

                ScepLogOutput3(2, 0, SCEDLL_STATUS_NC, pOneService->ServiceName);

                break;

            case SCE_STATUS_NOT_ANALYZED:

                ScepLogOutput3(2, 0, SCEDLL_STATUS_NEW, pOneService->ServiceName);

                break;

            default:

                ScepLogOutput3(2, 0, SCEDLL_STATUS_MISMATCH, pOneService->ServiceName);
                break;
            }

        } else
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    if ( SDspec != NULL ) {
        ScepFree( SDspec );
    }

    return(rc);
}


SCESTATUS
ScepInvokeSpecificServices(
    IN PSCECONTEXT hProfile,
    IN BOOL bConfigure,
    IN SCE_ATTACHMENT_TYPE aType
    )
/*
Routine Description:

    Call each service engine for configure or analyze

Arguments:

    hProfile - the profile handle

    bConfigure - TRUE = to configure, FALSE=to analyze

    aType - attachment type "services" or "policy"

Return Value:

    SCE status
*/
{
    //
    // for posting progress
    //

    DWORD nServices=0;
    AREA_INFORMATION Area=0;
    DWORD nMaxTicks=0;

    switch(aType) {
    case SCE_ATTACHMENT_SERVICE:
        Area = AREA_SYSTEM_SERVICE;
        nMaxTicks = TICKS_SPECIFIC_SERVICES;
        break;
    case SCE_ATTACHMENT_POLICY:
        Area = AREA_SECURITY_POLICY;
        nMaxTicks = TICKS_SPECIFIC_POLICIES;
        break;
    }

    if ( hProfile == NULL ) {

        ScepPostProgress(nMaxTicks,
                         Area,
                         NULL);

        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // call available service engines to configure specific setting
    //
    SCESTATUS SceErr ;
    PSCE_SERVICES pSvcEngineList=NULL;
    SCEP_HANDLE sceHandle;
    SCESVC_CALLBACK_INFO sceCbInfo;

    SceErr = ScepEnumServiceEngines(&pSvcEngineList, aType);

    if ( SceErr == SCESTATUS_SUCCESS) {

        HINSTANCE hDll;
        PF_ConfigAnalyzeService pfTemp;

        for ( PSCE_SERVICES pNode=pSvcEngineList;
              pNode != NULL; pNode = pNode->Next ) {

            ScepLogOutput3(2, 0, SCEDLL_LOAD_ATTACHMENT, pNode->ServiceName);

            if ( nServices < nMaxTicks ) {

                ScepPostProgress(1, Area, pNode->ServiceName);
                nServices++;
            }
            //
            // load the dll.
            //
            hDll = LoadLibrary(pNode->General.ServiceEngineName);

            if ( hDll != NULL ) {

                if ( bConfigure ) {
                    //
                    // call SceSvcAttachmentConfig from the dll
                    //
                    pfTemp = (PF_ConfigAnalyzeService)
                                      GetProcAddress(hDll,
                                                     "SceSvcAttachmentConfig") ;
                } else {
                    //
                    // call SceSvcAttachmentAnalyze from the dll
                    //
                    pfTemp = (PF_ConfigAnalyzeService)
                                      GetProcAddress(hDll,
                                                     "SceSvcAttachmentAnalyze") ;

                }
                if ( pfTemp != NULL ) {
                    //
                    // prepare the handle first
                    //
                    sceHandle.hProfile = (PVOID)hProfile;
                    sceHandle.ServiceName = (PCWSTR)(pNode->ServiceName);

                    sceCbInfo.sceHandle = &sceHandle;
                    sceCbInfo.pfQueryInfo = &SceCbQueryInfo;
                    sceCbInfo.pfSetInfo = &SceCbSetInfo;
                    sceCbInfo.pfFreeInfo = &SceSvcpFreeMemory;
                    sceCbInfo.pfLogInfo = &ScepLogOutput2;

                    //
                    // call the SceSvcAttachmentConfig/Analyze from the DLL
                    //
                    __try {

                        SceErr = (*pfTemp)((PSCESVC_CALLBACK_INFO)&sceCbInfo);

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        SceErr = SCESTATUS_SERVICE_NOT_SUPPORT;
                    }

                } else {
                    //
                    // this API is not supported
                    //
                    SceErr = SCESTATUS_SERVICE_NOT_SUPPORT;
                }

                //
                // try to free the library handle. If it fails, just leave it
                // to to the process to terminate
                //
                FreeLibrary(hDll);

            } else
                SceErr = SCESTATUS_SERVICE_NOT_SUPPORT;

            if ( SceErr == SCESTATUS_SERVICE_NOT_SUPPORT ) {
                if ( bConfigure )
                    ScepLogOutput3(1, ScepSceStatusToDosError(SceErr),
                                   SCEDLL_SCP_NOT_SUPPORT);
                else
                    ScepLogOutput3(1, ScepSceStatusToDosError(SceErr),
                                   SCEDLL_SAP_NOT_SUPPORT);
                SceErr = SCESTATUS_SUCCESS;

            } else if ( SceErr != SCESTATUS_SUCCESS &&
                        SceErr != SCESTATUS_RECORD_NOT_FOUND ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(SceErr),
                              SCEDLL_ERROR_LOAD, pNode->ServiceName);
            }

            if ( SceErr != SCESTATUS_SUCCESS &&
                 SceErr != SCESTATUS_SERVICE_NOT_SUPPORT &&
                 SceErr != SCESTATUS_RECORD_NOT_FOUND )
                break;
        }
        //
        // free the buffer
        //
        SceFreePSCE_SERVICES(pSvcEngineList);

    } else if ( SceErr != SCESTATUS_SUCCESS &&
                SceErr != SCESTATUS_PROFILE_NOT_FOUND &&
                SceErr != SCESTATUS_RECORD_NOT_FOUND ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(SceErr),
                      SCEDLL_SAP_ERROR_ENUMERATE, L"services");
    }

    if ( SceErr == SCESTATUS_PROFILE_NOT_FOUND ||
         SceErr == SCESTATUS_RECORD_NOT_FOUND ||
         SceErr == SCESTATUS_SERVICE_NOT_SUPPORT ) {
        //
        // no service engine defined
        //
        SceErr = SCESTATUS_SUCCESS;

    }

    if ( nServices < nMaxTicks ) {

        ScepPostProgress(nMaxTicks-nServices,
                         Area,
                         NULL);
    }

    return(SceErr);
}



SCESTATUS
ScepEnumServiceEngines(
    OUT PSCE_SERVICES *pSvcEngineList,
    IN SCE_ATTACHMENT_TYPE aType
    )
/*
Routine Description:

    Query all services which has a service engine for security manager
    The service engine information is in the registry:

    MACHINE\Software\Microsoft\Windows NT\CurrentVersion\SeCEdit

Arguments:

    pSvcEngineList - the service engine list

    aType - attachment type (service or policy)

Return Value:

    SCE status
*/
{
    if ( pSvcEngineList == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD   Win32Rc;
    HKEY    hKey=NULL;

    switch ( aType ) {
    case SCE_ATTACHMENT_SERVICE:
        Win32Rc = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SCE_ROOT_SERVICE_PATH,
                  0,
                  KEY_READ,
                  &hKey
                  );
        break;
    case SCE_ATTACHMENT_POLICY:

        Win32Rc = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SCE_ROOT_POLICY_PATH,
                  0,
                  KEY_READ,
                  &hKey
                  );
        break;
    default:
        return SCESTATUS_INVALID_PARAMETER;
    }

    if ( Win32Rc == ERROR_SUCCESS ) {

        TCHAR   Buffer[MAX_PATH];
        DWORD   BufSize;
        DWORD   index = 0;
        DWORD   EnumRc;
        FILETIME        LastWriteTime;
        PWSTR   BufTmp=NULL;
        PWSTR   EngineName=NULL;
        DWORD   RegType;

        //
        // enumerate all subkeys of the key
        //
        do {
            memset(Buffer, '\0', MAX_PATH*sizeof(WCHAR));
            BufSize = MAX_PATH;

            EnumRc = RegEnumKeyEx(
                            hKey,
                            index,
                            Buffer,
                            &BufSize,
                            NULL,
                            NULL,
                            NULL,
                            &LastWriteTime);

            if ( EnumRc == ERROR_SUCCESS ) {
                index++;
                //
                // get the service name, query service engine name
                //

                BufSize += wcslen(SCE_ROOT_SERVICE_PATH) + 1; //62;
                BufTmp = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                if ( BufTmp != NULL ) {

                    switch ( aType ) {
                    case SCE_ATTACHMENT_SERVICE:

                        swprintf(BufTmp, L"%s\\%s", SCE_ROOT_SERVICE_PATH, Buffer);

                        Win32Rc = ScepRegQueryValue(
                                        HKEY_LOCAL_MACHINE,
                                        BufTmp,
                                        L"ServiceAttachmentPath",
                                        (PVOID *)&EngineName,
                                        &RegType
                                        );
                        break;

                    case SCE_ATTACHMENT_POLICY:
                        // policies
                        swprintf(BufTmp, L"%s\\%s", SCE_ROOT_POLICY_PATH, Buffer);

                        Win32Rc = ScepRegQueryValue(
                                        HKEY_LOCAL_MACHINE,
                                        BufTmp,
                                        L"PolicyAttachmentPath",
                                        (PVOID *)&EngineName,
                                        &RegType
                                        );
                        break;
                    }

                    if ( Win32Rc == ERROR_SUCCESS ) {
                        //
                        // get the service engine name and service name
                        // add them to the service node
                        //
                        Win32Rc = ScepAddOneServiceToList(
                                        Buffer,   // service name
                                        NULL,
                                        0,
                                        (PVOID)EngineName,
                                        0,
                                        FALSE,
                                        pSvcEngineList
                                        );
                        //
                        // free the buffer if it's not added to the list
                        //
                        if ( Win32Rc != ERROR_SUCCESS && EngineName ) {
                            ScepFree(EngineName);
                        }
                        EngineName = NULL;

                    } else if ( Win32Rc == ERROR_FILE_NOT_FOUND ) {
                        //
                        // if no service engine name, ignore this service
                        //
                        Win32Rc = ERROR_SUCCESS;
                    }

                    ScepFree(BufTmp);
                    BufTmp = NULL;

                } else {
                    Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                if ( Win32Rc != ERROR_SUCCESS ) {
                    break;
                }
            }

        } while ( EnumRc != ERROR_NO_MORE_ITEMS );

        RegCloseKey(hKey);

        //
        // remember the error code from enumeration
        //
        if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {
            if ( Win32Rc == ERROR_SUCCESS )
                Win32Rc = EnumRc;
        }

    }

    if ( Win32Rc != NO_ERROR && *pSvcEngineList != NULL ) {
        //
        // free memory allocated for the list
        //

        SceFreePSCE_SERVICES(*pSvcEngineList);
        *pSvcEngineList = NULL;
    }

    return( ScepDosErrorToSceStatus(Win32Rc) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\scesrv.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    scesrv.cpp

Abstract:

    SCE Engine initialization

Author:

    Jin Huang (jinhuang) 23-Jan-1998 created

--*/
#include "serverp.h"
#include <locale.h>
#include "authz.h"
#include <alloca.h>

extern HINSTANCE MyModuleHandle;
AUTHZ_RESOURCE_MANAGER_HANDLE ghAuthzResourceManager = NULL;

#include "scesrv.h"

/*=============================================================================
**  Procedure Name:     DllMain
**
**  Arguments:
**
**
**
**  Returns:    0 = SUCCESS
**             !0 = ERROR
**
**  Abstract:
**
**  Notes:
**
**===========================================================================*/
BOOL WINAPI DllMain(
    IN HANDLE DllHandle,
    IN ULONG ulReason,
    IN LPVOID Reserved )
{

    switch(ulReason) {

    case DLL_PROCESS_ATTACH:

        MyModuleHandle = (HINSTANCE)DllHandle;

        //
        // initizlize server and thread data
        //
        setlocale(LC_ALL, ".OCP");

        (VOID) ScepInitServerData();

#if DBG == 1
        DebugInitialize();
#endif
        //
        // initialize dynamic stack allocation
        //

        SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                             SAFEALLOCA_USE_DEFAULT,
                             NULL,
                             NULL
                            );

        break;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        (VOID) ScepUninitServerData();

#if DBG == 1
        DebugUninit();
#endif
        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;
}

DWORD
WINAPI
ScesrvInitializeServer(
    IN PSVCS_START_RPC_SERVER pStartRpcServer
    )
{
    NTSTATUS NtStatus;
    NTSTATUS StatusConvert = STATUS_SUCCESS;
    DWORD    rc;
    DWORD   rcConvert;
    PWSTR   pszDrives = NULL;
    DWORD   dwWchars = 0;

    NtStatus = ScepStartServerServices(); // pStartRpcServer );
    rc = RtlNtStatusToDosError(NtStatus);

/* remove code to check "DemoteInProgress" value and trigger policy propagation
   because demoting a DC will always have policy re-propagated at reboot

    DWORD dwDemoteInProgress=0;

    ScepRegQueryIntValue(
            HKEY_LOCAL_MACHINE,
            SCE_ROOT_PATH,
            TEXT("DemoteInProgress"),
            &dwDemoteInProgress
            );
*/


    //
    //  if this key exists, some FAT->NTFS conversion happened and we need to set security
    //  so spawn a thread to configure security after autostart service event is signalled.
    //  LSA etc. are guaranteed to be started when this event is signalled
    //

    DWORD dwRegType = REG_NONE;

    rcConvert = ScepRegQueryValue(
                                 HKEY_LOCAL_MACHINE,
                                 SCE_ROOT_PATH,
                                 L"FatNtfsConvertedDrives",
                                 (PVOID *) &pszDrives,
                                 &dwRegType
                                 );

    //
    // at least one C: type drive should be there
    //

    if ( dwRegType != REG_MULTI_SZ || (pszDrives && wcslen(pszDrives) < 2) ) {

        if (pszDrives) {
            LocalFree(pszDrives);
        }

        rcConvert = ERROR_INVALID_PARAMETER;

    }

    //
    // if there is at least one drive scheduled to set security (dwWchars >= 4), pass this info
    // to the spawned thread along with an indication that we are in reboot (so it can loop
    // through all drives as queried)
    //

    if (rcConvert == ERROR_SUCCESS ) {

        if (pszDrives) {

            //
            // need to spawn some other event waiter thread that will call this function
            // thread will free pszDrives
            //

            StatusConvert = RtlQueueWorkItem(
                                        ScepWaitForServicesEventAndConvertSecurityThreadFunc,
                                        pszDrives,
                                        WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION
                                        ) ;
        }

        else if ( pszDrives ) {

            LocalFree( pszDrives );

        }

    }

    if ( rcConvert == ERROR_SUCCESS && pszDrives ) {

        //
        // since event log is not ready, log success or error
        // to logfile only if there is some drive to convert
        //

        WCHAR   szWinDir[MAX_PATH*2 + 1];
        WCHAR   LogFileName[MAX_PATH + 1];

        szWinDir[0] = L'\0';

        GetSystemWindowsDirectory( szWinDir, MAX_PATH );

        //
        // same log file is used by this thread as well as the actual configuration
        // thread ScepWaitForServicesEventAndConvertSecurityThreadFunc - so use it
        // here and close it
        //

        LogFileName[0] = L'\0';
        wcscpy(LogFileName, szWinDir);
        wcscat(LogFileName, L"\\security\\logs\\convert.log");

        ScepEnableDisableLog(TRUE);

        ScepSetVerboseLog(3);

        if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {

            ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );

        }

        rcConvert = RtlNtStatusToDosError(StatusConvert);

        ScepLogOutput3(0,0, SCEDLL_CONVERT_STATUS_CREATING_THREAD, rcConvert, L"ScepWaitForServicesEventAndConvertSecurityThreadFunc");

        ScepLogClose();

    }

    //
    // use AUTHZ for LSA Policy Setting access check - don't care about error now
    //

    AuthzInitializeResourceManager(
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  L"SCE",
                                  &ghAuthzResourceManager );

    return(rc);
}


DWORD
WINAPI
ScesrvTerminateServer(
    IN PSVCS_STOP_RPC_SERVER pStopRpcServer
    )
{
    NTSTATUS NtStatus;
    DWORD    rc;

    NtStatus = ScepStopServerServices( TRUE ); //, pStopRpcServer );
    rc = RtlNtStatusToDosError(NtStatus);

    if (ghAuthzResourceManager)
        AuthzFreeResourceManager( ghAuthzResourceManager );

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\service.h ===
//depot/private/vishnup_branch/DS/security/services/scerpc/server/service.h#1 - branch change 359 (text)
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    service.h

Abstract:

    Private headers for service.cpp

Author:

    Jin Huang (jinhuang) 25-Jan-1998

Revision History:

--*/

#ifndef _servicep_
#define _servicep_

#ifdef __cplusplus
extern "C" {
#endif


SCESTATUS
ScepConfigureGeneralServices(
    IN PSCECONTEXT hProfile,
    IN PSCE_SERVICES pServiceList,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepAnalyzeGeneralServices(
    IN PSCECONTEXT hProfile,
    IN DWORD Options
    );

SCESTATUS
ScepInvokeSpecificServices(
    IN PSCECONTEXT hProfile,
    IN BOOL bConfigure,
    IN SCE_ATTACHMENT_TYPE aType
    );

SCESTATUS
ScepEnumServiceEngines(
    OUT PSCE_SERVICES *pSvcEngineList,
    IN SCE_ATTACHMENT_TYPE aType
    );

//
// attachment engine call back functions
//
SCESTATUS
SceCbQueryInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    OUT PVOID               *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
    );

SCESTATUS
SceCbSetInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    IN PVOID                pvInfo
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\server.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    server.cpp

Abstract:

    Server (main) module

Author:

    Jin Huang (jinhuang) 28-Jan-1998

Revision History:

--*/
#include "serverp.h"
#include "service.h"
#include "ntrpcp.h"
#include "pfp.h"
#include "infp.h"
#include "sceutil.h"
#include "queue.h"
#include <io.h>
//
// thread global variables
//

DWORD Thread     gCurrentTicks=0;
DWORD Thread     gTotalTicks=0;
BYTE  Thread     cbClientFlag=0;
DWORD Thread     gWarningCode=0;
BOOL  Thread     gbInvalidData=FALSE;
BOOL  Thread     bLogOn=TRUE;
INT   Thread     gDebugLevel=-1;

DWORD Thread     gdwPolicyLog=(DWORD)-1;

NT_PRODUCT_TYPE  Thread ProductType=NtProductWinNt;
PSID             Thread AdminsSid=NULL;

extern DWORD Thread     t_pebSize;
extern LPVOID Thread    t_pebClient;
extern LSA_HANDLE        Thread LsaPrivatePolicy;

static PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo=NULL;
static BOOL gbSystemShutdown=FALSE;
static HANDLE hTimerQueue=NULL;

//
// database context list to keep tracking all client requested context
// so that they can be freed properly.
// if yes, we do not need to do this.
//

typedef struct _SCESRV_CONTEXT_LIST_ {

   PSCECONTEXT              Context;
   struct _SCESRV_CONTEXT_LIST_   *Next;
   struct _SCESRV_CONTEXT_LIST_   *Prior;

} SCESRV_CONTEXT_LIST, *PSCESRV_CONTEXT_LIST;

static PSCESRV_CONTEXT_LIST   pOpenContexts=NULL;
static CRITICAL_SECTION ContextSync;

//
// database task list to control simultaneous database operations under
// the same context (jet session)
//

typedef struct _SCESRV_DBTASK_ {

   PSCECONTEXT              Context;
   CRITICAL_SECTION         Sync;
   DWORD                    dInUsed;
   BOOL                     bCloseReq;
   struct _SCESRV_DBTASK_   *Next;
   struct _SCESRV_DBTASK_   *Prior;

} SCESRV_DBTASK, *PSCESRV_DBTASK;

static PSCESRV_DBTASK   pDbTask=NULL;
static CRITICAL_SECTION TaskSync;

#define SCE_TASK_LOCK       0x01L
#define SCE_TASK_CLOSE      0x02L

//
// engine task list to control simultaneous configuration/analysis engines
//

typedef struct _SCESRV_ENGINE_ {

   LPTSTR                   Database;
   struct _SCESRV_ENGINE_   *Next;
   struct _SCESRV_ENGINE_   *Prior;

} SCESRV_ENGINE, *PSCESRV_ENGINE;

static PSCESRV_ENGINE   pEngines=NULL;
static CRITICAL_SECTION EngSync;

//
// jet enigne synchronization
//

CRITICAL_SECTION JetSync;

//
// flag for stop request
//
static BOOL        bStopRequest=FALSE;
static BOOL        bDbStopped=FALSE;
static BOOL        bEngStopped=FALSE;

static CRITICAL_SECTION RpcSync;
static BOOL RpcStarted = FALSE;
static BOOL ServerInited = FALSE;

static CRITICAL_SECTION CloseSync;

static HINSTANCE hSceCliDll=NULL;
static PFSCEINFWRITEINFO pfSceInfWriteInfo=NULL;
static PFSCEGETINFO pfSceGetInfo=NULL;

extern PSCESRV_POLQUEUE pNotificationQHead;
#define SCE_POLICY_MAX_WAIT 24
static DWORD gPolicyWaitCount=0;

#define SERVICE_SAMSS       TEXT("SamSS")

SCESTATUS
ScepGenerateAttachmentSections(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName,
    IN SCE_ATTACHMENT_TYPE aType
    );

SCESTATUS
ScepGenerateWMIAttachmentSections(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName
    );

SCESTATUS
ScepGenerateOneAttachmentSection(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName,
    IN LPTSTR SectionName,
    IN BOOL bWMISection
    );

VOID
ScepWaitForSamSS(
    IN PVOID pContext
    );

SCESTATUS
ScepConvertServices(
    IN OUT PVOID *ppServices,
    IN BOOL bSRForm
    );

SCESTATUS
ScepFreeConvertedServices(
    IN PVOID pServices,
    IN BOOL bSRForm
    );

DWORD
ScepConfigureConvertedFileSecurityImmediate(
    IN PWSTR  pszDriveName
    );

////////////////////////////////////////////////////////////////////////
//
// Server Control APIs
//
////////////////////////////////////////////////////////////////////////

VOID
ScepInitServerData()
/*
Routine Description:

    Initialize global data for the server

Arguments:

    None

Return Value:

    None
*/
{
    //
    // initialize RPC server controls
    //

    InitializeCriticalSection(&RpcSync);
    RpcStarted = FALSE;
    ServerInited = FALSE;
    //
    // flag to indicate if the server is requested to stop.
    //
    bStopRequest = TRUE;  // will be reset when server is started up so this will
                          // block all RPC calls before server is ready

    //
    // database operation pending tasks control
    //
    pDbTask=NULL;
    InitializeCriticalSection(&TaskSync);

    //
    // configuration/analysis engine task control
    //
    pEngines=NULL;
    InitializeCriticalSection(&EngSync);

    //
    // should also remember all created database context so that
    // resource can be freed when server is shutting down
    //

    InitializeCriticalSection(&CloseSync);

    pOpenContexts = NULL;
    InitializeCriticalSection(&ContextSync);

    bEngStopped = FALSE;
    bDbStopped = FALSE;

    //
    // jet engine synchronization
    //
    InitializeCriticalSection(&JetSync);

    //
    // initialize jet engine globals
    //
    SceJetInitializeData();

    //
    // initialize well-known and builin name table
    //
    ScepInitNameTable();

    //
    // initialize queue related stuff
    //
    ScepNotificationQInitialize();

    return;
}


VOID
ScepUninitServerData()
/*
Routine Description:

    UnInitialize global data for the server

Arguments:

    None

Return Value:

    None
*/
{
    //
    // delete the critical sections
    //

    DeleteCriticalSection(&RpcSync);

    DeleteCriticalSection(&TaskSync);

    DeleteCriticalSection(&EngSync);

    DeleteCriticalSection(&CloseSync);

    DeleteCriticalSection(&ContextSync);

    DeleteCriticalSection(&JetSync);

    return;
}


NTSTATUS
ScepStartServerServices()
/*++

Routine Description:

    It starts the server services.

Arguments:

    None.

Return Value:

    NT status.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RPC_STATUS        RpcStatus;

    //
    // start RPC server
    //

    EnterCriticalSection(&RpcSync);

    if ( !RpcStarted ) {

        //
        // use secure RPC
        //
        Status = RpcServerRegisterAuthInfo(
                        NULL,
                        RPC_C_AUTHN_WINNT,
                        NULL,
                        NULL
                        );

        if ( NT_SUCCESS(Status) ) {

            RpcStatus = RpcpAddInterface( L"scerpc",
                                          scerpc_ServerIfHandle);

            if ( RpcStatus != RPC_S_OK ) {
                //
                // can't add RPC interface
                //
                Status = I_RpcMapWin32Status(RpcStatus);

            } else {

                //
                // The first argument specifies the minimum number of threads to
                // be created to handle calls; the second argument specifies the
                // maximum number of concurrent calls allowed.  The last argument
                // indicates not to wait.
                //

                RpcStatus = RpcServerListen(1,12345, 1);

                if ( RpcStatus == RPC_S_ALREADY_LISTENING ) {
                    RpcStatus = RPC_S_OK;
                }

                Status = I_RpcMapWin32Status(RpcStatus);

                if ( RpcStatus == RPC_S_OK ) {
                    RpcStarted = TRUE;
                }
            }
        }
    }

    if ( NT_SUCCESS(Status) ) {

        //
        // RPC server started
        // jet engine will be initialized when a database call comes in
        //

        //
        // delete the component log file
        //
        TCHAR szBuffer[MAX_PATH+1];
        TCHAR szCompLog[MAX_PATH+51];
        TCHAR szCompSav[MAX_PATH*2+20];

        szBuffer[0] = L'\0';
        GetSystemWindowsDirectory(szBuffer, MAX_PATH);
        szBuffer[MAX_PATH] = L'\0';

        wcscpy(szCompLog, szBuffer);
        wcscpy(szCompSav, szBuffer);

        wcscat(szCompLog, L"\\security\\logs\\scecomp.log\0");
        wcscat(szCompSav, L"\\security\\logs\\scecomp.old\0");

        CopyFile(szCompLog, szCompSav, FALSE);

        DeleteFile(szCompLog);

        //
        // clean up temp files
        //

        wcscpy(szCompLog, szBuffer);
        wcscat(szCompLog, L"\\security\\sce*.tmp");

        intptr_t            hFile;
        struct _wfinddata_t    FileInfo;

        hFile = _wfindfirst(szCompLog, &FileInfo);

        if ( hFile != -1 ) {

            do {

                wcscpy(szCompSav, szBuffer);
                wcscat(szCompSav, L"\\security\\");
                wcscat(szCompSav, FileInfo.name);

                DeleteFile(szCompSav);

            } while ( _wfindnext(hFile, &FileInfo) == 0 );

            _findclose(hFile);
        }

        //
        // reset the stop request flag
        //

        bEngStopped = FALSE;
        bDbStopped = FALSE;
        bStopRequest = FALSE;


    }

    pEngines = NULL;
    pOpenContexts = NULL;
    pDbTask = NULL;

    //
    // start a system thread to handle notifications
    // if the thread can't be started, return failure to services.exe
    // which will reboot.
    //
    if ( NT_SUCCESS(Status) ) {
        Status = ScepQueueStartSystemThread();
    }

    LeaveCriticalSection(&RpcSync);

    if ( NT_SUCCESS(Status) ) {
        //
        // launch a worker thread to wait for SAMSS service
        // the only failure case would be out of memory, in which case,
        // return the error to initialize code (to shutdown the system).
        //
        Status = RtlQueueWorkItem(
                        ScepWaitForSamSS,
                        NULL,
                        WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION
                        ) ;
    }

    return(Status);
}

VOID
ScepWaitForSamSS(
    IN PVOID pContext
    )
{
    //
    // make sure this function handles server temination
    // If for some reason, the wait times out, set ServerInited to TRUE
    // and let RPC threads continue to perform the task (and may fail later on)
    //

    DWORD rc = ERROR_SUCCESS;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    ULONG Timeout;
    ULONG TimeSleep;
    SERVICE_STATUS ServiceStatus;

    Timeout = 600; // 600 second timeout

    //
    // Open a handle to the Netlogon Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        rc = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        SERVICE_SAMSS,
                        SERVICE_QUERY_STATUS );

    if ( ServiceHandle == NULL ) {
        rc = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Loop waiting for the SamSS service to start.
    //

    for (;;) {

        //
        // Query the status of the SamSS service.
        //
        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            rc = GetLastError();
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the netlogon service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            rc = ERROR_SUCCESS;
            ServerInited = TRUE;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If Netlogon failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
                rc = ERROR_NOT_SUPPORTED;
                goto Cleanup;
            }

            //
            // If SamSs has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If SamSS is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            rc = ERROR_NOT_SUPPORTED;
            goto Cleanup;

        }

        //
        // if server is shutting down, break this loop
        //

        if ( bStopRequest ) {
            break;
        }

        //
        // sleep for ten seconds;
        //
        if ( Timeout > 5 ) {
            TimeSleep = 5;
        } else {
            TimeSleep = Timeout;
        }

        Sleep(TimeSleep*1000);

        Timeout -= TimeSleep;

        if ( Timeout == 0 ) {
            rc = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        }

    }

    ServerInited = TRUE;

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }

    if ( ERROR_SUCCESS != rc ) {

        //
        // even if it failed to wait for SAMSS service
        // still set the init flag to let RPC threads go through
        // after sleep for the timeout
        //

        if ( Timeout > 0 ) {
            Sleep(Timeout*1000);  // timeout second
        }

        ServerInited = TRUE;
    }

}


NTSTATUS
ScepStopServerServices(
    IN BOOL bShutDown
    )
/*++

Routine Description:

    It stops the server services. This include:
        Blocking all new RPC requests
        Stop RPC server
        wait for all active database operations to finish
        Close all context handles
        Terminate jet engine

Arguments:

    bShutdown  - if the server is shutting down.

Return Value:

    NT status.

--*/
{
    NTSTATUS    Status=STATUS_SUCCESS;
    RPC_STATUS RpcStatus;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER CurrentTime;
    DWORD dStartSeconds;
    DWORD dCurrentSeconds;

    //
    // no need to critical section this one because there
    // should be only one writer to this variable and I
    // don't care the readers
    //
    gbSystemShutdown = bShutDown;

    EnterCriticalSection(&RpcSync);

    //
    // block new RPC requests
    //

    bStopRequest = TRUE;

    ScepServerCancelTimer();

    //
    // stop RPC server
    //

    if ( RpcStarted ) {

        //
        // use secure RPC
        //
        RpcStatus = RpcServerUnregisterIf(scerpc_ServerIfHandle,
                                          0,
                                          1);

        if ( RpcStatus == RPC_S_OK ) {

            RpcMgmtStopServerListening(NULL);
            RpcMgmtWaitServerListen();
        }

        Status = I_RpcMapWin32Status(RpcStatus);

        if ( RpcStatus == RPC_S_OK ) {
            //
            // reset the flag
            //
            RpcStarted = FALSE;
        }
    }

    // db task
    EnterCriticalSection(&TaskSync);

    if ( pDbTask ) {

        bDbStopped = FALSE;
        LeaveCriticalSection(&TaskSync);

        NtQuerySystemTime(&StartTime);
        RtlTimeToSecondsSince1980 (&StartTime, &dStartSeconds);

        while ( !bDbStopped ) {
            //
            // wait until remove task routine removes everything
            // wait maximum 1 minutes in case some tasks are dead or looping
            //
            NtQuerySystemTime(&CurrentTime);
            RtlTimeToSecondsSince1980 (&CurrentTime, &dCurrentSeconds);

            if ( dCurrentSeconds - dStartSeconds > 60 ) {
                //
                // too long, break it
                //
                break;
            }
        }

    } else {
        //
        // new tasks are already blocked by bStopRequest
        // so pDbTask won't be !NULL again
        //
        LeaveCriticalSection(&TaskSync);
    }

    // engine task
    EnterCriticalSection(&EngSync);

    if ( pEngines ) {

        bEngStopped = FALSE;
        LeaveCriticalSection(&EngSync);

        NtQuerySystemTime(&StartTime);
        RtlTimeToSecondsSince1980 (&StartTime, &dStartSeconds);

        while ( !bEngStopped ) {
            //
            // wait until remove task routine removes everything
            // wait maximum 1 minutes in case some tasks are dead or looping
            //
            NtQuerySystemTime(&CurrentTime);
            RtlTimeToSecondsSince1980 (&CurrentTime, &dCurrentSeconds);

            if ( dCurrentSeconds - dStartSeconds > 60 ) {
                //
                // too long, break it
                //
                break;
            }
        }

    } else {
        //
        // new tasks are already blocked by bStopRequest
        // so pEngines won't be !NULL again
        //
        LeaveCriticalSection(&EngSync);

    }

    //
    // close all client's contexts
    //

    EnterCriticalSection(&ContextSync);

    PSCESRV_CONTEXT_LIST pList=pOpenContexts;
    PSCESRV_CONTEXT_LIST pTemp;

    while ( pList ) {

       __try {
           if ( pList->Context && ScepIsValidContext(pList->Context) ) {

               ScepCloseDatabase(pList->Context);

               pTemp = pList;
               pList = pList->Next;

               ScepFree(pTemp);

           } else {
               // it's already freed
               break;
           }
       } __except (EXCEPTION_EXECUTE_HANDLER) {
           break;
       }
    }

    pOpenContexts = NULL;

    LeaveCriticalSection(&ContextSync);

    //
    // check policy tasks
    //
    ScepQueuePrepareShutdown();

    if ( DnsDomainInfo ) {

        //
        // there is no other threads, free DnsDomainInfo
        //

        LsaFreeMemory( DnsDomainInfo );
        DnsDomainInfo = NULL;
    }

    //
    // terminate jet engine
    //

    SceJetTerminate(TRUE);

    SceJetDeleteJetFiles(NULL);

    LeaveCriticalSection(&RpcSync);

    return(Status);
}

SCESTATUS
ScepRsopLog(
   IN AREA_INFORMATION Area,
   IN DWORD dwConfigStatus,
   IN wchar_t *pStatusInfo OPTIONAL,
   IN DWORD dwPrivLow OPTIONAL,
   IN DWORD dwPrivHigh OPTIONAL
   )
/*
Routine Description:

    Call back to client for logging RSOP diagnosis mode data

Arguments:

    Area - the area being logged (used in client side in conjunction with last parameter pStatusInfo)

    dwConfigStatus - error/success code of the particular setting in question

   pStatusInfo - finer information regarding the above area (specific setting name etc.)
*/
{
    //
    // call back to client
    //
    __try {

        SceClientCallbackRsopLog(Area, dwConfigStatus, pStatusInfo, dwPrivLow, dwPrivHigh);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

return(SCESTATUS_SUCCESS);
}

SCESTATUS
ScepPostProgress(
   IN DWORD Delta,
   IN AREA_INFORMATION Area,
   IN LPTSTR szName OPTIONAL
   )
/*
Routine Description:

    Call back to client for the progress of current thread, if client set
    the callback flag.

Arguments:

    Delta - Ticks changes since last callback

    szName - the current item name
*/
{

   if ( cbClientFlag ) {

       //
       // callback is requested
       //

       gCurrentTicks += Delta;

       //
       // call back to client
       //
       __try {

           switch (cbClientFlag ) {
           case SCE_CALLBACK_DELTA:
               SceClientCallback(Delta,0,0,(wchar_t *)szName);
               break;

           case SCE_CALLBACK_TOTAL:
               if ( Area ) {
                   SceClientCallback(gCurrentTicks, gTotalTicks, Area, (wchar_t *)szName);
               }
               break;
           }

       } __except(EXCEPTION_EXECUTE_HANDLER) {

           return(SCESTATUS_INVALID_PARAMETER);
       }
   }

   return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepValidateAndLockContext(
    IN PSCECONTEXT Context,
    IN BYTE LockFlag,
    IN BOOL bRequireWrite,
    OUT PSCESRV_DBTASK *ppTask OPTIONAL
    )
/*
Routine Description:

    Validate the context handle is SCE context handle.
    If the same context (same session) is already used for another
    database operation, this operation will be in waiting (a critical
    section pointer is returned)

Arguments:

    Context     - the context handle

    bLock       - TRUE=perform the lock

    ppTask      - the output task pointer

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc = SCESTATUS_INVALID_PARAMETER;

    if ( (LockFlag & SCE_TASK_LOCK) && !ppTask ) {
        //
        // if willing to lock, ppTask must NOT be NULL
        //
        return(rc);
    }

    if ( !Context ) {
        //
        // contents of the context will be checked within the critical section
        // because other threads might free the context within there.
        //
        return(rc);
    }

    if ( ppTask ) {
        *ppTask = NULL;
    }

    //
    // lock the task list and verify the context
    //

    EnterCriticalSection(&TaskSync);

    if ( bStopRequest ) {
        LeaveCriticalSection(&TaskSync);
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    if ( ScepIsValidContext(Context) &&
         ( Context->JetSessionID != JET_sesidNil ) &&
         ( Context->JetDbID != JET_dbidNil) ) {

        rc = SCESTATUS_SUCCESS;

        if ( bRequireWrite &&
             ( SCEJET_OPEN_READ_ONLY == Context->OpenFlag ) ) {
            //
            // write operation is requested but the database is only granted
            // read only access to this context.
            //
            rc = SCESTATUS_ACCESS_DENIED;
        } else {
            //
            // check if esent delay load successful
            //
            DWORD dbVersion;

            __try {
                JetGetDatabaseInfo(Context->JetSessionID,
                                   Context->JetDbID,
                                   (void *)&dbVersion,
                                   sizeof(DWORD),
                                   JET_DbInfoVersion
                                   );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // esent.dll is not loaded (delay) successfully
                //
                rc = SCESTATUS_MOD_NOT_FOUND;
            }
        }

    } else {
        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( SCESTATUS_SUCCESS == rc && LockFlag ) {

        PSCESRV_DBTASK pdb = pDbTask;

        while ( pdb ) {
            if ( pdb->Context &&
                 pdb->Context->JetSessionID == Context->JetSessionID &&
                 pdb->Context->JetDbID == Context->JetDbID ) {
                break;
            }
            pdb = pdb->Next;
        }

        if ( pdb && pdb->Context ) {

            //
            // find the same context address and same session
            // critical section is in pdb->Sync
            //

            if ( pdb->bCloseReq ) {

                //
                // error this thread out because another thread is closing the
                // same context
                //

                rc = SCESTATUS_ACCESS_DENIED;

            } else if ( LockFlag & SCE_TASK_CLOSE ) {

                //
                // close on this context is requested but there are other
                // thread running under this context, so just turn on the flag
                // and the context will be closed when all pending tasks
                // are done
                //

                pdb->bCloseReq = TRUE;

            } else {

                //
                // request a lock, it's ok for this task to continue
                //

                pdb->dInUsed++;
                *ppTask = pdb;
            }

        } else {

            //
            // did not find the same context, this operation is ok to go
            // but need to add itself to the list
            //

            if ( LockFlag & SCE_TASK_CLOSE ) {

                //
                // a close context is requested, other threads using
                // the same context will be invalidated after this context
                // is freed
                //

                rc = ScepCloseDatabase(Context);

            } else if ( LockFlag & SCE_TASK_LOCK ) {

                PSCESRV_DBTASK NewDbTask = (PSCESRV_DBTASK)ScepAlloc(0, sizeof(SCESRV_DBTASK));

                if ( NewDbTask ) {
                    //
                    // new node is created
                    //
                    NewDbTask->Context = Context;
                    NewDbTask->Prior = NULL;
                    NewDbTask->dInUsed = 1;
                    NewDbTask->bCloseReq = FALSE;

                    InitializeCriticalSection(&(NewDbTask->Sync));

                    //
                    // link it to the db task list
                    //

                    NewDbTask->Next = pDbTask;

                    if ( pDbTask ) {
                        pDbTask->Prior = NewDbTask;
                    }

                    pDbTask = NewDbTask;

                    *ppTask = NewDbTask;

                } else {

                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                }

            } else {
                //
                // no lock, no close, just return
                //
            }
        }

    }

    LeaveCriticalSection(&TaskSync);

    return(rc);
}


SCESTATUS
ScepRemoveTask(
    PSCESRV_DBTASK pTask
    )
/*
Routine Description:

    Remove the task (context) from dbtask table if there is no other
    thread running in the same context.

Arguments:


    pTask       - the task node containing context and critical section

Return Value:

    SCESTATUS
*/
{

    if ( !pTask ) {
        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    EnterCriticalSection(&TaskSync);

    //
    // find the task pointer in the task list for verification
    //

    PSCESRV_DBTASK pdb = pDbTask;

    while ( pdb && (ULONG_PTR)pdb != (ULONG_PTR)pTask ) {

        pdb = pdb->Next;
    }

    if ( pdb ) {

        //
        // find the same task node
        //

        pdb->dInUsed--;

        if ( 0 == pdb->dInUsed ) {

            //
            // nobody is using this task node
            // remove it
            //

            if ( pdb->Prior ) {

                pdb->Prior->Next = pdb->Next;

            } else {
                //
                // no parent node, set the static variable
                //
                pDbTask = pdb->Next;

            }

            //
            // this is a double link list, remember to remove the Prior link
            //

            if ( pdb->Next ) {
                pdb->Next->Prior = pdb->Prior;
            }

            //
            // if close request is send, close this database
            //

            if ( pdb->bCloseReq && pdb->Context ) {

                ScepCloseDatabase(pdb->Context);
            }

            //
            // delete the critical section
            //
            DeleteCriticalSection(&(pdb->Sync));

            //
            // free the memory used by this node
            //

            ScepFree(pdb);

        } else {

            //
            // other thread is using this task node for database operation
            // do nothing
            //
        }

    } else {

        //
        // can't find the task node in global the task list
        //
        rc = SCESTATUS_INVALID_PARAMETER;

    }

    //
    // if stop is requested, notify the server that db task is done
    //
    if ( bStopRequest && !pDbTask ) {
        bDbStopped = TRUE;
    }

    LeaveCriticalSection(&TaskSync);

    return(rc);
}


SCESTATUS
ScepLockEngine(
    IN LPTSTR DatabaseName
    )
/*
Routine Description:

    Lock the database for configuration/analysis.

    Only one engine can run on the same database for configuration or
    analysis because first it's meaningless to have multiple engines
    running toward the same system, and second, the database is changed
    by the engine (table may be deleted, so on...)

    OpenDatabase is not locked by this lock, because each OpenDatabase
    has its own session and cursor and no operations such as delete the
    database or delete a table can be done with that context.

Arguments:

    DefProfile - the database name

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc;

    if ( !DatabaseName ) {
        //
        // if willing to lock, ppTask must NOT be NULL
        //
        return(SCESTATUS_INVALID_PARAMETER);
    }

    EnterCriticalSection(&EngSync);

    if ( bStopRequest ) {
        LeaveCriticalSection(&EngSync);
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    PSCESRV_ENGINE pe = pEngines;

    while ( pe ) {
        if ( pe->Database &&
             0 == _wcsicmp(pe->Database, DatabaseName) ) {
            break;
        }
        pe = pe->Next;
    }

    if ( pe ) {

        //
        // find the same database running by other threads
        //

        rc = SCESTATUS_ALREADY_RUNNING;

    } else {

        //
        // did not find the same database, this operation is ok to go
        // but need to add itself to the list
        //

        PSCESRV_ENGINE NewEng = (PSCESRV_ENGINE)ScepAlloc(0, sizeof(SCESRV_ENGINE));

        if ( NewEng ) {

            //
            // new node is created
            //
            NewEng->Database = (LPTSTR)ScepAlloc(LPTR, (wcslen(DatabaseName)+1)*sizeof(TCHAR));

            if ( NewEng->Database ) {

                wcscpy(NewEng->Database, DatabaseName);

                NewEng->Next = pEngines;
                NewEng->Prior = NULL;

                if ( pEngines ) {
                    pEngines->Prior = NewEng;
                }

                pEngines = NewEng;

                rc = SCESTATUS_SUCCESS;

            } else {

                ScepFree(NewEng);
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    }

    LeaveCriticalSection(&EngSync);

    return(rc);

}

SCESTATUS
ScepUnlockEngine(
    IN LPTSTR DatabaseName
    )
/*
Routine Description:

    Unlock the database.

Arguments:

    DatabaseName - the database name

Return Value:

    SCESTATUS
*/
{
    if ( !DatabaseName ) {
        //
        // if no database name, just return
        //
        return(SCESTATUS_SUCCESS);
    }

    EnterCriticalSection(&EngSync);

    PSCESRV_ENGINE pe = pEngines;

    while ( pe && pe->Database &&
            0 != _wcsicmp(pe->Database, DatabaseName) ) {
        pe = pe->Next;
    }

    if ( pe ) {

        //
        // find the database, unlock it.
        //
        if ( pe->Prior ) {

            pe->Prior->Next = pe->Next;

        } else {

            //
            // no parent node, set the static variable
            //

            pEngines = pe->Next;

        }

        //
        // this is a double link list, remember to remove the Prior link
        //

        if ( pe->Next ) {
            pe->Next->Prior = pe->Prior;
        }

        //
        // free the node
        //

        if ( pe->Database ) {
            ScepFree(pe->Database);
        }

        ScepFree(pe);
    }

    //
    // if stop is requested, notify the server that engine are done
    //
    if ( bStopRequest && !pEngines ) {
        bEngStopped = TRUE;
    }

    LeaveCriticalSection(&EngSync);

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepAddToOpenContext(
    IN PSCECONTEXT Context
    )
{
    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS  rc=SCESTATUS_SUCCESS;

    __try {
        if ( ScepIsValidContext(Context) ) {

            PSCESRV_CONTEXT_LIST pList=pOpenContexts;

            //
            // note, ContextSync is already entered before this function is called
            //

            while ( pList ) {

                if ( pList->Context &&
                     pList->Context->JetSessionID == Context->JetSessionID &&
                     pList->Context->JetDbID == Context->JetDbID ) {
//                     0 == memcmp(pList->Context, Context, sizeof(SCECONTEXT)) ) {
                    break;
                }
                pList = pList->Next;
            }

            if ( !pList ) {

                //
                // did not find this open context, add it
                //
                pList = (PSCESRV_CONTEXT_LIST)ScepAlloc(0, sizeof(SCESRV_CONTEXT_LIST));

                if ( pList ) {
                    pList->Context = Context;
                    pList->Prior = NULL;
                    pList->Next = pOpenContexts;

                    if ( pOpenContexts ) {
                        pOpenContexts->Prior = pList;
                    }
                    pOpenContexts = pList;

                } else {

                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                }

            }

        } else {
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    return(rc);
}

BOOL
ScepNoActiveContexts()
{

    BOOL bExist=FALSE;

    //
    // any active task ?
    //
    EnterCriticalSection(&TaskSync);

    if ( pDbTask ) {
        bExist = TRUE;
    }

    LeaveCriticalSection(&TaskSync);

    if ( bExist ) {
        return FALSE;
    }

    //
    // any active db engine task ?
    //
    EnterCriticalSection(&EngSync);

    if ( pEngines ) {
        bExist = TRUE;
    }

    LeaveCriticalSection(&EngSync);

    if ( bExist ) {
        return FALSE;
    }

    //
    // any open contexts ?
    //
    EnterCriticalSection(&ContextSync);

    if ( pOpenContexts ) {
        bExist = TRUE;
    }

    LeaveCriticalSection(&ContextSync);

    return !bExist;
}


VOID
pDelayShutdownFunc(
    IN PVOID Context,
    IN UCHAR Timeout
    )
{

    if ( TryEnterCriticalSection(&JetSync) ) {

        if ( hTimerQueue ) {
            //
            // it's necessary to do this check because there might be another thread
            // cancelled this timer (after it's fired)
            //
            if ( ScepNoActiveContexts() ) {

                SceJetTerminateNoCritical(TRUE);  // clean version store (FALSE);
            }

            //
            // 4. Note that UNLIKE before, EVERY timer needs to be deleted by calling
            // RtlDeleteTimer even if they are one shot objects and have fired.
            //
            DeleteTimerQueueTimer( NULL, hTimerQueue, NULL );

            //
            // do not call CloseHandle because the handle will be closed by the
            // timer function.

            hTimerQueue = NULL;
        }

        LeaveCriticalSection(&JetSync);

    } else {
        //
        // there is other thread holding off this one.
        // This means there is still active clients, or a new client
        // coming in, just return. htimerQueue will be reset by another thread
        //
    }
}


BOOL
ScepIfTerminateEngine()
{
    //
    // if system is requesting a shutdown, don't do
    // anything, because the active clients and jet engine will be shutdown
    //
    if ( ScepIsSystemShutDown() ) {
        return TRUE;
    }

    if ( ScepNoActiveContexts() ) {
        //
        // use JetSync to control timer queue
        //
        EnterCriticalSection(&JetSync);

        DWORD Interval = 6*60*1000 ;   // 6 minutes

        if ( !CreateTimerQueueTimer(
                        &hTimerQueue,
                        NULL,
                        pDelayShutdownFunc,
                        NULL,
                        Interval,
                        0,
                        0 ) ) {
            hTimerQueue = NULL;
        }

        LeaveCriticalSection(&JetSync);

        return TRUE;

    } else {
        return FALSE;
    }
}

SCESTATUS
ScepServerCancelTimer()
{

    EnterCriticalSection(&JetSync);

    if (hTimerQueue ) {

        DeleteTimerQueueTimer(
                NULL,
                hTimerQueue,
                (HANDLE)-1
                );
        hTimerQueue = NULL;
    }

    LeaveCriticalSection(&JetSync);

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepValidateAndCloseDatabase(
    IN PSCECONTEXT Context
    )
{
    SCESTATUS rc;


    EnterCriticalSection(&CloseSync);

    if ( ScepIsValidContext(Context) ) {

        rc = SCESTATUS_SUCCESS;

    } else {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        LeaveCriticalSection(&CloseSync);
        return(rc);
    }

    //
    // be able to access the first byte
    //

    EnterCriticalSection(&ContextSync);


    PSCESRV_CONTEXT_LIST pList=pOpenContexts;

    while ( pList && ((ULONG_PTR)(pList->Context) != (ULONG_PTR)Context ||
                      pList->Context->JetSessionID != Context->JetSessionID ||
                      pList->Context->JetDbID != Context->JetDbID) ) {
        pList = pList->Next;
    }

    if ( pList ) {
        //
        // find the open context, remove it from the open context list
        // NOTE: both Prior and Next should be handled
        //

        if ( pList->Prior ) {

            pList->Prior->Next = pList->Next;
        } else {

            pOpenContexts = pList->Next;
        }

        if ( pList->Next ) {
            pList->Next->Prior = pList->Prior;
        }

        //
        // free pList, do not call CloseDatabase because it will
        // be closed in the following call.
        //
        ScepFree(pList);

    }

    LeaveCriticalSection(&ContextSync);

    //
    // if there are other threads running using the
    // same database context, the close request is
    // turned on. When all threads using the context
    // finish, the context is closed.
    //
    // this client calling close won't have to wait
    // for other threads using the same context
    //

    rc = ScepValidateAndLockContext(
                    (PSCECONTEXT)Context,
                    SCE_TASK_CLOSE,
                    FALSE,
                    NULL);

    LeaveCriticalSection(&CloseSync);

    //
    // start a timer queue to check to see if there is active tasks/contexts
    // if not, terminate jet engine
    //
    ScepIfTerminateEngine();

    return(rc);
}


SCEPR_STATUS
SceSvcRpcQueryInfo(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_SVCINFO_TYPE SceSvcType,
    IN wchar_t *ServiceName,
    IN wchar_t *Prefix OPTIONAL,
    IN BOOL bExact,
    OUT PSCEPR_SVCINFO __RPC_FAR *ppvInfo,
    IN OUT PSCEPR_ENUM_CONTEXT psceEnumHandle
    )
/*
Routine Description:

    Retrieve information for the service from the database. If there are
    more than the maximum allowed records for the service, only maximum
    allowed records are returned. Client must use the enumeration handle
    to make next query.

    If during the enumeration, another client using the same context (which
    is wired but it's possible) to change the information for this service,
    the first client may get incorrect information.

    The recommend solution is to use another context handle when doing the
    update.

Arguments:

    Context     - the context handle

    SceSvcType  - the info type requested

    ServiceName - the service name for which info is requested

    Prefix      - optional key prefix

    bExact      - TRUE = exact match on key

    ppvInfo     - output buffer

    psceEnumHandle - the enumeration handle (used for next enumeration)

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }

    if ( !ServiceName || !ppvInfo || !psceEnumHandle ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        //
        // query the information now
        //
#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            __try {

                rc = SceSvcpQueryInfo(
                    (PSCECONTEXT)Context,
                    (SCESVC_INFO_TYPE)SceSvcType,
                    (PCWSTR)ServiceName,
                    (PWSTR)Prefix,
                    bExact,
                    (PVOID *)ppvInfo,
                    (PSCE_ENUMERATION_CONTEXT)psceEnumHandle
                    );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                //
                // free ppvInfo if it's allocated
                //
                SceSvcpFreeMemory(*ppvInfo);

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }


    RpcRevertToSelf();
    
    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceSvcRpcSetInfo(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_SVCINFO_TYPE SceSvcType,
    IN wchar_t *ServiceName,
    IN wchar_t *Prefix OPTIONAL,
    IN BOOL bExact,
    IN PSCEPR_SVCINFO pvInfo
    )
/*
Routine Description:

    Write information for the service to the database.

Arguments:

    Context     - the context handle

    SceSvcType  - the info type requested

    ServiceName - the service name for which info is requested

    Prefix      - optional key prefix

    bExact      - TRUE = exact match on key

    pvInfo     - output buffer

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !ServiceName || !pvInfo ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }
    
    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }



    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // set the information now
            //

            __try {

                rc = SceSvcpSetInfo(
                        (PSCECONTEXT)Context,
                        (SCESVC_INFO_TYPE)SceSvcType,
                        (LPTSTR)ServiceName,
                        (LPTSTR)Prefix,
                        bExact,
                        0,
                        (PVOID)pvInfo
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


DWORD
SceRpcSetupUpdateObject(
    IN SCEPR_CONTEXT Context,
    IN wchar_t *ObjectFullName,
    IN DWORD ObjectType,
    IN UINT nFlag,
    IN wchar_t *SDText
    )
/*
Routine Description:

    Update object's security settings.

Arguments:

    Context     - the context handle

    ObjectFullName - the object's full path name

    ObjectType  - the object type

    nFlag       - the update flag

    SDText      - the SDDL text for the object

Return Value:

    DWORD
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !ObjectFullName || !SDText ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
        
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {

#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // update object, return code is DWORD
            //
                rc = ScepSetupUpdateObject(
                            (PSCECONTEXT)Context,
                            (LPTSTR)ObjectFullName,
                            (SE_OBJECT_TYPE)ObjectType,
                            nFlag,
                            (LPTSTR)SDText
                            );

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif
        } __except(EXCEPTION_EXECUTE_HANDLER) {

           rc = ERROR_EXCEPTION_IN_SERVICE;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    } else {

        rc = ScepSceStatusToDosError(rc);
    }

    RpcRevertToSelf();

    return(rc);
}



DWORD
SceRpcSetupMoveFile(
    IN SCEPR_CONTEXT Context,
    IN wchar_t *OldName,
    IN wchar_t *NewName OPTIONAL,
    IN wchar_t *SDText OPTIONAL
    )
/*
Routine Description:

    Rename or delete a object in the section.

Arguments:

    Context     - the context handle

    SectionName - the object's section name

    OldName     - existing name

    NewName     - new name to rename to, if NULL, the existing object is deleted

Return Value:

    DWORD
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return ERROR_ACCESS_DENIED;

    }
    
    if ( !OldName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {

#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // update object, return code is DWORD
                //

                rc = ScepSetupMoveFile(
                            (PSCECONTEXT)Context,
                            (LPTSTR)OldName,
                            (LPTSTR)NewName,
                            (LPTSTR)SDText
                            );

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except(EXCEPTION_EXECUTE_HANDLER) {

           rc = ERROR_EXCEPTION_IN_SERVICE;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    } else {

        rc = ScepSceStatusToDosError(rc);
    }

    RpcRevertToSelf();

    return(rc);
}


DWORD
SceRpcGenerateTemplate(
    IN handle_t binding_h,
    IN wchar_t *JetDbName OPTIONAL,
    IN wchar_t *LogFileName OPTIONAL,
    OUT SCEPR_CONTEXT __RPC_FAR *pContext
    )
/*
Routine Description:

    Request a context handle to generate a template from the
    database. If database name is not provided, the default database
    used.

Arguments:

    JetDbName    - optional database name, if NULL, the default is used.

    LogFileName  - the log file name

    pContext     - the output context handle

Return Value:

    DWORD
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !pContext ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // there is no need to check delay loaded DLLs since now we have a exception hander
    // (defined in sources)
    // initialize jet engine in system context
    //

    rc = ScepSceStatusToDosError( SceJetInitialize(NULL) );

    if ( ERROR_SUCCESS != rc ) {
        return(rc);
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        *pContext = NULL;
        //
        // terminate jet engine if there is no other clients
        //
        ScepIfTerminateEngine();

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // get the default database name if needed
    // and call open database on it.
    //
    // OpenDatabase is not blocked by any task.
    //

    EnterCriticalSection(&ContextSync);

    PWSTR DefProfile=NULL;

    __try {
        //
        // figure out the default database name
        // catch exception if the input buffer are bogus
        //
        rc = ScepGetDefaultDatabase(
                 JetDbName,
                 0,
                 LogFileName,
                 NULL,
                 &DefProfile
                 );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = ERROR_EXCEPTION_IN_SERVICE;
    }

    if ( NO_ERROR == rc && DefProfile ) {

        //
        // initialize to open the database
        //

        ScepLogOutput3(0,0, SCEDLL_BEGIN_INIT);

        ScepLogOutput3(2,0, SCEDLL_FIND_DBLOCATION, DefProfile);

        //
        // open the database
        //

        rc = ScepOpenDatabase((PCWSTR)DefProfile,
                              0, // do not require analysis info,
                              SCEJET_OPEN_READ_ONLY,
                              (PSCECONTEXT *)pContext);

        rc = ScepSceStatusToDosError(rc);

        if ( ERROR_SUCCESS != rc ) {
            ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, DefProfile);
        }
    }

    if (DefProfile != NULL && DefProfile != JetDbName ) {

        ScepFree( DefProfile );
    }

    ScepLogClose();

    if ( *pContext ) {
        //
        // if a context is to be returned, add it to the open context list
        //
        ScepAddToOpenContext((PSCECONTEXT)(*pContext));
        rc = ERROR_SUCCESS;

    } else {

        rc = ERROR_FILE_NOT_FOUND;
    }

    LeaveCriticalSection(&ContextSync);

    RpcRevertToSelf();

    if ( ERROR_SUCCESS != rc ) {
        //
        // terminate jet engine if no other clients
        //
        ScepIfTerminateEngine();
    }

    return(rc);
}



SCEPR_STATUS
SceRpcConfigureSystem(
    IN handle_t binding_h,
    IN wchar_t *InfFileName OPTIONAL,
    IN wchar_t *DatabaseName OPTIONAL,
    IN wchar_t *LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREAPR Area,
    IN DWORD pebSize,
    IN UCHAR *pebClient OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    )
/*
Routine Description:

    Configure the system using the Inf template and/or existing
    database info

Arguments:

    See ScepConfigureSystem

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }

    RpcRevertToSelf();
    
    if ( bStopRequest ) {

        if ( !ServerInited ) {
            //
            // server is in the middle of initialization
            // client calls to server too early, should wait for some time
            // (maximum 3 seconds)
            //
            INT cnt=0;
            while (cnt < 6) {
                Sleep(500);  // .5 second
                if ( ServerInited ) {
                    break;
                }
                cnt++;
            }

            if ( bStopRequest ) {
                //
                // if it's still in stop mode, return failure
                //
                return(SCESTATUS_SERVICE_NOT_SUPPORT);
            }
        } else {

            return(SCESTATUS_SERVICE_NOT_SUPPORT);
        }
    }

    //
    // initialize jet engine in system context
    //
    JET_ERR JetErr=0;
    BOOL bAdminLogon=FALSE;

    rc = SceJetInitialize(&JetErr);

    if ( rc != SCESTATUS_SUCCESS ) {

        if ( (JetErr > JET_errUnicodeTranslationBufferTooSmall) &&
             (JetErr < JET_errInvalidLoggedOperation) &&
             (JetErr != JET_errLogDiskFull) ) {
            //
            // something is wrong with Jet log files
            // if I am in setup and using system database (admin logon) or
            // am in dcpromo, delete the Jet log files and try again
            //
            //
            // impersonate the client, return DWORD error code
            //

            if ( RPC_S_OK ==  RpcImpersonateClient( NULL ) ) {

                ScepIsAdminLoggedOn(&bAdminLogon);

                RpcRevertToSelf();

                if ( bAdminLogon &&
                     (DatabaseName == NULL || SceIsSystemDatabase(DatabaseName) )) {
                    //
                    // system database and admin logon
                    // delete the Jet log files now.
                    //
                    SceJetDeleteJetFiles(NULL);

                    //
                    // try to initialize again (in system context)
                    //
                    rc = SceJetInitialize(&JetErr);
                }
            }

        }

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    //
    // impersonate the client, return DWORD error code
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        ScepIfTerminateEngine();

        return( ScepDosErrorToSceStatus(rc) );
    }

    //
    // get the database name
    //

    LPTSTR DefProfile=NULL;

    __try {
        //
        // catch exception if the input parameters are bogus
        //
        rc = ScepGetDefaultDatabase(
                 (LPCTSTR)DatabaseName,
                 ConfigOptions,
                 (LPCTSTR)LogFileName,
                 &bAdminLogon,
                 &DefProfile
                 );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = ERROR_EXCEPTION_IN_SERVICE;
    }

    if ( ERROR_SUCCESS == rc && DefProfile ) {

        //
        // validate access to the database
        //
        rc = ScepDatabaseAccessGranted( DefProfile,
                                        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                                        TRUE
                                      );
    }

    rc = ScepDosErrorToSceStatus(rc);

    if ( SCESTATUS_SUCCESS == rc && DefProfile ) {

        //
        // validate the database to see if there is any configuration/
        // analysis running on other threads
        //

        rc = ScepLockEngine(DefProfile);

        if ( SCESTATUS_ALREADY_RUNNING == rc &&
             (ConfigOptions & SCE_DCPROMO_WAIT ) ) {
            //
            // will wait for max one minute
            //
            DWORD DcpromoWaitCount = 0;

            while ( TRUE ) {

                Sleep(5000);  // 5 seconds

                rc = ScepLockEngine(DefProfile);

                DcpromoWaitCount++;

                if ( SCESTATUS_SUCCESS == rc ||
                     DcpromoWaitCount >= 12 ) {
                    break;
                }
            }
        }

        if ( SCESTATUS_SUCCESS == rc ) {

            t_pebClient = (LPVOID)pebClient;
            t_pebSize = pebSize;

            //
            // it's ok to continue this operation
            // no other threads are running configuration/analysis
            // based on the same database
            //

            DWORD dOptions = ConfigOptions;
            if ( !DatabaseName ||
                 ( bAdminLogon && SceIsSystemDatabase(DatabaseName)) ) {

                dOptions |= SCE_SYSTEM_DB;
            }

            __try {
                //
                // catch exception if InfFileName, or pebClient/pdWarning are bogus
                //
                rc = ScepConfigureSystem(
                        (LPCTSTR)InfFileName,
                        DefProfile,
                        dOptions,
                        bAdminLogon,
                        (AREA_INFORMATION)Area,
                        pdWarning
                        );
            } __except(EXCEPTION_EXECUTE_HANDLER) {

               rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

            //
            // make sure private LSA handle is closed (to avoid deadlock)
            //
            if ( LsaPrivatePolicy ) {

                ScepNotifyLogPolicy(0, TRUE, L"Policy Prop: Private LSA handle is to be released", 0, 0, NULL );

                LsaClose(LsaPrivatePolicy);
                LsaPrivatePolicy = NULL;

            }

            //
            // unlock the engine for this database
            //

            ScepUnlockEngine(DefProfile);
        }
    }

    if ( DefProfile && DefProfile != DatabaseName ) {
        ScepFree(DefProfile);

    }

    ScepLogClose();

    //
    // change context back
    //

    RpcRevertToSelf();

    //
    // start a timer queue to check to see if there is active tasks/contexts
    // if not, terminate jet engine
    //
    ScepIfTerminateEngine();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcGetDatabaseInfo(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE ProfileType,
    IN AREAPR Area,
    OUT PSCEPR_PROFILE_INFO __RPC_FAR *ppInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Get information from the context database.

Arguments:

    Note: the InfoBuffer will always be the output buffer. Client site will
    pass in a address of NULL buffer to start with for any area information
    then merge this output buffer with the one clients called in.

    Have to marshlling security descriptor data to add a length in pServices

    See ScepGetDatabaseInfo

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !ppInfoBuffer ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {
            //
            // catch exception if Context, ppInfoBuffer, Errlog are bogus pointers
            //
#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // query the information now
                //

                rc = ScepGetDatabaseInfo(
                            (PSCECONTEXT)Context,
                            (SCETYPE)ProfileType,
                            (AREA_INFORMATION)Area,
                            0,
                            (PSCE_PROFILE_INFO *)ppInfoBuffer,
                            (PSCE_ERROR_LOG_INFO *)Errlog
                            );

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // free ppInfoBuffer if it's allocated
            //
            SceFreeProfileMemory( (PSCE_PROFILE_INFO)(*ppInfoBuffer));
            *ppInfoBuffer = NULL;

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

        __try {

            if ( *ppInfoBuffer && (*ppInfoBuffer)->pServices ) {
                //
                // marshell the SCEPR_SERVICES structure for the security
                // descriptor
                //
                for ( PSCE_SERVICES ps=(PSCE_SERVICES)((*ppInfoBuffer)->pServices);
                      ps != NULL; ps = ps->Next ) {

                    if ( ps->General.pSecurityDescriptor ) {
                        //
                        // if there is a security descriptor, it must be self relative
                        // because the SD is returned from SDDL apis.
                        //
                        ULONG nLen = RtlLengthSecurityDescriptor (
                                            ps->General.pSecurityDescriptor);

                        if ( nLen > 0 ) {
                            //
                            // create a wrapper node to contain the security descriptor
                            //

                            PSCEPR_SR_SECURITY_DESCRIPTOR pNewWrap;
                            pNewWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SCEPR_SR_SECURITY_DESCRIPTOR));
                            if ( pNewWrap ) {

                                //
                                // assign the wrap to the structure
                                //
                                pNewWrap->SecurityDescriptor = (UCHAR *)(ps->General.pSecurityDescriptor);
                                pNewWrap->Length = nLen;

                                ps->General.pSecurityDescriptor = (PSECURITY_DESCRIPTOR)pNewWrap;

                            } else {
                                //
                                // no memory is available, but still continue to parse all nodes
                                //
                                nLen = 0;
                            }
                        }

                        if ( nLen == 0 ) {
                            //
                            // something wrong with this security descriptor
                            // free the buffer
                            //
                            ScepFree(ps->General.pSecurityDescriptor);
                            ps->General.pSecurityDescriptor = NULL;
                            ps->SeInfo = 0;
                        }

                    }
                }
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }
    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcGetObjectChildren(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE ProfileType,
    IN AREAPR Area,
    IN wchar_t *ObjectPrefix,
    OUT PSCEPR_OBJECT_CHILDREN __RPC_FAR *Buffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Get immediate children of the object from the context database

Arguments:

    See ScepGetObjectChildren

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !ObjectPrefix || !Buffer ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // prevent empty strings
    //
    if ( ObjectPrefix[0] == L'\0' ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {

#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // query the information now
                //

                rc = ScepGetObjectChildren(
                            (PSCECONTEXT)Context,
                            (SCETYPE)ProfileType,
                            (AREA_INFORMATION)Area,
                            (PWSTR)ObjectPrefix,
                            SCE_IMMEDIATE_CHILDREN,
                            (PVOID *)Buffer,
                            (PSCE_ERROR_LOG_INFO *)Errlog
                            );

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // free Buffer if already allocated
            //
            SceFreeMemory( (PVOID)(*Buffer), SCE_STRUCT_OBJECT_CHILDREN);
            *Buffer = NULL;

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}



SCEPR_STATUS
SceRpcOpenDatabase(
    IN handle_t binding_h,
    IN wchar_t *DatabaseName,
    IN DWORD OpenOption,
    OUT SCEPR_CONTEXT __RPC_FAR *pContext
    )
/*
Routine Description:

    Request a context handle for the database. If bAnalysisRequired is set
    to TRUE, this routine also checks if there is analysis information
    in the database and return error is no analysis info is available.

Arguments:

    DatabaseName - database name

    OpenOption   - SCE_OPEN_OPTION_REQUIRE_ANALYSIS
                        require analysis information in the database
                  SCE_OPEN_OPTION_TATTOO
                        open the tattoo table instead (in system database)

    pContext     - the output context handle

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !pContext || !DatabaseName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    SCESTATUS rc;

    //
    // initialize jet engine in system context
    //
    rc = SceJetInitialize(NULL);

    if ( SCESTATUS_SUCCESS != rc ) {
        return(rc);
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        *pContext = NULL;
        rc = ScepDosErrorToSceStatus(rc);

    } else {

        BOOL    bAdminSidInToken = FALSE;

        rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

        if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
            RpcRevertToSelf();
            return SCESTATUS_SPECIAL_ACCOUNT;
        }
        
        //
        // OpenDatabase is not blocked by any task.
        //

        EnterCriticalSection(&ContextSync);

        __try {

            rc = ScepOpenDatabase(
                        (PCWSTR)DatabaseName,
                        OpenOption,
                        SCEJET_OPEN_READ_WRITE,
                        (PSCECONTEXT *)pContext
                        );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        if ( *pContext && SCESTATUS_SUCCESS == rc ) {
            //
            // if a context is to be returned, add it to the open context list
            //
            ScepAddToOpenContext((PSCECONTEXT)(*pContext));
        }

        LeaveCriticalSection(&ContextSync);

        RpcRevertToSelf();
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // make sure jet engine is terminated if no other acitve clients
        //
        ScepIfTerminateEngine();
    }

    return(rc);
}


SCEPR_STATUS
SceRpcCloseDatabase(
    IN OUT SCEPR_CONTEXT *pContext
    )
/*
Routine Description:

    Request to close the context. If other threads on working under the
    same context, the close request is send to the task list and when
    all pending tasks on the same context are done, the context is freed.

    This API does not wait for the closure of the database.

Arguments:

    Context     - the database context

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    SCESTATUS rc;

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // remove this from the open context too
    //

    if ( pContext && *pContext ) {

        rc = ScepValidateAndCloseDatabase((PSCECONTEXT)(*pContext));

        *pContext = NULL;

        return((SCEPR_STATUS)rc);
    }

    RpcRevertToSelf();

    return 0;
}



SCEPR_STATUS
SceRpcGetDatabaseDescription(
    IN SCEPR_CONTEXT Context,
    OUT wchar_t __RPC_FAR **Description
    )
/*
Routine Description:

    Query database description from the context

Arguments:

    Context     - the database context

    Description - the output buffer of description

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context || !Description ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // the context needs to be locked in case another thread
    // is calling close database on it
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // do not need to lock the context because
            // it's reading information from one record table
            //

            rc = SceJetGetDescription(
                      (PSCECONTEXT)Context,
                      (PWSTR *)Description
                      );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcGetDBTimeStamp(
    IN SCEPR_CONTEXT Context,
    OUT PLARGE_INTEGER ptsConfig,
    OUT PLARGE_INTEGER ptsAnalysis
    )
/*
Routine Description:

    Query the last configuration and analysis time stamp from the context.

Arguments:

    Context     - the database context

    ptsConfig   - the last configuration time stamp

    ptsAnalysis - the last analysis time stamp

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context || !ptsConfig || !ptsAnalysis ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // the context needs to be locked in case another thread
    // is calling close database on it
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // do not need to lock the context because
            // it's reading information from one record table
            //

            rc = SceJetGetTimeStamp(
                     (PSCECONTEXT)Context,
                     ptsConfig,
                     ptsAnalysis
                     );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}


SCEPR_STATUS
SceRpcGetObjectSecurity(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE DbProfileType,
    IN AREAPR Area,
    IN wchar_t *ObjectName,
    OUT PSCEPR_OBJECT_SECURITY __RPC_FAR *ObjSecurity
    )
/*
Routine Description:

    Query security settings for an object from the context database.

Arguments:

    Context     - the database context

    DbProfileType   - the database table type

    Area        - the security area (file, registry, so on.)

    ObjectName  - the object's full name

    ObjSecurity - object security settings structure

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context || !ObjSecurity || !ObjectName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;


    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // query the information now
            //

            rc = ScepGetObjectSecurity(
                        (PSCECONTEXT)Context,
                        (SCETYPE)DbProfileType,
                        (AREA_INFORMATION)Area,
                        (PWSTR)ObjectName,
                        (PSCE_OBJECT_SECURITY *)ObjSecurity
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

        //
        // convert the security descriptor
        //
        if ( ( SCESTATUS_SUCCESS == rc ) &&
             *ObjSecurity &&
             (*ObjSecurity)->pSecurityDescriptor ) {

            //
            // there is a security descriptor, it must be self relative
            // because it's returned from the SDDL api.
            //
            ULONG nLen = RtlLengthSecurityDescriptor (
                                (PSECURITY_DESCRIPTOR)((*ObjSecurity)->pSecurityDescriptor));

            if ( nLen > 0 ) {
                //
                // create a wrapper node to contain the security descriptor
                //

                PSCEPR_SR_SECURITY_DESCRIPTOR pNewWrap;
                pNewWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SCEPR_SR_SECURITY_DESCRIPTOR));
                if ( pNewWrap ) {

                    //
                    // assign the wrap to the structure
                    //
                    pNewWrap->SecurityDescriptor = (UCHAR *)((*ObjSecurity)->pSecurityDescriptor);
                    pNewWrap->Length = nLen;

                    (*ObjSecurity)->pSecurityDescriptor = (SCEPR_SR_SECURITY_DESCRIPTOR *)pNewWrap;

                } else {
                    //
                    // no memory is available, but still continue to parse all nodes
                    //
                    nLen = 0;
                }
            }

            if ( nLen == 0 ) {
                //
                // something wrong with this security descriptor
                // free the buffer
                //
                ScepFree((*ObjSecurity)->pSecurityDescriptor);
                (*ObjSecurity)->pSecurityDescriptor = NULL;
                (*ObjSecurity)->SeInfo = 0;
            }

        }

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcGetAnalysisSummary(
    IN SCEPR_CONTEXT Context,
    IN AREAPR Area,
    OUT PDWORD pCount
    )
/*
Routine Description:

    Query security settings for an object from the context database.

Arguments:

    Context     - the database context

    Area        - the security area (file, registry, so on.)

    pCount      - the output count

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context || !pCount ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // query the information now
            //

            rc = ScepGetAnalysisSummary(
                        (PSCECONTEXT)Context,
                        (AREA_INFORMATION)Area,
                        pCount
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcAnalyzeSystem(
    IN handle_t binding_h,
    IN wchar_t *InfFileName OPTIONAL,
    IN wchar_t *DatabaseName OPTIONAL,
    IN wchar_t *LogFileName OPTIONAL,
    IN AREAPR Area,
    IN DWORD AnalyzeOptions,
    IN DWORD pebSize,
    IN UCHAR *pebClient OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    )
/*
Routine Description:

    Analyze the system using the Inf template and/or existing
    database info

Arguments:

    See ScepAnalyzeSystem

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    SCESTATUS rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // initialize jet engine in system context
    //
    rc = SceJetInitialize(NULL);

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    //
    // impersonate the client, return DWORD error code
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        ScepIfTerminateEngine();

        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // get the database name
    //

    BOOL bAdminLogon=FALSE;
    LPTSTR DefProfile=NULL;

    __try {

        rc = ScepGetDefaultDatabase(
                 (AnalyzeOptions & SCE_GENERATE_ROLLBACK) ? NULL : (LPCTSTR)DatabaseName,
                 AnalyzeOptions,
                 (LPCTSTR)LogFileName,
                 &bAdminLogon,
                 &DefProfile
                 );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        rc = ERROR_EXCEPTION_IN_SERVICE;
    }

    if ( (AnalyzeOptions & SCE_GENERATE_ROLLBACK)
         && !bAdminLogon  ) {
        //
        // only allow admin to use system database to generate rollback
        // is this the correct design?
        //
        rc = ERROR_ACCESS_DENIED;
    }

    if ( ERROR_SUCCESS == rc && DefProfile ) {

        //
        // validate access to the database
        //
        rc = ScepDatabaseAccessGranted( DefProfile,
                                        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                                        TRUE
                                      );
    }

    rc = ScepDosErrorToSceStatus(rc);

    if ( SCESTATUS_SUCCESS == rc && DefProfile ) {

        //
        // validate the database to see if there is any configuration/
        // analysis running on other threads
        //

        rc = ScepLockEngine(DefProfile);

        if ( SCESTATUS_SUCCESS == rc ) {

            t_pebClient = (LPVOID)pebClient;
            t_pebSize = pebSize;

            //
            // it's ok to continue this operation
            // no other threads are running configuration/analysis
            // based on the same database
            //

            DWORD dOptions = AnalyzeOptions;
            if ( !(AnalyzeOptions & SCE_GENERATE_ROLLBACK) ) {
                if ( !DatabaseName ||
                    ( bAdminLogon && SceIsSystemDatabase(DatabaseName)) ) {

                    dOptions |= SCE_SYSTEM_DB;
                }
            }

            __try {

                rc = ScepAnalyzeSystem(
                        (LPCTSTR)InfFileName,
                        DefProfile,
                        dOptions,
                        bAdminLogon,
                        (AREA_INFORMATION)Area,
                        pdWarning,
                        (AnalyzeOptions & SCE_GENERATE_ROLLBACK) ? DatabaseName : NULL
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

            //
            // unlock the engine for this database
            //

            ScepUnlockEngine(DefProfile);
        }
    }

    if ( DefProfile && DefProfile != DatabaseName ) {
        ScepFree(DefProfile);

    }

    ScepLogClose();

    //
    // change context back
    //

    RpcRevertToSelf();

    //
    // start a timer queue to check to see if there is active tasks/contexts
    // if not, terminate jet engine
    //
    ScepIfTerminateEngine();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcUpdateDatabaseInfo(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE ProfileType,
    IN AREAPR Area,
    IN PSCEPR_PROFILE_INFO pInfo,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update database in the context using pInfo

Arguments:

    Context     - the database context

    ProfileType - the database table type

    Area        - the security area (security policy... except objects's area)

    pInfo       - the info to update

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context || !pInfo ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }



    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        PSCEPR_SERVICES pOldServices = pInfo->pServices;

        //
        // Convert SCEPR_PROFILE_INFO into SCE_PROFILE_INFO
        //
        if ( (Area & AREA_SYSTEM_SERVICE) &&
             pOldServices ) {

            rc = ScepConvertServices( (PVOID *)&(pInfo->pServices), TRUE );

        } else {
            pInfo->pServices = NULL;
        }


        if ( SCESTATUS_SUCCESS == rc ) {

            //
            // lock the context
            //

            if ( pTask ) {
                EnterCriticalSection(&(pTask->Sync));
            }

            __try {

    #ifdef SCE_JET_TRAN
                rc = SceJetJetErrorToSceStatus(
                        JetSetSessionContext(
                            ((PSCECONTEXT)Context)->JetSessionID,
                            (ULONG_PTR)Context
                            ));

                if ( SCESTATUS_SUCCESS == rc ) {
    #endif
                    //
                    // update the information now
                    //

                    if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {

                        //
                        // update local policy only
                        //
                        rc = ScepUpdateLocalTable(
                                    (PSCECONTEXT)Context,
                                    (AREA_INFORMATION)Area,
                                    (PSCE_PROFILE_INFO)pInfo,
                                    dwMode
                                    );
                    } else {
                        //
                        // update the database (SMP and SAP)
                        //
                        rc = ScepUpdateDatabaseInfo(
                                    (PSCECONTEXT)Context,
                                    (AREA_INFORMATION)Area,
                                    (PSCE_PROFILE_INFO)pInfo
                                    );
                    }

    #ifdef SCE_JET_TRAN
                    JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

                }
    #endif

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

            //
            // unlock the context
            //

            if ( pTask ) {
                LeaveCriticalSection(&(pTask->Sync));
            }

            ScepFreeConvertedServices( pInfo->pServices, FALSE );

        }

        pInfo->pServices = pOldServices;

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcUpdateObjectInfo(
    IN SCEPR_CONTEXT Context,
    IN AREAPR Area,
    IN wchar_t *ObjectName,
    IN DWORD NameLen,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN SCEPR_SR_SECURITY_DESCRIPTOR *pSD OPTIONAL,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    )
/*
Routine Description:

    Update object's security settings in the database.

Arguments:

    See ScepUpdateObjectInfo

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context || !ObjectName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }
#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // update the object info now
            //

            __try {

                rc = ScepUpdateObjectInfo(
                            (PSCECONTEXT)Context,
                            (AREA_INFORMATION)Area,
                            (PWSTR)ObjectName,
                            NameLen,
                            ConfigStatus,
                            IsContainer,
                            pSD ? (PSECURITY_DESCRIPTOR)(pSD->SecurityDescriptor) : NULL,
                            SeInfo,
                            pAnalysisStatus
                            );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcStartTransaction(
    IN SCEPR_CONTEXT Context
    )
/*
Routine Description:

    Start a transaction on the context. If other threads sharing the same
    context, their changes will also be controlled by this transaction.

    It's the caller's responsible to not share the same context for
    transactioning.

Arguments:

    See SceJetStartTransaction

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        //
        // start transaction on this context
        //
#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            rc = SceJetStartTransaction(
                        (PSCECONTEXT)Context
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcCommitTransaction(
    IN SCEPR_CONTEXT Context
    )
/*
Routine Description:

    Commit a transaction on the context. If other threads sharing the same
    context, their changes will also be controlled by this transaction.

    It's the caller's responsible to not share the same context for
    transactioning.

Arguments:

    See SceJetCommitTransaction

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        //
        // set the context to the jet session so thread id is not used for this
        // operation.
        //
#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // commit transaction on this context
            //

            rc = SceJetCommitTransaction(
                        (PSCECONTEXT)Context,
                        0
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcRollbackTransaction(
    IN SCEPR_CONTEXT Context
    )
/*
Routine Description:

    Rollback a transaction on the context. If other threads sharing the same
    context, their changes will also be controlled by this transaction.

    It's the caller's responsible to not share the same context for
    transactioning.

Arguments:

    See SceJetRollback

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        //
        // set the context to the jet session so thread id is not used for this
        // operation.
        //

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // rollback transaction on this context
            //

            rc = SceJetRollback(
                        (PSCECONTEXT)Context,
                        0
                        );

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);
        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}


SCEPR_STATUS
SceRpcGetServerProductType(
    IN handle_t binding_h,
    OUT PSCEPR_SERVER_TYPE srvProduct
    )
/*
Routine Description:

    Get SCE server's product type

Arguments:

Return Value:

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !srvProduct ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // impersonate the client
    //

    BOOL    bAdminSidInToken = FALSE;
    DWORD rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;

    }

    ScepGetProductType((PSCE_SERVER_TYPE)srvProduct);

    RpcRevertToSelf();

    return(SCESTATUS_SUCCESS);
}



SCEPR_STATUS
SceSvcRpcUpdateInfo(
    IN SCEPR_CONTEXT Context,
    IN wchar_t *ServiceName,
    IN PSCEPR_SVCINFO Info
    )
/*
Routine Description:

    Update information for the service to the database.

Arguments:

    Context     - the context handle

    ServiceName - the service name for which info is requested

    Info     - output buffer

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context || !ServiceName || !Info ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // update the service info now
            //

            __try {

                rc = SceSvcpUpdateInfo(
                        (PSCECONTEXT)Context,
                        (LPCTSTR)ServiceName,
                        (PSCESVC_CONFIGURATION_INFO)Info
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                rc = SCESTATUS_EXCEPTION_IN_SERVER;
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}



SCEPR_STATUS
SceRpcCopyObjects(
    IN SCEPR_CONTEXT Context,
    IN SCEPR_TYPE ProfileType,
    IN wchar_t *InfFileName,
    IN AREAPR Area,
    OUT PSCEPR_ERROR_LOG_INFO *pErrlog OPTIONAL
    )
/*
Routine Description:

    Update information for the service to the database.

Arguments:

    Context     - the context handle

    InfFileName - the inf template name to copy to

    Area        - which area(s) to copy

    pErrlog     - the error log buffer

Return Value:

    SCEPR_STATUS
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !Context || !InfFileName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !Area ) {
        //
        // nothing to copy
        //
        return(SCESTATUS_SUCCESS);
    }

    if ( ProfileType != SCE_ENGINE_SCP &&
         ProfileType != SCE_ENGINE_SMP ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // impersonate the client
    //

    SCESTATUS rc;

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif

            //
            // query the information now
            //

            if ( Area & AREA_REGISTRY_SECURITY ) {

                rc = ScepCopyObjects(
                        (PSCECONTEXT)Context,
                        (SCETYPE)ProfileType,
                        (LPTSTR)InfFileName,
                        szRegistryKeys,
                        AREA_REGISTRY_SECURITY,
                        (PSCE_ERROR_LOG_INFO *)pErrlog
                        );
            }

            if ( SCESTATUS_SUCCESS == rc &&
                 Area & AREA_FILE_SECURITY ) {

                rc = ScepCopyObjects(
                        (PSCECONTEXT)Context,
                        (SCETYPE)ProfileType,
                        (LPTSTR)InfFileName,
                        szFileSecurity,
                        AREA_FILE_SECURITY,
                        (PSCE_ERROR_LOG_INFO *)pErrlog
                        );
            }
#if 0
            if ( SCESTATUS_SUCCESS == rc &&
                 Area & AREA_DS_OBJECTS ) {

                rc = ScepCopyObjects(
                        (PSCECONTEXT)Context,
                        (SCETYPE)ProfileType,
                        (LPTSTR)InfFileName,
                        szDSSecurity,
                        AREA_DS_OBJECTS,
                        (PSCE_ERROR_LOG_INFO *)pErrlog
                        );
            }
#endif
            if ( SCESTATUS_SUCCESS == rc &&
                 Area & AREA_SYSTEM_SERVICE ) {

                rc = ScepCopyObjects(
                        (PSCECONTEXT)Context,
                        (SCETYPE)ProfileType,
                        (LPTSTR)InfFileName,
                        szServiceGeneral,
                        AREA_SYSTEM_SERVICE,
                        (PSCE_ERROR_LOG_INFO *)pErrlog
                        );
            }

            SCESVC_INFO_TYPE iType;
            switch ( ProfileType ) {
            case SCE_ENGINE_SCP:
                iType = SceSvcMergedPolicyInfo;
                break;
            case SCE_ENGINE_SMP:
                iType = SceSvcConfigurationInfo;
                break;
            }

            if ( SCESTATUS_SUCCESS == rc &&
                 ( Area & AREA_SYSTEM_SERVICE) ) {

                rc = ScepGenerateAttachmentSections(
                        (PSCECONTEXT)Context,
                        iType,
                        (LPTSTR)InfFileName,
                        SCE_ATTACHMENT_SERVICE
                        );
            }
            if ( SCESTATUS_SUCCESS == rc &&
                 (Area & AREA_SECURITY_POLICY) ) {

                rc = ScepGenerateAttachmentSections(
                        (PSCECONTEXT)Context,
                        iType,
                        (LPTSTR)InfFileName,
                        SCE_ATTACHMENT_POLICY
                        );
            }
            if ( SCESTATUS_SUCCESS == rc &&
                 ( Area & AREA_ATTACHMENTS) ) {

                rc = ScepGenerateWMIAttachmentSections(
                        (PSCECONTEXT)Context,
                        iType,
                        (LPTSTR)InfFileName
                        );
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}

SCEPR_STATUS
SceRpcSetupResetLocalPolicy(
    IN SCEPR_CONTEXT  Context,
    IN AREAPR         Area,
    IN wchar_t        *OneSectionName OPTIONAL,
    IN DWORD          PolicyOptions
    )
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    TRUE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

#ifdef SCE_JET_TRAN
        rc = SceJetJetErrorToSceStatus(
                JetSetSessionContext(
                    ((PSCECONTEXT)Context)->JetSessionID,
                    (ULONG_PTR)Context
                    ));

        if ( SCESTATUS_SUCCESS == rc ) {
#endif
            //
            // remove policies from the local table
            //
            if ( PolicyOptions & SCE_RESET_POLICY_SYSPREP ) {

                ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                               (AREA_INFORMATION)Area,
                                               NULL,
                                               SCE_ENGINE_SMP,
                                               FALSE
                                              );
                ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                               (AREA_INFORMATION)Area,
                                               NULL,
                                               SCE_ENGINE_SCP,
                                               FALSE
                                              );

                rc = ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                               (AREA_INFORMATION)Area,
                                               NULL,
                                               SCE_ENGINE_SAP,  // for the tattoo table
                                               FALSE
                                              );
            } else {

                if ( PolicyOptions & SCE_RESET_POLICY_TATTOO ) {
                    // after dcpromo, we need to reset the tattoo values
                    rc = ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                                   (AREA_INFORMATION)Area,
                                                   (PCWSTR)OneSectionName,
                                                   SCE_ENGINE_SAP, // for the tattoo table
                                                   FALSE
                                                  );
                }

                rc = ScepSetupResetLocalPolicy((PSCECONTEXT)Context,
                                               (AREA_INFORMATION)Area,
                                               (PCWSTR)OneSectionName,
                                               SCE_ENGINE_SMP,
                                               (PolicyOptions & SCE_RESET_POLICY_KEEP_LOCAL)
                                              );

                if ( (PolicyOptions & SCE_RESET_POLICY_ENFORCE_ATREBOOT ) &&
                    ( (((PSCECONTEXT)Context)->Type & 0xF0L) == SCEJET_MERGE_TABLE_1 ||
                      (((PSCECONTEXT)Context)->Type & 0xF0L) == SCEJET_MERGE_TABLE_2 ) &&
                    ((PSCECONTEXT)Context)->JetScpID != ((PSCECONTEXT)Context)->JetSmpID ) {
                    //
                    // there is effective policy table already in the database
                    // (and this is in setup upgrade)
                    // update local group policy table to trigger a policy prop at reboot
                    //

                    ScepEnforcePolicyPropagation();
                }
            }

#ifdef SCE_JET_TRAN
            JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

        }
#endif
        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}



SCESTATUS
ScepGenerateAttachmentSections(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName,
    IN SCE_ATTACHMENT_TYPE aType
    )
{
    SCESTATUS rc;
    PSCE_SERVICES    pServiceList=NULL, pNode;

    rc = ScepEnumServiceEngines( &pServiceList, aType );

    if ( rc == SCESTATUS_SUCCESS ) {

       for ( pNode=pServiceList; pNode != NULL; pNode=pNode->Next) {
           //
           // generate section for one attachment
           //
           rc = ScepGenerateOneAttachmentSection(hProfile,
                                                 InfoType,
                                                 InfFileName,
                                                 pNode->ServiceName,
                                                 FALSE
                                                );

           if ( rc != SCESTATUS_SUCCESS ) {
               ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                             SCEDLL_ERROR_CONVERT_SECTION, pNode->ServiceName );
               break;
           }
       }

       SceFreePSCE_SERVICES(pServiceList);

    }

    if ( rc == SCESTATUS_PROFILE_NOT_FOUND ||
                rc == SCESTATUS_RECORD_NOT_FOUND ) {
        // if no service exist, just ignore
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);

}

SCESTATUS
ScepGenerateWMIAttachmentSections(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName
    )
{
    SCESTATUS rc;
    PSCE_NAME_LIST    pList=NULL, pNode;

    rc = ScepEnumAttachmentSections( hProfile, &pList);

    if ( rc == SCESTATUS_SUCCESS ) {

       for ( pNode=pList; pNode != NULL; pNode=pNode->Next) {

           //
           // generate section for one attachment
           //
           rc = ScepGenerateOneAttachmentSection(hProfile,
                                                 InfoType,
                                                 InfFileName,
                                                 pNode->Name,
                                                 TRUE
                                                );

           if ( rc != SCESTATUS_SUCCESS ) {
               ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                             SCEDLL_ERROR_CONVERT_SECTION, pNode->Name );
               break;
           }
       }

       ScepFreeNameList(pList);

    }

    if ( rc == SCESTATUS_PROFILE_NOT_FOUND ||
                rc == SCESTATUS_RECORD_NOT_FOUND ) {
        // if no service exist, just ignore
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);

}

SCESTATUS
ScepGenerateOneAttachmentSection(
    IN PSCECONTEXT hProfile,
    IN SCESVC_INFO_TYPE InfoType,
    IN LPTSTR InfFileName,
    IN LPTSTR SectionName,
    IN BOOL bWMISection
    )
{
    //
    // read inf info for the section
    //
    SCESTATUS rc;
    SCE_ENUMERATION_CONTEXT sceEnumHandle=0;
    DWORD CountReturned;
    PSCESVC_CONFIGURATION_INFO pAttachInfo=NULL;

    do {

       CountReturned = 0;

       rc = SceSvcpQueryInfo(
                hProfile,
                InfoType,
                SectionName,
                NULL,
                FALSE,
                (PVOID *)&pAttachInfo,
                &sceEnumHandle
                );

       if ( rc == SCESTATUS_SUCCESS && pAttachInfo != NULL &&
            pAttachInfo->Count > 0 ) {
           //
           // got something
           //
           CountReturned = pAttachInfo->Count;

           //
           // copy each line
           //
           for ( DWORD i=0; i<pAttachInfo->Count; i++ ) {

               if ( pAttachInfo->Lines[i].Key == NULL ||
                    pAttachInfo->Lines[i].Value == NULL ) {
                   continue;
               }

               if ( !WritePrivateProfileString(
                               SectionName,
                               pAttachInfo->Lines[i].Key,
                               pAttachInfo->Lines[i].Value,
                               InfFileName
                               ) ) {

                   rc = ScepDosErrorToSceStatus(GetLastError());
                   break;
               }
           }

           if ( bWMISection ) {

               //
               // make sure to create the szAttachments section
               //
               if ( !WritePrivateProfileString(
                               szAttachments,
                               SectionName,
                               L"Include",
                               InfFileName
                               ) ) {

                   rc = ScepDosErrorToSceStatus(GetLastError());
               }
           }
       }

       SceSvcpFreeMemory((PVOID)pAttachInfo);
       pAttachInfo = NULL;

    } while ( rc == SCESTATUS_SUCCESS && CountReturned > 0 );

    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
       rc = SCESTATUS_SUCCESS;
    }

    return rc;

}

void __RPC_USER
SCEPR_CONTEXT_rundown( SCEPR_CONTEXT Context)
{

    SCESTATUS rc;

    //
    // this client is shutting down
    //

    rc = ScepValidateAndCloseDatabase((PSCECONTEXT)Context);

    return;
}



SCESTATUS
ScepOpenDatabase(
    IN PCWSTR DatabaseName,
    IN DWORD  OpenOption,
    IN SCEJET_OPEN_TYPE OpenType,
    OUT PSCECONTEXT *pContext
    )
/*
Routine Description:

    This routine opens the database and returns a context handle.
    OpenDatabase can be called by multiple clients for the same database
    and we do not block multiple access because each client will get
    a duplicate database cursor and have their own working tables.

    When a database is changed by other clients, all cursors will be
    synchronized. Clients who had retrived "old" data are responsible
    to refresh their data buffer. No notification is provided at this
    point.

Arguments:

Return Value:


*/
{
    if ( !DatabaseName || !pContext ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS    rc;
    //
    // check access of the database (with current client token)
    //
    DWORD Access=0;

    if ( SCEJET_OPEN_READ_ONLY == OpenType ) {

//      BUG in ESENT
//      Even ask for read only, ESENT still writes to the database
//        Access = FILE_GENERIC_READ;
        Access = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
    } else {
        Access = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
    }

    rc = ScepDatabaseAccessGranted((LPTSTR)DatabaseName,
                                   Access,
                                   FALSE
                                  );

    if ( rc != ERROR_SUCCESS ) {

        ScepLogOutput2(1,rc,L"%s", DatabaseName);

        return( ScepDosErrorToSceStatus(rc) );
    }

    DWORD       Len;
    DWORD       MBLen=0;
    PCHAR       FileName=NULL;
    NTSTATUS    NtStatus;

    //
    // convert WCHAR into ANSI
    //

    Len = wcslen( DatabaseName );

    NtStatus = RtlUnicodeToMultiByteSize(&MBLen, (PWSTR)DatabaseName, Len*sizeof(WCHAR));

    if ( !NT_SUCCESS(NtStatus) ) {
        //
        // cannot get the length, set default to 512
        //
        MBLen = 512;
    }

    FileName = (PCHAR)ScepAlloc( LPTR, MBLen+2);

    if ( FileName == NULL ) {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    } else {

        NtStatus = RtlUnicodeToMultiByteN(
                        FileName,
                        MBLen+1,
                        NULL,
                        (PWSTR)DatabaseName,
                        Len*sizeof(WCHAR)
                        );

        if ( !NT_SUCCESS(NtStatus) ) {
            rc = SCESTATUS_PROFILE_NOT_FOUND;

        } else {

            //
            // make sure the context buffer is initialized
            //

            *pContext = NULL;

            rc = SceJetOpenFile(
                        (LPSTR)FileName,
                        OpenType, //SCEJET_OPEN_READ_WRITE,
                        (OpenOption == SCE_OPEN_OPTION_TATTOO ) ? SCE_TABLE_OPTION_TATTOO : 0,
                        pContext
                        );

            if ( (OpenOption == SCE_OPEN_OPTION_REQUIRE_ANALYSIS ) &&
                 SCESTATUS_SUCCESS == rc &&
                 *pContext ) {

                if ( (*pContext)->JetSapID == JET_tableidNil ) {

                    //
                    // no analysis information is available
                    //

                    rc = SCESTATUS_PROFILE_NOT_FOUND;

                    //
                    // free handle
                    //

                    SceJetCloseFile(
                            *pContext,
                            TRUE,
                            FALSE
                            );
                    *pContext = NULL;
                }

            }
        }
        ScepFree( FileName );

    }

    return(rc);
}


SCESTATUS
ScepCloseDatabase(
    IN PSCECONTEXT Context
    )
{
    SCESTATUS rc;

    if ( !Context ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    __try {

        if ( ScepIsValidContext(Context) ) {

            //
            // be able to access the first byte
            //

            rc = SceJetCloseFile(
                    Context,
                    TRUE,
                    FALSE
                    );
        } else {
            //
            // this context is not our context or already be freed
            //
            rc = SCESTATUS_INVALID_PARAMETER;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    return(rc);

}

DWORD
SceRpcControlNotificationQProcess(
    IN handle_t binding_h,
    IN DWORD Flag
    )
/*
Description:

    This function should be called by a system thread to control that policy
    notification queue process should be suspended or resumed.

    The purpose of this function is to protect policy changes being overwritten
    by policy proapgation when the GPO file is copied/imported into the database

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return ERROR_ACCESS_DENIED;

    }
    
    //
    // even though there might be a shutdown request
    // we need to let the control go through
    //

    DWORD rc=ERROR_SUCCESS;

    if ( Flag ) {

        ScepNotifyLogPolicy(0, TRUE, L"RPC enter Suspend queue.", 0, 0, NULL );
        //
        // this thread is called from policy propagation which is guaranteed to
        // run by one thread (system context). No need to protect the global buffer
        //
        gPolicyWaitCount++;

        if ( pNotificationQHead ) {

            if ( gPolicyWaitCount < SCE_POLICY_MAX_WAIT ) {
                //
                // queue is not empty, should not propagate policy
                //
                ScepNotifyLogPolicy(0, FALSE, L"Queue is not empty, abort.", 0, 0, NULL );
                return (ERROR_OVERRIDE_NOCHANGES);

            } else {

                ScepNotifyLogPolicy(0, FALSE, L"Resetting policy wait count.", 0, 0, NULL );
                gPolicyWaitCount = 0;

            }
        } else {
            gPolicyWaitCount = 0;
        }

    } else {

        ScepNotifyLogPolicy(0, TRUE, L"RPC enter Resume queue.", 0, 0, NULL );
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        ScepNotifyLogPolicy(rc, FALSE, L"Impersonation Failed", 0, 0, NULL );
        return( rc );
    }

    //
    // perform access check to make sure that only
    // system thread can make the call
    //
    HANDLE hToken = NULL;

    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY,
                          FALSE,
                          &hToken)) {

        rc = GetLastError();

        ScepNotifyLogPolicy(rc, FALSE, L"Fail to query token", 0, 0, NULL );
        return( rc );
    }

    BOOL b=FALSE;

    rc = RtlNtStatusToDosError( ScepIsSystemContext(hToken, &b) );

    if ( rc != ERROR_SUCCESS || !b ) {

        CloseHandle(hToken);

        ScepNotifyLogPolicy(rc, FALSE, L"Not system context", 0, 0, NULL );
        return( rc ? rc : ERROR_ACCESS_DENIED );
    }

    CloseHandle(hToken);

    //
    // now set the control flag
    //

    ScepNotificationQControl(Flag);

    RpcRevertToSelf();

    return(rc);
}

DWORD
SceRpcNotifySaveChangesInGP(
    IN handle_t binding_h,
    IN DWORD DbType,
    IN DWORD DeltaType,
    IN DWORD ObjectType,
    IN PSCEPR_SID ObjectSid OPTIONAL,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight
    )
/*
Description:

    This function should be called by a system thread to notify that policy
    in LSA/SAM databases are changed programmatically by other applications.
    The purpose of this function is to synchronize policy store with LSA/SAM
    databases so that application changes won't be overwritten by next
    policy propagation.

    This function will add the notification to a queue for server to process.
    Only system context can add a node to the queue.

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return ERROR_ACCESS_DENIED;

    }
    
    //
    // even though there might be a shutdown request
    // we need to let notification saved before allowing shutdown
    //

    DWORD rc=ERROR_SUCCESS;

    ScepNotifyLogPolicy(0, TRUE, L"Notified DC", DbType, ObjectType, NULL );

    if ( ObjectSid ) {

        __try {

            if ( !RtlValidSid(ObjectSid) ) {
                rc = GetLastError();
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // objectsid buffer is invalid
            rc = ERROR_EXCEPTION_IN_SERVICE;
        }

        if ( rc != ERROR_SUCCESS ) {
            ScepNotifyLogPolicy(0, FALSE, L"Invalid Sid", DbType, ObjectType, NULL );
            return(rc);
        }
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        ScepNotifyLogPolicy(rc, FALSE, L"Impersonation Failed", DbType, ObjectType, NULL );
        return( rc );
    }

    //
    // perform access check to make sure that only
    // system thread can make the call
    //
    HANDLE hToken = NULL;

    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY,
                          FALSE,
                          &hToken)) {

        rc = GetLastError();

        ScepNotifyLogPolicy(rc, FALSE, L"Fail to query token", DbType, ObjectType, NULL );
        return( rc );
    }

    BOOL b=FALSE;

    rc = RtlNtStatusToDosError( ScepIsSystemContext(hToken, &b) );

    if ( rc != ERROR_SUCCESS || !b ) {

        CloseHandle(hToken);

        ScepNotifyLogPolicy(rc, FALSE, L"Not system context", DbType, ObjectType, NULL );
        return( rc ? rc : ERROR_ACCESS_DENIED );
    }

    CloseHandle(hToken);

    //
    // Add the request to the "queue" for further process
    //
    rc = ScepNotificationQEnqueue((SECURITY_DB_TYPE)DbType,
                                  (SECURITY_DB_DELTA_TYPE)DeltaType,
                                  (SECURITY_DB_OBJECT_TYPE)ObjectType,
                                  (PSID)ObjectSid,
                                  ExplicitLowRight,
                                  ExplicitHighRight,
                                  NULL
                                  );

    RpcRevertToSelf();

    return(rc);
}

DWORD
ScepNotifyProcessOneNodeDC(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID ObjectSid,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight
    )
/*
Description:

    This function is called by the queue management thread to process one
    notification node in the queue. This function will determine which group
    policy template to save to and what are the differences between current
    state of LSA/SAM and group policy.

    Group policy is only modified when there is a difference detected. Group
    policy version # is updated on save. This function is always called in a
    single system thread.

    if scecli.dll fails to be loaded, ERROR_MOD_NOT_FOUND will be returned.

    if sysvol share is not ready, the error returned will be ERROR_FILE_NOT_FOUND.
    However if the template file doesn't exist (deleted), ERROR_FILE_NOT_FOUND will
    also be returned. This case is handled the same way as the share/path doesn't
    exist (error logged and retried) because the GPOs are required to be there for
    replication purpose. But in the future, when the dependency is removed from
    domain controllers GPO, we might need to separate the two cases (one success,
    one failure).

    If disk is full, the error returned will be ERROR_EXTENDED_ERROR.

*/
{

    //
    // query if I am in setup
    //
    DWORD dwInSetup = 0;
    DWORD rc=0;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("System\\Setup"),
                TEXT("SystemSetupInProgress"),
                &dwInSetup
                );

    PWSTR TemplateName=NULL;

    if ( dwInSetup && !IsNT5()) {

        //
        // if it's in setup, group policy templates are not available (DS is down)
        // save the notifications to a temperaory store and process the
        // store at next system start up.
        //
        ScepNotifyLogPolicy(0, FALSE, L"In setup", DbType, ObjectType, NULL );

        UNICODE_STRING tmp;
        tmp.Length = 0;
        tmp.Buffer = NULL;
        BOOL bAccountGPO=FALSE;

        if ( DbType == SecurityDbSam &&
             ObjectType != SecurityDbObjectSamUser &&
             ObjectType != SecurityDbObjectSamGroup &&
             ObjectType != SecurityDbObjectSamAlias ) {
            //
            // if it's for deleted account, should update user right GPO
            // otherwise, update the account GPO
            //
            bAccountGPO = TRUE;
        }

        //
        // get the default template name
        //
        rc = ScepNotifyGetDefaultGPOTemplateName(
                                tmp,
                                bAccountGPO,
                                SCEGPO_INSETUP_NT4,
                                &TemplateName
                                );

        if ( ERROR_SUCCESS == rc && TemplateName ) {

            //
            // save the transaction in this temp file
            //
            rc = ScepNotifySaveNotifications(TemplateName,
                                            (SECURITY_DB_TYPE)DbType,
                                            (SECURITY_DB_OBJECT_TYPE)ObjectType,
                                            (SECURITY_DB_DELTA_TYPE)DeltaType,
                                            (PSID)ObjectSid
                                             );

            ScepNotifyLogPolicy(rc, FALSE, L"Notification Saved", DbType, ObjectType, TemplateName );

        } else {

            ScepNotifyLogPolicy(rc, FALSE, L"Error get file path", DbType, ObjectType, NULL );
        }

        //
        // free TemplateName
        //
        LocalFree(TemplateName);

        return rc;
    }

    //
    // let's check if scecli is loaded in the process
    // once it's loaded, it will stay loaded.
    //
    if ( hSceCliDll == NULL )
        hSceCliDll = LoadLibrary(TEXT("scecli.dll"));

    if ( hSceCliDll ) {
        if ( pfSceInfWriteInfo == NULL ) {
            pfSceInfWriteInfo = (PFSCEINFWRITEINFO)GetProcAddress(
                                                   hSceCliDll,
                                                   "SceWriteSecurityProfileInfo");
        }

        if ( pfSceGetInfo == NULL ) {
            pfSceGetInfo = (PFSCEGETINFO)GetProcAddress(
                                                   hSceCliDll,
                                                   "SceGetSecurityProfileInfo");
        }
    }

    //
    // if shutdown/stop service is requested, or client functions can't be found
    // quit now
    //

    if ( bStopRequest || !hSceCliDll ||
         !pfSceInfWriteInfo || !pfSceGetInfo ) {

        if ( bStopRequest ) {
            ScepNotifyLogPolicy(0, FALSE, L"Leave - Stop Requested", DbType, ObjectType, NULL );
        } else {
            rc = ERROR_MOD_NOT_FOUND;
            ScepNotifyLogPolicy(0, FALSE, L"Leave - Can't load scecli.dll or GetProcAddr", DbType, ObjectType, NULL );
        }

        return(rc);
    }

    //
    // domain DNS name is required to access the sysvol portion of group policy
    // templates.
    //
    // This information is only queried once and saved in the static global buffer.
    //
    if ( (DnsDomainInfo == NULL) ||
         (DnsDomainInfo->DnsDomainName.Buffer == NULL) ) {

        //
        // free the old buffer
        //
        if ( DnsDomainInfo ) {
            LsaFreeMemory(DnsDomainInfo);
            DnsDomainInfo = NULL;
        }

        OBJECT_ATTRIBUTES ObjectAttributes;
        LSA_HANDLE LsaPolicyHandle;

        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

        NTSTATUS Status = LsaOpenPolicy( NULL,
                                         &ObjectAttributes,
                                         POLICY_VIEW_LOCAL_INFORMATION,
                                         &LsaPolicyHandle );

        if ( NT_SUCCESS(Status) ) {

            Status = LsaQueryInformationPolicy( LsaPolicyHandle,
                                                PolicyDnsDomainInformation,
                                                ( PVOID * )&DnsDomainInfo );

            LsaClose( LsaPolicyHandle );
        }

        rc = RtlNtStatusToDosError(Status);
    }

    //
    // get the template name (full UNC path) in sysvol
    //
    if ( ERROR_SUCCESS == rc &&
         DnsDomainInfo &&
         (DnsDomainInfo->DnsDomainName.Buffer) ) {

        BOOL bAccountGPO=FALSE;

        if ( DbType == SecurityDbSam &&
             ObjectType != SecurityDbObjectSamUser &&
             ObjectType != SecurityDbObjectSamGroup &&
             ObjectType != SecurityDbObjectSamAlias ) {
            //
            // if it's for deleted account, should update user right GPO
            // otherwise, update the account GPO
            //
            bAccountGPO = TRUE;
        }

        rc = ScepNotifyGetDefaultGPOTemplateName(
                                (UNICODE_STRING)(DnsDomainInfo->DnsDomainName),
                                bAccountGPO,
                                dwInSetup ? SCEGPO_INSETUP_NT5 : 0,
                                &TemplateName
                                );
    }

    ScepNotifyLogPolicy(rc, FALSE, L"Get template name", DbType, ObjectType, TemplateName);

    if ( ERROR_SUCCESS == rc && TemplateName ) {

        AREA_INFORMATION Area;
        PSCE_PROFILE_INFO pSceInfo=NULL;

        //
        // open template to get the existing template info
        //

        SCE_HINF hProfile;

        hProfile.Type = (BYTE)SCE_INF_FORMAT;

        rc = SceInfpOpenProfile(
                TemplateName,
                &(hProfile.hInf)
                );

        rc = ScepSceStatusToDosError(rc);

        if ( ERROR_SUCCESS == rc ) {

            if ( (DbType == SecurityDbLsa &&
                  ObjectType == SecurityDbObjectLsaAccount) ||
                 (DbType == SecurityDbSam &&
                  (ObjectType == SecurityDbObjectSamUser ||
                   ObjectType == SecurityDbObjectSamGroup ||
                   ObjectType == SecurityDbObjectSamAlias )) ) {
                Area = AREA_ATTACHMENTS; // just create the buffer;
            } else {
                Area = AREA_SECURITY_POLICY;
            }

            //
            // load informatin from the template (GP)
            //
            rc = (*pfSceGetInfo)(
                        (PVOID)&hProfile,
                        SCE_ENGINE_SCP,
                        Area,
                        &pSceInfo,
                        NULL
                        );

            rc = ScepSceStatusToDosError(rc);

            if ( ERROR_SUCCESS != rc ) {

                ScepNotifyLogPolicy(rc, FALSE, L"Error read inf", DbType, ObjectType, TemplateName);
            }

            if ( Area == AREA_ATTACHMENTS ) {
                //
                // now get the real settings for user rights
                //
                Area = AREA_PRIVILEGES;

                if ( pSceInfo ) {

                    rc = SceInfpGetPrivileges(
                                hProfile.hInf,
                                FALSE,
                                &(pSceInfo->OtherInfo.smp.pPrivilegeAssignedTo),
                                NULL
                                );

                    rc = ScepSceStatusToDosError(rc);

                    if ( ERROR_SUCCESS != rc ) {
                        ScepNotifyLogPolicy(rc, FALSE, L"Error read privileges from template", DbType, ObjectType, TemplateName);
                    }
                }
            }

            SceInfpCloseProfile(hProfile.hInf);

        } else {

            ScepNotifyLogPolicy(rc, FALSE, L"Error open inf", DbType, ObjectType, TemplateName);
        }

        if ( ERROR_SUCCESS == rc && pSceInfo ) {

            //
            // SMP and INF takes the same structure
            //
            pSceInfo->Type = SCE_ENGINE_SMP;

            BOOL bChanged = FALSE;

            ScepIsDomainLocal(NULL);

            //
            // check if there is difference between current state of LSA
            // and group policy templates.
            //
            rc = ScepNotifyGetChangedPolicies(
                            (SECURITY_DB_TYPE)DbType,
                            (SECURITY_DB_DELTA_TYPE)DeltaType,
                            (SECURITY_DB_OBJECT_TYPE)ObjectType,
                            (PSID)ObjectSid,
                            pSceInfo,
                            NULL,
                            FALSE,  // not save to DB
                            ExplicitLowRight,
                            ExplicitHighRight,
                            &bChanged
                            );

            if ( ERROR_SUCCESS == rc && bChanged ) {
                //
                // no error, get the policy for the area changed
                // now, write it back to the template
                //

                ScepNotifyLogPolicy(0, FALSE, L"Save", DbType, ObjectType, NULL );

                ScepCheckAndWaitPolicyPropFinish();

                PSCE_ERROR_LOG_INFO pErrList=NULL;

                rc = (*pfSceInfWriteInfo)(
                                TemplateName,
                                Area,
                                (PSCE_PROFILE_INFO)pSceInfo,
                                &pErrList
                                );

                ScepNotifyLogPolicy(rc, FALSE, L"Save operation", DbType, ObjectType, NULL );

                for (PSCE_ERROR_LOG_INFO pErr = pErrList; pErr != NULL; pErr = pErr->next) {

                   ScepNotifyLogPolicy(pErr->rc, FALSE, L"Save operation error", DbType, ObjectType, pErr->buffer );
                }

                ScepFreeErrorLog(pErrList);

                rc = ScepSceStatusToDosError(rc);

                //
                // only update version # of the GPO if it's not access denied or file not found
                // if verion # failed to update, still continue but in which case
                // the change will probably not get replicated and applied on
                // other DCs right away
                //

                if ( ERROR_ACCESS_DENIED != rc &&
                     ERROR_FILE_NOT_FOUND != rc ) {

                    BOOL bAccountGPO=FALSE;

                    if ( DbType == SecurityDbSam &&
                         ObjectType != SecurityDbObjectSamUser &&
                         ObjectType != SecurityDbObjectSamGroup &&
                         ObjectType != SecurityDbObjectSamAlias ) {
                        //
                        // if it's for deleted account, should update user right GPO
                        // otherwise, update the account GPO
                        //
                        bAccountGPO = TRUE;
                    }

                    DWORD rc2 = ScepNotifyUpdateGPOVersion( TemplateName,
                                                            bAccountGPO );

                    ScepNotifyLogPolicy(rc2, FALSE, L"GPO Version updated", DbType, ObjectType, NULL );
                }

            } else if ( ERROR_SUCCESS == rc ) {
                //
                // nothing changed
                //
                ScepNotifyLogPolicy(0, FALSE, L"No change", DbType, ObjectType, NULL );
            }

        }

        //
        // free any memory allocated
        //
        SceFreeMemory( (PVOID)pSceInfo, Area);
        ScepFree(pSceInfo);

    } else {

        ScepNotifyLogPolicy(rc, FALSE, L"Error get file path", DbType, ObjectType, NULL );
    }

    //
    // free TemplateName
    //
    LocalFree(TemplateName);

    return rc;
}


SCEPR_STATUS
SceRpcBrowseDatabaseTable(
    IN handle_t binding_h,
    IN wchar_t *DatabaseName OPTIONAL,
    IN SCEPR_TYPE ProfileType,
    IN AREAPR Area,
    IN BOOL bDomainPolicyOnly
    )
{

    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    SCESTATUS rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // initialize jet engine in system context
    //
    rc = SceJetInitialize(NULL);

    if ( SCESTATUS_SUCCESS != rc ) {
        return(rc);
    }

    //
    // impersonate the client, return DWORD error code
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        //
        // if no other active clients, terminate jet engine
        //
        ScepIfTerminateEngine();

        return( ScepDosErrorToSceStatus(rc) );

    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // get the database name
    //

    BOOL bAdminLogon=FALSE;
    LPTSTR DefProfile=NULL;
    PSCECONTEXT hProfile=NULL;

    __try {

        rc = ScepGetDefaultDatabase(
                 (LPCTSTR)DatabaseName,
                 0,
                 NULL,
                 &bAdminLogon,
                 &DefProfile
                 );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        rc = ERROR_EXCEPTION_IN_SERVICE;
    }

    rc = ScepDosErrorToSceStatus(rc);

    if ( SCESTATUS_SUCCESS == rc && DefProfile ) {

        //
        // OpenDatabase is not blocked by any task.
        //

        EnterCriticalSection(&ContextSync);

        DWORD Option=0;
        if ( ProfileType == SCE_ENGINE_SAP ) {
            if ( bDomainPolicyOnly )
                Option = SCE_OPEN_OPTION_TATTOO;
            else
                Option = SCE_OPEN_OPTION_REQUIRE_ANALYSIS;
        }

        rc = ScepOpenDatabase(
                    (PCWSTR)DefProfile,
                    Option,
                    SCEJET_OPEN_READ_ONLY,
                    &hProfile
                    );

        if ( SCESTATUS_SUCCESS == rc ) {
            //
            // a new context is opened, add it to the open context list
            //

            if ( (ProfileType != SCE_ENGINE_SAP) && bDomainPolicyOnly &&
                 ( (hProfile->Type & 0xF0L) != SCEJET_MERGE_TABLE_1 ) &&
                 ( (hProfile->Type & 0xF0L) != SCEJET_MERGE_TABLE_2 ) ) {
                //
                // there is no merged policy table
                //
                rc = SceJetCloseFile(
                        hProfile,
                        TRUE,
                        FALSE
                        );

                rc = SCESTATUS_PROFILE_NOT_FOUND;
                hProfile = NULL;

            } else {

                ScepAddToOpenContext(hProfile);
            }
        } else {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_OPEN, DefProfile);
        }

        LeaveCriticalSection(&ContextSync);

        if ( DefProfile != DatabaseName )
            ScepFree(DefProfile);
        DefProfile = NULL;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        if ( ProfileType == SCE_ENGINE_SCP ) {
            switch ( (hProfile->Type & 0xF0L) ) {
            case SCEJET_MERGE_TABLE_1:
                SceClientBrowseCallback(
                        0,
                        L"Merged Policy Table 1",
                        NULL,
                        NULL
                        );
                break;
            case SCEJET_MERGE_TABLE_2:
                SceClientBrowseCallback(
                        0,
                        L"Merged Policy Table 2",
                        NULL,
                        NULL
                        );
                break;
            default:

                SceClientBrowseCallback(
                        0,
                        L"There is no merged policy table. Local policy table is used.",
                        NULL,
                        NULL
                        );
                break;
            }

        }
        //
        // browse the information now
        //
        DWORD dwBrowseOptions;

        if ( (ProfileType != SCE_ENGINE_SAP) && bDomainPolicyOnly ) {
            dwBrowseOptions = SCEBROWSE_DOMAIN_POLICY;
        } else {
            dwBrowseOptions = 0;
        }

        if ( Area & AREA_SECURITY_POLICY ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szSystemAccess,
                        dwBrowseOptions
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szKerberosPolicy,
                            dwBrowseOptions
                            );
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szAuditEvent,
                            dwBrowseOptions
                            );
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szAuditSystemLog,
                            dwBrowseOptions
                            );
            }

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szAuditSecurityLog,
                            dwBrowseOptions
                            );
            }
            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szAuditApplicationLog,
                            dwBrowseOptions
                            );
            }
            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            szRegistryValues,
                            dwBrowseOptions | SCEBROWSE_MULTI_SZ
                            );
            }
        }

        if ( (Area & AREA_PRIVILEGES) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szPrivilegeRights,
                        dwBrowseOptions | SCEBROWSE_MULTI_SZ
                        );
        }
        if ( (Area & AREA_GROUP_MEMBERSHIP) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szGroupMembership,
                        dwBrowseOptions | SCEBROWSE_MULTI_SZ
                        );
        }
        if ( (Area & AREA_SYSTEM_SERVICE) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szServiceGeneral,
                        dwBrowseOptions
                        );
        }

        if ( (Area & AREA_REGISTRY_SECURITY) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szRegistryKeys,
                        dwBrowseOptions
                        );
        }
        if ( (Area & AREA_FILE_SECURITY) &&
             (SCESTATUS_SUCCESS == rc) ) {

            rc = ScepBrowseTableSection(
                        hProfile,
                        (SCETYPE)ProfileType,
                        szFileSecurity,
                        dwBrowseOptions
                        );
        }

        if ( (Area & AREA_ATTACHMENTS) &&
             (SCESTATUS_SUCCESS == rc) ) {

            PSCE_NAME_LIST    pList=NULL;

            rc = ScepEnumAttachmentSections( hProfile, &pList);

            if ( rc == SCESTATUS_SUCCESS ) {

                for ( PSCE_NAME_LIST pNode=pList; pNode != NULL; pNode=pNode->Next) {

                    rc = ScepBrowseTableSection(
                            hProfile,
                            (SCETYPE)ProfileType,
                            pNode->Name,
                            dwBrowseOptions
                            );
                    if ( SCESTATUS_SUCCESS != rc ) {
                        break;
                    }
                }
            }

            ScepFreeNameList(pList);
        }

        ScepValidateAndCloseDatabase(hProfile);
        hProfile = NULL;

    } else {

        //
        // start a timer queue to check to see if there is active tasks/contexts
        // if not, terminate jet engine
        //
        ScepIfTerminateEngine();

    }

    ScepLogClose();

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);
}

BOOL
ScepIsSystemShutDown()
{

    return(gbSystemShutdown);

}

/*
see delay load exception handler in sources
SCESTATUS
ScepCheckDelayLoadedDlls(
    IN BOOL bCheckLdap
    )
{
    HINSTANCE hDll;

    hDll = LoadLibrary(TEXT("samlib.dll"));
    if ( hDll == NULL ) {
        return(SCESTATUS_MOD_NOT_FOUND);
    }

    if ( GetProcAddress(hDll, "SamAddMemberToAlias") == NULL ||
         GetProcAddress(hDll, "SamAddMemberToGroup") == NULL ||
         GetProcAddress(hDll, "SamCloseHandle") == NULL ||
         GetProcAddress(hDll, "SamConnect") == NULL ||
         GetProcAddress(hDll, "SamEnumerateAliasesInDomain") == NULL ||
         GetProcAddress(hDll, "SamFreeMemory") == NULL ||
         GetProcAddress(hDll, "SamGetAliasMembership") == NULL ||
         GetProcAddress(hDll, "SamGetGroupsForUser") == NULL ||
         GetProcAddress(hDll, "SamGetMembersInAlias") == NULL ||
         GetProcAddress(hDll, "SamGetMembersInGroup") == NULL ||
         GetProcAddress(hDll, "SamLookupDomainInSamServer") == NULL ||
         GetProcAddress(hDll, "SamLookupIdsInDomain") == NULL ||
         GetProcAddress(hDll, "SamLookupNamesInDomain") == NULL ||
         GetProcAddress(hDll, "SamOpenAlias") == NULL ||
         GetProcAddress(hDll, "SamOpenDomain") == NULL ||
         GetProcAddress(hDll, "SamOpenGroup") == NULL ||
         GetProcAddress(hDll, "SamOpenUser") == NULL ||
         GetProcAddress(hDll, "SamQueryInformationAlias") == NULL ||
         GetProcAddress(hDll, "SamQueryInformationDomain") == NULL ||
         GetProcAddress(hDll, "SamQueryInformationGroup") == NULL ||
         GetProcAddress(hDll, "SamQueryInformationUser") == NULL ||
         GetProcAddress(hDll, "SamRemoveMemberFromAlias") == NULL ||
         GetProcAddress(hDll, "SamRemoveMemberFromGroup") == NULL ||
         GetProcAddress(hDll, "SamSetInformationDomain") == NULL ||
         GetProcAddress(hDll, "SamSetInformationUser") == NULL ) {

        FreeLibrary(hDll);
        return(SCESTATUS_MOD_NOT_FOUND);
    }

    FreeLibrary(hDll);
    hDll = NULL;


    hDll = LoadLibrary(TEXT("setupapi.dll"));
    if ( hDll == NULL ) {
        return(SCESTATUS_MOD_NOT_FOUND);
    }

    if ( GetProcAddress(hDll, "SetupFindNextLine") == NULL ||
         GetProcAddress(hDll, "SetupGetFieldCount") == NULL ||
         GetProcAddress(hDll, "SetupGetStringFieldW") == NULL ||
         GetProcAddress(hDll, "SetupFindFirstLineW") == NULL ||
         GetProcAddress(hDll, "SetupGetLineCountW") == NULL ||
         GetProcAddress(hDll, "SetupOpenInfFileW") == NULL ||
         GetProcAddress(hDll, "SetupCloseInfFile") == NULL ||
         GetProcAddress(hDll, "SetupGetMultiSzFieldW") == NULL ||
         GetProcAddress(hDll, "SetupGetIntField") == NULL ) {

        FreeLibrary(hDll);
        return(SCESTATUS_MOD_NOT_FOUND);
    }

    FreeLibrary(hDll);
    hDll = NULL;

    if ( bCheckLdap ) {

        NT_PRODUCT_TYPE productType=NtProductWinNt;

        if ( (RtlGetNtProductType (&productType) == FALSE) ||
             (productType == NtProductLanManNt) ) {
            //
            // if error to get product type, check the dll anyway
            //
            hDll = LoadLibrary(TEXT("wldap32.dll"));
            if ( hDll == NULL ) {
                return(SCESTATUS_MOD_NOT_FOUND);
            }

            if ( GetProcAddress(hDll, "ldap_msgfree") == NULL ||
                 GetProcAddress(hDll, "LdapMapErrorToWin32") == NULL ||
                 GetProcAddress(hDll, "ldap_value_freeW") == NULL ||
                 GetProcAddress(hDll, "ldap_value_free_len") == NULL ||
                 GetProcAddress(hDll, "ldap_get_valuesW") == NULL ||
                 GetProcAddress(hDll, "ldap_get_values_lenW") == NULL ||
                 GetProcAddress(hDll, "ldap_first_entry") == NULL ||
                 GetProcAddress(hDll, "ldap_next_entry") == NULL ||
                 GetProcAddress(hDll, "ldap_search_sW") == NULL ||
                 GetProcAddress(hDll, "ldap_search_ext_sW") == NULL ||
                 GetProcAddress(hDll, "ldap_bind_sW") == NULL ||
                 GetProcAddress(hDll, "ldap_openW") == NULL ||
                 GetProcAddress(hDll, "ldap_unbind") == NULL ||
                 GetProcAddress(hDll, "ldap_count_entries") == NULL ||
                 GetProcAddress(hDll, "ldap_count_valuesW") == NULL ||
                 GetProcAddress(hDll, "ldap_modify_sW") == NULL ||
                 GetProcAddress(hDll, "ldap_modify_ext_sW") == NULL ) {

                FreeLibrary(hDll);
                return(SCESTATUS_MOD_NOT_FOUND);
            }

            FreeLibrary(hDll);
            hDll = NULL;

        }
    }


    hDll = LoadLibrary(TEXT("ntmarta.dll"));
    if ( hDll == NULL ) {
        return(SCESTATUS_MOD_NOT_FOUND);
    }

    if ( GetProcAddress(hDll, "AccRewriteSetNamedRights") == NULL ) {

        FreeLibrary(hDll);
        return(SCESTATUS_MOD_NOT_FOUND);
    }

    FreeLibrary(hDll);

    hDll = LoadLibrary(TEXT("authz.dll"));
    if ( hDll == NULL ) {
        return(SCESTATUS_MOD_NOT_FOUND);
    }

    if ( GetProcAddress(hDll, "AuthzInitializeResourceManager") == NULL ||
         GetProcAddress(hDll, "AuthzInitializeContextFromSid") == NULL ||
         GetProcAddress(hDll, "AuthzAccessCheck") == NULL ||
         GetProcAddress(hDll, "AuthzFreeContext") == NULL ||
         GetProcAddress(hDll, "AuthzFreeResourceManager") == NULL )
        {

        FreeLibrary(hDll);
        return(SCESTATUS_MOD_NOT_FOUND);

    }

    FreeLibrary(hDll);
    hDll = NULL;

    return(SCESTATUS_SUCCESS);
}
*/


SCESTATUS
ScepConvertServices(
    IN OUT PVOID *ppServices,
    IN BOOL bSRForm
    )
{
    if ( !ppServices ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCE_SERVICES pTemp = (PSCE_SERVICES)(*ppServices);
    SCESTATUS rc=SCESTATUS_SUCCESS;

    PSCE_SERVICES pNewNode;
    PSCE_SERVICES pNewServices=NULL;

    while ( pTemp ) {

        pNewNode = (PSCE_SERVICES)ScepAlloc(0,sizeof(SCE_SERVICES));

        if ( pNewNode ) {

            pNewNode->ServiceName = pTemp->ServiceName;
            pNewNode->DisplayName = pTemp->DisplayName;
            pNewNode->Status = pTemp->Status;
            pNewNode->Startup = pTemp->Startup;
            pNewNode->SeInfo = pTemp->SeInfo;

            pNewNode->General.pSecurityDescriptor = NULL;

            pNewNode->Next = pNewServices;
            pNewServices = pNewNode;

            if ( bSRForm ) {
                //
                // Service node is in SCEPR_SERVICES structure
                // convert it to SCE_SERVICES structure
                // in this case, just use the self relative security descriptor
                //
                if ( pTemp->General.pSecurityDescriptor) {
                    pNewNode->General.pSecurityDescriptor = ((PSCEPR_SERVICES)pTemp)->pSecurityDescriptor->SecurityDescriptor;
                }

            } else {

                //
                // Service node is in SCE_SERVICES strucutre
                // convert it to SCEPR_SERVICES structure
                //
                // make the SD to self relative format and PSCEPR_SR_SECURITY_DESCRIPTOR
                //

                if ( pTemp->General.pSecurityDescriptor ) {

                    if ( !RtlValidSid ( pTemp->General.pSecurityDescriptor ) ) {
                        rc = SCESTATUS_INVALID_PARAMETER;
                        break;
                    }

                    //
                    // get the length
                    //
                    DWORD nLen = 0;
                    DWORD NewLen;
                    PSECURITY_DESCRIPTOR pSD;
                    PSCEPR_SR_SECURITY_DESCRIPTOR pNewWrap;

                    RtlMakeSelfRelativeSD( pTemp->General.pSecurityDescriptor,
                                           NULL,
                                           &nLen
                                         );

                    if ( nLen > 0 ) {

                        pSD = (PSECURITY_DESCRIPTOR)ScepAlloc(LMEM_ZEROINIT, nLen);

                        if ( !pSD ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            break;
                        }

                        NewLen = nLen;

                        rc = ScepDosErrorToSceStatus(
                               RtlNtStatusToDosError(
                                 RtlMakeSelfRelativeSD( pTemp->General.pSecurityDescriptor,
                                                        pSD,
                                                        &NewLen
                                                      ) ) );

                        if ( SCESTATUS_SUCCESS == rc ) {

                            //
                            // create a wrapper node to contain the security descriptor
                            //

                            pNewWrap = (PSCEPR_SR_SECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SCEPR_SR_SECURITY_DESCRIPTOR));
                            if ( pNewWrap ) {

                                //
                                // assign the wrap to the structure
                                //
                                pNewWrap->SecurityDescriptor = (UCHAR *)pSD;
                                pNewWrap->Length = nLen;

                            } else {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            }
                        }

                        if ( SCESTATUS_SUCCESS != rc ) {
                            ScepFree(pSD);
                            break;
                        }

                        //
                        // now link the SR_SD to the list
                        //
                        ((PSCEPR_SERVICES)pNewNode)->pSecurityDescriptor = pNewWrap;

                    } else {
                        //
                        // something is wrong with the SD
                        //
                        rc = SCESTATUS_INVALID_PARAMETER;
                        break;
                    }
                }
            }

        } else {
            //
            // all allocated buffer are in the list of pNewServices
            //
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            break;
        }

        pTemp = pTemp->Next;
    }

    if ( SCESTATUS_SUCCESS != rc ) {

        //
        // free pNewServices
        //
        ScepFreeConvertedServices( (PVOID)pNewServices, !bSRForm );
        pNewServices = NULL;
    }

    *ppServices = (PVOID)pNewServices;

    return(rc);
}


SCESTATUS
ScepFreeConvertedServices(
    IN PVOID pServices,
    IN BOOL bSRForm
    )
{

    if ( pServices == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    PSCEPR_SERVICES pNewNode = (PSCEPR_SERVICES)pServices;

    PSCEPR_SERVICES pTempNode;

    while ( pNewNode ) {

        if ( bSRForm && pNewNode->pSecurityDescriptor ) {

            //
            // free this allocated buffer (PSCEPR_SR_SECURITY_DESCRIPTOR)
            //
            if ( pNewNode->pSecurityDescriptor->SecurityDescriptor ) {
                ScepFree( pNewNode->pSecurityDescriptor->SecurityDescriptor);
            }
            ScepFree(pNewNode->pSecurityDescriptor);
        }

        //
        // also free the PSCEPR_SERVICE node (but not the names referenced by this node)
        //
        pTempNode = pNewNode;
        pNewNode = pNewNode->Next;

        ScepFree(pTempNode);
    }

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SceRpcGetSystemSecurity(
    IN handle_t binding_h,
    IN AREAPR                 Area,
    IN DWORD                  Options,
    OUT PSCEPR_PROFILE_INFO __RPC_FAR *ppInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Query system security settings)

    Only password, account lockout, kerberos, audit, user rights, and
    SCE registry values are queried.

    multile threads doing get/set system security are not blocked. In
    other words, system security settings are not exclusive.
*/

{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    __try {
        //
        // catch exception if InfFileName, or pebClient/pdWarning are bogus
        //
        rc = ScepGetSystemSecurity(
                (AREA_INFORMATION)Area,
                Options,
                (PSCE_PROFILE_INFO *)ppInfoBuffer,
                (PSCE_ERROR_LOG_INFO *)Errlog
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = SCESTATUS_EXCEPTION_IN_SERVER;
    }

    RpcRevertToSelf();

    return(rc);
}

SCESTATUS
SceRpcGetSystemSecurityFromHandle(
    IN SCEPR_CONTEXT          Context,  // must be a context point to system db
    IN AREAPR                 Area,
    IN DWORD                  Options,
    OUT PSCEPR_PROFILE_INFO __RPC_FAR *ppInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Query local security policy from the system (directly)

    Only password, account lockout, kerberos, audit, user rights, and
    SCE registry values are queried.

    multile threads doing get/set system security are not blocked. In
    other words, system security settings are not exclusive.
*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // should we validate the profile handle?
    // it's not used here so it's not validated now.
    //

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    __try {
        //
        // catch exception if InfFileName, or pebClient/pdWarning are bogus
        //
        rc = ScepGetSystemSecurity(
                (AREA_INFORMATION)Area,
                Options,
                (PSCE_PROFILE_INFO *)ppInfoBuffer,
                (PSCE_ERROR_LOG_INFO *)Errlog
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = SCESTATUS_EXCEPTION_IN_SERVER;
    }

    RpcRevertToSelf();

    return(rc);
}

SCEPR_STATUS
SceRpcSetSystemSecurityFromHandle(
    IN SCEPR_CONTEXT          Context,  // must be a context point to system db
    IN AREAPR                 Area,
    IN DWORD                  Options,
    IN PSCEPR_PROFILE_INFO __RPC_FAR pInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Set local security policy to the system (directly)

    Only password, account lockout, kerberos, audit, user rights, and
    SCE registry values are set.

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // should we validate the profile handle?
    // it's not used here so it's not validated now.
    //

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    __try {
        //
        // catch exception if InfFileName, or pebClient/pdWarning are bogus
        //
        rc = ScepSetSystemSecurity(
                (AREA_INFORMATION)Area,
                Options,
                (PSCE_PROFILE_INFO)pInfoBuffer,
                (PSCE_ERROR_LOG_INFO *)Errlog
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = SCESTATUS_EXCEPTION_IN_SERVER;
    }

    RpcRevertToSelf();

    return(rc);
}


SCEPR_STATUS
SceRpcSetSystemSecurity(
    IN handle_t binding_h,
    IN AREAPR                 Area,
    IN DWORD                  Options,
    IN PSCEPR_PROFILE_INFO __RPC_FAR pInfoBuffer,
    OUT PSCEPR_ERROR_LOG_INFO __RPC_FAR *Errlog OPTIONAL
    )
/*
Routine Description:

    Set local security policy to the system (directly)

    Only password, account lockout, kerberos, audit, user rights, and
    SCE registry values are set.

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    DWORD rc;

    if ( bStopRequest ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    __try {
        //
        // catch exception if InfFileName, or pebClient/pdWarning are bogus
        //
        rc = ScepSetSystemSecurity(
                (AREA_INFORMATION)Area,
                Options,
                (PSCE_PROFILE_INFO)pInfoBuffer,
                (PSCE_ERROR_LOG_INFO *)Errlog
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

       rc = SCESTATUS_EXCEPTION_IN_SERVER;
    }

    RpcRevertToSelf();

    return(rc);
}


SCEPR_STATUS
SceRpcSetDatabaseSetting(
    IN SCEPR_CONTEXT  Context,
    IN SCEPR_TYPE     ProfileType,
    IN wchar_t *SectionName,
    IN wchar_t *KeyName,
    IN PSCEPR_VALUEINFO pValueInfo OPTIONAL
    )
/*
Set or delete value from the given key

if pValueInfo is NULL, delete the key

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( SCEPR_SMP != ProfileType ) {
        return SCESTATUS_INVALID_PARAMETER;
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;
    PSCESECTION hSection=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {
            //
            // catch exception if Context, ppInfoBuffer, Errlog are bogus pointers
            //
#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // query the information now
                //

                rc = ScepOpenSectionForName(
                            (PSCECONTEXT)Context,
                            (SCETYPE)ProfileType,
                            SectionName,
                            &hSection
                            );

                if ( SCESTATUS_SUCCESS == rc ) {

                    if ( pValueInfo == NULL || pValueInfo->Value == NULL ) {
                        // delete the key
                        rc = SceJetDelete(
                            hSection,
                            KeyName,
                            FALSE,
                            SCEJET_DELETE_LINE_NO_CASE
                            );

                    } else {
                        // set the value
                        rc = SceJetSetLine(
                                   hSection,
                                   KeyName,
                                   FALSE,
                                   (PWSTR)pValueInfo->Value,
                                   pValueInfo->ValueLen,
                                   0
                                   );
                    }

                    SceJetCloseSection(&hSection, TRUE);
                }

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // free ppInfoBuffer if it's allocated
            //

            if ( hSection )
                SceJetCloseSection(&hSection, TRUE);

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}

SCEPR_STATUS
SceRpcGetDatabaseSetting(
    IN SCEPR_CONTEXT  Context,
    IN SCEPR_TYPE     ProfileType,
    IN wchar_t *SectionName,
    IN wchar_t *KeyName,
    OUT PSCEPR_VALUEINFO *pValueInfo
    )
/*
Routine Description:

    Get information for the particular key from the context database.

Arguments:

Return Value:

*/
{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return SCESTATUS_ACCESS_DENIED;

    }
    
    if ( !pValueInfo ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( SCEPR_SMP != ProfileType ) {
        return SCESTATUS_INVALID_PARAMETER;
    }

    SCESTATUS rc;

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {
        return( ScepDosErrorToSceStatus(rc) );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }

    //
    // validate the context handle is a SCE context
    // Only one database operation per context
    //

    PSCESRV_DBTASK pTask=NULL;
    PSCESECTION hSection=NULL;
    PWSTR Value=NULL;

    rc = ScepValidateAndLockContext((PSCECONTEXT)Context,
                                    SCE_TASK_LOCK,
                                    FALSE,
                                    &pTask);

    if (SCESTATUS_SUCCESS == rc ) {

        //
        // lock the context
        //

        if ( pTask ) {
            EnterCriticalSection(&(pTask->Sync));
        }

        __try {
            //
            // catch exception if Context, ppInfoBuffer, Errlog are bogus pointers
            //
#ifdef SCE_JET_TRAN
            rc = SceJetJetErrorToSceStatus(
                    JetSetSessionContext(
                        ((PSCECONTEXT)Context)->JetSessionID,
                        (ULONG_PTR)Context
                        ));

            if ( SCESTATUS_SUCCESS == rc ) {
#endif
                //
                // query the information now
                //

                rc = ScepOpenSectionForName(
                            (PSCECONTEXT)Context,
                            (SCETYPE)ProfileType,
                            SectionName,
                            &hSection
                            );

                if ( SCESTATUS_SUCCESS == rc ) {

                    DWORD ValueLen=0;
                    DWORD NewLen=0;

                    rc = SceJetGetValue(
                            hSection,
                            SCEJET_EXACT_MATCH_NO_CASE,
                            KeyName,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            0,
                            &ValueLen
                            );

                    // allocate output buffer
                    if ( SCESTATUS_SUCCESS == rc ) {
                        Value = (PWSTR)ScepAlloc(LPTR, ValueLen+2);

                        if ( !Value )
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        else {
                            *pValueInfo = (PSCEPR_VALUEINFO)ScepAlloc(0,sizeof(SCEPR_VALUEINFO));

                            if ( *pValueInfo == NULL ) {
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                            }
                        }
                    }

                    // query the value
                    if ( SCESTATUS_SUCCESS == rc ) {

                        rc = SceJetGetValue(
                                hSection,
                                SCEJET_CURRENT,
                                KeyName,
                                NULL,
                                0,
                                NULL,
                                Value,
                                ValueLen,
                                &NewLen
                                );
                        if ( SCESTATUS_SUCCESS == rc ) {
                            (*pValueInfo)->ValueLen = ValueLen+2;
                            (*pValueInfo)->Value = (byte *)Value;
                        }
                    }

                    // free buffer
                    if ( SCESTATUS_SUCCESS != rc ) {

                        if ( Value ) ScepFree(Value);
                        if ( *pValueInfo ) {
                            ScepFree(*pValueInfo);
                            *pValueInfo = NULL;
                        }
                    }

                    SceJetCloseSection(&hSection, TRUE);
                }

#ifdef SCE_JET_TRAN
                JetResetSessionContext(((PSCECONTEXT)Context)->JetSessionID);

            }
#endif

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // free ppInfoBuffer if it's allocated
            //

            if ( Value ) ScepFree(Value);
            if ( *pValueInfo ) {
                ScepFree(*pValueInfo);
                *pValueInfo = NULL;
            }

            if ( hSection )
                SceJetCloseSection(&hSection, TRUE);

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        //
        // unlock the context
        //

        if ( pTask ) {
            LeaveCriticalSection(&(pTask->Sync));
        }

        //
        // remove the context from task table
        //

        ScepRemoveTask(pTask);

    }

    RpcRevertToSelf();

    return((SCEPR_STATUS)rc);

}

DWORD
SceRpcConfigureConvertedFileSecurityImmediately(
    IN handle_t binding_h,
    IN wchar_t *pszDriveName
    )
/*
Routine Description:

    RPC interface called by SCE client (only when conversion of security is immediate)

Arguments:

    binding_h       -   binding handle
    pszDriveName   -   name of the volume for which setup-style security is to be applied

Return:

    win32 error code

*/

{
    UINT ClientLocalFlag = 0;

    if ( RPC_S_OK != I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag) ||
         0 == ClientLocalFlag ){

        //
        // to prevent denial-of-service type attacks,
        // do not allow remote RPC 
        //
        
        return ERROR_ACCESS_DENIED;

    }
    
    DWORD rc = ERROR_SUCCESS;
    NTSTATUS    Status = NO_ERROR;

    if ( pszDriveName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // impersonate the client
    //

    rc =  RpcImpersonateClient( NULL );

    if (rc != RPC_S_OK) {

        return( rc );
    }

    BOOL    bAdminSidInToken = FALSE;
    
    rc = ScepDosErrorToSceStatus(ScepIsAdminLoggedOn(&bAdminSidInToken));

    if (SCESTATUS_SUCCESS != rc || FALSE == bAdminSidInToken) {
        RpcRevertToSelf();
        return SCESTATUS_SPECIAL_ACCOUNT;
    }
    
    rc = ScepConfigureConvertedFileSecurityImmediate( pszDriveName );

    RpcRevertToSelf();

    return(rc);
}


DWORD
ScepServerConfigureSystem(
    IN  PWSTR   InfFileName,
    IN  PWSTR   DatabaseName,
    IN  PWSTR   LogFileName,
    IN  DWORD   ConfigOptions,
    IN  AREA_INFORMATION  Area
    )
/*
Routine Description:

    Configure the system using the Inf template. This routine is similar to the RPC interface
    SceRpcConfigureSystem except that the configuration is initiated by the server itself.

    Since this routine is called by the server only (system context) and not by sce client,
    there is no need to do impersonate etc.
    Log file initialization etc. is done outside of this routine

Arguments:

    InfFileName     -   name of inf file to import configuration information from
    DatabaseName    -   name of database to import into
    LogFileName     -   name of log file to log errors
    ConfigOptions   -   configuration options ()
    Area            -   security area to configure

Return Value:

    win32 error code
*/
{
    DWORD rc = ERROR_SUCCESS;

    if (InfFileName == NULL || DatabaseName == NULL || LogFileName == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // initialize jet engine in system context if not already initialized
    //
    rc = SceJetInitialize(NULL);

    if ( rc != SCESTATUS_SUCCESS ) {
        return(ScepSceStatusToDosError(rc));
    }

    //
    // no one else can use convert.sdb - lock access to it
    //

    rc = ScepLockEngine(DatabaseName);

    if ( SCESTATUS_ALREADY_RUNNING == rc ) {
        //
        // will wait for max one minute
        //
        DWORD dwWaitCount = 0;

        while ( TRUE ) {

            Sleep(5000);  // 5 seconds

            rc = ScepLockEngine(DatabaseName);

            dwWaitCount++;

            if ( SCESTATUS_SUCCESS == rc ||
                 dwWaitCount >= 12 ) {
                break;
            }
        }
    }


    if ( SCESTATUS_SUCCESS == rc ) {


        __try {
            //
            // catch exception if InfFileName, or pebClient/pdWarning are bogus
            //
            rc = ScepConfigureSystem(
                                    (LPCTSTR)InfFileName,
                                    DatabaseName,
                                    ConfigOptions,
                                    TRUE,
                                    (AREA_INFORMATION)Area,
                                    NULL
                                    );

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            rc = SCESTATUS_EXCEPTION_IN_SERVER;
        }

        ScepUnlockEngine(DatabaseName);

    }
    //
    // start a timer queue to check to see if there is active tasks/contexts
    // if not, terminate jet engine
    //
    ScepIfTerminateEngine();

    return(ScepSceStatusToDosError(rc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\serverp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    serverp.h

Abstract:

    This module defines the data structures and function prototypes
    for the security managment utility

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

    jinhuang 26-Jan-1998   splitted for client-server

--*/

#ifndef _serverp_
#define _serverp_

#include "headers.h"

#include <ntsam.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <ntdddisk.h>
#define OEMRESOURCE     // setting this gets OBM_ constants in windows.h
#include <winspool.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include <cfgmgr32.h>
//#include <objbase.h>
#include <userenv.h>
#include <regstr.h>
#include <setupbat.h>
#include <aclapi.h>
#include <winldap.h>

#include "scejetp.h"
//
// the following header is defined as a c header so both c and cpp can
// link to the client lib
//
#include "scesvc.h"
#include "scerpc.h"

#include "scep.h"
#include "srvutil.h"
#include "srvrpcp.h"
#include "scesrvrc.h"
#include "sceutil.h"
#include "service.h"

#ifdef __cplusplus
extern "C" {
#endif

#if _WIN32_WINNT>=0x0500

#include <dsgetdc.h>
#include <ntdsapi.h>

typedef DWORD (WINAPI *PFNDSGETDCNAME)(LPCTSTR, LPCTSTR, GUID *, LPCTSTR, ULONG, PDOMAIN_CONTROLLER_INFO *);
typedef DWORD (WINAPI *PFNNETAPIFREE)(LPVOID);


#endif

#define Thread  __declspec( thread )


extern DWORD Thread     gCurrentTicks;
extern DWORD Thread     gTotalTicks;
extern BYTE  Thread     cbClientFlag;
extern DWORD Thread     gWarningCode;
extern BOOL  Thread     gbInvalidData;
extern BOOL  Thread     bLogOn;
extern INT   Thread     gDebugLevel;

extern DWORD Thread     gMaxRegTicks;
extern DWORD Thread     gMaxFileTicks;
extern DWORD Thread     gMaxDsTicks;

extern NT_PRODUCT_TYPE  Thread ProductType;
extern PSID             Thread AdminsSid;
extern DWORD  Thread gdwPolicyLog;


#define SCE_RPC_SERVER_ACTIVE       L"SCE_RPC_SERVER_ACTIVE"
#define SCE_RPC_SERVER_STOPPED      L"SCE_RPC_SERVER_STOPPED"

//
// prototypes in server.cpp
//

VOID
ScepInitServerData();

VOID
ScepUninitServerData();

NTSTATUS
ScepStartServerServices();

NTSTATUS
ScepStopServerServices(
    IN BOOL bShutDown
    );

SCESTATUS
ScepPostProgress(
   IN DWORD Delta,
   IN AREA_INFORMATION Area,
   IN LPTSTR szName OPTIONAL
   );

SCESTATUS
ScepRsopLog(
   IN AREA_INFORMATION Area,
   IN DWORD dwConfigStatus,
   IN wchar_t *pStatusInfo OPTIONAL,
   IN DWORD dwPrivLow OPTIONAL,
   IN DWORD dwPrivHigh OPTIONAL
   );

BOOL
ScepIsSystemShutDown();

SCESTATUS
ScepServerCancelTimer();

//
// prototypes in errlog.c
//

SCESTATUS
ScepSetVerboseLog(
    IN INT dbgLevel
    );

SCESTATUS
ScepEnableDisableLog(
   IN BOOL bOnOff
   );

//
// prototypes defined in tree.c
//

SCESTATUS
ScepBuildObjectTree(
    IN OUT PSCE_OBJECT_TREE *ParentNode,
    IN OUT PSCE_OBJECT_CHILD_LIST *ChildHead,
    IN ULONG Level,
    IN WCHAR Delim,
    IN PCWSTR ObjectFullName,
    IN BOOL IsContainer,
    IN BYTE Status,
    IN PSECURITY_DESCRIPTOR pInfSecurityDescriptor,
    IN SECURITY_INFORMATION InfSeInfo
    );

SCESTATUS
ScepCalculateSecurityToApply(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

SCESTATUS
ScepConfigureObjectTree(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepFreeObject2Security(
    IN PSCE_OBJECT_CHILD_LIST  NodeList,
    IN BOOL bFreeComputedSDOnly
    );

DWORD
ScepSetSecurityWin32(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType
    );

DWORD
ScepSetSecurityObjectOnly(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType,
    OUT PBOOL pbHasChild
    );

DWORD
ScepGetNewSecurity(
    IN LPTSTR ObjectName,
    IN PSECURITY_DESCRIPTOR pParentSD OPTIONAL,
    IN PSECURITY_DESCRIPTOR pObjectSD OPTIONAL,
    IN BYTE nFlag,
    IN BOOLEAN bIsContainer,
    IN SECURITY_INFORMATION SeInfo,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *ppNewSD
    );

SCESTATUS
ScepSetupResetLocalPolicy(
    IN PSCECONTEXT          Context,
    IN AREA_INFORMATION     Area,
    IN PCWSTR               SectionName OPTIONAL,
    IN SCETYPE              ProfileType,
    IN BOOL                 bKeepBasicPolicy
    );

DWORD
ScepAddSidStringToNameList(
    IN OUT PSCE_NAME_LIST *ppNameList,
    IN PSID pSid
    );

DWORD
ScepNotifyProcessOneNodeDC(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID ObjectSid,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight
    );

VOID
ScepConfigureConvertedFileSecurityThreadFunc(
    IN PVOID pV
    );

VOID
ScepWaitForServicesEventAndConvertSecurityThreadFunc(
    IN PVOID pV
    );

DWORD
ScepServerConfigureSystem(
    IN  PWSTR   InfFileName,
    IN  PWSTR   DatabaseName,
    IN  PWSTR   LogFileName,
    IN  DWORD   ConfigOptions,
    IN  AREA_INFORMATION  Area
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\setupsrv.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setupsrv.cpp

Abstract:

    Routines for secedit integration with system setup and component setup

Author:

    Jin Huang (jinhuang) 15-Aug-1997

Revision History:

    jinhuang 26-Jan-1998  splitted to client-server

--*/

#include "headers.h"
#include "serverp.h"
#include "srvrpcp.h"
#include "pfp.h"
#include <io.h>


SCESTATUS
ScepUpdateObjectInSection(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR ObjectName,
    IN SE_OBJECT_TYPE ObjectType,
    IN UINT nFlag,
    IN PWSTR SDText,
    OUT UINT *pStatus
    );

//
// implementations
//


DWORD
ScepSetupUpdateObject(
    IN PSCECONTEXT Context,
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN UINT nFlag,
    IN PWSTR SDText
    )
/*
Routine Description:

    This routine is the private API called from the RPC interface to
    update object information in the database.

Arguments:

    Context     - the database context handle

    ObjectFullName  - the object's name

    Objecttype      - the object type

    nFlag       - the flag on how to update this object

    SDText      - the security descriptor in SDDL text


Return Value:

*/
{

    if ( !ObjectFullName || NULL == SDText ) {
        return ERROR_INVALID_PARAMETER;
    }

    switch ( ObjectType ) {
    case SE_SERVICE:
    case SE_REGISTRY_KEY:
    case SE_FILE_OBJECT:
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    SCESTATUS rc;

    DWORD dwInSetup=0;

    ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                TEXT("System\\Setup"),
                TEXT("SystemSetupInProgress"),
                &dwInSetup
                );

    //
    // convert SDText to security descriptor
    //
    PSECURITY_DESCRIPTOR pSD=NULL;
    DWORD SDSize;
    SECURITY_INFORMATION SeInfo=0;
    HANDLE  Token=NULL;

    DWORD Win32rc=ERROR_SUCCESS;

    if ( !(nFlag & SCESETUP_UPDATE_DB_ONLY) ) {
        //
        // security will be set, so compute the security descriptor
        //
        Win32rc = ConvertTextSecurityDescriptor (
                        SDText,
                        &pSD,
                        &SDSize,
                        &SeInfo
                        );

        if ( NO_ERROR == Win32rc ) {

            ScepChangeAclRevision(pSD, ACL_REVISION);

            //
            // get current thread/process's token
            //
            if (!OpenThreadToken( GetCurrentThread(),
                                   TOKEN_QUERY,
                                   FALSE,
                                   &Token)) {

                if (!OpenProcessToken( GetCurrentProcess(),
                                      TOKEN_QUERY,
                                      &Token)) {

                    Win32rc = GetLastError();
                }
            }

            if ( Token && (SeInfo & SACL_SECURITY_INFORMATION) ) {

                SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, Token );
            }
        }
    }

    if ( NO_ERROR == Win32rc ) {

        //
        // only update DB if it's in setup
        //

        //
        // on 64-bit platform, only update database if setup does not indicate SCE_SETUP_32KEY flag
        //

#ifdef _WIN64
        if ( dwInSetup && !(nFlag & SCE_SETUP_32KEY) ) {
#else
        if ( dwInSetup ) {
#endif

            // save this into SCP and SMP, do not overwrite the status/container flag
            // if there is one exist, else use SCE_STATUS_CHECK and check for container
            //
            //
            // start a transaction since there are multiple operations
            //

            rc = SceJetStartTransaction( Context );

            if ( rc == SCESTATUS_SUCCESS ) {

                UINT Status=SCE_STATUS_CHECK;

                rc = ScepUpdateObjectInSection(
                            Context,
                            SCE_ENGINE_SMP,
                            ObjectFullName,
                            ObjectType,
                            nFlag,
                            SDText,
                            &Status
                            );

                if ( rc == SCESTATUS_SUCCESS &&
                     (Context->JetSapID != JET_tableidNil) ) {
                    //
                    // the SAP table ID points to the tattoo table
                    // should update the tattoo table too if it exist
                    //
                    rc = ScepUpdateObjectInSection(
                                Context,
                                SCE_ENGINE_SAP,
                                ObjectFullName,
                                ObjectType,
                                nFlag,
                                SDText,
                                NULL
                                );

                }
            }

        } else {
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc == SCESTATUS_SUCCESS &&
             !(nFlag & SCESETUP_UPDATE_DB_ONLY) ) {

            //
            // set security to the object
            //

            //
            // if 64-bit platform, no synchronization is done and setup will have
            // to call the exported API with SCE_SETUP_32KEY if 32-bit hive is desired
            //

#ifdef _WIN64
            if ( ObjectType == SE_REGISTRY_KEY && (nFlag & SCE_SETUP_32KEY) ){
                ObjectType = SE_REGISTRY_WOW64_32KEY;
            }
#endif

            Win32rc = ScepSetSecurityWin32(
                ObjectFullName,
                SeInfo,
                pSD,
                ObjectType
                );

        } else
            Win32rc = ScepSceStatusToDosError(rc);

        if ( Win32rc == ERROR_SUCCESS ||
             Win32rc == ERROR_FILE_NOT_FOUND ||
             Win32rc == ERROR_PATH_NOT_FOUND ||
             Win32rc == ERROR_INVALID_OWNER ||
             Win32rc == ERROR_INVALID_PRIMARY_GROUP ||
             Win32rc == ERROR_INVALID_HANDLE ) {

            if ( Win32rc )
                gWarningCode = Win32rc;

            if ( dwInSetup ) {  // in setup, update DB
                Win32rc = ScepSceStatusToDosError(
                           SceJetCommitTransaction( Context, 0));
            } else {
                Win32rc = ERROR_SUCCESS;
            }

        } else if ( dwInSetup ) {  // in setup

            SceJetRollback( Context, 0 );
        }

        if ( Token && (SeInfo & SACL_SECURITY_INFORMATION) )
            SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, FALSE, Token );

    }

    CloseHandle(Token);

    if ( pSD ) {
        LocalFree(pSD);
        pSD = NULL;
    }

    return(Win32rc);

}


SCESTATUS
ScepUpdateObjectInSection(
    IN PSCECONTEXT Context,
    IN SCETYPE ProfileType,
    IN PWSTR ObjectName,
    IN SE_OBJECT_TYPE ObjectType,
    IN UINT nFlag,
    IN PWSTR SDText,
    OUT UINT *pStatus
    )
/*
Routine Description:

    Update SCP and SMP. if the table does not exist at all, ignore the update.
    Delete SAP entry for the object. If table or record not found, ignore the error.

Arguments:

Return Value:

*/
{
    if ( Context == NULL || ObjectName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    PSCESECTION hSection=NULL;
    PCWSTR SectionName;

    switch ( ObjectType ) {
    case SE_FILE_OBJECT:
        SectionName = szFileSecurity;
        break;
    case SE_REGISTRY_KEY:
        SectionName = szRegistryKeys;
        break;
    case SE_SERVICE:
        SectionName = szServiceGeneral;
        break;
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    rc = ScepOpenSectionForName(
                Context,
                ProfileType,
                SectionName,
                &hSection
                );
    if ( rc == SCESTATUS_BAD_FORMAT ||
         rc == SCESTATUS_RECORD_NOT_FOUND ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        WCHAR         StatusFlag=L'\0';
        DWORD         ValueLen;
        BYTE          Status=SCE_STATUS_CHECK;
        BOOL          IsContainer=TRUE;
        BYTE          StartType;

        rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                ObjectName,
                NULL,
                0,
                NULL,
                (PWSTR)&StatusFlag,
                2,
                &ValueLen
                );

        if ( rc == SCESTATUS_SUCCESS ||
             rc == SCESTATUS_BUFFER_TOO_SMALL ) {

            rc = SCESTATUS_SUCCESS;

            Status = *((BYTE *)&StatusFlag);

            if ( pStatus ) {
                *pStatus = Status;
            }

            if ( ObjectType == SE_SERVICE ) {
                StartType = *((BYTE *)&StatusFlag+1);
            } else {
                IsContainer = *((CHAR *)&StatusFlag+1) != '0' ? TRUE : FALSE;
            }
        }

        if ( ObjectType == SE_SERVICE ) {

            DWORD SDLen, Len;
            PWSTR ValueToSet;

            StartType = (BYTE)nFlag;

            if ( SDText != NULL ) {
                SDLen = wcslen(SDText);
                Len = ( SDLen+1)*sizeof(WCHAR);
            } else
                Len = sizeof(WCHAR);

            ValueToSet = (PWSTR)ScepAlloc( (UINT)0, Len+sizeof(WCHAR) );

            if ( ValueToSet != NULL ) {

                //
                // The first byte is the flag, the second byte is IsContainer (1,0)
                //
                *((BYTE *)ValueToSet) = Status;

                *((BYTE *)ValueToSet+1) = StartType;

                if ( SDText != NULL ) {
                    swprintf(ValueToSet+1, L"%s", SDText );
                    ValueToSet[SDLen+1] = L'\0';  //terminate this string
                } else {
                    ValueToSet[1] = L'\0';
                }

                if ( SCESTATUS_SUCCESS == rc || ProfileType != SCE_ENGINE_SAP ) {
                    //
                    // only update tattoo table (pointed by SAP handle) if it finds a record there
                    // for other table (SMP), ignore the error code, just set
                    //
                    rc = SceJetSetLine( hSection,
                                        ObjectName,
                                        FALSE,
                                        ValueToSet,
                                        Len,
                                        0);
                }

                ScepFree( ValueToSet );

            } else {

                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        } else if ( SCESTATUS_SUCCESS == rc || ProfileType != SCE_ENGINE_SAP ) {
            //
            // only update tattoo table (pointed by SAP handle) if it finds a record there
            // for other table (SMP), ignore the error code, just set
            //

            rc = ScepSaveObjectString(
                    hSection,
                    ObjectName,
                    IsContainer,
                    Status,
                    SDText,
                    (SDText == NULL ) ? 0 : wcslen(SDText)
                    );
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND )
            rc = SCESTATUS_SUCCESS;

        SceJetCloseSection(&hSection, TRUE);
    }

    return(rc);
}


DWORD
ScepSetupMoveFile(
    IN PSCECONTEXT Context,
    PWSTR OldName,
    PWSTR NewName OPTIONAL,
    PWSTR SDText OPTIONAL
    )
/*
Routine Description:

    Set security to OldName but save with NewName in SCE database if SDText
    is not NULL. If NewName is NULL, delete OldName from SCE database.

Arguments:

    Context     - the databaes context handle

    SectionName - the section name

    OldName     - the object's old name

    NewName     - the new name to rename to, if NULL, delete the old object

    SDText      - security string

Return Value:

    Win32 error code
*/
{

    if ( !Context || !OldName ) {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD rc32=ERROR_SUCCESS;

    if ( NewName && SDText  ) {
        //
        // set security on OldName with SDText
        //

        rc32 = ScepSetupUpdateObject(
                        Context,
                        OldName,
                        SE_FILE_OBJECT,
                        0,
                        SDText
                        );
    }

    if ( rc32 == ERROR_SUCCESS ) {

        //
        // save this into SCP and SMP, do not overwrite the status/container flag
        // if there is one exist, else use SCE_STATUS_CHECK and check for container
        //

        SCESTATUS rc = SceJetStartTransaction( Context );

        if ( rc == SCESTATUS_SUCCESS ) {

            PSCESECTION hSection=NULL;
            //
            // process SMP section first
            //
            rc = ScepOpenSectionForName(
                        Context,
                        SCE_ENGINE_SMP,
                        szFileSecurity,
                        &hSection
                        );

            if ( rc == SCESTATUS_SUCCESS ) {
                if ( NewName ) {
                    //
                    // rename this line
                    //
                    rc = SceJetRenameLine(
                            hSection,
                            OldName,
                            NewName,
                            FALSE);

                } else {
                    //
                    // delete this line first
                    //
                    rc = SceJetDelete(
                        hSection,
                        OldName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
                }
                SceJetCloseSection( &hSection, TRUE);
            }


            if ( (SCESTATUS_SUCCESS == rc ||
                  SCESTATUS_RECORD_NOT_FOUND == rc ||
                  SCESTATUS_BAD_FORMAT == rc) &&
                 (Context->JetSapID != JET_tableidNil) ) {
                //
                // process tattoo table
                //
                rc = ScepOpenSectionForName(
                            Context,
                            SCE_ENGINE_SAP,
                            szFileSecurity,
                            &hSection
                            );

                if ( rc == SCESTATUS_SUCCESS ) {
                    if ( NewName ) {
                        //
                        // rename this line
                        //
                        rc = SceJetRenameLine(
                                hSection,
                                OldName,
                                NewName,
                                FALSE);

                    } else {
                        //
                        // delete this line first
                        //
                        rc = SceJetDelete(
                            hSection,
                            OldName,
                            FALSE,
                            SCEJET_DELETE_LINE_NO_CASE
                            );
                    }

                    SceJetCloseSection( &hSection, TRUE);
                }

            }
            if ( SCESTATUS_RECORD_NOT_FOUND == rc ||
                 SCESTATUS_BAD_FORMAT == rc ) {
                rc = SCESTATUS_SUCCESS;
            }

            if ( SCESTATUS_SUCCESS == rc ) {
                //
                // commit the transaction
                //
                rc = SceJetCommitTransaction( Context, 0 );
            } else {
                //
                // rollback the transaction
                //
                SceJetRollback( Context, 0 );
            }
        }

        rc32 = ScepSceStatusToDosError(rc);
    }

    return(rc32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\srvutil.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    srvutil.cpp

Abstract:

    Server Service attachment APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997

Revision History:

    jinhuang    23-Jan-1998     splitted to client-server
--*/
#include "serverp.h"
#include "srvutil.h"
#include "infp.h"
#include "pfp.h"

#include <io.h>
#pragma hdrstop

DWORD Thread     gMaxRegTicks=0;
DWORD Thread     gMaxFileTicks=0;
DWORD Thread     gMaxDsTicks=0;
WCHAR Thread     theAcctDomName[MAX_PATH+1];
WCHAR Thread     ComputerName[MAX_COMPUTERNAME_LENGTH+1];
CHAR Thread      sidAuthBuf[32];
CHAR Thread      sidBuiltinBuf[32];
DWORD Thread     t_pebSize=0;
LPVOID Thread    t_pebClient=NULL;

SCESTATUS
ScepQueryInfTicks(
    IN PWSTR TemplateName,
    IN AREA_INFORMATION Area,
    OUT PDWORD pTotalTicks
    );

SCESTATUS
ScepGetObjectCount(
    IN PSCECONTEXT Context,
    IN PCWSTR SectionName,
    IN BOOL bPolicyProp,
    OUT PDWORD pTotalTicks
    );


LPTSTR
ScepSearchClientEnv(
    IN LPTSTR varName,
    IN DWORD dwSize
    );

//
// implementations
//


SCESTATUS
ScepGetTotalTicks(
    IN PCWSTR TemplateName,
    IN PSCECONTEXT Context,
    IN AREA_INFORMATION Area,
    IN SCEFLAGTYPE nFlag,
    OUT PDWORD pTotalTicks
    )
/*
Routine Description:

    Retrieve the total count of objects from the inf template and/or the
    database for the area specified.

Arguments:

    TemplateName - the INF template Name

    Context      - the database context

    Area         - the security area

    nFlag - the flag to indicate operation which determines where the count is
            retrieved:

                SCE_FLAG_CONFIG
                SCE_FLAG_CONFIG_APPEND
                SCE_FLAG_ANALYZE
                SCE_FLAG_ANALYZE_APPEND

    pTotalTicks - the output count

Return Value:

    SCE Status
*/
{
    if ( pTotalTicks == NULL ||
        ( NULL == TemplateName && NULL == Context) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;
    DWORD nTicks=0;

    *pTotalTicks = 0;
    gMaxRegTicks=0;
    gMaxFileTicks=0;
    gMaxDsTicks=0;

    if ( Area & (AREA_FILE_SECURITY |
                 AREA_REGISTRY_SECURITY) ) { // |
//                 AREA_DS_OBJECTS) ) {

        switch ( nFlag ) {
        case SCE_FLAG_CONFIG:
        case SCE_FLAG_CONFIG_APPEND:
        case SCE_FLAG_CONFIG_SCP:
        case SCE_FLAG_CONFIG_SCP_APPEND:

            if ( TemplateName != NULL ) {

                //
                // use the template if there is any
                //
                rc = ScepQueryInfTicks(
                            (LPTSTR)TemplateName,
                            Area & (AREA_FILE_SECURITY |
                                    AREA_REGISTRY_SECURITY), // |
//                                    AREA_DS_OBJECTS),
                            pTotalTicks
                            );
            }
            if ( Context != NULL &&
                 (nFlag == SCE_FLAG_CONFIG_APPEND ||
                  nFlag == SCE_FLAG_CONFIG_SCP_APPEND ||
                  TemplateName == NULL) ) {

                //
                // use the existing database
                //

                if ( Area & AREA_REGISTRY_SECURITY ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                            szRegistryKeys,
                                            (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                            &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxRegTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
                if ( rc == SCESTATUS_SUCCESS && (Area & AREA_FILE_SECURITY) ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                             szFileSecurity,
                                             (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                             &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxFileTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
#if 0
                if ( rc == SCESTATUS_SUCCESS && (Area & AREA_DS_OBJECTS) ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                        szDSSecurity,
                                        (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                        &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxDsTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
#endif

            }

            break;
        case SCE_FLAG_ANALYZE:
        case SCE_FLAG_ANALYZE_APPEND:

            if ( Context != NULL ) {
                //
                // use the existing database
                //
                if ( Area & AREA_REGISTRY_SECURITY ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                             szRegistryKeys,
                                             (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                             &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxRegTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
                if ( rc == SCESTATUS_SUCCESS &&
                     Area & AREA_FILE_SECURITY ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                             szFileSecurity,
                                             (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                             &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxFileTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
#if 0
                if ( rc == SCESTATUS_SUCCESS &&
                    Area & AREA_DS_OBJECTS ) {

                    nTicks = 0;
                    rc = ScepGetObjectCount(Context,
                                        szDSSecurity,
                                        (nFlag >= SCE_FLAG_CONFIG_SCP) ? TRUE : FALSE,
                                        &nTicks);
                    if ( SCESTATUS_SUCCESS == rc ) {
                        gMaxDsTicks += nTicks;
                        *pTotalTicks += nTicks;
                    }
                }
#endif
            }

            if ( rc == SCESTATUS_SUCCESS && TemplateName != NULL &&
                 (nFlag == SCE_FLAG_ANALYZE_APPEND || Context == NULL) ) {

                //
                // get handle in template
                //

                DWORD nTempTicks=0;

                rc = ScepQueryInfTicks(
                            (LPTSTR)TemplateName,
                            Area & (AREA_FILE_SECURITY |
                                    AREA_REGISTRY_SECURITY), // |
//                                    AREA_DS_OBJECTS),
                            &nTempTicks
                            );
                if ( rc == SCESTATUS_SUCCESS ) {
                    *pTotalTicks += nTempTicks;
                }
            }

            break;
        default:
            return SCESTATUS_INVALID_PARAMETER;
        }
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Area & AREA_SECURITY_POLICY )
            *pTotalTicks += TICKS_SECURITY_POLICY_DS + TICKS_SPECIFIC_POLICIES;

        if ( Area & AREA_GROUP_MEMBERSHIP )
            *pTotalTicks += TICKS_GROUPS;

        if ( Area & AREA_PRIVILEGES )
            *pTotalTicks += TICKS_PRIVILEGE;

        if ( Area & AREA_SYSTEM_SERVICE )
            *pTotalTicks += TICKS_GENERAL_SERVICES + TICKS_SPECIFIC_SERVICES;
/*
        if ( *pTotalTicks ) {
            *pTotalTicks += 10;  // for jet engine initialization
        }
*/
    }

    return(rc);

}


SCESTATUS
ScepQueryInfTicks(
    IN PWSTR TemplateName,
    IN AREA_INFORMATION Area,
    OUT PDWORD pTotalTicks
    )
/*
Routine Description:

    Query total number of objects in the inf template for the specified area.

Arguments:

Return:

*/
{
    LONG Count=0;
    HINF InfHandle;

    SCESTATUS rc = SceInfpOpenProfile(
                        TemplateName,
                        &InfHandle
                        );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Area & AREA_REGISTRY_SECURITY ) {

            Count = SetupGetLineCount(InfHandle, szRegistryKeys);
            gMaxRegTicks += Count;

        }
        if ( Area & AREA_FILE_SECURITY ) {

            Count += SetupGetLineCount(InfHandle, szFileSecurity);
            gMaxFileTicks += Count;
        }
#if 0
        if ( Area & AREA_DS_OBJECTS ) {

            Count += SetupGetLineCount(InfHandle, szDSSecurity);
            gMaxDsTicks += Count;
        }
#endif
        SceInfpCloseProfile(InfHandle);
    }

    *pTotalTicks = Count;

    return(rc);
}



SCESTATUS
ScepGetObjectCount(
    IN PSCECONTEXT Context,
    IN PCWSTR SectionName,
    IN BOOL bPolicyProp,
    OUT PDWORD pTotalTicks
    )
{
    if ( Context == NULL || SectionName == NULL ||
         pTotalTicks == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCESECTION hSection=NULL;
    SCESTATUS rc;
    DWORD count=0;

    rc = ScepOpenSectionForName(
                Context,
                bPolicyProp ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                SectionName,
                &hSection
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = SceJetGetLineCount(
                    hSection,
                    NULL,
                    FALSE,
                    &count
                    );

        if ( rc == SCESTATUS_SUCCESS )
            *pTotalTicks += count;

        SceJetCloseSection( &hSection, TRUE);
    }

    if ( SCESTATUS_RECORD_NOT_FOUND )
        rc = SCESTATUS_SUCCESS;

    return(rc);
}


BOOL
ScepIsEngineRecovering()
{
   TCHAR TempFileName[MAX_PATH];
   PWSTR SysRoot=NULL;
   DWORD SysLen;
   DWORD rc;
   intptr_t            hFile;
   struct _wfinddata_t    FileInfo;
   BOOL bFindIt=FALSE;

   SysLen =  0;
   rc = ScepGetNTDirectory( &SysRoot, &SysLen, SCE_FLAG_WINDOWS_DIR );

   if ( rc == NO_ERROR && SysRoot != NULL ) {

       swprintf(TempFileName, L"%s\\Security\\tmp.edb", SysRoot);
       TempFileName[MAX_PATH-1] = L'\0';

       hFile = _wfindfirst(TempFileName, &FileInfo);

       if ( hFile != -1 ) {

           bFindIt = TRUE;
           _findclose(hFile);
       }

       ScepFree(SysRoot);

   }

   return bFindIt;

}



SCESTATUS
ScepSaveAndOffAuditing(
    OUT PPOLICY_AUDIT_EVENTS_INFO *ppAuditEvent,
    IN BOOL bTurnOffAuditing,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    )
{
    LSA_HANDLE      lsaHandle=NULL;
    NTSTATUS        status;
    SCESTATUS        rc;
    POLICY_AUDIT_EVENT_OPTIONS  lSaveAudit;

    //
    // open Lsa policy for read/write
    //

    if ( PolicyHandle == NULL ) {

        ACCESS_MASK  access=0;

        if ( bTurnOffAuditing ) {
            access = POLICY_SET_AUDIT_REQUIREMENTS | POLICY_AUDIT_LOG_ADMIN;
        }

        status = ScepOpenLsaPolicy(
                        POLICY_VIEW_AUDIT_INFORMATION | access,
                        &lsaHandle,
                        TRUE
                        );

        if (status != ERROR_SUCCESS) {

            lsaHandle = NULL;
            rc = RtlNtStatusToDosError( status );
            ScepLogOutput3( 1, rc, SCEDLL_LSA_POLICY);

            return(ScepDosErrorToSceStatus(rc));
        }

    } else {

        lsaHandle = PolicyHandle;
    }
    //
    // Query audit event information
    //

    status = LsaQueryInformationPolicy( lsaHandle,
                                      PolicyAuditEventsInformation,
                                      (PVOID *)ppAuditEvent
                                    );
    rc = RtlNtStatusToDosError( status );

    if ( NT_SUCCESS( status ) && bTurnOffAuditing && (*ppAuditEvent)->AuditingMode ) {

        //
        // turn off object access auditing
        //
        if ( AuditCategoryObjectAccess < (*ppAuditEvent)->MaximumAuditEventCount ) {
            lSaveAudit = (*ppAuditEvent)->EventAuditingOptions[AuditCategoryObjectAccess];
            (*ppAuditEvent)->EventAuditingOptions[AuditCategoryObjectAccess] = POLICY_AUDIT_EVENT_NONE;

            status = LsaSetInformationPolicy( lsaHandle,
                                              PolicyAuditEventsInformation,
                                              (PVOID)(*ppAuditEvent)
                                            );

            //
            // restore the object access auditing mode
            //

            (*ppAuditEvent)->EventAuditingOptions[AuditCategoryObjectAccess] = lSaveAudit;

        }

        rc = RtlNtStatusToDosError( status );


        if ( rc == NO_ERROR )
            ScepLogOutput3( 2, 0, SCEDLL_EVENT_IS_OFF);
        else
            ScepLogOutput3( 1, rc, SCEDLL_SCP_ERROR_EVENT_AUDITING);

    } else if ( rc != NO_ERROR)
        ScepLogOutput3( 1, rc, SCEDLL_ERROR_QUERY_EVENT_AUDITING);

    //
    // free LSA handle if it's opened in this function
    //
    if ( lsaHandle && (PolicyHandle == NULL) )
        LsaClose( lsaHandle );

    return(ScepDosErrorToSceStatus(rc));
}


NTSTATUS
ScepGetAccountExplicitRight(
    IN LSA_HANDLE PolicyHandle,
    IN PSID       AccountSid,
    OUT PDWORD    PrivilegeLowRights,
    OUT PDWORD    PrivilegeHighRights
    )
/* ++
Routine Description:

    This routine queries the explicitly assigned privilege/rights to a account
    (referenced by AccountSid) and stores in a DWORD type variable PrivilegeRights,
    in which each bit represents a privilege/right.

Arguments:

    PolicyHandle    - Lsa Policy Domain handle

    AccountSid      - The SID for the account

    PrivilegeRights - Privilege/Rights of this account

Return value:

    NTSTATUS
-- */
{
    NTSTATUS            NtStatus;

    DWORD               CurrentPrivLowRights=0, CurrentPrivHighRights=0;
    LONG                index;
    PUNICODE_STRING     UserRightEnum=NULL;
    ULONG               i, cnt=0;
    LUID                LuidValue;

    //
    // Enumerate user privilege/rights
    //

    NtStatus = LsaEnumerateAccountRights(
                    PolicyHandle,
                    AccountSid,
                    &UserRightEnum,
                    &cnt
                    );
    if ( NtStatus == STATUS_NO_SUCH_PRIVILEGE ||
        NtStatus == STATUS_OBJECT_NAME_NOT_FOUND ) {

        NtStatus = ERROR_SUCCESS;
        goto Done;
    }

    if ( !NT_SUCCESS( NtStatus) ) {
        ScepLogOutput3(1,
                       RtlNtStatusToDosError(NtStatus),
                       SCEDLL_SAP_ERROR_ENUMERATE,
                       L"LsaEnumerateAccountRights");
        goto Done;
    }

    if (UserRightEnum != NULL)

        for ( i=0; i < cnt; i++) {
            if ( UserRightEnum[i].Length == 0 )
                continue;

            NtStatus = LsaLookupPrivilegeValue(
                            PolicyHandle,
                            &UserRightEnum[i],
                            &LuidValue
                            );

            if ( NtStatus == STATUS_NO_SUCH_PRIVILEGE ) {
                index = ScepLookupPrivByName( UserRightEnum[i].Buffer );
                NtStatus = ERROR_SUCCESS;
            } else if ( NT_SUCCESS(NtStatus) ) {
                index = ScepLookupPrivByValue( LuidValue.LowPart );
            } else
                index = -1;

            if ( index == -1 ) {

                //
                // not found
                //

                NtStatus = STATUS_NOT_FOUND;
                ScepLogOutput3(1,
                               RtlNtStatusToDosError(NtStatus),
                               SCEDLL_USERRIGHT_NOT_DEFINED);
                goto Done;

            } else {
                if ( index < 32 ) {
                    CurrentPrivLowRights |= (1 << index);
                } else {
                    CurrentPrivHighRights |= (1 << (index-32) );
                }
            }
        }

Done:

    *PrivilegeLowRights = CurrentPrivLowRights;
    *PrivilegeHighRights = CurrentPrivHighRights;

    if (UserRightEnum != NULL)
        LsaFreeMemory(UserRightEnum);

    return (NtStatus);
}


NTSTATUS
ScepGetMemberListSids(
    IN PSID         DomainSid,
    IN LSA_HANDLE   PolicyHandle,
    IN PSCE_NAME_LIST pMembers,
    OUT PUNICODE_STRING *MemberNames,
    OUT PSID**      Sids,
    OUT PULONG      MemberCount
    )
/*
Routine Description:

    Lookup each account in the name list pMembers and return the lookup information
    in the output buffer - MemberNames, Sids, MemberCount.

    if an account can't be resolved, the corresponding SID will be empty.

*/
{
    NTSTATUS                    NtStatus=STATUS_SUCCESS;
    PSCE_NAME_LIST               pUser;

    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains=NULL;
    PLSA_TRANSLATED_SID2        MemberSids=NULL;
    DWORD                       i;
    PSID                        DomainSidToUse=NULL;
    ULONG                       Cnt=0;

    //
    // build a UNICODE_STRING for the member list to look up
    //
    for (pUser=pMembers;
         pUser != NULL;
         pUser = pUser->Next) {

        if ( pUser->Name == NULL ) {
            continue;
        }
        Cnt++;
    }

    if ( Cnt > 0 ) {

        *MemberNames = (PUNICODE_STRING)RtlAllocateHeap(
                                        RtlProcessHeap(),
                                        0,
                                        Cnt * sizeof (UNICODE_STRING)
                                        );
        
        if ( *MemberNames == NULL )
            return(STATUS_NO_MEMORY);
                
        *Sids = (PSID *)ScepAlloc( LMEM_ZEROINIT, Cnt*sizeof(PSID));
        if ( *Sids == NULL ) {
            NtStatus = STATUS_NO_MEMORY;
            goto Done;
        }
        
        //
        // Lookup each UNICODE_STRING
        //
        
        for (pUser=pMembers, Cnt=0;
             pUser != NULL;
             pUser = pUser->Next) {

            if ( pUser->Name == NULL ) {
                continue;
            }

            RtlInitUnicodeString(&((*MemberNames)[Cnt]), pUser->Name);
            
            NtStatus = ScepLsaLookupNames2(
                                          PolicyHandle,
                                          LSA_LOOKUP_ISOLATED_AS_LOCAL,
                                          pUser->Name,
                                          &ReferencedDomains,
                                          &MemberSids
                                          );

            if ( !NT_SUCCESS(NtStatus) ) {
                ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                               SCEDLL_ERROR_LOOKUP);
                goto NextMember;
            }
            
            DWORD SidLength=0;
            
            //
            // translate the LSA_TRANSLATED_SID into PSID
            //
            
            if ( MemberSids[0].Use != SidTypeInvalid &&
                 MemberSids[0].Use != SidTypeUnknown &&
                 MemberSids[0].Sid != NULL ) {

                SidLength = RtlLengthSid(MemberSids[0].Sid);

                if ( ((*Sids)[Cnt] = (PSID) ScepAlloc( (UINT)0, SidLength)) == NULL ) {
                    NtStatus = STATUS_NO_MEMORY;
                } else {

                    //
                    // copy the SID
                    // if failed, memory will be freed at cleanup
                    //

                    NtStatus = RtlCopySid( SidLength, (*Sids)[Cnt], MemberSids[0].Sid );

                }

                if ( !NT_SUCCESS(NtStatus) ) {
                    goto Done;
                }
            }

NextMember:

            if ( ReferencedDomains != NULL ){
                LsaFreeMemory(ReferencedDomains);
                ReferencedDomains = NULL;
            }

            if ( MemberSids != NULL ){
                LsaFreeMemory(MemberSids);
                MemberSids = NULL;
            }
            
            Cnt++;
        }
        
    }
    *MemberCount = Cnt;
Done:

    if (!NT_SUCCESS(NtStatus) ) {
        if ( *Sids != NULL ) {
            for ( i=0; i<Cnt; i++ )
                if ( (*Sids)[i] != NULL )
                    ScepFree( (*Sids)[i] );
            ScepFree( *Sids );
            *Sids = NULL;
        }
        if ( *MemberNames != NULL )
            RtlFreeHeap(RtlProcessHeap(), 0, *MemberNames);
        *MemberNames = NULL;
    }
    if ( ReferencedDomains != NULL )
        LsaFreeMemory(ReferencedDomains);

    if ( MemberSids != NULL )
        LsaFreeMemory(MemberSids);

    return(NtStatus);
}


DWORD
ScepOpenFileObject(
    IN  LPWSTR       pObjectName,
    IN  ACCESS_MASK  AccessMask,
    OUT PHANDLE      Handle
    )
/*++
Routine Description:

    opens the specified file (or directory) object

Arguments:

    pObjectName   - the name of the file object

    AccessMask    - Desired Access

    Handle        - the just opened handle to the object

Return value:

    Win32 errro code
*/
{
    NTSTATUS NtStatus;
    DWORD Status = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES Attributes;
    IO_STATUS_BLOCK Isb;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    //
    // cut and paste code from windows\base\advapi\security.c SetFileSecurityW
    //
    if (RtlDosPathNameToNtPathName_U(
                            pObjectName,
                            &FileName,
                            NULL,
                            &RelativeName
                            ))
    {
        FreeBuffer = FileName.Buffer;

        if ( RelativeName.RelativeName.Length ) {
            FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
        else {
            RelativeName.ContainingDirectory = NULL;
        }

        InitializeObjectAttributes(
            &Attributes,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );


        NtStatus = NtOpenFile( Handle,
                               AccessMask,
                               &Attributes,
                               &Isb,
                               FILE_SHARE_READ |
                               FILE_SHARE_WRITE |
                               FILE_SHARE_DELETE,
                               0);

        if (!NT_SUCCESS(NtStatus))
        {
            Status = RtlNtStatusToDosError(NtStatus);
        }

        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    } else
    {
        Status = ERROR_INVALID_NAME;
    }

    return(Status);
}


DWORD
ScepOpenRegistryObject(
    IN  SE_OBJECT_TYPE  ObjectType,
    IN  LPWSTR       pObjectName,
    IN  ACCESS_MASK  AccessMask,
    OUT PHKEY        Handle
    )
/*++
Routine Description:

    opens the specified registry key object

Arguments:

    pObjectName  - the name of the object

    AccessMask   - Desired access

    Handle      - the just opened handle to the object

Return value:

    Win32 error code

Note:
    The code is cut/pasted from windows\base\accctrl\src\registry.cxx and modified
--*/
{
    DWORD status=NO_ERROR;
    HKEY basekey;
    LPWSTR usename, basekeyname, keyname;

    if (pObjectName) {

        //
        // save a copy of the name since we must crack it.
        //
        if (NULL != (usename = (LPWSTR)ScepAlloc( LMEM_ZEROINIT,
                               (wcslen(pObjectName) + 1) * sizeof(WCHAR)))) {

            wcscpy(usename,pObjectName);

            basekeyname = usename;
            keyname = wcschr(usename, L'\\');
            if (keyname != NULL) {
                *keyname = L'\0';
                keyname++;
            }

            if (0 == _wcsicmp(basekeyname, L"MACHINE")) {
                basekey = HKEY_LOCAL_MACHINE;
            } else if (0 == _wcsicmp(basekeyname, L"USERS")) {
                basekey = HKEY_USERS;
            } else if ( 0 == _wcsicmp(basekeyname, L"CLASSES_ROOT")) {
                basekey = HKEY_CLASSES_ROOT;
            } else {
                status = ERROR_INVALID_PARAMETER;
            }

            if (NO_ERROR == status) {
                if ( keyname == NULL ) {
                    *Handle = basekey;
                } else {
                    //
                    // open the key
                    //

#ifdef _WIN64
                    if (ObjectType == SE_REGISTRY_WOW64_32KEY) {
                        AccessMask |= KEY_WOW64_32KEY;
                    }
#endif

                    status = RegOpenKeyEx(
                                  basekey,
                                  keyname,
                                  0 ,
                                  AccessMask,
                                  Handle
                                  );
                }
            }
            ScepFree(usename);
        } else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        status = ERROR_INVALID_NAME;
    }

    return(status);
}



SCESTATUS
ScepGetNameInLevel(
    IN PCWSTR ObjectFullName,
    IN DWORD  Level,
    IN WCHAR  Delim,
    OUT PWSTR Buffer,
    OUT PBOOL LastOne
    )
/* ++
Routine Description:

    This routine parses a full path name and returns the component for the
    level. For example, a object name "c:\winnt\system32" will return c: for
    level 1, winnt for level 2, and system32 for level 3. This routine is
    used when add a object to the security tree.

Arguments:

    ObjectFullName - The full path name of the object

    Level - the level of component to return

    Delim - the deliminator to look for

    Buffer - The address of buffer for the component name

    LastOne - Flag to indicate if the component is the last one

Return value:

    SCESTATUS

-- */
{
    PWSTR  pTemp, pStart;
    DWORD i;

    if ( ObjectFullName == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // loop through the object name to find the level
    // if there is no such level, return INVALID_PARAMETER
    //
    pStart = (PWSTR)ObjectFullName;
    for ( i=0; i<Level; i++) {

        pTemp = wcschr(pStart, Delim);

        if ( pTemp == pStart ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        if ( i == Level-1 ) {
            //
            // find the right level
            //
            if ( pTemp == NULL ) {
                wcscpy(Buffer, pStart);
                *LastOne = TRUE;
            } else {
                wcsncpy(Buffer, pStart, (size_t)(pTemp - pStart));
                if ( *(pTemp+1) == L'\0' )
                    *LastOne = TRUE;
                else
                    *LastOne = FALSE;
            }
        } else {
            if ( pTemp == NULL )
                return(SCESTATUS_INVALID_PARAMETER);
            else
                pStart = pTemp + 1;
        }
    }

    return(SCESTATUS_SUCCESS);

}

SCESTATUS
ScepTranslateFileDirName(
   IN  PWSTR oldFileName,
   OUT PWSTR *newFileName
   )
/* ++
Routine Description:

   This routine converts a generic file/directory name to a real used name
   for the current system. The following generic file/directory names are handled:
         %systemroot%   - Windows NT root directory (e.g., c:\winnt)
         %systemDirectory% - Windows NT system32 directory (e.g., c:\winnt\system32)

Arguments:

   oldFileName - the file name to convert, which includes "%" to represent
                 some directory names

   newFileName - the real file name, in which the "%" name is replaced with
                 the real directory name

Return values:

   Win32 error code

-- */
{
    PWSTR   pTemp=NULL, pStart, TmpBuf, szVar;
    DWORD   rc=NO_ERROR;
    DWORD   newFileSize, cSize;
    BOOL    bContinue;

    //
    // match for %systemroot%
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMROOT%",
                                       SCE_FLAG_WINDOWS_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for %systemdirectory%
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMDIRECTORY%",
                                       SCE_FLAG_SYSTEM_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for systemdrive
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%SYSTEMDRIVE%",
                                       SCE_FLAG_WINDOWS_DIR,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    //
    // match for boot drive
    //

    rc = ScepExpandEnvironmentVariable(oldFileName,
                                       L"%BOOTDRIVE%",
                                       SCE_FLAG_BOOT_DRIVE,
                                       newFileName);

    if ( rc != ERROR_FILE_NOT_FOUND ) {
        return rc;
    }

    rc = ERROR_SUCCESS;
    //
    // search for environment variable in the current process
    //
    pStart = wcschr(oldFileName, L'%');

    if ( pStart ) {
        pTemp = wcschr(pStart+1, L'%');
        if ( pTemp ) {

            bContinue = TRUE;
            //
            // find a environment variable to translate
            //
            TmpBuf = (PWSTR)ScepAlloc(0, ((UINT)(pTemp-pStart))*sizeof(WCHAR));
            if ( TmpBuf ) {

                wcsncpy(TmpBuf, pStart+1, (size_t)(pTemp-pStart-1));
                TmpBuf[pTemp-pStart-1] = L'\0';

                //
                // try search in the client environment block
                //

                szVar = ScepSearchClientEnv(TmpBuf, (DWORD)(pTemp-pStart-1));

                if ( szVar ) {

//                        ScepLogOutput2(3,0,L"\tFind client env %s=%s", TmpBuf, szVar);
                    //
                    // find it in the client's environment block, use it
                    // get info in szVar
                    //
                    bContinue = FALSE;

                    newFileSize = ((DWORD)(pStart-oldFileName))+wcslen(szVar)+wcslen(pTemp+1)+1;

                    *newFileName = (PWSTR)ScepAlloc(0, newFileSize*sizeof(TCHAR));

                    if (*newFileName ) {
                        if ( pStart != oldFileName ) {
                            wcsncpy(*newFileName, oldFileName, (size_t)(pStart-oldFileName));
                        }

                        swprintf((PWSTR)(*newFileName+(pStart-oldFileName)), L"%s%s", szVar, pTemp+1);

                    } else {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    //
                    // DO NOT free szVar because it's a ref pointer to the env block
                    //
                } else {

                    cSize = GetEnvironmentVariable( TmpBuf,
                                                NULL,
                                                0 );

                    if ( cSize > 0 ) {
                    //
                    // does not find it in the client environment block,
                    // find it in the current server process environment, use it
                    //
                        szVar = (PWSTR)ScepAlloc(0, (cSize+1)*sizeof(WCHAR));

                        if ( szVar ) {
                            cSize = GetEnvironmentVariable(TmpBuf,
                                                       szVar,
                                                       cSize);
                            if ( cSize > 0 ) {
                                //
                                // get info in szVar
                                //
                                bContinue = FALSE;

                                newFileSize = ((DWORD)(pStart-oldFileName))+cSize+wcslen(pTemp+1)+1;

                                *newFileName = (PWSTR)ScepAlloc(0, newFileSize*sizeof(TCHAR));

                                if (*newFileName ) {
                                    if ( pStart != oldFileName )
                                        wcsncpy(*newFileName, oldFileName, (size_t)(pStart-oldFileName));

                                    swprintf((PWSTR)(*newFileName+(pStart-oldFileName)), L"%s%s", szVar, pTemp+1);

                                } else
                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                            }

                            ScepFree(szVar);

                        } else
                            rc = ERROR_NOT_ENOUGH_MEMORY;

                    }
                }

                ScepFree(TmpBuf);

            } else
                rc = ERROR_NOT_ENOUGH_MEMORY;

            if ( NO_ERROR != rc || !bContinue ) {
                //
                // if errored, or do not continue
                //
                return(rc);
            }

            //
            // not found in environment blob,
            // continue to search for DSDIT/DSLOG/SYSVOL in registry
            //
            if ( ProductType == NtProductLanManNt ) {

                //
                // search for DSDIT
                //

                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%DSDIT%",
                                                   SCE_FLAG_DSDIT_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

                //
                // search for DSLOG
                //

                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%DSLOG%",
                                                   SCE_FLAG_DSLOG_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

                //
                // search for SYSVOL
                //
                rc = ScepExpandEnvironmentVariable(oldFileName,
                                                   L"%SYSVOL%",
                                                   SCE_FLAG_SYSVOL_DIR,
                                                   newFileName);

                if ( rc != ERROR_FILE_NOT_FOUND ) {
                    return rc;
                }

            }

        }
    }
    //
    // Otherwise, just copy the old name to a new buffer and return ERROR_PATH_NOT_FOUND
    //
    *newFileName = (PWSTR)ScepAlloc(0, (wcslen(oldFileName)+1)*sizeof(TCHAR));

    if (*newFileName != NULL) {
        wcscpy(*newFileName, _wcsupr(oldFileName) );
        rc = ERROR_PATH_NOT_FOUND;
    } else
        rc = ERROR_NOT_ENOUGH_MEMORY;

    return(rc);

}

LPTSTR
ScepSearchClientEnv(
    IN LPTSTR varName,
    IN DWORD dwSize
    )
{
    if ( !varName || dwSize == 0 ||
         !t_pebClient || t_pebSize == 0 ) {
        return NULL;
    }

    LPTSTR pTemp = (LPTSTR)t_pebClient;

    while ( pTemp && *pTemp != L'\0' ) {


        if ( _wcsnicmp(varName, pTemp, dwSize) == 0 &&
             L'=' == *(pTemp+dwSize) ) {
            //
            // find the variable
            //
            return pTemp+dwSize+1;
            break;
        }
        DWORD Len = wcslen(pTemp);
        pTemp += Len+1;
    }

    return NULL;
}


SCESTATUS
ScepConvertLdapToJetIndexName(
    IN PWSTR TempName,
    OUT PWSTR *OutName
    )
{
    PWSTR pTemp1;
    PWSTR pTemp2;
    INT i,j;
    DWORD Len;

    //
    // Ldap name are in the format of CN=,DC=,...O=
    // Jet Index requires names in the O=,...DC=,CN= format
    //
    // semicolon is converted to , and spaces are stripped out
    //
    if ( TempName == NULL || OutName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    Len = wcslen(TempName);
    pTemp1 = TempName + Len - 1;

    //
    // skip the trailing spaces, commas, or semicolons
    //
    while ( pTemp1 >= TempName &&
            (*pTemp1 == L' ' || *pTemp1 == L';' || *pTemp1 == L',') ) {
        pTemp1--;
    }

    if ( pTemp1 < TempName ) {
        //
        // all spaces or ; in the name
        //
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // allocate output buffer
    //
    *OutName = (PWSTR)ScepAlloc(0, ((UINT)(pTemp1-TempName+2))*sizeof(WCHAR));
    if ( *OutName != NULL ) {

        pTemp2 = *OutName;

        while ( pTemp1 >= TempName ) {

            //
            // find the previous ; or ,
            //
            i = 0;
            while ( pTemp1-i >= TempName && *(pTemp1-i) != L',' &&
                    *(pTemp1-i) != L';' ) {
                i++;
            }
            //
            // either reach the head, or a ; or , is encountered
            //
            i--;   // i must be >= 0

            //
            // skip the leading spaces
            //
            j = 0;
            while ( *(pTemp1-i+j) == L' ' && j <= i ) {
                j++;
            }
            //
            // copy the component
            //
            if ( i >= j ) {

                if ( pTemp2 != *OutName ) {
                    *pTemp2++ = L',';
                }
                wcsncpy(pTemp2, pTemp1-i+j, i-j+1);
                pTemp2 += (i-j+1);

            } else {
                //
                // all spaces
                //
            }
            pTemp1 -= (i+1);
            //
            // skip the trailing spaces, commas, or semicolons
            //
            while ( pTemp1 >= TempName &&
                    (*pTemp1 == L' ' || *pTemp1 == L';' || *pTemp1 == L',') ) {
                pTemp1--;
            }
        }
        if ( pTemp2 == *OutName ) {
            //
            // nothing got copied to the output buffer, WRONG!!!
            //
            ScepFree(*OutName);
            *OutName = NULL;
            return(SCESTATUS_INVALID_PARAMETER);

        } else {
            //
            // teminate the string
            //
            *pTemp2 = L'\0';
            _wcslwr(*OutName);

            return(SCESTATUS_SUCCESS);
        }

    } else
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
}



SCESTATUS
ScepRestoreAuditing(
    IN PPOLICY_AUDIT_EVENTS_INFO auditEvent,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    )
{
    LSA_HANDLE      lsaHandle=NULL;
    NTSTATUS        status;
    SCESTATUS        rc;

    if ( auditEvent == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( PolicyHandle == NULL ) {

        // open Lsa policy for read/write
        status = ScepOpenLsaPolicy(
                        POLICY_VIEW_AUDIT_INFORMATION |
                        POLICY_SET_AUDIT_REQUIREMENTS |
                        POLICY_AUDIT_LOG_ADMIN,
                        &lsaHandle,
                        TRUE
                        );

        if (status != ERROR_SUCCESS) {

            lsaHandle = NULL;
            rc = RtlNtStatusToDosError( status );
            ScepLogOutput3( 1, rc, SCEDLL_LSA_POLICY);

            return(ScepDosErrorToSceStatus(rc));
        }

    } else {
        lsaHandle = PolicyHandle;
    }

    // restore
    status = LsaSetInformationPolicy( lsaHandle,
                                      PolicyAuditEventsInformation,
                                      (PVOID)(auditEvent)
                                    );
    rc = RtlNtStatusToDosError( status );

    if ( rc == NO_ERROR )
        ScepLogOutput3( 2, 0, SCEDLL_EVENT_RESTORED);
    else
        ScepLogOutput3( 1, rc, SCEDLL_SCP_ERROR_EVENT_AUDITING);

    if ( lsaHandle && (lsaHandle != PolicyHandle) )
        LsaClose( lsaHandle );

    return(ScepDosErrorToSceStatus(rc));

}


DWORD
ScepGetDefaultDatabase(
    IN LPCTSTR JetDbName OPTIONAL,
    IN DWORD LogOptions,
    IN LPCTSTR LogFileName OPTIONAL,
    OUT PBOOL pAdminLogon OPTIONAL,
    OUT PWSTR *ppDefDatabase
    )
/*
Routine Description:

    Get the default SCE database for the current logged on user.

Arguments:

    JetDbName   - optional jet database name

    LogOptions  - options for the log, if there is any

    LogFileName - the log file

    pAdminLogon - output flag to indicate if administrative privileged user logged on

    ppDefDatabase - the default database name

Return Value:

    SCESTATUS
*/
{
    if ( !ppDefDatabase ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( LogOptions & SCE_DISABLE_LOG) {

        ScepEnableDisableLog(FALSE);
    } else {
        ScepEnableDisableLog(TRUE);
    }

    if ( LogOptions & SCE_DEBUG_LOG ) {

        ScepSetVerboseLog(3);

    } else if ( LogOptions & SCE_VERBOSE_LOG ) {
        //
        // by default it's not verbose
        //
        ScepSetVerboseLog(2);

    } else {
        ScepSetVerboseLog(-1);
    }

    if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {
        ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );
    }


    DWORD rc=ERROR_SUCCESS;
    BOOL bAdminLogon=FALSE;

    //
    // determine if admin logs on
    //

    if ( pAdminLogon || !JetDbName || wcslen(JetDbName) < 1) {

        rc = ScepIsAdminLoggedOn(&bAdminLogon);
        if ( rc != NO_ERROR ) {
            ScepLogOutput3(1, rc, SCEDLL_UNKNOWN_LOGON_USER);
        }

        if ( bAdminLogon ) {
            ScepLogOutput3(3, 0, SCEDLL_ADMIN_LOGON);
        }
    }

    //
    // find the databae name
    //

    if ( JetDbName && wcslen(JetDbName) > 0 ) {

        *ppDefDatabase = (LPTSTR)JetDbName;

    } else {

        //
        // query if the profile name (or the default ) in registry
        //

        rc = ScepGetProfileSetting(
                L"DefaultProfile",
                bAdminLogon,
                ppDefDatabase
                );

        if ( rc != NO_ERROR || *ppDefDatabase == NULL ) {   // return is Win32 error code
            ScepLogOutput3(1,rc, SCEDLL_UNKNOWN_DBLOCATION);
        }
    }

    if ( pAdminLogon ) {
        *pAdminLogon = bAdminLogon;
    }

    return(rc);

}



BOOL
ScepIsDomainLocal(
    IN PUNICODE_STRING pDomainName OPTIONAL
    )
/* ++
Routine Description:

    This routine checks if the domain is on the local machine by comparing
    the domain name with the local machine's computer name.

Arguments:

    pDomainName - the domain's name to check

Return Value:

    TRUE if it is local

-- */
{
    NTSTATUS                     NtStatus;
    OBJECT_ATTRIBUTES            ObjectAttributes;
    LSA_HANDLE                   PolicyHandle;
    DWORD                        NameLen=MAX_COMPUTERNAME_LENGTH;


    if ( pDomainName == NULL ) {
        //
        // reset the buffer
        //
        ComputerName[0] = L'\0';
        theAcctDomName[0] = L'\0';
        sidBuiltinBuf[0] = '\0';
        sidAuthBuf[0] = '\0';

        return(TRUE);
    }

    if ( pDomainName->Length <= 0 ||
         pDomainName->Buffer == NULL )
        return(TRUE);

    if ( ComputerName[0] == L'\0' ) {
        memset(ComputerName, '\0', (MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR));
        GetComputerName(ComputerName, &NameLen);
    }

    NameLen = wcslen(ComputerName);

    if ( _wcsnicmp(ComputerName, pDomainName->Buffer, pDomainName->Length/2 ) == 0 &&
         (LONG)NameLen == pDomainName->Length/2 )
        return(TRUE);

    if ( theAcctDomName[0] == L'\0' ) {

        //
        // query the current account domain name (for DC case)
        //

        PPOLICY_ACCOUNT_DOMAIN_INFO  PolicyAccountDomainInfo=NULL;

        //
        // Open the policy database
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        NtStatus = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &PolicyHandle );
        if ( NT_SUCCESS(NtStatus) ) {

            //
            // Query the account domain information
            //

            NtStatus = LsaQueryInformationPolicy( PolicyHandle,
                                                PolicyAccountDomainInformation,
                                                (PVOID *)&PolicyAccountDomainInfo );

            LsaClose( PolicyHandle );
        }

        if ( NT_SUCCESS(NtStatus) ) {

            if ( PolicyAccountDomainInfo->DomainName.Buffer ) {

                wcsncpy(theAcctDomName,
                        PolicyAccountDomainInfo->DomainName.Buffer,
                        PolicyAccountDomainInfo->DomainName.Length/2);

                theAcctDomName[PolicyAccountDomainInfo->DomainName.Length/2] = L'\0';


            }
            LsaFreeMemory(PolicyAccountDomainInfo);
        }
    }

    NameLen = wcslen(theAcctDomName);

    if ( _wcsnicmp(theAcctDomName, pDomainName->Buffer, pDomainName->Length/2) == 0 &&
         (LONG)NameLen == pDomainName->Length/2 )
        return(TRUE);
    else
        return(FALSE);

}


BOOL
ScepIsDomainLocalBySid(
    PSID pSidLookup
    )
{

    if ( pSidLookup == NULL ) {
        return FALSE;
    }

    NTSTATUS                     NtStatus;
    SID_IDENTIFIER_AUTHORITY     NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // search for "NT Authority" name
    //
    if ( sidAuthBuf[0] == '\0' ) {  // sid revision can't be 0

        //
        // build the NT authority sid
        //
        NtStatus = RtlInitializeSid(
                        (PSID)sidAuthBuf,
                        &NtAuthority,
                        0
                        );

        if ( !NT_SUCCESS(NtStatus) ) {

            sidAuthBuf[0] = '\0';
        }

    }

    if ( sidAuthBuf[0] != '\0' &&
         RtlEqualSid((PSID)sidAuthBuf, pSidLookup) ) {

        return(TRUE);
    }

    if ( sidBuiltinBuf[0] == '\0' ) {
        //
        // build the builtin domain sid
        //

        NtStatus = RtlInitializeSid(
                        (PSID)sidBuiltinBuf,
                        &NtAuthority,
                        1
                        );

        if ( NT_SUCCESS(NtStatus) ) {

            *(RtlSubAuthoritySid((PSID)sidBuiltinBuf, 0)) = SECURITY_BUILTIN_DOMAIN_RID;

        } else {

            sidBuiltinBuf[0] = '\0';
        }
    }

    if ( sidBuiltinBuf[0] != '\0' &&
         RtlEqualSid((PSID)sidBuiltinBuf, pSidLookup) ) {

        return(TRUE);

    } else {

        return(FALSE);
    }

}


NTSTATUS
ScepAddAdministratorToThisList(
    IN SAM_HANDLE DomainHandle OPTIONAL,
    IN OUT PSCE_NAME_LIST *ppList
    )
{
    NTSTATUS NtStatus;
    SAM_HANDLE          AccountDomain=NULL;
    SAM_HANDLE          UserHandle=NULL;
    SAM_HANDLE          ServerHandle=NULL;
    PSID                DomainSid=NULL;

    USER_NAME_INFORMATION *BufName=NULL;
    DOMAIN_NAME_INFORMATION *DomainName=NULL;
    PSCE_NAME_LIST        pName=NULL;

    if (!ppList ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if ( !DomainHandle ) {

        //
        // open the sam account domain
        //

        NtStatus = ScepOpenSamDomain(
                        SAM_SERVER_ALL_ACCESS,
                        MAXIMUM_ALLOWED,
                        &ServerHandle,
                        &AccountDomain,
                        &DomainSid,
                        NULL,
                        NULL
                        );

        if ( !NT_SUCCESS(NtStatus) ) {
            ScepLogOutput3(1,RtlNtStatusToDosError(NtStatus),
                           SCEDLL_ERROR_OPEN, L"SAM");
            return(NtStatus);
        }

    } else {
        AccountDomain = DomainHandle;
    }

    //
    // query account domain name
    //
    NtStatus = SamQueryInformationDomain(
                    AccountDomain,
                    DomainNameInformation,
                    (PVOID *)&DomainName
                    );

    if ( NT_SUCCESS( NtStatus ) && DomainName &&
         DomainName->DomainName.Length > 0 && DomainName->DomainName.Buffer ) {

        NtStatus = SamOpenUser(
                      AccountDomain,
                      MAXIMUM_ALLOWED,
                      DOMAIN_USER_RID_ADMIN,
                      &UserHandle
                      );

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SamQueryInformationUser(
                          UserHandle,
                          UserNameInformation,
                          (PVOID *)&BufName
                          );

            if ( NT_SUCCESS( NtStatus ) && BufName &&
                 BufName->UserName.Length > 0 && BufName->UserName.Buffer ) {

                //
                // add it to the members list, check duplicate
                //
                LONG NameLen;
                PWSTR                 pTemp;

                for ( pName = *ppList; pName; pName=pName->Next ) {

                    if ( !pName->Name ) {
                        continue;
                    }

                    pTemp = wcschr( pName->Name, L'\\');

                    if ( pTemp ) {
                        //
                        // has a domain prefix
                        //
                        pTemp++;
                    } else {
                        pTemp = pName->Name;
                    }
                    NameLen = wcslen(pTemp);

                    if ( NameLen == BufName->UserName.Length/2 &&
                         _wcsnicmp(pTemp,
                                   BufName->UserName.Buffer,
                                   BufName->UserName.Length/2) == 0 ) {
                        //
                        // now, match the domain prefix
                        //
                        if ( pTemp != pName->Name ) {

                            if ( (pTemp-pName->Name-1) == DomainName->DomainName.Length/2 &&
                                 _wcsnicmp(pName->Name,
                                           DomainName->DomainName.Buffer,
                                           DomainName->DomainName.Length/2) == 0 ) {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }

                if ( !pName ) {

                    //
                    // allocate a new node, if no resource, ignore the addition
                    //
                    pName = (PSCE_NAME_LIST)ScepAlloc( (UINT)0, sizeof(SCE_NAME_LIST));

                    if ( pName ) {

                        pName->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, BufName->UserName.Length+DomainName->DomainName.Length+4);

                        if ( pName->Name == NULL ) {
                            ScepFree(pName);
                        } else {
                            //
                            // add the node to the front of the members list
                            //
                            NameLen = DomainName->DomainName.Length/2;

                            wcsncpy(pName->Name, DomainName->DomainName.Buffer,
                                    NameLen);
                            pName->Name[NameLen] = L'\\';

                            wcsncpy(pName->Name+NameLen+1, BufName->UserName.Buffer,
                                    BufName->UserName.Length/2);
                            pName->Name[NameLen+1+BufName->UserName.Length/2] = L'\0';

                            pName->Next = *ppList;
                            *ppList = pName;
                        }
                    }
                } else {
                    // else find it in the member list already, do nothing
                }

            }

            //
            // close the user handle
            //
            SamCloseHandle(UserHandle);
            UserHandle = NULL;
        }
    }

    if ( AccountDomain != DomainHandle ) {
       //
       // domain is opened
       //
       SamCloseHandle(AccountDomain);

       SamCloseHandle( ServerHandle );
       if ( DomainSid != NULL )
           SamFreeMemory(DomainSid);
    }

    if ( BufName ) {
        SamFreeMemory(BufName);
    }

    if ( DomainName ) {
        SamFreeMemory(DomainName);
    }

    return(NtStatus);
}



DWORD
ScepDatabaseAccessGranted(
    IN LPTSTR DatabaseName,
    IN DWORD DesiredAccess,
    IN BOOL bCreate
    )
{

    if ( DatabaseName == NULL || DesiredAccess == 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    HANDLE hToken, hNewToken;
    DWORD Win32rc = NO_ERROR;

    //
    // get current client token
    //
    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                          FALSE,
                          &hToken)) {

        if (!OpenProcessToken( GetCurrentProcess(),
                               TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                               &hToken)) {
            return( GetLastError() );
        }
    }

    //
    // Duplicate it so it can be used for impersonation
    //

    if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                          NULL, SecurityImpersonation, TokenImpersonation,
                          &hNewToken))
    {
        CloseHandle (hToken);
        return ( GetLastError() );
    }

    CloseHandle (hToken);


    PSECURITY_DESCRIPTOR pCurrentSD=NULL;
    PRIVILEGE_SET PrivSet;
    DWORD PrivSetLength = sizeof(PRIVILEGE_SET);
    DWORD dwGrantedAccess;
    BOOL bAccessStatus = TRUE;

    if ( !bCreate ) {

        Win32rc = ScepGetNamedSecurityInfo(
                        DatabaseName,
                        SE_FILE_OBJECT,
                        OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION |
                        DACL_SECURITY_INFORMATION,
                        &pCurrentSD
                        );

        if ( Win32rc == ERROR_PATH_NOT_FOUND ||
             Win32rc == ERROR_FILE_NOT_FOUND ) {

            pCurrentSD = NULL;

            Win32rc = NO_ERROR;

        }
    }

    if ( Win32rc == NO_ERROR ) {

        if ( pCurrentSD == NULL ) {
            //
            // either this database is to be overwritten (re-created)
            // or it doesn't exist. In both cases, hand the call over to Jet
            // which will do the right access checking.
            //
        } else {

            if ( !AccessCheck (
                        pCurrentSD,
                        hNewToken,
                        DesiredAccess,
                        &FileGenericMapping,
                        &PrivSet,
                        &PrivSetLength,
                        &dwGrantedAccess,
                        &bAccessStatus
                        ) ) {

                Win32rc = GetLastError();

            } else {

                if ( bAccessStatus &&
                     (dwGrantedAccess == DesiredAccess ) ) {
                    Win32rc = NO_ERROR;
                } else {
                    Win32rc = ERROR_ACCESS_DENIED;
                }
            }
        }

    }

    if ( pCurrentSD ) {

        LocalFree(pCurrentSD);
    }

    CloseHandle (hNewToken);

    return( Win32rc );
}


DWORD
ScepAddSidToNameList(
    OUT PSCE_NAME_LIST *pNameList,
    IN PSID pSid,
    IN BOOL bReuseBuffer,
    OUT BOOL *pbBufferUsed
    )
/* ++
Routine Description:

    This routine adds a SID to the name list. The new added
    node is always placed as the head of the list for performance reason.

Arguments:

    pNameList -  The address of the name list to add to.

    pSid      - the Sid to add

Return value:

    Win32 error code
-- */
{

    PSCE_NAME_LIST pList=NULL;
    ULONG  Length;

    //
    // check arguments
    //
    if ( pNameList == NULL ||
         pbBufferUsed == NULL )
        return(ERROR_INVALID_PARAMETER);

    *pbBufferUsed = FALSE;

    if ( pSid == NULL )
        return(NO_ERROR);

    if ( !RtlValidSid(pSid) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // check if the SID is already in the name list
    //
    for ( pList=*pNameList; pList!=NULL; pList=pList->Next ) {
        if ( pList->Name == NULL ) {
            continue;
        }
        if ( ScepValidSid( (PSID)(pList->Name) ) &&
             RtlEqualSid( (PSID)(pList->Name), pSid ) ) {
            break;
        }
    }

    if ( pList ) {
        //
        // the SID is already in the list
        //
        return(NO_ERROR);
    }

    //
    // allocate a new node
    //
    pList = (PSCE_NAME_LIST)ScepAlloc( (UINT)0, sizeof(SCE_NAME_LIST));

    if ( pList == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    if ( bReuseBuffer ) {

        pList->Name = (PWSTR)pSid;
        *pbBufferUsed = TRUE;

    } else {

        Length = RtlLengthSid ( pSid );

        pList->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, Length);
        if ( pList->Name == NULL ) {
            ScepFree(pList);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // add the node to the front of the list and link its next to the old list
        //
        RtlCopySid( Length, (PSID)(pList->Name), pSid );
    }

    pList->Next = *pNameList;
    *pNameList = pList;

    return(NO_ERROR);
}


BOOL
ScepValidSid(
    PSID Sid
    )
{
    if ( RtlValidSid(Sid) ) {

        PISID Isid = (PISID) Sid;

        if ( Isid->Revision == SID_REVISION ) {
            return(TRUE);
        } else {
            return(FALSE);
        }
    }

    return(FALSE);
}

BOOL
ScepBinarySearch(
    IN  PWSTR   *aPszPtrs,
    IN  DWORD   dwSize_aPszPtrs,
    IN  PWSTR   pszNameToFind
    )
/* ++
Routine Description:

    This routine determines if a string is found in a sorted array of strings.
    The complexity of this search is logarithmic (log(n)) in the size of the
    input array.

Arguments:

    aPszPtrs        -   the array of string pointers to search in

    dwSize_aPszPtrs -   the size of the above array

    pszNameToFind   -   the string to search for

Return value:

    TRUE if string is found
    FALSE if string is not found

-- */
{
    if ( aPszPtrs == NULL || dwSize_aPszPtrs == 0 || pszNameToFind == NULL ) {
        return FALSE;
    }

    int   iLow = 0;
    int   iHigh = dwSize_aPszPtrs - 1;
    int   iMid;
    int   iCmp;

    while (iLow <= iHigh ) {

        iMid = (iLow + iHigh ) / 2;

        iCmp = _wcsicmp( aPszPtrs[iMid], pszNameToFind );

        if ( iCmp == 0 )
            return TRUE;
        else if ( iCmp < 0 )
            iLow = iMid + 1;
        else
            iHigh = iMid - 1;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\srvrpcp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    srvrpcp.h

Abstract:

    This module defines private APIs called from the RPC interfaces on server
    site.

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

    jinhuang 26-Jan-1998   splitted for client-server

--*/

#ifndef _srvrpcp_
#define _srvrpcp_

#ifdef __cplusplus
extern "C" {
#endif

typedef SCESTATUS (WINAPI *PFSCEINFWRITEINFO)(LPCTSTR, AREA_INFORMATION, PSCE_PROFILE_INFO, PSCE_ERROR_LOG_INFO *);
typedef SCESTATUS (WINAPI *PFSCEGETINFO)(PVOID, SCETYPE, AREA_INFORMATION, PSCE_PROFILE_INFO *, PSCE_ERROR_LOG_INFO *);

#define SCEPOL_SAVE_BUFFER      0x1
#define SCEPOL_SAVE_DB          0x2
#define SCEPOL_SYSTEM_SETTINGS  0x4

//
// svcsrv.cpp
//

SCESTATUS
SceSvcpUpdateInfo(
    IN PSCECONTEXT                  Context,
    IN PCWSTR                       ServiceName,
    IN PSCESVC_CONFIGURATION_INFO   Info
    );

SCESTATUS
SceSvcpQueryInfo(
    IN PSCECONTEXT                  Context,
    IN SCESVC_INFO_TYPE             SceSvcType,
    IN PCWSTR                       ServiceName,
    IN PWSTR                        Prefix OPTIONAL,
    IN BOOL                         bExact,
    OUT PVOID                       *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT    psceEnumHandle
    );

SCESTATUS
SceSvcpSetInfo(
    IN PSCECONTEXT  Context,
    IN SCESVC_INFO_TYPE SceSvcType,
    IN PCWSTR           ServiceName,
    IN PWSTR            Prefix OPTIONAL,
    IN BOOL             bExact,
    IN LONG             GpoID,
    IN PVOID            pvInfo OPTIONAL
    );

//
// setupsrv.cpp
//

DWORD
ScepSetupUpdateObject(
    IN PSCECONTEXT Context,
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN UINT nFlag,
    IN PWSTR SDText
    );

DWORD
ScepSetupMoveFile(
    IN PSCECONTEXT Context,
    PWSTR OldName,
    PWSTR NewName OPTIONAL,
    PWSTR SDText OPTIONAL
    );

//
// pfget.cpp
//
SCESTATUS
ScepGetDatabaseInfo(
    IN  PSCECONTEXT     Context,
    IN  SCETYPE             ProfileType,
    IN  AREA_INFORMATION    Area,
    IN  DWORD               dwAccountFormat,
    OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    IN  OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetObjectChildren(
    IN PSCECONTEXT Context,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    IN SCE_SUBOBJECT_TYPE Option,
    OUT PVOID *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
ScepGetObjectSecurity(
    IN PSCECONTEXT Context,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    OUT PSCE_OBJECT_SECURITY *ObjSecurity
    );

//
// ScepCopyObjects is called for each area
// within the RPC interface SceRpcCopyObjects
// for system service or security policy area
// attchments needs to be considered
//

SCESTATUS
ScepGetAnalysisSummary(
    IN PSCECONTEXT Context,
    IN AREA_INFORMATION Area,
    OUT PDWORD pCount
    );

//
// server.cpp
//

SCESTATUS
ScepOpenDatabase(
    IN PCWSTR DatabaseName,
    IN DWORD OpenOption,
    IN SCEJET_OPEN_TYPE OpenType,
    OUT PSCECONTEXT *pContext
    );

SCESTATUS
ScepCloseDatabase(
    IN PSCECONTEXT Context
    );

//
// SceJetGetDescription, SceJetGetTimeStamp
// SceJetStartTransaction, SceJetCommitTransaction, SceJetRollback,
// RtlGetNtProductType (for SceRpcGetServerProductType)
// are called within the RPC interfaces directly
//

//
// config.c
//

SCESTATUS
ScepConfigureSystem(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN DWORD ConfigOptions,
    IN BOOL bAdminLogon,
    IN AREA_INFORMATION Area,
    OUT PDWORD pdWarning OPTIONAL
    );

//
// analyze.c
//

SCESTATUS
ScepAnalyzeSystem(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN DWORD AnalyzeOptions,
    IN BOOL bAdminLogon,
    IN AREA_INFORMATION Area,
    IN PDWORD pdWarning OPTIONAL,
    IN PWSTR InfRollback OPTIONAL
    );

SCESTATUS
ScepAnalyzeSystemAccess(
    IN PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN DWORD dwSaveOption,
    OUT BOOL *pbChanged,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog
    );

//
// editsave.c
//

SCESTATUS
ScepUpdateDatabaseInfo(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo
    );

SCESTATUS
ScepUpdateLocalTable(
    IN PSCECONTEXT       hProfile,
    IN AREA_INFORMATION  Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD             dwMode
    );

SCESTATUS
ScepUpdateObjectInfo(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN BYTE ConfigStatus,
    IN BOOL  IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    );

//
// polsrv.cpp
//
DWORD
ScepNotifyGetChangedPolicies(
    IN SECURITY_DB_TYPE DbType,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN PSID ObjectSid OPTIONAL,
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN BOOL bSaveToLocal,
    IN DWORD ExplicitLowRight,
    IN DWORD ExplicitHighRight,
    OUT BOOL *pbChanged
    );

DWORD
ScepNotifySaveChangedPolicies(
    IN PSCECONTEXT hProfile,
    IN SECURITY_DB_TYPE DbType,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pMergedInfo OPTIONAL
    );

#define SCEGPO_INSETUP_NT4          1
#define SCEGPO_INSETUP_NT5          2

DWORD
ScepNotifyGetDefaultGPOTemplateName(
    UNICODE_STRING DnsDomainName,
    IN BOOL bDomainPolicy,
    IN DWORD dwInSetup,
    OUT LPTSTR *pTemplateName
    );

DWORD
ScepNotifySaveNotifications(
    IN PWSTR TemplateName,
    IN SECURITY_DB_TYPE  DbType,
    IN SECURITY_DB_OBJECT_TYPE  ObjectType,
    IN SECURITY_DB_DELTA_TYPE  DeltaType,
    IN PSID ObjectSid OPTIONAL
    );

DWORD
ScepNotifyUpdateGPOVersion(
    IN PWSTR GpoTemplateName,
    IN BOOL bDomainPolicy
    );

//
// analyze.cpp
//
SCESTATUS
ScepGetSystemSecurity(
    IN AREA_INFORMATION Area,
    IN DWORD Options,
    OUT PSCE_PROFILE_INFO *ppInfo,
    OUT PSCE_ERROR_LOG_INFO *pErrLog
    );

//
// config.cpp
//
SCESTATUS
ScepSetSystemSecurity(
    IN AREA_INFORMATION Area,
    IN DWORD ConfigOptions,
    IN PSCE_PROFILE_INFO pInfo,
    OUT PSCE_ERROR_LOG_INFO *pErrLog
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\tree.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tree.cpp

Abstract:

    SCE Engine security inheritance and propagation APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997 created

--*/
#include "serverp.h"
#include "srvutil.h"
#include <io.h>

BOOL    gbQueriedIfSystemContext = FALSE;
BOOL    gbIsSystemContext = FALSE;

#ifdef SCE_DBG
DWORD    gDbgNumPushed = 0;
DWORD    gDbgNumPopped = 0;
#endif

#if _WIN32_WINNT==0x0400
#include "dsrights.h"
#endif

#pragma hdrstop
#define SCETREE_QUERY_SD    1

#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )


#define SCEP_IGNORE_SOME_ERRORS(ErrorCode)  ErrorCode == ERROR_FILE_NOT_FOUND ||\
                                            ErrorCode == ERROR_PATH_NOT_FOUND ||\
                                            ErrorCode == ERROR_ACCESS_DENIED ||\
                                            ErrorCode == ERROR_SHARING_VIOLATION ||\
                                            ErrorCode == ERROR_INVALID_OWNER ||\
                                            ErrorCode == ERROR_INVALID_PRIMARY_GROUP ||\
                                            ErrorCode == ERROR_INVALID_HANDLE ||\
                                            ErrorCode == ERROR_INVALID_SECURITY_DESCR ||\
                                            ErrorCode == ERROR_CANT_ACCESS_FILE


DWORD
AccRewriteSetNamedRights(
    IN     LPWSTR               pObjectName,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN     BOOL                 bSkipInheritanceComputation
    );

SCESTATUS
ScepCreateObjectNode(
    IN PWSTR Buffer,
    IN WCHAR Delim,
    IN PSCE_OBJECT_TREE *ParentNode,
    OUT PSCE_OBJECT_CHILD_LIST *NewNode
    );

DWORD
ScepDoesObjectHasChildren(
    IN SE_OBJECT_TYPE ObjectType,
    IN PWSTR ObjectName,
    OUT PBOOL pbHasChildren
    );

DWORD
ScepAddAutoInheritRequest(
    IN OUT PSECURITY_DESCRIPTOR pSD,
    IN OUT SECURITY_INFORMATION *pSeInfo
    );

DWORD
ScepSetSecurityOverwriteExplicit(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

DWORD
ScepConfigureOneSubTreeFile(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOL BackSlashExist
    );

DWORD
ScepConfigureOneSubTreeKey(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

typedef struct _SCEP_STACK_NODE_ {
    PWSTR   Buffer;
    PSECURITY_DESCRIPTOR pObjectSecurity;
    struct _SCEP_STACK_NODE_    *Next;
} SCEP_STACK_NODE, *PSCEP_STACK_NODE;

DWORD
ScepStackNodePush(
    IN PSCEP_STACK_NODE    *ppStackHead,
    IN PWSTR   pszObjectName,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

VOID
ScepStackNodePop(
    IN OUT PSCEP_STACK_NODE    *ppStackHead,
    IN OUT PWSTR   *ppszObjectName,
    IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

VOID
ScepFreeStack(
    IN PSCEP_STACK_NODE    *ppStackHead
    );

VOID
ScepDumpStack(
    IN PSCEP_STACK_NODE    *ppStackHead
    );

SCESTATUS
ScepBuildObjectTree(
    IN OUT PSCE_OBJECT_TREE *ParentNode,
    IN OUT PSCE_OBJECT_CHILD_LIST *ChildHead,
    IN ULONG Level,
    IN WCHAR Delim,
    IN PCWSTR ObjectFullName,
    IN BOOL IsContainer,
    IN BYTE Status,
    IN PSECURITY_DESCRIPTOR pInfSecurityDescriptor,
    IN SECURITY_INFORMATION InfSeInfo
    )
/* ++
Routine Description:

    This routine adds the ObjectFullName to the tree. When this routine is
    first called from outside, the root of the tree is passed in as *SiblingHead,
    and the ParentNode is NULL. Then the routine parses the ObjectFullName for
    each level and adds the node if it does not exist. For example:

                           root

        level 1             c: ---------> d:--->...
                           /              /
        level 2        winnt->NTLDR->... "Program Files"->...
                       /
        level 3 system32->system->...

Arguments:

    ParentNode - The parent node pointer

    SiblingHead - The sibling head pointer for this level

    Level       - The level (1,2,3...)

    Delim - The deliminator to separate each level in the full name component
            Currently '\' is used for file and registry objects, and '/' is used
            for acitve directory objects.

    ObjectFullName - Full path name of the object (file, registry)

    Status - The configuration status
                    SCE_STATUS_CHECK (with AUTO_INHERIT)
                    SCE_STATUS_NO_AUTO_INHERIT
                    SCE_STATUS_IGNORE
                    SCE_STATUS_OVERWRITE

    pInfSecurityDescriptor - The security descriptor set in the INF file

    InfSeInfo - The security information set in the INF file

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_NOT_ENOUGH_RESOURCE


-- */
{
    SCESTATUS                rc;
    TCHAR                   *Buffer = NULL;
    PSCE_OBJECT_CHILD_LIST  NewNode=NULL;
    PSCE_OBJECT_CHILD_LIST  PrevSib=NULL;
    PSCE_OBJECT_TREE        ThisNode=NULL;
    INT                     Result;
    BOOL                    LastOne=FALSE;
    DWORD                   dwObjectFullNameLen = 0;

    //
    // address for ParentNode can be empty( the root )
    // but address for the first node of the level cannot be empty.
    //
    if ( ChildHead == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // find the object name for the level (from ObjectFullName)
    // e.g., if ObjectFullName is c:\winnt\system32 then
    // level 1 name is c:, level 2 name is winnt, level 3 name is system32
    //
    dwObjectFullNameLen = wcslen(ObjectFullName);
    Buffer = (TCHAR *)LocalAlloc(LMEM_ZEROINIT, 
                                 sizeof(TCHAR) * (dwObjectFullNameLen + 1));

    if (NULL == Buffer) {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        goto Done;
    }

    memset(Buffer, '\0', dwObjectFullNameLen * sizeof(TCHAR));
    
    rc = ScepGetNameInLevel(ObjectFullName,
                           Level,
                           Delim,
                           Buffer,
                           &LastOne);

    if ( rc != SCESTATUS_SUCCESS )
        goto Done;

    if ( *ChildHead == NULL ) {
        //
        // This is the first node in this level
        // Create the node and assign it to the ChildHead
        //
        rc = ScepCreateObjectNode(
                        Buffer,
                        Delim,
                        ParentNode,
                        &NewNode
                        );

        if ( rc != SCESTATUS_SUCCESS)
            goto Done;

        *ChildHead = NewNode;

        //
        // Establish the link if there is a parent
        //
        if ( ParentNode != NULL )
            if ( *ParentNode != NULL )
                (*ParentNode)->ChildList = NewNode;

        ThisNode = NewNode->Node;

    } else {
        //
        // There are existing nodes. Search all siblings
        // All siblings are stored in alphabetic order.
        //
        PSCE_OBJECT_CHILD_LIST pTemp;

        for ( pTemp = *ChildHead, PrevSib = NULL;
              pTemp != NULL;
              pTemp = pTemp->Next) {
            //
            // Compare the node's object name with the current object name
            //
            Result = _wcsicmp(pTemp->Node->Name, Buffer);
            //
            // if the node's object name is equal to (find it) or greater
            // than (insert the node) the current object name, then stop
            //
            if ( Result >= 0 ) {
                break;
            }
            PrevSib = pTemp;
        }

        if ( pTemp == NULL ) {
            //
            // Not exist. Append the new node
            //
            rc = ScepCreateObjectNode(
                            Buffer,
                            Delim,
                            ParentNode,
                            &NewNode
                            );

            if ( rc != SCESTATUS_SUCCESS)
                goto Done;

            if ( PrevSib != NULL )
                PrevSib->Next = NewNode;
            else {
                //
                // this is the first one in the level
                //
                (*ChildHead)->Next = NewNode;
            }
            ThisNode = NewNode->Node;

        } else {
            //
            // either find it (i=0) or need to insert between PrevSib and ThisNode
            //
            if ( Result > 0 ) {
                //
                // insert the node
                //
                rc = ScepCreateObjectNode(
                                Buffer,
                                Delim,
                                ParentNode,
                                &NewNode
                                );

                if ( rc != SCESTATUS_SUCCESS)
                    goto Done;

                NewNode->Next = pTemp;
                if ( PrevSib != NULL )
                    PrevSib->Next = NewNode;
                else {
                    //
                    // insert before SiblingHead
                    //
                    *ChildHead = NewNode;
                    if ( ParentNode != NULL )
                        if ( *ParentNode != NULL )
                            (*ParentNode)->ChildList = NewNode;
                }

                ThisNode = NewNode->Node;

            } else {
                ThisNode = pTemp->Node;
            }
        }
    }

    if ( LastOne ) {
        //
        // Assign Inf security information to this node
        //
        ThisNode->pSecurityDescriptor = pInfSecurityDescriptor;
        ThisNode->SeInfo = InfSeInfo;
        ThisNode->Status = Status;
        ThisNode->IsContainer = IsContainer;

    } else {
        //
        // process next level recursively
        //
        rc = ScepBuildObjectTree(&ThisNode,
                                &(ThisNode->ChildList),
                                Level+1,
                                Delim,
                                ObjectFullName,
                                IsContainer,
                                Status,
                                pInfSecurityDescriptor,
                                InfSeInfo);
    }

Done:

    if (Buffer) {
        LocalFree(Buffer);
    }
    
    return(rc);

}


SCESTATUS
ScepCreateObjectNode(
    IN PWSTR Buffer,
    IN WCHAR Delim,
    IN PSCE_OBJECT_TREE *ParentNode,
    OUT PSCE_OBJECT_CHILD_LIST *NewNode
    )
/* ++
Routine Description:

    This routine allocates memory for a new node in the tree. The ParentNode
    is used to determine the full object name and link the new node (if not NULL)

Arguments:

    Buffer - The component name of a object

    Delim - The deliminator to separate different levels in the full name.

    ParentNode - Pointer of the parent node of this new node

    NewNode - New created node

Return value:

    SCESTATUS

-- */
{
    DWORD Len;

    if (NewNode == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // allocate buffer for the node
    //
    *NewNode = (PSCE_OBJECT_CHILD_LIST)ScepAlloc(LPTR, sizeof(SCE_OBJECT_CHILD_LIST));
    if ( *NewNode == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    PSCE_OBJECT_TREE Node = (PSCE_OBJECT_TREE)ScepAlloc((UINT)0, sizeof(SCE_OBJECT_TREE));

    if ( Node == NULL ) {
        ScepFree(*NewNode);
        *NewNode = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // allocate buffer for the object name
    //
    Len = wcslen(Buffer);

    Node->Name = (PWSTR)ScepAlloc((UINT)0,
                                   (Len+1) * sizeof(TCHAR));
    if ( Node->Name == NULL ) {
        ScepFree(Node);
        ScepFree(*NewNode);
        *NewNode = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    if ( ParentNode != NULL &&
         *ParentNode != NULL ) {
        Len += wcslen((*ParentNode)->ObjectFullName)+1;
        ++((*ParentNode)->dwSize_aChildNames);
    // Reserve a space for "\" for the root dir c:\ .
    } else if ( Buffer[1] == L':' ) {
        Len++;
    }

    Node->ObjectFullName = (PWSTR)ScepAlloc( LMEM_ZEROINIT, (Len+1)*sizeof(TCHAR));

    if ( Node->ObjectFullName == NULL ) {
        ScepFree(Node->Name );
        ScepFree(Node);
        ScepFree( *NewNode );
        *NewNode = NULL;
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    //
    // initialize
    //
    wcscpy(Node->Name, Buffer);
    Node->ChildList = NULL;
    Node->pSecurityDescriptor = NULL;
    Node->pApplySecurityDescriptor = NULL;
    Node->SeInfo = 0;
    Node->IsContainer = TRUE;
    Node->aChildNames = NULL;
    Node->dwSize_aChildNames = 0;

    if ( ParentNode != NULL &&
         *ParentNode != NULL ) {
        //
        // link to parent, use parent's status for this one
        //
        Node->Parent = *ParentNode;
        swprintf(Node->ObjectFullName,
                 L"%s%c%s",
                 (*ParentNode)->ObjectFullName,
                 Delim,
                 Buffer);
        Node->Status = (*ParentNode)->Status;
    } else {
        //
        // this is the first node.
        //
        Node->Parent = NULL;
        wcscpy(Node->ObjectFullName, Buffer);
        Node->Status = SCE_STATUS_CHECK;
    }

    (*NewNode)->Node = Node;

    return(SCESTATUS_SUCCESS);

}


SCESTATUS
ScepCalculateSecurityToApply(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
/* ++
Routine Description:

    This routine walks through the security tree to determine security
    descriptor for each node. It calls RtlNewSecurityObject, passing a
    parent node's SD and current node's SD specified in the INF file.
    The output SD from that API is the security descriptor to set to the
    current object.

Arguments:

    ThisNode - The current object's node

    ObjectType - The object's type
                     SE_FILE_OBJECT
                     SE_REGISTRY_KEY

    Token - The thread/process token of the calling client

    GenericMapping - Generic access map table

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_OTHER_ERROR (see log for detail error)

-- */
{
    SCESTATUS               rc=SCESTATUS_SUCCESS;
    PSECURITY_DESCRIPTOR    ParentSD=NULL;
    SECURITY_INFORMATION    SeInfoGet;
    DWORD                   Win32rc;
    intptr_t                    hFile;
    struct _wfinddata_t     *pFileInfo=NULL;
    DWORD   dwChildIndex = 0;



    if ( ThisNode == NULL )
        return(SCESTATUS_SUCCESS);

#ifdef SCE_DBG
    wprintf(L"%s\n", ThisNode->ObjectFullName);
#endif
    //
    // if IGNORE is set, skip this node too
    //
    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT &&
         ThisNode->Status != SCE_STATUS_OVERWRITE )
        goto Done;

    if ( ThisNode->dwSize_aChildNames != 0) {
        ThisNode->aChildNames = (PWSTR *) LocalAlloc( LMEM_ZEROINIT,
                                                     (sizeof(PWSTR) * ThisNode->dwSize_aChildNames));

        if ( ThisNode->aChildNames == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            goto Done;
        }
    }


    if ( ThisNode->Parent == NULL ) {

        //
        // this is the first node
        // should always use Rtl routine to compute security descriptor
        // so Creator Owner ace is translated properly.
        //

        if ( ThisNode->pSecurityDescriptor ) {
            Win32rc = ScepGetNewSecurity(
                                ThisNode->ObjectFullName,
                                NULL, // parent's SD
                                ThisNode->pSecurityDescriptor,
                                0,    // does not query current object SD
                                (BOOLEAN)(ThisNode->IsContainer),
                                ThisNode->SeInfo,
                                ObjectType,
                                Token,
                                GenericMapping,
                                &(ThisNode->pApplySecurityDescriptor)
                                );
            if ( Win32rc != NO_ERROR ) {
                ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_BUILD_SD,
                             ThisNode->ObjectFullName );
                rc = ScepDosErrorToSceStatus(Win32rc);
                goto Done;
            }

        } else {
            //
            // no explicit security specified for this node
            //
            ThisNode->pApplySecurityDescriptor = NULL;
        }

        goto ProcChild;
    }

    //
    // process children nodes
    //
    if ( ThisNode->pSecurityDescriptor != NULL ||
         ThisNode->Parent->pApplySecurityDescriptor != NULL ) {

        if ( ObjectType == SE_FILE_OBJECT && NULL == ThisNode->ChildList ) {
            //
            // detect if this is a file (non-container object)
            //
            pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
            if ( pFileInfo == NULL ) {

                //
                // out of memory, treat it as a container for now and
                // will error out later.
                //

                ThisNode->IsContainer = TRUE;

            } else {

                hFile = _wfindfirst(ThisNode->ObjectFullName, pFileInfo);
                ThisNode->IsContainer = FALSE;
                if ( hFile != -1 ) {
                    _findclose(hFile);
                    if ( pFileInfo->attrib & _A_SUBDIR ) {
                        ThisNode->IsContainer = TRUE;
                    }
                }

                ScepFree(pFileInfo);
                pFileInfo = NULL;
            }

        } else {

            ThisNode->IsContainer = TRUE;
        }

        //
        // even if the security descriptor is protected,
        // still need to call ScepNewSecurity to get CREATOR OWNER ace
        // translated correctly.
        //

        //
        // if this is the first explicit node in this branch,
        // the pApplySecurityDescriptor of the parent must be NULL.
        //

        if ( ThisNode->Parent->pApplySecurityDescriptor == NULL ) {

            //
            // yes, this is the first explicit node.
            // get the current system's setting on the parent node
            // have to use Win32 api because it will compute all inherited
            // security information from all parents automatically
            //

            SeInfoGet = 0;
            if ( ThisNode->SeInfo & DACL_SECURITY_INFORMATION )
                SeInfoGet |= DACL_SECURITY_INFORMATION;

            if ( ThisNode->SeInfo & SACL_SECURITY_INFORMATION )
                SeInfoGet |= SACL_SECURITY_INFORMATION;

            Win32rc = GetNamedSecurityInfo(
                                ThisNode->Parent->ObjectFullName,
                                ObjectType,
                                SeInfoGet,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &ParentSD
                                );
/*
            Win32rc = ScepGetNamedSecurityInfo(
                        ThisNode->Parent->ObjectFullName,
                        ObjectType,
                        SeInfoGet,
                        &ParentSD
                        );
*/
            if ( Win32rc != NO_ERROR &&
                Win32rc != ERROR_FILE_NOT_FOUND &&
                Win32rc != ERROR_PATH_NOT_FOUND &&
                Win32rc != ERROR_ACCESS_DENIED &&
                Win32rc != ERROR_CANT_ACCESS_FILE &&
                Win32rc != ERROR_SHARING_VIOLATION ) {

                ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_QUERY_SECURITY,
                             ThisNode->Parent->ObjectFullName );
                rc = ScepDosErrorToSceStatus(Win32rc);
                goto Done;
            }

        } else {
            ParentSD = ThisNode->Parent->pApplySecurityDescriptor;
            //
            // owner/group information are not inheritable
            //
            if ( ThisNode->Parent->SeInfo & DACL_SECURITY_INFORMATION )
                ThisNode->SeInfo |= DACL_SECURITY_INFORMATION;
            if ( ThisNode->Parent->SeInfo & SACL_SECURITY_INFORMATION )
                ThisNode->SeInfo |= SACL_SECURITY_INFORMATION;
        }

        //
        // compute the new security descriptor with inherited aces from the parentSD
        // if the status is SCE_STATUS_CHECK (auto inherit), need to query the current
        // object's security descriptor if no explicit SD is specified
        // (ThisNode->pSecurityDescriptor is NULL)
        //

        Win32rc = ScepGetNewSecurity(
                        ThisNode->ObjectFullName,
                        ParentSD,
                        ThisNode->pSecurityDescriptor,
                        (BYTE)(( ThisNode->Status == SCE_STATUS_CHECK ) ? SCETREE_QUERY_SD : 0),
                        (BOOLEAN)(ThisNode->IsContainer),
                        ThisNode->SeInfo,
                        ObjectType,
                        Token,
                        GenericMapping,
                        &(ThisNode->pApplySecurityDescriptor)
                        );

        if ( ParentSD &&
             ParentSD != ThisNode->Parent->pApplySecurityDescriptor ) {
            //
            // free the parent security descriptor if it's allocated here
            //
            LocalFree(ParentSD);
        }

        if ( ERROR_SUCCESS == Win32rc ||
             ERROR_FILE_NOT_FOUND == Win32rc ||
             ERROR_PATH_NOT_FOUND == Win32rc ||
             ERROR_ACCESS_DENIED == Win32rc ||
             ERROR_CANT_ACCESS_FILE == Win32rc ||
             ERROR_SHARING_VIOLATION == Win32rc ) {

            rc = SCESTATUS_SUCCESS;
        } else {
            ScepLogOutput3(1, Win32rc,
                         SCEDLL_ERROR_BUILD_SD,
                         ThisNode->ObjectFullName
                         );
            rc = ScepDosErrorToSceStatus(Win32rc);
            goto Done;
        }

    }

ProcChild:
    //
    // then process left child
    //

    for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
          pTemp != NULL; pTemp = pTemp->Next ) {

        if ( pTemp->Node == NULL ) continue;

        ThisNode->aChildNames[dwChildIndex] = pTemp->Node->Name;

        ++dwChildIndex;

        rc = ScepCalculateSecurityToApply(
                        pTemp->Node,
                        ObjectType,
                        Token,
                        GenericMapping
                        );

        if ( rc != SCESTATUS_SUCCESS )
            goto Done;
    }

    //
    // in case there are lesser child names than initially calcluated
    //

    if (dwChildIndex < ThisNode->dwSize_aChildNames) {

        ThisNode->dwSize_aChildNames = dwChildIndex;

    }

Done:

    return(rc);

}


DWORD
ScepGetNewSecurity(
    IN LPTSTR ObjectName,
    IN PSECURITY_DESCRIPTOR pParentSD OPTIONAL,
    IN PSECURITY_DESCRIPTOR pObjectSD OPTIONAL,
    IN BYTE nFlag,
    IN BOOLEAN bIsContainer,
    IN SECURITY_INFORMATION SeInfo,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *ppNewSD
    )
/*
Routine Description:

    This routine will compute a security descriptor based on parent's security
    descriptor and the explicit security descriptor for the object. If no owner
    information is specified in the object's security descriptor, this routine
    will query the current owner of the object on the system so CREATOR_OWNER
    ace can be translated into the proper ace based on the owner.

Arguments:

    ObjectName - the object's full name

    pParentSD - optional security descriptor of the parent

    pObjectSD - optional explicit security descriptor of this object

    SeInfo    - security information contained in the object's SD

    bIsContainer - if the object is a container

    pNewSD - the new computed security descriptor address

Return Value:

    NTSTATUS of this operation
*/
{

    BOOL        bOwner;
    BOOLEAN     tFlag;
    BOOLEAN     aclPresent;
    PSID        pOwner=NULL;
    PACL        pDacl=NULL;
    PACL        pSacl=NULL;
    SECURITY_DESCRIPTOR     SD;
    PSECURITY_DESCRIPTOR    pCurrentSD=NULL;
    DWORD       Win32rc;
    NTSTATUS    NtStatus;
    SECURITY_DESCRIPTOR_CONTROL Control;
    ULONG Revision;

    if ( !ppNewSD ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // In case there is no RPC call causing us to enter here, there
    // is no impersonation happening and the current thread is already
    // running under Local System context in which case there is no
    // need to RevertToSelf() etc. as below.
    // This behavior happens when, for example, the server side itself
    // initiates a configuration
    //

    if ( !gbQueriedIfSystemContext ) {

        //
        // if any error happens when checking if running under system context,
        // continue - since there will be impersonation errors later on in
        // this routine
        //

        NtStatus = ScepIsSystemContext(
                                              Token,
                                              &gbIsSystemContext);

        if (ERROR_SUCCESS == RtlNtStatusToDosError(NtStatus)) {

            gbQueriedIfSystemContext = TRUE;

        }

    }

    if ( nFlag == SCETREE_QUERY_SD &&
         !pObjectSD ) {
        //
        // current object's security descriptor is used, for SeInfo | OWNER
        // NOTE: the inherited ace from pCurrentSD are not copied (which is correct).
        //

        Win32rc = GetNamedSecurityInfo(
                        ObjectName,
                        ObjectType,
                        SeInfo | OWNER_SECURITY_INFORMATION,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &pCurrentSD
                        );
/*
        Win32rc = ScepGetNamedSecurityInfo(
                        ObjectName,
                        ObjectType,
                        SeInfo | OWNER_SECURITY_INFORMATION,
                        &pCurrentSD
                        );
*/
        //
        // RtlNewSecurityObjectEx must be called on the process context (system)
        // because it will try to get process information inside the api.
        //

        if (!gbIsSystemContext) {

            RpcRevertToSelf();

        }

        if ( ERROR_SUCCESS == Win32rc ||
             ERROR_FILE_NOT_FOUND == Win32rc ||
             ERROR_PATH_NOT_FOUND == Win32rc ) {

            //
            // use the current SD to compute
            //
            NtStatus = RtlNewSecurityObjectEx(
                        pParentSD,
                        pCurrentSD,
                        ppNewSD,
                        NULL, // GUID
                        bIsContainer,
                        SEF_DACL_AUTO_INHERIT |
                        SEF_SACL_AUTO_INHERIT |
                        SEF_AVOID_OWNER_CHECK |
                        SEF_AVOID_PRIVILEGE_CHECK,
                        Token,
                        GenericMapping
                        );
            Win32rc = RtlNtStatusToDosError(NtStatus);
        }

        if ( pCurrentSD ) {
            ScepFree(pCurrentSD);
        }

    } else {

        //
        // RtlNewSecurityObjectEx must be called on the process context (system)
        // because it will try to get process information inside the api.
        //

        if (!gbIsSystemContext) {

            RpcRevertToSelf();

        }

        if ( pObjectSD ) {
            //
            // check if there is a owner
            //

            NtStatus = RtlGetOwnerSecurityDescriptor(
                              pObjectSD,
                              &pOwner,
                              &tFlag);
            if ( NT_SUCCESS(NtStatus) && pOwner && !tFlag ) {
                bOwner = TRUE;
            } else {
                bOwner = FALSE;
            }

        } else {
            //
            // no owner
            //
            bOwner = FALSE;
        }

        if ( !bOwner ) {
            //
            // query owner information only
            //
            Win32rc = ScepGetNamedSecurityInfo(
                            ObjectName,
                            ObjectType,
                            OWNER_SECURITY_INFORMATION,
                            &pCurrentSD
                            );

            if ( ERROR_SUCCESS == Win32rc ) {

                NtStatus = RtlGetOwnerSecurityDescriptor(
                                  pCurrentSD,
                                  &pOwner,
                                  &tFlag);
                Win32rc = RtlNtStatusToDosError(NtStatus);
            }

            if ( ERROR_FILE_NOT_FOUND == Win32rc ||
                 ERROR_PATH_NOT_FOUND == Win32rc ) {
                Win32rc = ERROR_SUCCESS;
            }

            if ( ERROR_SUCCESS == Win32rc ) {

                //
                // build a security descriptor to use
                //

                if ( SeInfo & DACL_SECURITY_INFORMATION &&
                     pObjectSD ) {

                    //
                    // Get DACL address
                    //
                    Win32rc = RtlNtStatusToDosError(
                                  RtlGetDaclSecurityDescriptor(
                                                pObjectSD,
                                                &aclPresent,
                                                &pDacl,
                                                &tFlag));
                    if (Win32rc == NO_ERROR && !aclPresent ) {
                        pDacl = NULL;
                    }
                }


                if ( ERROR_SUCCESS == Win32rc &&
                     (SeInfo & SACL_SECURITY_INFORMATION) &&
                     pObjectSD ) {

                    //
                    // Get SACL address
                    //

                    Win32rc = RtlNtStatusToDosError(
                                  RtlGetSaclSecurityDescriptor(
                                                pObjectSD,
                                                &aclPresent,
                                                &pSacl,
                                                &tFlag));
                    if ( Win32rc == NO_ERROR && !aclPresent ) {
                        pSacl = NULL;
                    }
                }

                if ( ERROR_SUCCESS == Win32rc ) {

                    //
                    // build an absolute security descriptor
                    //
                    NtStatus = RtlCreateSecurityDescriptor( &SD,
                                            SECURITY_DESCRIPTOR_REVISION );
                    if ( NT_SUCCESS(NtStatus) ) {

                        //
                        // set control field
                        //

                        if ( pObjectSD ) {

                            NtStatus = RtlGetControlSecurityDescriptor (
                                            pObjectSD,
                                            &Control,
                                            &Revision
                                            );
                            if ( NT_SUCCESS(NtStatus) ) {

                                Control &= SE_VALID_CONTROL_BITS;
                                NtStatus = RtlSetControlSecurityDescriptor (
                                                &SD,
                                                Control,
                                                Control
                                                );
                            }
                        }

                        //
                        // set owner first
                        //

                        if ( pOwner ) {
                            NtStatus = RtlSetOwnerSecurityDescriptor (
                                            &SD,
                                            pOwner,
                                            FALSE
                                            );
                        }

                        if ( NT_SUCCESS(NtStatus) ) {
                            //
                            // set DACL and SACL pointer to this SD
                            //
                            if ( SeInfo & DACL_SECURITY_INFORMATION && pDacl ) {

                                NtStatus = RtlSetDaclSecurityDescriptor (
                                                &SD,
                                                TRUE,
                                                pDacl,
                                                FALSE
                                                );
                            }

                            if ( NT_SUCCESS(NtStatus) &&
                                 (SeInfo & SACL_SECURITY_INFORMATION) && pSacl ) {

                                NtStatus = RtlSetSaclSecurityDescriptor (
                                                &SD,
                                                TRUE,
                                                pSacl,
                                                FALSE
                                                );
                            }
                        }

                        //
                        // now compute the new security descriptor
                        //

                        if ( NT_SUCCESS(NtStatus) ) {

                            NtStatus = RtlNewSecurityObjectEx(
                                        pParentSD,
                                        &SD,
                                        ppNewSD,
                                        NULL, // GUID
                                        bIsContainer,
                                        SEF_DACL_AUTO_INHERIT |
                                        SEF_SACL_AUTO_INHERIT |
                                        SEF_AVOID_OWNER_CHECK |
                                        SEF_AVOID_PRIVILEGE_CHECK,
                                        Token,
                                        GenericMapping
                                        );

                        }
                    }

                    Win32rc = RtlNtStatusToDosError(NtStatus);
                }
            }

            if ( pCurrentSD ) {
                //
                // this owner needs to be freed
                //
                LocalFree(pCurrentSD);
            }

        } else {

            //
            // there is a SD and there is a owner in it, just use it
            //
            NtStatus = RtlNewSecurityObjectEx(
                        pParentSD,
                        pObjectSD,
                        ppNewSD,
                        NULL, // GUID
                        bIsContainer,
                        SEF_DACL_AUTO_INHERIT |
                        SEF_SACL_AUTO_INHERIT |
                        SEF_AVOID_OWNER_CHECK |
                        SEF_AVOID_PRIVILEGE_CHECK,
                        Token,
                        GenericMapping
                        );

            Win32rc = RtlNtStatusToDosError(NtStatus);
        }

    }

    RPC_STATUS RpcStatus = RPC_S_OK;

    if (!gbIsSystemContext) {

        RpcStatus = RpcImpersonateClient( NULL );

    }

    if ( RpcStatus != RPC_S_OK ) {

        Win32rc = I_RpcMapWin32Status(RpcStatus);
    }

    if ( NO_ERROR != Win32rc &&
         *ppNewSD ) {
        //
        // free the buffer if there is an error
        //
        RtlDeleteSecurityObject(ppNewSD);
        *ppNewSD = NULL;
    }

    return(Win32rc);
}


DWORD
ScepAddAutoInheritRequest(
    IN OUT PSECURITY_DESCRIPTOR pSD,
    IN OUT SECURITY_INFORMATION *pSeInfo
    )
{

    SECURITY_DESCRIPTOR_CONTROL Control;
    SECURITY_DESCRIPTOR_CONTROL ToSet;
    ULONG Revision;
    NTSTATUS NtStatus;

    DWORD Win32rc=NO_ERROR;

    if ( !pSeInfo )
        return(ERROR_INVALID_PARAMETER);

    if ( pSD != NULL &&
         (*pSeInfo & DACL_SECURITY_INFORMATION ||
         *pSeInfo & SACL_SECURITY_INFORMATION) ) {

        NtStatus = RtlGetControlSecurityDescriptor (
                        pSD,
                        &Control,
                        &Revision
                        );
        if ( !NT_SUCCESS(NtStatus) ) {

            Win32rc = RtlNtStatusToDosError(NtStatus);

        } else {

            if ( !(Control & SE_DACL_PRESENT) )
                *pSeInfo &= ~DACL_SECURITY_INFORMATION;

            if ( !(Control & SE_SACL_PRESENT) )
                *pSeInfo &= ~SACL_SECURITY_INFORMATION;

            if ( *pSeInfo & (DACL_SECURITY_INFORMATION |
                             SACL_SECURITY_INFORMATION) ) {

                ToSet = 0;
                if ( *pSeInfo & DACL_SECURITY_INFORMATION ) {

                    ToSet |= (SE_DACL_AUTO_INHERIT_REQ |
                                SE_DACL_AUTO_INHERITED);
                }

                if ( *pSeInfo & SACL_SECURITY_INFORMATION) {

                    ToSet |= (SE_SACL_AUTO_INHERIT_REQ |
                                SE_SACL_AUTO_INHERITED);
                }

                if ( ToSet ) {
                    ((SECURITY_DESCRIPTOR *)pSD)->Control &= ~ToSet;
                    ((SECURITY_DESCRIPTOR *)pSD)->Control |= ToSet;
/*
                    NtStatus = RtlSetControlSecurityDescriptor (
                                pSD,
                                ToSet,
                                ToSet
                                );
                    Win32rc = RtlNtStatusToDosError(NtStatus);
*/
                }
            }

        }

    }

    return(Win32rc);
}



DWORD
ScepDoesObjectHasChildren(
    IN SE_OBJECT_TYPE ObjectType,
    IN PWSTR ObjectName,
    OUT PBOOL pbHasChildren
    )
{
    PWSTR Name=NULL;
    DWORD rc=NO_ERROR;
    DWORD Len;
    intptr_t            hFile;
    struct _wfinddata_t    FileInfo;
    HKEY hKey;
    DWORD cSubKeys=0;


    if ( ObjectName == NULL || pbHasChildren == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *pbHasChildren = TRUE;  // default

    if ( ObjectType == SE_FILE_OBJECT ) {
        //
        // detect if this is a container for file system
        //
        Len = wcslen(ObjectName);
        Name = (PWSTR)ScepAlloc(0, (Len+5)*sizeof(WCHAR) );

        if ( Name != NULL ) {

            swprintf(Name, L"%s\\*.*", ObjectName);
            Name[Len+3] = L'\0';

            hFile = _wfindfirst(Name, &FileInfo);

            if ( hFile == -1 ) {
                *pbHasChildren = FALSE;
            } else {
                _findclose(hFile);
            }

            ScepFree(Name);

        } else
            rc = ERROR_NOT_ENOUGH_MEMORY;

#ifdef _WIN64
    } else if ( ObjectType == SE_REGISTRY_KEY || ObjectType == SE_REGISTRY_WOW64_32KEY) {
#else
    } else if ( ObjectType == SE_REGISTRY_KEY) {
#endif

        rc = ScepOpenRegistryObject(
                    ObjectType,
                    (LPWSTR)ObjectName,
                    KEY_READ,
                    &hKey
                    );

        if ( rc == NO_ERROR ) {

            cSubKeys = 0;

            rc = RegQueryInfoKey (
                        hKey,
                        NULL,
                        NULL,
                        NULL,
                        &cSubKeys,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

            if ( rc == NO_ERROR && cSubKeys == 0 ) {
                *pbHasChildren = FALSE;
            }

            RegCloseKey(hKey);
        }
    }

    return(rc);
}


SCESTATUS
ScepConfigureObjectTree(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    IN DWORD ConfigOptions
    )
/* ++
Routine Description:

    This routine set security information to each node in the tree and objects of
    the container if SCE_STATUS_OVERWRITE is set.

Arguments:

    ThisNode - one node in the tree

    ObjectType - type of the object (SE_FILE_OBJECT, SE_REGISTRY_KEY)

    Token - The current process/thread's token (for computing new security descriptors)

    GenericMapping - The access mask mappings from generic access rights to object
                    specific access rights.

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_OTHER_ERROR (see the log file for detail error)

-- */
{
    // two error codes to distinguish between config status of "ThisNode" and "ThisNode's children"
    DWORD rcThisNodeOnly = ERROR_SUCCESS;
    DWORD rcThisNodeChildren = ERROR_SUCCESS;

    if ( ThisNode == NULL )
        return(SCESTATUS_SUCCESS);

    //
    // if IGNORE is set, skip this node, but post progress on it
    //
    if ( ThisNode->pSecurityDescriptor != NULL ) {
        //
        // notify the progress bar if there is any
        //
        switch(ObjectType) {
        case SE_FILE_OBJECT:
            ScepPostProgress(1, AREA_FILE_SECURITY, ThisNode->ObjectFullName);
            break;
        case SE_REGISTRY_KEY:
#ifdef _WIN64
        case SE_REGISTRY_WOW64_32KEY:
#endif
            ScepPostProgress(1, AREA_REGISTRY_SECURITY, ThisNode->ObjectFullName);
            break;
        default:
            ScepPostProgress(1, 0, ThisNode->ObjectFullName);
            break;
        }
    }

    SCESTATUS       rc=SCESTATUS_SUCCESS;
    DWORD           Win32Rc=ERROR_SUCCESS;

    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT &&
         ThisNode->Status != SCE_STATUS_OVERWRITE )
        goto SkipNode;

    if ( ThisNode->pSecurityDescriptor != NULL ) {

        ScepLogOutput3(2, 0, SCEDLL_SCP_CONFIGURE, ThisNode->ObjectFullName);
    }

    //
    // Process this node first
    // Note: we do not set NULL security descriptor
    //

    if ( ThisNode->pApplySecurityDescriptor != NULL ) {

        if ( ThisNode->pSecurityDescriptor == NULL ) {
            ScepLogOutput3(3, 0, SCEDLL_SCP_CONFIGURE, ThisNode->ObjectFullName);
        }

        BOOL            BackSlashExist=FALSE;

        if ( ThisNode->Status == SCE_STATUS_NO_AUTO_INHERIT ) {
            //
            // no auto inherit to children. Apply to this object only
            // this flag is removed since 2/20/1998
            //
            Win32Rc = ScepSetSecurityObjectOnly(
                        ThisNode->ObjectFullName,
                        ThisNode->SeInfo,
                        ThisNode->pApplySecurityDescriptor,
                        ObjectType,
                        NULL
                        );

            rcThisNodeOnly = Win32Rc;

        } else if ( ThisNode->ChildList == NULL &&
                    ThisNode->Status != SCE_STATUS_OVERWRITE ) {
            //
            // there is no children
            // apply security to everyone underneeth, using the win32 api.
            //
            Win32Rc = ScepDoesObjectHasChildren(ObjectType,
                                              ThisNode->ObjectFullName,
                                              &BackSlashExist // temp use
                                              );
            if ( Win32Rc == NO_ERROR ) {

                if ( BackSlashExist ) {
                    //
                    // this is a container which has children
                    //

                    //
                    // new marta API without considering parent
                    //
                    Win32Rc = AccRewriteSetNamedRights(
                                                      ThisNode->ObjectFullName,
                                                      ObjectType,
                                                      ThisNode->SeInfo,
                                                      ThisNode->pApplySecurityDescriptor,
                                                      TRUE    // bSkipInheritanceComputation
                                                      );
/*
                    Win32Rc = ScepSetSecurityWin32(
                            ThisNode->ObjectFullName,
                            ThisNode->SeInfo,
                            ThisNode->pApplySecurityDescriptor,
                            ObjectType
                            );
*/
                } else {
                    //
                    // no children
                    //
                    Win32Rc = ScepSetSecurityObjectOnly(
                                ThisNode->ObjectFullName,
                                ThisNode->SeInfo,
                                ThisNode->pApplySecurityDescriptor,
                                ObjectType,
                                NULL
                                );
                }

            } else {
                ScepLogOutput3(1, Win32Rc, SCEDLL_SAP_ERROR_ENUMERATE,
                             ThisNode->ObjectFullName);
            }

            rcThisNodeOnly = Win32Rc;

        } else {

            //
            // there is child(ren) in the tree, or OVERWRITE flag is set
            //


            Win32Rc = ScepDoesObjectHasChildren(ObjectType,
                                              ThisNode->ObjectFullName,
                                              &BackSlashExist // temp use
                                              );

            rcThisNodeOnly = Win32Rc;

            if ( Win32Rc != ERROR_SUCCESS ) {
                //
                // for registry keys, the above function could fail if the key does
                // not exist. Log the error in this case
                //
                ScepLogOutput3(1, Win32Rc, SCEDLL_SAP_ERROR_ENUMERATE,
                             ThisNode->ObjectFullName);

            }
            if ( Win32Rc == ERROR_SUCCESS && !BackSlashExist ) {
                //
                // no child exist
                //
                if (ThisNode->Status == SCE_STATUS_OVERWRITE ) {

                    //
                    // if OVERWRITE flag set and no children, set now (top-down)
                    // if OVERWRITE flag and has children then share logic with 0 mode, set later (bottom-up)
                    // maybe we can have all OVERWRITE mode go bottom-up if goto SkipNode is removed here
                    //

                    Win32Rc = ScepSetSecurityObjectOnly(
                                ThisNode->ObjectFullName,
                                ThisNode->SeInfo,
                                ThisNode->pApplySecurityDescriptor,
                                ObjectType,
                                &BackSlashExist
                                );

                    rcThisNodeOnly = rcThisNodeOnly == NO_ERROR ? Win32Rc: rcThisNodeOnly;

                }

                goto SkipNode;
            }

            if ( Win32Rc == ERROR_SUCCESS && BackSlashExist ) {

                //
                // set security for other files/keys under this directory
                //
                //
                // child exist, set child node first
                // set security for other files/keys under this directory
                //

                switch ( ObjectType ) {
                case SE_FILE_OBJECT:

                    //
                    // detect if there is a \ at the end
                    //
                    BackSlashExist = ScepLastBackSlash(ThisNode->ObjectFullName);

                    Win32Rc = ScepConfigureOneSubTreeFile(ThisNode,
                                                      ObjectType,
                                                      Token,
                                                      GenericMapping,
                                                      BackSlashExist
                                                      );
                    break;

                case SE_REGISTRY_KEY:
#ifdef _WIN64
                case SE_REGISTRY_WOW64_32KEY:
#endif

                    //
                    // process this key and any sub keys
                    //

                    Win32Rc = ScepConfigureOneSubTreeKey(ThisNode,
                                                ObjectType,
                                                Token,
                                                GenericMapping
                                               );
                    break;
                }


                //
                // this rc is the status for configuration of children of ThisNode
                //
                rcThisNodeChildren = Win32Rc;

            }
        }

        //
        // ignore some error codes and continue to configure other objects
        //
        if ( SCEP_IGNORE_SOME_ERRORS(Win32Rc) ) {

            gWarningCode = Win32Rc;
            rc = SCESTATUS_SUCCESS;
            goto SkipNode;
        }

        if ( Win32Rc != ERROR_SUCCESS ) {
            //
            // if security for this object was specified in the config template/database, log to RSOP status
            //

            if (ThisNode->pSecurityDescriptor && (ConfigOptions & SCE_RSOP_CALLBACK) ) {

                ScepRsopLog(ObjectType == SE_FILE_OBJECT ?
                            SCE_RSOP_FILE_SECURITY_INFO :
                            SCE_RSOP_REGISTRY_SECURITY_INFO,
                            rcThisNodeOnly,
                            ThisNode->ObjectFullName,0,0);

                if (rcThisNodeOnly == ERROR_SUCCESS && rcThisNodeChildren != ERROR_SUCCESS) {

                    ScepRsopLog(ObjectType == SE_FILE_OBJECT ?
                                (SCE_RSOP_FILE_SECURITY_INFO | SCE_RSOP_FILE_SECURITY_INFO_CHILD) :
                                (SCE_RSOP_REGISTRY_SECURITY_INFO | SCE_RSOP_REGISTRY_SECURITY_INFO_CHILD),
                                rcThisNodeChildren,
                                ThisNode->ObjectFullName,0,0);
                }

            }

            return(ScepDosErrorToSceStatus(Win32Rc));
        }

    }


    //
    // then process children
    //

    for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
          pTemp != NULL; pTemp = pTemp->Next ) {

        if ( pTemp->Node == NULL ) continue;

        rc = ScepConfigureObjectTree(
                                    pTemp->Node,
                                    ObjectType,
                                    Token,
                                    GenericMapping,
                                    ConfigOptions
                                    );
        Win32Rc = ScepSceStatusToDosError(rc);

        //
        // ignore some error codes and continue to configure other objects
        //
        if (  SCEP_IGNORE_SOME_ERRORS(Win32Rc) ) {

            gWarningCode = Win32Rc;
            Win32Rc = ERROR_SUCCESS;
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);

    }

    if ( ThisNode->pApplySecurityDescriptor != NULL &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT &&
         ( ThisNode->ChildList != NULL ||
           ThisNode->Status == SCE_STATUS_OVERWRITE ) ) {

        //
        // finally config the current node - (post order)
        //

        Win32Rc = ScepSetSecurityObjectOnly(
                ThisNode->ObjectFullName,
                ThisNode->SeInfo,
                ThisNode->pApplySecurityDescriptor,
                ObjectType,
                NULL
                );

        rc = ScepDosErrorToSceStatus(Win32Rc);

        rcThisNodeOnly = rcThisNodeOnly == NO_ERROR ? Win32Rc: rcThisNodeOnly;

        //
        // ignore the following error codes and continue to configure other objects
        //
        if ( SCEP_IGNORE_SOME_ERRORS(Win32Rc) ) {

            gWarningCode = Win32Rc;
            Win32Rc = ERROR_SUCCESS;
            rc = SCESTATUS_SUCCESS;
        }
    }



SkipNode:

    //
    // if security for this object was specified in the config template/database, log to RSOP status
    //

    if (ThisNode->pSecurityDescriptor && (ConfigOptions & SCE_RSOP_CALLBACK) ) {

        ScepRsopLog(ObjectType == SE_FILE_OBJECT ?
                    SCE_RSOP_FILE_SECURITY_INFO :
                    SCE_RSOP_REGISTRY_SECURITY_INFO,
                    rcThisNodeOnly,
                    ThisNode->ObjectFullName,0,0);

        if (rcThisNodeOnly == ERROR_SUCCESS && rcThisNodeChildren != ERROR_SUCCESS) {

            ScepRsopLog(ObjectType == SE_FILE_OBJECT ?
                        (SCE_RSOP_FILE_SECURITY_INFO | SCE_RSOP_FILE_SECURITY_INFO_CHILD) :
                        (SCE_RSOP_REGISTRY_SECURITY_INFO | SCE_RSOP_REGISTRY_SECURITY_INFO_CHILD),
                        rcThisNodeChildren,
                        ThisNode->ObjectFullName,0,0);
        }

    }

    return(rc);

}


DWORD
ScepConfigureOneSubTreeFile(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOL BackSlashExist
    )
{

    if ( NULL == ThisNode ) {
        return(ERROR_SUCCESS);
    }

    DWORD           BufSize;
    PWSTR           Buffer=NULL;

    //
    // find all files under this directory/file
    //

    BufSize = wcslen(ThisNode->ObjectFullName)+4;
    Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
    if ( Buffer == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if ( BackSlashExist ) {
        swprintf(Buffer, L"%s*.*", ThisNode->ObjectFullName);
    } else {
        swprintf(Buffer, L"%s\\*.*", ThisNode->ObjectFullName);
    }

    intptr_t            hFile;
    struct _wfinddata_t    *pFileInfo=NULL;

    //
    // allocate the find buffer
    //
    pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
    if ( pFileInfo == NULL ) {
        ScepFree(Buffer);
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    hFile = _wfindfirst(Buffer, pFileInfo);

    ScepFree(Buffer);
    Buffer = NULL;

    DWORD  Win32Rc = ERROR_SUCCESS;
    BOOL    bFilePresentInTree;

    if ( hFile != -1 ) {

        PSCE_OBJECT_CHILD_LIST pTemp;
        INT             i;
        DWORD           EnumRc;
        PSECURITY_DESCRIPTOR pChildrenSD=NULL;

        do {
            if ( pFileInfo->name[0] == L'.' && 
                 (pFileInfo->name[1] == L'\0' || (pFileInfo->name[1] == L'.' && pFileInfo->name[2] == L'\0')))
                continue;

            bFilePresentInTree = ScepBinarySearch(
                                                 ThisNode->aChildNames,
                                                 ThisNode->dwSize_aChildNames,
                                                 pFileInfo->name);

            if ( ! bFilePresentInTree ) {

                //
                // The name is not in the list, so set.
                // build the full name first
                //

                BufSize = wcslen(ThisNode->ObjectFullName)+wcslen(pFileInfo->name)+1;
                Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                if ( Buffer == NULL ) {
                    Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                if ( BackSlashExist ) {

                    swprintf(Buffer, L"%s%s", ThisNode->ObjectFullName, pFileInfo->name);
                } else {

                    swprintf(Buffer, L"%s\\%s", ThisNode->ObjectFullName, pFileInfo->name);
                }
                EnumRc = pFileInfo->attrib; // borrow this variable temperaorily

                ScepFree(pFileInfo);
                pFileInfo = NULL;


                //
                // compute the SDs for each individual object
                //
                Win32Rc = ScepGetNewSecurity(
                                    Buffer,
                                    ThisNode->pApplySecurityDescriptor, // parent's SD
                                    NULL,
                                    (BYTE)((ThisNode->Status != SCE_STATUS_OVERWRITE ) ? SCETREE_QUERY_SD : 0),
                                    (BOOLEAN)(EnumRc & _A_SUBDIR),
                                    ThisNode->SeInfo,
                                    ObjectType,
                                    Token,
                                    GenericMapping,
                                    &pChildrenSD
                                    );

                if (Win32Rc == ERROR_SHARING_VIOLATION ||
                    Win32Rc == ERROR_ACCESS_DENIED ||
                    Win32Rc == ERROR_CANT_ACCESS_FILE) {

                    ScepLogOutput3(1, Win32Rc, SCEDLL_ERROR_BUILD_SD, Buffer);
                }

                if ( Win32Rc == NO_ERROR ) {

                    if ( !(EnumRc & _A_SUBDIR) ) {

                        // this is a single file
                        //

                        Win32Rc = ScepSetSecurityObjectOnly(
                                    Buffer,
                                    (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                    (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                    pChildrenSD,
                                    ObjectType,
                                    NULL
                                    );

                    } else if ( ThisNode->Status == SCE_STATUS_OVERWRITE ) {

                        //
                        // enumerate all nodes under this one and "empty" explicit aces by
                        // calling NtSetSecurityInfo directly but please note
                        // Creator Owner Ace should be reserved
                        //

                        Win32Rc = ScepSetSecurityOverwriteExplicit(
                                    Buffer,
                                    (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                    (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                    pChildrenSD,
                                    ObjectType,
                                    Token,
                                    GenericMapping
                                    );
                    } else {
                        //
                        // new marta API without considering parent
                        //
                        Win32Rc = AccRewriteSetNamedRights(
                                                Buffer,
                                                ObjectType,
                                                ThisNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                                pChildrenSD,
                                                TRUE    // bSkipInheritanceComputation
                                                );
                        /*
                        Win32Rc = ScepSetSecurityWin32(
                                    Buffer,
                                    (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                    (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                    pChildrenSD,
                                    ObjectType
                                    );
                       */

                        if ( Win32Rc != ERROR_SUCCESS ) {
                            //
                            // something is wrong to set inheritance info, log it
                            // but still continue to the next one
                            //
                            gWarningCode = Win32Rc;

                            Win32Rc = NO_ERROR;

                        }
                    }

                }

                ScepFree(Buffer);
                Buffer = NULL;

                //
                // free the SD pointers allocated for this object
                //
                if ( pChildrenSD != NULL )
                    RtlDeleteSecurityObject( &pChildrenSD );

                pChildrenSD = NULL;

                if (Win32Rc == ERROR_FILE_NOT_FOUND ||
                    Win32Rc == ERROR_PATH_NOT_FOUND ||
                    Win32Rc == ERROR_SHARING_VIOLATION ||
                    Win32Rc == ERROR_ACCESS_DENIED ||
                    Win32Rc == ERROR_CANT_ACCESS_FILE ) {

                    gWarningCode = Win32Rc;

                    Win32Rc = NO_ERROR;
                } else if ( Win32Rc != ERROR_SUCCESS )
                    break;

                pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
                if ( pFileInfo == NULL ) {
                    Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

            }
        } while ( _wfindnext(hFile, pFileInfo) == 0 );

        _findclose(hFile);

        //
        // free memory if allocated
        //
        if ( pChildrenSD != NULL &&
             pChildrenSD != ThisNode->pApplySecurityDescriptor ) {

            RtlDeleteSecurityObject( &pChildrenSD );
            pChildrenSD = NULL;
        }

    }

    if ( pFileInfo != NULL ) {
        ScepFree(pFileInfo);
        pFileInfo = NULL;
    }

    if ( Buffer != NULL ) {
        ScepFree(Buffer);
        Buffer = NULL;
    }

    return(Win32Rc);
}


DWORD
ScepConfigureOneSubTreeKey(
    IN PSCE_OBJECT_TREE  ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
{

    if ( NULL == ThisNode ) {
        return(ERROR_SUCCESS);
    }

    HKEY            hKey=NULL;
    DWORD           Win32Rc;

    DWORD           SubKeyLen;
    PWSTR           Buffer1=NULL;

    //
    // open the key
    //

    Win32Rc = ScepOpenRegistryObject(
                ObjectType,
                ThisNode->ObjectFullName,
                KEY_READ,
                &hKey
                );

    if ( Win32Rc == ERROR_SUCCESS ) {

        SubKeyLen = 0;
        Win32Rc = RegQueryInfoKey (
                    hKey,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &SubKeyLen,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
    } else {
        ScepLogOutput3(1, Win32Rc, SCEDLL_ERROR_OPEN, ThisNode->ObjectFullName );
    }

    if ( Win32Rc == ERROR_SUCCESS ) {

        //
        // enumerate all subkeys of the key
        //
        Buffer1 = (PWSTR)ScepAlloc(0, (SubKeyLen+2)*sizeof(WCHAR));
        if ( Buffer1 == NULL ) {
            Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( Win32Rc == ERROR_SUCCESS ) {

        DWORD           index;
        DWORD           EnumRc;
        DWORD           BufSize;

        PSCE_OBJECT_CHILD_LIST pTemp;
        INT             i;
        PWSTR           Buffer=NULL;
        PSECURITY_DESCRIPTOR pChildrenSD=NULL;
        BOOL    bKeyPresentInTree;

        index = 0;

        do {

            BufSize = SubKeyLen+1;
            memset(Buffer1, L'\0', (SubKeyLen+2)*sizeof(WCHAR));

            EnumRc = RegEnumKeyEx(hKey,
                            index,
                            Buffer1,
                            &BufSize,
                            NULL,
                            NULL,
                            NULL,
                            NULL);

            if ( EnumRc == ERROR_SUCCESS ) {

                index++;
                //
                // find if the subkey is already in the tree
                // if it is in the tree, it will be processed later
                //

                bKeyPresentInTree = ScepBinarySearch(
                                                    ThisNode->aChildNames,
                                                    ThisNode->dwSize_aChildNames,
                                                    Buffer1);

                if ( ! bKeyPresentInTree ) {
                    //
                    // The name is not in the list, so set
                    // build the fullname first
                    //
                    BufSize += wcslen(ThisNode->ObjectFullName)+1;
                    Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                    if ( Buffer == NULL ) {
                        Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    swprintf(Buffer, L"%s\\%s", ThisNode->ObjectFullName, Buffer1);

                    ScepLogOutput3(3, 0, SCEDLL_SCP_CONFIGURE, Buffer);

                    //
                    // compute the SDs for each individual object
                    //
                    Win32Rc = ScepGetNewSecurity(
                                        Buffer,
                                        ThisNode->pApplySecurityDescriptor, // parent's SD
                                        NULL,
                                        (BYTE)((ThisNode->Status != SCE_STATUS_OVERWRITE ) ? SCETREE_QUERY_SD : 0),
                                        (BOOLEAN)TRUE,
                                        ThisNode->SeInfo,
                                        ObjectType,
                                        Token,
                                        GenericMapping,
                                        &pChildrenSD
                                        );

                    if (Win32Rc == ERROR_SHARING_VIOLATION ||
                        Win32Rc == ERROR_ACCESS_DENIED ||
                        Win32Rc == ERROR_CANT_ACCESS_FILE) {

                        ScepLogOutput3(1, Win32Rc, SCEDLL_ERROR_BUILD_SD, Buffer);
                    }

                    if ( Win32Rc == ERROR_SUCCESS ) {
                        if ( ThisNode->Status == SCE_STATUS_OVERWRITE ) {

                            //
                            // enumerate all nodes under this one and "empty" explicit aces by
                            // calling NtSetSecurityInfo directly
                            //

                            Win32Rc = ScepSetSecurityOverwriteExplicit(
                                        Buffer,
                                        (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                        (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                        pChildrenSD,
                                        ObjectType,
                                        Token,
                                        GenericMapping
                                        );
                        } else {

                            //
                            // new marta API without considering parent
                            //
                            Win32Rc = AccRewriteSetNamedRights(
                                                    Buffer,
                                                    ObjectType,
                                                    ThisNode->SeInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
                                                    pChildrenSD,
                                                    TRUE    // bSkipInheritanceComputation
                                                    );

                            /*
                            Win32Rc = ScepSetSecurityWin32(
                                        Buffer,
                                        (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                        (ThisNode->SeInfo & SACL_SECURITY_INFORMATION),
                                        pChildrenSD,  // ThisNode->pApplySecurityDescriptor, calculate autoinheritance
                                        ObjectType
                                        );
                            */

                            if ( Win32Rc != ERROR_SUCCESS ) {
                                //
                                // can't set inheritance to children, log it but continue
                                //
                                gWarningCode = Win32Rc;

                                Win32Rc = NO_ERROR;
                            }
                        }

                    }
                    if ( pChildrenSD != NULL ) {
                        RtlDeleteSecurityObject( &pChildrenSD );
                        pChildrenSD = NULL;
                    }

                    if ( Win32Rc == ERROR_FILE_NOT_FOUND ||
                         Win32Rc == ERROR_INVALID_HANDLE ||
                         Win32Rc == ERROR_PATH_NOT_FOUND ||
                         Win32Rc == ERROR_ACCESS_DENIED ||
                         Win32Rc == ERROR_CANT_ACCESS_FILE ||
                         Win32Rc == ERROR_SHARING_VIOLATION ) {

                        gWarningCode = Win32Rc;
                        Win32Rc = NO_ERROR;
                    }

                    if ( Win32Rc != ERROR_SUCCESS )
                        ScepLogOutput3(1, Win32Rc, SCEDLL_ERROR_SET_SECURITY, Buffer);

                    ScepFree(Buffer);
                    Buffer = NULL;

                    if ( Win32Rc != ERROR_SUCCESS )
                        break;
                }

            } else if ( EnumRc != ERROR_NO_MORE_ITEMS ) {
                break;
            }
        } while ( EnumRc != ERROR_NO_MORE_ITEMS );

        ScepFree(Buffer1);
        Buffer1 = NULL;

        if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {

            ScepLogOutput3(1, EnumRc, SCEDLL_SAP_ERROR_ENUMERATE,
                         ThisNode->ObjectFullName );
            if ( Win32Rc == ERROR_SUCCESS )
                Win32Rc = EnumRc;

        }

        //
        // free memory if allocated
        //
        if ( pChildrenSD != NULL &&
             pChildrenSD != ThisNode->pApplySecurityDescriptor ) {

            RtlDeleteSecurityObject( &pChildrenSD );
            pChildrenSD = NULL;
        }
        if ( Buffer != NULL ) {
            ScepFree(Buffer);
            Buffer = NULL;
        }

    }

    if ( hKey ) {
        RegCloseKey(hKey);
    }

    return(Win32Rc);

}


SCESTATUS
ScepFreeObject2Security(
    IN PSCE_OBJECT_CHILD_LIST  NodeList,
    IN BOOL bFreeComputedSDOnly
    )
/* ++
Routine Description:

    This routine frees memory allocated by the security object tree.

Arguments:

    ThisNode - one node in the tree

Return value:

    None

-- */
{
    NTSTATUS  NtStatus;
    SCESTATUS  rc;


    if ( NodeList == NULL )
        return(SCESTATUS_SUCCESS);

    PSCE_OBJECT_CHILD_LIST pTemp,pTemp1;
    PSCE_OBJECT_TREE ThisNode;

    //
    // free children first
    //
    pTemp = NodeList;

    while ( pTemp != NULL ) {
        if ( pTemp->Node ) {

            ThisNode = pTemp->Node;

            rc = ScepFreeObject2Security(ThisNode->ChildList, bFreeComputedSDOnly);
            //
            // both security descriptors need to be freed for SAP/SMP type
            //
            if ( ThisNode->pApplySecurityDescriptor != NULL &&
                 ThisNode->pApplySecurityDescriptor != ThisNode->pSecurityDescriptor ) {

                NtStatus = RtlDeleteSecurityObject(
                                &(ThisNode->pApplySecurityDescriptor)
                                );
                ThisNode->pApplySecurityDescriptor = NULL;
            }

            if (!bFreeComputedSDOnly) {

                if ( ThisNode->pSecurityDescriptor != NULL )
                    ScepFree(ThisNode->pSecurityDescriptor);

                if ( ThisNode->Name != NULL)
                    ScepFree(ThisNode->Name);

                if ( ThisNode->ObjectFullName != NULL )
                    ScepFree(ThisNode->ObjectFullName);

                if ( ThisNode->aChildNames != NULL ) {
                    LocalFree(ThisNode->aChildNames);
                }

                ScepFree(ThisNode);
            }

        }

        pTemp1 = pTemp;
        pTemp = pTemp->Next;

        if (!bFreeComputedSDOnly) {
            ScepFree(pTemp1);
        }
    }

    return(SCESTATUS_SUCCESS);
}


DWORD
ScepSetSecurityWin32(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType
    )
/* ++
Routine Description:

    This routine set security information to the object and inherited aces
    are set to the object's children by calling Win32 API SetNamedSecurityInfo


Arguments:

    ObjecName  - name of the object to set security to

    SeInfo     - Security information to set

    pSecurityDescriptor - the security descriptor

    ObjectType - type of the object
                      SE_FILE_OBJECT
                      SE_REGISTRY_KEY
                      SE_DS_OBJECT

Return value:

    Win32 error code

-- */
{

    if ( !ObjectName || !pSecurityDescriptor || SeInfo == 0 ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD       Win32rc = NO_ERROR;
    SECURITY_INFORMATION SeInfoSet;


    BOOLEAN     tFlag;
    BOOLEAN     aclPresent;
    PSID        pOwner=NULL;
    PSID        pGroup=NULL;
    PACL        pDacl=NULL;
    PACL        pSacl=NULL;
    SECURITY_DESCRIPTOR_CONTROL Control=0;

    if ( pSecurityDescriptor != NULL ) {

        RtlGetControlSecurityDescriptor (
                pSecurityDescriptor,
                &Control,
                &Win32rc  // temp use
                );
        //
        // Get Owner address
        // always get the owner in case take ownership occurs
        //
        Win32rc = RtlNtStatusToDosError(
                      RtlGetOwnerSecurityDescriptor(
                                pSecurityDescriptor,
                                &pOwner,
                                &tFlag));
#if 0
        //
        // Get Group address
        //

        if ( SeInfo & GROUP_SECURITY_INFORMATION ) {
            Win32rc = RtlNtStatusToDosError(
                         RtlGetGroupSecurityDescriptor(
                                 pSecurityDescriptor,
                                 &pGroup,
                                 &tFlag));
        }
#endif
        //
        // Get DACL address
        //

        if ( SeInfo & DACL_SECURITY_INFORMATION ) {
            Win32rc = RtlNtStatusToDosError(
                          RtlGetDaclSecurityDescriptor(
                                        pSecurityDescriptor,
                                        &aclPresent,
                                        &pDacl,
                                        &tFlag));
            if (Win32rc == NO_ERROR && !aclPresent )
                pDacl = NULL;
        }


        //
        // Get SACL address
        //

        if ( SeInfo & SACL_SECURITY_INFORMATION ) {
            Win32rc = RtlNtStatusToDosError(
                          RtlGetSaclSecurityDescriptor(
                                        pSecurityDescriptor,
                                        &aclPresent,
                                        &pSacl,
                                        &tFlag));
            if ( Win32rc == NO_ERROR && !aclPresent )
                pSacl = NULL;
        }
    }

    //
    // if error occurs for this one, do not set. return
    //

    if ( Win32rc != NO_ERROR ) {

        ScepLogOutput3(1, Win32rc, SCEDLL_INVALID_SECURITY, (PWSTR)ObjectName );
        return(Win32rc);
    }
    //
    // set permission
    //
#ifdef SCE_DBG
    printf("Calling SetNamedSecurityInfo:\n");
    ScepPrintSecurityDescriptor( pSecurityDescriptor, TRUE );
#endif
    //
    // should set owner/group separately from dacl/sacl
    // if access is denied, take ownership will occur.
    //

    if ( Win32rc != NO_ERROR ) {
        //
        // ignore the error code from setting owner/group
        //
        Win32rc = NO_ERROR;
    }

    //
    // set DACL/SACL
    //
    SeInfoSet = 0;

    if ( (SeInfo & DACL_SECURITY_INFORMATION) && pDacl ) {

        SeInfoSet |= DACL_SECURITY_INFORMATION;

        if ( Control & SE_DACL_PROTECTED ) {
            SeInfoSet |= PROTECTED_DACL_SECURITY_INFORMATION;
        }
    }

    if ( (SeInfo & SACL_SECURITY_INFORMATION) && pSacl ) {

        SeInfoSet |= SACL_SECURITY_INFORMATION;

        if ( Control & SE_SACL_PROTECTED ) {
            SeInfoSet |= PROTECTED_SACL_SECURITY_INFORMATION;
        }
    }

    Win32rc = SetNamedSecurityInfo(
                        (LPWSTR)ObjectName,
                        ObjectType,
                        SeInfoSet,
                        NULL,
                        NULL,
                        pDacl,
                        pSacl
                        );

    if ( (Win32rc == ERROR_ACCESS_DENIED || Win32rc == ERROR_CANT_ACCESS_FILE) && NULL != AdminsSid ) {
        //
        // access denied, take ownership and then set
        // should backup the old owner first
        // NOTE: the old owner of this object is already stored in pOwner
        // (pSecurityDescritor) which is queried from ScepGetNewSecurity(...
        //

        ScepLogOutput3(3,0, SCEDLL_SCP_TAKE_OWNER, (LPWSTR)ObjectName);

        Win32rc = SetNamedSecurityInfo(
                            (LPWSTR)ObjectName,
                            ObjectType,
                            OWNER_SECURITY_INFORMATION,
                            AdminsSid,
                            NULL,
                            NULL,
                            NULL
                            );

        if ( Win32rc == NO_ERROR ) {
            //
            // ownership is changed, then set security again
            //
            Win32rc = SetNamedSecurityInfo(
                                (LPWSTR)ObjectName,
                                ObjectType,
                                SeInfoSet,
                                NULL,
                                NULL,
                                pDacl,
                                pSacl
                                );

            //
            // set the old owner back (later)
            //
        } else {

            ScepLogOutput3(2,Win32rc, SCEDLL_ERROR_TAKE_OWNER, (LPWSTR)ObjectName);
        }

    } else {
        //
        // no takeownership action is taken
        //
        if ( !(SeInfo & OWNER_SECURITY_INFORMATION) ) {
            pOwner = NULL;
        }
    }

    if ( Win32rc != NO_ERROR ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_SET_SECURITY,
                     (PWSTR)ObjectName );
    } else {

        if ( pOwner != NULL || pGroup != NULL ) {
            if ( pOwner != NULL )
                SeInfoSet = OWNER_SECURITY_INFORMATION;
            else
                SeInfoSet = 0;
            if ( pGroup != NULL )
                SeInfoSet |= GROUP_SECURITY_INFORMATION;

            Win32rc = SetNamedSecurityInfo(
                            (LPWSTR)ObjectName,
                            ObjectType,
                            SeInfoSet,
                            pOwner,
                            pGroup,
                            NULL,
                            NULL
                            );
        }

    }


/*
#if 0

#ifdef SCE_DBG
    printf("Calling SetNamedSecurityInfoEx:\n");
    ScepPrintSecurityDescriptor( pSecurityDescriptor, TRUE );
#endif

    //
    // convert to the new structure
    //
    PACTRL_ACCESS       pAccess=NULL;
    PACTRL_AUDIT        pAudit=NULL;
    LPWSTR              pOwner=NULL;
    LPWSTR              pGroup=NULL;

    Win32rc = ConvertSecurityDescriptorToAccessNamed(
                        ObjectName,
                        ObjectType,
                        pSecurityDescriptor,
                        &pAccess,
                        &pAudit,
                        &pOwner,
                        &pGroup
                        );

    if ( Win32rc == ERROR_SUCCESS ) {

        //
        // set DACL/SACL
        //
        SeInfoSet = (SeInfo & DACL_SECURITY_INFORMATION) |
                    (SeInfo & SACL_SECURITY_INFORMATION);

        Win32rc = SetNamedSecurityInfoEx(
                                ObjectName,
                                ObjectType,
                                SeInfoSet,
                                NULL,
                                pAccess,
                                pAudit,
                                NULL,
                                NULL,
                                NULL
                                );

        if ( (Win32rc == ERROR_ACCESS_DENIED || Win32rc == ERROR_CANT_ACCESS_FILE) && NULL != AdminsSid ) {
            //
            // access denied, take ownership and then set
            // should backup the old owner first
            // NOTE: the old owner of this object is already stored in pOwner
            // (pSecurityDescritor) which is queried from ScepGetNewSecurity(...
            //

            ScepLogOutput3(3,0, SCEDLL_SCP_TAKE_OWNER, (LPWSTR)ObjectName);

            Win32rc = SetNamedSecurityInfo(
                                (LPWSTR)ObjectName,
                                ObjectType,
                                OWNER_SECURITY_INFORMATION,
                                AdminsSid,
                                NULL,
                                NULL,
                                NULL
                                );

            if ( Win32rc == NO_ERROR ) {
                //
                // ownership is changed, then set security again
                //
                Win32rc = SetNamedSecurityInfoEx(
                                        ObjectName,
                                        ObjectType,
                                        SeInfoSet,
                                        NULL,
                                        pAccess,
                                        pAudit,
                                        NULL,
                                        NULL,
                                        NULL
                                        );

                //
                // set the old owner back (later)
                //
            } else {

                ScepLogOutput3(2,Win32rc, SCEDLL_ERROR_TAKE_OWNER, (LPWSTR)ObjectName);
            }
        }

        if ( Win32rc != NO_ERROR ) {
            ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_SET_SECURITY,
                         (PWSTR)ObjectName );
        } else {

            if ( pOwner != NULL || pGroup != NULL ) {
                if ( pOwner != NULL )
                    SeInfoSet = OWNER_SECURITY_INFORMATION;
                else
                    SeInfoSet = 0;
                if ( pGroup != NULL )
                    SeInfoSet |= GROUP_SECURITY_INFORMATION;

                Win32rc = SetNamedSecurityInfoEx(
                                        ObjectName,
                                        ObjectType,
                                        SeInfoSet,
                                        NULL,
                                        NULL,
                                        NULL,
                                        pOwner,
                                        pGroup,
                                        NULL
                                        );
            }

        }
    }

    if ( pAccess ) {
        LocalFree(pAccess);
    }

    if ( pAudit ) {
        LocalFree(pAudit);
    }

    if ( pGroup ) {
        LocalFree(pGroup);
    }

    if ( pOwner ) {
        LocalFree(pOwner);
    }
#endif
*/

    if (Win32rc == ERROR_FILE_NOT_FOUND ||
        Win32rc == ERROR_PATH_NOT_FOUND ||
        Win32rc == ERROR_SHARING_VIOLATION ||
        Win32rc == ERROR_ACCESS_DENIED ||
        Win32rc == ERROR_CANT_ACCESS_FILE ||
        Win32rc == ERROR_INVALID_HANDLE ) {

        gWarningCode = Win32rc;

        Win32rc = NO_ERROR;
    }

    return(Win32rc);
}


DWORD
ScepSetSecurityOverwriteExplicit(
    IN PCWSTR pszRootObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
/*
Routine Description:

    This routine will set security to the current object and all children.
    By calling this function, the existing security descriptor for all children
    will be totally replaced by pSecurityDescriptor if it is a container, or by
    pObjectSecurity if it is a file object.

    The difference between this function and SetNamedSecurityInfo is that
    SetNamedSecurityInfo only overwrites the inherited aces for all children
    but not the explicit aces.

Arguments:

    ObjectName - The container object's name

    SeInfo     - Security Information to set

    pSecurityDescriptor - Security descriptor for container type objects

    ObjectType - The object type
                        SE_FILE_OBJECT
                        SE_REGISTRY_KEY

Return Value:

    Win32 error codes
*/
{

    PSCEP_STACK_NODE pStackHead = NULL;
    DWORD           rc;
    BOOL    bPushedOntoStack = FALSE;

    //
    // for file objects - to avoid excessive heap operations
    //
    struct _wfinddata_t FileInfo = {0};

    //
    // for registry objects - to avoid excessive heap operations
    //

    WCHAR           Buffer1[261];
    PWSTR   ObjectName = NULL;

    Buffer1[0] = L'\0';

    rc = ScepStackNodePush(&pStackHead,
                                (PWSTR)pszRootObjectName,
                                pSecurityDescriptor);

    if (rc == ERROR_SUCCESS ) {

        while (pStackHead) {

            ScepStackNodePop(&pStackHead,
                             &ObjectName,
                             &pSecurityDescriptor);

#ifdef SCE_DBG
            ScepDumpStack(&pStackHead);
#endif

            BOOL            bHasChild=FALSE;

            //
            // set security to the current object first
            //
#ifdef _WIN64
            rc = ScepSetSecurityObjectOnly(
                                          ObjectName,
                                          SeInfo,
                                          pSecurityDescriptor,
                                          ObjectType,
                                          (ObjectType == SE_REGISTRY_KEY || ObjectType == SE_REGISTRY_WOW64_32KEY) ? &bHasChild : NULL
                                          );
#else
            rc = ScepSetSecurityObjectOnly(
                                          ObjectName,
                                          SeInfo,
                                          pSecurityDescriptor,
                                          ObjectType,
                                          (ObjectType == SE_REGISTRY_KEY) ? &bHasChild : NULL
                                          );
#endif

            if ( rc == ERROR_ACCESS_DENIED ||
                 rc == ERROR_CANT_ACCESS_FILE ||
                 rc == ERROR_FILE_NOT_FOUND ||
                 rc == ERROR_PATH_NOT_FOUND ||
                 rc == ERROR_SHARING_VIOLATION ||
                 rc == ERROR_INVALID_HANDLE ) {

                gWarningCode = rc;


                if (ObjectName != pszRootObjectName) {

                    ScepFree(ObjectName);
                    ObjectName = NULL;

                    if (pSecurityDescriptor) {
                        RtlDeleteSecurityObject( &pSecurityDescriptor );
                        pSecurityDescriptor = NULL;
                    }
                }

                continue;
            }

            if ( rc != ERROR_SUCCESS )
                break;

            PWSTR           Buffer=NULL;
            DWORD           BufSize;
            PSECURITY_DESCRIPTOR pObjectSecurity=NULL;


            switch ( ObjectType ) {
            case SE_FILE_OBJECT:

                //
                // find all files under this directory/file
                //
                BufSize = wcslen(ObjectName)+4;
                Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                if ( Buffer == NULL ) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                swprintf(Buffer, L"%s\\*.*", ObjectName);

                intptr_t            hFile;

                hFile = _wfindfirst(Buffer, &FileInfo);

                ScepFree(Buffer);
                Buffer = NULL;

                if ( hFile != -1 ) {

                    do {
                        if ( FileInfo.name[0] == L'.')
                            continue;

                        //
                        // build the full name for this object
                        //
                        BufSize = wcslen(ObjectName)+wcslen(FileInfo.name)+1;
                        Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                        if ( Buffer == NULL ) {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                        swprintf(Buffer, L"%s\\%s", ObjectName, FileInfo.name);

                        //
                        // compute the new security descriptor because
                        // different objects may have different owner and
                        // the creator owner ace must be translated correctly
                        //

                        rc = ScepGetNewSecurity(
                                               Buffer,
                                               pSecurityDescriptor, // parent's SD
                                               NULL,  // object SD
                                               0,    // does not query current object SD
                                               (BOOLEAN)(FileInfo.attrib & _A_SUBDIR ),
                                               SeInfo,
                                               ObjectType,
                                               Token,
                                               GenericMapping,
                                               &pObjectSecurity
                                               );

                        if ( ERROR_SUCCESS  == rc ) {

                            if ( FileInfo.attrib & _A_SUBDIR ) {


                                //
                                // enumerate all nodes under this one and "empty" explicit aces by
                                // calling NtSetSecurityInfo directly
                                //
                                /*rc = ScepSetSecurityOverwriteExplicit(
                                                                     Buffer,
                                                                     SeInfo,
                                                                     pObjectSecurity,
                                                                     ObjectType,
                                                                     Token,
                                                                     GenericMapping
                                                                     );*/

                                rc = ScepStackNodePush(&pStackHead,
                                                            Buffer,
                                                            pObjectSecurity);

                                if (rc == ERROR_SUCCESS)
                                    bPushedOntoStack = TRUE;

                            } else {
                                //
                                // this is a file. Set the file security descriptor to this object
                                // using NT api
                                //
                                rc = ScepSetSecurityObjectOnly(
                                                              Buffer,
                                                              SeInfo,
                                                              pObjectSecurity,
                                                              ObjectType,
                                                              NULL
                                                              );
                                if ( rc == ERROR_ACCESS_DENIED ||
                                     rc == ERROR_CANT_ACCESS_FILE ||
                                     rc == ERROR_FILE_NOT_FOUND ||
                                     rc == ERROR_PATH_NOT_FOUND ||
                                     rc == ERROR_SHARING_VIOLATION ||
                                     rc == ERROR_INVALID_HANDLE ) {

                                    gWarningCode = rc;
                                    rc = NO_ERROR;
                                }
                            }
                        }

                        if ( !bPushedOntoStack ) {

                            if (pObjectSecurity) {
                                RtlDeleteSecurityObject( &pObjectSecurity );
                                pObjectSecurity = NULL;
                            }

                            if (Buffer) {
                                ScepFree(Buffer);
                                Buffer = NULL;
                            }

                        }

                        bPushedOntoStack = FALSE;


                        if ( rc != ERROR_SUCCESS )
                            break;

                    } while ( _wfindnext(hFile, &FileInfo) == 0 );

                    _findclose(hFile);
                }

                break;

            case SE_REGISTRY_KEY:
#ifdef _WIN64
            case SE_REGISTRY_WOW64_32KEY:
#endif

                if ( bHasChild ) {

                    HKEY            hKey;

                    //
                    // open the key
                    //
                    rc = ScepOpenRegistryObject(
                                               ObjectType,
                                               (LPWSTR)ObjectName,
                                               KEY_READ,
                                               &hKey
                                               );

                    if ( rc == ERROR_SUCCESS ) {

                        DWORD           SubKeyLen;
                        DWORD           cSubKeys;

                        cSubKeys = 0;

                        rc = RegQueryInfoKey (
                                             hKey,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &cSubKeys,
                                             &SubKeyLen,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL
                                             );

                        if ( rc != NO_ERROR ) {

                            ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_INFO, (PWSTR)ObjectName );

                            cSubKeys = 0;
                            SubKeyLen = 0;

                            rc = NO_ERROR;
                        }

                        if ( cSubKeys && SubKeyLen ) {

                            DWORD           index;
                            DWORD           EnumRc;

                            index = 0;
                            //
                            // enumerate all subkeys of the key
                            //

                            do {
                                BufSize = 260;

                                EnumRc = RegEnumKeyEx(hKey,
                                                      index,
                                                      Buffer1,
                                                      &BufSize,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      NULL);

                                if ( EnumRc == ERROR_SUCCESS ) {
                                    index++;

                                    BufSize += wcslen(ObjectName)+1;
                                    Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                                    if ( Buffer == NULL ) {
                                        rc = ERROR_NOT_ENOUGH_MEMORY;
                                        break;
                                    }
                                    swprintf(Buffer, L"%s\\%s", ObjectName, Buffer1);

                                    //
                                    // compute the new security descriptor because
                                    // different objects may have different owner and
                                    // the creator owner ace must be translated correctly
                                    //

                                    rc = ScepGetNewSecurity(
                                                           Buffer,
                                                           pSecurityDescriptor, // parent's SD
                                                           NULL,  // object SD
                                                           0,    // does not query current object SD
                                                           (BOOLEAN)TRUE,
                                                           SeInfo,
                                                           ObjectType,
                                                           Token,
                                                           GenericMapping,
                                                           &pObjectSecurity
                                                           );

                                    if ( ERROR_SUCCESS == rc ) {

                                        //
                                        // enumerate all nodes under this one and "empty" explicit aces by
                                        // calling NtSetSecurityInfo directly
                                        //
                                        /*rc = ScepSetSecurityOverwriteExplicit(
                                                                             Buffer,
                                                                             SeInfo,
                                                                             pObjectSecurity,
                                                                             ObjectType,
                                                                             Token,
                                                                             GenericMapping
                                                                             );*/

                                        rc = ScepStackNodePush(&pStackHead,
                                                                    Buffer,
                                                                    pObjectSecurity);

                                        if (rc == ERROR_SUCCESS)
                                            bPushedOntoStack = TRUE;


                                    }

                                    if ( rc != ERROR_SUCCESS )
                                        ScepLogOutput3(1, rc, SCEDLL_ERROR_SET_SECURITY, Buffer);

                                    if ( !bPushedOntoStack ) {

                                        if ( pObjectSecurity ) {

                                            RtlDeleteSecurityObject( &pObjectSecurity );
                                            pObjectSecurity = NULL;
                                        }

                                        ScepFree(Buffer);
                                        Buffer = NULL;
                                    }

                                    bPushedOntoStack = FALSE;

                                    if ( rc != ERROR_SUCCESS )
                                        break;

                                } else if ( EnumRc != ERROR_NO_MORE_ITEMS ) {
                                    break;
                                }

                            } while ( EnumRc != ERROR_NO_MORE_ITEMS );

                            if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {
                                ScepLogOutput3(1, EnumRc, SCEDLL_SAP_ERROR_ENUMERATE, (PWSTR)ObjectName );
                                if ( rc == ERROR_SUCCESS )
                                    rc = EnumRc;

                            }
                        }

                        RegCloseKey(hKey);

                    } else
                        ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, (PWSTR)ObjectName );
                }

                break;
            }

            if (ObjectName != pszRootObjectName) {

                ScepFree(ObjectName);
                ObjectName = NULL;

                if (pSecurityDescriptor) {
                    RtlDeleteSecurityObject( &pSecurityDescriptor );
                    pSecurityDescriptor = NULL;
                }
            }

        }

        if ( rc != ERROR_SUCCESS ) {
            ScepFreeStack(&pStackHead);
        }

    }

    return(rc);

}

VOID
ScepFreeStack(
    IN PSCEP_STACK_NODE    *ppStackHead
    )
{
    if (ppStackHead == NULL || *ppStackHead == NULL )
        return;

    PSCEP_STACK_NODE    pNode;

    while ( pNode = *ppStackHead ) {
        ScepFree( pNode->Buffer );
        RtlDeleteSecurityObject( &(pNode->pObjectSecurity) );
        *ppStackHead = pNode->Next;
        LocalFree(pNode);
    }
    return;
}

VOID
ScepDumpStack(
    IN PSCEP_STACK_NODE    *ppStackHead
    )
{
    if (ppStackHead == NULL || *ppStackHead == NULL )
        return;

    PSCEP_STACK_NODE    pNode = *ppStackHead;

    wprintf(L"\n >>>>>>>>> Stack contents");

    while ( pNode ) {
        if ( pNode->Buffer)
            wprintf(L"\n     %s", pNode->Buffer );
        pNode = pNode->Next;
    }
    return;
}


DWORD
ScepStackNodePush(
    IN PSCEP_STACK_NODE    *ppStackHead,
    IN PWSTR   pszObjectName,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{

    if (ppStackHead == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    PSCEP_STACK_NODE    pNode = (PSCEP_STACK_NODE) LocalAlloc(LMEM_ZEROINIT, sizeof(SCEP_STACK_NODE));

    if ( pNode == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    pNode->Buffer = pszObjectName;
    pNode->pObjectSecurity = pSecurityDescriptor;
    pNode->Next = *ppStackHead;
    *ppStackHead = pNode;

#ifdef SCE_DBG
    gDbgNumPushed ++;
#endif

    return ERROR_SUCCESS;

}

VOID
ScepStackNodePop(
    IN OUT PSCEP_STACK_NODE    *ppStackHead,
    IN OUT PWSTR   *ppszObjectName,
    IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    )
{
    if (ppStackHead == NULL ||
        *ppStackHead == NULL ||
        ppszObjectName == NULL ||
        ppSecurityDescriptor == NULL )
        return;

    PSCEP_STACK_NODE    pNode = *ppStackHead;

    *ppszObjectName =  pNode->Buffer;
    *ppSecurityDescriptor = pNode->pObjectSecurity;
    *ppStackHead = pNode->Next;

    LocalFree(pNode);

#ifdef SCE_DBG
    gDbgNumPopped ++;
#endif

    return;

}


DWORD
ScepSetSecurityObjectOnly(
    IN PCWSTR ObjectName,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SE_OBJECT_TYPE ObjectType,
    OUT PBOOL pbHasChild
    )
/* ++
Routine Description:

    This routine set security information to the object only. Security
    for children of this object is not set.

Arguments:

    ObjecName  - name of the object to set security to

    SeInfo     - Security information to set

    pSecurityDescriptor - the security descriptor

    ObjectType - type of the object (FILE, REGISTRY, ...)

Return value:

    Win32 error code

-- */
{
    DWORD       rc=ERROR_SUCCESS;
    HANDLE      Handle=NULL;
    NTSTATUS    NtStatus;
    DWORD       cSubKeys;
    SECURITY_INFORMATION SeInfoToSet=0;
    SECURITY_DESCRIPTOR SD;

#ifdef SCE_DBG
    UCHAR psdbuffer[1024];
    PISECURITY_DESCRIPTOR psecuritydescriptor = (PISECURITY_DESCRIPTOR) psdbuffer;
    ULONG bytesneeded = 0;
    ULONG newbytesneeded;

    printf("Before calling NtSetSecurityObject:\n");
    ScepPrintSecurityDescriptor( pSecurityDescriptor, TRUE );
#endif

    //
    // make a absolute format security descriptor which only contains AdminsSid
    // as the owner.
    //

    switch ( ObjectType ) {
    case SE_FILE_OBJECT:
        //
        // open file object. If it can't be opend due to access denied,
        // take ownership then open again.
        //
        rc = ScepOpenFileObject(
                    (LPWSTR)ObjectName,
                    ScepGetDesiredAccess(MODIFY_ACCESS_RIGHTS, SeInfo),
                    &Handle
                    );

        if ( (rc == ERROR_ACCESS_DENIED || rc == ERROR_CANT_ACCESS_FILE) && NULL != AdminsSid ) {
            //
            // open with access to set owner
            //
            ScepLogOutput3(3,0, SCEDLL_SCP_TAKE_OWNER, (LPWSTR)ObjectName);

            rc = ScepOpenFileObject(
                        (LPWSTR)ObjectName,
                        ScepGetDesiredAccess(WRITE_ACCESS_RIGHTS, OWNER_SECURITY_INFORMATION),
                        &Handle
                        );
            if ( rc == ERROR_SUCCESS ) {
                //
                // make a absolute format of security descriptor
                // to set owner with
                // if error occurs, continue
                //

                NtStatus = RtlCreateSecurityDescriptor( &SD,
                                        SECURITY_DESCRIPTOR_REVISION );
                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = RtlSetOwnerSecurityDescriptor (
                                        &SD,
                                        AdminsSid,
                                        FALSE
                                        );
                    if ( NT_SUCCESS(NtStatus) ) {
                        NtStatus = NtSetSecurityObject(
                                            Handle,
                                            OWNER_SECURITY_INFORMATION,
                                            &SD
                                            );
                    }
                }

                rc = RtlNtStatusToDosError(NtStatus);

                CloseHandle(Handle);

                if ( rc == ERROR_SUCCESS ) {

                    //
                    // old owner of the object is already stored in the security descriptor
                    // passed in, which is created from ScepGetNewSecurity...
                    //
                    SeInfoToSet = OWNER_SECURITY_INFORMATION;

                    //
                    // re-open the file
                    //
                    rc = ScepOpenFileObject(
                                (LPWSTR)ObjectName,
                                ScepGetDesiredAccess(MODIFY_ACCESS_RIGHTS, SeInfoToSet | SeInfo), //SeInfo),
                                &Handle
                                );
                }
            }

            if ( ERROR_SUCCESS != rc ) {
                ScepLogOutput3(2, rc, SCEDLL_ERROR_TAKE_OWNER, (PWSTR)ObjectName );
            }
        }

        if (rc == ERROR_SUCCESS ) {

            //
            // set security to this object
            //

            SeInfoToSet |= SeInfo;
            ScepAddAutoInheritRequest(pSecurityDescriptor, &SeInfoToSet);

            NtStatus = NtSetSecurityObject(
                                Handle,
                                SeInfoToSet,
                                pSecurityDescriptor
                                );
            rc = RtlNtStatusToDosError(NtStatus);

#ifdef SCE_DBG
            if ( rc == NO_ERROR ) {

                printf("After calling NtSetSecurityObject:\n");

                NtStatus = NtQuerySecurityObject( Handle,
                                                   SeInfo,
                                                   psecuritydescriptor,
                                                   1024,
                                                   &bytesneeded);

                if (STATUS_BUFFER_TOO_SMALL == NtStatus)
                {
                    if (NULL != (psecuritydescriptor = (PISECURITY_DESCRIPTOR)
                                         ScepAlloc(LMEM_ZEROINIT, bytesneeded) ))

                        NtStatus = NtQuerySecurityObject(Handle,
                                              SeInfo,
                                              psecuritydescriptor,
                                              bytesneeded,
                                              &newbytesneeded);
                }
                if (NT_SUCCESS(NtStatus)) {
                    ScepPrintSecurityDescriptor( (PSECURITY_DESCRIPTOR)psecuritydescriptor, TRUE );
                } else
                    printf("error occurs: %x\n", NtStatus);

                if (bytesneeded > 1024)
                    ScepFree(psecuritydescriptor);

            }
#endif
            CloseHandle(Handle);
        }

        if ( rc == ERROR_SUCCESS && pbHasChild != NULL ) {
            ScepDoesObjectHasChildren(ObjectType, (PWSTR)ObjectName, pbHasChild);
        }

        break;

    case SE_REGISTRY_KEY:
#ifdef _WIN64
    case SE_REGISTRY_WOW64_32KEY:
#endif
        //
        // open registry object. If it can't be opened due to access denied,
        // take ownership then open again.
        //
        rc = ScepOpenRegistryObject(
                    ObjectType,
                    (LPWSTR)ObjectName,
                    ScepGetDesiredAccess(WRITE_ACCESS_RIGHTS, SeInfo),
                    (PHKEY)&Handle
                    );

        if ( (rc == ERROR_ACCESS_DENIED || rc == ERROR_CANT_ACCESS_FILE) && NULL != AdminsSid ) {

            ScepLogOutput3(3,0, SCEDLL_SCP_TAKE_OWNER, (LPWSTR)ObjectName);

            //
            // open registry object with access to set owner
            //
            rc = ScepOpenRegistryObject(
                        ObjectType,
                        (LPWSTR)ObjectName,
                        ScepGetDesiredAccess(WRITE_ACCESS_RIGHTS, OWNER_SECURITY_INFORMATION),
                        (PHKEY)&Handle
                        );
            if ( rc == ERROR_SUCCESS ) {
                //
                // make a absolute format of security descriptor
                // to set owner with
                // if error occurs, continue
                //

                NtStatus = RtlCreateSecurityDescriptor( &SD,
                                        SECURITY_DESCRIPTOR_REVISION );
                if ( NT_SUCCESS(NtStatus) ) {

                    NtStatus = RtlSetOwnerSecurityDescriptor (
                                        &SD,
                                        AdminsSid,
                                        FALSE
                                        );
                }

                if ( NT_SUCCESS(NtStatus) ) {
                    rc = RegSetKeySecurity((HKEY)Handle,
                                            OWNER_SECURITY_INFORMATION,
                                            &SD);

                } else {
                    rc = RtlNtStatusToDosError(NtStatus);
                }

                RegCloseKey((HKEY)Handle);

                if ( rc == ERROR_SUCCESS ) {

                    //
                    // old owner is already stored in the pSecurityDescriptor passed in
                    // which is created in ScepGetNewSecurity...
                    //

                    SeInfoToSet = OWNER_SECURITY_INFORMATION;
                    //
                    // re-open the registry key
                    //
                    rc = ScepOpenRegistryObject(
                                ObjectType,
                                (LPWSTR)ObjectName,
                                ScepGetDesiredAccess(WRITE_ACCESS_RIGHTS, SeInfoToSet | SeInfo),
                                (PHKEY)&Handle
                                );
                }
            }

            if ( ERROR_SUCCESS != rc ) {

                ScepLogOutput3(2, rc, SCEDLL_ERROR_TAKE_OWNER, (PWSTR)ObjectName );
            }

        }

        if (rc == ERROR_SUCCESS ) {

            //
            // set security to the registry key
            //
            SeInfoToSet |= SeInfo;
            ScepAddAutoInheritRequest(pSecurityDescriptor, &SeInfoToSet);

            rc = RegSetKeySecurity((HKEY)Handle,
                                    SeInfoToSet,
                                    pSecurityDescriptor);

            RegCloseKey((HKEY)Handle);

            //
            // query key info for subkeys first
            //
            if ( ERROR_SUCCESS == rc && pbHasChild != NULL ) {

                rc = ScepOpenRegistryObject(
                            ObjectType,
                            (LPWSTR)ObjectName,
                            KEY_READ,
                            (PHKEY)&Handle
                            );

                if ( ERROR_SUCCESS == rc ) {

                    cSubKeys = 0;

                    rc = RegQueryInfoKey (
                                (HKEY)Handle,
                                NULL,
                                NULL,
                                NULL,
                                &cSubKeys,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

                    RegCloseKey((HKEY)Handle);
                }

                if ( rc != NO_ERROR ) {

                    ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_INFO, (PWSTR)ObjectName );

                    cSubKeys = 0;

                    rc = NO_ERROR;
                }

                if (cSubKeys == 0 )
                    *pbHasChild = FALSE;
                else
                    // ignore the error, just set has child.
                    //
                    *pbHasChild = TRUE;

            }

        } else
            ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, (PWSTR)ObjectName);


        break;
    }

    if ( rc != NO_ERROR )
        ScepLogOutput3(1, rc, SCEDLL_ERROR_SET_SECURITY, (PWSTR)ObjectName);

    if ( rc == ERROR_INVALID_OWNER ||
         rc == ERROR_INVALID_PRIMARY_GROUP ||
         rc == ERROR_INVALID_SECURITY_DESCR )
        rc = NO_ERROR;

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\svcsrv.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    svcsrv.cpp

Abstract:

    Server Service attachment APIs

Author:

    Jin Huang (jinhuang) 23-Jun-1997

Revision History:

    jinhuang    23-Jan-1998     splitted to client-server
--*/
#include "serverp.h"
#include "pfp.h"
#include "srvrpcp.h"
#include "service.h"
#pragma hdrstop

//
// private prototypes
//
SCESTATUS
SceSvcpGetOneKey(
    IN PSCESECTION hSection,
    IN PWSTR Prefix,
    IN DWORD PrefixLen,
    IN SCESVC_INFO_TYPE Type,
    OUT PVOID *Info
    );

SCESTATUS
SceSvcpEnumNext(
    IN PSCESECTION hSection,
    IN DWORD RequestCount,
    IN SCESVC_INFO_TYPE Type,
    OUT PVOID *Info,
    OUT PDWORD CountReturned
    );

//
// prototypes called from RPC interfaces
//


SCESTATUS
SceSvcpUpdateInfo(
    IN PSCECONTEXT                  Context,
    IN PCWSTR                       ServiceName,
    IN PSCESVC_CONFIGURATION_INFO   Info
    )
/*
Routine Description:

    Load service's engine dll and pass the Info buffer to service engine's
    update API (SceSvcAttachmentUpdate). Currently security manager engine
    is not doing any processing for the service data.

    This routine triggers the update of configuration database and/or
    analysis information by the service engine. Info may contain the
    modifications only, or the whole configuratio data for the service,
    or partial configuration data, depending on the agreement between service
    extension and service engine.

    This routine does not really write info to security manager database directly,
    instead, it passes the info buffer to the service engine's update interface
    and service engine will determine what and when to write inot the database.

Arguments:

    hProfile - the security database context handle

    ServiceName - The service's name as used by service control manager

    Info - The information modified

*/
{

    if ( Context == NULL || ServiceName == NULL ||
        Info == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);

    }

    SCESTATUS rc;

    //
    // get service's dll name
    //

    DWORD KeyLen;
    PWSTR KeyStr=NULL;

    KeyLen = wcslen(SCE_ROOT_SERVICE_PATH) + 1 + wcslen(ServiceName);

    KeyStr = (PWSTR)ScepAlloc(0, (KeyLen+1)*sizeof(WCHAR));

    if ( KeyStr == NULL ) {

        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    }

    PWSTR Setting=NULL;
    DWORD RegType;

    swprintf(KeyStr, L"%s\\%s", SCE_ROOT_SERVICE_PATH, ServiceName);
    KeyStr[KeyLen] = L'\0';

    rc = ScepRegQueryValue(
            HKEY_LOCAL_MACHINE,
            KeyStr,
            L"ServiceAttachmentPath",
            (PVOID *)&Setting,
            &RegType
            );

    rc = ScepDosErrorToSceStatus(rc);

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Setting != NULL ) {

            //
            // load the dll.
            //
            HINSTANCE hService;

            hService = LoadLibrary(Setting);

            if ( hService != NULL ) {
                //
                // call SceSvcAttachmentUpdate from the dll
                //
                PF_UpdateService pfTemp;

                pfTemp = (PF_UpdateService)
                                  GetProcAddress(hService,
                                                 "SceSvcAttachmentUpdate") ;
                if ( pfTemp != NULL ) {

                    SCEP_HANDLE sceHandle;
                    SCESVC_CALLBACK_INFO sceCbInfo;

                    sceHandle.hProfile = (PVOID)Context;
                    sceHandle.ServiceName = ServiceName;

                    sceCbInfo.sceHandle = &sceHandle;
                    sceCbInfo.pfQueryInfo = &SceCbQueryInfo;
                    sceCbInfo.pfSetInfo = &SceCbSetInfo;
                    sceCbInfo.pfFreeInfo = &SceSvcpFreeMemory;
                    sceCbInfo.pfLogInfo = &ScepLogOutput2;

                    //
                    // call the SceSvcAttachmentUpdate from the DLL
                    //
                    __try {

                        rc = (*pfTemp)((PSCESVC_CALLBACK_INFO)&sceCbInfo, Info );

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                    }

                } else {
                    //
                    // this API is not supported
                    //
                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                }

                //
                // try to free the library handle. If it fails, just leave it
                // to to the process to terminate
                //
                FreeLibrary(hService);

            } else
                rc = SCESTATUS_SERVICE_NOT_SUPPORT;

            ScepFree(Setting);

        } else
            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
    }

    ScepFree(KeyStr);

    return(rc);

}


SCESTATUS
SceSvcpQueryInfo(
    IN PSCECONTEXT                  Context,
    IN SCESVC_INFO_TYPE             SceSvcType,
    IN PCWSTR                       ServiceName,
    IN PWSTR                        Prefix OPTIONAL,
    IN BOOL                         bExact,
    OUT PVOID                       *ppvInfo,
    IN OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
    )
/*
Routine Description:

    Query information for the service in the configuration/analysis database
    which contains the modified configuration and last analysis information.

    One enumeration returns maximum SCESVC_ENUMERATION_MAX lines (key/value)
    matching the lpPrefix for the service. If lpPrefix is NULL, all information
    for the service is enumerated. If there is more information, psceEnumHandle
    must be used to get next set of keys/values, until *ppvInfo is NULL or Count is 0.

    When bExact is set and lpPrefix is not NULL, exact match on the lpPrefix is
    searched and only one line is returned.

    The output buffer must be freed by SceSvcFree

Arguments:

    Context     - the database context handle

    SceSvcType  - the information type to query

    ServiceName - the service name to query info for

    Prefix      - the optional key name prefix for the query

    bExact      - TRUE = exact match on key

    ppvInfo     - the output buffer

    psceEnumHandle  - the output enumeration handle for next enumeartion

*/
{
    if ( Context == NULL || ppvInfo == NULL ||
         psceEnumHandle == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);

    }

    PSCESECTION   hSection=NULL;
    DOUBLE        SectionID;
    SCESTATUS     rc;

    switch ( SceSvcType ) {
    case SceSvcConfigurationInfo:
        //
        // query data in configuration database
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SMP,
                    ServiceName,
                    &hSection
                    );
        break;

    case SceSvcAnalysisInfo:
        //
        // query data in analysis database
        //
        rc = ScepOpenSectionForName(
                    Context,
                    SCE_ENGINE_SAP,
                    ServiceName,
                    &hSection
                    );
        break;

    case SceSvcInternalUse:
    case SceSvcMergedPolicyInfo:
        //
        // query data in SCP database
        //
        rc = SceJetGetSectionIDByName(
                    Context,
                    ServiceName,
                    &SectionID
                    );
        if ( rc == SCESTATUS_SUCCESS ) {

            rc = SceJetOpenSection(
                        Context,
                        SectionID,
                        SCEJET_TABLE_SCP,
                        &hSection
                        );
        }
        break;

    default:
        rc = SCESTATUS_INVALID_PARAMETER;
        break;
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        *ppvInfo = NULL;

        DWORD PrefixLen, CountReturned;

        if ( Prefix != NULL ) {
            PrefixLen = wcslen(Prefix);
        } else
            PrefixLen = 0;

        if ( bExact && Prefix != NULL ) {

            //
            // one single key match
            //

            rc = SceSvcpGetOneKey(
                        hSection,
                        Prefix,
                        PrefixLen,
                        SceSvcType,
                        ppvInfo
                        );

            *psceEnumHandle = 0;

        } else {
            //
            // count total number of lines matching Prefix
            //
            DWORD LineCount;

            rc = SceJetGetLineCount(
                        hSection,
                        Prefix,
                        TRUE,
                        &LineCount
                        );

            if ( rc == SCESTATUS_SUCCESS && LineCount <= 0 )
                rc = SCESTATUS_RECORD_NOT_FOUND;

            if ( rc == SCESTATUS_SUCCESS ) {

                if ( LineCount <= *psceEnumHandle ) {
                    //
                    // no more entries
                    //

                } else {
                    //
                    // go to the first line of Prefix
                    //
                    rc = SceJetSeek(
                            hSection,
                            Prefix,
                            PrefixLen*sizeof(WCHAR),
                            SCEJET_SEEK_GE
                            );

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // skip the first *EnumHandle lines
                        //
                        JET_ERR JetErr;

                        JetErr = JetMove(hSection->JetSessionID,
                                     hSection->JetTableID,
                                     *psceEnumHandle,
                                     0
                                     );
                        rc = SceJetJetErrorToSceStatus(JetErr);

                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // find the right start point
                            //
                            DWORD CountToReturn;

                            if ( LineCount - *psceEnumHandle > SCESVC_ENUMERATION_MAX ) {
                                CountToReturn = SCESVC_ENUMERATION_MAX;
                            } else
                                CountToReturn = LineCount - *psceEnumHandle;
                            //
                            // get next block of data
                            //
                            rc = SceSvcpEnumNext(
                                    hSection,
                                    CountToReturn,
                                    SceSvcType,
                                    ppvInfo,
                                    &CountReturned
                                    );

                            if ( rc == SCESTATUS_SUCCESS ) {
                                //
                                // update the enumeration handle
                                //
                                *psceEnumHandle += CountReturned;

                            }
                        }

                    }

                }
            }
        }

        if ( rc != SCESTATUS_SUCCESS ) {

            *psceEnumHandle = 0;
        }

        //
        // close the section
        //
        SceJetCloseSection(&hSection, TRUE);
    }

    return(rc);
}



SCESTATUS
SceSvcpGetOneKey(
    IN PSCESECTION hSection,
    IN PWSTR Prefix,
    IN DWORD PrefixLen,
    IN SCESVC_INFO_TYPE Type,
    OUT PVOID *Info
    )
/*
Read key and value information into *Info for exact matched Prefix

*/
{
    if ( hSection == NULL || Prefix == NULL ||
         Info == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    DWORD ValueLen;
    PBYTE Value=NULL;

    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH,
                Prefix,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // allocate buffer for Value
        //
        Value = (PBYTE)ScepAlloc(0, ValueLen+2);

        if ( Value != NULL ) {

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        (PWSTR)Value,
                        ValueLen,
                        &ValueLen
                        );

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // allocate output buffer and assign
                //
                PSCESVC_ANALYSIS_INFO pAnalysisInfo=NULL;
                PSCESVC_CONFIGURATION_INFO pConfigInfo=NULL;

                if ( Type == SceSvcAnalysisInfo ) {

                    *Info = ScepAlloc(0, sizeof(SCESVC_ANALYSIS_INFO));
                    pAnalysisInfo = (PSCESVC_ANALYSIS_INFO)(*Info);

                } else {
                    *Info = ScepAlloc(0, sizeof(SCESVC_CONFIGURATION_INFO));
                    pConfigInfo = (PSCESVC_CONFIGURATION_INFO)(*Info);
                }

                if ( *Info != NULL ) {
                    //
                    // Lines buffer
                    //
                    if ( Type == SceSvcAnalysisInfo ) {

                        pAnalysisInfo->Lines = (PSCESVC_ANALYSIS_LINE)ScepAlloc(0,
                                                sizeof(SCESVC_ANALYSIS_LINE));

                        if ( pAnalysisInfo->Lines != NULL ) {
                            //
                            // Key buffer
                            //
                            pAnalysisInfo->Lines->Key = (PWSTR)ScepAlloc(0, (PrefixLen+1)*sizeof(WCHAR));

                            if ( pAnalysisInfo->Lines->Key != NULL ) {

                                wcscpy( pAnalysisInfo->Lines->Key, Prefix );
                                pAnalysisInfo->Lines->Value = Value;
                                pAnalysisInfo->Lines->ValueLen = ValueLen;

                                pAnalysisInfo->Count = 1;

                                Value = NULL;


                            } else {
                                //
                                // free *Info->Lines
                                //
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                ScepFree( pAnalysisInfo->Lines );
                                pAnalysisInfo->Lines = NULL;
                            }

                        } else
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        if ( rc != SCESTATUS_SUCCESS ) {
                            //
                            // free buffer allocate
                            //
                            ScepFree(*Info);
                            *Info = NULL;

                        }

                    } else {
                        pConfigInfo->Lines = (PSCESVC_CONFIGURATION_LINE)ScepAlloc(0,
                                                sizeof(SCESVC_CONFIGURATION_LINE));

                        if ( pConfigInfo->Lines != NULL ) {
                            //
                            // Key buffer
                            //
                            pConfigInfo->Lines->Key = (PWSTR)ScepAlloc(0, (PrefixLen+1)*sizeof(WCHAR));

                            if ( pConfigInfo->Lines->Key != NULL ) {

                                wcscpy( pConfigInfo->Lines->Key, Prefix );
                                pConfigInfo->Lines->Value = (PWSTR)Value;
                                pConfigInfo->Lines->ValueLen = ValueLen;

                                pConfigInfo->Count = 1;

                                Value = NULL;

                            } else {
                                //
                                // free *Info->Lines
                                //
                                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                ScepFree( pConfigInfo->Lines );
                                pConfigInfo->Lines = NULL;
                            }

                        } else
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        if ( rc != SCESTATUS_SUCCESS ) {
                            //
                            // free buffer allocate
                            //
                            ScepFree(*Info);
                            *Info = NULL;

                        }

                    }
                    //
                    // free *Info
                    //
                    if ( rc != SCESTATUS_SUCCESS ) {

                        ScepFree( *Info );
                        *Info = NULL;
                    }

                } else
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

            if ( Value != NULL ) {
                ScepFree(Value);
                Value = NULL;
            }

        }
    }
    return(rc);
}


SCESTATUS
SceSvcpEnumNext(
    IN PSCESECTION hSection,
    IN DWORD RequestCount,
    IN SCESVC_INFO_TYPE Type,
    OUT PVOID *Info,
    OUT PDWORD CountReturned
    )
{
    if ( hSection == NULL || Info == NULL || CountReturned == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( RequestCount <= 0 ) {
        *CountReturned = 0;

        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    //
    // allocate output buffer
    //
    PSCESVC_ANALYSIS_INFO pAnalysisInfo=NULL;
    PSCESVC_CONFIGURATION_INFO pConfigInfo=NULL;

    if ( Type == SceSvcAnalysisInfo ) {

        *Info = ScepAlloc(0, sizeof(SCESVC_ANALYSIS_INFO));
        pAnalysisInfo = (PSCESVC_ANALYSIS_INFO)(*Info);

    } else {

        *Info = ScepAlloc(0, sizeof(SCESVC_CONFIGURATION_INFO));
        pConfigInfo = (PSCESVC_CONFIGURATION_INFO)(*Info);
    }

    if ( *Info != NULL ) {

        DWORD Count=0;

        if ( Type == SceSvcAnalysisInfo ) {

            pAnalysisInfo->Lines = (PSCESVC_ANALYSIS_LINE)ScepAlloc(0,
                                      RequestCount*sizeof(SCESVC_ANALYSIS_LINE));

            if ( pAnalysisInfo->Lines == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        } else {

            pConfigInfo->Lines = (PSCESVC_CONFIGURATION_LINE)ScepAlloc(0,
                                      RequestCount*sizeof(SCESVC_CONFIGURATION_LINE));

            if ( pConfigInfo->Lines == NULL ) {
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }

        }

        if ( rc == SCESTATUS_SUCCESS ) {  // if Lines is NULL, rc will be NOT_ENOUGH_RESOURCE

            //
            // loop through each line
            //
            DWORD KeyLen, ValueLen;
            PWSTR Key=NULL, Value=NULL;

            do {

                rc = SceJetGetValue(
                            hSection,
                            SCEJET_CURRENT,
                            NULL,
                            NULL,
                            0,
                            &KeyLen,
                            NULL,
                            0,
                            &ValueLen
                            );

                if ( rc == SCESTATUS_SUCCESS ) {

                    //
                    // allocate memory for the Key and Value
                    //
                    Key = (PWSTR)ScepAlloc(LMEM_ZEROINIT, KeyLen+2);
                    Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

                    if ( Key == NULL || Value == NULL ) {

                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        ScepFree(Key);
                        ScepFree(Value);

                    } else {
                        //
                        // Get the Key and Value
                        //
                        rc = SceJetGetValue(
                                    hSection,
                                    SCEJET_CURRENT,
                                    NULL,
                                    Key,
                                    KeyLen,
                                    &KeyLen,
                                    Value,
                                    ValueLen,
                                    &ValueLen
                                    );

                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // assign to the output buffer
                            //
                            if ( Type == SceSvcAnalysisInfo ) {
                                pAnalysisInfo->Lines[Count].Key = Key;
                                pAnalysisInfo->Lines[Count].Value = (PBYTE)Value;
                                pAnalysisInfo->Lines[Count].ValueLen = ValueLen;
                            } else {
                                pConfigInfo->Lines[Count].Key = Key;
                                pConfigInfo->Lines[Count].Value = Value;
                                pConfigInfo->Lines[Count].ValueLen = ValueLen;
                            }

                        } else {
                            ScepFree(Key);
                            ScepFree(Value);
                        }

                    }
                }

                //
                // move to next line
                //
                if ( rc == SCESTATUS_SUCCESS ) {

                    rc = SceJetMoveNext(hSection);

                    Count++;
                }

            } while (rc == SCESTATUS_SUCCESS && Count < RequestCount );

        }

        *CountReturned = Count;

        if (Type == SceSvcAnalysisInfo) {

            pAnalysisInfo->Count = Count;

        } else {

            pConfigInfo->Count = Count;
        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS;

        } else if ( rc != SCESTATUS_SUCCESS ) {
            //
            // free memory allocated for output buffer
            //
            DWORD i;

            if (Type == SceSvcAnalysisInfo) {

                for ( i=0; i<Count; i++ ) {
                    ScepFree(pAnalysisInfo->Lines[i].Key);
                    ScepFree(pAnalysisInfo->Lines[i].Value);
                }

                ScepFree(pAnalysisInfo->Lines);

            } else {

                for ( i=0; i<Count; i++ ) {

                    ScepFree(pConfigInfo->Lines[i].Key);
                    ScepFree(pConfigInfo->Lines[i].Value);
                }

                ScepFree(pConfigInfo->Lines);
            }

            ScepFree(*Info);
            *Info = NULL;

            *CountReturned = 0;
        }

    } else
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

    return(rc);
}


SCESTATUS
SceSvcpSetInfo(
    IN PSCECONTEXT      Context,
    IN SCESVC_INFO_TYPE SceSvcType,
    IN PCWSTR           ServiceName,
    IN PWSTR            Prefix OPTIONAL,
    IN BOOL             bExact,
    IN LONG             GpoID,
    IN PVOID            pvInfo OPTIONAL
    )
/*
Routine Description:

    Save information of a service into security manager internal database. It's up
    to the service to collect/decide the information to write.

    Type indicates the type of internal database: CONFIGURATION or ANALYSIS.

    If the service section does not exist, create it.

*/
{
    if (!Context || !ServiceName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSCESECTION hSection=NULL;
    SCESTATUS rc;

    //
    // open/create the sections
    //

    rc = SceJetStartTransaction( Context );

    if ( rc == SCESTATUS_SUCCESS ) {

        switch ( SceSvcType ) {
        case SceSvcConfigurationInfo:

            rc = ScepStartANewSection(
                        Context,
                        &hSection,
                        SCEJET_TABLE_SMP,
                        ServiceName
                        );
            break;

        case SceSvcAnalysisInfo:

            rc = ScepStartANewSection(
                        Context,
                        &hSection,
                        SCEJET_TABLE_SAP,
                        ServiceName
                        );
            break;

        case SceSvcInternalUse:
        case SceSvcMergedPolicyInfo:

            rc = ScepStartANewSection(
                        Context,
                        &hSection,
                        SCEJET_TABLE_SCP,
                        ServiceName
                        );
            break;

        default:
            rc = SCESTATUS_INVALID_PARAMETER;
        }

        if ( rc == SCESTATUS_SUCCESS ) {

            if ( pvInfo == NULL ) {
                //
                // delete the whole section, partial for Prefix, or a single line
                //
                if (Prefix == NULL ) {
                    rc = SceJetDelete(
                             hSection,
                             NULL,
                             FALSE,
                             SCEJET_DELETE_SECTION
                             );
                } else if ( bExact ) {
                    //
                    // delete single line
                    //
                    rc = SceJetDelete(
                             hSection,
                             Prefix,
                             FALSE,
                             SCEJET_DELETE_LINE
                             );
                } else {
                    rc = SceJetDelete(
                             hSection,
                             Prefix,
                             FALSE,
                             SCEJET_DELETE_PARTIAL
                             );
                }
                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;
                }

            } else {
                //
                // if bExact is not set, delete the whole section first
                //
                if ( !bExact ) {
                    rc = SceJetDelete(
                             hSection,
                             NULL,
                             FALSE,
                             SCEJET_DELETE_SECTION
                             );
                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        rc = SCESTATUS_SUCCESS;
                    }
                }
                //
                // overwrite some keys in Info
                //
                DWORD Count;
                PWSTR Key;
                PBYTE Value;
                DWORD ValueLen;

                if ( SceSvcType == SceSvcAnalysisInfo )
                    Count = ((PSCESVC_ANALYSIS_INFO)pvInfo)->Count;
                else
                    Count = ((PSCESVC_CONFIGURATION_INFO)pvInfo)->Count;

                for ( DWORD i=0; i<Count; i++ ) {

                    if ( SceSvcType == SceSvcAnalysisInfo ) {

                        Key = ((PSCESVC_ANALYSIS_INFO)pvInfo)->Lines[i].Key;
                        Value = ((PSCESVC_ANALYSIS_INFO)pvInfo)->Lines[i].Value;
                        ValueLen = ((PSCESVC_ANALYSIS_INFO)pvInfo)->Lines[i].ValueLen;

                    } else {
                        Key = ((PSCESVC_CONFIGURATION_INFO)pvInfo)->Lines[i].Key;
                        Value = (PBYTE)(((PSCESVC_CONFIGURATION_INFO)pvInfo)->Lines[i].Value);
                        ValueLen = ((PSCESVC_CONFIGURATION_INFO)pvInfo)->Lines[i].ValueLen;
                    }

                    rc = SceJetSetLine(
                                hSection,
                                Key,
                                TRUE,
                                (PWSTR)Value,
                                ValueLen,
                                GpoID
                                );

                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }

                }
            }
        }
        //
        // close the section
        //
        SceJetCloseSection(&hSection, TRUE);

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // commit the change
            //
            rc = SceJetCommitTransaction(Context, 0);

        }
        if ( rc != SCESTATUS_SUCCESS ) {

            SceJetRollback(Context, 0);
        }
    }

    return(rc);
}

//
// attachment engine call back functions
//

SCESTATUS
SceCbQueryInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    OUT PVOID               *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
    )
{

    PVOID hProfile;
    SCESTATUS rc=ERROR_SUCCESS;

    __try {

        hProfile = ((SCEP_HANDLE *)sceHandle)->hProfile;

        if ( !hProfile ||
            ((SCEP_HANDLE *)sceHandle)->ServiceName == NULL ) {

            rc = SCESTATUS_INVALID_PARAMETER;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // call the private function
        //

        rc = SceSvcpQueryInfo(
                    (PSCECONTEXT)hProfile,
                    sceType,
                    ((SCEP_HANDLE *)sceHandle)->ServiceName,
                    lpPrefix,
                    bExact,
                    ppvInfo,
                    psceEnumHandle
                    );
    }

    return(rc);

}

SCESTATUS
SceCbSetInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    IN PVOID                pvInfo
    )
{

    PVOID hProfile;
    SCESTATUS rc=ERROR_SUCCESS;

    __try {

        hProfile = ((SCEP_HANDLE *)sceHandle)->hProfile;

        if ( !hProfile ||
            ((SCEP_HANDLE *)sceHandle)->ServiceName == NULL ) {

            rc = SCESTATUS_INVALID_PARAMETER;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = SCESTATUS_INVALID_PARAMETER;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // call the private function
        //

        rc = SceSvcpSetInfo(
                    (PSCECONTEXT)hProfile,
                    sceType,
                    ((SCEP_HANDLE *)sceHandle)->ServiceName,
                    lpPrefix,
                    bExact,
                    0,
                    pvInfo
                    );

    }

    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\common\buffers.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    buffers

Abstract:

    This module provides the run time code to support the CBuffer object.

Author:

    Doug Barlow (dbarlow) 11/7/1995

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <SCardLib.h>


/*++

CBuffer:

    This constructor is a special case for use explicitly with the operator+
    routine.  It builds a CBuffer out of the other two with only a single
    allocation.

Arguments:

    bfSourceOne supplies the first part of the new buffer
    bfSourceTwo supplies the second part of the new buffer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 11/7/1995

--*/

CBuffer::CBuffer(           //  Object assignment constructor.
    IN const CBuffer &bfSourceOne,
    IN const CBuffer &bfSourceTwo)
{
    Initialize();
    Presize(bfSourceOne.m_cbDataLength + bfSourceTwo.m_cbDataLength);
    Set(bfSourceOne.m_pbBuffer, bfSourceOne.m_cbDataLength);
    Append(bfSourceTwo.m_pbBuffer, bfSourceTwo.m_cbDataLength);
}


/*++

Clear:

    This routine resets a CBuffer to it's initial state, freeing any allocated
    memory.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

void
CBuffer::Clear(
    void)
{
    if (NULL != m_pbBuffer)
        delete[] m_pbBuffer;
    Initialize();
}


/*++

Reset:

    This routine logically empties the CBuffer without actually deallocating
    memory.  It's data lengh goes to zero.

Arguments:

    None

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Reset(
    void)
{
    m_cbDataLength = 0;
    return m_pbBuffer;
}


/*++

Presize:

    This is the primary workhorse of the CBuffer class.  It ensures that the
    size of the buffer is of the proper size.  Data in the buffer may optionally
    be preserved, in which case the data length doesn't change.  If the buffer
    is not preserved, then the data length is reset to zero.

Arguments:

    cbLength supplies the desired length of the buffer.

    fPreserve supplies a flag indicating whether or not to preserve the current
        contents of the buffer.

Return Value:

    The address of the properly sized buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Presize(
    IN DWORD cbLength,
    IN BOOL fPreserve)
{
    LPBYTE pbNewBuf = NULL;
    if (fPreserve && (0 < m_cbDataLength))
    {

        //
        // Increase the buffer length, and preserve the existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                throw (DWORD)ERROR_OUTOFMEMORY;
            memcpy(pbNewBuf, m_pbBuffer, m_cbDataLength);
            delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            m_cbBufferLength = cbLength;
        }
    }
    else
    {

        //
        // Increase the buffer length, but lose any existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                throw (DWORD)ERROR_OUTOFMEMORY;
            if (NULL != m_pbBuffer)
                delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            m_cbBufferLength = cbLength;
        }
        m_cbDataLength = 0;
    }
    return m_pbBuffer;
}


/*++

Resize:

    This method sets the length of the data to the given size.  If the buffer
    isn't big enough to support that data length, it is enlarged.

Arguments:

    cbLength supplies the new length of the data.

    fPreserve supplies a flag indicating whether or not to preserve existing
        data.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Resize(
    DWORD cbLength,
    BOOL fPreserve)
{
    LPBYTE pb = Presize(cbLength, fPreserve);
    m_cbDataLength = cbLength;
    return pb;
}


/*++

Set:

    This method sets the contents of the data to the given value.  If the buffer
    isn't big enough to hold the given data, it is enlarged.

Arguments:

    pbSource supplies the data to place in the data buffer.

    cbLength supplies the length of that data, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Set(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = Presize(cbLength, FALSE);
    if (0 < cbLength)
        memcpy(pb, pbSource, cbLength);
    m_cbDataLength = cbLength;
    return pb;
}


/*++

CBuffer::Append:

    This method appends the supplied data onto the end of the existing data,
    enlarging the buffer if necessary.

Arguments:

    pbSource supplies the data to be appended.

    cbLength supplies the length of the data to be appended, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPBYTE
CBuffer::Append(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = m_pbBuffer;
    if (0 < cbLength)
    {
        pb = Presize(m_cbDataLength + cbLength, TRUE);
        memcpy(&pb[m_cbDataLength], pbSource, cbLength);
        m_cbDataLength += cbLength;
    }
    return pb;
}


/*++

CBuffer::Compare:

    This method compares the contents of another CBuffer to this one, and
    returns a value indicating a comparative value.

Arguments:

    bfSource supplies the other buffer.

Return Value:

    < 0 - The other buffer is less than this one.
    = 0 - The other buffer is identical to this one.
    > 0 - The other buffer is greater than this one.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

int
CBuffer::Compare(
    const CBuffer &bfSource)
const
{
    if (m_cbDataLength < bfSource.m_cbDataLength)
        return -1;
    else if (m_cbDataLength > bfSource.m_cbDataLength)
        return 1;
    else if (0 < m_cbDataLength)
        return memcmp(m_pbBuffer, bfSource.m_pbBuffer, m_cbDataLength);
    else
        return 0;
}


/*++

operator+:

    This routine is a special operator that allows addition of two CBuffers to
    produce a third, a la bfThree = bfOne + bfTwo.  It calls the special
    protected constructor of CBuffer.

Arguments:

    bfSourceOne supplies the first buffer
    bfSourceTwo supplies the second buffer

Return Value:

    A reference to a temporary CBuffer that is the concatenation of the two
    provided buffers.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

#pragma warning (disable : 4172)
CBuffer &
operator+(
    IN const CBuffer &bfSourceOne,
    IN const CBuffer &bfSourceTwo)
{
    return CBuffer(bfSourceOne, bfSourceTwo);
}
#pragma warning (default : 4172)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\srvutil.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scep.h

Abstract:

    This module defines the data structures and function prototypes
    for the security managment utility

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#ifndef _srvutil_
#define _srvutil_

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _SCE_FLAG_TYPE {

    SCE_FLAG_CONFIG=1,
    SCE_FLAG_CONFIG_APPEND,
    SCE_FLAG_ANALYZE,
    SCE_FLAG_ANALYZE_APPEND,
    SCE_FLAG_CONFIG_SCP,
    SCE_FLAG_CONFIG_SCP_APPEND

} SCEFLAGTYPE;

SCESTATUS
ScepGetTotalTicks(
    IN PCWSTR TemplateName,
    IN PSCECONTEXT Context,
    IN AREA_INFORMATION Area,
    IN SCEFLAGTYPE nFlag,
    OUT PDWORD pTotalTicks
    );

BOOL
ScepIsEngineRecovering();

SCESTATUS
ScepSaveAndOffAuditing(
    OUT PPOLICY_AUDIT_EVENTS_INFO *ppAuditEvent,
    IN BOOL bTurnOffAuditing,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    );

NTSTATUS
ScepGetAccountExplicitRight(
    IN LSA_HANDLE PolicyHandle,
    IN PSID       AccountSid,
    OUT PDWORD    PrivilegeLowRights,
    OUT PDWORD    PrivilegeHighRights
    );

NTSTATUS
ScepGetMemberListSids(
    IN PSID         DomainSid,
    IN LSA_HANDLE   PolicyHandle,
    IN PSCE_NAME_LIST pMembers,
    OUT PUNICODE_STRING *MemberNames,
    OUT PSID**      Sids,
    OUT PULONG      MemberCount
    );

DWORD
ScepOpenFileObject(
    IN  LPWSTR       pObjectName,
    IN  ACCESS_MASK  AccessMask,
    OUT PHANDLE      Handle
    );

DWORD
ScepOpenRegistryObject(
    IN  SE_OBJECT_TYPE  ObjectType,
    IN  LPWSTR       pObjectName,
    IN  ACCESS_MASK  AccessMask,
    OUT PHKEY        Handle
    );

SCESTATUS
ScepGetNameInLevel(
    IN PCWSTR ObjectFullName,
    IN DWORD  Level,
    IN WCHAR  Delim,
    OUT PWSTR Buffer,
    OUT PBOOL LastOne
    );


SCESTATUS
ScepTranslateFileDirName(
   IN PWSTR oldFileName,
   OUT PWSTR *newFileName
   );

//
// errlog.c
//
SCESTATUS
ScepLogInitialize(
   IN PCWSTR logname
   );

SCESTATUS
ScepLogOutput2(
   IN INT     ErrLevel,
   IN DWORD   rc,
   IN PWSTR   fmt,
   ...
  );

SCESTATUS
ScepLogOutput(
    IN DWORD rc,
    IN LPTSTR buf
    );

SCESTATUS
ScepLogOutput3(
   IN INT     ErrLevel,
   IN DWORD   rc,
   IN UINT nId,
   ...
  );

SCESTATUS
ScepLogClose();

SCESTATUS
ScepLogWriteError(
    IN PSCE_ERROR_LOG_INFO  pErrlog,
    IN INT ErrLevel
    );

SCESTATUS
ScepConvertLdapToJetIndexName(
    IN PWSTR TempName,
    OUT PWSTR *OutName
    );

SCESTATUS
ScepRestoreAuditing(
    IN PPOLICY_AUDIT_EVENTS_INFO auditEvent,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    );

DWORD
ScepGetDefaultDatabase(
    IN LPCTSTR JetDbName OPTIONAL,
    IN DWORD LogOptions,
    IN LPCTSTR LogFileName OPTIONAL,
    OUT PBOOL pAdminLogon OPTIONAL,
    OUT PWSTR *ppDefDatabase
    );

BOOL
ScepIsDomainLocal(
    IN PUNICODE_STRING pDomainName OPTIONAL
    );

BOOL
ScepIsDomainLocalBySid(
    IN PSID pSidLookup
    );

NTSTATUS
ScepAddAdministratorToThisList(
    IN SAM_HANDLE DomainHandle OPTIONAL,
    IN OUT PSCE_NAME_LIST *ppList
    );

DWORD
ScepDatabaseAccessGranted(
    IN LPTSTR DatabaseName,
    IN DWORD DesiredAccess,
    IN BOOL bCreate
    );

DWORD
ScepAddSidToNameList(
    OUT PSCE_NAME_LIST *pNameList,
    IN PSID pSid,
    IN BOOL bReuseBuffer,
    OUT BOOL *pbBufferUsed
    );

BOOL
ScepValidSid(
    PSID Sid
    );

BOOL
ScepBinarySearch(
    IN  PWSTR   *aPszPtrs,
    IN  DWORD   dwSize_aPszPtrs,
    IN  PWSTR   pszNameToFind
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\common\changedb.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    changedb

Abstract:

    This file provides the implementation of the Calais Database management
    utilities which modify the Calais database.

Author:

    Doug Barlow (dbarlow) 1/29/1997

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <winscard.h>
#include <CalaisLb.h>

// Keep this in sync with QueryDB.cpp
typedef struct {
    DWORD dwScope;
    HKEY hKey;
} RegMap;

#if SCARD_SCOPE_SYSTEM < SCARD_SCOPE_USER
#error Invalid ordering to SCARD_SCOPE definitions
#endif

static TCHAR l_szInvalidChars[] = TEXT("\\?");
static const RegMap l_rgRegMap[]
    = {
        { SCARD_SCOPE_USER,     HKEY_CURRENT_USER },
     // { SCARD_SCOPE_TERMINAL, Not implemented yet },  // ?Hydra?
        { SCARD_SCOPE_SYSTEM,   HKEY_LOCAL_MACHINE }
      };
static const DWORD l_dwRegMapMax = sizeof(l_rgRegMap) / sizeof(RegMap);

static const LPCTSTR l_szrgProvMap[]
    = {
        NULL,   // Zero value
        SCARD_REG_PPV,
        SCARD_REG_CSP
      };
static const DWORD l_dwProvMapMax = sizeof(l_szrgProvMap) / sizeof(LPCTSTR);

static void
GuidFromString(
    IN LPCTSTR szGuid,
    OUT LPGUID pguidResult);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Management Services
//
//      The following services provide for managing the Calais Database.  These
//      services actually update the database, and require a smartcard context.
//

/*++

IntroduceReaderGroup:

    This service provides means for introducing a new smartcard reader group to
    Calais.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported..

    szGroupName supplies the friendly name to be assigned to the new reader
        group.

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
IntroduceReaderGroup(
    IN DWORD dwScope,
    IN LPCTSTR szGroupName)
{

    //
    //  In this implementation, groups need not be pre-declared.
    //

    if (0 == *szGroupName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    if (NULL != _tcspbrk(szGroupName, l_szInvalidChars))
        throw (DWORD)SCARD_E_INVALID_VALUE;
    return;
}


/*++

ForgetReaderGroup:

    This service provides means for removing a previously defined smartcard
    reader group from the Calais Subsystem.  This service automatically clears
    all readers from the group before forgetting it.  It does not affect the
    existence of the readers in the database.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szGroupName supplies the friendly name of the reader group to be
        forgotten.  The Calais-defined default reader groups may not be
        forgotten.

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
ForgetReaderGroup(
    IN DWORD dwScope,
    IN LPCTSTR szGroupName)
{
    DWORD dwCount, dwLen;
    LPCTSTR mszGroups;
    CBuffer bfTmp;
    CBuffer bfGroup;
    DWORD dwIndex;
    CRegistry regReaders;
    LPCTSTR szReader;

    if (0 == *szGroupName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;

    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_ALL_ACCESS);
    regReaders.Status();
    MStrAdd(bfGroup, szGroupName);
    for (dwIndex = 0;; dwIndex += 1)
    {
        try
        {
            try
            {
                szReader = regReaders.Subkey(dwIndex);
            }
            catch (...)
            {
                szReader = NULL;
            }
            if (NULL == szReader)
                break;
            CRegistry regReader(regReaders, szReader, KEY_ALL_ACCESS);
            mszGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
            dwCount = MStringCount(mszGroups);
            dwLen = MStringRemove(mszGroups, bfGroup, bfTmp);
            if (dwCount != dwLen)
                regReader.SetMultiStringValue(SCARD_REG_GROUPS, bfTmp);
        }
        catch (...) {}
    }
}


/*++

IntroduceReader:

    This service provides means for introducing an existing smartcard reader
    device to Calais.  Once introduced, Calais will assume responsibility for
    managing access to that reader.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szReaderName supplies the friendly name to be assigned to the reader.

    SzDeviceName supplies the system name of the smartcard reader device.
        (Example: "Smartcard0".)

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
IntroduceReader(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szDeviceName)
{
    CRegistry regReaders;
    DWORD dwIndex;


    //
    // Verify the reader name, so that it doesn't include any
    // disallowed characters.
    //

    if (0 == *szReaderName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    if (NULL != _tcspbrk(szReaderName, l_szInvalidChars))
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Translate the caller's scope.
    //

    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;


    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_CREATE_SUB_KEY,
            REG_OPTION_NON_VOLATILE,
            NULL);  // Inherit
    CRegistry regReader(
            regReaders,
            szReaderName,
            KEY_SET_VALUE,
            REG_OPTION_NON_VOLATILE,
            NULL);   // Create it & inherit

    if (REG_OPENED_EXISTING_KEY == regReader.GetDisposition())
        throw (DWORD)SCARD_E_DUPLICATE_READER;
    regReader.SetValue(SCARD_REG_DEVICE, szDeviceName);
    // regReader.SetValue(SCARD_REG_OEMCFG, ?what?);
    regReader.SetMultiStringValue(SCARD_REG_GROUPS, SCARD_DEFAULT_READERS);
}


/*++

ForgetReader:

    This service provides means for removing previously defined smartcard
    readers from control by the Calais Subsystem.  It is automatically removed
    from any groups it may have been added to.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szReaderName supplies the friendly name of the reader to be forgotten.

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
ForgetReader(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName)
{
    CRegistry regReaders;
    DWORD dwIndex;

    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;

    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_ALL_ACCESS);
    regReaders.DeleteKey(szReaderName);
}


/*++

AddReaderToGroup:

    This service provides means for adding existing an reader into an existing
    reader group.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szReaderName supplies the friendly name of the reader to be added.

    szGroupName supplies the friendly name of the group to which the reader
        should be added.

Return Value:

    None

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
AddReaderToGroup(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szGroupName)
{
    DWORD dwCount, dwLen;
    LPCTSTR mszGroups;
    CBuffer bfTmp;
    CBuffer bfGroup;
    CRegistry regReaders;
    DWORD dwIndex;

    if (0 == *szGroupName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;

    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_ALL_ACCESS);
    CRegistry regReader(
            regReaders,
            szReaderName,
            KEY_ALL_ACCESS);

    MStrAdd(bfGroup, szGroupName);
    mszGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
    dwCount = MStringCount(mszGroups);
    dwLen = MStringMerge(mszGroups, bfGroup, bfTmp);
    if (dwCount != dwLen)
        regReader.SetMultiStringValue(SCARD_REG_GROUPS, bfTmp);
}


/*++

RemoveReaderFromGroup:

    This service provides means for removing an existing reader from an existing
    reader group.  It does not affect the existence of either the reader or the
    group in the Calais database.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szReaderName supplies the friendly name of the reader to be removed.

    szGroupName supplies the friendly name of the group to which the reader
        should be removed.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow)  1/29/1007

--*/

void
RemoveReaderFromGroup(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szGroupName)
{
    DWORD dwCount, dwLen;
    LPCTSTR mszGroups;
    CBuffer bfTmp;
    CBuffer bfGroup;
    CRegistry regReaders;
    DWORD dwIndex;

    if (0 == *szGroupName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)SCARD_E_INVALID_VALUE;

    regReaders.Open(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_READERS,
            KEY_ALL_ACCESS);
    CRegistry regReader(
            regReaders,
            szReaderName,
            KEY_ALL_ACCESS);

    MStrAdd(bfGroup, szGroupName);
    mszGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
    dwCount = MStringCount(mszGroups);
    dwLen = MStringRemove(mszGroups, bfGroup, bfTmp);
    if (dwCount != dwLen)
        regReader.SetMultiStringValue(SCARD_REG_GROUPS, bfTmp);
}


/*++

IntroduceCard:

    This service provides means for introducing new smartcards to the Calais
    Subsystem for the active user.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szCardName supplies the friendly name by which this card should be known.

    PguidPrimaryProvider supplies a pointer to a GUID used to identify the
        Primary Service Provider for the card.

    rgguidInterfaces supplies an array of GUIDs identifying the smartcard
        interfaces supported by this card.

    dwInterfaceCount supplies the number of GUIDs in the pguidInterfaces array.

    pbAtr supplies a string against which card ATRs will be compared to
        determine a possible match for this card.  The length of this string is
        determined by normal ATR parsing.

    pbAtrMask supplies an optional bitmask to use when comparing the ATRs of
        smartcards to the ATR supplied in pbAtr.  If this value is non-NULL, it
        must point to a string of bytes the same length as the ATR string
        supplied in pbAtr.  Then when a given ATR A is compared to the ATR
        supplied in pbAtr B, it matches if and only if A & M = B, where M is the
        supplied mask, and & represents bitwise logical AND.

    cbAtrLen supplies the length of the ATR and Mask.  This value may be zero
        if the lentgh is obvious from the ATR.  However, it may be required if
        there is a Mask value that obscures the actual ATR.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
IntroduceCard(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen)
{
    DWORD dwIndex, dwReg, dwAtrLen;



    //
    // Verify the card name, so that it doesn't include any
    // disallowed characters.
    //

    if (0 == *szCardName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    if (NULL != _tcspbrk(szCardName, l_szInvalidChars))
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Translate the caller's scope.
    //

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;
    dwReg = dwIndex;
    if (NULL == pbAtrMask)
    {
        if (!ParseAtr(pbAtr, &dwAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
        if ((0 != cbAtrLen) && (dwAtrLen != cbAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else
    {
        if ((2 > cbAtrLen) || (33 < cbAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
        for (dwIndex = 0; dwIndex < cbAtrLen; dwIndex += 1)
        {
            if (pbAtr[dwIndex] != (pbAtr[dwIndex] & pbAtrMask[dwIndex]))
                throw (DWORD)SCARD_E_INVALID_PARAMETER;
        }
        dwAtrLen = cbAtrLen;
    }

    CRegistry regCards(
            l_rgRegMap[dwReg].hKey,
            SCARD_REG_CARDS,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);      // Inherit
    CRegistry regCard(
            regCards,
            szCardName,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);   // Create it & inherit

    if (REG_OPENED_EXISTING_KEY == regCard.GetDisposition())
        throw (DWORD)ERROR_ALREADY_EXISTS;
    regCard.SetValue(
            SCARD_REG_ATR,
            pbAtr,
            dwAtrLen);
    if (NULL != pbAtrMask)
        regCard.SetValue(
            SCARD_REG_ATRMASK,
            pbAtrMask,
            dwAtrLen);
    if (NULL != pguidPrimaryProvider)
        regCard.SetValue(
            SCARD_REG_PPV,
            (LPBYTE)pguidPrimaryProvider,
            sizeof(GUID));
    if ((NULL != rgguidInterfaces) && (0 < dwInterfaceCount))
        regCard.SetValue(
            SCARD_REG_GUIDS,
            (LPBYTE)rgguidInterfaces,
            sizeof(GUID) * dwInterfaceCount);
}


/*++

SetCardTypeProviderName:

    This routine sets the value of a given Provider Name, by Id number, for the
    identified card type.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL and SCARD_SCOPE_USER are not supported.

    szCardName supplies the name of the card type with which this provider
        name is to be associated.

    dwProviderId supplies the identifier for the provider to be associated with
        this card type.  Possible values are:

        SCARD_PROVIDER_SSP - The SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
            over 0x80000000 are available for use by the smart card vendors, and
            are card-specific.

    szProvider supplies the string identifying the provider.

Return Value:

    None.

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/

void
SetCardTypeProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCTSTR szProvider)
{
    DWORD dwIndex;
    LPCTSTR szProvValue;
    TCHAR szNumeric[36];


    //
    // Validate the request.
    //

    if (0 == *szCardName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    if (0 == *szProvider)
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Find the Card definition.
    //

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;

    CRegistry regCardTypes(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_CARDS,
            KEY_ALL_ACCESS);
    CRegistry regCard(
            regCardTypes,
            szCardName,
            KEY_ALL_ACCESS);
    regCard.Status();


    //
    // Derive the Provider Value Name.
    //

    if (dwProviderId < l_dwProvMapMax)
    {
        szProvValue = l_szrgProvMap[dwProviderId];
        if (NULL == szProvValue)
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else if (0x80000000 <= dwProviderId)
    {
        _ultot(dwProviderId, szNumeric, 16);
        szProvValue = szNumeric;
    }
    else
        throw (DWORD)SCARD_E_INVALID_PARAMETER;


    //
    // Write the provider value.
    //

    switch (dwProviderId)
    {
    case 1: // SCARD_PROVIDER_SSP
    {
        GUID guidProvider;

        GuidFromString(szProvider, &guidProvider);
        regCard.SetValue(szProvValue, (LPCBYTE)&guidProvider, sizeof(GUID));
        break;
    }
    default:
        regCard.SetValue(szProvValue, szProvider);
    }
}


/*++

ForgetCard:

    This service provides means for removing previously defined smartcards from
    the Calais Subsystem.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szCardName supplies the friendly name of the card to be forgotten.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
ForgetCard(
    IN DWORD dwScope,
    IN LPCTSTR szCardName)
{
    DWORD dwIndex;

    if (0 == *szCardName)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;

    CRegistry regCards(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_CARDS,
            KEY_ALL_ACCESS);

    regCards.DeleteKey(szCardName);
}


#ifdef ENABLE_SCARD_TEMPLATES
/*++

IntroduceCardTypeTemplate:

    This service provides means for introducing a new smartcard template to the
    Calais Subsystem.  A card tye template is a known card type that hasn't
    been formally introduced.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_USER and SCARD_SCOPE_TERMINAL is not supported.

    szVendorName supplies the manufacturer name by which this card should be
        recognized.

    PguidPrimaryProvider supplies a pointer to a GUID used to identify the
        Primary Service Provider for the card.

    rgguidInterfaces supplies an array of GUIDs identifying the smartcard
        interfaces supported by this card.

    dwInterfaceCount supplies the number of GUIDs in the pguidInterfaces array.

    pbAtr supplies a string against which card ATRs will be compared to
        determine a possible match for this card.  The length of this string is
        determined by normal ATR parsing.

    pbAtrMask supplies an optional bitmask to use when comparing the ATRs of
        smartcards to the ATR supplied in pbAtr.  If this value is non-NULL, it
        must point to a string of bytes the same length as the ATR string
        supplied in pbAtr.  Then when a given ATR A is compared to the ATR
        supplied in pbAtr B, it matches if and only if A & M = B, where M is the
        supplied mask, and & represents bitwise logical AND.

    cbAtrLen supplies the length of the ATR and Mask.  This value may be zero
        if the lentgh is obvious from the ATR.  However, it may be required if
        there is a Mask value that obscures the actual ATR.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
IntroduceCardTypeTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen)
{
    DWORD dwIndex, dwReg, dwAtrLen;



    //
    // Verify the template name, so that it doesn't include any
    // disallowed characters.
    //

    if (NULL != _tcspbrk(szVendorName, l_szInvalidChars))
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Translate the caller's scope.
    //

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;
    dwReg = dwIndex;
    if (NULL == pbAtrMask)
    {
        if (!ParseAtr(pbAtr, &dwAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
        if ((0 != cbAtrLen) && (dwAtrLen != cbAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else
    {
        if ((2 > cbAtrLen) || (33 < cbAtrLen))
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
        for (dwIndex = 0; dwIndex < cbAtrLen; dwIndex += 1)
        {
            if (pbAtr[dwIndex] != (pbAtr[dwIndex] & pbAtrMask[dwIndex]))
                throw (DWORD)SCARD_E_INVALID_PARAMETER;
        }
        dwAtrLen = cbAtrLen;
    }

    CRegistry regCards(
            l_rgRegMap[dwReg].hKey,
            SCARD_REG_TEMPLATES,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);
    CRegistry regCard(
            regCards,
            szVendorName,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);   // Create it.

    if (REG_OPENED_EXISTING_KEY == regCard.GetDisposition())
        throw (DWORD)ERROR_ALREADY_EXISTS;
    regCard.SetValue(
            SCARD_REG_ATR,
            pbAtr,
            dwAtrLen);
    if (NULL != pbAtrMask)
        regCard.SetValue(
            SCARD_REG_ATRMASK,
            pbAtrMask,
            dwAtrLen);
    if (NULL != pguidPrimaryProvider)
        regCard.SetValue(
            SCARD_REG_PPV,
            (LPBYTE)pguidPrimaryProvider,
            sizeof(GUID));
    if ((NULL != rgguidInterfaces) && (0 < dwInterfaceCount))
        regCard.SetValue(
            SCARD_REG_GUIDS,
            (LPBYTE)rgguidInterfaces,
            sizeof(GUID) * dwInterfaceCount);
}


/*++

SetCardTypeTemplateProviderName:

    This routine sets the value of a given Provider Name, by Id number, for the
    identified card type template.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL and SCARD_SCOPE_USER are not supported.

    szTemplateName supplies the name of the card type template with which this
        provider name is to be associated.

    dwProviderId supplies the identifier for the provider to be associated with
        this card type template.  Possible values are:

        SCARD_PROVIDER_SSP - The SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
            over 0x80000000 are available for use by the smart card vendors, and
            are card-specific.

    szProvider supplies the string identifying the provider.

Return Value:

    None.

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/

void
SetCardTypeTemplateProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szTemplateName,
    IN DWORD dwProviderId,
    IN LPCTSTR szProvider)
{
    DWORD dwIndex;
    LPCTSTR szProvValue;
    TCHAR szNumeric[36];

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;


    //
    // Make sure the template exists.
    //

    CRegistry regTemplates(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_TEMPLATES,
            KEY_ALL_ACCESS);
    CRegistry regTempl(
            regTemplates,
            szTemplateName,
            KEY_ALL_ACCESS);
    regTempl.Status();


    //
    // Derive the Provider Value Name.
    //

    if (dwProviderId < l_dwProvMapMax)
    {
        szProvValue = l_szrgProvMap[dwProviderId];
        if (NULL == szProvValue)
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else if (0x80000000 <= dwProviderId)
    {
        _ultot(dwProviderId, szNumeric, 16);
        szProvValue = szNumeric;
    }
    else
        throw (DWORD)SCARD_E_INVALID_PARAMETER;


    //
    // Write the provider value.
    //

    switch (dwProviderId)
    {
    case 1: // SCARD_PROVIDER_SSP
    {
        GUID guidProvider;

        GuidFromString(szProvider, &guidProvider);
        regTempl.SetValue(szProvValue, (LPCBYTE)&guidProvider, sizeof(GUID));
        break;
    }
    default:
        regTempl.SetValue(szProvValue, szProvider);
    }
}


/*++

ForgetCardTypeTemplate:

    This service provides means for removing previously defined smart card type
    templates from the Calais Subsystem.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_USER and SCARD_SCOPE_TERMINAL are not supported.

    szVendorName supplies the manufacturer's name of the card to be forgotten.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
ForgetCardTypeTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName)
{
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;

    CRegistry regTemplates(
            l_rgRegMap[dwIndex].hKey,
            SCARD_REG_TEMPLATES,
            KEY_ALL_ACCESS);

    regTemplates.DeleteKey(szVendorName);
}


/*++

IntroduceCardTypeFromTemplate:

    This service provides means for introducing new smartcards to the Calais
    Subsystem for the active user, based on a stored card template.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, SCARD_SCOPE_TERMINAL is not supported.

    szVendorName supplies the vendor name by which this card type is known,
        identifying the template to use.

    szFriendlyName supplies the friendly name by which this card should be
        known.  If this value is NULL, the vendor name is used as the friendly
        name,

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
IntroduceCardTypeFromTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName,
    IN LPCTSTR szFriendlyName /* = NULL */ )
{
    DWORD dwIndex;
    HKEY hCardTypeKey;
    CRegistry regTemplates, regTmpl;


    //
    // Verify the reader name, so that it doesn't include any
    // disallowed characters.
    //

    if (NULL == szFriendlyName)
        szFriendlyName = szVendorName;
    else
    {
        if (NULL != _tcspbrk(szFriendlyName, l_szInvalidChars))
            throw (DWORD)SCARD_E_INVALID_VALUE;
    }


    //
    // Identify the card type scope.
    //

    for (dwIndex = 0; dwIndex < l_dwRegMapMax; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope == dwScope)
            break;
    }
    if (l_dwRegMapMax == dwIndex)
        throw (DWORD)SCARD_E_INVALID_PARAMETER;
    hCardTypeKey = l_rgRegMap[dwIndex].hKey;


    //
    // Find the Template definition closest to the caller.
    //

    for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
    {
        if (l_rgRegMap[dwIndex].dwScope >= dwScope)
        {
            regTemplates.Open(
                l_rgRegMap[dwIndex].hKey,
                SCARD_REG_TEMPLATES,
                KEY_READ);
            try
            {
                regTmpl.Open(regTemplates, szVendorName, KEY_READ);
                regTmpl.Status();
                break;
            }
            catch (...)
            {
                regTmpl.Close();
            }
            regTemplates.Close();
        }
    }
    if (l_dwRegMapMax <= dwIndex)
        throw (DWORD)ERROR_FILE_NOT_FOUND;


    //
    // Create the CardType Entry.
    //

    CRegistry regCards(
            hCardTypeKey,
            SCARD_REG_CARDS,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);
    CRegistry regCard(
            regCards,
            szFriendlyName,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);   // Create it.
    if (REG_OPENED_EXISTING_KEY == regCard.GetDisposition())
        throw (DWORD)ERROR_ALREADY_EXISTS;


    //
    // Copy the entries.
    //

    regCard.Copy(regTmpl);
}
#endif  // ENABLE_SCARD_TEMPLATES


//
////////////////////////////////////////////////////////////////////////////////
//
// Support Routines
//

/*++

GuidFromString:

    This routine converts a string representation of a GUID into an actual GUID.
    It tries not to be picky about the systax, as long as it can get a GUID out
    of the string.  It's here so that it's not necessary to link all of OleBase
    into WinSCard.  Otherwise, we'd just use CLSIDFromString.

Arguments:

    szGuid supplies the GUID as a string.  For this routine, a GUID consists of
        hex digits, and some collection of braces and dashes.

    pguidResult receives the converted GUID.  If an error occurs during
        conversion, the contents of this parameter are indeterminant.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/20/1998

--*/

static void
GuidFromString(
    IN LPCTSTR szGuid,
    OUT LPGUID pguidResult)
{
    // The following placement assumes Little Endianness.
    static const WORD wPlace[sizeof(GUID)]
        = { 3, 2, 1, 0, 5, 4, 7, 6, 8, 9, 10, 11, 12, 13, 14, 15 };
    DWORD dwI, dwJ;
    LPCTSTR pch = szGuid;
    LPBYTE pbGuid = (LPBYTE)pguidResult;
    BYTE bVal;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        bVal = 0;
        for (dwJ = 0; dwJ < 2;)
        {
            switch (*pch)
            {
            case TEXT('0'):
            case TEXT('1'):
            case TEXT('2'):
            case TEXT('3'):
            case TEXT('4'):
            case TEXT('5'):
            case TEXT('6'):
            case TEXT('7'):
            case TEXT('8'):
            case TEXT('9'):
                bVal = (bVal << 4) + (*pch - TEXT('0'));
                dwJ += 1;
                break;
            case TEXT('A'):
            case TEXT('B'):
            case TEXT('C'):
            case TEXT('D'):
            case TEXT('E'):
            case TEXT('F'):
                bVal = (bVal << 4) + (10 + *pch - TEXT('A'));
                dwJ += 1;
                break;
            case TEXT('a'):
            case TEXT('b'):
            case TEXT('c'):
            case TEXT('d'):
            case TEXT('e'):
            case TEXT('f'):
                bVal = (bVal << 4) + (10 + *pch - TEXT('a'));
                dwJ += 1;
                break;
            case TEXT('['):
            case TEXT(']'):
            case TEXT('{'):
            case TEXT('}'):
            case TEXT('-'):
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            pch += 1;
        }
        pbGuid[wPlace[dwI]] = bVal;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\common\querydb.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    QueryDB

Abstract:

    This module provides simple access to the Calais Registry Database.

Author:

    Doug Barlow (dbarlow) 11/25/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <winscard.h>
#include <CalaisLb.h>

// Keep this in sync with ChangeDB.cpp
typedef struct {
    DWORD dwScope;
    HKEY hKey;
} RegMap;

#if SCARD_SCOPE_SYSTEM < SCARD_SCOPE_USER
#error Invalid ordering to SCARD_SCOPE definitions
#endif

static const RegMap l_rgRegMap[]
    = {
        { SCARD_SCOPE_USER,     HKEY_CURRENT_USER },
     // { SCARD_SCOPE_TERMINAL, Not implemented yet },  // ?Hydra?
        { SCARD_SCOPE_SYSTEM,   HKEY_LOCAL_MACHINE }
      };
static const DWORD l_dwRegMapMax = sizeof(l_rgRegMap) / sizeof(RegMap);

static const LPCTSTR l_szrgProvMap[]
    = {
        NULL,   // Zero value
        SCARD_REG_PPV,
        SCARD_REG_CSP
      };
static const DWORD l_dwProvMapMax = sizeof(l_szrgProvMap) / sizeof(LPCTSTR);

static BOOL
ListKnownKeys(
    IN  DWORD dwScope,
    OUT CBuffer &bfKeys,
    IN  LPCTSTR szUserList,
    IN  LPCTSTR szSystemList = NULL);
static void
FindKey(
    IN  DWORD dwScope,
    IN LPCTSTR szKey,
    OUT CRegistry &regKey,
    IN  LPCTSTR szUserList,
    IN  LPCTSTR szSystemList = NULL);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Query Services
//
//      These services all are oriented towards reading the Calais database.
//

/*++

ListReaderGroups:

    This service provides the list of named card reader groups that have
    previously been defined to the system.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, this value is ignored, and assumed to be SCARD_SCOPE_SYSTEM.

    bfGroups receives a multi-string listing the reader groups defined within
        the supplied scope.

Return Value:

    None.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
ListReaderGroups(
    IN DWORD dwScope,
    OUT CBuffer &bfGroups)
{
    CBuffer bfReaders;
    CRegistry regReader;
    LPCTSTR szReader, mszGroups;
    CBuffer bfTmp;
    DWORD cchGroups;

    ListKnownKeys(dwScope, bfReaders, SCARD_REG_READERS);
    for (szReader = FirstString(bfReaders);
         NULL != szReader;
         szReader = NextString(szReader))
    {
        try
        {
            FindKey(dwScope, szReader, regReader, SCARD_REG_READERS);
            mszGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
            cchGroups = regReader.GetValueLength() / sizeof(TCHAR);
            while (0 == mszGroups[cchGroups - 1])
                cchGroups -= 1;
            bfTmp.Append(
                (LPBYTE)mszGroups,
                cchGroups * sizeof(TCHAR));
            bfTmp.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
        }
        catch (...) {}
    }


    //
    // Sort the list, and remove duplicates.
    //

    bfTmp.Append((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
    MStringSort(bfTmp, bfGroups);
}


/*++

ListReaders:

    This service provides the list of readers within a set of named reader
    groups, eliminating duplicates.  The caller supplies a multistring listing
    the name of a set of pre-defined group of readers, and receives the list of
    smartcard readers within the named groups.  Unrecognized group names are
    ignored.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    mszGroups supplies the names of the reader groups defined to the system, as
        a multi-string.  If this parameter is null, all readers are returned.

    bfReaders receives a multi-string listing the card readers within the
        supplied reader groups.

Return Value:

    None.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
ListReaders(
    IN DWORD dwScope,
    IN LPCTSTR mszGroups,
    OUT CBuffer &bfReaders)
{
    CRegistry regReader;
    LPCTSTR szReader, mszRdrGroups;
    CBuffer bfRdrs, bfCmn;
    DWORD dwCmnCount;

    dwCmnCount = MStringCommon(mszGroups, SCARD_ALL_READERS, bfCmn);
    if (0 == dwCmnCount)
    {
        if ((NULL == mszGroups) || (0 == *mszGroups))
            mszGroups = SCARD_DEFAULT_READERS;
        bfReaders.Reset();
        ListKnownKeys(dwScope, bfRdrs, SCARD_REG_READERS);
        for (szReader = FirstString(bfRdrs);
        NULL != szReader;
        szReader = NextString(szReader))
        {
            try
            {
                FindKey(dwScope, szReader, regReader, SCARD_REG_READERS);
                mszRdrGroups = regReader.GetMultiStringValue(SCARD_REG_GROUPS);
                dwCmnCount = MStringCommon(mszGroups, mszRdrGroups, bfCmn);
                if (0 < dwCmnCount)
                    bfReaders.Append(
                    (LPCBYTE)szReader,
                    (lstrlen(szReader) + 1) * sizeof(TCHAR));
            }
            catch (...) {}
        }
        bfReaders.Append((LPBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
        bfReaders.Resize(MStrLen((LPCTSTR)bfReaders.Access()), TRUE);
    }
    else
        ListKnownKeys(dwScope, bfReaders, SCARD_REG_READERS);
}


/*++

ListReaderNames:

    This routine returns the list of names corresponding to a given reader
    device.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

        For V1, this value is ignored, and assumed to be SCARD_SCOPE_SYSTEM.

    szDevice supplies the reader device name.

    bfNames receives a multistring of the names given to that device, if any.

Return Value:

    None

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 2/13/1997

--*/

void
ListReaderNames(
    IN DWORD dwScope,
    IN LPCTSTR szDevice,
    OUT CBuffer &bfNames)
{
    CRegistry regReader;
    LPCTSTR szReader, szDev;
    CBuffer bfRdrs;

    bfNames.Reset();
    ListKnownKeys(dwScope, bfRdrs, SCARD_REG_READERS);
    for (szReader = FirstString(bfRdrs);
    NULL != szReader;
    szReader = NextString(szReader))
    {
        try
        {
            FindKey(dwScope, szReader, regReader, SCARD_REG_READERS);
            szDev = regReader.GetStringValue(SCARD_REG_DEVICE);
            if (0 == lstrcmpi(szDev, szDevice))
                MStrAdd(bfNames, szReader);
        }
        catch (...) {}
    }
}



/*++

ListCards:

    This service provides a list of named cards previously introduced to the
    system by this user which match an optionally supplied ATR string and/or
    supply a set of given interfaces.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    pbAtr supplies the address of an ATR string to compare to known cards, or
        NULL if all card names are to be returned.

    rgguidInterfaces supplies an array of GUIDs, or the value NULL.  When an
        array is supplied, a card name will be returned only if this set of
        GUIDs is a (possibly improper) subset of the set of GUIDs supported by
        the card.

    cguidInterfaceCount supplies the number of entries in the rgguidInterfaces
        array.  If rgguidInterfaces is NULL, then this value is ignored.

  bfCards receives a multi-string listing the smartcards introduced to the
        system by this user which match the supplied ATR string.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/

void
ListCards(
    DWORD dwScope,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT CBuffer &bfCards)
{
    CRegistry regCard;
    LPCTSTR szCard;
    CBuffer bfCardAtr;
    CBuffer bfCardList;

    bfCards.Reset();
    ListKnownKeys(dwScope, bfCardList, SCARD_REG_CARDS, SCARD_REG_TEMPLATES);
    for (szCard = FirstString(bfCardList);
         NULL != szCard;
         szCard = NextString(szCard))
    {
        try
        {
            FindKey(
                dwScope,
                szCard,
                regCard,
                SCARD_REG_CARDS,
                SCARD_REG_TEMPLATES);


            //
            // Does this card match the supplied ATR?
            //

            if ((NULL != pbAtr) && (0 != *pbAtr))
            {
                LPCBYTE pbCardAtr, pbCardMask;
                DWORD cbCardAtr, cbCardMask;

                pbCardAtr = regCard.GetBinaryValue(
                                        SCARD_REG_ATR,
                                        &cbCardAtr);
                bfCardAtr.Set(pbCardAtr, cbCardAtr);
                try
                {
                    pbCardMask = regCard.GetBinaryValue(
                                            SCARD_REG_ATRMASK,
                                            &cbCardMask);
                    if (cbCardAtr != cbCardMask)
                        continue;       // Invalid ATR/Mask combination.
                }
                catch (...)
                {
                    pbCardMask = NULL;  // No mask.
                }

                if (!AtrCompare(pbAtr, bfCardAtr, pbCardMask, cbCardAtr))
                    continue;           // ATRs invalid or don't match.
            }


            //
            // Does this card support the given interfaces?
            //

            if ((NULL != rgquidInterfaces) && (0 < cguidInterfaceCount))
            {
                DWORD cguidCrd;
                DWORD ix, jx;
                BOOL fAllInterfacesFound = TRUE;
                LPCGUID rgCrdInfs = (LPCGUID)regCard.GetBinaryValue(
                                            SCARD_REG_GUIDS,
                                            &cguidCrd);
                if ((0 != (cguidCrd % sizeof(GUID)))
                    || (0 == cguidCrd))
                    continue;           // Invalid GUID list.
                cguidCrd /= sizeof(GUID);
                for (ix = 0; ix < cguidInterfaceCount; ix += 1)
                {
                    for (jx = 0; jx < cguidCrd; jx += 1)
                    {
                        if (0 == MemCompare(
                                    (LPCBYTE)&rgCrdInfs[jx],
                                    (LPCBYTE)&rgquidInterfaces[ix],
                                    sizeof(GUID)))
                            break;
                    }
                    if (jx == cguidCrd)
                    {
                        fAllInterfacesFound = FALSE; // Unsupported interface
                        break;
                    }
                }
                if (!fAllInterfacesFound)
                    continue;
            }


            //
            // This card passes all the tests -- Include it.
            //

            MStrAdd(bfCards, szCard);
        }
        catch (...) {}
    }
    if (0 == bfCards.Length())
        bfCards.Set((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
}


/*++

GetCardTypeProviderName:

    This routine returns the value of a given Provider Name, by Id number, for
    the identified card type.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    szCardName supplies the name of the card type with which this provider name
        is associated.

    dwProviderId supplies the identifier for the provider associated with this
        card type.  Possible values are:

        SCARD_PROVIDER_SSP - The SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
            over 0x80000000 are available for use by the smart card vendors, and
            are card-specific.

    bfProvider receives the string identifying the provider.

Return Value:

    None

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/

void
GetCardTypeProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN DWORD dwProviderId,
    OUT CBuffer &bfProvider)
{
    LPCTSTR szProvValue;
    TCHAR szNumeric[36];
    CRegistry regCard;


    //
    // Find the Card definition closest to the caller.
    //

    FindKey(
        dwScope,
        szCardName,
        regCard,
        SCARD_REG_CARDS,
        SCARD_REG_TEMPLATES);


    //
    // Derive the Provider Value Name.
    //

    if (dwProviderId < l_dwProvMapMax)
    {
        szProvValue = l_szrgProvMap[dwProviderId];
        if (NULL == szProvValue)
            throw (DWORD)SCARD_E_INVALID_PARAMETER;
    }
    else if (0x80000000 <= dwProviderId)
    {
        _ultot(dwProviderId, szNumeric, 16);
        szProvValue = szNumeric;
    }
    else
        throw (DWORD)SCARD_E_INVALID_PARAMETER;


    //
    // Read the provider value.
    //

    switch (dwProviderId)
    {
    case 1: // SCARD_PROVIDER_SSP
    {
        CBuffer bfGuid(sizeof(GUID));

        bfProvider.Presize(40 * sizeof(TCHAR));
        regCard.GetValue(szProvValue, bfGuid);
        StringFromGuid(
            (LPCGUID)bfGuid.Access(),
            (LPTSTR)bfProvider.Access());
        bfProvider.Resize(
            (lstrlen((LPCTSTR)bfProvider.Access()) + 1) * sizeof(TCHAR),
            TRUE);
        break;
    }
    default:
        regCard.GetValue(szProvValue, bfProvider);
    }
}


/*++

GetReaderInfo:

    This routine returns all stored information regarding a given reader.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    szReader supplies the name of the reader of which info is to be extracted.

    pbfGroups receives the list of groups as a multistring.

    pbfDevice receives the device name.

Return Value:

    TRUE - Reader found
    FALSE - Reader not found

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

BOOL
GetReaderInfo(
    IN DWORD dwScope,
    IN LPCTSTR szReader,
    OUT CBuffer *pbfGroups,
    OUT CBuffer *pbfDevice)
{
    CRegistry regReader;


    //
    // Find the reader definition closest to the caller.
    //

    try
    {
        FindKey(dwScope, szReader, regReader, SCARD_REG_READERS);
    }
    catch (...)
    {
        return FALSE;
    }


    //
    // Look up all it's values.
    //

    if (NULL != pbfDevice)
    {
        // Device name
        try
        {
            regReader.GetValue(SCARD_REG_DEVICE, *pbfDevice);
        }
        catch (...)
        {
            pbfDevice->Reset();
        }
    }

    if (NULL != pbfGroups)
    {
        // Group list
        try
        {
            regReader.GetValue(SCARD_REG_GROUPS, *pbfGroups);
        }
        catch (...)
        {
            pbfGroups->Reset();
        }
    }

    return TRUE;
}


/*++

GetCardInfo:

    This routine finds the given card under the given scope, and returns all
    information associated with it.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    szCard supplies the name of the card for which info is to be extracted.

    pbfAtr receives the ATR string of the given card.  This parameter may be
        NULL if the ATR is not desired.

    pbfAtrMask receives the ATR mask of the given card, if any.  This parameter
        may be NULL if the value is not desired.

    pbfInterfaces receives the list of interfaces as an array of GUIDs for the
        given card, if any.  This parameter may be NULL if the value is not
        desired.

    pbfProvider receives the Primary Provider of the given card, if any.  This
        parameter may be NULL if the value is not desired.

Return Value:

    TRUE - The card was found, the returned data is valid.
    FALSE - The supplied card was not found.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/3/1996

--*/

BOOL
GetCardInfo(
    IN DWORD dwScope,
    IN LPCTSTR szCard,
    OUT CBuffer *pbfAtr,
    OUT CBuffer *pbfAtrMask,
    OUT CBuffer *pbfInterfaces,
    OUT CBuffer *pbfProvider)
{
    CRegistry regCard;


    //
    // Find the Card definition closest to the caller.
    //

    try
    {
        FindKey(
            dwScope,
            szCard,
            regCard,
            SCARD_REG_CARDS,
            SCARD_REG_TEMPLATES);
    }
    catch (...)
    {
        return FALSE;
    }


    //
    // Look up all it's values.
    //

    if (NULL != pbfAtr)
    {
        // Card ATR String
        try
        {
            regCard.GetValue(SCARD_REG_ATR, *pbfAtr);
        }
        catch (...)
        {
            pbfAtr->Reset();
        }
    }

    if (NULL != pbfAtrMask)
    {
        // Card ATR Comparison Mask
        try
        {
            regCard.GetValue(SCARD_REG_ATRMASK, *pbfAtrMask);
        }
        catch (...)
        {
            pbfAtrMask->Reset();
        }
    }

    if (NULL != pbfInterfaces)
    {
        // Supported Interface List
        try
        {
            regCard.GetValue(SCARD_REG_GUIDS, *pbfInterfaces);
        }
        catch (...)
        {
            pbfInterfaces->Reset();
        }
    }

    if (NULL != pbfProvider)
    {
        // Card Primary Provider
        try
        {
            regCard.GetValue(SCARD_REG_PPV, *pbfProvider);
        }
        catch (...)
        {
            pbfProvider->Reset();
        }
    }

    return TRUE;
}


#ifdef ENABLE_SCARD_TEMPLATES
/*++

ListCardTypeTemplates:

    This routine searches the template database looking for previously defined
    smart card templates against which the given card ATR matches.  If the ATR
    parameter is NULL, it returns a list of all templates.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    pbAtr supplies the ATR of a card to be matched against the known templates.

    bfTemplates receives a list of matching template names, as a multistring.

Return Value:

    TRUE - At least one template was found.
    FALSE - No matching templates were found.

Throws:

    Errors

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

BOOL
ListCardTypeTemplates(
    IN DWORD dwScope,
    IN LPCBYTE pbAtr,
    OUT CBuffer &bfTemplates)
{
    CRegistry regCard;
    LPCTSTR szCard;
    CBuffer bfCardAtr;
    CBuffer bfCardList;

    bfTemplates.Reset();
    ListKnownKeys(dwScope, bfCardList, SCARD_REG_TEMPLATES);
    for (szCard = FirstString(bfCardList);
         NULL != szCard;
         szCard = NextString(szCard))
    {
        try
        {
            FindKey(dwScope, szCard, regCard, SCARD_REG_TEMPLATES);


            //
            // Does this card match the supplied ATR?
            //

            if ((NULL != pbAtr) && (0 != *pbAtr))
            {
                LPCBYTE pbCardAtr, pbCardMask;
                DWORD cbCardAtr, cbCardMask;

                pbCardAtr = regCard.GetBinaryValue(
                                        SCARD_REG_ATR,
                                        &cbCardAtr);
                bfCardAtr.Set(pbCardAtr, cbCardAtr);
                try
                {
                    pbCardMask = regCard.GetBinaryValue(
                                            SCARD_REG_ATRMASK,
                                            &cbCardMask);
                    if (cbCardAtr != cbCardMask)
                        continue;       // Invalid ATR/Mask combination.
                }
                catch (...)
                {
                    pbCardMask = NULL;  // No mask.
                }

                if (!AtrCompare(pbAtr, bfCardAtr, pbCardMask, cbCardAtr))
                    continue;           // ATRs invalid or don't match.
            }


            //
            // This card passes all the tests -- Include it.
            //

            MStrAdd(bfTemplates, szCard);
        }
        catch (...) {}
    }
    if (0 == bfTemplates.Length())
    {
        bfTemplates.Set((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
        return FALSE;
    }
    else
        return TRUE;
}
#endif  // ENABLE_SCARD_TEMPLATES


//
////////////////////////////////////////////////////////////////////////////////
//
// Support Routines
//

/*++

ListKnownKeys:

    This routine lists all known keys of a given type within the current
    caller's scope.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    bfKeys receives a multistring of existing key names, sorted and stripped
        of duplicates.

    szUserList supplies the primary registry path from which key names are to
        be returned.

    szSystemList supplies an optional secondary path from which key names can
        be returned if the caller is running at system scope.

Return Value:

    TRUE - At least one was found
    FALSE - None were found.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/22/1998

--*/

static BOOL
ListKnownKeys(
    IN  DWORD dwScope,
    OUT CBuffer &bfKeys,
    IN  LPCTSTR szUserList,
    IN  LPCTSTR szSystemList)
{
    DWORD dwSpace, dwIndex, dwCount;
    CRegistry regScopeKey;
    CBuffer bfMyList;
    LPCTSTR rgszLists[2];


    //
    // Loop through introduced space, then if appropriate, template space.
    //

    rgszLists[0] = szUserList;
    rgszLists[1] = szSystemList;
    for (dwSpace = 0; 2 > dwSpace; dwSpace += 1)
    {
        if (NULL == rgszLists[dwSpace])
            continue;


        //
        // Loop through all the possible scopes, from highest to lowest.
        //

        for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
        {
            if (l_rgRegMap[dwIndex].dwScope >= dwScope)
            {

                //
                // If the caller is under this scope, then look for existing
                // Keys.
                //

                regScopeKey.Open(
                    l_rgRegMap[dwIndex].hKey,
                    rgszLists[dwSpace],
                    KEY_READ);
                if (SCARD_S_SUCCESS != regScopeKey.Status(TRUE))
                    continue;


                //
                // Pull out all it's subkey names.
                //

                for (dwCount = 0;; dwCount += 1)
                {
                    LPCTSTR szKey;

                    szKey = regScopeKey.Subkey(dwCount);
                    if (NULL == szKey)
                        break;

                    bfMyList.Append(
                        (LPBYTE)szKey,
                        (lstrlen(szKey) + 1) * sizeof(TCHAR));
                }
            }
        }


        //
        // Don't go on to the system list unless we're at system scope.
        //

        if (SCARD_SCOPE_SYSTEM != dwScope)
            break;
    }


    //
    // Sort the list, and remove duplicates.
    //

    bfMyList.Append((LPBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
    MStringSort(bfMyList, bfKeys);
    return (2 * sizeof(TCHAR) < bfKeys.Length());
}



/*++

FindKey:

    This routine finds the named key closest in scope to the caller.

Arguments:

    dwScope supplies an indicator of the scope of the operation.  Possible
        values are:

        SCARD_SCOPE_USER - The current user's definitions are used.
        SCARD_SCOPE_TERMINAL - The terminal's definitions are used.
        SCARD_SCOPE_SYSTEM - The system's definitions are used.

    szKey supplies the name of the key to be found.

    regKey receives initialization to reference the named key.

    szUserList supplies the primary registry path from which key names are to
        be returned.

    szSystemList supplies an optional secondary path from which key names can
        be returned if the caller is running at system scope.

Return Value:

    TRUE - The key was found.
    FALSE - No such key was found.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/22/1998

--*/

static void
FindKey(
    IN  DWORD dwScope,
    IN LPCTSTR szKey,
    OUT CRegistry &regKey,
    IN  LPCTSTR szUserList,
    IN  LPCTSTR szSystemList)
{
    DWORD dwSpace, dwIndex;
    CRegistry regScopeKey;
    LPCTSTR rgszLists[2];


    //
    // Loop through introduced space, then if appropriate, template space.
    //

    rgszLists[0] = szUserList;
    rgszLists[1] = szSystemList;
    for (dwSpace = 0; 2 > dwSpace; dwSpace += 1)
    {
        if (NULL == rgszLists[dwSpace])
            continue;


        //
        // Loop through all the possible scopes, from highest to lowest.
        //

        for (dwIndex = 0; l_dwRegMapMax > dwIndex; dwIndex += 1)
        {
            if (l_rgRegMap[dwIndex].dwScope >= dwScope)
            {

                //
                // If the caller is under this scope, then look for an
                // existing Key.
                //

                regScopeKey.Open(
                    l_rgRegMap[dwIndex].hKey,
                    rgszLists[dwSpace],
                    KEY_READ);
                if (SCARD_S_SUCCESS != regScopeKey.Status(TRUE))
                    continue;

                regKey.Open(regScopeKey, szKey, KEY_READ);
                if (SCARD_S_SUCCESS != regKey.Status(TRUE))
                    continue;

                //
                // We've found such a key.  Return immediately.
                //

                return;
            }
        }


        //
        // Don't go on to the system list unless we're at system scope.
        //

        if (SCARD_SCOPE_SYSTEM != dwScope)
            break;
    }


    //
    // We didn't find any such key.
    //

    throw (DWORD)ERROR_FILE_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\common\misc.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    misc

Abstract:

    This module contains an interesting collection of routines that are
    generally useful in the Calais context, but don't seem to fit anywhere else.

Author:

    Doug Barlow (dbarlow) 11/14/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <Windows.h>
#include <SCardLib.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>


/*++

MemCompare:

    This routine compares memory sections.

Arguments:

    pbOne supplies the address of the first block of memory

    pbTwo supplies the address of the second block of memory

    cbLength supplies the length of the two memory segments.

Return Value:

    the difference between the first two differing bytes, or zero if they're the
    identical.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/26/1996

--*/

int
MemCompare(
    IN LPCBYTE pbOne,
    IN LPCBYTE pbTwo,
    IN DWORD cbLength)
{
    for (DWORD index = 0; index < cbLength; index += 1)
    {
        if (*pbOne++ != *pbTwo++)
            return (int)*(--pbOne) - (int)*(--pbTwo);
    }
    return 0;
}


/*++

MStrAdd:

    This method adds a string to the end of a multistring contained in a
    CBuffer.  The CBuffer may be empty, in which case its value becomes a
    multistring with the single string element.

Arguments:

    bfMsz supplies the multistring to be modified.

    szAdd supplies the string to append.

Return Value:

    the number of strings in the resulting multistring.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/29/1997

--*/

DWORD
MStrAdd(
    IN OUT CBuffer &bfMsz,
    IN LPCSTR szAdd)
{
    DWORD dwLen, dwAddLen;
    CBuffer bfTmp;

    dwLen = bfMsz.Length();
    if (0 < dwLen)
    {
        ASSERT(2 * sizeof(TCHAR) <= dwLen);
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - sizeof(TCHAR))));
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - 2 * sizeof(TCHAR))));
        dwLen -= sizeof(TCHAR);
    }

    dwAddLen = MoveString(bfTmp, szAdd);
    bfMsz.Presize((dwLen + dwAddLen + 1) * sizeof(TCHAR), TRUE);
    bfMsz.Resize(dwLen, TRUE);  // Trim one trailing NULL, if any.
    bfMsz.Append(bfTmp.Access(), dwAddLen * sizeof(TCHAR));
    bfMsz.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
    return MStrLen(bfMsz);
}

DWORD
MStrAdd(
    IN OUT CBuffer &bfMsz,
    IN LPCWSTR szAdd)
{
    DWORD dwLen, dwAddLen;
    CBuffer bfTmp;

    dwLen = bfMsz.Length();
    if (0 < dwLen)
    {
        ASSERT(2 * sizeof(TCHAR) <= dwLen);
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - sizeof(TCHAR))));
        ASSERT(0 == *(LPCTSTR)(bfMsz.Access(dwLen - 2 * sizeof(TCHAR))));
        dwLen -= sizeof(TCHAR);
    }

    dwAddLen = MoveString(bfTmp, szAdd);
    bfMsz.Presize((dwLen + dwAddLen + 2) * sizeof(TCHAR), TRUE);
    bfMsz.Resize(dwLen, TRUE);  // Trim one trailing NULL, if any.
    bfMsz.Append(bfTmp.Access(), dwAddLen * sizeof(TCHAR));
    bfMsz.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
    return MStrLen(bfMsz);
}


/*++

MStrLen:

    This routine determines the length of a Multi-string, in characters.

Arguments:

    mszString supplies the string to compute the length of.

Return Value:

    The length of the string, in characters, including trailing zeroes.

Author:

    Doug Barlow (dbarlow) 11/14/1996

--*/

DWORD
MStrLen(
    LPCSTR mszString)
{
    DWORD dwLen, dwTotLen = 0;

    for (;;)
    {
        dwLen = lstrlenA(&mszString[dwTotLen]);
        dwTotLen += dwLen + 1;
        if (0 == dwLen)
            break;
    }
    if (2 > dwTotLen)
        dwTotLen = 2;  // Include the second trailing null character.
    return dwTotLen;
}

DWORD
MStrLen(
    LPCWSTR mszString)
{
    DWORD dwLen, dwTotLen = 0;

    for (;;)
    {
        dwLen = lstrlenW(&mszString[dwTotLen]);
        dwTotLen += dwLen + 1;
        if (0 == dwLen)
            break;
    }
    if (2 > dwTotLen)
        dwTotLen = 2;  // Include the second trailing null character.
    return dwTotLen;
}


/*++

FirstString:

    This routine returns a pointer to the first string in a multistring, or NULL
    if there aren't any.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the first null-terminated string in the structure, or NULL if
    there are no strings.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

LPCTSTR
FirstString(
    IN LPCTSTR szMultiString)
{
    LPCTSTR szFirst = NULL;

    try
    {
        if (0 != *szMultiString)
            szFirst = szMultiString;
    }
    catch (...) {}

    return szFirst;
}



/*++

NextString:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the current string in a
    multi-string structure, it returns the next string, or NULL if no other
    strings follow the current string.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the next Null-terminated string in the structure, or NULL if
    no more strings follow.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/

LPCTSTR
NextString(
    IN LPCTSTR szMultiString)
{
    LPCTSTR szNext;

    try
    {
        DWORD cchLen = lstrlen(szMultiString);
        if (0 == cchLen)
            szNext = NULL;
        else
        {
            szNext = szMultiString + cchLen + 1;
            if (0 == *szNext)
                szNext = NULL;
        }
    }

    catch (...)
    {
        szNext = NULL;
    }

    return szNext;
}


/*++

StringIndex:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the starting address of a
    multi-string structure, it returns the nth string in the structure, where n
    is a zero-based index.  If the supplied value for n exceeds the number of
    strings in the structure, NULL is returned.

Arguments:

    szMultiString - This supplies the address of the Multi-string structure.

    dwIndex - This supplies the index value into the structure.

Return Value:

    The address of the specified Null-terminated string in the structure, or
    NULL if dwIndex indexes beyond the end of the structure.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/

LPCTSTR
StringIndex(
    IN LPCTSTR szMultiString,
    IN DWORD dwIndex)
{
    LPCTSTR szCurrent = szMultiString;

    try
    {
        DWORD index;
        for (index = 0; (index < dwIndex) && (NULL != szCurrent); index += 1)
            szCurrent = NextString(szCurrent);
    }

    catch (...)
    {
        szCurrent = NULL;
    }

    return szCurrent;
}


/*++

MStringCount:

    This routine returns the count of the number of strings in a multistring

Arguments:

    mszInString supplies the input string to be sorted.

Return Value:

    The count of strings

Throws:

    None

Author:

    Ross Garmoe (v-rossg) 12/05/1996

--*/

DWORD
MStringCount(
    LPCTSTR mszInString)
{
    LPCTSTR szCurrent;
        DWORD   cStr = 0;

    //
    // Count the strings
    //

    for (szCurrent = FirstString(mszInString);
         NULL != szCurrent;
         szCurrent = NextString(szCurrent))
        cStr++;

        return (cStr);
}


/*++

MStringSort:

    This routine rearranges a multistring so that the elements are sorted and
    duplicates are eliminated.

Arguments:

    mszInString supplies the input string to be sorted.

    bfOutString receives the sorted string.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringSort(
    LPCTSTR mszInString,
    CBuffer &bfOutString)
{
    LPCTSTR szCurrent;
    LPCTSTR szTmp;
    CDynamicArray<const TCHAR> rgszElements;
    DWORD ix, jx, kx, nMax;
    int nDiff;


    //
    // Set up for the sort.
    //

    for (szCurrent = FirstString(mszInString);
         NULL != szCurrent;
         szCurrent = NextString(szCurrent))
        rgszElements.Add(szCurrent);


    //
    // Do a simple bubble sort, eliminating duplicates.  (We don't use qsort
    // here, to ensure that the Run-time library doesn't get pulled in.)
    //

    nMax = rgszElements.Count();
    if (0 == nMax)
    {
        bfOutString.Set((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
        return (nMax);     // No elements implies nothing to do.
    }
    for (ix = 0; ix < nMax; ix += 1)
    {
        for (jx = nMax - 1; ix < jx; jx -= 1)
        {
            nDiff = lstrcmpi(rgszElements[jx - 1], rgszElements[jx]);
            if (0 < nDiff)
            {
                szTmp = rgszElements.Get(jx - 1);
                rgszElements.Set(jx - 1, rgszElements.Get(jx));
                rgszElements.Set(jx, szTmp);
            }
            else if (0 == nDiff)
            {
                for (kx = jx; kx < nMax - 1; kx += 1)
                    rgszElements.Set(kx, rgszElements.Get(kx + 1));
                rgszElements.Set(nMax -1, NULL);
                nMax -= 1;
            }
            // else 0 > nDiff, which is what we want.
        }
    }


    //
    // Write the sorted strings to the output buffer.
    //

    jx = 0;
    for (ix = 0; ix < nMax; ix += 1)
        jx += lstrlen(rgszElements[ix]) + 1;
    bfOutString.Presize((jx + 2) * sizeof(TCHAR));
    bfOutString.Reset();

    for (ix = 0; ix < nMax; ix += 1)
    {
        szTmp = rgszElements[ix];
        bfOutString.Append(
                (LPCBYTE)szTmp,
                (lstrlen(szTmp) + 1) * sizeof(TCHAR));
    }
    bfOutString.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));
    return (nMax);
}


/*++

MStringMerge:

    This routine merges two Multistrings into a single multistring without
    duplicate entries.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the combined strings.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringMerge(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    DWORD dwLenOne = (MStrLen(mszOne) - 1) * sizeof(TCHAR);
    DWORD dwLenTwo = MStrLen(mszTwo) * sizeof(TCHAR);
    CBuffer bfTmp;

    bfTmp.Presize((dwLenOne + dwLenTwo) * sizeof(TCHAR));
    bfTmp.Set((LPCBYTE)mszOne, dwLenOne);
    bfTmp.Append((LPCBYTE)mszTwo, dwLenTwo);

    return MStringSort((LPCTSTR)bfTmp.Access(), bfOutString);
}


/*++

MStringCommon:

    This routine finds strings which are common to both supplied multistrings,
    and returns the list of commonalities.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the intersection of the strings.

Return Value:

    Count of strings in the multistring

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringCommon(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    CBuffer bfOne, bfTwo;
    LPCTSTR szOne, szTwo;
    DWORD dwStrings = 0;
    int nDiff;

    bfOutString.Reset();
    MStringSort(mszOne, bfOne);
    MStringSort(mszTwo, bfTwo);
    szOne = FirstString(bfOne);
    szTwo = FirstString(bfTwo);

    while ((NULL != szOne) && (NULL != szTwo))
    {
        nDiff = lstrcmpi(szOne, szTwo);
        if (0 > nDiff)
            szOne = NextString(szOne);
        else if (0 < nDiff)
            szTwo = NextString(szTwo);
        else    // a match!
        {
            bfOutString.Append(
                (LPCBYTE)szOne,
                (lstrlen(szOne) + 1) * sizeof(TCHAR));
            szOne = NextString(szOne);
            szTwo = NextString(szTwo);
            dwStrings += 1;
        }
    }
    if (0 == dwStrings)
        bfOutString.Append((LPCBYTE)TEXT("\000"), 2 * sizeof(TCHAR));
    else
        bfOutString.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));
    return dwStrings;
}


/*++

MStringRemove:

    This routine scans the first supplied multistring, removing any entries that
    exist in the second string.

Arguments:

    mszOne supplies the first multistring.

    mszTwo supplies the secong multistring.

    bfOutString receives the value of the first string without the second
        string.

Return Value:

    Number of strings in output buffer

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

DWORD
MStringRemove(
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString)
{
    CBuffer bfOne, bfTwo;
    LPCTSTR szOne, szTwo;
    int nDiff;
        DWORD   cStr = 0;

    bfOutString.Reset();
    MStringSort(mszOne, bfOne);
    MStringSort(mszTwo, bfTwo);
    szOne = FirstString(bfOne);
    szTwo = FirstString(bfTwo);

    while ((NULL != szOne) && (NULL != szTwo))
    {
        nDiff = lstrcmpi(szOne, szTwo);
        if (0 > nDiff)
        {
            bfOutString.Append(
                (LPCBYTE)szOne,
                (lstrlen(szOne) + 1) * sizeof(TCHAR));
            szOne = NextString(szOne);
                        cStr++;
        }
        else if (0 < nDiff)
        {
            szTwo = NextString(szTwo);
        }
        else    // a match!
        {
            szOne = NextString(szOne);
            szTwo = NextString(szTwo);
        }
    }
    while (NULL != szOne)
    {
                bfOutString.Append(
                        (LPCBYTE)szOne,
                        (lstrlen(szOne) + 1) * sizeof(TCHAR));
                        szOne = NextString(szOne);
                cStr++;
    }
    bfOutString.Append(
        (LPCBYTE)TEXT("\000"),
        (DWORD)(0 == cStr ? 2 * sizeof(TCHAR) :sizeof(TCHAR)));
    return cStr;
}


/*++

ParseAtr:

    This routine parses an ATR string.

Arguments:

    pbAtr supplies the ATR string.

    pdwAtrLen receives the length of the ATR string.  This is an optional
        parameter, and may be NULL.

    pdwHistOffset receives the offset into the ATR string at which the history
        string starts; i.e., the history string is at pbAtr[*pdwOffset].

    pcbHisory receives the length of the history string, in bytes.

    cbMaxLen supplies the maximum length of this ATR string.  Typically this is
        33, but you can restrict it to less by setting this parameter.

Return Value:

    TRUE - Valid ATR
    FALSE - Invalid ATR

Author:

    Doug Barlow (dbarlow) 11/14/1996

--*/

BOOL
ParseAtr(
    LPCBYTE pbAtr,
    LPDWORD pdwAtrLen,
    LPDWORD pdwHistOffset,
    LPDWORD pcbHistory,
    DWORD cbMaxLen)
{
    static const BYTE rgbYMap[] = {
        0,      // 0000
        1,      // 0001
        1,      // 0010
        2,      // 0011
        1,      // 0100
        2,      // 0101
        2,      // 0110
        3,      // 0111
        1,      // 1000
        2,      // 1001
        2,      // 1010
        3,      // 1011
        2,      // 1100
        3,      // 1101
        3,      // 1110
        4 };    // 1111
    DWORD dwHistLen, dwHistOffset, dwTDLen, dwIndex, dwAtrLen;
    BOOL fTck = FALSE;


    ASSERT(33 >= cbMaxLen);
    try
    {


        //
        // Get the ATR string, if any.
        //

        if ((0x3b != pbAtr[0]) && (0x3f != pbAtr[0]))
            throw (DWORD)ERROR_NOT_SUPPORTED;
        dwHistLen = pbAtr[1] & 0x0f;
        dwIndex = 1;
        dwTDLen = 0;
        for (;;)
        {
            dwIndex += dwTDLen;
            dwTDLen = rgbYMap[(pbAtr[dwIndex] >> 4) & 0x0f];
            if (cbMaxLen < dwIndex + dwTDLen + dwHistLen)
                throw (DWORD)ERROR_INVALID_DATA;
            if (0 == dwTDLen)
                break;
            if (0 != (pbAtr[dwIndex] & 0x80))
            {
                if (0 != (pbAtr[dwIndex + dwTDLen] & 0x0f))
                    fTck = TRUE;
            }
            else
                break;
        }
        dwIndex += dwTDLen + 1;
        dwHistOffset = dwIndex;
        dwAtrLen = dwIndex + dwHistLen + (fTck ? 1 : 0);
        if (cbMaxLen < dwAtrLen)
            throw (DWORD)ERROR_INVALID_DATA;
        if (fTck)
        {
            BYTE bXor = 0;
            for (dwIndex = 1; dwIndex < dwAtrLen; dwIndex += 1)
                bXor ^= pbAtr[dwIndex];
            if (0 != bXor)
                throw (DWORD)ERROR_INVALID_DATA;
        }
    }

    catch (...)
    {
        return FALSE;
    }


    //
    // Let the caller in on what we know.
    //

    if (NULL != pdwAtrLen)
        *pdwAtrLen = dwAtrLen;
    if (NULL != pdwHistOffset)
        *pdwHistOffset = dwHistOffset;
    if (NULL != pcbHistory)
        *pcbHistory = dwHistLen;
    return TRUE;
}


/*++

AtrCompare:

    This routine compares two ATRs for equality, given an optional ATR mask.  If
    the mask is supplied, ATR1 XORed against the mask must match ATR2.

Arguments:

    pbAtr1 supplies the first ATR.

    pbAtr2 supplies the second ATR,

    pbMask supplies the ATR mask associated with the 2nd ATR.  If this
        parameter is NULL, no mask is used.

    cbAtr2 supplies the length of ATR2 and it's mask.  This value may be zero
        if the length should be derived from ATR2.

Return Value:

    TRUE - They are identical
    FALSE - They differ.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/

BOOL
AtrCompare(
    LPCBYTE pbAtr1,
    LPCBYTE pbAtr2,
    LPCBYTE pbMask,
    DWORD cbAtr2)
{
    DWORD dwAtr1Len = 0;
    DWORD dwAtr2Len = 0;


    //
    // Trivial checks.
    //

    if (!ParseAtr(pbAtr1, &dwAtr1Len))
        return FALSE;   // Invalid ATR.
    if ((NULL == pbMask) || (0 == cbAtr2))
    {
        if (!ParseAtr(pbAtr2, &dwAtr2Len))
            return FALSE;   // Invalid ATR.
        if ((0 != cbAtr2) && (dwAtr2Len != cbAtr2))
            return FALSE;   // Lengths don't match.
        if (dwAtr1Len != dwAtr2Len)
            return FALSE;   // Different lengths.
    }
    else
    {
        dwAtr2Len = cbAtr2;
        if (dwAtr1Len != dwAtr2Len)
            return FALSE;   // Different lengths.
    }


    //
    // Apply the mask, if any.
    //

    if (NULL != pbMask)
    {
        for (DWORD index = 0; index < dwAtr2Len; index += 1)
        {
            if ((pbAtr1[index] & pbMask[index]) != pbAtr2[index])
                return FALSE;   // Byte mismatch.
        }
    }
    else
    {
        for (DWORD index = 0; index < dwAtr2Len; index += 1)
        {
            if (pbAtr1[index] != pbAtr2[index])
                return FALSE;   // Byte mismatch.
        }
    }


    //
    // If we get here, they match.
    //

    return TRUE;
}



/*++

MoveString:

    This routine moves an ASCII or UNICODE string into a buffer, converting to
    the character set in use.

Arguments:

    bfDst receives the string, converted to TCHARs, and NULL terminated.

    szSrc supplies the original string.

    dwLength supplies the length of the string, with or without trailing
        nulls, in characters.  A -1 value implies the length should be
        computed based on a trailing null.

Return Value:

    The actual number of characters in the resultant string, including the
    trailing null.

Throws:

    Errors encountered, as DWORDS.

Author:

    Doug Barlow (dbarlow) 2/12/1997

--*/

DWORD
MoveString(
    CBuffer &bfDst,
    LPCSTR szSrc,
    DWORD dwLength)
{
    if ((DWORD)(-1) == dwLength)
        dwLength = lstrlenA(szSrc);
    else
    {
        while ((0 < dwLength) && (0 == szSrc[dwLength - 1]))
            dwLength -= 1;
    }

#ifdef UNICODE
    DWORD dwResultLength;

    dwResultLength =
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            dwLength,
            NULL,
            0);
    if (0 == dwLength)
        throw GetLastError();
    bfDst.Presize((dwResultLength + 1) * sizeof(TCHAR));
    dwResultLength =
        MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            dwLength,
            (LPTSTR)bfDst.Access(),
            bfDst.Space()/sizeof(TCHAR) - 1);
    if (0 == dwLength)
        throw GetLastError();
    bfDst.Resize(dwResultLength * sizeof(TCHAR), TRUE);
    dwLength = dwResultLength;
#else
    bfDst.Presize((dwLength + 1) * sizeof(TCHAR));
    bfDst.Set((LPCBYTE)szSrc, dwLength * sizeof(TCHAR));
#endif
    bfDst.Append((LPCBYTE)(TEXT("\000")), sizeof(TCHAR));
    dwLength += 1;
    return dwLength;
}

DWORD
MoveString(
    CBuffer &bfDst,
    LPCWSTR szSrc,
    DWORD dwLength)
{
    if ((DWORD)(-1) == dwLength)
        dwLength = lstrlenW(szSrc);
    else
    {
        while ((0 < dwLength) && (0 == szSrc[dwLength - 1]))
            dwLength -= 1;
    }

#ifndef UNICODE
    DWORD dwResultLength =
        WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            dwLength,
            NULL,
            0,
            NULL,
            NULL);
    if (0 == dwResultLength)
        throw GetLastError();
    bfDst.Presize((dwResultLength + 1) * sizeof(TCHAR));
    dwResultLength =
        WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            dwLength,
            (LPSTR)bfDst.Access(),
            bfDst.Space()/sizeof(TCHAR) - 1,
            NULL,
            NULL);
    if (0 == dwResultLength)
        throw GetLastError();
    bfDst.Resize(dwResultLength * sizeof(TCHAR), TRUE);
    dwLength = dwResultLength;
#else
    bfDst.Presize((dwLength + 1) * sizeof(TCHAR));
    bfDst.Set((LPCBYTE)szSrc, dwLength * sizeof(TCHAR));
#endif
    bfDst.Append((LPCBYTE)(TEXT("\000")), sizeof(TCHAR));
    dwLength += 1;
    return dwLength;
}


/*++

MoveToAnsiString:

    This routine moves the internal string representation to an ANSI output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the string.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input string.

    cchLength supplies the length of the input string, with or without trailing
        nulls.  A -1 value implies the length should be computed based on a
        trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    null.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/14/1997

--*/

DWORD
MoveToAnsiString(
    LPSTR szDst,
    LPCTSTR szSrc,
    DWORD cchLength)
{
    if ((DWORD)(-1) == cchLength)
        cchLength = lstrlen(szSrc);
    else
    {
        while ((0 < cchLength) && (0 == szSrc[cchLength - 1]))
            cchLength -= 1;
    }

#ifdef UNICODE
    if (0 == *szSrc)
        cchLength = 1;
    else if (NULL == szDst)
    {
        cchLength =
            WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            cchLength,
            NULL,
            0,
            NULL,
            NULL);
        if (0 == cchLength)
            throw GetLastError();
        cchLength += 1;
    }
    else
    {
        cchLength =
            WideCharToMultiByte(
            GetACP(),
            WC_COMPOSITECHECK,
            szSrc,
            cchLength,
            szDst,
            cchLength,
            NULL,
            NULL);
        if (0 == cchLength)
            throw GetLastError();
        szDst[cchLength++] = 0;
    }
#else
    if (0 < cchLength)
    {
        cchLength += 1;
        if (NULL != szDst)
            CopyMemory(szDst, szSrc, cchLength * sizeof(TCHAR));
    }
#endif
    return cchLength;
}


/*++

MoveToUnicodeString:

    This routine moves the internal string representation to a UNICODE output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the string.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input string.

    cchLength supplies the length of the input string, with or without trailing
        nulls.  A -1 value implies the length should be computed based on a
        trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    null.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/14/1997

--*/

DWORD
MoveToUnicodeString(
    LPWSTR szDst,
    LPCTSTR szSrc,
    DWORD cchLength)
{
    if ((DWORD)(-1) == cchLength)
        cchLength = lstrlen(szSrc);
    else
    {
        while ((0 < cchLength) && (0 == szSrc[cchLength - 1]))
            cchLength -= 1;
    }

#ifndef UNICODE
    if (0 == *szSrc)
        cchLength = 1;
    else if (NULL == szDst)
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            NULL,
            0);
        if (0 == cchLength)
            throw GetLastError();
        cchLength += 1;
    }
    else
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            szDst,
            cchLength);
        if (0 == cchLength)
            throw GetLastError();
        szDst[cchLength++] = 0;
    }
#else
    cchLength += 1;
    if (NULL != szDst)
        CopyMemory(szDst, szSrc, cchLength * sizeof(TCHAR));
#endif
    return cchLength;
}


/*++

MoveToAnsiMultistring:

    This routine moves the internal multistring representation to an ANSI output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the multistring.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input multistring.

    cchLength supplies the length of the input string, in characters, with or
        without trailing nulls.  A -1 value implies the length should be
        computed based on a double trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    nulls.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
MoveToAnsiMultiString(
    LPSTR mszDst,
    LPCTSTR mszSrc,
    DWORD cchLength)
{
    DWORD dwLen;

    if ((DWORD)(-1) == cchLength)
        cchLength = MStrLen(mszSrc);
    dwLen = MoveToAnsiString(mszDst, mszSrc, cchLength);
    if (0 == dwLen)
    {
        if (NULL != mszDst)
            mszDst[0] = mszDst[1] = 0;
        dwLen = 2;
    }
    else
    {
        if (NULL != mszDst)
            mszDst[dwLen] = 0;
        dwLen += 1;
    }
    return dwLen;
}


/*++

MoveToUnicodeMultistring:

    This routine moves the internal multistring representation to a
    Unicode output buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the multistring.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input multistring.

    cchLength supplies the length of the input string, in characters, with or
        without trailing nulls.  A -1 value implies the length should be
        computed based on a double trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    nulls.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
MoveToUnicodeMultiString(
    LPWSTR mszDst,
    LPCTSTR mszSrc,
    DWORD cchLength)
{
    DWORD dwLen;

    if ((DWORD)(-1) == cchLength)
        cchLength = MStrLen(mszSrc);
    dwLen = MoveToUnicodeString(mszDst, mszSrc, cchLength);
    if (NULL != mszDst)
        mszDst[dwLen] = 0;
    dwLen += 1;
    return dwLen;
}


/*++

ErrorString:

    This routine does it's very best to translate a given error code into a
    text message.  Any trailing non-printable characters are striped from the
    end of the text message, such as carriage returns and line feeds.

Arguments:

    dwErrorCode supplies the error code to be translated.

Return Value:

    The address of a freshly allocated text string.  Use FreeErrorString to
    dispose of it.

Throws:

    Errors are thrown as DWORD status codes.

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

LPCTSTR
ErrorString(
    DWORD dwErrorCode)
{
    LPTSTR szErrorString = NULL;

    try
    {
        DWORD dwLen;
        LPTSTR szLast;

        dwLen = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwErrorCode,
                    LANG_NEUTRAL,
                    (LPTSTR)&szErrorString,
                    0,
                    NULL);
        if (0 == dwLen)
        {
            ASSERT(NULL == szErrorString);
            dwLen = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        GetModuleHandle(NULL),
                        dwErrorCode,
                        LANG_NEUTRAL,
                        (LPTSTR)&szErrorString,
                        0,
                        NULL);
            if (0 == dwLen)
            {
                ASSERT(NULL == szErrorString);
                szErrorString = (LPTSTR)LocalAlloc(
                                        LMEM_FIXED,
                                        32 * sizeof(TCHAR));
                if (NULL == szErrorString)
                    throw (DWORD)SCARD_E_NO_MEMORY;
                _stprintf(szErrorString, TEXT("0x%08x"), dwErrorCode);
            }
        }

        ASSERT(NULL != szErrorString);
        for (szLast = szErrorString + lstrlen(szErrorString) - 1;
             szLast > szErrorString;
             szLast -= 1)
         {
            if (_istgraph(*szLast))
                break;
            *szLast = 0;
         }
    }
    catch (...)
    {
        FreeErrorString(szErrorString);
        throw;
    }

    return szErrorString;
}


/*++

FreeErrorString:

    This routine frees the Error String allocated by the ErrorString service.

Arguments:

    szErrorString supplies the error string to be deallocated.

Return Value:

    None

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}


/*++

SelectString:

    This routine compares a given string to a list of possible strings, and
    returns the index of the string that matches.  The comparison is done case
    insensitive, and abbreviations are allowed, as long as they're unique.

Arguments:

    szSource supplies the string to be compared against all other strings.

    Following strings supply a list of strings against which the source string
        can be compared.  The last parameter must be NULL.

Return Value:

    0 - No match, or ambiguous match.
    1-n - The source string matches the indexed template string.

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

DWORD
SelectString(
    LPCTSTR szSource,
    ...)
{
    va_list vaArgs;
    DWORD cchSourceLen;
    DWORD dwReturn = 0;
    DWORD dwIndex = 1;
    LPCTSTR szTpl;


    va_start(vaArgs, szSource);


    //
    //  Step through each input parameter until we find an exact match.
    //

    cchSourceLen = lstrlen(szSource);
    if (0 == cchSourceLen)
        return 0;       //  Empty strings don't match anything.
    szTpl = va_arg(vaArgs, LPCTSTR);
    while (NULL != szTpl)
    {
        if (0 == _tcsncicmp(szTpl, szSource, cchSourceLen))
        {
            if (0 != dwReturn)
            {
                dwReturn = 0;
                break;
            }
            dwReturn = dwIndex;
        }
        szTpl = va_arg(vaArgs, LPCTSTR);
        dwIndex += 1;
    }
    va_end(vaArgs);
    return dwReturn;
}


/*++

StringFromGuid:

    This routine converts a GUID into its corresponding string representation.
    It's here so that it's not necessary to link all of OleBase into WinSCard.
    Otherwise, we'd just use StringFromCLSID.

Arguments:

    pguidSource supplies the GUID to convert.

    szGuid receives the GUID as a string.  This string is assumed to be at
        least 39 characters long.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/20/1998

--*/

void
StringFromGuid(
    IN LPCGUID pguidResult,
    OUT LPTSTR szGuid)
{

    //
    // The following placement assumes Little Endianness.
    // {1D92589A-91E4-11d1-93AA-00C04FD91402}
    // 0123456789012345678901234567890123456789
    //           1         2         3
    //

    static const WORD wPlace[sizeof(GUID)]
        = { 8, 6, 4, 2, 13, 11, 18, 16, 21, 23, 26, 28, 30, 32, 34, 36 };
    static const WORD wPunct[]
        = { 0,         9,         14,        19,        24,        37,        38 };
    static const TCHAR chPunct[]
        = { TEXT('{'), TEXT('-'), TEXT('-'), TEXT('-'), TEXT('-'), TEXT('}'), TEXT('\000') };
    DWORD dwI, dwJ;
    TCHAR ch;
    LPTSTR pch;
    LPBYTE pbGuid = (LPBYTE)pguidResult;
    BYTE bVal;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        bVal = pbGuid[dwI];
        pch = &szGuid[wPlace[dwI]];
        for (dwJ = 0; dwJ < 2; dwJ += 1)
        {
            ch = bVal & 0x0f;
            ch += TEXT('0');
            if (ch > TEXT('9'))
                ch += TEXT('A') - (TEXT('9') + 1);
            *pch-- = ch;
            bVal >>= 4;
        }
    }

    dwI = 0;
    do
    {
        szGuid[wPunct[dwI]] = chPunct[dwI];
    } while (0 != chPunct[dwI++]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\common\ntacls.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    NTacls

Abstract:

    This module implements the CSecurityAttribute class.  It's job is to
    encapsulate the NT security descriptors as needed by Calais.

Author:

    Doug Barlow (dbarlow) 1/24/1997

Environment:

    Windows NT, Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <CalaisLb.h>


const CSecurityDescriptor::SecurityId
    CSecurityDescriptor::SID_Null =        { SECURITY_NULL_SID_AUTHORITY,    1, SECURITY_NULL_RID,           0 },
    CSecurityDescriptor::SID_World =       { SECURITY_WORLD_SID_AUTHORITY,   1, SECURITY_WORLD_RID,          0 },
    CSecurityDescriptor::SID_Local =       { SECURITY_LOCAL_SID_AUTHORITY,   1, SECURITY_LOCAL_RID,          0 },
    CSecurityDescriptor::SID_Owner =       { SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_OWNER_RID,  0 },
    CSecurityDescriptor::SID_Group =       { SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_GROUP_RID,  0 },
    CSecurityDescriptor::SID_Admins =      { SECURITY_NT_AUTHORITY,          2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS },
    CSecurityDescriptor::SID_SrvOps =      { SECURITY_NT_AUTHORITY,          2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_SYSTEM_OPS },
    CSecurityDescriptor::SID_DialUp =      { SECURITY_NT_AUTHORITY,          1, SECURITY_DIALUP_RID,         0 },
    CSecurityDescriptor::SID_Network =     { SECURITY_NT_AUTHORITY,          1, SECURITY_NETWORK_RID,        0 },
    CSecurityDescriptor::SID_Batch =       { SECURITY_NT_AUTHORITY,          1, SECURITY_BATCH_RID,          0 },
    CSecurityDescriptor::SID_Interactive = { SECURITY_NT_AUTHORITY,          1, SECURITY_INTERACTIVE_RID,    0 },
    CSecurityDescriptor::SID_Service =     { SECURITY_NT_AUTHORITY,          1, SECURITY_SERVICE_RID,        0 },
    CSecurityDescriptor::SID_System =      { SECURITY_NT_AUTHORITY,          1, SECURITY_LOCAL_SYSTEM_RID,   0 },
    CSecurityDescriptor::SID_LocalService ={ SECURITY_NT_AUTHORITY,          1, SECURITY_LOCAL_SERVICE_RID,  0 },
    CSecurityDescriptor::SID_SysDomain =   { SECURITY_NT_AUTHORITY,          1, SECURITY_BUILTIN_DOMAIN_RID, 0 };

CSecurityDescriptor::CSecurityDescriptor()
{
    m_pSD = NULL;
    m_pOwner = NULL;
    m_pGroup = NULL;
    m_pDACL = NULL;
    m_pSACL= NULL;
    m_fInheritance = FALSE;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
    if (m_pSD)
        delete m_pSD;
    if (m_pOwner)
        delete[] (LPBYTE)m_pOwner;
    if (m_pGroup)
        delete[] (LPBYTE)m_pGroup;
    if (m_pDACL)
        delete[] (LPBYTE)m_pDACL;
    if (m_pSACL)
        delete[] (LPBYTE)m_pSACL;
}

HRESULT CSecurityDescriptor::Initialize()
{
    if (m_pSD)
    {
        delete m_pSD;
        m_pSD = NULL;
    }
    if (m_pOwner)
    {
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
    }
    if (m_pGroup)
    {
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
    }
    if (m_pDACL)
    {
        delete[] (LPBYTE)(m_pDACL);
        m_pDACL = NULL;
    }
    if (m_pSACL)
    {
        delete[] (LPBYTE)(m_pSACL);
        m_pSACL = NULL;
    }

    m_pSD = new SECURITY_DESCRIPTOR;
    if (!m_pSD)
        return E_OUTOFMEMORY;
    if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        delete m_pSD;
        m_pSD = NULL;
        _ASSERTE(FALSE);
        return hr;
    }
    // Set the DACL to allow EVERYONE
    SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
    return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
    PSID pUserSid;
    PSID pGroupSid;
    HRESULT hr;

    Initialize();
    hr = GetProcessSids(&pUserSid, &pGroupSid);
    if (!FAILED(hr))
        hr = SetOwner(pUserSid, bDefaulted);
    if (!FAILED(hr))
        hr = SetGroup(pGroupSid, bDefaulted);

    if (pUserSid)
        delete[] (LPBYTE)(pUserSid);
    if (pGroupSid)
        delete[] (LPBYTE)(pGroupSid);

    if (FAILED(hr))
        return hr;
    return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
    PSID pUserSid;
    PSID pGroupSid;
    HRESULT hr;

    Initialize();
    hr = GetThreadSids(&pUserSid, &pGroupSid);
    if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
        hr = GetProcessSids(&pUserSid, &pGroupSid);
    if (!FAILED(hr))
        hr = SetOwner(pUserSid, bDefaulted);
    if (!FAILED(hr))
        hr = SetGroup(pGroupSid, bDefaulted);

    if (pUserSid)
        delete[] (LPBYTE)(pUserSid);
    if (pGroupSid)
        delete[] (LPBYTE)(pGroupSid);

    if (FAILED(hr))
        return hr;
    return S_OK;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
    _ASSERTE(m_pSD);

    // Mark the SD as having no owner
    if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }

    if (m_pOwner)
    {
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
    }

    // If they asked for no owner don't do the copy
    if (pOwnerSid == NULL)
        return S_OK;

    // Make a copy of the Sid for the return value
    DWORD dwSize = GetLengthSid(pOwnerSid);

    m_pOwner = (PSID) new BYTE[dwSize];
    if (!m_pOwner)
    {
        // Insufficient memory to allocate Sid
        _ASSERTE(FALSE);
        return E_OUTOFMEMORY;
    }
    if (!CopySid(dwSize, m_pOwner, pOwnerSid))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
        return hr;
    }

    _ASSERTE(IsValidSid(m_pOwner));

    if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
    _ASSERTE(m_pSD);

    // Mark the SD as having no Group
    if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }

    if (m_pGroup)
    {
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
    }

    // If they asked for no Group don't do the copy
    if (pGroupSid == NULL)
        return S_OK;

    // Make a copy of the Sid for the return value
    DWORD dwSize = GetLengthSid(pGroupSid);

    m_pGroup = (PSID) new BYTE[dwSize];
    if (!m_pGroup)
    {
        // Insufficient memory to allocate Sid
        _ASSERTE(FALSE);
        return E_OUTOFMEMORY;
    }
    if (!CopySid(dwSize, m_pGroup, pGroupSid))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
        return hr;
    }

    _ASSERTE(IsValidSid(m_pGroup));

    if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::Allow(const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, psidPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::AllowOwner(DWORD dwAccessMask)
{
    HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Deny(const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, psidPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
    HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
    BOOL bRes;
    HRESULT hr;
    HANDLE hToken = NULL;
    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;
    bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
    if (!bRes)
    {
        // Couldn't open process token
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }
    hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
    CloseHandle(hToken);
    return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
    BOOL bRes;
    HRESULT hr;
    HANDLE hToken = NULL;
    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;
    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
    if (!bRes)
    {
        // Couldn't open thread token
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }
    hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
    CloseHandle(hToken);
    return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
    DWORD dwSize;
    HRESULT hr;
    PTOKEN_USER ptkUser = NULL;
    PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;

    if (ppUserSid)
    {
        // Get length required for TokenUser by specifying buffer length of 0
        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
            // Expected ERROR_INSUFFICIENT_BUFFER
            _ASSERTE(FALSE);
            hr = HRESULT_FROM_WIN32(hr);
            goto failed;
        }

        ptkUser = (TOKEN_USER*) new BYTE[dwSize];
        if (!ptkUser)
        {
            // Insufficient memory to allocate TOKEN_USER
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
        {
            // Couldn't get user info
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        // Make a copy of the Sid for the return value
        dwSize = GetLengthSid(ptkUser->User.Sid);

        PSID pSid = (PSID) new BYTE[dwSize];
        if (!pSid)
        {
            // Insufficient memory to allocate Sid
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        _ASSERTE(IsValidSid(pSid));
        *ppUserSid = pSid;
        delete[] (LPBYTE)(ptkUser);
        ptkUser = NULL;
    }
    if (ppGroupSid)
    {
        // Get length required for TokenPrimaryGroup by specifying buffer length of 0
        GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
            // Expected ERROR_INSUFFICIENT_BUFFER
            _ASSERTE(FALSE);
            hr = HRESULT_FROM_WIN32(hr);
            goto failed;
        }

        ptkGroup = (TOKEN_PRIMARY_GROUP*) new BYTE[dwSize];
        if (!ptkGroup)
        {
            // Insufficient memory to allocate TOKEN_USER
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
        {
            // Couldn't get user info
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        // Make a copy of the Sid for the return value
        dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

        PSID pSid = (PSID) new BYTE[dwSize];
        if (!pSid)
        {
            // Insufficient memory to allocate Sid
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        _ASSERTE(IsValidSid(pSid));

        *ppGroupSid = pSid;
        delete[] (LPBYTE)(ptkGroup);
        ptkGroup = NULL;
    }

    return S_OK;

failed:
    if (ptkUser)
        delete[] (LPBYTE)(ptkUser);
    if (ptkGroup)
        delete[] (LPBYTE)(ptkGroup);
    return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
    HANDLE tkHandle = NULL;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
    {
        TOKEN_USER *tkUser;
        DWORD tkSize;
        DWORD sidLength;

        // Call to get size information for alloc
        GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
        tkUser = (TOKEN_USER *) new BYTE[tkSize];
        if (NULL == tkUser)
        {
            CloseHandle(tkHandle);
            return E_OUTOFMEMORY;
        }

        // Now make the real call
        if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
        {
            sidLength = GetLengthSid(tkUser->User.Sid);
            *ppSid = (PSID) new BYTE[sidLength];
            if (NULL != *ppSid)
            {
                memcpy(*ppSid, tkUser->User.Sid, sidLength);
                CloseHandle(tkHandle);

                delete[] (LPBYTE)(tkUser);
                return S_OK;
            }
            else
            {
                CloseHandle(tkHandle);
                delete[] (LPBYTE)(tkUser);
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            CloseHandle(tkHandle);
            delete[] (LPBYTE)(tkUser);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
    HRESULT hr;
    LPTSTR pszRefDomain = NULL;
    DWORD dwDomainSize = 0;
    DWORD dwSidSize = 0;
    SID_NAME_USE snu;

    // Call to get size info for alloc
    LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

    hr = GetLastError();
    if (hr != ERROR_INSUFFICIENT_BUFFER)
        return HRESULT_FROM_WIN32(hr);

    pszRefDomain = new TCHAR[dwDomainSize];
    if (pszRefDomain == NULL)
        return E_OUTOFMEMORY;

    *ppSid = (PSID) new BYTE[dwSidSize];
    if (*ppSid != NULL)
    {
        if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
        {
            delete[] (LPBYTE)(*ppSid);
            *ppSid = NULL;
            delete[] pszRefDomain;
            return HRESULT_FROM_WIN32(GetLastError());
        }
        delete[] pszRefDomain;
        return S_OK;
    }
    delete[] pszRefDomain;
    return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
    PACL    pDACL = NULL;
    PACL    pSACL = NULL;
    BOOL    bDACLPresent, bSACLPresent;
    BOOL    bDefaulted;
    PACL    m_pDACL = NULL;
    ACCESS_ALLOWED_ACE* pACE;
    HRESULT hr;
    PSID    pUserSid;
    PSID    pGroupSid;

    hr = Initialize();
    if(FAILED(hr))
        return hr;

    // get the existing DACL.
    if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
        goto failed;

    if (bDACLPresent)
    {
        if (pDACL)
        {
            // allocate new DACL.
            if (!(m_pDACL = (PACL) new BYTE[pDACL->AclSize]))
                goto failed;

            // initialize the DACL
            if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
                goto failed;

            // copy the ACES
            for (int i = 0; i < pDACL->AceCount; i++)
            {
                if (!GetAce(pDACL, i, (void **)&pACE))
                    goto failed;

                if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
                    goto failed;
            }

            if (!IsValidAcl(m_pDACL))
                goto failed;
        }

        // set the DACL
        if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
            goto failed;
    }

    // get the existing SACL.
    if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
        goto failed;

    if (bSACLPresent)
    {
        if (pSACL)
        {
            // allocate new SACL.
            if (!(m_pSACL = (PACL) new BYTE[pSACL->AclSize]))
                goto failed;

            // initialize the SACL
            if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
                goto failed;

            // copy the ACES
            for (int i = 0; i < pSACL->AceCount; i++)
            {
                if (!GetAce(pSACL, i, (void **)&pACE))
                    goto failed;

                if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
                    goto failed;
            }

            if (!IsValidAcl(m_pSACL))
                goto failed;
        }

        // set the SACL
        if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
            goto failed;
    }

    if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
        goto failed;

    if (FAILED(SetOwner(pUserSid, bDefaulted)))
        goto failed;

    if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
        goto failed;

    if (FAILED(SetGroup(pGroupSid, bDefaulted)))
        goto failed;

    if (!IsValidSecurityDescriptor(m_pSD))
        goto failed;

    return hr;

failed:
    if (m_pDACL)
        delete[] (LPBYTE)(m_pDACL);
    if (m_pSD)
        delete[] (LPBYTE)(m_pSD);
    return E_UNEXPECTED;
}

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
    HRESULT hr;
    DWORD dwSize = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;

    GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

    hr = GetLastError();
    if (hr != ERROR_INSUFFICIENT_BUFFER)
        return HRESULT_FROM_WIN32(hr);

    pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];
    if (NULL==pSD)
        return E_OUTOFMEMORY;

    if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        delete[] (LPBYTE)(pSD);
        return hr;
    }

    hr = Attach(pSD);
    delete[] (LPBYTE)(pSD);
    return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    LPVOID pAce;
    ACE_HEADER *aceHeader;

    if (pSrc == NULL)
        return S_OK;

    if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        return HRESULT_FROM_WIN32(GetLastError());

    // Copy all of the ACEs to the new ACL
    for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pSrc, i, &pAce))
            return HRESULT_FROM_WIN32(GetLastError());

        aceHeader = (ACE_HEADER *) pAce;

        if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
            return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;

    oldACL = *ppAcl;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL)
    {
        delete[] (LPBYTE)principalSID;
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;
    DWORD dwLen, dwIx;

    oldACL = *ppAcl;

    ASSERT(255 >= psidPrincipal->dwRidCount);
    dwLen = GetSidLengthRequired((UCHAR)psidPrincipal->dwRidCount);
    principalSID = (PSID)(new BYTE[dwLen]);
    if (NULL==principalSID)
        return E_OUTOFMEMORY;
    if (!InitializeSid(
                principalSID,
                (PSID_IDENTIFIER_AUTHORITY)&psidPrincipal->sid,
                (UCHAR)psidPrincipal->dwRidCount))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }
    for (dwIx = 0; dwIx < psidPrincipal->dwRidCount; dwIx += 1)
        *GetSidSubAuthority(principalSID, dwIx) = psidPrincipal->rgRids[dwIx];
    if (!IsValidSid(principalSID))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL)
    {
        delete[] (LPBYTE)principalSID;
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID = NULL;
    PACL oldACL, newACL;
    DWORD dwLen, dwIx;

    oldACL = *ppAcl;

    ASSERT(255 >= psidPrincipal->dwRidCount);
    dwLen = GetSidLengthRequired((UCHAR)psidPrincipal->dwRidCount);
    principalSID = (PSID)(new BYTE[dwLen]);
    if (NULL==principalSID)
        return E_OUTOFMEMORY;
    if (!InitializeSid(
                principalSID,
                (PSID_IDENTIFIER_AUTHORITY)&psidPrincipal->sid,
                (UCHAR)psidPrincipal->dwRidCount))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }
    for (dwIx = 0; dwIx < psidPrincipal->dwRidCount; dwIx += 1)
        *GetSidSubAuthority(principalSID, dwIx) = psidPrincipal->rgRids[dwIx];
    if (!IsValidSid(principalSID))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL) {
        delete[] (LPBYTE)principalSID;
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)principalSID;
        return returnValue;
    }

    if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)newACL;
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)principalSID;
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;

    oldACL = *ppAcl;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL)
    {
        delete[] (LPBYTE)principalSID;
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)(newACL);
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PACL oldACL, newACL;

    oldACL = *ppAcl;

    if (!IsValidSid(m_pOwner))
    {
        _ASSERTE(FALSE);
        return E_INVALIDARG;
    }

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(m_pOwner) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];
    if (NULL==newACL)
    {
        return E_OUTOFMEMORY;
    }

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(newACL);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(newACL);
        return returnValue;
    }

    if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, m_pOwner))
    {
        delete[] (LPBYTE)(newACL);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    return S_OK;
}

HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    ULONG i;
    LPVOID ace;
    ACCESS_ALLOWED_ACE *accessAllowedAce;
    ACCESS_DENIED_ACE *accessDeniedAce;
    SYSTEM_AUDIT_ACE *systemAuditAce;
    PSID principalSID;
    DWORD returnValue;
    ACE_HEADER *aceHeader;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pAcl, i, &ace))
        {
            delete[] (LPBYTE)(principalSID);
            return HRESULT_FROM_WIN32(GetLastError());
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        }
    }
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
    HRESULT hr;
    TOKEN_PRIVILEGES tpPrevious;
    TOKEN_PRIVILEGES tp;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID luid;
    HANDLE hMyToken = NULL;

    // if no token specified open process token
    if (hToken == 0)
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hMyToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            return hr;
        }
        hToken = hMyToken;
    }

    if (!LookupPrivilegeValue(NULL, privilege, &luid ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        if (NULL != hMyToken)
            CloseHandle(hMyToken);
        return hr;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = 0;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        if (NULL != hMyToken)
            CloseHandle(hMyToken);
        return hr;
    }

    tpPrevious.PrivilegeCount = 1;
    tpPrevious.Privileges[0].Luid = luid;

    if (bEnable)
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    else
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

    if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        if (NULL != hMyToken)
            CloseHandle(hMyToken);
        return hr;
    }
    if (NULL != hMyToken)
        CloseHandle(hMyToken);
    return S_OK;
}

CSecurityDescriptor::operator LPSECURITY_ATTRIBUTES()
{
    m_saAttrs.nLength = sizeof (m_saAttrs);
    m_saAttrs.lpSecurityDescriptor = m_pSD;
    m_saAttrs.bInheritHandle = m_fInheritance;
    return (&m_saAttrs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\common\noncom.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    noncom

Abstract:

    This module provides a means to bypass COM, such that typical in-process
    COM objects can be called directly in any operating system.

Author:

    Doug Barlow (dbarlow) 1/4/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <scardlib.h>
#include <ole2.h>
#include <unknwn.h>
#include <noncom.h>

typedef HRESULT
(STDAPICALLTYPE *GetClassObjectFunc)(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv);


#ifdef UNDER_TEST

typedef struct {
    IID iid;
    HINSTANCE hDll;
    GetClassObjectFunc pgco;
} NonComModuleStruct;

class NonComControlStruct
{
public:
    DWORD dwInitializeCount;
    CRITICAL_SECTION csLock;
    CDynamicArray<NonComModuleStruct> rgModules;
};

static NonComControlStruct *l_pControl = NULL;


/*++

NoCoInitialize:

    This function initializes the NonCOM subsystem.

Arguments:

    pvReserved - [in] Reserved; must be NULL.

Return Value:

    S_OK - The NonCOM subsystem was initialized correctly.
    S_FALSE - The NonCOM library is already initialized.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/4/1999

--*/

STDAPI
NoCoInitialize(
    LPVOID pvReserved)
{
    HRESULT hReturn = E_UNEXPECTED;


    //
    // Validate parameters.
    //

    if (NULL != pvReserved)
    {
        hReturn = E_INVALIDARG;
        goto ErrorExit;
    }


    //
    // Create the Control structure, if necessary.
    //

    if (NULL == l_pControl)
    {
        l_pControl = new NonComControlStruct;
        if (NULL == l_pControl)
        {
            hReturn = E_OUTOFMEMORY;
            goto ErrorExit;
        }
        InitializeCriticalSection(&l_pControl->csLock);
        CCritSect csLock(&l_pControl->csLock);
        // ?code? Database initialization
        l_pControl->dwInitializeCount = 1;
    }
    else
    {
        CCritSect csLock(&l_pControl->csLock);
        ASSERT(0 < l_pControl->dwInitializeCount);
        l_pControl->dwInitializeCount += 1;
    }
    return S_OK;

ErrorExit:
    return hReturn;
}


/*++

NoCoUninitialize:

    Closes the NonCOM library on the current apartment, unloads all DLLs
    loaded by the apartment, frees any other resources that the apartment
    maintains, and forces all RPC connections on the apartment to close.

Arguments:

    None

Return Value:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/4/1999

--*/

STDAPI_(void)
NoCoUninitialize(
    void)
{
    DWORD dwI;
    NonComModuleStruct *pMod;

    if (NULL != l_pControl)
    {
        {
            CCritSect csLock(&l_pControl->csLock);
            ASSERT(0 < l_pControl->dwInitializeCount);
            l_pControl->dwInitializeCount -= 1;
            if (0 == l_pControl->dwInitializeCount)
            {
                for (dwI = l_pControl->rgModules.Count(); 0 < dwI;)
                {
                    pMod = l_pControl->rgModules[--dwI];
                    FreeLibrary(pMod->hDll);
                    delete pMod;
                }
                l_pControl->rgModules.Clear();
            }
        }
        DeleteCriticalSection(&l_pControl->csLock);
        delete l_pControl;
        l_pControl = NULL;
    }
}

#endif


/*++

NoCoGetClassObject:

    Provides a pointer to an interface on a class object associated with a
    specified CLSID. CoGetClassObject locates, and if necessary, dynamically
    loads the executable code required to do this.

Arguments:

    rclsid - [in] CLSID associated with the data and code that you will use to
        create the objects.

    riid - [in] Reference to the identifier of the interface, which will be
        supplied in ppv on successful return. This interface will be used to
        communicate with the class object.

    ppv - [out] Address of pointer variable that receives the interface
        pointer requested in riid. Upon successful return, *ppv contains the
        requested interface pointer.

Return Value:

    S_OK - Location and connection to the specified class object was successful.

    REGDB_E_CLASSNOTREG - CLSID is not properly registered. Can also indicate
        that the value you specified in dwClsContext is not in the registry.

    E_NOINTERFACE - Either the object pointed to by ppv does not support the
        interface identified by riid, or the QueryInterface operation on the
        class object returned E_NOINTERFACE.

    REGDB_E_READREGDB - Error reading the registration database.

    CO_E_DLLNOTFOUND - In-process DLL not found.

    E_ACCESSDENIED - General access failure.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/4/1999

--*/

STDAPI
NoCoGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv)
{
    DWORD dwStatus;
    HRESULT hReturn = E_UNEXPECTED;
    TCHAR szGuid[40];
    CBuffer szDll;
    HINSTANCE hDll = NULL;
    GetClassObjectFunc pfGetObject;

#ifdef UNDER_TEST
    if (NULL == l_pControl)
    {
        hReturn = NoCoInitialize(NULL);
        if (S_OK != hReturn)
            goto ErrorExit;
    }

    {
        DWORD dwI;
        CCritSect(&l_pControl->csLock);

        for (dwI = l_pControl->rgModules.Count(); 0 < dwI;)
        {
            dwI -= 1;
            if (IsEqualGUID(l_pControl->rgModules[dwI]->iid, rclsid))
            {
                try
                {
                    hReturn = (*l_pControl->rgModules[dwI]->pgco)(rclsid, riid, ppv);
                }
                catch (...)
                {
                    hReturn = E_UNEXPECTED;
                }
                goto ErrorExit;
            }
        }
    }
#endif

    StringFromGuid(&rclsid, szGuid);

    try
    {

        //
        // Open the Class Registry Database.
        //

        CRegistry regClsId(
                        HKEY_CLASSES_ROOT,
                        TEXT("ClsID"),
                        KEY_READ);
        dwStatus = regClsId.Status(TRUE);
        if (ERROR_SUCCESS != dwStatus)
        {
            hReturn = REGDB_E_READREGDB;
            goto ErrorExit;
        }


        //
        // Look up the specified Class.
        //

        CRegistry regClass(
                        regClsId,
                        szGuid,
                        KEY_READ);
        dwStatus = regClass.Status(TRUE);
        if (ERROR_SUCCESS != dwStatus)
        {
            hReturn = REGDB_E_CLASSNOTREG;
            goto ErrorExit;
        }


        //
        // Get the registered InProcess Server.
        //

        CRegistry regServer(
                        regClass,
                        TEXT("InprocServer32"),
                        KEY_READ);
        dwStatus = regServer.Status(TRUE);
        if (ERROR_SUCCESS != dwStatus)
        {
            hReturn = REGDB_E_CLASSNOTREG;
            goto ErrorExit;
        }


        //
        // Get the handler DLL name.
        //

        regServer.GetValue(TEXT(""), szDll);
    }
    catch (DWORD dwError)
    {
        switch (dwError)
        {
        case ERROR_OUTOFMEMORY:
            hReturn = E_OUTOFMEMORY;
            break;
        default:
            hReturn = HRESULT_FROM_WIN32(dwError);
        }
        goto ErrorExit;
    }


    //
    // We've got the target DLL.  Load it and look for the entrypoint.
    //

    hDll = LoadLibrary((LPCTSTR)szDll.Access());
    if (NULL == hDll)
    {
        hReturn = CO_E_DLLNOTFOUND;
        goto ErrorExit;
    }
    pfGetObject = (GetClassObjectFunc)GetProcAddress(
                                            hDll,
                                            "DllGetClassObject");
    if (NULL == pfGetObject)
    {
        hReturn = E_NOINTERFACE;
        goto ErrorExit;
    }

#ifdef UNDER_TEST
    {
        NonComModuleStruct *pMod = new NonComModuleStruct;

        if (NULL == pMod)
        {
            hReturn = E_OUTOFMEMORY;
            goto ErrorExit;
        }

        pMod->hDll = hDll;
        CopyMemory(&pMod->iid, &rclsid, sizeof(IID));
        pMod->pgco = pfGetObject;
        try
        {
            l_pControl->rgModules.Add(pMod);
        }
        catch (...)
        {
            delete pMod;
        }
    }
#endif

    try
    {
        hReturn = (*pfGetObject)(rclsid, riid, ppv);
    }
    catch (...)
    {
        hReturn = E_UNEXPECTED;
    }
    if (S_OK != hReturn)
        goto ErrorExit;


    //
    // Add the Handler to our database.
    //

    // ?code? -- No database yet.
    hDll = NULL;

    ASSERT(NULL == hDll);
    return S_OK;

ErrorExit:
    if (NULL != hDll)
        FreeLibrary(hDll);
    return hReturn;
}


/*++

NoCoCreateInstance:

    Creates a single uninitialized object of the class associated with a
    specified CLSID. Call CoCreateInstance when you want to create only one
    object on the local system.

Arguments:

    rclsid - [in] CLSID associated with the data and code that will be used to
        create the object.

    pUnkOuter - [in] If NULL, indicates that the object is not being created as
        part of an aggregate. If non-NULL, pointer to the aggregate object's
        IUnknown interface (the controlling IUnknown).

    riid - [in] Reference to the identifier of the interface to be used to
        communicate with the object.

    ppv - [out] Address of pointer variable that receives the interface
        pointer requested in riid. Upon successful return, *ppv contains the
        requested interface pointer.

Return Value:

    S_OK - An instance of the specified object class was successfully created.

    REGDB_E_CLASSNOTREG - A specified class is not registered in the
        registration database. Also can indicate that the type of server you
        requested in the CLSCTX enumeration is not registered or the values
        for the server types in the registry are corrupt.

Author:

    Doug Barlow (dbarlow) 1/15/1999

--*/

STDAPI
NoCoCreateInstance(
    REFCLSID rclsid,
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppv)
{
    HRESULT hReturn = E_UNEXPECTED;
    IClassFactory *pCF = NULL;

    hReturn = NoCoGetClassObject(rclsid, IID_IClassFactory, (LPVOID*)&pCF);
    if (S_OK != hReturn)
        goto ErrorExit;
    hReturn = pCF->CreateInstance(pUnkOuter, riid, ppv);
    if (S_OK != hReturn)
        goto ErrorExit;
    pCF->Release();
    pCF = NULL;
    return S_OK;

ErrorExit:
    if (NULL != pCF)
        pCF->Release();
    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\common\text.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    text

Abstract:

    This module provides the runtime code to support the CTextString class.

Author:

    Doug Barlow (dbarlow) 11/7/1995

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <SCardLib.h>


/*++

CTextString::operator=:

    These methods set the CTextString object to the given value, properly
    adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CTextString object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CTextString object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CTextString &
CTextString::operator=(
    const CTextString &tz)
{

    //
    // See what the other CTextString object has that's good, and copy it over
    // here.
    //

    switch (m_fFlags = tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing's Good!?!  ?Error?
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.
        m_bfAnsi = tz.m_bfAnsi;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.
        m_bfUnicode = tz.m_bfUnicode;
        break;

    case fBothGood:
        // Everything is good.
        m_bfAnsi = tz.m_bfAnsi;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    default:
        // Internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return *this;
}

LPCSTR
CTextString::operator=(
    LPCSTR sz)
{
    DWORD length;

    //
    // Reset the ANSI buffer.
    //

    if (NULL != sz)
    {
        length = Length(sz) + 1;
        m_bfAnsi.Set((LPBYTE)sz, length * sizeof(CHAR));
    }
    else
        m_bfAnsi.Reset();
    m_fFlags = fAnsiGood;
    return sz;
}

LPCWSTR
CTextString::operator=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Reset the Unicode Buffer.
    //

    if (NULL != wsz)
    {
        length = Length(wsz) + 1;
        m_bfUnicode.Set((LPBYTE)wsz, length * sizeof(WCHAR));
    }
    else
        m_bfUnicode.Reset();
    m_fFlags = fUnicodeGood;
    return wsz;
}


/*++

CTextString::operator+=:

    These methods append the given data to the existing CTextString object
    value, properly adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CTextString object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CTextString object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CTextString &
CTextString::operator+=(
    const CTextString &tz)
{

    //
    // Append the other's good value to our value.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        *this += (LPCSTR)tz.m_bfAnsi.Access();
        break;

    case fUnicodeGood:
        *this += (LPCWSTR)tz.m_bfUnicode.Access();
        break;

    case fBothGood:
#ifdef UNICODE
        *this += (LPCWSTR)tz.m_bfUnicode.Access();
#else
        *this += (LPCSTR)tz.m_bfAnsi.Access();
#endif
        break;

    default:
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return *this;
}

LPCSTR
CTextString::operator+=(
    LPCSTR sz)
{
    DWORD length;


    //
    // Extend ourself as an ANSI string.
    //

    if (NULL != sz)
    {
        length = Length(sz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(CHAR);
            Ansi();
            if (0 < m_bfAnsi.Length())
                m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE);
            m_bfAnsi.Append((LPBYTE)sz, length);
            m_fFlags = fAnsiGood;
        }
    }
    return (LPCSTR)m_bfAnsi.Access();
}

LPCWSTR
CTextString::operator+=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Extend ourself as a Unicode string.
    //

    if (NULL != wsz)
    {
        length = Length(wsz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(WCHAR);
            Unicode();
            if (0 < m_bfUnicode.Length())
                m_bfUnicode.Resize(m_bfUnicode.Length() - sizeof(WCHAR), TRUE);
            m_bfUnicode.Append((LPBYTE)wsz, length);
            m_fFlags = fUnicodeGood;
        }
    }
    return (LPCWSTR)m_bfUnicode.Access();
}


/*++

Unicode:

    This method returns the CTextString object as a Unicode string.

Arguments:

    None

Return Value:

    The value of the object expressed in Unicode.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPCWSTR
CTextString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // No valid values.  Report an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        if (0 < m_bfAnsi.Length())
        {
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    NULL,
                    0);
            if (0 == length)
                throw GetLastError();
            m_bfUnicode.Resize((length + 1) * sizeof(WCHAR));
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    (LPWSTR)m_bfUnicode.Access(),
                    length);
            if (0 == length)
                throw GetLastError();
            *(LPWSTR)m_bfUnicode.Access(length * sizeof(WCHAR)) = 0;
        }
        else
            m_bfUnicode.Reset();
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    default:
        // Internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }


    //
    // If we don't have any value, return a null string.
    //

    if (0 == m_bfUnicode.Length())
        return L"\000";     // Double NULLs to support Multistrings
    else
        return (LPCWSTR)m_bfUnicode.Access();
}


/*++

CTextString::Ansi:

    This method returns the value of the object expressed in an ANSI string.

Arguments:

    None

Return Value:

    The value of the object expressed as an ANSI string.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPCSTR
CTextString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        if (0 < m_bfUnicode.Length())
        {
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            if (0 == length)
                throw GetLastError();
            m_bfAnsi.Resize((length + 1) * sizeof(CHAR));
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPSTR)m_bfAnsi.Access(),
                    length,
                    NULL,
                    NULL);
            if (0 == length)
                throw GetLastError();
            *(LPSTR)m_bfAnsi.Access(length * sizeof(CHAR)) = 0;
        }
        else
            m_bfAnsi.Reset();
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    default:
        // An internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }


    //
    // If there's nothing in the ANSI buffer, return a null string.
    //

    if (0 == m_bfAnsi.Length())
        return "\000";  // Double NULLs to support Multistrings
    else
        return (LPCSTR)m_bfAnsi.Access();
}


/*++

Compare:

    These methods compare the value of this object to another value, and return
    a comparative value.

Arguments:

    tz supplies the value to be compared as a CTextString object.
    sz supplies the value to be compared as an ANSI string.
    wsz supplies the value to be compared as a Unicode string.

Return Value:

    < 0 - The supplied value is less than this object.
    = 0 - The supplied value is equal to this object.
    > 0 - The supplies value is greater than this object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

int
CTextString::Compare(
    const CTextString &tz)
{
    int nResult;


    //
    // See what we've got to compare.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing!?!  Complain.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fBothGood:
    case fAnsiGood:
        // Use the ANSI version for fastest comparison.
        Ansi();
        nResult = CompareStringA(
                    LOCALE_USER_DEFAULT,
                    0,
                    (LPCSTR)m_bfAnsi.Access(),
                    (m_bfAnsi.Length() / sizeof(CHAR)) - 1,
                    (LPCSTR)tz.m_bfAnsi.Access(),
                    (tz.m_bfAnsi.Length() / sizeof(CHAR)) - 1);
        break;

    case fUnicodeGood:
        // The Unicode version is good.
        Unicode();
        nResult = CompareStringW(
                    LOCALE_USER_DEFAULT,
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPCWSTR)tz.m_bfUnicode.Access(),
                    (tz.m_bfUnicode.Length() / sizeof(WCHAR)) - 1);
        break;

    default:
        // Internal Error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return nResult;
}

int
CTextString::Compare(
    LPCSTR sz)
{
    int nResult;


    //
    // Make sure our ANSI version is good.
    //

    Ansi();


    //
    // Do an ANSI comparison.
    //

    nResult = CompareStringA(
                LOCALE_USER_DEFAULT,
                0,
                (LPCSTR)m_bfAnsi.Access(),
                (m_bfAnsi.Length() / sizeof(CHAR)) - 1,
                sz,
                Length(sz));
    return nResult;
}

int
CTextString::Compare(
    LPCWSTR wsz)
{
    int nResult;


    //
    // Make sure our Unicode version is good.
    //

    Unicode();


    //
    // Do the comparison using Unicode.
    //

    nResult = CompareStringW(
                LOCALE_USER_DEFAULT,
                0,
                (LPCWSTR)m_bfUnicode.Access(),
                (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                wsz,
                Length(wsz));
    return nResult;
}


/*++

Length:

    These routines return the length of strings, in Characters, not including
    any trailing null characters.

Arguments:

    sz supplies the value whos length is to be returned as an ANSI string.
    wsz supplies the value whos length is to be returned as a Unicode string.

Return Value:

    The length of the string, in characters, excluding the trailing null.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
CTextString::Length(
    void)
{
    DWORD dwLength = 0;

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.  We'll return its length.
        if (0 < m_bfAnsi.Length())
            dwLength = (m_bfAnsi.Length() / sizeof(CHAR)) - 1;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Return it's length.
        if (0 < m_bfUnicode.Length())
            dwLength = (m_bfUnicode.Length() / sizeof(WCHAR)) - 1;
        break;

    case fBothGood:
#ifdef UNICODE
        // The Unicode buffer is good.  Return it's length.
        if (0 < m_bfUnicode.Length())
            dwLength = (m_bfUnicode.Length() / sizeof(WCHAR)) - 1;
#else
        // The ANSI buffer is good.  We'll return its length.
        if (0 < m_bfAnsi.Length())
            dwLength = (m_bfAnsi.Length() / sizeof(CHAR)) - 1;
#endif
        break;

    default:
        // An internal error.
        throw (DWORD)ERROR_INTERNAL_ERROR;
        break;
    }
    return dwLength;
}

DWORD
CTextString::Length(
    LPCWSTR wsz)
{
    return lstrlenW(wsz);
}

DWORD
CTextString::Length(
    LPCSTR sz)
{
    return lstrlenA(sz);
}


//
//==============================================================================
//
//  CTextMultistring
//

/*++

Length:

    These routines return the length of strings, in Characters, not including
    any trailing null characters.

Arguments:

    sz supplies the value whos length is to be returned as an ANSI string.
    wsz supplies the value whos length is to be returned as a Unicode string.

Return Value:

    The length of the string, in characters, excluding the trailing null.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

DWORD
CTextMultistring::Length(
    LPCWSTR wsz)
{
    return MStrLen(wsz) - 1;
}

DWORD
CTextMultistring::Length(
    LPCSTR sz)
{
    return MStrLen(sz) - 1;
}


/*++

Length:

    This routine returns the length of the stored MultiString in characters,
    including the trailing NULL characters.

Arguments:

    None

Return Value:

    The length, in characters, including trailing nulls.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

DWORD
CTextMultistring::Length(
    void)
{
    return CTextString::Length() + 1;
}


/*++

operator=:

    These methods assign values to the MultiString object.

Arguments:

    tz supplies the new value as a CTextMultistring
    sz supplies the new value as an ANSI string
    wsz supplies the new value as a UNICODE string

Return Value:

    The assigned string value, in its original form.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

CTextMultistring &
CTextMultistring::operator=(
    const CTextMultistring &tz)
{
    CTextString::operator=((const CTextString &)tz);
    return *this;
}

LPCSTR
CTextMultistring::operator=(
    LPCSTR sz)
{
    return CTextString::operator=(sz);
}

LPCWSTR
CTextMultistring::operator=(
    LPCWSTR wsz)
{
    return CTextString::operator=(wsz);
}


/*++

operator+=:

    These methods append values to the MultiString object.

Arguments:

    tz supplies the value to be appended as a CTextMultistring
    sz supplies the value to be appended as an ANSI string
    wsz supplies the value to be appended as a UNICODE string

Return Value:

    The concatenated string, in the form of the appended string.

Author:

    Doug Barlow (dbarlow) 2/25/1998

--*/

CTextMultistring &
CTextMultistring::operator+=(
    const CTextMultistring &tz)
{
    CTextString::operator+=((const CTextString &)tz);
    return *this;
}

LPCSTR
CTextMultistring::operator+=(
    LPCSTR sz)
{
    return CTextString::operator+=(sz);
}

LPCWSTR
CTextMultistring::operator+=(
    LPCWSTR wsz)
{
    return CTextString::operator+=(wsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\common\registry.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Registry

Abstract:

    This module implements the CRegistry Class, simplifying access to the
    Registry Database.

Author:

    Doug Barlow (dbarlow) 7/15/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    The only exceptions thrown are DWORDs, containing the error code.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <SCardLib.h>

#define NTOHL HTONL

static inline DWORD
HTONL(
    DWORD dwInVal)
{
    DWORD   dwOutVal;
    LPBYTE  pbIn = (LPBYTE)&dwInVal,
            pbOut = (LPBYTE)&dwOutVal;
    for (DWORD index = 0; index < sizeof(DWORD); index += 1)
        pbOut[sizeof(DWORD) - 1 - index] = pbIn[index];
    return dwOutVal;
}


//
//==============================================================================
//
//  CRegistry
//

/*++

CRegistry:

    These routines provide for the construction and destruction of Objects of
    this class.

Arguments:

    regBase - A CRegistry object to be used as a parent for this object.

    hBase - A Registry key to be the parent of this object.

    szName - The name of the Registry key, relative to the supplied parent.

    samDesired - The desired SAM.

    dwOptions - Any special creation optiopns.

Throws:

    None.  If the registry access fails, the error will be thrown on first use.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

CRegistry::CRegistry(
    HKEY hBase,
    LPCTSTR szName,
    REGSAM samDesired,
    DWORD dwOptions,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
:   m_bfResult()
{
    m_hKey = NULL;
    m_lSts = ERROR_BADKEY;
    Open(hBase, szName, samDesired, dwOptions, lpSecurityAttributes);
}

CRegistry::CRegistry()
{
    m_hKey = NULL;
    m_lSts = ERROR_BADKEY;
}

CRegistry::~CRegistry()
{
    Close();
}


/*++

Open:

    These methods allow a CRegistry object to attempt to access a given registry
    entry.

Arguments:

    regBase - A CRegistry object to be used as a parent for this object.

    hBase - A Registry key to be the parent of this object.

    szName - The name of the Registry key, relative to the supplied parent.

    samDesired - The desired SAM.

    dwOptions - Any special creation optiopns.

Return Value:

    None

Throws:

    None -- errors are saved for follow-on operations, so that Open can be used
            safely in a constructor.

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

void CRegistry::Open(
    HKEY hBase,
    LPCTSTR szName,
    REGSAM samDesired,
    DWORD dwOptions,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    Close();
    if (REG_OPTION_EXISTS == dwOptions)
    {
        m_lSts = RegOpenKeyEx(
                    hBase,
                    szName,
                    0,
                    samDesired,
                    &m_hKey);
        m_dwDisposition = REG_OPENED_EXISTING_KEY;
    }
    else
        m_lSts = RegCreateKeyEx(
                    hBase,
                    szName,
                    0,
                    TEXT(""),
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    &m_hKey,
                    &m_dwDisposition);
}


/*++

Close:

    Shut down a CRegistry object, making it available for follow-on opens.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

void
CRegistry::Close(
    void)
{
    HRESULT hrSts;

    if (NULL != m_hKey)
    {
        hrSts = RegCloseKey(m_hKey);
        ASSERT(ERROR_SUCCESS == hrSts);
        m_hKey = NULL;
    }
    m_lSts = ERROR_BADKEY;
    m_bfResult.Reset();
}


/*++

Status:

    This routine returns the status code from the construction routine.  This is
    useful to check for errors prior to having them thrown.

Arguments:

    fQuiet indicates whether or not to throw an error if the status is not
        ERROR_SUCCESS.

Return Value:

    The status code from the creation.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LONG
CRegistry::Status(
    BOOL fQuiet)
const
{
    if ((ERROR_SUCCESS != m_lSts) && !fQuiet)
        throw (DWORD)m_lSts;
    return m_lSts;
}


/*++

Empty:

    This method cleans out the registry tree under the given key.  All
    underlying keys and values are removed.  This does it's best -- if an error
    occurs, the emptying operation stops, leaving the registry in an
    indeterminate state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
CRegistry::Empty(
    void)
{
    LPCTSTR szValue;
    LPCTSTR szKey;


    //
    // Go through all the values and delete them.
    //

    while (NULL != (szValue = Value(0)))
        DeleteValue(szValue, TRUE);


#if 0       // Obsolete code
    //
    // Go through all the Keys and empty them.
    //

    DWORD dwIndex;
    for (dwIndex = 0; NULL != (szKey = Subkey(dwIndex)); dwIndex += 1)
    {
        CRegistry regEmpty;

        regEmpty.Open(*this, szKey);
        regEmpty.Empty();
        regEmpty.Close();
    }
#endif


    //
    // Now delete all the keys.
    //

    while (NULL != (szKey = Subkey(0)))
        DeleteKey(szKey, TRUE);
}


/*++

Copy:

    This method loads the current registry keys with all the subkeys and values
    from the supplied key.  Current keys and values of this key are deleted.

Arguments:

    regSrc supplies the source registry key from which values and keys will be
        loaded.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
CRegistry::Copy(
    CRegistry &regSrc)
{
    LPCTSTR szValue;
    LPCTSTR szKey;
    DWORD dwIndex, dwType;
    CRegistry regSrcSubkey, regDstSubkey;
    CBuffer bfValue;


    //
    // Go through all the values and copy them.
    //

    for (dwIndex = 0; NULL != (szValue = regSrc.Value(dwIndex)); dwIndex += 1)
    {
        regSrc.GetValue(szValue, bfValue, &dwType);
        SetValue(szValue, bfValue.Access(), bfValue.Length(), dwType);
    }


    //
    // Now copy all the keys.
    //

    for (dwIndex = 0; NULL != (szKey = regSrc.Subkey(dwIndex)); dwIndex += 1)
    {
        regSrcSubkey.Open(regSrc, szKey, KEY_READ);
        regDstSubkey.Open(
                *this,
                szKey,
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
        regDstSubkey.Status();
        regDstSubkey.Copy(regSrcSubkey);
        regDstSubkey.Close();
        regSrcSubkey.Close();
    }
}


/*++

DeleteKey:

    This method deletes a subkey from this key.

Arguments:

    szKey supplies the name of the key to be deleted.

    fQuiet supplies whether or not to suppress errors.

Return Value:

    None

Throws:

    if fQuiet is FALSE, then any errors encountered are thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::DeleteKey(
    LPCTSTR szKey,
    BOOL fQuiet)
const
{
    if (ERROR_SUCCESS == m_lSts)
    {
        try
        {
            CRegistry regSubkey(m_hKey, szKey);
            LPCTSTR szSubKey;

            if (ERROR_SUCCESS == regSubkey.Status(TRUE))
            {
                while (NULL != (szSubKey = regSubkey.Subkey(0)))
                    regSubkey.DeleteKey(szSubKey, fQuiet);
            }
        }
        catch (DWORD dwError)
        {
            if (!fQuiet)
                throw dwError;
        }

        LONG lSts = RegDeleteKey(m_hKey, szKey);
        if ((ERROR_SUCCESS != lSts) && !fQuiet)
            throw (DWORD)lSts;
    }
    else if (!fQuiet)
        throw (DWORD)m_lSts;
}


/*++

DeleteValue:

    This method deletes a Value from this key.

Arguments:

    szValue supplies the name of the Value to be deleted.

    fQuiet supplies whether or not to suppress errors.

Return Value:

    None

Throws:

    if fQuiet is FALSE, then any errors encountered are thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::DeleteValue(
    LPCTSTR szValue,
    BOOL fQuiet)
const
{
    LONG lSts;

    if (fQuiet)
    {
        if (ERROR_SUCCESS == m_lSts)
            lSts = RegDeleteValue(m_hKey, szValue);
    }
    else
    {
        if (ERROR_SUCCESS != m_lSts)
            throw (DWORD)m_lSts;
        lSts = RegDeleteValue(m_hKey, szValue);
        if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    }
}


/*++

Subkey:

    This method allows for iterating over the names of the subkeys of this key.

Arguments:

    dwIndex supplies the index into the set of subkeys.

Return Value:

    The name of the indexed subkey, or NULL if none exists.

Throws:

    Any error other than ERROR_NO_MORE_ITEMS is thrown.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LPCTSTR
CRegistry::Subkey(
    DWORD dwIndex)
{
    LONG lSts;
    DWORD dwLen;
    LPCTSTR szResult = NULL;
    BOOL fDone = FALSE;
    FILETIME ftLastWrite;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    m_bfResult.Presize(128);
    while (!fDone)
    {
        dwLen = m_bfResult.Space() / sizeof(TCHAR);
        lSts = RegEnumKeyEx(
                    m_hKey,
                    dwIndex,
                    (LPTSTR)m_bfResult.Access(),
                    &dwLen,
                    NULL,
                    NULL,
                    NULL,
                    &ftLastWrite);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            m_bfResult.Resize((dwLen + 1) * sizeof(TCHAR), TRUE);
            szResult = (LPCTSTR)m_bfResult.Access();
            fDone = TRUE;
            break;
        case ERROR_NO_MORE_ITEMS:
            szResult = NULL;
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            m_bfResult.Presize((dwLen + 1) * sizeof(TCHAR));
            continue;
        default:
            throw (DWORD)lSts;
        }
    }

    return szResult;
}


/*++

Value:

    This method allows for iterating over the names of the Values of this key.

Arguments:

    dwIndex supplies the index into the set of Values.

    pdwType receives the type of the entry.  This parameter may be NULL.

Return Value:

    The name of the indexed Value, or NULL if none exists.

Throws:

    Any error other than ERROR_NO_MORE_ITEMS is thrown.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LPCTSTR
CRegistry::Value(
    DWORD dwIndex,
    LPDWORD pdwType)
{
    LONG lSts;
    DWORD dwLen, dwType;
    LPCTSTR szResult = NULL;
    BOOL fDone = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    m_bfResult.Presize(128);    // Force it to not be zero length.
    while (!fDone)
    {
        dwLen = m_bfResult.Space() / sizeof(TCHAR);
        lSts = RegEnumValue(
                    m_hKey,
                    dwIndex,
                    (LPTSTR)m_bfResult.Access(),
                    &dwLen,
                    NULL,
                    &dwType,
                    NULL,
                    NULL);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            m_bfResult.Resize((dwLen + 1) * sizeof(TCHAR), TRUE);
            if (NULL != pdwType)
                *pdwType = dwType;
            szResult = (LPCTSTR)m_bfResult.Access();
            fDone = TRUE;
            break;
        case ERROR_NO_MORE_ITEMS:
            szResult = NULL;
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            if (dwLen == m_bfResult.Space())
                throw (DWORD)ERROR_INSUFFICIENT_BUFFER; // Won't tell us how big.
            m_bfResult.Presize((dwLen + 1) * sizeof(TCHAR));
            break;
        default:
            throw (DWORD)lSts;
        }
    }

    return szResult;
}


/*++

GetValue:

    These methods provide access to the values of the Value entries.

Arguments:

    szKeyValue supplies the name of the Value entry to get.
    pszValue receives the value of the entry as a string.
    pdwValue receives the value of the entry as a DWORD.
    ppbValue receives the value of the entry as a Binary string.
    pcbLength receives the length of the entry when it's a binary string.
    pdwType receives the type of the registry entry.

Return Value:

    None

Throws:

    Any error encountered.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    CBuffer &bfValue,
    LPDWORD pdwType)
{
    LONG lSts;
    DWORD dwLen, dwType = 0;
    BOOL fDone = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    while (!fDone)
    {
        dwLen = bfValue.Space();
        lSts = RegQueryValueEx(
                    m_hKey,
                    szKeyValue,
                    NULL,
                    &dwType,
                    bfValue.Access(),
                    &dwLen);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            bfValue.Resize(dwLen, TRUE);
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            bfValue.Presize(dwLen);
            break;
        default:
            throw (DWORD)lSts;
        }
    }
    if (NULL != pdwType)
        *pdwType = dwType;
}


void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPTSTR *pszValue,
    LPDWORD pdwType)
{
    DWORD dwLen, dwType;
    TCHAR chTmp;
    CBuffer bfUnexpanded;
    LONG lSts;

    dwLen = 0;
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                NULL,
                &dwLen);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    switch (dwType)
    {
    case REG_EXPAND_SZ:
        bfUnexpanded.Presize(dwLen);
        GetValue(szKeyValue, bfUnexpanded, &dwType);
        dwLen = ExpandEnvironmentStrings(
                    (LPTSTR)bfUnexpanded.Access(),
                    &chTmp,
                    0);
        if (0 == dwLen)
            throw GetLastError();
        dwLen = ExpandEnvironmentStrings(
                    (LPTSTR)bfUnexpanded.Access(),
                    (LPTSTR)m_bfResult.Resize(dwLen),
                    dwLen);
        if (0 == dwLen)
            throw GetLastError();
        break;

    case REG_BINARY:
    case REG_MULTI_SZ:
    case REG_SZ:
        m_bfResult.Presize(dwLen);
        GetValue(szKeyValue, m_bfResult, &dwType);
        break;

    default:
        throw (DWORD)ERROR_BAD_FORMAT;
    }
    *pszValue = (LPTSTR)m_bfResult.Access();
    if (NULL != pdwType)
        *pdwType = dwType;
}

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwValue,
    LPDWORD pdwType)
const
{
    LONG lSts;
    DWORD dwLen, dwType;
    CBuffer szExpanded;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    dwLen = sizeof(DWORD);
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                (LPBYTE)pdwValue,
                &dwLen);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;

    switch (dwType)
    {
    case REG_DWORD_BIG_ENDIAN:
        *pdwValue = NTOHL(*pdwValue);
        break;
    case REG_DWORD:
    // case REG_DWORD_LITTLE_ENDIAN:
        break;
    default:
        throw (DWORD)ERROR_BAD_FORMAT;
    }
    if (NULL != pdwType)
        *pdwType = dwType;
}

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPBYTE *ppbValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
{
    DWORD dwType;

    GetValue(szKeyValue, m_bfResult, &dwType);
    *ppbValue = m_bfResult.Access();
    *pcbLength = m_bfResult.Length();
    if (NULL != pdwType)
        *pdwType = dwType;
}


/*++

SetValue:

    These methods provide write access to the values of the Value entries.

Arguments:

    szKeyValue supplies the name of the Value entry to set.
    szValue supplies the new value of the entry as a string.
    dwValue supplies the new value of the entry as a DWORD.
    pbValue supplies the new value of the entry as a Binary string.
    cbLength supplies the length of the entry when it's a binary string.
    dwType supplies the registry type value.

Return Value:

    None

Throws:

    Any error encountered.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    LPCTSTR szValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)szValue,
                (lstrlen(szValue) + 1) * sizeof(TCHAR));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    DWORD dwValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    if (REG_DWORD_BIG_ENDIAN == dwType)
        dwValue = HTONL(dwValue);
    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)&dwValue,
                sizeof(DWORD));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    LPCBYTE pbValue,
    DWORD cbLength,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                pbValue,
                cbLength);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}


/*++

GetStringValue:

    This is an alternate mechanism for obtaining a string value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a string pointer.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

LPCTSTR
CRegistry::GetStringValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
{
    LPTSTR szResult;
    GetValue(szKeyValue, &szResult, pdwType);
    return szResult;
}


/*++

GetNumericValue:

    This is an alternate mechanism for obtaining a numeric value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a DWORD.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetNumericValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
const
{
    DWORD dwResult;
    GetValue(szKeyValue, &dwResult, pdwType);
    return dwResult;
}


/*++

GetBinaryValue:

    This is an alternate mechanism for obtaining a binary value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a binary pointer.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

LPCBYTE
CRegistry::GetBinaryValue(
    LPCTSTR szKeyValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
{
    LPBYTE pbResult;
    DWORD cbLength;
    GetValue(szKeyValue, &pbResult, &cbLength, pdwType);
    if (NULL != pcbLength)
        *pcbLength = cbLength;
    return pbResult;

}


/*++

GetValueLength:

    This routine is designed to work in conjunction with GetBinaryValue, but may
    have other uses as well.  It returns the length of the internal storage
    area, in bytes.  Note DWORDs are not stored internally, so this value will
    not represent the size of a DWORD following a GetNumericValue call.

Arguments:

    none

Return Value:

    The length of the internal storage buffer, in bytes.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetValueLength(
    void)
const
{
    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    return m_bfResult.Length();
}


/*++

ValueExists:

    This routine tests for the existance of a given value, and optionally
    returns its type and length.

Arguments:

    none

Return Value:

    A boolean indication as to whether or not the value exists.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

BOOL
CRegistry::ValueExists(
    LPCTSTR szKeyValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
const
{
    LONG lSts;
    DWORD dwLen, dwType;
    BOOL fResult = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    dwLen = 0;
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                NULL,
                &dwLen);
    if (ERROR_SUCCESS == lSts)
    {
        if (NULL != pcbLength)
            *pcbLength = dwLen;
        if (NULL != pdwType)
            *pdwType = dwType;
        fResult = TRUE;
    }
    return fResult;
}


/*++

GetDisposition:

    This routine returns the disposition of creation.

Arguments:

    none

Return Value:

    The return disposition flag from creating the registry entry.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetDisposition(
    void)
const
{
    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    return m_dwDisposition;
}


/*++

SetMultiStringValue:

    This method simplifies the work of adding a MultiString value to the
    registry.

Arguments:

    szKeyValue supplies the name of the Value entry to set.
    mszValue supplies the new value of the entry as a multi-string.
    dwType supplies the registry type value.

Return Value:

    None

Throws:

    Any errors encountered as a DWORD status value.

Author:

    Doug Barlow (dbarlow) 11/6/1996

--*/

void
CRegistry::SetMultiStringValue(
    LPCTSTR szKeyValue,
    LPCTSTR mszValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)mszValue,
                MStrLen(mszValue) * sizeof(TCHAR));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}


/*++

GetMultiStringValue:

    This method obtains a multi-string value from the registry.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The registry value, as a multi-string.

Throws:

    Any errors encountered as a DWORD status value.

Author:

    Doug Barlow (dbarlow) 11/6/1996

--*/

LPCTSTR
CRegistry::GetMultiStringValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
{
    LPTSTR szResult;
    GetValue(szKeyValue, &szResult, pdwType);
    return szResult;
}


/*++

SetAcls:

    This method sets security attributes for a single key, or an entire key
    branch.

Arguments:

    SecurityInformation supplies the SECURITY_INFORMATION value (see
        RegSetKeySecurity in the SDK documentation).
    pSecurityDescriptor supplies the SECURITY_DESCRIPTOR value (see
        RegSetKeySecurity in the SDK documentation).
    fRecurse supplies an indicator as to whether to just set the ACL on this
        key (FALSE), or this key and all subkeys (TRUE).

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/10/1998

--*/

void
CRegistry::SetAcls(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN BOOL fRecurse)
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetKeySecurity(
                m_hKey,
                SecurityInformation,
                pSecurityDescriptor);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    if (fRecurse)
    {
        CRegistry regSub;
        LPCTSTR szSubKey;
        DWORD dwIndex;

        for (dwIndex = 0;
             NULL != (szSubKey = Subkey(dwIndex));
             dwIndex += 1)
        {
            regSub.Open(m_hKey, szSubKey);
            regSub.SetAcls(
                SecurityInformation,
                pSecurityDescriptor);
            regSub.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\common\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

buffers.cpp: ..\..\common\buffers.cpp
	copy $** $@

misc.cpp: ..\..\common\misc.cpp
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\certprop\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCStatus.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\certprop\certprop.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    PropCert

Abstract:

    This file contains the definitition of the thread
	which propogates digital certificates from smart cards
	to the smart card physical store and My store
    
Author:

    Chris Dudley 5/16/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	Amanda Matlosz 12/05/97	removed the CNewDlg (replaced w/ CWizPropSheet)
	Amanda Matlosz 01/23/97 removed the wizard entirely

Notes:

--*/

#if !defined(__PROPCERT_INCLUDED__)
#define __PROPCERT_INCLUDED__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <wincrypt.h>

typedef struct _THREADDATA
{
	SCARDCONTEXT    hSCardContext;	
	HANDLE          hClose;
    HANDLE          hUserToken;
    HANDLE          hThread;
	BOOL			fSuspended;

} THREADDATA;

typedef struct _PROPDATA
{
 	TCHAR szCSPName[MAX_PATH];
    TCHAR szReader[MAX_PATH];
    TCHAR szCardName[MAX_PATH];
    HANDLE hUserToken;

} PROPDATA, *PPROPDATA;

DWORD
WINAPI
PropagateCertificates(
    LPVOID lpParameter
    );

void
StopMonitorReaders(
    THREADDATA *ThreadData
    );

DWORD
WINAPI
StartMonitorReaders( 
    LPVOID lpParameter
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\common\rdrstate.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    RdrState

Abstract:

    This file contains the outline implementation of the Smartcard Common
    dialog CSCardReaderState class. This class encapsulates Smartcard
    Reader information.

Author:

    Chris Dudley 3/3/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "stdafx.h"
#include "rdrstate.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Local Macros
//

#ifdef _DEBUG
    #define TRACE_STR(name,sz) \
                TRACE(_T("CmnUILb.lib: %s: %s\n"), name, sz)
    #define TRACE_CODE(name,code) \
                TRACE(_T("CmnUILb.lib: %s: error = 0x%x\n"), name, code)
    #define TRACE_CATCH(name,code)      TRACE_CODE(name,code)
    #define TRACE_CATCH_UNKNOWN(name)   TRACE_STR(name,_T("An unidentified exception has occurred!"))
#else
    #define TRACE_STR(name,sz)          ((void)0)
    #define TRACE_CODE(name,code)       ((void)0)
    #define TRACE_CATCH(name,code)      ((void)0)
    #define TRACE_CATCH_UNKNOWN(name)   ((void)0)
#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
// CSCardReaderState Implementation
//

/*++

void CheckCard:

    Routine sets an internal flag if the given card name is the currently
    in this reader.

Arguments:

    LPCTSTR - string containing the card name or names if multistring.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/10/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/
LONG CSCardReaderState::CheckCard( LPCTSTR szCardName )
{
    // Locals
    LPCTSTR      szCards = szCardName;
    LPCTSTR      szCard = m_sCardName;
    LONG        lReturn = SCARD_S_SUCCESS;

    try
	{
        m_fCardLookup = FALSE;
        m_fChecked = FALSE;

		//
        // Set "Lookup" flag if card name is one we're looking for
		//

		if (0 == MStringCount(szCards))
		{
			// if we havn't indicated preferred card names, any
			// card name is considered...
			m_fCardLookup = TRUE;
		}
		else
		{
			szCards = FirstString(szCards);
			while ((szCards != NULL) && (!m_fCardLookup)) 
			{
				m_fCardLookup = ( _stricmp(szCards, szCard) == 0 );
				szCards = NextString(szCards);
			}
		}

        // If there's a match, does the card pass the check?
        if (m_fCardLookup)
		{
			// Call the user's callbacks if they're available
			if (IsCallbackValid())
			{
				lReturn = UserConnect(&m_hCard);
				if (SCARDFAILED(lReturn))
				{
					throw (lReturn);
				}

				lReturn = UserCheck(); // this is where m_fChecked gets set.
				if (SCARDFAILED(lReturn))
				{
					throw (lReturn);
				}

				lReturn = UserDisconnect();
				if (SCARDFAILED(lReturn))
				{
					throw (lReturn);
				}
			}
			// Otherwise the card automatically checks out OK!
			else
			{
				m_fChecked = TRUE;
			}
        }
    }

    catch (LONG err) {
        lReturn = err;
        TRACE_CATCH(_T("CheckCard"), err);
    }

    catch (...) {
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("CheckCard"));
    }

    return lReturn;
}


/*++

LONG Connect:

    Attempts to connect to the reader

Arguments:

    pHandle - pointer to an SCARDHANDLE that will be returned.
    dwShareMode - preferred share.
    dwProtocols - preferred protocol
    dwActiveProtocol - returned actual protocol in use.
    pszReaderName - returned name of reader connecting to.
    pszCardName - returned name of card connecting to.

Return Value:

    A LONG value indicating the status of the requested action. 
    See the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
LONG CSCardReaderState::Connect(SCARDHANDLE *pHandle,
                                DWORD dwShareMode,
                                DWORD dwProtocols,
                                DWORD *pdwActiveProtocol,
                                CTextString *pszReaderName, //=NULL
                                CTextString *pszCardName //=NUL
                                )
{
    // Locals
    LONG        lReturn = SCARD_S_SUCCESS;

    try
	{
        // Check Params
        if (NULL == pHandle)
		{
            throw (LONG)SCARD_E_INVALID_VALUE;
		}
        if (NULL == pdwActiveProtocol)
		{
            throw (LONG)SCARD_E_INVALID_VALUE;
		}

        if (!IsCardInserted())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}
        if (!IsContextValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Clear handle
        *pHandle = NULL;

        if (!m_fConnected)
		{
            // Attempt to connect
            lReturn = SCardConnect( m_hContext,
                                    (LPCTSTR)m_sReaderName,
                                    dwShareMode,
                                    dwProtocols,
                                    &m_hCard,
                                    pdwActiveProtocol);
            if (SCARDFAILED(lReturn))
                throw (lReturn);

            // Return reader/card names
            if (pszReaderName != NULL)
                (*pszReaderName) = m_sReaderName;
            if (pszCardName != NULL)
                (*pszCardName) = m_sCardName;
        }

        *pHandle = m_hCard;
        m_fConnected = TRUE;
    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("Connect"), lReturn);
    }
    catch(...)
	{
        lReturn = SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("Connect"));
    }

    return lReturn;
}


/*++

LONG GetReaderCardInfo:

    Provides a way for user to set two CTextStrings to the reader and card name.

	This function is essentially a dummy connect routine -- it is used when the caller
	does not wish to actually connect to a card selected by the user, but would like
	to be able to know which card was selected, providing the same UI.

	Note that this is only of interest to the Common Dialog.

Arguments:

	pszReaderName - the Reader;
	pszCardName - the Card;

Return Value:

    A LONG value indicating the status of the requested action. 
    ALWAYS SCARD_S_SUCESS.

Author:

    Amanda Matlosz 3/24/98

Revision History:


--*/
LONG CSCardReaderState::GetReaderCardInfo(CTextString* pszReaderName,
											CTextString* pszCardName)
{
    if (NULL != pszReaderName)
	{
        (*pszReaderName) = m_sReaderName;
	}

    if (NULL != pszCardName)
	{
        (*pszCardName) = m_sCardName;
	}

	return SCARD_S_SUCCESS;
}



/*++

LONG GetReaderInfo:

    Retrieves the current state information of the object and returns.

Arguments:

    pReaderInfo - pointer to LPSCARD_READERINFO structure

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
LONG CSCardReaderState::GetReaderInfo( LPSCARD_READERINFO pReaderInfo )
{
    // Locals
    LONG    lReturn = SCARD_S_SUCCESS;

    try {
        // Check params, etc..
        if (NULL == pReaderInfo)
		{
            throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
        if (!IsStateValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Setup the struct
        ::ZeroMemory( (LPVOID)pReaderInfo, (DWORD)sizeof(SCARD_READERINFO));
        pReaderInfo->sReaderName = m_sReaderName;
        pReaderInfo->fCardLookup = m_fCardLookup;
        if (IsCardInserted())
		{
            pReaderInfo->sCardName = m_sCardName;
            pReaderInfo->fCardInserted = TRUE;
            pReaderInfo->fChecked = m_fChecked;
        }

        // Set the atr
        ::CopyMemory(   &(pReaderInfo->rgbAtr),
                        &(m_ReaderState.rgbAtr),
                        m_ReaderState.cbAtr);
        pReaderInfo->dwAtrLength = m_ReaderState.cbAtr;

		//
        // Set the state
		//

		// NO CARD
        if(m_ReaderState.dwEventState & SCARD_STATE_EMPTY)
		{
			pReaderInfo->dwState = SC_STATUS_NO_CARD;
		}
		// CARD in reader: SHARED, EXCLUSIVE, FREE, UNKNOWN ?
		else if(m_ReaderState.dwEventState & SCARD_STATE_PRESENT)
		{
			if (m_ReaderState.dwEventState & SCARD_STATE_MUTE)
			{
				pReaderInfo->dwState = SC_STATUS_UNKNOWN;
			}
			else if (m_ReaderState.dwEventState & SCARD_STATE_INUSE)
			{
				if(m_ReaderState.dwEventState & SCARD_STATE_EXCLUSIVE)
				{
					pReaderInfo->dwState = SC_STATUS_EXCLUSIVE;
				}
				else
				{
					pReaderInfo->dwState = SC_STATUS_SHARED;
				}
			}
			else
			{
				pReaderInfo->dwState = SC_SATATUS_AVAILABLE;
			}
        }
		// READER ERROR?  at this point, something's gone wrong
		else // if(m_ReaderState.dwEventState & SCARD_STATE_UNAVAILABLE)
		{
			pReaderInfo->dwState = SC_STATUS_ERROR;
        }

    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("GetReaderInfo"), lReturn);
    }
    catch(...)
	{
        lReturn = SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("GetReaderInfo"));
    }

    return lReturn;
}


/*++

LONG GetReaderState:

    Retrieves the current state information of the object and returns in
    given SCARD_READERSTATE struct.

Arguments:

    pReaderState - pointer to SCARD_READERSTATE_A or SCARD_READERSTATE_W struct

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revision History:

    Chris Dudley 5/13/1997
	Amanda Matlosz 2/01/98 A/W code cleanup

--*/
LONG CSCardReaderState::GetReaderState( LPSCARD_READERSTATE pReaderState )
{
    LONG lReturn = SCARD_S_SUCCESS;

    try
	{
        // Check params, etc..
        if (NULL == pReaderState)
		{
            throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
        if (!IsStateValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Setup the struct
        ::ZeroMemory(   (LPVOID)pReaderState,
                        (DWORD)sizeof(SCARD_READERSTATE));
        pReaderState->szReader = m_sReaderName;
        pReaderState->dwEventState = m_ReaderState.dwEventState;
        pReaderState->dwCurrentState = m_ReaderState.dwCurrentState;
        pReaderState->cbAtr = m_ReaderState.cbAtr;
        ::CopyMemory(   (LPVOID)pReaderState->rgbAtr,
                        (CONST LPVOID)m_ReaderState.rgbAtr,
                        (DWORD)pReaderState->cbAtr );
    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("FirstReader"), lReturn);
    }
    catch(...)
	{
        lReturn = SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("FirstReader"));
    }

    return lReturn;
}


/*++

BOOL IsCallbackValid:

    This routine checks the user callback functions.

Arguments:

    None

Return Value:

    TRUE if calbacks are valid. FALSE otherwise.

Author:

    Chris Dudley 3/15/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
BOOL CSCardReaderState::IsCallbackValid ( void )
{
    // Locals
    BOOL    fValid = FALSE;

    fValid =  (((m_lpfnConnectA != NULL) || (m_lpfnConnectW != NULL)) &&
				(m_lpfnCheck != NULL) && 
				(m_lpfnDisconnect != NULL) );

    return fValid;
}


/*++

BOOL IsCardInserted:

    This routine determines if a card is inserted into this object's reader.

Arguments:

    None

Return Value:

    TRUE if card inserted. FALSE otherwise.

Author:

    Chris Dudley 3/3/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
BOOL CSCardReaderState::IsCardInserted ( void )
{
    // Locals
    BOOL    fReturn = FALSE;

    if (!IsStateValid())
        return fReturn;

    // Check for card in appropriate struct
    fReturn = (m_ReaderState.dwEventState & SCARD_STATE_PRESENT);

    return fReturn;
}


/*++

BOOL IsStateValid:

    This routine determines if the information in the object is in a valid/usable
    state.

Arguments:

    None

Return Value:

    TRUE if state information is valid. FALSE otherwise.

Author:

    Chris Dudley 3/3/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
BOOL CSCardReaderState::IsStateValid ( void )
{
    // Locals
    BOOL    fReturn = TRUE;

    fReturn = (IsContextValid()) && (NULL != m_ReaderState.szReader);

    return fReturn;
}


/*++

void SetContext:

    Sets the card context

Arguments:

    hContext - card context handle

Return Value:

    None.

Author:

    Chris Dudley 3/3/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
void CSCardReaderState::SetContext( SCARDCONTEXT hContext )
{
    // Locals

    // Store it
    m_hContext = hContext;
}


/*++

LONG SetReaderState:

    Sets the internal SCARD_READERSTATE structure for the reader.

Arguments:

    lpfnConnectA - pointer to user's connect callback function (ANSI).
    lpfnConnectW - pointer to user's conenct callback function (UNICODE).
    lpfnCheck - pointer to user's check callback function.
    lpfnDisconnect - pointer to user's disconnect callback function.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/5/1997

Revision History:

    Chris Dudley 5/13/1997

--*/
// ANSI
LONG CSCardReaderState::SetReaderState( LPOCNCONNPROCA lpfnConnectA, // = NULL
                                        LPOCNCHKPROC lpfnCheck, // = NULL
                                        LPOCNDSCPROC lpfnDisconnect, // = NULL
                                        LPVOID lpUserData // = NULL
                                        )
{
    LONG lReturn = SCARD_S_SUCCESS;
    LPSTR szCardName = NULL;
    DWORD dwNumChar = SCARD_AUTOALLOCATE;

    try
	{
        // Check Param,etc.
        if (!IsContextValid() || !IsStateValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Get current status of this reader
        lReturn = SCardGetStatusChangeA(m_hContext,
                                        (DWORD)0,
                                        &m_ReaderState,
                                        (DWORD)1);
        if(SCARDFAILED(lReturn))
		{
            throw (lReturn);
		}

        // Check for inserted card and get card name
        if (IsCardInserted())
		{
            // Is the reader in a state where this is useful?
            if ((m_ReaderState.dwEventState & SCARD_STATE_UNAVAILABLE) ||
                (m_ReaderState.dwEventState & SCARD_STATE_MUTE) )
			{
                m_sCardName = szCardName;
            }
            else
			{
                lReturn = SCardListCardsA(  m_hContext,
                                            (LPCBYTE)m_ReaderState.rgbAtr,
                                            NULL,
                                            (DWORD) 0,
                                            (LPSTR)&szCardName,
                                            &dwNumChar);
                if(SCARDFAILED(lReturn))
				{
                    throw (lReturn);
				}

                // Save the name of the card
                m_sCardName = szCardName;
            }
        }

        // Set the current state
		m_lpfnConnectW = NULL;

        m_ReaderState.dwCurrentState = m_ReaderState.dwEventState;
        m_lpfnConnectA = lpfnConnectA;
        m_lpfnCheck = lpfnCheck;
        m_lpfnDisconnect = lpfnDisconnect;
        m_lpUserData = lpUserData;
    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("SetReaderState"),lReturn);
    }
    catch(...)
	{
        lReturn = SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("SetReaderState"));
    }

    // Clean Up
    if (NULL != szCardName)
	{
        SCardFreeMemory(m_hContext, (LPVOID)szCardName);
	}

    return lReturn;
}


// UNICODE
LONG CSCardReaderState::SetReaderState( LPOCNCONNPROCW lpfnConnectW, // = NULL
                                        LPOCNCHKPROC lpfnCheck, // = NULL
                                        LPOCNDSCPROC lpfnDisconnect, // = NULL
                                        LPVOID lpUserData // = NULL
                                        )
{
    LONG lReturn = SCARD_S_SUCCESS;
    LPWSTR szCardName = NULL;
    DWORD dwNumChar = SCARD_AUTOALLOCATE;

    try
	{
        // Check Param
        if (!IsContextValid() || !IsStateValid())
		{
            throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

        // Get current status of this reader
        lReturn = SCardGetStatusChange(m_hContext,
										(DWORD) 0,
										&m_ReaderState,
										(DWORD) 1);
        if(SCARDFAILED(lReturn))
		{
            throw (lReturn);
		}

        // Check for inserted card and get card name
        if(IsCardInserted())
		{
            // Is the reader in a state where this is useful?
            if ((m_ReaderState.dwEventState & SCARD_STATE_UNAVAILABLE) ||
                (m_ReaderState.dwEventState & SCARD_STATE_MUTE))
			{
                m_sCardName = szCardName;
            }
            else
			{
                lReturn = SCardListCardsW(	m_hContext,
											(LPCBYTE)m_ReaderState.rgbAtr,
											NULL,
											(DWORD)0,
                                            (LPWSTR)&szCardName,
                                            &dwNumChar);
                if (SCARDFAILED(lReturn))
                    throw (lReturn);
                // Save the name of the card
                m_sCardName = szCardName;
            }
        }

        // Set the current state
		m_lpfnConnectA = NULL;
        m_ReaderState.dwCurrentState = m_ReaderState.dwEventState;
        m_lpfnConnectW = lpfnConnectW;
        m_lpfnCheck = lpfnCheck;
        m_lpfnDisconnect = lpfnDisconnect;
        m_lpUserData = lpUserData;
    }
    catch(LONG lErr)
	{
        lReturn = lErr;
        TRACE_CATCH(_T("SetReaderState -- UNICODE"),lReturn);
    }

    catch(...)
	{
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("SetReaderState -- UNICODE"));
    }

    // Clean Up
    if (NULL != szCardName)
	{
        SCardFreeMemory(m_hContext, (LPVOID)szCardName);
	}

    return lReturn;
}


/*++

void StoreName:

    Stores a name for the reader associated with this object.

Arguments:

    szGroupName - Group name in ANSI or UNICODE

Return Value:

    None.

Author:

    Chris Dudley 3/3/1997

--*/
void CSCardReaderState::StoreName( LPCTSTR szReaderName )
{
    // Store it
    m_sReaderName = szReaderName;
    m_ReaderState.szReader = m_sReaderName;
}


/*++

LONG UserCheck:

    Attempts to check a card using the user callback routine.

Arguments:

    None.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/
LONG CSCardReaderState::UserCheck( void )
{
    // Locals
    LONG        lReturn = SCARD_S_SUCCESS;

    try {
        // Check Params, etc.
        if (!IsContextValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardInserted())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardConnected())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCallbackValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );

        if (!m_fConnected) {
            lReturn = UserConnect( &m_hCard );
            if (FAILED(lReturn))
                throw (lReturn);
        };
        // Attempt to Check
        m_fChecked = m_lpfnCheck (  m_hContext,
                                    m_hCard,
                                    m_lpUserData);
    }

    catch (LONG err) {
        lReturn = err;
        TRACE_CATCH(_T("UserCheck"), err);
    }

    catch (...) {
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("UserCheck"));
    }

    return lReturn;
}


/*++

LONG UserConnect:

    Attempts to connect to the reader using a user callback function.

Arguments:

    pCard - pointer to a SCARDHANDLE

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/
LONG CSCardReaderState::UserConnect(LPSCARDHANDLE pCard,
                                    CTextString *pszReaderName, //=NULL
                                    CTextString *pszCardName //=NULL
                                    )
{
    LONG lReturn = SCARD_S_SUCCESS;

    try
	{
        // Check Params, etc.
        if (!IsContextValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardInserted())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCallbackValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );

        // Clear handle
        (*pCard) = NULL;

        if (!m_fConnected)
		{
			if (NULL != m_lpfnConnectA)
			{
				m_hCard = m_lpfnConnectA(	m_hContext,
											(LPSTR)((LPCSTR)m_sReaderName),
											(LPSTR)((LPCSTR)m_sCardName),
											m_lpUserData);
				if ( m_hCard == NULL )
					throw ( (LONG) SCARD_F_INTERNAL_ERROR );
				// Return reader/card names
				if (pszReaderName != NULL)
					(*pszReaderName) = m_sReaderName;
				if (pszCardName != NULL)
					(*pszCardName) = m_sCardName;
			}
			else if (NULL != m_lpfnConnectW)
			{
				m_hCard = m_lpfnConnectW(	m_hContext,
											(LPWSTR)((LPCWSTR)m_sReaderName),
											(LPWSTR)((LPCWSTR)m_sCardName),
											m_lpUserData);
				if ( m_hCard == NULL )
					throw ( (LONG) SCARD_F_INTERNAL_ERROR );
				// Return reader/card names
				if (pszReaderName != NULL)
					(*pszReaderName) = (LPCWSTR)m_sReaderName;	// force the unicode version
				if (pszCardName != NULL)
					(*pszCardName) = (LPCWSTR)m_sCardName;	// force the unicode version
			}
			else
			{
				throw ( (LONG) SCARD_F_INTERNAL_ERROR ); // should never have gotten here!
			}
        }

        *pCard = m_hCard;
        m_fConnected = TRUE;
    }

    catch(LONG err)
	{
        lReturn = err;
        TRACE_CATCH(_T("UserConnect"), err);
    }
    catch(...)
	{
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("UserConnect"));
    }

    return lReturn;
}


/*++

LONG UserDisconnect:

    Attempts to disconnect a card using the user callback routine.

Arguments:

    None.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/16/1997

Revision History:

    Chris Dudley 5/13/1997

Notes:

--*/
LONG CSCardReaderState::UserDisconnect( void )
{
    // Locals
    LONG        lReturn = SCARD_S_SUCCESS;

    try {
        // Check Params, etc.
        if (!IsContextValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardInserted())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCardConnected())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );
        if (!IsCallbackValid())
            throw ( (LONG) SCARD_F_INTERNAL_ERROR );

        if (m_fConnected)
		{
            // Attempt to Disconnect
            m_lpfnDisconnect (  m_hContext,
                                m_hCard,
                                m_lpUserData);
            // Clear handle
            m_hCard = NULL;
            m_fConnected = FALSE;
        };
    }

    catch (LONG err) {
        lReturn = err;
        TRACE_CATCH(_T("UserDisconnect"), err);
    }

    catch (...) {
        lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
        TRACE_CATCH_UNKNOWN(_T("UserDisconnect"));
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\certprop\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

// Include multi-thread classes
#include <afxmt.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#include <atlconv.h>		// ATL Conversion macros

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\statmon.h ===
// statmon.h

/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    StatMon

Abstract:

    This file contains the implementation of CScStatusMonitor
	(an object that watches for status changes of readers recognized 
	by the smart card service, handling PNP and requests for copies of
	the status array)

Author:

    Amanda Matlosz	02/26/98

Environment:

    Win32, C++ with exceptions

Revision History:

Notes:

  In order to use this class, first declare an object, then initialize it w/ 
  your HWND and a UINT indicating the message you want to receive when a 
  change in the system reader status has occurred.  Handle that message 
  simply by calling GetReaderStatus().  When the object is destroyed, any 
  outstanding threads will be stopped.

	CScStatusMonitor m_monitor; 
	m_monitor.Start(hWnd, STATUS_MONITOR_CHANGE, NULL) // use default reader group
	on STATUS_MONITOR_CHANGE() 
	{
	m_monitor.GetStatus(); ???????
	m_monitor.GetReaderStatus(ReaderStatusArray); // check return val for system errors
	}
	m_monitor.Stop(); // also in ~CScStatusMonitor(); closes threads

  The monitor object maintains a separate thread to signal and record changes in
  reader status, as well as an enhanced record of that status that is available
  to the object's caller via GetReaderStatus().  The enhnced record includes the
  first card name associated with the inserted card's ATR.

  In the event that the resource manager service is stopped, the monitor will
  move to a stopped state and send the status_change message to the caller's hWnd.
  The caller is responsible for starting the monitor again (if it so wishes)
  when the service is back up.

--*/

#ifndef _STATUS_MONITOR
#define _STATUS_MONITOR

#include <afxwin.h>
#include "afxtempl.h"
#include <afxmt.h>
#include "winscard.h"
#include "calaislb.h"

// Status of reader
#define SC_STATUS_FIRST			SC_STATUS_NO_CARD

#define SC_STATUS_NO_CARD       0	// SCARD_STATE_EMPTY
#define SC_STATUS_UNKNOWN		1	// SCARD_STATE_PRESENT | SCARD_STATE_MUTE
#define SC_SATATUS_AVAILABLE	2	// SCARD_STATE_PRESENT (| SCARD_STATE_UNPOWERED)
#define SC_STATUS_SHARED		3	// SCARD_SATATE_PRESENT | SCARD_STATE_INUSE
#define SC_STATUS_EXCLUSIVE		4	// "" | SCARD_STATE_EXCLUSIVE
#define SC_STATUS_ERROR			5	// SCARD_STATE_UNAVAILABLE (reader or card error)

#define SC_STATUS_LAST			SC_STATUS_ERROR

class CSCardReaderState
{
public:

	CSCardReaderState(const CSCardReaderState* pCRS=NULL)
	{
		if(NULL != pCRS)
		{
			strReader = (LPCTSTR)pCRS->strReader;
			dwCurrentState = pCRS->dwCurrentState;
			dwEventState = pCRS->dwEventState;
			cbAtr = pCRS->cbAtr;
			memcpy(rgbAtr, pCRS->rgbAtr, pCRS->cbAtr);
			strCard = (LPCTSTR)pCRS->strCard;
			dwState = pCRS->dwState;
			fOK = pCRS->fOK;
		}
		else
		{
			strReader = _T("");
			dwCurrentState = 0;
			dwEventState = 0;
			ZeroMemory(rgbAtr, sizeof(rgbAtr));
			cbAtr = 0;
			strCard = _T("");
			dwState = 0;
			fOK = FALSE;
		}
	}

	// used to talk w/ Resource Manager

    CString     strReader;		// reader name
    DWORD       dwCurrentState; // current state of reader at time of call
    DWORD       dwEventState;   // state of reader after state change
    DWORD       cbAtr;          // Number of bytes in the returned ATR.
    BYTE        rgbAtr[36];     // Atr of inserted card, (extra alignment bytes)

	// used by caller for easier user-friendly UI

	CString		strCard;		// first card name RM returns for ATR
	DWORD		dwState;		// simplified reader state; see #defines above

	// BOOL for Smart Card Common Dialog's use (not used by status monitor)
	BOOL		fOK;
};

typedef CTypedPtrArray<CPtrArray, CSCardReaderState*> CSCardReaderStateArray;


class CScStatusMonitor
{
public:

	// status
	enum status{	uninitialized=0, 
					stopped, 
					running,
					no_service,
					no_readers,
					unknown};

	// constructors
	CScStatusMonitor() 
	{ 
		m_status = CScStatusMonitor::uninitialized; 
		m_uiStatusChangeMsg=0; 
		m_pStatusThrd=NULL;
		m_szReaderNames = NULL;
		m_pInternalReaderStatus = NULL;
		m_dwInternalNumReaders = 0;
	}

	~CScStatusMonitor();

	// operations & attributes
	LONG Start(HWND hWnd, UINT uiMsg, LPCTSTR szGroupNames=NULL);
	void Stop();

	void GetReaderStatus(CSCardReaderStateArray& aReaderStatus);
	void SetReaderStatus(); // uses same lock as above... 

	status GetStatus() { return m_status; }

	UINT GetStatusChangeProc();

private:

	LONG InitInternalReaderStatus();
	LONG UpdateInternalReaderStatus();
	void EmptyExternalReaderStatus();

	// members

	status m_status;

	HWND m_hwnd;
	UINT m_uiStatusChangeMsg;
	CWinThread* m_pStatusThrd;
	HANDLE m_hEventKillStatus;
	SCARDCONTEXT m_hContext;
	SCARDCONTEXT m_hInternalContext;

	CTextMultistring m_strGroupNames;

	CCriticalSection m_csRdrStsLock;
	CSCardReaderStateArray m_aReaderStatus;

	// internally maintained -- does not include card name, rebuilt during each SetReaderStatus
	CCriticalSection m_csInternalRdrStsLock;
	SCARD_READERSTATE* m_pInternalReaderStatus;
	DWORD m_dwInternalNumReaders;
	LPTSTR m_szReaderNames;

};

#endif // _STATUS_MONITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\certprop\certprop.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    PropCert

Abstract:

    This module initiates smart card cert propagation to 'My' store.
    It is loaded and started by winlogon through an entry in the registry.

Author:

    Klaus Schutz

--*/

#include "stdafx.h"
#include <wincrypt.h>
#include <winscard.h>
#include <winwlx.h>

#include "calaislb.h"
#include "scrdcert.h"   // smart card cert store
#include "certprop.h"
#include "StatMon.h"    // smart card reader status monitor
#include "scevents.h"

#include <mmsystem.h>

#ifndef SCARD_PROVIDER_CSP
#define SCARD_PROVIDER_CSP 2
#endif

#define REG_KEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\ScCertProp"

static THREADDATA l_ThreadData;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if defined(DBG) || defined(DEBUG)
BOOL Debug = TRUE;
#define DebugPrint(a) _DebugPrint a
void
__cdecl
_DebugPrint(
    LPCTSTR szFormat,
    ...
    )
{
    if (Debug) {
     	
        TCHAR szBuffer[512];
        va_list ap;

        va_start(ap, szFormat);
        _vstprintf(szBuffer, szFormat, ap);
        OutputDebugString(szBuffer);
    }
}

#else
#define DebugPrint(a)
#endif

LPCTSTR
FirstString(
    IN LPCTSTR szMultiString
    )
/*++

FirstString:

    This routine returns a pointer to the first string in a multistring, or NULL
    if there aren't any.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the first null-terminated string in the structure, or NULL if
    there are no strings.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/
{
    LPCTSTR szFirst = NULL;

    try
    {
        if (0 != *szMultiString)
            szFirst = szMultiString;
    }
    catch (...) {}

    return szFirst;
}

LPCTSTR
NextString(
    IN LPCTSTR szMultiString)
/*++

NextString:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the current string in a
    multi-string structure, it returns the next string, or NULL if no other
    strings follow the current string.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the next Null-terminated string in the structure, or NULL if
    no more strings follow.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/
{
    LPCTSTR szNext;

    try
    {
        DWORD cchLen = lstrlen(szMultiString);
        if (0 == cchLen)
            szNext = NULL;
        else
        {
            szNext = szMultiString + cchLen + 1;
            if (0 == *szNext)
                szNext = NULL;
        }
    }

    catch (...)
    {
        szNext = NULL;
    }

    return szNext;
}

/*++

MoveToUnicodeString:

    This routine moves the internal string representation to a UNICODE output
    buffer.

Arguments:

    szDst receives the output string.  It must be sufficiently large enough to
        handle the string.  If this parameter is NULL, then the number of
        characters required to hold the result is returned.

    szSrc supplies the input string.

    cchLength supplies the length of the input string, with or without trailing
        nulls.  A -1 value implies the length should be computed based on a
        trailing null.

Return Value:

    The length of the resultant string, in characters, including the trailing
    null.

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 2/14/1997

--*/

DWORD
MoveToUnicodeString(
    LPWSTR szDst,
    LPCTSTR szSrc,
    DWORD cchLength)
{
    if ((DWORD)(-1) == cchLength)
        cchLength = lstrlen(szSrc);
    else
    {
        while ((0 < cchLength) && (0 == szSrc[cchLength - 1]))
            cchLength -= 1;
    }

#ifndef UNICODE
    if (0 == *szSrc)
        cchLength = 1;
    else if (NULL == szDst)
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            NULL,
            0);
        if (0 == cchLength)
            throw GetLastError();
        cchLength += 1;
    }
    else
    {
        cchLength =
            MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,
            szSrc,
            cchLength,
            szDst,
            cchLength);
        if (0 == cchLength)
            throw GetLastError();
        szDst[cchLength++] = 0;
    }
#else
    cchLength += 1;
    if (NULL != szDst)
        CopyMemory(szDst, szSrc, cchLength * sizeof(TCHAR));
#endif
    return cchLength;
}

void
StopMonitorReaders(
    THREADDATA *ThreadData
    )
{
    DWORD dwRet;

    _ASSERT(ThreadData != NULL);

    SetEvent(ThreadData->hClose);

    if (ThreadData->hSCardContext) {
     	
        SCardCancel(ThreadData->hSCardContext);  	
    }
}

DWORD
WINAPI
StartMonitorReaders( 
    LPVOID lpParameter
    )
{
    LPCTSTR szCardHandled = "KS";
    LPCTSTR  newPnPReader = SCPNP_NOTIFICATION;
    THREADDATA  *ThreadData = (THREADDATA *) lpParameter;
    HANDLE hCalaisStarted = NULL;
    HANDLE lHandles[2];

    //
    // We use this outer loop to restart in case the 
    // resource manager was stopped
    //
    while (WaitForSingleObject(ThreadData->hClose, 0) == WAIT_TIMEOUT) {
     	
        // Acquire context with resource manager
        LONG lReturn = SCardEstablishContext(
            SCARD_SCOPE_SYSTEM,
            NULL,
            NULL,
            &ThreadData->hSCardContext
            );

        if (SCARD_S_SUCCESS != lReturn) {

            if (SCARD_E_NO_SERVICE == lReturn) {

                // SCRM not started yet. Give it a chance
                hCalaisStarted = CalaisAccessStartedEvent();

                if (hCalaisStarted == NULL) {

                    // no way to recover
                    break;             	
                }

                lHandles[0] = hCalaisStarted;
                lHandles[1] = ThreadData->hClose;

                lReturn = WaitForMultipleObjectsEx(
                    2,
                    lHandles,
                    FALSE,
                    120 * 1000,     // only couple minutes
                    FALSE
                    );         
            
                if (lReturn != WAIT_OBJECT_0) {

                    // We stop if an error occured or if the user logs out
                    break;             	
                }

                // Otherwise the resource manager has started
                DebugPrint(("ScCertProp: Smart card resource manager started\n"));
                continue;
            }

            // The prev. call should never fail
            // It's better to termninate this thread.
            break;
        }

        LPCTSTR szReaderName = NULL;
        DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
        // now list the available readers
        lReturn = SCardListReaders( 
            ThreadData->hSCardContext,
            SCARD_DEFAULT_READERS,
            (LPTSTR)&szReaderName,
            &dwAutoAllocate
            );

        SCARD_READERSTATE   rgReaders[MAXIMUM_SMARTCARD_READERS + 1];
        // First, make sure the array is totally zeroed.
        ZeroMemory((LPVOID) rgReaders, sizeof(rgReaders));

        // add the 'new pnp reader has arrived' reader
        rgReaders[0].szReader = newPnPReader;
        rgReaders[0].dwCurrentState = 0;
        DWORD dwNumReaders = 1;

        // And build a bare-bones readerstatearray IFF there are any readers
        if (SCARD_S_SUCCESS == lReturn)
        {
            szReaderName = FirstString( szReaderName );

            while (NULL != szReaderName && 
                   dwNumReaders < MAXIMUM_SMARTCARD_READERS + 1) {

                DebugPrint(
                    ("ScCertProp: Found reader: '%s'\n", 
                    szReaderName)
                    );

                rgReaders[dwNumReaders].szReader = (LPCTSTR) szReaderName;
                rgReaders[dwNumReaders].dwCurrentState = SCARD_STATE_EMPTY;

                szReaderName = NextString(szReaderName);
                dwNumReaders++;
            }
        }

        if (SCARD_S_SUCCESS != lReturn) {

            DebugPrint(("ScCertProp: No readers found. Waiting for new reader arrival...\n"));
            //
            // We now will call SCardGetStatusChange which 
            // will return upon new reader arrival
            //
        }

        BOOL fNewReader = FALSE;

        // analyze newly inserted cards and prop certs as necessary
        while (WaitForSingleObject(ThreadData->hClose, 0) == WAIT_TIMEOUT &&
               fNewReader == FALSE) {

            //
            // Wait for a change in the system status before continuing; quit if an error occurred
            //
            lReturn = SCardGetStatusChange( 
                ThreadData->hSCardContext,
                INFINITE,
                rgReaders,
                dwNumReaders
                );

#ifdef DEBUG_VERBOSE
            DebugPrint(
                ("ScCertProp: SCardGetStatusChange returned %lx\n",
                lReturn)
                );
#endif

            if (SCARD_E_SYSTEM_CANCELLED == lReturn) {

                DebugPrint(("ScCertProp: Smart card resource manager stopped\n"));

                // Clean up
                if (NULL != szReaderName)
                {
                    SCardFreeMemory(ThreadData->hSCardContext, (PVOID)szReaderName);
                    szReaderName = NULL;
                }
                if (NULL != ThreadData->hSCardContext)                 
                {
                    SCardReleaseContext(ThreadData->hSCardContext);
                    ThreadData->hSCardContext = NULL;
                }

                //
                // The resource manager has been stopped.
                // Wait until it restarted or until the user logs out
                //
                hCalaisStarted = CalaisAccessStartedEvent();

                if (hCalaisStarted == NULL) {

                    // no way to recover. stop cert prop
                    StopMonitorReaders(ThreadData);
                    break;             	
                }

                lHandles[0] = hCalaisStarted;
                lHandles[1] = ThreadData->hClose;

                lReturn = WaitForMultipleObjectsEx(
                    2,
                    lHandles,
                    FALSE,
                    INFINITE,
                    FALSE
                    );         
            
                if (lReturn != WAIT_OBJECT_0) {

                    // We stop if an error occured or if the user logs out
                    StopMonitorReaders(ThreadData);
                    break;             	
                }

                // Otherwise the resource manager has been restarted
                DebugPrint(("ScCertProp: Smart card resource manager re-started\n"));
                break;
            }

            if (SCARD_S_SUCCESS != lReturn)
            {
                if (SCARD_E_CANCELLED != lReturn)
                    StopMonitorReaders(ThreadData);
			    break;
            }

#ifdef DEBUG_VERBOSE
            DebugPrint(
                ("ScCertProp: Reader(PnP) state %lx/%lx\n",
                rgReaders[0].dwCurrentState, 
                rgReaders[0].dwEventState)
                );
#endif
            // check if a new reader showed up
            if ((dwNumReaders == 1 || rgReaders[0].dwCurrentState != 0) && 
                rgReaders[0].dwEventState & SCARD_STATE_CHANGED) {
                
                DebugPrint(("ScCertProp: New reader reported...\n"));
                fNewReader = TRUE;
                break;
            }

            rgReaders[0].dwCurrentState = rgReaders[0].dwEventState;

            //
            // Enumerate the readers and for every recognized card that's been
            // inserted and has an associated CSP, get a cert (if there is one)
            // off the default container and prop it to the 'My' store
            //            
            for (DWORD dwIndex = 1; dwIndex < dwNumReaders; dwIndex++)
            {
#ifdef DEBUG_VERBOSE
                DebugPrint(
                    ("ScCertProp: Reader(%s) state %lx/%lx\n",
                    rgReaders[dwIndex].szReader,
                    rgReaders[dwIndex].dwCurrentState, 
                    rgReaders[dwIndex].dwEventState)
                    );
#endif

                if ((rgReaders[dwIndex].dwCurrentState & SCARD_STATE_EMPTY) &&
                    (rgReaders[dwIndex].dwEventState & SCARD_STATE_PRESENT)) {
                     	
                    // play sound for card insertion
                    PlaySound(
                        TEXT("SmartcardInsertion"),
                        NULL,
                        SND_ASYNC | SND_ALIAS | SND_NODEFAULT
                        );
                }

                if ((rgReaders[dwIndex].dwCurrentState & SCARD_STATE_PRESENT) &&
                    (rgReaders[dwIndex].dwEventState & SCARD_STATE_EMPTY)) {
                     	
                    // play sound for card removal
                    PlaySound(
                        TEXT("SmartcardRemoval"),
                        NULL,
                        SND_ASYNC | SND_ALIAS | SND_NODEFAULT
                        );
                }

                if ((rgReaders[dwIndex].dwCurrentState & SCARD_STATE_EMPTY) &&
                    (rgReaders[dwIndex].dwEventState & SCARD_STATE_PRESENT) &&
                    (rgReaders[dwIndex].dwEventState & SCARD_STATE_CHANGED) &&
                    (rgReaders[dwIndex].pvUserData != (PVOID) szCardHandled))
                {

                    // Get the name of the card
                    LPCSTR szCardName = NULL;
                    dwAutoAllocate = SCARD_AUTOALLOCATE;
                    lReturn = SCardListCards(   
                        ThreadData->hSCardContext,
                        rgReaders[dwIndex].rgbAtr,
                        NULL,
                        0,
                        (LPTSTR)&szCardName,
                        &dwAutoAllocate
                        );

                    LPCSTR szCSPName = NULL;
                    if (SCARD_S_SUCCESS == lReturn)
                    {
                        dwAutoAllocate = SCARD_AUTOALLOCATE;
                        lReturn = SCardGetCardTypeProviderName(
                            ThreadData->hSCardContext,
                            szCardName,
                            SCARD_PROVIDER_CSP,
                            (LPTSTR)&szCSPName,
                            &dwAutoAllocate
                            );
                    }

                    DebugPrint(
                        ("ScCertProp: Smart Card '%s' inserted into reader '%s'\n", 
                        (strlen(szCardName) ? szCardName : "<Unknown>"),
                        rgReaders[dwIndex].szReader)
                        );

                    if (SCARD_S_SUCCESS == lReturn)
                    {
                        PPROPDATA PropData = (PPROPDATA) LocalAlloc(LPTR, sizeof(PROPDATA));
                        if (PropData) {
                         	
                            _tcscpy(PropData->szReader, rgReaders[dwIndex].szReader);
                            _tcscpy(PropData->szCardName, szCardName);
                            _tcscpy(PropData->szCSPName, szCSPName);
                            PropData->hUserToken = ThreadData->hUserToken;

                            //
                            // Create a thread to propagate this cert.
                            // The thread is responsible to free PropData
                            //
                            HANDLE hThread = CreateThread(
                                NULL,
                                0,
                                PropagateCertificates,
                                (LPVOID) PropData,         
	                            0,
                                NULL
                                );

                            if (hThread == NULL) {

                                LocalFree(PropData);                             	
                            }
                        }
                    }

                    //
                    // Clean up
                    //
                    if (NULL != szCSPName)
                    {
                        SCardFreeMemory(ThreadData->hSCardContext, (PVOID)szCSPName);
                        szCSPName = NULL;
                    }
                    if (NULL != szCardName)
                    {
                        SCardFreeMemory(ThreadData->hSCardContext, (PVOID)szCardName);
                        szCardName = NULL;
                    }

                    // Record that we're done with this card
                    rgReaders[dwIndex].pvUserData = (PVOID) szCardHandled;

                }
                else
                {
                    // there's no card to handle in this reader; reset pvUserData
                    rgReaders[dwIndex].pvUserData = NULL;
                }

                // Update the "current state" of this reader
                rgReaders[dwIndex].dwCurrentState = rgReaders[dwIndex].dwEventState;
            }
        }

        // Clean up
        if (NULL != szReaderName)
        {
            SCardFreeMemory(ThreadData->hSCardContext, (PVOID)szReaderName);
            szReaderName = NULL;
        }
        if (NULL != ThreadData->hSCardContext)                 
        {
            SCardReleaseContext(ThreadData->hSCardContext);
            ThreadData->hSCardContext = NULL;
        }
    }

    return TRUE;
}

DWORD
WINAPI
PropagateCertificates(
    LPVOID lpParameter
    )
/*++

Routine Description:
	This function propagates the cert of a card.
    It runs as a seperate thread

--*/
{
    PPROPDATA PropData = (PPROPDATA) lpParameter;
    BOOL    fSts = FALSE;
    long    lErr = 0;
    DWORD   dwIndex = 0;

    DWORD   cbContainerName = 0;
    LPSTR   szContainerName = NULL;
    LPWSTR  lpwszContainerName = NULL;
    LPWSTR  lpwszCSPName = NULL;
    LPWSTR  lpwszCardName = NULL;
    LPSTR lpszContainerName = NULL;
    DWORD   dwCertLen = 0;
    LPBYTE  pbCert = NULL;

    CRYPT_KEY_PROV_INFO keyProvInfo;
    HCERTSTORE hCertStore = NULL;
    HCRYPTKEY  hKey = NULL;
    HCRYPTPROV hCryptProv = NULL;

    LPCTSTR szCSPName = PropData->szCSPName;
    LPCTSTR szCardName = PropData->szCardName;

    static const DWORD rgdwKeys[] = { AT_KEYEXCHANGE , AT_SIGNATURE };
    static const DWORD cdwKeys = sizeof(rgdwKeys) / sizeof(DWORD);

#if defined(DBG) || defined(DEBUG)
    time_t start = time(NULL);
#endif

    lpszContainerName = (LPSTR) LocalAlloc(
        LPTR, 
        strlen(PropData->szReader) + 10
        );

    if (lpszContainerName == NULL) {
     	
        lErr = NTE_NO_MEMORY;
        goto ErrorExit;
    }

    sprintf(lpszContainerName, "\\\\.\\%s\\", PropData->szReader);

    fSts = CryptAcquireContext(
        &hCryptProv,
        lpszContainerName, 
        PropData->szCSPName,
        PROV_RSA_FULL,
        CRYPT_SILENT
        );

    DebugPrint(
        ("ScCertProp(%s): CryptAcquireContext took %ld seconds to return %lx\n", 
        PropData->szCardName,
        (time(NULL) - start),
        GetLastError())
        );

    LocalFree(lpszContainerName);

    if (fSts == FALSE) {

        lErr = GetLastError();
        goto ErrorExit;   	
    }

    // the following struct is always empty, for I_CryptAddSmartCardCertToStore
    CRYPT_DATA_BLOB scCryptData;
    memset(&scCryptData, 0, sizeof(CRYPT_DATA_BLOB));

    //
    // Get the default container name, so we can use it
    //
    fSts = CryptGetProvParam(
        hCryptProv,
        PP_CONTAINER,
        NULL,
        &cbContainerName,
        0
        );

    if (!fSts)
    {
        lErr = GetLastError();
        goto ErrorExit;
    }

    szContainerName = (LPSTR) LocalAlloc(LPTR, cbContainerName);
    if (NULL == szContainerName)
    {
        lErr = NTE_NO_MEMORY;
        goto ErrorExit;
    }

    fSts = CryptGetProvParam(
        hCryptProv,
        PP_CONTAINER,
        (PBYTE)szContainerName,
        &cbContainerName,
        0
        );

    if (!fSts)
    {
        lErr = GetLastError();
        goto ErrorExit;
    }

    //
    // Prepare the key prov info that's generic to all keysets
    //
    lpwszContainerName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (lstrlen(szContainerName) + 1));
    lpwszCSPName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (lstrlen(szCSPName) + 1));
    lpwszCardName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (lstrlen(szCardName) + 1));
    if ((NULL == lpwszCSPName) || (NULL == lpwszCardName) || (NULL == lpwszContainerName))
    {
        lErr = NTE_NO_MEMORY;
        goto ErrorExit;
    }

    MoveToUnicodeString(lpwszContainerName, szContainerName, lstrlen(szContainerName) + 1);
    MoveToUnicodeString(lpwszCSPName, szCSPName, lstrlen(szCSPName) + 1);
    MoveToUnicodeString(lpwszCardName, szCardName, lstrlen(szCardName) + 1);

    memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
    keyProvInfo.pwszContainerName   = lpwszContainerName;
    keyProvInfo.pwszProvName        = lpwszCSPName;
    keyProvInfo.dwProvType          = PROV_RSA_FULL;
    keyProvInfo.dwFlags             = 0;
    keyProvInfo.cProvParam          = 0;
    keyProvInfo.rgProvParam         = NULL;

    //
    // For each keyset in this container, get the cert and make
    // a cert context, then prop the cert to the My store
    //
    for (dwIndex = 0; dwIndex < cdwKeys; dwIndex += 1)
    {
        try
        {
            //
            // Note which key we're working with and get the key handle.
            //
            keyProvInfo.dwKeySpec = rgdwKeys[dwIndex];

            fSts = CryptGetUserKey(
                hCryptProv,
                rgdwKeys[dwIndex],
                &hKey
                );

            if (!fSts)
            {
                lErr = GetLastError();
                if (NTE_NO_KEY != lErr)
                {
                    throw lErr;
                }
            }

            //
            // Upload the certificate & prep CertData blob
            //
            if (fSts)
            {
                fSts = CryptGetKeyParam(
                    hKey,
                    KP_CERTIFICATE,
                    NULL,
                    &dwCertLen,
                    0
                    );

                if (!fSts)
                {
                    lErr = GetLastError();
                    if (ERROR_MORE_DATA == lErr)
                    {
                        // There's a certificate -- this means SUCCESS!
                        fSts = TRUE;
                    }
                    //
                    // otherwise, there may be a key but no cert
                    // this just means that there's nothing to do.
                    //
                }
            }

            if (!fSts) {
             	
                DebugPrint(
                    ("ScCertProp(%s): No %s certificate on card\n",
                    PropData->szCardName,
                    (dwIndex == 0 ? "key exchange" : "signature"))
                    );
            }

            if (fSts)
            {
                pbCert = (LPBYTE) LocalAlloc(LPTR, dwCertLen);
                if (NULL == pbCert)
                {
                    throw ERROR_OUTOFMEMORY;
                }

                fSts = CryptGetKeyParam(
                    hKey,
                    KP_CERTIFICATE,
                    pbCert,
                    &dwCertLen,
                    0
                    );

                if (!fSts)
                {
                    throw (long) GetLastError();
                }
            }

            if (fSts)
            {
                CRYPT_DATA_BLOB cdbCertData;
                cdbCertData.cbData = dwCertLen;
                cdbCertData.pbData = pbCert;

                if (PropData->hUserToken && !ImpersonateLoggedOnUser( PropData->hUserToken )) {

                    DebugPrint(("ScCertProp: ImpersonateLoggedOnUser failed\n"));
                    throw (long) GetLastError();
                }

                try
                {
                    //
                    // Open the MyStore -- and add the cert if it's not there
                    //
                    hCertStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W,               // "My store"
                        0,                                      // not applicable
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG |
                        CERT_SYSTEM_STORE_CURRENT_USER,
                        L"MY"
                        );

                    if (NULL == hCertStore)
                    {
                        throw((long)GetLastError());
                    }
                    // is the cert already there?
                    SMART_CARD_CERT_FIND_DATA sccfd;
                    memset(&sccfd, 0, sizeof(SMART_CARD_CERT_FIND_DATA));
                    sccfd.cbSize = sizeof(SMART_CARD_CERT_FIND_DATA);
                    sccfd.pwszProvider = keyProvInfo.pwszProvName;
                    sccfd.dwProviderType = keyProvInfo.dwProvType;
                    sccfd.pwszContainer = keyProvInfo.pwszContainerName;
                    sccfd.dwKeySpec = keyProvInfo.dwKeySpec;

                    PCCERT_CONTEXT pCCtx = NULL;
                    pCCtx = I_CryptFindSmartCardCertInStore (
                        hCertStore,
                        pCCtx, 
                        &sccfd,
                        NULL
                        );

                    BOOL fSame = FALSE;

                    if (pCCtx != NULL)
                    {
                        if ((pCCtx->cbCertEncoded == dwCertLen) &&
                            (memcmp(pCCtx->pbCertEncoded, pbCert, dwCertLen) == 0))
                        {
                            fSame = TRUE;
                        }

                        CertFreeCertificateContext(pCCtx);
                        pCCtx = NULL;

                        DebugPrint(
                            ("ScCertProp(%s): %s certificate already in store\n",
                            PropData->szCardName,
                            (dwIndex == 0 ? "Key exchange" : "Signature"))
                            );

                        fSts = TRUE;
                    }

                    if (!fSame)
                    {
                        // this by default does "replace existing"
                        fSts = I_CryptAddSmartCardCertToStore(
                            hCertStore,
                            &cdbCertData,
                            NULL,   
                            &scCryptData, 
                            &keyProvInfo
                            );

                        DebugPrint(
                            ("ScCertProp(%s): %s certificate %s propagated\n",
                            PropData->szCardName,
                            (dwIndex == 0 ? "Key exchange" : "Signature"),
                            (fSts ? "successfully" : "NOT"))
                            );

                    }

                    if (NULL != hCertStore)
                    {
                        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
                        hCertStore = NULL;
                    }
                    if (!fSts)
                    {
                        throw((long) GetLastError());
                    }
                    RevertToSelf();
                }
                catch(...)
                {
                    RevertToSelf();
                    throw;
                }
            }
        }
        catch (...)
        {
        }

        // clean up each time around...

        if (NULL != hKey)
        {
            CryptDestroyKey(hKey);
            hKey = NULL;
        }
        if (NULL != pbCert)
        {
            LocalFree(pbCert);
            pbCert = NULL;
            dwCertLen = 0;
        }
    }

ErrorExit:

    if (NULL != szContainerName)
    {
        LocalFree(szContainerName);
    }
    if (NULL != lpwszContainerName)
    {
        LocalFree(lpwszContainerName);
    }
    if (NULL != lpwszCSPName)
    {
        LocalFree(lpwszCSPName);
    }
    if (NULL != lpwszCardName)
    {
        LocalFree(lpwszCardName);
    }
    if (NULL != pbCert)
    {
        LocalFree(pbCert);                                    
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != hCryptProv)
    {
        CryptReleaseContext(hCryptProv, 0);
    }

    DebugPrint(
        ("ScCertProp(%s): Certificate propagation took %ld seconds\n", 
        PropData->szCardName,
        (time(NULL) - start))
        );

    LocalFree(PropData);

    return ERROR_SUCCESS;
}

DWORD WINAPI
SCardStartCertProp(
    LPVOID lpvParam
    )
/*++

Routine Description:
    Starts cert. propagation after the user logged on.

--*/
{
    PWLX_NOTIFICATION_INFO User = (PWLX_NOTIFICATION_INFO) lpvParam;
    HKEY hKey;
    DWORD fEnabled = TRUE;

    //
    // First check if cert. prop. is enabled.
    //
    if (RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REG_KEY,
        &hKey) == ERROR_SUCCESS) {

        ULONG uBufferLen = sizeof(fEnabled);
        DWORD dwKeyType;

        RegQueryValueEx(
            hKey,
            "Enabled",
            NULL,
            &dwKeyType,
            (PUCHAR) &fEnabled,
            &uBufferLen);

        RegCloseKey(hKey);
    }

    if (FALSE == fEnabled) {

        DebugPrint(("ScCertProp: Smart card certificate propagation is disabled\n"));
        return ERROR_SUCCESS;     	
    }

    __try {

        if(User) {
         	
            l_ThreadData.hUserToken = User->hToken;
        }

        l_ThreadData.hClose = CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

        if (l_ThreadData.hClose == NULL) {

            __leave;         	
        }

        l_ThreadData.hThread = CreateThread(
            NULL,
            0,
            StartMonitorReaders,
            (LPVOID) &l_ThreadData,         
	        CREATE_SUSPENDED,
            NULL
            );

        if (l_ThreadData.hThread == NULL) {

            CloseHandle(l_ThreadData.hClose);
            __leave;         	
        }

		l_ThreadData.fSuspended = FALSE;	// was initially suspended, not anymore

        ResumeThread(l_ThreadData.hThread);

        DebugPrint(("ScCertProp: Smart card certificate propagation started\n"));
    }

    __finally {

    }

    return ERROR_SUCCESS;
}

DWORD WINAPI
SCardStopCertProp(
    LPVOID lpvParam
    )
/*++

Routine Description:
    Stops cert. propagation when the user logs out.

Arguments:
    lpvParam - Winlogon notification info.

--*/
{
    UNREFERENCED_PARAMETER(lpvParam);

	if(NULL != l_ThreadData.hThread)
	{
        DWORD dwStatus;

			// If the user that unlocks the workstation is different from the one
			// that locked it, Logoff occurs without an Unlock, thus the thread is
			// still suspended. This should take care of it.
		if (l_ThreadData.fSuspended)
		{
			ResumeThread(l_ThreadData.hThread);
	        l_ThreadData.fSuspended = FALSE;
		}
        
        StopMonitorReaders(&l_ThreadData);
        dwStatus = WaitForSingleObject(
            l_ThreadData.hThread, 
            INFINITE
            );
        _ASSERT(dwStatus == WAIT_OBJECT_0);
        CloseHandle(l_ThreadData.hClose);
        l_ThreadData.hClose = NULL;
        CloseHandle(l_ThreadData.hThread);
        l_ThreadData.hThread = NULL;
        DebugPrint(("ScCertProp: Smart card certificate propagation stopped\n"));
	}

    return ERROR_SUCCESS;
}

DWORD WINAPI
SCardSuspendCertProp(
    LPVOID lpvParam
    )
/*++

Routine Description:
    Suspens cert. propagation when the workstation will be locked
    	
Arguments:
    lpvParam - Winlogon notification info.

--*/
{
    UNREFERENCED_PARAMETER(lpvParam);

		// The suspended flag should take care of the following scenario:
		// Winlogon generates lock notification each time the locked dialog appears
		// (vs. only once when the wks is locked) and the thread would get suspended
		// amny times. This happens when the screen saver is kicking on & off while
		// the wks is locked (Bug 105852)
    if ((NULL != l_ThreadData.hThread) && (!l_ThreadData.fSuspended)){

        SuspendThread(l_ThreadData.hThread);
        l_ThreadData.fSuspended = TRUE;
        DebugPrint(("ScCertProp: Smart card certificate propagation suspended\n"));
    }
    return ERROR_SUCCESS;     	
}

DWORD WINAPI
SCardResumeCertProp(
    LPVOID lpvParam
    )
/*++

Routine Description:
	Resumes cert. propagation after unlocking the workstation

Arguments:
    lpvParam - Winlogon notification info.

--*/
{     	
    UNREFERENCED_PARAMETER(lpvParam);

    if (NULL != l_ThreadData.hThread) {

        ResumeThread(l_ThreadData.hThread);
        l_ThreadData.fSuspended = FALSE;
        DebugPrint(("ScCertProp: Smart card certificate propagation resumed\n"));
    }
    return ERROR_SUCCESS;     	
}

DWORD WINAPI
SCardEnableCertProp(
    BOOL On
    )
/*++

Routine Description:
    Allows cert. propagation to be turned off/on 
	
Arguments:
    On - TRUE turn on, else off

--*/
{
    HKEY l_hKey;
    LONG l_lResult;
	
    if ((l_lResult = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REG_KEY,
        &l_hKey)) == ERROR_SUCCESS) {

        l_lResult = RegSetValueEx(  
            l_hKey,     
            "Enabled",
            0,
            REG_DWORD,
            (PUCHAR) &On,
            sizeof(DWORD)
            );

        RegCloseKey(l_hKey);
    }

    return l_lResult;
}

#ifdef test
__cdecl
main(
    int argc,
    char ** argv
    )
{
    EnableScCertProp(TRUE);
    StartScCertProp(NULL);
    getchar();
    StopScCertProp(&l_ThreadData);

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\statmon.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    StatMon

Abstract:

    This file contains the implementation of CScStatusMonitor
    (an object that watches for status changes of readers recognized
    by the smart card service, handling PNP and requests for copies of
    the status array)

Author:

    Amanda Matlosz      02/26/98

Environment:

    Win32, C++ with exceptions

Revision History:

Notes:

--*/
#include "statmon.h"

// forward declarations of private functions
UINT ScStatusChangeProc(LPVOID pParam);


/////
// CScStatusMonitor

CScStatusMonitor::~CScStatusMonitor()
{
    if (stopped != m_status)
    {
        Stop();
    }
}


/*++

Start:

    The monitor will fail to start if:

        Any of the arguments are missing.
        Two SCARDCONTEXTs could not be acquired from the RM.
        An error occurs while retrieving a list of readers from the RM.
        Or the status thread fails to start.

Arguments:

    hWnd -- The monitor's owner's HWND, for sending notification messages.

    uiMsg -- The message that will be posted to the hWnd of the monitor's owner
                     when a change in status has occurred.

    szGroupNames -- Reader groups we're interested in.  see "winscard.h"

Return Value:

    LONG.

Author:

    Amanda Matlosz      02/26/98

Notes:

  If already started, causes a restart.
  All the arguments are required.

--*/
LONG CScStatusMonitor::Start(HWND hWnd, UINT uiMsg, LPCTSTR szGroupNames)
{
    LONG lReturn = SCARD_S_SUCCESS;

    // the monitor must be uninitialized or stopped before it can start
    if (uninitialized != m_status && stopped != m_status)
    {
        Stop();
    }

    if (NULL == hWnd || 0 == uiMsg)
    {
        // invalid parameters
        m_status = uninitialized;
        return ERROR_INVALID_PARAMETER;
    }

    m_hwnd = hWnd;
    m_uiStatusChangeMsg = uiMsg;

    if (NULL == szGroupNames || 0 == _tcslen(szGroupNames))
    {
        m_strGroupNames = SCARD_DEFAULT_READERS;
    }

    //
    // Get two contexts from the resource manager to use,
    // one for the monitor itself, and one for it's status-watching thread
    //

    m_hContext = NULL;
    m_hInternalContext = NULL;

    lReturn = SCardEstablishContext(SCARD_SCOPE_USER,
                                    NULL,
                                    NULL,
                                    &m_hContext);

    if (SCARD_S_SUCCESS == lReturn)
    {
        lReturn = SCardEstablishContext(SCARD_SCOPE_USER,
                                        NULL,
                                        NULL,
                                        &m_hInternalContext);
    }

    if (SCARD_S_SUCCESS != lReturn)
    {
        m_status = no_service;

        if (NULL != m_hContext)
        {
            SCardReleaseContext(m_hContext);
            m_hContext = NULL;
        }
        if (NULL != m_hInternalContext)
        {
            SCardReleaseContext(m_hInternalContext);
            m_hInternalContext = NULL;
        }
    }
    //
    // If we successfully got a context, go ahead and initialize
    // the internal reader status array & kick off status thread
    //
    else
    {
        lReturn = InitInternalReaderStatus();
    }

    if (SCARD_S_SUCCESS == lReturn)
    {
        m_status = running;

        // kick off status thread
        m_pStatusThrd = AfxBeginThread((AFX_THREADPROC)ScStatusChangeProc,
										(LPVOID)this,
										THREAD_PRIORITY_NORMAL,
										0,
										CREATE_SUSPENDED);

        if (NULL == m_pStatusThrd)
        {
            m_status = stopped;
            return GetLastError();
        }

		m_pStatusThrd->m_bAutoDelete = FALSE; // don't delete the thread on completion
		m_pStatusThrd->ResumeThread();
    }

    return lReturn;
}


/*++

Stop:

    In order to stop the monitor, the SCARDCONTEXTS are canceled, the
    status thread is shut down, and data members that are only valid while
    running are cleaned up.

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
void CScStatusMonitor::Stop()
{
    m_status = stopped;

    // tell thread to stop now
    SCardCancel(m_hInternalContext);

    if (NULL != m_pStatusThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_pStatusThrd->m_hThread, INFINITE); // for testing: 10000
        _ASSERTE(WAIT_OBJECT_0 == dwRet);

		delete m_pStatusThrd;
        m_pStatusThrd = NULL;
    }

	// clear out internal scardcontext

    SCardReleaseContext(m_hInternalContext);
	m_hInternalContext = NULL;

    // Empty external readerstatusarray

    EmptyExternalReaderStatus();

    // Empty internal readerstatusarray

    if (NULL != m_pInternalReaderStatus)
    {
        delete[] m_pInternalReaderStatus;
        m_pInternalReaderStatus = NULL;
    }
    m_dwInternalNumReaders = 0;

    // Close main scardcontext so nothing can happen 'til restart
    SCardReleaseContext(m_hContext);
	m_hContext = NULL;
}


/*++

EmptyExternalReaderStatus:

    This empties out the external CSCardReaderStateArray, deleting
    all CSCardReaderState objects it has pointers to.

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
void CScStatusMonitor::EmptyExternalReaderStatus(void)
{
    for (int nIndex = (int)m_aReaderStatus.GetUpperBound(); 0 <= nIndex; nIndex--)
    {
        delete m_aReaderStatus[nIndex];
    }

    m_aReaderStatus.RemoveAll();
}


/*++

GetReaderStatus:

    This returns copies of the Readers (CSCardReaderState) in the
    "external" array.

    It is assumed that the user is handing us an empty
    CSCardReaderStateArray, or one that is safe to be emptied.

Arguments:

    aReaderStatus -- a reference to a CSCardReaderStateArray that will
    receive the values of the new array.  If it is not empty, all the objects
    pointed to will be deleted and removed.

Return Value:

    None.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
void CScStatusMonitor::GetReaderStatus(CSCardReaderStateArray& aReaderStatus)
{
    m_csRdrStsLock.Lock();

    // Make sure they gave us an empty array;
    // empty it out for them politely if they didn't.

    if (0 != aReaderStatus.GetSize())
    {
        for (int i = (int)aReaderStatus.GetUpperBound(); i>=0; i--)
        {
            delete aReaderStatus[i];
        }

        aReaderStatus.RemoveAll();
    }

    // build external copy of internal readerstatusarray
    CSCardReaderState* pReader = NULL;
    for (int i = 0; i <= m_aReaderStatus.GetUpperBound(); i++)
    {
        pReader = new CSCardReaderState(m_aReaderStatus[i]);
        ASSERT(NULL != pReader); // otherwise, fudge
        if (NULL != pReader)
		{
            aReaderStatus.Add(pReader);
		}
    }

    m_csRdrStsLock.Unlock();
}


/*++

SetReaderStatus:

    The external ReaderStatus array is set to mirror the internal
    READERSTATUSARRAY, with some embellishment.

    If the external ReaderStatus array is empty, it will be built.
    It if it not empty, it is assumed to be the correct length.

    The CScStatusMonitor's parent is notified before returning.

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
void CScStatusMonitor::SetReaderStatus()
{
    m_csRdrStsLock.Lock();

    long lReturn = SCARD_S_SUCCESS;
    CSCardReaderState* pReader = NULL;

    //
    // if ext readerstatusarray is empty, initialize it
    //

    if (0 == m_aReaderStatus.GetSize())
    {
        for (DWORD dwIndex=0; dwIndex<m_dwInternalNumReaders; dwIndex++)
        {
            pReader = new CSCardReaderState();
            ASSERT(NULL != pReader);    // If not, fudge.
            if (NULL != pReader)
            {
                pReader->strReader = (LPCTSTR)m_pInternalReaderStatus[dwIndex].szReader;
                pReader->dwCurrentState = m_pInternalReaderStatus[dwIndex].dwCurrentState;
                pReader->dwEventState = m_pInternalReaderStatus[dwIndex].dwEventState;
                pReader->cbAtr = 0;
                pReader->strCard = _T("");
                pReader->dwState = 0;

                m_aReaderStatus.Add(pReader);
            }
        }
        pReader = NULL;
    }

    //
    // Set everything in the external array to match the internal.
    // It's safe to assume that both the internal and external
    // arrays match reader for reader.
    //

    for (DWORD dwIndex=0; dwIndex<m_dwInternalNumReaders; dwIndex++)
    {

        pReader = m_aReaderStatus.GetAt(dwIndex);
        bool fNewCard = false;

        if (NULL == pReader)
        {
            ASSERT(FALSE);  // this should be initialized at this point!
            TRACE(_T("CScStatusMonitor::SetReaderStatus external array does not match internal array."));
            break;
        }

        // set state
        pReader->dwEventState = m_pInternalReaderStatus[dwIndex].dwEventState;
        pReader->dwCurrentState = m_pInternalReaderStatus[dwIndex].dwCurrentState;

        // NO CARD
        if(pReader->dwEventState & SCARD_STATE_EMPTY)
        {
            pReader->dwState = SC_STATUS_NO_CARD;
        }
        // CARD in reader: SHARED, EXCLUSIVE, FREE, UNKNOWN ?
        else if(pReader->dwEventState & SCARD_STATE_PRESENT)
        {
            if (pReader->dwEventState & SCARD_STATE_MUTE)
            {
                pReader->dwState = SC_STATUS_UNKNOWN;
            }
            else if (pReader->dwEventState & SCARD_STATE_INUSE)
            {
                if(pReader->dwEventState & SCARD_STATE_EXCLUSIVE)
                {
                    pReader->dwState = SC_STATUS_EXCLUSIVE;
                }
                else
                {
                    pReader->dwState = SC_STATUS_SHARED;
                }
            }
            else
            {
                pReader->dwState = SC_SATATUS_AVAILABLE;
            }
        }
        // READER ERROR: at this point, something's gone wrong
        else // m_ReaderState.dwEventState & SCARD_STATE_UNAVAILABLE
        {
            pReader->dwState = SC_STATUS_ERROR;
        }

        //
        // ATR and CardName: reset to empty if card is not available/responding
        // else, query RM for first card name to match ATR
        //

        if (SC_STATUS_NO_CARD == pReader->dwState ||
                SC_STATUS_UNKNOWN == pReader->dwState ||
                SC_STATUS_ERROR == pReader->dwState )
        {
            pReader->strCard.Empty();
            pReader->cbAtr = 0;
        }
        else
        {
            LPTSTR szCardName = NULL;
            DWORD dwNumChar = SCARD_AUTOALLOCATE;

            pReader->cbAtr = m_pInternalReaderStatus[dwIndex].cbAtr;
            memcpy(pReader->rgbAtr,
                    m_pInternalReaderStatus[dwIndex].rgbAtr,
                    m_pInternalReaderStatus[dwIndex].cbAtr);

            lReturn = SCardListCards(m_hInternalContext,
                                    (LPCBYTE)pReader->rgbAtr,
                                    NULL,
                                    (DWORD)0,
                                    (LPTSTR)&szCardName,
                                    &dwNumChar);

            if (SCARD_S_SUCCESS == lReturn)
            {
                pReader->strCard = (LPCTSTR)szCardName;
                SCardFreeMemory(m_hInternalContext, (LPVOID)szCardName);
            }
            else
            {
                pReader->strCard.Empty();
            }
        }
    }       // Now the two arrays are in sync

    m_csRdrStsLock.Unlock();

    ::PostMessage(m_hwnd, m_uiStatusChangeMsg, 0, (LONG)lReturn);
}


/*++

InitInternalReaderStatus:

    This resets the internal READERSTATUSARRAY to <empty> before calling
    SCardListReaders; if there are no readers, the array will remain empty;
    if the RM is down, an error will be returned.

Arguments:

    None.

Return Value:

    0 on success; WIN32 error message otherwise.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
LONG CScStatusMonitor::InitInternalReaderStatus()
{
    LONG lReturn = SCARD_S_SUCCESS;

    //
    // Get list of readers from Resource manager
    //
    if (NULL != m_pInternalReaderStatus)
    {
        delete[] m_pInternalReaderStatus;
    }

    DWORD dwNameLength = SCARD_AUTOALLOCATE;
    m_szReaderNames = NULL;
    m_dwInternalNumReaders = 0;

    lReturn = SCardListReaders(m_hContext,
								(LPTSTR)(LPCTSTR)m_strGroupNames,
								(LPTSTR)&m_szReaderNames,
								&dwNameLength);

    if(SCARD_S_SUCCESS == lReturn)
    {
        // make a readerstatusarray big enough for all readers
        m_dwInternalNumReaders = MStringCount(m_szReaderNames);
        _ASSERTE(0 != m_dwInternalNumReaders);
        m_pInternalReaderStatus = new SCARD_READERSTATE[m_dwInternalNumReaders];
        if (NULL != m_pInternalReaderStatus)
        {
            // use the list of readers to build a readerstate array
            LPCTSTR pchReader = m_szReaderNames;
            int nIndex = 0;
            while(0 != *pchReader)
            {
                m_pInternalReaderStatus[nIndex].szReader = pchReader;
                m_pInternalReaderStatus[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
                pchReader += lstrlen(pchReader)+1;
                nIndex++;
            }
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }
    }
    else if (SCARD_E_NO_READERS_AVAILABLE == lReturn)
    {
        m_status = no_readers;
        if(NULL != m_szReaderNames)
        {
            SCardFreeMemory(m_hContext, (LPVOID)m_szReaderNames);
            m_szReaderNames = NULL;
        }
    }
    // else m_status == unknown?

    // this array, and the m_szReaderNames used to build it, are now property of
    // the StatusChangeProc...

    return lReturn;
}


/*++

ScStatusChangeProc:


Arguments:

    pParam - CScStatusMonitor*

Return Value:

    0 on success; WIN32 error message otherwise.

Author:

    Amanda Matlosz      02/26/98

Notes:

--*/
UINT ScStatusChangeProc(LPVOID pParam)
{
    UINT uiReturn = 0;

    if(NULL != pParam)
    {
        return ((CScStatusMonitor*)pParam)->GetStatusChangeProc();
    }

    return SCARD_E_INVALID_PARAMETER;
}


UINT CScStatusMonitor::GetStatusChangeProc()
{
    LONG lReturn = SCARD_S_SUCCESS;

    while (stopped != m_status)
    {
        // Wait for change in status (safe to use pMonitor's internal vars)
        lReturn = SCardGetStatusChange(m_hInternalContext,
                                        INFINITE,
                                        m_pInternalReaderStatus,
                                        m_dwInternalNumReaders);

        // inform monitor that given status has changed (Only on success!)
        if (SCARD_S_SUCCESS == lReturn)
        {
            SetReaderStatus();
        }
        else
        {
            //
            // If the context has been cancelled, quit quietly
            // Otherwise, announce that the thread is aborting prematurely
            //
			m_status = stopped;

            if(SCARD_E_CANCELLED != lReturn)
            {
                // TODO: ? wrap in critsec ?
                m_pStatusThrd = NULL;
                // TODO: ? end crit sec ?

                ::PostMessage(m_hwnd, m_uiStatusChangeMsg, 0, (LONG)lReturn);
            }

            break;
        }

        // Prep the array for the next GetStatusChange call
        for(DWORD dwIndex=0; dwIndex<m_dwInternalNumReaders; dwIndex++)
        {
            m_pInternalReaderStatus[dwIndex].dwCurrentState =
                m_pInternalReaderStatus[dwIndex].dwEventState;
        }
    }

    // Clean Up
    if(NULL != m_szReaderNames)
    {
        SCardFreeMemory(m_hContext, (LPVOID)m_szReaderNames);
        m_szReaderNames = NULL;
    }


    return (UINT)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\common\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCardDlg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\inc\cmnuilb.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cmnuilb.h

Abstract:

	This file includes headers used for the cmnuilb.lib
	
	
Author:

    Chris Dudley 7/28/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

--*/

#ifndef __CMNUILB_H__
#define __CMNUILB_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include <cmnui.h>
#include <rdrstate.h>
#include <senv.h>


/////////////////////////////////////////////////////////////////////////////

#endif // __CMNUILB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\inc\senv.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SEnv

Abstract:

    This file contains the definition of the Smartcard Common
    dialog CSCardEnv class. This class encapsulates Smartcard
    Environment information.

Author:

    Chris Dudley 3/3/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

    Amanda Matlosz 1/29/98  Changed class structure; added Unicode support

Notes:

--*/

#ifndef __SENV_H__
#define __SENV_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "cmnui.h"
#include "rdrstate.h"

/////////////////////////////////////////////////////////////////////////////
//
// CSCardEnv Class - encapsulates current smartcard environment regarding
//                   groups of readers and associated cards/status
//
class CSCardEnv
{

    // Construction/Destruction

public:
    CSCardEnv()
    {
            m_pOCNA = NULL;
            m_pOCNW = NULL;
            m_dwReaderIndex = 0;
            m_hContext = NULL;
    }
    ~CSCardEnv()
    {
        // Release any attached readers
        RemoveReaders();
    }

    // Implementation

public:
    // Initialization / completion routines
    LONG SetOCN(LPOPENCARDNAMEA pOCNA);
    LONG SetOCN(LPOPENCARDNAMEW pOCNW);
    LONG UpdateOCN();

    void SetContext( SCARDCONTEXT hContext );

    // Attributes / properties
    SCARDCONTEXT GetContext() { return m_hContext; }
    void GetCardList(LPCTSTR* pszCardList);
    void GetDialogTitle(CTextString *pstzTitle);
    HWND GetParentHwnd() { return (m_hwndOwner); }
    BOOL IsOCNValid() { return (NULL != m_pOCNA || NULL != m_pOCNW); }
    BOOL IsCallbackValid( void );
    BOOL IsContextValid() { return (m_hContext != NULL); }
    BOOL IsArrayValid() { return (m_rgReaders.GetSize() > 0); }
    int NumberOfReaders() { return (int)m_rgReaders.GetSize(); }
	BOOL CardMeetsSearchCriteria(DWORD dwSelectedReader);

    // Reader array management
    LONG CreateReaderStateArray( LPSCARD_READERSTATE_A* prgReaderStateArray );  // TODO: ?? A/W ??
    void DeleteReaderStateArray( LPSCARD_READERSTATE_A* prgReaderStateArray );  // TODO: ?? A/W ??
    LONG FirstReader( LPSCARD_READERINFO pReaderInfo );
    LONG NextReader( LPSCARD_READERINFO pReaderInfo );
    void RemoveReaders( void );
    LONG UpdateReaders( void );

    // Methods
    LONG NoUISearch( BOOL* pfEnableUI );                        // try this search first...
    LONG Search( int* pcMatches, DWORD* pdwIndex );
    LONG ConnectToReader(DWORD dwSelectedReader);
    LONG ConnectInternal(   DWORD dwSelectedReader,
                            SCARDHANDLE *pHandle,
                            DWORD dwShareMode,
                            DWORD dwProtocols,
                            DWORD* pdwActiveProtocols,
                            CTextString* pszReaderName = NULL,
                            CTextString* pszCardName = NULL);
    LONG ConnectUser(   DWORD dwSelectedReader,
                        SCARDHANDLE *pHandle,
                        CTextString* pszReaderName = NULL,
                        CTextString* pszCardName = NULL);


private:
    LONG BuildReaderArray( LPSTR szReaderNames );   // TODO: ?? A/W ??
	void InitializeAllPossibleCardNames( void );


    // Members

private:

    // Reader information
    CTypedPtrArray<CPtrArray, CSCardReaderState*> m_rgReaders;
    DWORD m_dwReaderIndex;

    // external representation of OpenCardName structs are not touched unless
    // SCardEnv->UpdateOCN explicitly called.
    LPOPENCARDNAMEA     m_pOCNA;
    LPOPENCARDNAMEW     m_pOCNW;

    // internal representation of OpenCardName struct combines ansi/
    // unicode information from whichever kind of OCN user provided
    CTextMultistring     m_strGroupNames;
    CTextMultistring     m_strCardNames;
	CTextMultistring	 m_strAllPossibleCardNames;
    CTextString     m_strReader;
    CTextString     m_strCard;
    CTextString     m_strTitle;

    // only LPOCNCONNPROC needs to differentiate between A/W
    LPOCNCONNPROCA  m_lpfnConnectA;
    LPOCNCONNPROCW  m_lpfnConnectW;
    LPOCNCHKPROC    m_lpfnCheck;
    LPOCNDSCPROC    m_lpfnDisconnect;
    LPVOID          m_lpUserData;

    SCARDCONTEXT    m_hContext;
    HWND            m_hwndOwner;
    LPCGUID         m_rgguidInterfaces;
    DWORD           m_cguidInterfaces;
    DWORD           m_dwFlags;
    LPVOID          m_pvUserData;
    DWORD           m_dwShareMode;
    DWORD           m_dwPreferredProtocols;
    DWORD           m_dwActiveProtocol;
    SCARDHANDLE     m_hCardHandle;

};

///////////////////////////////////////////////////////////////////////////////////////

#endif //__SENV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\inc\cmnui.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Common

Abstract:

    This file contains common includes, data structures, defines, etc. used
    throughtout the common dialog

Author:

    Chris Dudley 3/15/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:
    
    Chris Dudley 5/13/1997

Notes:

--*/

#ifndef __COMMON_H__
#define __COMMON_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include <winscard.h>
#include <SCardLib.h>
#include <scarderr.h> //Smartcard errors

//////////////////////////////////////////////////////////////////////////////
//
// Defines
//

// Status of reader
#define SC_STATUS_NO_CARD       0	// SCARD_STATE_EMPTY
#define SC_STATUS_UNKNOWN		1	// SCARD_STATE_PRESENT | SCARD_STATE_MUTE
#define SC_SATATUS_AVAILABLE	2	// SCARD_STATE_PRESENT (| SCARD_STATE_UNPOWERED)
#define SC_STATUS_SHARED		3	// SCARD_SATATE_PRESENT | SCARD_STATE_INUSE
#define SC_STATUS_EXCLUSIVE		4	// "" | SCARD_STATE_EXCLUSIVE
#define SC_STATUS_ERROR			5	// SCARD_STATE_UNAVAILABLE (reader or card error)

/*
#define SC_STATUS_NO_CARD       0	
#define SC_STATUS_NOT_IN_USE    1
#define SC_STATUS_ERROR         2
#define SC_STATUS_IN_USE        3
*/

/////////////////////////////////////////////////////////////////////////////
//
// Structures
//
#ifndef __READERINFO__
#define __READERINFO__
typedef struct _READERINFO {
    CTextString     sReaderName;    // Reader name
    CTextString     sCardName;      // Card name if inserted
    BOOL            fCardInserted;  // Flag indicating card in reader
    BOOL            fCardLookup;    // Flag indicating inserted card is being looked for
    BOOL            fChecked;       // Flag indicating inserted card has been checked by callers code
    DWORD           dwState;        // State of reader
    DWORD           dwInternalIndex;// Indicates this readerinfo's position in a ReaderStateArray
    BYTE            rgbAtr[36];     // RFU!!
    DWORD           dwAtrLength;    // RFU!!
} SCARD_READERINFO;
typedef SCARD_READERINFO* LPSCARD_READERINFO;
#endif

// Structure used for thread-to-thread communication.
// Note: "Might" want to encapsulate these in class!!
#ifndef __STATUS__
#define __STATUS__
typedef struct _STATUS {
    HWND        hwnd;
    // Event handles
    HANDLE      hEventKillStatus;
    // Smartcard Info
    SCARDCONTEXT hContext;
    LPSCARD_READERSTATE rgReaderState;
    DWORD       dwNumReaders;
} SCSTATUS, *LPSCSTATUS;
#endif //STATUS

////////////////////////////////////////////////////////////////////////////////
//
// Constants
//
#define SCARD_NO_MORE_READERS       -1
const char SCARD_DEFAULT_A[] = "SCard$DefaultReaders\0\0";
const WCHAR SCARD_DEFAULT_W[] = L"SCard$DefaultReaders\0\0";

//////////////////////////////////////////////////////////////////////////
//
// Macros
//
#ifndef SCARDFAILED
    #define SCARDFAILED(r)      ((r != SCARD_S_SUCCESS) ? TRUE : FALSE)
#endif

#ifndef SCARDSUCCESS
    #define SCARDSUCCESS(r)     ((r == SCARD_S_SUCCESS) ? TRUE : FALSE)
#endif

//////////////////////////////////////////////////////////////////////////////

#endif //__SCDLGCMN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\common\senv.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

	SEnv

Abstract:

	This file contains the outline implementation of the Smartcard Common
	dialog CSCardEnv class. This class encapsulates current Smartcard
	environment information (i.e. given groups, readers, cards, etc.)
	
Author:

    Chris Dudley 3/3/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	Chris Dudley (cdudley) 4/15/97
	Amanda Matlosz (amatlosz) 1/29/98 Combined CSCardEnv and CSCardGroup,
										added unicode support

Notes:

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "stdafx.h"
#include "senv.h"
#include <querydb.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// local macros
#ifdef _DEBUG
	#define TRACE_STR(name,sz) \
				TRACE(_T("CmnUILb.lib: %s: %s\n"), name, sz)
	#define TRACE_CODE(name,code) \
				TRACE(_T("CmnUILb.lib: %s: error = 0x%x\n"), name, code)
	#define TRACE_CATCH(name,code)		TRACE_CODE(name,code)
	#define TRACE_CATCH_UNKNOWN(name)	TRACE_STR(name,_T("An unidentified exception has occurred!"))
#else
	#define TRACE_STR(name,sz)			((void)0)
	#define TRACE_CODE(name,code)		((void)0)
	#define TRACE_CATCH(name,code)		((void)0)
	#define TRACE_CATCH_UNKNOWN(name)	((void)0)
#endif  // _DEBUG


/////////////////////////////////////////////////////////////////////////////
//
// CSCardEnv Implementation
//


/*++
GetDialogTitle:

	Routine returns a new title for the dialog if needed

Arguments:

	pstzTitle -- pointer to a CTextString to contain the dialog's title
		
Return Value:
	
    A CTextString object containing the new dialog text or empty string
	if no new title required.

Author:

    Chris Dudley 3/3/1997

Revisions:

	Amanda Matlosz	1/28/98	Add unicode support/code cleanup

Notes:

--*/
void CSCardEnv::GetDialogTitle( CTextString *pstzTitle )
{
	// check & empty params

	ASSERT(NULL != pstzTitle);
	pstzTitle->Clear();

	*pstzTitle = m_strTitle;
}


/*++

LONG CardMeetsSearchCriteria:

    Routine determines if a selected reader has a card inserted which
	meets the search criteria defined by the caller.

Arguments:

	dwSelectedReader - index used to select which reader to query.
		
Return Value:
	
    A BOOL value indicating whether or not the card meets the search criteria.

Author:

	Amanda Matlosz	3/16/1998	created

Revisions:


--*/
BOOL CSCardEnv::CardMeetsSearchCriteria(DWORD dwSelectedReader)
{
	BOOL fReturn = FALSE;
	CSCardReaderState* pReaderState = NULL;
	SCARD_READERINFO ReaderInfo;

	try
	{
		// check params
		if(dwSelectedReader >= (DWORD)NumberOfReaders())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}

		if (!IsContextValid())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		
		// get the reader object
		pReaderState = m_rgReaders[dwSelectedReader];

		// is it valid, matches the search list, and passes the check?
		if (NULL != pReaderState)
		{
			ReaderInfo.fCardLookup = FALSE;
			ReaderInfo.fChecked = FALSE;

			pReaderState->GetReaderInfo(&ReaderInfo);

			fReturn = (ReaderInfo.fCardLookup && ReaderInfo.fChecked);
		}
	}
	catch(LONG lErr)
	{
		TRACE_CATCH(_T("CardMeetsSearchCriteria"), lErr);
	}
	catch(...)
	{
		TRACE_CATCH_UNKNOWN(_T("CardMeetsSearchCriteria"));
	}

	return fReturn;
}
/*++

LONG ConnectToReader:

    Routine connects to a selected reader, and sets the user-provided structs
	to contain the reader&cardname.  returns an error if the user-provided struct's
	buffers aren't long enough.

Arguments:

	dwSelectedReader - index used to select which reader to connect to.
		
Return Value:
	
    A LONG value indicating the status of the requested action.
	See the Smartcard header files for additional information.

Author:

    Chris Dudley 3/3/1997

Revisions:

	Amanda Matlosz	1/28/1998	code cleanup

--*/
LONG CSCardEnv::ConnectToReader(DWORD dwSelectedReader)
{
	LONG lReturn = SCARD_S_SUCCESS;
	LPSTR szName = NULL;
	LPWSTR wszName = NULL;

	try
	{
		if (!IsContextValid())
		{
			throw (LONG)E_FAIL;
		}

		//
		// If user has indicated to make a connection, do so
		// through callbacks or internally.
		// m_strReader and m_strCard are set as a side effect of these connect calls
		//

		if(IsCallbackValid())
		{
			lReturn = ConnectUser(	dwSelectedReader,
									&m_hCardHandle,
									&m_strReader,
									&m_strCard);
		}
		else
		{
			if (0 != m_dwShareMode)
			{
				lReturn = ConnectInternal(	dwSelectedReader,
											&m_hCardHandle,
											m_dwShareMode,
											m_dwPreferredProtocols,
											&m_dwActiveProtocol,
											&m_strReader,
											&m_strCard);
			}
			else
			{
				//
				// MUST set m_strReader and m_strCard manually
				//
				CSCardReaderState* pReaderState = NULL;
				pReaderState = m_rgReaders[dwSelectedReader];
				if (NULL != pReaderState)
				{
					lReturn = pReaderState->GetReaderCardInfo(	&m_strReader,
																&m_strCard);
				}
			}
		}
		if (SCARDFAILED(lReturn))
		{
			throw (lReturn);
		}

		//
		// Set the user's OCN struct to contain return information
		//

		if(NULL != m_pOCNW)
		{
			m_pOCNW->hCardHandle = m_hCardHandle;
			m_pOCNW->dwActiveProtocol = m_dwActiveProtocol;

			wszName = (LPWSTR)(LPCWSTR)m_strReader;
			if (m_pOCNW->nMaxRdr >= m_strReader.Length()+1)
			{
				::CopyMemory(	(LPVOID) m_pOCNW->lpstrRdr,
								(CONST LPVOID)wszName,
								((m_strReader.Length()+1) * sizeof(WCHAR)) );
			}
			else
			{
				m_pOCNW->nMaxRdr = m_strReader.Length()+1;
				throw (LONG)SCARD_E_NO_MEMORY;
			};

			wszName = (LPWSTR)(LPCWSTR)m_strCard;
			if (m_pOCNW->nMaxCard >= m_strCard.Length()+1)
			{
				::CopyMemory(	(LPVOID) m_pOCNW->lpstrCard,
								(CONST LPVOID)wszName,
								((m_strCard.Length()+1) * sizeof(WCHAR)) );
			}
			else
			{
				m_pOCNW->nMaxCard = m_strCard.Length()+1;
				throw (LONG)SCARD_E_NO_MEMORY;
			};
		}
		else if (NULL != m_pOCNA)
		{
			m_pOCNA->hCardHandle = m_hCardHandle;
			m_pOCNA->dwActiveProtocol = m_dwActiveProtocol;

			szName = (LPSTR)(LPCSTR)m_strReader;
			if (m_pOCNA->nMaxRdr >= m_strReader.Length()+1)
			{
				::CopyMemory(	(LPVOID) m_pOCNA->lpstrRdr,
								(CONST LPVOID)szName,
								m_strReader.Length()+1);
			}
			else
			{
				m_pOCNA->nMaxRdr = m_strReader.Length()+1;
				throw (LONG)SCARD_E_NO_MEMORY;
			}
	
			szName = (LPSTR)(LPCSTR)m_strCard;
			if (m_pOCNA->nMaxCard >= m_strCard.Length()+1)
			{
				::CopyMemory(	(LPVOID) m_pOCNA->lpstrCard,
								(CONST LPVOID)szName,
								m_strCard.Length()+1);
			}
			else
			{
				m_pOCNA->nMaxCard = m_strCard.Length()+1;
				throw (LONG)SCARD_E_NO_MEMORY;
			}
		}
		else
		{
			// Error!  One of them must be valid!
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("ConnectToReader"), lErr);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("ConnectToReader"));
	}

	return lReturn;
}


/*++

LONG Search:

    This routine is called to search for a card when the calling application
	requests SC_DLG_NO_UI or SC_DLG_MINIMAL_UI.
		
Arguments:

	pcMatches - pointer to a counter containing the number of matches found for
	the given searched for card.

	pdwIndex - index of the first card found that matches the search criteria.

Return Value:
	
    A LONG value indicating the status of the requested action.
	See the Smartcard header files for additional information.

Author:

    Chris Dudley (cdudley) 4/15/97

--*/
LONG CSCardEnv::Search(int *pcMatches, DWORD *pdwIndex)
{
	// Locals
	LONG	lReturn = SCARD_S_SUCCESS;
	LONG	lMoreReaders = SCARD_S_SUCCESS;
	int		cMatches = 0;
	DWORD	dwIndex = 0;
	BOOL	fIndexStored = FALSE;
	SCARD_READERINFO	ReaderInfo;

	try
	{
		// Check params
		if(pcMatches == NULL || pdwIndex == NULL)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}

		// Initialize reader array
		lReturn = UpdateReaders();
		if(SCARDFAILED(lReturn))
		{
			throw lReturn;
		}

		//
		// Walk through cards testing if this is a seached for card
		//

		lMoreReaders = FirstReader(&ReaderInfo);
		while (SCARD_NO_MORE_READERS != lMoreReaders)
		{
			// Check card search status
			if((ReaderInfo.fCardLookup) && (ReaderInfo.fChecked))
			{
				// We've found a card being searched for...Update
				cMatches++;

				// Save the index of this card
				if (!fIndexStored)
				{
					dwIndex = ReaderInfo.dwInternalIndex;
					fIndexStored = TRUE;
				}
			}
			
			// Must clean up CTextString members before calling again
			ReaderInfo.sReaderName.Clear();
			ReaderInfo.sCardName.Clear();

			// Get Next struct
			lMoreReaders = NextReader( &ReaderInfo );
		}

		// Package for return
		*pcMatches = cMatches;
		*pdwIndex = dwIndex;
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("Search"), lReturn);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("Search"));
	}

	return lReturn;
}


/*++

InitializeAllPossibleCardNames:

    Stores all known card names matching the ATRs of the cardnames provided by
	the OPENCARDNAME struct to search for.
*/
void CSCardEnv::InitializeAllPossibleCardNames( void )
{
	LPCSTR szCards = NULL;
	LONG lResult = SCARD_S_SUCCESS;
	CBuffer bfAtr, bfAtrMask, bfInterfaces, bfProvider;

	if (0 == MStringCount(m_strCardNames))
	{
		// No card names to check
		m_strAllPossibleCardNames = m_strCardNames;
		return;
	}

	szCards = m_strCardNames;

	szCards = FirstString(szCards);
	while (szCards != NULL)
	{
		//
		// get all possible names for this card's ATR
		//

		if (! GetCardInfo(
					SCARD_SCOPE_USER,
					szCards,
					&bfAtr,
					&bfAtrMask,
					&bfInterfaces,
					&bfProvider ) )
		{
			// it's weird that this failed, but assume that the name is still OK
			m_strAllPossibleCardNames += szCards;
		}
		else
		{
			LPTSTR szListCards = NULL;
			DWORD dwCards = SCARD_AUTOALLOCATE;

			lResult = SCardListCards(
						m_hContext,
						bfAtr,
						NULL,
						0,
						(LPTSTR)&szListCards,
						&dwCards);

			if (SCARD_S_SUCCESS == lResult)
			{
				// append them to the list of all possible card names
				m_strAllPossibleCardNames += szListCards;
			}
			else
			{
				// it's weird that this failed, but assume that the name is still OK
				m_strAllPossibleCardNames += szCards;
			}

			if (NULL != szListCards)
			{
				SCardFreeMemory(m_hContext, (PVOID)szListCards);
			}
		}

		szCards = NextString(szCards);
	}

}


/*++

LONG SetOCN:

    Stores the user OpenCardName info in the encapsulated data for UNICODE and
	ANSI.
		
Arguments:

	LPOPENCARDNAMEA - pointer to ANSI Open card name data.
	LPOPENCARDNAMEW - pointer to UNICODE Open card name data.

Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/3/1997

Revisions:

	Amanda Matlosz	1/28/98	code cleanup, use charset-generic m_OCN,
							move EnableUI code to separate function

--*/
LONG CSCardEnv::SetOCN(LPOPENCARDNAMEA	pOCNA)
{
	// Locals
	LONG		lReturn = SCARD_S_SUCCESS;
	int			cMatches = 0;
	DWORD		dwIndex = 0;

	try
	{
		// Check params
		if(NULL == pOCNA)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		if( pOCNA->dwStructSize != sizeof (OPENCARDNAMEA) )
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}

		// TODO: ?? remove this test when Interfaces search is implemented ??
		if( (pOCNA->rgguidInterfaces != NULL) || (pOCNA->cguidInterfaces != 0) )
		{
			throw (LONG)SCARD_E_INVALID_VALUE;	// NYI
		}

		//
		// Set UNICODE-specific members to NULL!
		//

		m_pOCNW = NULL;
		m_lpfnConnectW = NULL;

		//
		// Set appropriate charset-correct member, and copy to charset-generic
		//

		m_pOCNA = pOCNA;

		m_hwndOwner = m_pOCNA->hwndOwner;
		m_hContext = m_pOCNA->hSCardContext;
		m_strCardNames = m_pOCNA->lpstrCardNames;
		m_rgguidInterfaces = m_pOCNA->rgguidInterfaces;
		m_cguidInterfaces = m_pOCNA->cguidInterfaces;
		m_strReader = m_pOCNA->lpstrRdr;
		m_strCard = m_pOCNA->lpstrCard;
		m_strTitle = m_pOCNA->lpstrTitle;
		m_dwFlags = m_pOCNA->dwFlags;
		m_pvUserData = m_pOCNA->pvUserData;
		m_dwShareMode = m_pOCNA->dwShareMode;
		m_dwPreferredProtocols = m_pOCNA->dwPreferredProtocols;
		m_dwActiveProtocol = m_pOCNA->dwActiveProtocol;
		m_lpfnConnectA = m_pOCNA->lpfnConnect;
		m_lpfnCheck = m_pOCNA->lpfnCheck;
		m_lpfnDisconnect = m_pOCNA->lpfnDisconnect;
		m_lpUserData = m_pOCNA->pvUserData;
		m_hCardHandle = m_pOCNA->hCardHandle;

		// special case: lpstrGroupNames==NULL -> use default
		if (NULL != m_pOCNA->lpstrGroupNames)
		{
			m_strGroupNames = m_pOCNA->lpstrGroupNames;
		}
		else
		{
			m_strGroupNames = "SCard$DefaultReaders";
		}

		InitializeAllPossibleCardNames();
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("SetOCN - ANSI"),lReturn);
	}
	catch(...)
	{
		lReturn = (LONG)SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("SetOCN - ANSI"));
	}


	// Release memory if required
	RemoveReaders();

	return lReturn;
}


// UNICODE
LONG CSCardEnv::SetOCN(LPOPENCARDNAMEW	pOCNW)
{
	LONG lReturn = SCARD_S_SUCCESS;

	try
	{
		// Check params
		if (NULL == pOCNW)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		if (pOCNW->dwStructSize != sizeof(OPENCARDNAMEW) )
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		if ((pOCNW->rgguidInterfaces != NULL) || (pOCNW->cguidInterfaces != 0))
		{
			throw (LONG)SCARD_E_INVALID_VALUE; // NYI
		}

		//
		// Set ANSI-specific members to NULL!
		//

		m_pOCNA = NULL;
		m_lpfnConnectA = NULL;

		//
		// Set appropriate charset-correct member, and copy to charset-generic
		//

		m_pOCNW = pOCNW;

		m_hwndOwner = m_pOCNW->hwndOwner;
		m_hContext = m_pOCNW->hSCardContext;
		m_strCardNames = m_pOCNW->lpstrCardNames;
		m_rgguidInterfaces = m_pOCNW->rgguidInterfaces;
		m_cguidInterfaces = m_pOCNW->cguidInterfaces;
		m_strReader = m_pOCNW->lpstrRdr;
		m_strCard = m_pOCNW->lpstrCard;
		m_strTitle = m_pOCNW->lpstrTitle;
		m_dwFlags = m_pOCNW->dwFlags;
		m_pvUserData = m_pOCNW->pvUserData;
		m_dwShareMode = m_pOCNW->dwShareMode;
		m_dwPreferredProtocols = m_pOCNW->dwPreferredProtocols;
		m_dwActiveProtocol = m_pOCNW->dwActiveProtocol;
		m_lpfnConnectW = m_pOCNW->lpfnConnect;
		m_lpfnCheck = m_pOCNW->lpfnCheck;
		m_lpfnDisconnect = m_pOCNW->lpfnDisconnect;
		m_lpUserData = m_pOCNW->pvUserData;
		m_hCardHandle = m_pOCNW->hCardHandle;

		// special case: lpstrGroupNames=="" -> use default
		if (NULL != m_pOCNW->lpstrGroupNames && 0 != *(m_pOCNW->lpstrGroupNames))
		{
			m_strGroupNames = m_pOCNW->lpstrGroupNames;
		}
		else
		{
			m_strGroupNames = L"SCard$DefaultReaders";
		}

		InitializeAllPossibleCardNames();
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("SetOCN - UNICODE"),lReturn);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("SetOCN - UNICODE"));
	}

	return lReturn;
}


/*++

LONG NoUISearch:

    If the user has not set SC_DLG_FORCE_UI, perform a search for all
	possible cards.  If only one card is the result, then the search has
	succeeded and no UI is necessary.

		
Arguments:

	BOOL* pfEnableUI.
		
Return Value:
	
    A LONG indicating the success of the search.  If SC_DLG_FORCE_UI is set,
	pfEnableUI is always TRUE; if SC_DLG_NO_UI is set, the pfEnableUI is always
	FALSE.

Author:

    Amanda Matlosz	02/01/1998	

Revisions:

--*/
LONG CSCardEnv::NoUISearch(BOOL* pfEnableUI)
{
	//
	// Must search so we can check all the cards, even if we have to show UI
	//

	*pfEnableUI = FALSE;
	long lResult = SCARD_S_SUCCESS;
	int cMatches = 0;
	DWORD dwIndex = 0;

	try
	{
		// Search for the card
		lResult = Search(&cMatches, &dwIndex);
		if(SCARDFAILED(lResult))
		{
			throw lResult;
		}

		// Determine if UI should be used...

		if(m_dwFlags & SC_DLG_FORCE_UI)
		{
			*pfEnableUI = TRUE;
		}
		else if((m_dwFlags & SC_DLG_MINIMAL_UI) && (cMatches != 1))
		{
			*pfEnableUI = TRUE;
		}

		// Connect to the reader if 1 matching card found

		if(cMatches == 1)
		{
			lResult = ConnectToReader(dwIndex);
			if (SCARDFAILED(lResult))
			{
				*pfEnableUI = TRUE; // an error occurred with the reader?  eep.
				throw lResult;
			}
		}
	}
	catch(LONG lErr)
	{
		TRACE_CATCH(_T("NoUISearch"),lErr);
	}
	catch(...)
	{
		TRACE_CATCH_UNKNOWN(_T("NoUISearch"));
		lResult = SCARD_F_UNKNOWN_ERROR;
	}

	// Release memory if required
	RemoveReaders();

	return lResult;
}


/*++

LONG BuildReaderArray:

    Builds an array of CSCardReader objects. 1 object per reader.
		
Arguments:

	szReaderNames - an LPTSTR (A/W) multistring containing a list of readers.
		
Return Value:
	
    A LONG value indicating the status of the requested action.
	See the Smartcard header files for additional information.

Author:

    Chris Dudley 3/5/1997

Revisions:

	Amanda Matlosz 1/29/98	added unicode support
--*/
LONG CSCardEnv::BuildReaderArray( LPTSTR szReaderNames )
{
	LONG		lReturn = SCARD_S_SUCCESS;
	LPCTSTR		szReaderName = szReaderNames;
	CSCardReaderState* pReaderState = NULL;

	try
	{
		// Check Params
		if (NULL == szReaderNames || NULL == *szReaderNames)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		
		//
		// Store a reader object in the array for each reader
		//

		szReaderName = FirstString( szReaderName );
		while (NULL != szReaderName)
		{
			pReaderState = new CSCardReaderState;
			if (NULL == pReaderState)
			{
				throw (LONG)SCARD_E_NO_MEMORY;
			}

			pReaderState->SetContext(m_hContext);
			pReaderState->StoreName(szReaderName);

			if (NULL != m_pOCNA)
			{
				lReturn = pReaderState->SetReaderState(	m_lpfnConnectA,
														m_lpfnCheck,
														m_lpfnDisconnect,
														m_lpUserData);
			}
			else if (NULL != m_pOCNW)
			{
				lReturn = pReaderState->SetReaderState(	m_lpfnConnectW,
														m_lpfnCheck,
														m_lpfnDisconnect,
														m_lpUserData);

			}
			else
			{
				// Either m_pOCNA or m_pOCNW *must* be valid!
				throw (long)SCARD_F_INTERNAL_ERROR;
			}

			if (SCARDFAILED(lReturn))
			{
				throw (lReturn);
			}

			// Check if card inserted and set flag if it contains the search card
			if (pReaderState->IsCardInserted())
			{
				// TODO: ?? fix readerstate so it's nicer w/ W ??
				lReturn = pReaderState->CheckCard(m_strAllPossibleCardNames);
				if (SCARDFAILED(lReturn))
				{
					throw (lReturn);
				}
			}

			m_rgReaders.Add(pReaderState);
			szReaderName = NextString(szReaderName);
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("BuildReaderArray"), lReturn);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("BuildReaderArray"));
	}

	return lReturn;
}


/*++

LONG ConnectInternal:

    Connect internally to the reader

Arguments:

	dwSelectedIndex - index used to select which reader to connect to.
	pHandle - pointer to an SCARDHANDLE that will be set on  return.
	dwShareMode - contains share mode to use when connecting
	dwProtocols - contains requested protocol(s) to use when connecting
	pdwActiveProtocl - returns active protocol on successful connection
	szReaderName - returned name of the reader being connected

Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revisions:

	Amanda Matlosz 1/30/98	code cleanup
--*/
LONG CSCardEnv::ConnectInternal(	DWORD dwSelectedReader,
									SCARDHANDLE *pHandle,
									DWORD dwShareMode,
									DWORD dwProtocols,
									DWORD *pdwActiveProtocol,
									CTextString *pszReaderName,//=NULL
									CTextString *pszCardName//=NULL
									)
{
	LONG lReturn = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;

	try
	{
		// Check Params
		if (NULL == pHandle)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		if (NULL == pdwActiveProtocol)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		if (dwSelectedReader >= (DWORD)NumberOfReaders())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}

		if (!IsContextValid())
		{
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}
		
		// Clear handle
		*pHandle = NULL;

		// get the object & connect
		pReaderState = m_rgReaders[dwSelectedReader];
		lReturn = pReaderState->Connect(pHandle,
										dwShareMode,
										dwProtocols,
										pdwActiveProtocol,
										pszReaderName,
										pszCardName);
		if (SCARDFAILED(lReturn))
		{
			throw lReturn;
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("ConnectInternal"), lReturn);
	}
	catch(...)
	{
		lReturn = SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("ConnectInternal"));
	}

	return lReturn;
}


/*++

LONG ConnectUser:

    Connect to the reader using user supplied callback

Arguments:

	dwSelectedReader - index to reader to connect
	lpfnConnect - user supplied callback function.
	pHandle - pointer to an SCARDHANDLE that will be set on  return.
	lpUserData - pointer to user data.

Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/11/1997

Revisions:

	Amanda Matlosz 1//30/98	code cleanup

--*/
LONG CSCardEnv::ConnectUser(	DWORD dwSelectedReader,
								SCARDHANDLE *pHandle,
								CTextString *pszReaderName, //=NULL
								CTextString *pszCardName //=NULL
								)
{
	LONG lReturn = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;

	try
	{
		// Check Params
		if(NULL == pHandle)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		if(dwSelectedReader >= (DWORD)NumberOfReaders())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}

		if (!IsContextValid())
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}
		
		// Clear handle
		*pHandle = NULL;

		// get the reader object & connect
		pReaderState = m_rgReaders[dwSelectedReader];
		lReturn = pReaderState->UserConnect(pHandle,
											pszReaderName,
											pszCardName);
		if (SCARDFAILED(lReturn))
		{
			throw (lReturn);
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("ConnectUser"), lReturn);
	}
	catch(...)
	{
		lReturn = SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("ConnectUser"));
	}

	return lReturn;
}


/*++

void GetCardList:
	
	Returns a multistring containing the list cards being searched for.
		
Arguments:

	LPCTSTR* - pointer->pointer for the list
		
Return Value:
	
	none

Author:

    Chris Dudley 3/7/1997

Notes:
	
--*/
void CSCardEnv::GetCardList( LPCTSTR* pszCardList )
{
	// Check params
	if (NULL != pszCardList)
	{
		*pszCardList = m_strCardNames;
	}
}


/*++

BOOL IsCallbackValid:

    This routine checks the user callback functions.
		
Arguments:

	None
		
Return Value:
	
	TRUE if calbacks are valid. FALSE otherwise.

Author:

    Chris Dudley 3/15/1997

--*/
BOOL CSCardEnv::IsCallbackValid ( void )
{
	BOOL fValid = FALSE;

	fValid = ((NULL != m_lpfnConnectA || NULL != m_lpfnConnectW) &&
				(m_lpfnCheck != NULL) && (m_lpfnDisconnect != NULL));

	return fValid;
}


/*++

LONG CreateReaderStateArray:
	
	Returns an array of SCARD_READERSTATE structs.
		
Arguments:

	LPSCARD_READERSTATE* - pointer->pointer to an SCARDREADERSTATE struct
		
Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revisions:

	Amanda Matlosz 1/30/98	added unicode support, code cleanup

--*/
LONG CSCardEnv::CreateReaderStateArray(	LPSCARD_READERSTATE* prgReaderStates )
{
	// Locals
	LONG	lReturn = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;
	LPSCARD_READERSTATE	rgReader;

	try
	{
		// Check params, etc.
		if (prgReaderStates == NULL)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;
		}

		if (!IsArrayValid())
		{
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

		// Clean up the destination
		DeleteReaderStateArray(prgReaderStates);

		// Build a temp array, set the destination array
		rgReader = new SCARD_READERSTATE[(size_t)m_rgReaders.GetSize()];
		if (rgReader == NULL)
		{
			throw (LONG)SCARD_E_NO_MEMORY;
		}
		
		for (int ix =0; ix < m_rgReaders.GetSize(); ix++)
		{
			pReaderState = m_rgReaders[ix];
			pReaderState->GetReaderState(&(rgReader[ix]));	// TODO: ?? looks funny ??
		}

		// Asign the pointer
		*prgReaderStates = rgReader;
	}

	catch (LONG err) {
		lReturn = err;
		TRACE_CATCH(_T("GetReaderStateArray"),err);
	}

	catch (...) {
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("GetReaderStateArray"));
	}

	return lReturn;
}


/*++

void DeleteReaderStateArray:

    Frees the memory associated with a previously created SCARD_READERSTATE
	array.
		
Arguments:

	rgReaderStateArray - pointer to the array.
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/7/1997

--*/
void CSCardEnv::DeleteReaderStateArray(LPSCARD_READERSTATE* prgReaderStateArray)
{
	if (NULL != *prgReaderStateArray)
	{
		delete [] (*prgReaderStateArray);
		*prgReaderStateArray = NULL;
	}
}


/*++

LONG FirstReader:

    Retrieves information on the first reader in the reader array.
		
Arguments:

	None
		
Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

	A return value of SCARD_NO_MORE_READERS means no readers available.

Author:

    Chris Dudley 3/7/1997

Notes:

	1. This routine 0's the memory pointed to by pReaderInfo. The calling app should be
	careful (i.e. clean up LSCARD_READERINFO struct) before each call to this routine.

--*/
LONG CSCardEnv::FirstReader(LPSCARD_READERINFO pReaderInfo)
{
	// Locals
	LONG	lResult = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;

	try
	{
		if (NULL == pReaderInfo)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;	
		}

		// Give up if there are no readers
		if (m_rgReaders.GetSize() <= 0)
		{
			throw (LONG)SCARD_NO_MORE_READERS;
		}

		// Get the first reader
		m_dwReaderIndex = 0;
		pReaderState = m_rgReaders[m_dwReaderIndex];
		if (!pReaderState->IsStateValid())
		{
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

		// Prepare the return struct
		::ZeroMemory( (LPVOID)pReaderInfo, (DWORD)sizeof(SCARD_READERINFO));
		lResult = pReaderState->GetReaderInfo(pReaderInfo);
		if (SCARDFAILED(lResult))
		{
			throw (lResult);
		}
		// Update the index
		pReaderInfo->dwInternalIndex = m_dwReaderIndex;
	}
	catch(LONG lErr)
	{
		lResult = lErr;
		TRACE_CATCH(_T("FirstReader"), lResult);
	}
	catch(...)
	{
		lResult = SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("FirstReader"));
	}

	return lResult;
}


/*++

LONG NextReader:

    Retrieves information on the next reader (using internal index) in the
	reader array.
		
Arguments:

	None
		
Return Value:
	
    A LONG value indicating the status of the requested action.
	See the Smartcard header files for additional information.

	A return value of SCARD_NO_MORE_READERS means no readers available.

Author:

    Chris Dudley 3/7/1997

Notes:

	1. This routine 0's the memory pointed to by pReaderInfo. The calling app should be
	careful (i.e. clean up LSCARD_READERINFO struct) before each call to this routine.

--*/
LONG CSCardEnv::NextReader(LPSCARD_READERINFO pReaderInfo)
{
	LONG	lResult = SCARD_S_SUCCESS;
	CSCardReaderState* pReaderState = NULL;
	DWORD dwTotalReaders = (DWORD)m_rgReaders.GetUpperBound();

	try
	{
		// Check params
		if (NULL == pReaderInfo)
		{
			throw (LONG)SCARD_E_INVALID_PARAMETER;	
		}

		// Is there a next reader to retrieve?
		m_dwReaderIndex++;
		if (m_dwReaderIndex > dwTotalReaders)
		{
			throw (LONG)SCARD_NO_MORE_READERS;
		}

		// Fetch the reader state from our array
		pReaderState = m_rgReaders[m_dwReaderIndex];
		if (!pReaderState->IsStateValid())
		{
			throw (LONG)SCARD_F_INTERNAL_ERROR;
		}

		// Setup the struct to return

		::ZeroMemory((LPVOID)pReaderInfo, (DWORD)sizeof(SCARD_READERINFO));
		lResult = pReaderState->GetReaderInfo(pReaderInfo);
		if (SCARDFAILED(lResult))
		{
			throw (lResult);
		}

		// Update the index
		pReaderInfo->dwInternalIndex = m_dwReaderIndex;
	}
	catch(LONG lErr)
	{
		lResult = lErr;
		TRACE_CATCH(_T("NextReader"), lResult);
	}
	catch(...)
	{
		lResult = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("NextReader"));
	}

	return lResult;
}


/*++

void RemoveReaderArray:

    Deletes the array of CSCardReader objects.
		
Arguments:

	None
		
Return Value:

	None

Author:

    Chris Dudley 3/5/1997

Revisions:

	Amanda Matlosz 1/29/98	code cleanup

--*/
void CSCardEnv::RemoveReaders( void )
{
	if (IsArrayValid())
	{
		// Delete the attached reader objects
		for (int ix=0; ix <= m_rgReaders.GetUpperBound(); ix++)
		{
			delete m_rgReaders[ix];
		}

		// Free array memory
		m_rgReaders.RemoveAll();
	}
}


/*++

void SetContext:

    Sets the card context, performs no checking.
		
Arguments:

	hContext - card context handle
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/3/1997

--*/
void CSCardEnv::SetContext(SCARDCONTEXT hContext)
{
	m_hContext = hContext;
}


/*++

LONG UpdateReaders:

    Updates the reader array using m_GroupName member.
		
Arguments:

	None.
		
Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/3/1997

Revisions:

	Amanda Matlosz 1/29/98	added Unicode support

Note:
	
--*/
LONG CSCardEnv::UpdateReaders( void )
{
	TRACE("\tCSCardEnv::UpdateReaders\r\n");	// TODO: ?? remove this ??

	LONG		lReturn = SCARD_S_SUCCESS;
	LPTSTR		szReaderNames = NULL;
	DWORD		dwNameLength = SCARD_AUTOALLOCATE;

	if (!IsContextValid())
	{
		TRACE_CODE(_T("UpdateReaders"),E_FAIL);
		return (LONG)E_FAIL;
	}

	RemoveReaders();	// deletes current array if required

	try
	{
		// Call Resource manager for list of readers
		lReturn = SCardListReaders(m_hContext,
									m_strGroupNames,
									(LPTSTR)&szReaderNames,
									&dwNameLength);

		if(SCARDFAILED(lReturn))
		{
			throw (lReturn);
		}

		// SCardListReaders will succeed in a PnP world even if there are currently no
		// readers for this group.
		_ASSERTE(NULL != szReaderNames && NULL != *szReaderNames);

		lReturn = BuildReaderArray(szReaderNames);
		if (SCARDFAILED(lReturn))
		{
			throw (lReturn);
		}
	}
	catch(LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("UpdateReaders"),lReturn);
	}
	catch(...)
	{
		lReturn = (LONG) SCARD_F_UNKNOWN_ERROR;
		TRACE_CATCH_UNKNOWN(_T("UpdateReaders"));
	}

	// Clean Up
	if(NULL != szReaderNames)
	{
		SCardFreeMemory(m_hContext, (LPVOID)szReaderNames);
	}

	return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\cmnstat.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    comstat

Abstract:

	This file contains the definition of the common types, etc. used in
	the status application
	
Author:

    Chris Dudley 7/28/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

--*/

#ifndef __COMSTAT_H__
#define __COMSTAT_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//


////////////////////////////////////////////////////////////////////////////
//
// Constants
// 

// system state
static const DWORD k_State_Unknown = 0;
static const DWORD k_State_NoCard = 1;
static const DWORD k_State_CardAvailable = 2;
static const DWORD k_State_CardIdle = 3;

// alert options
static const UINT_PTR k_AlertOption_IconOnly = 0;
static const UINT_PTR k_AlertOption_IconSound = 1;
static const UINT_PTR k_AlertOption_IconSoundMsg = 2;
static const UINT_PTR k_AlertOption_IconMsg = 3;

// RegKeys
static const LPCTSTR szAlertOptionsKey = TEXT("Software\\Microsoft\\Cryptography\\Calais\\Smart Card Alert");
static const LPCTSTR szScRemoveOptionKey = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");

// messages

static const UINT WM_SCARD_NOTIFY = WM_USER + 1;
static const UINT WM_SCARD_STATUS_DLG_EXITED = WM_USER + 2;
static const UINT WM_SCARD_CERTPROP_EXITED = WM_USER + 3;
static const UINT WM_READERSTATUSCHANGE = WM_USER + 4;
static const UINT WM_SCARD_RESMGR_EXIT = WM_USER + 5;
static const UINT WM_SCARD_RESMGR_STATUS = WM_USER + 6;
static const UINT WM_SCARD_NEWREADER = WM_USER + 7;
static const UINT WM_SCARD_NEWREADER_EXIT = WM_USER + 8;
static const UINT WM_SCARD_CARDSTATUS = WM_USER + 9;
static const UINT WM_SCARD_CARDSTATUS_EXIT = WM_USER + 10;
static const UINT WM_SCARD_REMOPT_CHNG = WM_USER + 11;
static const UINT WM_SCARD_REMOPT_EXIT = WM_USER + 12;
////////////////////////////////////////////////////////////////////////////

#endif // __COMSTAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\inc\rdrstate.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

	RdrState

Abstract:

	This file contains the definition of the Smartcard Common 
	dialog CSCardReaderState class. This class encapsulates Smartcard 
	Reader information.
	
Author:

    Chris Dudley 3/3/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:
	
	Chris Dudley 5/13/1997
	Amanda Matlosz 1/30/98 unicode support, code cleanup

Notes:

--*/

#ifndef __RDRSTATE_H__
#define __RDRSTATE_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "cmnui.h"

/////////////////////////////////////////////////////////////////////////////
//
// CSCardReaderState Class - encapsulates reader state 
//
class CSCardReaderState
{
	// members
private:
	SCARDCONTEXT	m_hContext;			// Context handle w/Calais
	SCARDHANDLE		m_hCard;			// Handle to smartcard in Reader
	CTextString		m_sReaderName;		// Reader name
	CTextString		m_sCardName;		// Card name actually inserted into Reader
	BOOL			m_fCardInReader;	// Flag for card currently in reader
	BOOL			m_fCardLookup;		// Indicates card is being looked for.
	BOOL			m_fConnected;		// Flag connected to card in reader
	BOOL			m_fChecked;			// Flag that this card has been user verified
	SCARD_READERSTATE m_ReaderState;	// Handle to ANSI reader status
	LPOCNCONNPROCA	m_lpfnConnectA;		// User call back functions
	LPOCNCONNPROCW	m_lpfnConnectW;		// User call back functions
	LPOCNCHKPROC	m_lpfnCheck;
	LPOCNDSCPROC	m_lpfnDisconnect;
	LPVOID			m_lpUserData;

	// RFU AS INDICATED!!!
	BOOL			m_fUpdated;			// RFU!!! Flag for change in name, group, etc.
	CTextMultistring	m_sGroupName;	// RFU!!! Groups this reader belongs to.

public:

	// Construction/Destruction
public:
	CSCardReaderState()
	{
		::ZeroMemory(	(LPVOID)&m_ReaderState, 
						(DWORD)sizeof(SCARD_READERSTATE) );

		m_hContext = NULL;
		m_hCard = NULL;
		m_fCardInReader = FALSE;
		m_fCardLookup = FALSE;
		m_fChecked = FALSE;
		m_fConnected = FALSE;
		m_fUpdated = FALSE;
		m_lpfnConnectA = NULL;		// User call back functions
		m_lpfnConnectW = NULL;
		m_lpfnCheck = NULL;
		m_lpfnDisconnect = NULL;
		m_lpUserData = NULL;
	}
				
	~CSCardReaderState()
	{	
		m_sReaderName.Clear();
		m_sCardName.Clear();
	}

	// Implementation
private:

public:
	// initialization
	void SetContext(SCARDCONTEXT hContext);
	void StoreName(LPCTSTR szReaderName);
	LONG SetReaderState(LPOCNCONNPROCA lpfnConnectA = NULL,
						LPOCNCHKPROC lpfnCheck = NULL,
						LPOCNDSCPROC lpfnDisconnect = NULL,
						LPVOID lpUserData = NULL);
	LONG SetReaderState(LPOCNCONNPROCW lpfnConnectW = NULL,
						LPOCNCHKPROC lpfnCheck = NULL,
						LPOCNDSCPROC lpfnDisconnect = NULL,
						LPVOID lpUserData = NULL);

	// attributes
	LONG GetReaderInfo(LPSCARD_READERINFO pReaderInfo);
	LONG GetReaderState(LPSCARD_READERSTATE pReaderState);
	BOOL IsCallbackValid(void);
	BOOL IsCardConnected() { return (m_fConnected); }
	BOOL IsCardInserted(void);
	BOOL IsContextValid() { return (NULL != m_hContext); }
	BOOL IsStateValid(void);

	// methods
	LONG CheckCard(LPCTSTR szCardName);
	LONG Connect(	SCARDHANDLE *pHandle, 
					DWORD dwShareMode, 
					DWORD dwProtocols,
					DWORD* pdwActiveProtocols,
					CTextString* pszReaderName = NULL,
					CTextString* pszCardName = NULL);
	LONG UserCheck(void);
	LONG UserConnect(	LPSCARDHANDLE pCard,
						CTextString* pszReaderName = NULL,
						CTextString* pszCardName = NULL);
	LONG UserDisconnect(void);
	LONG GetReaderCardInfo(	CTextString* pszReaderName = NULL,
							CTextString* pszCardName = NULL);

};

/////////////////////////////////////////////////////////////////////////////

#endif // __RDRSTATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\inc\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

SCSTFILES=scstmsg.h scstmsg.rc msg00001.bin

SCSTMSG: $(SCSTFILES)

res\scstatus.rc2: $(SCSTFILES)

$(SCSTFILES): scstmsg.mc
    mc scstmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\miscdef.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MiscDef.h

Abstract:

	This file contains miscellanious definitions, including the debug trace macros
	written by Chris Dudley
	
Author:

    Amanda Matlosz 12/15/97

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

  intended only for use in the scstatus project

--*/

#ifndef __MISC_H__
#define __MISC_H__

#ifdef _DEBUG
	#define TRACE_STR(name,sz) \
				TRACE(_T("SCStatus.EXE: %s: %s\n"), name, sz)
	#define TRACE_CODE(name,code) \
				TRACE(_T("SCStatus.EXE: %s: error = 0x%x\n"), name, code)
	#define TRACE_CATCH(name,code)		TRACE_CODE(name,code)
	#define TRACE_CATCH_UNKNOWN(name)	TRACE_STR(name,_T("An unidentified exception has occurred!"))
#else
	#define TRACE_STR(name,sz)			((void)0)
	#define TRACE_CODE(name,code)		((void)0)
	#define TRACE_CATCH(name,code)		((void)0)
	#define TRACE_CATCH_UNKNOWN(name)	((void)0)
#endif  // _DEBUG


#endif  // __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\resmgrst.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ResMgrSt

Abstract:

    This file contains definititions of threads
	used by scstatus.exe to monitor the status of
	the Smart Card Resource Manager and report changes.
    
Author:

    Amanda Matlosz	10/28/98

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:


Notes:

--*/

#if !defined(_RES_MGR_STATUS)
#define _RES_MGR_STATUS

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include "cmnstat.h"


///////////////////////////////////////////////////////////////////////////
//
// CResMgrStatusThrd - is Calais running or stopped?
//

class CResMgrStatusThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CResMgrStatusThrd)

public:
	// Construction / Destruction
	CResMgrStatusThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_hKillThrd = NULL;
	}

	~CResMgrStatusThrd() {}

	// Implementation
public:
	virtual BOOL InitInstance();

	// Member vars
public:
	HWND m_hCallbackWnd;
	HANDLE m_hKillThrd;

};

///////////////////////////////////////////////////////////////////////////
//
// CNewReaderThrd - has a new reader been made available to Calais?
//

class CNewReaderThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CNewReaderThrd)

public:
	// Construction / Destruction
	CNewReaderThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_hKillThrd = NULL;
	}

	~CNewReaderThrd() {}

	// Implementation
public:
	virtual BOOL InitInstance();

	// Member vars
public:
	HWND m_hCallbackWnd;
	HANDLE m_hKillThrd;
};

///////////////////////////////////////////////////////////////////////////
//
// CRemovalOptionsThrd - has user changed removal options? (via lock/unlock)
//

class CRemovalOptionsThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CRemovalOptionsThrd)

public:
	// Construction / Destruction
	CRemovalOptionsThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_hKillThrd = NULL;
	}

	~CRemovalOptionsThrd() {}

	// Implementation
public:
	virtual BOOL InitInstance();

	// Member vars
public:
	HWND m_hCallbackWnd;
	HANDLE m_hKillThrd;

};

///////////////////////////////////////////////////////////////////////////
//
// CCardStatusThrd - has a card been idle for X seconds?
//

class CCardStatusThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CCardStatusThrd)

public:
	// Construction / Destruction
	CCardStatusThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_hKillThrd = NULL;
		m_paIdleList = NULL;

		m_hCtx = NULL;

		m_pstrLogonReader = NULL;
	}

	~CCardStatusThrd() { }

	// Implementation
public:
	virtual BOOL InitInstance();
	void CopyIdleList(CStringArray* paStr);

	void Close()
	{
		if (m_hCtx != NULL)
		{
			SCardCancel(m_hCtx);
		}

		// supress messages
		m_hCallbackWnd = NULL;
	}


	// Member vars
public:
	HWND m_hCallbackWnd;
	HANDLE m_hKillThrd;
	SCARDCONTEXT m_hCtx;
	CStringArray* m_paIdleList;
	CCriticalSection m_csLock;
	CString* m_pstrLogonReader;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _RES_MGR_STATUS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scalert.rc
//
#define IDS_SC_UNKNOWN_NO               1
#define IDS_SC_KNOWN_INCORRECT          2
#define IDS_SC_DEAD                     3
#define IDFINISH_NEXT                   3
#define IDS_SC_BUSY                     4
#define IDBACK                          4
#define IDS_SC_STATUS_NO_CARD           5
#define IDS_SC_STATUS_NOT_IN_USE        6
#define IDS_SC_STATUS_ERROR             7
#define IDS_SC_STATUS_IN_USE            8
#define IDS_SC_NAME_UNKNOWN             9
#define IDS_SC_CONNECT_FAILED           10
#define IDS_SC_STATUS_AVAILABLE         10
#define IDS_SC_SELECT                   11
#define IDS_SC_STATUS_UNKNOWN           11
#define IDS_SC_TITLE_ERROR              12
#define IDS_SC_STATUS_SHARED            12
#define IDS_SC_FOUND                    13
#define IDS_SC_REMOVAL_LOCK             13
#define IDS_SC_FOUND_BUSY               14
#define IDS_SC_REMOVAL_LOGOFF           14
#define IDD_SCSTATUS_DIALOG             102
#define IDS_PROPSHT_CAPTION             103
#define IDD_PROPPAGE1                   104
#define IDS_WELCOME_CAPTION             104
#define IDD_PROPPAGE2                   105
#define IDS_WELCOME_TEXT                105
#define IDD_PROPPAGE3                   106
#define IDD_PROPPAGE4                   107
#define IDS_PP2_Reader                  107
#define IDD_PROPPAGE5                   108
#define IDS_PP2_CardName                108
#define IDS_PP3_GenerateCert            109
#define IDS_PP3_UseKeys                 110
#define IDS_PP3_YesCert                 111
#define IDS_PP3_NoCert                  112
#define IDS_PP3_YesKeys                 113
#define IDS_PP3_NoKeys                  114
#define IDS_PP3_Header_Caption          117
#define IDS_PP3_Header_Text             118
#define IDS_PP2_Header_Caption          119
#define IDS_PP2_Header_Text             120
#define IDS_PP2_ERR_NoName              121
#define IDS_PP2_ERR_NonuniqueName       122
#define IDS_PP4_Header_Caption          123
#define IDS_PP4_Header_Text             124
#define IDS_PP2_CSP                     125
#define IDS_COMPLETE_CAPTION            126
#define IDS_COMPLETE_SUCCESS            127
#define IDR_MAINFRAME                   128
#define IDS_COMPLETE_FAIL               128
#define IDB_WELCOME                     129
#define IDS_PP2_CSP_Default             129
#define IDI_SCARD_UP                    130
#define IDB_HEADER                      130
#define IDS_COMPLETE_ERR_NoMessage      130
#define IDI_SCARD_DOWN                  131
#define IDS_CERTREQ_ERROR               131
#define IDI_SC_RIGHTARROW               132
#define IDS_CERTREQ_DENIED              132
#define IDR_STATUS_MENU                 133
#define IDI_SC_CHECKED                  133
#define IDS_CERTREQ_SEPARATE            133
#define IDI_SC_INSERT                   134
#define IDS_CERTREQ_UNDERSUBMISSION     134
#define IDI_SC_READEREMPTY              135
#define IDB_WIZARD                      135
#define IDS_CERTREQ_UNKNOWN             135
#define IDI_SC_READERLOADED             136
#define IDB_LINE                        136
#define IDS_CERT_UNKNOWN                136
#define IDI_SC_REMOVE                   137
#define IDS_CERT_TRY_AGAIN              137
#define IDD_NEW_CARD_DLG                138
#define IDS_ICTFT_ERR                   138
#define IDI_SC_READERLOADED_V2          138
#define IDI_SC_READEREMPTY_V2           139
#define IDS_ERR_CSP                     139
#define IDI_SC_READERERR                140
#define IDS_ERR_KEYSET                  140
#define IDS_CREATECERT_FAIL             141
#define IDI_SC_INFO                     141
#define IDS_ERR_CERTCTX                 142
#define IDD_OPTIONSDLG                  142
#define IDI_SC_CARD                     143
#define IDS_CERTPROP_OK                 143
#define IDI_SC_LOGONLOCK                143
#define IDS_CERTPROP_UNKNOWN            144
#define IDS_CREATECERT_SUCCESS          145
#define IDS_OPENSTORE_ERR               146
#define IDS_CERTTOSTORE_ERR             147
#define IDC_HEADER_TEXT                 1001
#define IDC_HEADER_CAPTION              1002
#define IDC_MAIN_GRAPHIC                1003
#define IDC_WELCOME_CAPTION             1004
#define IDC_WELCOME_TEXT                1005
#define IDC_SCARD_LIST                  1006
#define IDC_COMPLETE_TEXT               1006
#define IDC_HEADER_GRAPHIC              1007
#define IDC_USE_CERT                    1009
#define IDC_USE_KEYS                    1012
#define IDC_PROMPT_CSP                  1013
#define IDC_PROMPT_CARDTYPE             1013
#define IDC_CSP                         1014
#define IDC_CARDTYPE                    1014
#define IDC_CERTTYPE_PROMPT             1015
#define IDC_RADIO1                      1016
#define IDC_CARD_NAME                   1017
#define IDC_RADIO2                      1017
#define IDC_SCARD_NAME                  1018
#define IDC_LIST_CARDS                  1018
#define IDC_RADIO3                      1018
#define IDC_READER_NAME                 1019
#define IDC_RADIO4                      1019
#define IDC_READER_LIST                 1020
#define IDC_PROMPT_CARD_NAME            1020
#define IDC_CERTTYPE_DD                 1020
#define IDC_COMPLETE_CAPTION            1021
#define IDC_ALERT                       1025
#define IDC_DIALOG                      1026
#define IDC_SOUND                       1027
#define IDC_INFO                        1027
#define ID_STATUS                       32773
#define ID_CERTIFICATE                  32774
#define IDS_SYSTEM_DOWN                 32775
#define IDS_SYSTEM_UP                   32776
#define IDS_NOTIFY_WIN_NAME             32777
#define IDS_SC_READER                   32778
#define IDS_SC_CARDSTATUS               32779
#define IDS_SC_CARD                     32780
#define IDM_STATUS                      32781
#define IDS_NO_SYSTEM_STATUS            32781
#define IDM_CERTIFICATES                32782
#define IDS_UNKNOWN_ERROR               32782
#define IDM_CLOSE                       32783
#define IDS_TITLE_ERROR                 32783

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        145
#define _APS_NEXT_COMMAND_VALUE         32784
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\notfywin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       notfywin.cpp
//
//--------------------------------------------------------------------------

// NotfyWin.cpp : implementation file
//

#include "stdafx.h"
#include <winsvc.h> // PnP awareness
#include <dbt.h>    //      " "
#include <mmsystem.h>
#include <scEvents.h>

#include "notfywin.h"
#include "SCAlert.h"
#include "miscdef.h"
#include "cmnstat.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CNotifyWin Window
//


BEGIN_MESSAGE_MAP(CNotifyWin, CWnd)
	//{{AFX_MSG_MAP(CNotifyWin)
	ON_MESSAGE( WM_DEVICECHANGE, OnDeviceChange )
	ON_MESSAGE( WM_SCARD_NOTIFY, OnSCardNotify )
	ON_MESSAGE( WM_SCARD_STATUS_DLG_EXITED, OnSCardStatusDlgExit )
	ON_MESSAGE( WM_SCARD_RESMGR_EXIT, OnResMgrExit )
	ON_MESSAGE( WM_SCARD_RESMGR_STATUS, OnResMgrStatus )
	ON_MESSAGE( WM_SCARD_NEWREADER, OnNewReader )
	ON_MESSAGE( WM_SCARD_NEWREADER_EXIT, OnNewReaderExit )
	ON_MESSAGE( WM_SCARD_CARDSTATUS, OnCardStatus )
	ON_MESSAGE( WM_SCARD_CARDSTATUS_EXIT, OnCardStatusExit )
	ON_MESSAGE( WM_SCARD_REMOPT_CHNG, OnRemovalOptionsChange )
	ON_MESSAGE( WM_SCARD_REMOPT_EXIT, OnRemovalOptionsExit )
	ON_COMMAND( IDM_CLOSE, OnContextClose )
	ON_COMMAND( IDM_STATUS, OnContextStatus)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


////////////////////////////////////////////////////////////////////////////////////
//
// CNotifyWin Class
//


/*++

FinalConstruct:

    This method implements the constructor for this window

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
BOOL CNotifyWin::FinalConstruct(void)
{
    BOOL fResult = FALSE;

    // Initialize
    m_fCalaisUp = FALSE;

    // Register a new class for this window
    m_sClassName = AfxRegisterWndClass(CS_NOCLOSE);

    // Load the context menu resource
    fResult = m_ContextMenu.LoadMenu((UINT)IDR_STATUS_MENU);

    return fResult;
}


/*++

FinalRelease:

    This method implements the final destructor for this window

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CNotifyWin::FinalRelease( void )
{
    //
    // Clean up anything init'd in the FinalContruct(or)
    //

    m_ContextMenu.DestroyMenu();
}


/////////////////////////////////////////////////////////////////////////////
//
// CNotifyWin message handlers
//


/*++

void OnCreate:

    Called after windows is created but before it is shown. Used here
    to set task bar icon.

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
int CNotifyWin::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    BOOL fReturn = TRUE;
    int nReturn = 0;
    CString strStatusText;

    try
    {
        if (CWnd::OnCreate(lpCreateStruct) == -1)
            throw (int)-1;

        // Set the menu
        if (!SetMenu(&m_ContextMenu))
        {
            throw (long)GetLastError();
        }

        // Set the task bar icon
        m_pApp = (CSCStatusApp*)AfxGetApp();
        ASSERT(NULL != m_pApp);

        // Setup notify struct
        ZeroMemory((PVOID)&m_nidIconData, sizeof(NOTIFYICONDATA));
        m_nidIconData.cbSize = sizeof(NOTIFYICONDATA);
        m_nidIconData.hWnd = m_hWnd;
        m_nidIconData.uID = 1;  // this is our #1 (only) icon
        m_nidIconData.uFlags = 0
            |   NIF_ICON    // The hIcon member is valid
            |   NIF_MESSAGE // The uCallbackMessage message is valid
            |   NIF_TIP;    // The szTip member is valid
        m_nidIconData.uCallbackMessage = WM_SCARD_NOTIFY;
        m_nidIconData.hIcon = m_pApp->m_hIconCard; // this will be set later
        strStatusText.LoadString(IDS_SYSTEM_UP);
        lstrcpy(m_nidIconData.szTip, strStatusText);

        if (!Shell_NotifyIcon(NIM_ADD, &m_nidIconData))
        {
            _ASSERTE(FALSE);    // Why can't we modify the taskbar icon???
        }

        // Determine Smart Card service status (sets task bar icon & threads)
        CheckSystemStatus(TRUE);

    }
    catch(long lErr)
    {
        nReturn = 0;
        TRACE_CATCH_UNKNOWN(_T("OnCreate"));
    }
    catch(int nErr)
    {
        nReturn = nErr;
        TRACE_CATCH_UNKNOWN(_T("OnCreate"));
    }

    return nReturn;
}


/*++

void OnContextClose:

    This message handler is when the popup menu's Close is called

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CNotifyWin::OnContextClose( void )
{
    //
    // Remove task bar notification area icon first
    //

    if (!Shell_NotifyIcon(NIM_DELETE, &m_nidIconData))
    {
        _ASSERTE(FALSE); // the icon will be cleaned up when app exits, anyway
    }

    //
    // Note that we're shutting down, so CheckSystemStatus will do no work.
    //
    m_fShutDown = TRUE;

    //
    // Shut down threads one at a time
    //
    m_ThreadLock.Lock();

    if (NULL != m_lpStatusDlgThrd)
    {
        m_lpStatusDlgThrd->Close();
        DWORD dwRet = WaitForSingleObject(m_lpStatusDlgThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpStatusDlgThrd;
        m_lpStatusDlgThrd = NULL;
    }

    if (NULL != m_lpCardStatusThrd)
    {
        m_lpCardStatusThrd->Close();
        DWORD dwRet = WaitForSingleObject(m_lpCardStatusThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpCardStatusThrd;
        m_lpCardStatusThrd = NULL;
    }

	if (NULL != m_lpNewReaderThrd)
	{
		// signal m_lpNewReaderThrd to close
		SetEvent(m_hKillNewReaderThrd);
		DWORD dwRet = WaitForSingleObject(m_lpNewReaderThrd->m_hThread, INFINITE);
		_ASSERTE(WAIT_OBJECT_0 == dwRet);
		delete m_lpNewReaderThrd;
		m_lpNewReaderThrd = NULL;
		CloseHandle(m_hKillNewReaderThrd);
		m_hKillNewReaderThrd = NULL;
	}

	if (NULL != m_lpRemOptThrd)
	{
		// signal m_lpRemOptThrd to close
		SetEvent(m_hKillRemOptThrd);
		DWORD dwRet = WaitForSingleObject(m_lpRemOptThrd->m_hThread, INFINITE);
		_ASSERTE(WAIT_OBJECT_0 == dwRet);
		delete m_lpRemOptThrd;
		m_lpRemOptThrd = NULL;
		CloseHandle(m_hKillRemOptThrd);
		m_hKillRemOptThrd = NULL;
	}

	if (NULL != m_lpResMgrStsThrd)
	{
		// signal m_lpNewReaderThrd to close
		SetEvent(m_hKillResMgrStatusThrd);
		DWORD dwRet = WaitForSingleObject(m_lpResMgrStsThrd->m_hThread, INFINITE);
		_ASSERTE(WAIT_OBJECT_0 == dwRet);
		delete m_lpResMgrStsThrd;
		m_lpResMgrStsThrd = NULL;
		CloseHandle(m_hKillResMgrStatusThrd);
		m_hKillResMgrStatusThrd = NULL;
	}

    m_ThreadLock.Unlock();

    // Post the quit message for this thread
    ::PostQuitMessage(0);
}


/*++

void OnContextStatus:

    This message handler is when the popup menu's Status is called.
    Thie displays the dialog.

Arguments:

    None.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CNotifyWin::OnContextStatus( void )
{
    if (!m_fCalaisUp)
    {
        // The user should not have been able to request "Status"
        // when the system is down.  Toss up an error...

        AfxMessageBox(IDS_NO_SYSTEM_STATUS);
        return;
    }

    //
    // Start a thread for the status dialog if needed
    //

    m_ThreadLock.Lock();

    if (NULL != m_lpCardStatusThrd)
    {
        m_lpCardStatusThrd->CopyIdleList(&m_aIdleList);
    }

    if (m_lpStatusDlgThrd == NULL)
    {
        m_lpStatusDlgThrd = (CSCStatusDlgThrd*)AfxBeginThread(
                                    RUNTIME_CLASS(CSCStatusDlgThrd),
                                    THREAD_PRIORITY_NORMAL,
                                    0,
                                    CREATE_SUSPENDED);

        if (NULL != m_lpStatusDlgThrd)
        {
            m_lpStatusDlgThrd->m_hCallbackWnd = m_hWnd;
            m_lpStatusDlgThrd->ResumeThread();
            m_lpStatusDlgThrd->UpdateStatus(&m_aIdleList);
        }
    }
    else
    {
        // ShowDialog should start the dialog if it's not currently open...
        m_lpStatusDlgThrd->ShowDialog(SW_SHOWNORMAL, &m_aIdleList);
    }

    m_ThreadLock.Unlock();
}


/*++

void OnSCardNotify:

    This message handler is called when action is taken on the task bar icon.

Arguments:

    wParam - wparam of message
    lParam - lparam of message.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
LONG CNotifyWin::OnSCardNotify( UINT wParam, LONG lParam)
{
    // Locals
    BOOL fResult = FALSE;
    CMenu *pMenu = NULL;
    POINT point;

    try
    {
        // Switch on mouse button notification types.
        switch ((UINT) lParam)
        {
        case WM_LBUTTONUP:
            // same thing as if user selected context menu:Status
            OnContextStatus();
            break;

        case WM_RBUTTONUP:

            //
            // Display context menu where user clicked
            //

            // Set the foregrouond window to fix menu track problem.
            SetForegroundWindow();

            fResult = GetCursorPos(&point);

            if (fResult)
            {
                // Display the pop-up menu
                pMenu = m_ContextMenu.GetSubMenu(0);
                ASSERT(NULL != pMenu);

                if (NULL != pMenu)
                {
                    fResult = pMenu->TrackPopupMenu(    TPM_RIGHTALIGN |
                                                        TPM_BOTTOMALIGN |
                                                        TPM_LEFTBUTTON |
                                                        TPM_RIGHTBUTTON,
                                                        point.x,
                                                        point.y,
                                                        this,
                                                        NULL);
                }
            }

            if (!fResult)
            {
                throw (fResult);
            }

            // Force a task switch by sending message to fix menu track problem
            PostMessage(WM_NULL);
            break;

        default:
            break;
        }
    }
    catch(LONG err)
    {
        TRACE_CATCH(_T("OnSCardNotify"),err);
    }
    catch(...)
    {
        TRACE_CATCH_UNKNOWN(_T("OnSCardNotify"));
    }

    return 0;
}


/*++

void OnSCardStatusDlgExit:

    This message handler is called when the status dialog is closed.

Arguments:

    wParam - wparam of message
    lParam - lparam of message.

Return Value:

    None

Author:

    Chris Dudley 7/30/1997

Note:

--*/
LONG CNotifyWin::OnSCardStatusDlgExit( UINT, LONG )
{
    m_ThreadLock.Lock();

    // Clear for creation of another dialog
    if (NULL != m_lpStatusDlgThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_lpStatusDlgThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpStatusDlgThrd;
        m_lpStatusDlgThrd = NULL;
    }

    m_ThreadLock.Unlock();

    // Did the resource manager go down?
    CheckSystemStatus();

    return 0;
}


/*++

void OnResMgrExit:

    This message handler signals "resmgr thread gone" & calls CheckSystemStatus

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnResMgrExit( UINT, LONG )
{
    m_ThreadLock.Lock();

    // close the killthread event handle
    if (NULL != m_hKillResMgrStatusThrd)
    {
        CloseHandle(m_hKillResMgrStatusThrd);
        m_hKillResMgrStatusThrd = NULL;
    }

    // delete the old (dead) thread
    if (NULL != m_lpResMgrStsThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_lpResMgrStsThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpResMgrStsThrd;
        m_lpResMgrStsThrd = NULL;
    }

    m_ThreadLock.Unlock();

    // What is the status of the RM now?
    CheckSystemStatus();
    return 0;
}


/*++

void OnNewReaderExit:

    This message handler signals "resmgr thread gone" & calls CheckSystemStatus

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnNewReaderExit( UINT, LONG )
{
    m_ThreadLock.Lock();

    // close the killthread event handle
    if (NULL != m_hKillNewReaderThrd)
    {
        CloseHandle(m_hKillNewReaderThrd);
        m_hKillNewReaderThrd = NULL;
    }

    // delete the old (dead) thread
    if (NULL != m_lpNewReaderThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_lpNewReaderThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpNewReaderThrd;
        m_lpNewReaderThrd = NULL;
    }

    m_ThreadLock.Unlock();

    // What is the status of the RM now?
    CheckSystemStatus();
    return 0;
}


/*++

void OnCardStatusExit:

    This message handler signals "cardstatus thread gone" & calls CheckSystemStatus

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnCardStatusExit( UINT, LONG )
{
    m_ThreadLock.Lock();

    // Clear for creation of another CardStatusThrd
    if (NULL != m_lpCardStatusThrd)
    {
        DWORD dwRet = WaitForSingleObject(m_lpCardStatusThrd->m_hThread, INFINITE);
        _ASSERTE(WAIT_OBJECT_0 == dwRet);
        delete m_lpCardStatusThrd;
        m_lpCardStatusThrd = NULL;
    }

    m_ThreadLock.Unlock();

    // What is the status of the RM now?
    CheckSystemStatus();
    return 0;
}


/*++

void OnResMgrStatus:

    This message handler catches RM system status updates from the
    ResMGrThread, and calls SetSystemStatus accordingly

Arguments:

    ui - WPARAM (BOOL - true if calais is running)
    l - not used.

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnResMgrStatus( UINT ui, LONG l)
{
    // Is the resource manager back?
    BOOL fCalaisUp = (ui != 0);
    SetSystemStatus(fCalaisUp);

    return 0;
}


/*++

void OnNewReader:

    This message handler tells the two threads that use reader lists to
    update those lists.

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnNewReader( UINT, LONG )
{
    m_ThreadLock.Lock();

    if (NULL != m_lpStatusDlgThrd)
    {
        m_lpStatusDlgThrd->Update();
    }

    m_ThreadLock.Unlock();

    return 0;
}



/*++

void OnCardStatus:

    This message handler tells the two threads that use reader lists to
    update those lists.

Arguments:

    Not Used

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98

Note:

--*/
LONG CNotifyWin::OnCardStatus( UINT uStatus, LONG )
{
    bool fNotify = false;

    //
    // Need to notify user at end of OnCardStatus if a new card has gone IDLE
    //

    if (k_State_CardIdle == uStatus)
    {
        if (k_State_CardIdle != m_pApp->m_dwState)
        {
            fNotify = true;
        }
        else
        {
            CStringArray astrTemp;
            m_ThreadLock.Lock();
            {
                if (NULL != m_lpCardStatusThrd)
                {
                    m_lpCardStatusThrd->CopyIdleList(&astrTemp);
                }
            }
            m_ThreadLock.Unlock();

            // compare new list of idle cards w/ current list
            for (int n1=(int)astrTemp.GetUpperBound(); n1>=0; n1--)
            {
                for (int n2=(int)m_aIdleList.GetUpperBound(); n2>=0; n2--)
                {
                    if (m_aIdleList[n2] == astrTemp[n1]) break;
                }
                if (n2<0) // a match was not found!
                {
                    fNotify = true;
                }
            }
        }
    }

    //
    // At least, update the status dialog with the new idle list
    //

    m_ThreadLock.Lock();
    {
        if (NULL != m_lpCardStatusThrd)
        {
            m_lpCardStatusThrd->CopyIdleList(&m_aIdleList);

            if (NULL != m_lpStatusDlgThrd)
            {
                m_lpStatusDlgThrd->UpdateStatus(&m_aIdleList);
            }
        }
    }
    m_ThreadLock.Unlock();

    //
    // Set the new status
    //

    SetSystemStatus(true, false, (DWORD)uStatus);

    //
    // If there is a newly idle card, notify user according to alert options
    //

    if(fNotify)
    {
        switch(m_pApp->m_dwAlertOption)
        {
        case k_AlertOption_IconOnly:
            // Do nothing
            break;
        case k_AlertOption_IconSound:
            // MessageBeep(MB_ICONINFORMATION);
            PlaySound( TEXT("SmartcardIdle"), NULL, SND_ASYNC | SND_ALIAS | SND_NODEFAULT );
            break;
        case k_AlertOption_IconSoundMsg:
            // MessageBeep(MB_ICONINFORMATION);
            PlaySound( TEXT("SmartcardIdle"), NULL, SND_ASYNC | SND_ALIAS | SND_NODEFAULT );
        case k_AlertOption_IconMsg:
            OnContextStatus(); // raise status dialog
            break;
        default:
            MessageBeep(MB_ICONQUESTION);
            break;
        }
    }

    return 0;
}



/*++

void OnRemovalOptionsChange:

    This message handler tells the status dialog to update its
	logon/lock reader designation
		
Arguments:

	Not Used
	
Return Value:
	
	None

Author:

    Amanda Matlosz	4/28/98

Note:

--*/
LONG CNotifyWin::OnRemovalOptionsChange( UINT, LONG )
{
	ASSERT(NULL != m_pApp);

	//
	// Need to update RemovalOptions
	//

	m_pApp->SetRemovalOptions();

	//
	// Tell stat dialog to update status if neccessary
	//
	m_ThreadLock.Lock();
	{
		if (NULL != m_lpCardStatusThrd)
		{
			m_lpCardStatusThrd->CopyIdleList(&m_aIdleList);

			if (NULL != m_lpStatusDlgThrd)
			{
				m_lpStatusDlgThrd->UpdateStatus(&m_aIdleList);
			}
		}
	}
	m_ThreadLock.Unlock();

    return 0;
}


/*++

void OnRemovalOptionsExit:

    This message handler signals "remoptions thread gone" & calls CheckSystemStatus
		
Arguments:

	Not Used
	
Return Value:
	
	None

Author:

    Amanda Matlosz	4/28/98

Note:

--*/
LONG CNotifyWin::OnRemovalOptionsExit( UINT, LONG )
{
	m_ThreadLock.Lock();

	// close the killthread event handle
	if (NULL != m_hKillRemOptThrd)
	{
		CloseHandle(m_hKillRemOptThrd);
		m_hKillRemOptThrd = NULL;
	}

	// delete the old (dead) thread
	if (NULL != m_lpRemOptThrd)
	{
		DWORD dwRet = WaitForSingleObject(m_lpRemOptThrd->m_hThread, INFINITE);
		_ASSERTE(WAIT_OBJECT_0 == dwRet);
		delete m_lpRemOptThrd;
		m_lpRemOptThrd = NULL;
	}

	m_ThreadLock.Unlock();

	// What is the status of the RM now?
	CheckSystemStatus();
	return 0;
}



/*++

void SetSystemStatus:

    This is called to set UI & behavior according to RM status.

Arguments:

    fCalaisUp -- TRUE if the RM is running

Return Value:

    None

Author:

    Amanda Matlosz  5/28/98

Note:

--*/
void CNotifyWin::SetSystemStatus(BOOL fCalaisUp, BOOL fForceUpdate, DWORD dwState)
{
    ASSERT(NULL != m_pApp);

    //
    // Update UI & behavior & threads only if there has actually been a change
    //

    if (!fForceUpdate && fCalaisUp == m_fCalaisUp && m_pApp->m_dwState == dwState)
    {
        return;
    }

    m_fCalaisUp = fCalaisUp;
    if (dwState != k_State_Unknown)
    {
        m_pApp->m_dwState = dwState;
    }

    //
    // Set appearance of taskbar icon
    //

    CString strStatusText;

    if (!m_fCalaisUp)
    {
        // Get new icon & tooltip for taskbar
        strStatusText.LoadString(IDS_SYSTEM_DOWN);
        m_nidIconData.hIcon = m_pApp->m_hIconCalaisDown;

        // disable "Status" Context menuitem
        m_ContextMenu.EnableMenuItem(IDM_STATUS, MF_DISABLED | MF_GRAYED);
        m_pApp->m_dwState = k_State_Unknown;
    }
    else
    {
        // Get new icon & tooltip for taskbar
        strStatusText.LoadString(IDS_SYSTEM_UP);

        switch(m_pApp->m_dwState)
        {
        case k_State_CardAvailable:
            m_nidIconData.hIcon = m_pApp->m_hIconCard;
            break;
        case k_State_CardIdle:
            m_nidIconData.hIcon = m_pApp->m_hIconCardInfo;
            break;
        default:
        case k_State_NoCard:
            m_nidIconData.hIcon = m_pApp->m_hIconRdrEmpty;
            break;
        }

        // enable "Status" Context menuitem
        m_ContextMenu.EnableMenuItem(IDM_STATUS, MF_ENABLED);
    }

    lstrcpy(m_nidIconData.szTip, strStatusText);
    if (!Shell_NotifyIcon(NIM_MODIFY, &m_nidIconData))
    {
        _ASSERTE(FALSE);    // Why can't we modify the taskbar icon???
                            // Ultimately, though, we don't care about this error.
    }

    //
    // Start or stop threads as appropriate
    //

    m_ThreadLock.Lock();

	// the RemoveOptionsChange thread should always be running
	if (NULL == m_lpRemOptThrd)
	{
		// reset the KillThread event if possible; if not, recreate it.
		if (NULL != m_hKillRemOptThrd)
		{
			// reset event to non-signalled
			if (!ResetEvent(m_hKillRemOptThrd))
			{
				CloseHandle(m_hKillRemOptThrd);
				m_hKillRemOptThrd = NULL;
			}
		}

		if (NULL == m_hKillRemOptThrd)
		{
			m_hKillRemOptThrd = CreateEvent(
				NULL,
				TRUE,  // must call ResetEvent() to set non-signaled
				FALSE, // not signaled when it starts
				NULL);
		}

		m_lpRemOptThrd = (CRemovalOptionsThrd*)AfxBeginThread(
									RUNTIME_CLASS(CRemovalOptionsThrd),
									THREAD_PRIORITY_NORMAL,
									0,
									CREATE_SUSPENDED);

		if (NULL != m_lpRemOptThrd)
		{
			m_lpRemOptThrd->m_hCallbackWnd = m_hWnd;
			m_lpRemOptThrd->m_hKillThrd = m_hKillRemOptThrd;
			m_lpRemOptThrd->ResumeThread();
		}
	}

	if (!m_fCalaisUp)
	{
		if (NULL != m_lpNewReaderThrd)
		{
			// signal m_lpNewReaderThrd to close
			SetEvent(m_hKillNewReaderThrd);
			DWORD dwRet = WaitForSingleObject(m_lpNewReaderThrd->m_hThread, INFINITE);
			_ASSERTE(WAIT_OBJECT_0 == dwRet);
			delete m_lpNewReaderThrd;
			m_lpNewReaderThrd = NULL;
			CloseHandle(m_hKillNewReaderThrd);
			m_hKillNewReaderThrd = NULL;
		}

        if (NULL != m_lpCardStatusThrd)
        {
            // close down m_lpCardStatusThrd
            m_lpCardStatusThrd->Close();
            DWORD dwRet = WaitForSingleObject(m_lpCardStatusThrd->m_hThread, INFINITE);
            _ASSERTE(WAIT_OBJECT_0 == dwRet);
            delete m_lpCardStatusThrd;
            m_lpCardStatusThrd = NULL;
        }

        // Start ResMgrSts to poll/wait for RM startup
        if (NULL == m_lpResMgrStsThrd)
        {
            // reset the KillThread event if possible; if not, recreate it.
            if (NULL != m_hKillResMgrStatusThrd)
            {
                // reset event to non-signalled
                if (!ResetEvent(m_hKillResMgrStatusThrd))
                {
                    CloseHandle(m_hKillResMgrStatusThrd);
                    m_hKillResMgrStatusThrd = NULL;
                }
            }

            if (NULL == m_hKillResMgrStatusThrd)
            {
                m_hKillResMgrStatusThrd = CreateEvent(
                    NULL,
                    TRUE,  // must call ResetEvent() to set non-signaled
                    FALSE, // not signaled when it starts
                    NULL);
            }

            m_lpResMgrStsThrd = (CResMgrStatusThrd*)AfxBeginThread(
                                        RUNTIME_CLASS(CResMgrStatusThrd),
                                        THREAD_PRIORITY_NORMAL,
                                        0,
                                        CREATE_SUSPENDED);

            if (NULL != m_lpResMgrStsThrd)
            {
                m_lpResMgrStsThrd->m_hCallbackWnd = m_hWnd;
                m_lpResMgrStsThrd->m_hKillThrd = m_hKillResMgrStatusThrd;
                m_lpResMgrStsThrd->ResumeThread();
            }
        }

    }
    else
    {
        // shut down res mgr status thread
        if (NULL != m_lpResMgrStsThrd)
        {
            // signal m_lpResMgrStsThrd to close
            SetEvent(m_hKillResMgrStatusThrd);
            DWORD dwRet = WaitForSingleObject(m_lpResMgrStsThrd->m_hThread, INFINITE);
            _ASSERTE(WAIT_OBJECT_0 == dwRet);
            delete m_lpResMgrStsThrd;
            m_lpResMgrStsThrd = NULL;
            CloseHandle(m_hKillResMgrStatusThrd);
            m_hKillResMgrStatusThrd = NULL;
        }

        // start newreader thread
        if (NULL == m_lpNewReaderThrd)
        {
            // reset the KillThread event if possible; if not, recreate it.
            if (NULL != m_hKillNewReaderThrd)
            {
                // reset event to non-signalled
                if (!ResetEvent(m_hKillNewReaderThrd))
                {
                    CloseHandle(m_hKillNewReaderThrd);
                    m_hKillNewReaderThrd = NULL;
                }
            }

            if (NULL == m_hKillNewReaderThrd)
            {
                m_hKillNewReaderThrd = CreateEvent(
                    NULL,
                    TRUE,  // must call ResetEvent() to set non-signaled
                    FALSE, // not signaled when it starts
                    NULL);
            }

            if (NULL != m_hKillNewReaderThrd)
            {
                m_lpNewReaderThrd = (CNewReaderThrd*)AfxBeginThread(
                                        RUNTIME_CLASS(CNewReaderThrd),
                                        THREAD_PRIORITY_NORMAL,
                                        0,
                                        CREATE_SUSPENDED);
            }

            if (NULL != m_lpNewReaderThrd)
            {
                m_lpNewReaderThrd->m_hCallbackWnd = m_hWnd;
                m_lpNewReaderThrd->m_hKillThrd = m_hKillNewReaderThrd;
                m_lpNewReaderThrd->ResumeThread();
            }
        }

        // start CardStatus thread
        if (NULL == m_lpCardStatusThrd)
        {
            m_lpCardStatusThrd = (CCardStatusThrd*)AfxBeginThread(
                                        RUNTIME_CLASS(CCardStatusThrd),
                                        THREAD_PRIORITY_NORMAL,
                                        0,
                                        CREATE_SUSPENDED);

			if (NULL != m_lpCardStatusThrd)
			{
				m_lpCardStatusThrd->m_hCallbackWnd = m_hWnd;
				m_lpCardStatusThrd->m_paIdleList = &m_aIdleList;
				m_lpCardStatusThrd->m_pstrLogonReader = &(((CSCStatusApp*)AfxGetApp())->m_strLogonReader);
				m_lpCardStatusThrd->ResumeThread();
			}
		}
		else // better be NULL!
		{
			_ASSERTE(FALSE);
		}

        // StatDlg may need to be updated
        if (NULL != m_lpStatusDlgThrd)
        {
            m_lpStatusDlgThrd->Update();
        }

    }

    m_ThreadLock.Unlock();

}


/*++

void CheckSystemStatus:

    This is called as a result of a thread exiting.  Check to see whether the
    MS Smart Card Resource Manager (Calais) is running or not, and set
    UI & behavior accordingly.

Arguments:

    None

Return Value:

    None

Author:

    Amanda Matlosz  3/18/98

Note:

--*/
void CNotifyWin::CheckSystemStatus(BOOL fForceUpdate)
{
    //
    // We only care about this status if we're
    // NOT in the middle of shutting down
    //

    if (m_fShutDown)
    {
        return;
    }

    //
    // Query the service manager for the RM's status
    //

    DWORD dwReturn = ERROR_SUCCESS;
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    SERVICE_STATUS ssStatus;    // current status of the service
    ZeroMemory((PVOID)&ssStatus, sizeof(ssStatus));

    schSCManager = OpenSCManager(
                        NULL,                 // machine (NULL == local)
                        NULL,                 // database (NULL == default)
                        SC_MANAGER_CONNECT);  // access required
    if (NULL == schSCManager)
    {
        dwReturn = (DWORD)GetLastError();
    }

    if (ERROR_SUCCESS == dwReturn)
    {
        schService = OpenService(
                            schSCManager,
                            TEXT("SCardSvr"),
                            SERVICE_QUERY_STATUS);
        if (NULL == schService)
        {
            dwReturn = (DWORD)GetLastError();
        }
        else if (!QueryServiceStatus(schService, &ssStatus))
        {
            dwReturn = (DWORD)GetLastError();
        }
    }

    // if the service is running, say it's up
    // if the service is stopped, paused, or pending action,
    // say it's down.  NOTE: may want to consider graying out
    // the taskbar icon to indicate paused, or some other err.
    if (ERROR_SUCCESS == dwReturn)
    {
        if (SERVICE_RUNNING == ssStatus.dwCurrentState)
        {
            dwReturn = SCARD_S_SUCCESS;
        }
        else
        {
            dwReturn = SCARD_E_NO_SERVICE;
        }
    }

    if (NULL != schService)
    {
        CloseServiceHandle(schService);
        schService = NULL;
    }
    if (NULL != schSCManager)
    {
        CloseServiceHandle(schSCManager);
        schSCManager = NULL;
    }
    CalaisReleaseStartedEvent();

    //
    // Change state, log event as necessary,
    // and kick off appropriate threads
    //

    SetSystemStatus((SCARD_S_SUCCESS == dwReturn), fForceUpdate);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\resmgrst.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ResMgrSt

Abstract:

    This file contains the implementation of threads that monitor
	the status of the smart card resource manager, and notify the
	application when that state has changed via callbacks.

Author:

    Amanda Matlosz      03/18/1998

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

    5/28/98 AMatlosz    Previously, this thread just watched for the RM to move
                        from a 'down' state to an 'up' state.  Now it keeps on
                        eye on the state to make up for the fact that the other
                        two threads who previously monitored status must shut
                        themselves down if the RM is up but there are no readers
                        available.

	10/28/98 AMatlosz	Added thread to watch for new readers.

Notes:

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "stdafx.h"
#include <winsvc.h>
#include <winscard.h>
#include <calaislb.h>
#include <scEvents.h>

#include "SCAlert.h"
#include "ResMgrSt.h"
#include "miscdef.h"


////////////////////////////////////////////////////////////////////////////
//
// Globals
//

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////////////
//
// CResMgrStatusThrd
//

IMPLEMENT_DYNCREATE(CResMgrStatusThrd, CWinThread)

/*++

InitInstance

    Must override init instance to do the loop

Arguments:


Return Value:

    TRUE on build start message loop. FALSE otherwise


Notes:

    This thread uses two callbacks to inform the caller of its status:

    WM_SCARD_RESMGR_STATUS -- WPARAM is bool indicating RM status: true == up
    WM_SCARD_RESMGR_EXIT -- indicates thread has been shut down or is shutting
                            down.
--*/
BOOL CResMgrStatusThrd::InitInstance(void)
{
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    SERVICE_STATUS ssStatus;    // current status of the service
    DWORD dwSts;
    DWORD dwReturn = ERROR_SUCCESS;

    //
    // Take a short break, then ping the service manager to see if the resource
    // manager is running.  If not, wait a long time for it to start.  Repeat
    // until the thread has been asked to die.
    //

	BOOL fContinue = TRUE;

    while (fContinue)
    {
        try
        {
            if (NULL == schSCManager)
            {
                schSCManager = OpenSCManager(
                                    NULL,                   // machine (NULL == local)
                                    NULL,                   // database (NULL == default)
                                    SC_MANAGER_CONNECT);  // access required
                if (NULL == schSCManager)
                    throw (DWORD)GetLastError();
            }
            if (NULL == schService)
            {
                schService = OpenService(
                                    schSCManager,
                                    TEXT("SCardSvr"),
                                    SERVICE_QUERY_STATUS);
                if (NULL == schService)
                    throw (DWORD)GetLastError();
            }
            if (!QueryServiceStatus(schService, &ssStatus))
                throw (DWORD)GetLastError();

			switch (ssStatus.dwCurrentState)
			{
			case SERVICE_CONTINUE_PENDING:
			case SERVICE_PAUSE_PENDING:
			case SERVICE_PAUSED:
				continue;
				break;
			case SERVICE_START_PENDING:
			case SERVICE_STOP_PENDING:
			case SERVICE_STOPPED:
				dwReturn = SCARD_E_NO_SERVICE;
				break;
			case SERVICE_RUNNING:
				dwReturn = SCARD_S_SUCCESS;
				break;
			default:
				throw (DWORD)SCARD_F_INTERNAL_ERROR;
			}
        }

        catch (DWORD dwErr)
        {
            _ASSERTE(FALSE);  // For debugging.
            if (NULL != schService)
            {
                CloseServiceHandle(schService);
                schService = NULL;
            }
            if (NULL != schSCManager)
            {
                CloseServiceHandle(schSCManager);
                schSCManager = NULL;
            }
            dwReturn = dwErr;
        }

        catch (...)
        {
            _ASSERTE(FALSE);  // For debugging.
            if (NULL != schService)
            {
                CloseServiceHandle(schService);
                schService = NULL;
            }
            if (NULL != schSCManager)
            {
                CloseServiceHandle(schSCManager);
                schSCManager = NULL;
            }
            dwReturn = ERROR_INVALID_PARAMETER;
        }

        if (SCARD_S_SUCCESS == dwReturn)
        {
			// say it's UP!
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_RESMGR_STATUS,
                          TRUE,
                          0);
        }
        else
        {
			// say it's DOWN!
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_RESMGR_STATUS,
                          FALSE,
                          0);
		}

		//
		// Wait for ~30 seconds, continuing on Start or timeout
		// and stopping immediately if the stop event is signaled
		//

		HANDLE rgHandle[2];
		int nHandle = 2;
		rgHandle[0] = CalaisAccessStartedEvent();
		rgHandle[1] = m_hKillThrd;

 		dwSts = WaitForMultipleObjects(
					nHandle,
					rgHandle,
					FALSE,
					300000);
		if (WAIT_OBJECT_0 != dwSts && WAIT_TIMEOUT != dwSts)
		{
			fContinue = FALSE;
		}

        CalaisReleaseStartedEvent();

    }

    //
    // Clean up & let our caller know that we're shutting down.
    //

    if (NULL != schService)
    {
        CloseServiceHandle(schService);
        schService = NULL;
    }
    if (NULL != schSCManager)
    {
        CloseServiceHandle(schSCManager);
        schSCManager = NULL;
    }
    CalaisReleaseStartedEvent();
    if (NULL != m_hCallbackWnd)
    {
        ::PostMessage(m_hCallbackWnd,
                      WM_SCARD_RESMGR_EXIT,
                      0, 0);
    }

    AfxEndThread(0);
    return TRUE; // to make compiler happy
}



/////////////////////////////////////////////////////////////////////////////////////
//
// CRemovalOptionsThrd
//

IMPLEMENT_DYNCREATE(CRemovalOptionsThrd, CWinThread)

/*++

InitInstance

    Must override init instance to do the loop

Arguments:


Return Value:

    TRUE on build start message loop. FALSE otherwise


Notes:

    This thread uses one message to inform the caller of a change in
	the user's removal options:

    WM_SCARD_REMOPT_CHNG -- re-query smart card removal options

--*/
BOOL CRemovalOptionsThrd::InitInstance(void)
{
    DWORD dwSts = WAIT_FAILED;
    LONG lResult = ERROR_SUCCESS;
	BOOL fContinue = TRUE;
	int nHandle = 2;
	HANDLE rgHandle[2] = {NULL, NULL};
	rgHandle[1] = m_hKillThrd;
	HKEY hKey = NULL;

    while (fContinue)
    {
		// open regkey
		lResult = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			szScRemoveOptionKey,
			0,
			KEY_ALL_ACCESS,
			&hKey);
		if (ERROR_SUCCESS != lResult)
		{
			goto ErrorExit;
		}

		// reset/create event
		if (NULL != rgHandle[0])
		{
			if (!ResetEvent(rgHandle[0]))
			{
				CloseHandle(rgHandle[0]);
				rgHandle[0] = NULL;
			}
		}
		if (NULL == rgHandle[0])
		{
			rgHandle[0] = CreateEvent(
				NULL,
				TRUE,  // must call ResetEvent() to set non-signaled
				FALSE, // not signaled when it starts
				NULL);
			if (NULL == rgHandle[0])
			{
				// give up!
				goto ErrorExit;
			}
		}

		lResult = RegNotifyChangeKeyValue(
			hKey,
			TRUE,
			REG_NOTIFY_CHANGE_LAST_SET,
			rgHandle[0],
			TRUE);
		if (ERROR_SUCCESS != lResult)
		{
			goto ErrorExit;
		}


 		dwSts = WaitForMultipleObjects(
					nHandle,
					rgHandle,
					FALSE,
					INFINITE);

		if (WAIT_OBJECT_0 == dwSts)
		{
			// announce the change
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_REMOPT_CHNG,
                          0, 0);
		}
		else if (WAIT_OBJECT_0+1 == dwSts || WAIT_FAILED == dwSts)
		{
			// Time for thread to quit
			fContinue = FALSE;
		}
		else
		{
			_ASSERTE(WAIT_TIMEOUT == dwSts);
		}


    }

    //
    // Clean up & let our caller know that we're shutting down.
    //
ErrorExit:

	if (NULL != hKey)
	{
		RegCloseKey(hKey);
	}

	if (NULL != rgHandle[0])
	{
		CloseHandle(rgHandle[0]);
	}

    if (NULL != m_hCallbackWnd)
    {
			// announce thread's exit
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_REMOPT_EXIT,
                          0, 0);
    }

    AfxEndThread(0);
    return TRUE; // to make compiler happy
}



/////////////////////////////////////////////////////////////////////////////////////
//
// CNewReaderThrd
//

IMPLEMENT_DYNCREATE(CNewReaderThrd, CWinThread)

/*++

InitInstance

    Must override init instance to do the loop

Arguments:


Return Value:

    TRUE on build start message loop. FALSE otherwise


Notes:

    This thread uses one callback to inform the caller of an addition to
	the active reader list.

    WM_SCARD_NEWREADER -- indicates that Calais reports a reader just added

--*/
BOOL CNewReaderThrd::InitInstance(void)
{
	if (NULL == m_hCallbackWnd)
	{
		_ASSERTE(FALSE);
		return TRUE; // for compiler
	}

	DWORD dwSts = 0;
	BOOL fContinue = TRUE;

    while (fContinue)
    {
		HANDLE rgHandle[2];
		int nHandle = 2;
		rgHandle[0] = CalaisAccessNewReaderEvent();
		rgHandle[1] = m_hKillThrd;

 		dwSts = WaitForMultipleObjects(
					nHandle,
					rgHandle,
					FALSE,
					300000);

		if (WAIT_OBJECT_0 == dwSts)
		{
			// a new reader event happened!  Fire off the notice
            ::PostMessage(m_hCallbackWnd,
                          WM_SCARD_NEWREADER,
                          TRUE,
                          0);
		}
		else if (WAIT_OBJECT_0+1 == dwSts || WAIT_FAILED == dwSts)
		{
			// Time for thread to quit
			fContinue = FALSE;
		}
		else
		{
			_ASSERTE(WAIT_TIMEOUT == dwSts);
		}

		CalaisReleaseNewReaderEvent();
    }

    if (NULL != m_hCallbackWnd)
    {
        ::PostMessage(m_hCallbackWnd,
                      WM_SCARD_NEWREADER_EXIT,
                      0, 0);
    }

    AfxEndThread(0);
    return TRUE; // to make compiler happy
}


/////////////////////////////////////////////////////////////////////////////////////
//
// CCardStatusThrd
//

IMPLEMENT_DYNCREATE(CCardStatusThrd, CWinThread)

/*++

InitInstance

    Must override init instance to do the loop

Arguments:


Return Value:

    TRUE on build start message loop. FALSE otherwise


Notes:

    This thread uses one callback to inform the caller of a change in
	smart card status -- a card is available, no cards are available,
	or a card has been idle for >30 seconds.

    WM_SCARD_CARDSTATUS -- indicates a new card status
	WM_SCARD_CARDSTATUS_EXIT -- indicates imminent thread death.

--*/
BOOL CCardStatusThrd::InitInstance(void)
{
	LONG lResult = SCardEstablishContext(SCARD_SCOPE_USER,NULL,NULL,&m_hCtx);

	if (SCARD_S_SUCCESS != lResult)
	{
		CString str;
		str.Format(_T("CCardStatusThrd:: SCardEstablishContext returned 0x%x."), lResult);
	}

	BOOL fContinue = TRUE;
	LPTSTR szReaders = NULL;
	LPCTSTR pchReader = NULL;
	DWORD dwReadersLen = SCARD_AUTOALLOCATE;
    SCARD_READERSTATE rgReaderStates[MAXIMUM_SMARTCARD_READERS];
	int nIndex = 0, nCnReaders = 0;
	BOOL fLogonLock = (NULL != m_pstrLogonReader && !m_pstrLogonReader->IsEmpty());

    lResult = SCardListReaders(
        m_hCtx,
        SCARD_ALL_READERS,
        (LPTSTR)&szReaders,
        &dwReadersLen
        );

    if(SCARD_S_SUCCESS != lResult ||
	  (0 == dwReadersLen || NULL == szReaders || 0 == *szReaders) )
    {
		fContinue = FALSE;
    }

	if (fContinue)
	{
		// use the list of readers to build a readerstate array
		for (nIndex = 0, pchReader = szReaders;
			 nIndex < MAXIMUM_SMARTCARD_READERS && 0 != *pchReader;
			 nIndex++)
		{
			rgReaderStates[nIndex].szReader = pchReader;
			rgReaderStates[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
			pchReader += lstrlen(pchReader)+1;
		}
	    nCnReaders = nIndex;
	}

    while (fContinue)
    {
		UINT uState = (UINT)k_State_NoCard;

        lResult = SCardGetStatusChange(
            m_hCtx,
            10000,			//  IN      DWORD dwTimeout (10 seconds)
            rgReaderStates, //  IN OUT  LPSCARD_READERSTATE
            nCnReaders      //  IN      DWORD cReaders
            );

		// IF return is success, determine if there are any cards inserted
		// if YES, send a messge to notfywnd saying "card in"
		// if NO, send a message to notfywnd saying "no card"
		if (SCARD_S_SUCCESS == lResult)
		{
			// Determine if
			//   (a) any card is present in the system and
			//   (b) if each idle card has ceased to be idle or present
			BOOL fIdle = FALSE;

			for(nIndex=0; nIndex < nCnReaders; nIndex++)
			{
				if (rgReaderStates[nIndex].dwEventState & SCARD_STATE_PRESENT)
				{
					uState = (UINT)k_State_CardAvailable;
				}

				if (k_State_CardIdle == (UINT_PTR)(rgReaderStates[nIndex].pvUserData))
				{
					if ( !(rgReaderStates[nIndex].dwEventState & SCARD_STATE_PRESENT) ||
						  (rgReaderStates[nIndex].dwEventState & SCARD_STATE_INUSE) )
					{
						rgReaderStates[nIndex].pvUserData = NULL;
					}
					else
					{
						fIdle = TRUE;
					}
				}

				rgReaderStates[nIndex].dwCurrentState = rgReaderStates[nIndex].dwEventState;
			}

			if (fIdle) uState = k_State_CardIdle;

		}
		// IF return indicates timeout, determine if any cards are idle.
		else if (SCARD_E_TIMEOUT == lResult)
		{
			BOOL fIdle = FALSE;

			// is there an idle card?
			for(nIndex=0; nIndex < nCnReaders; nIndex++)
			{
				if (rgReaderStates[nIndex].dwEventState & SCARD_STATE_PRESENT)
				{
					uState = k_State_CardAvailable;

					if (!(rgReaderStates[nIndex].dwEventState & SCARD_STATE_INUSE))
					{
						// card used for logon & logoff or lock is not considered idle
						if (!fLogonLock ||
							0 != m_pstrLogonReader->Compare(rgReaderStates[nIndex].szReader))
						{
							rgReaderStates[nIndex].pvUserData = ULongToPtr(k_State_CardIdle);
							fIdle = TRUE;
						}
					}
					rgReaderStates[nIndex].dwCurrentState = rgReaderStates[nIndex].dwEventState;
				}
			}

			// there's an overdue idle card!  Fire off the notification.
			if (fIdle) uState = k_State_CardIdle;
		}
		else
		{
			fContinue = FALSE;
		}

		// update list of readers w/idle cards
		m_csLock.Lock();
		{
			m_paIdleList->RemoveAll();
			
			for(nIndex=0; nIndex < nCnReaders; nIndex++)
			{
				if (k_State_CardIdle == (UINT_PTR)rgReaderStates[nIndex].pvUserData)
				{
					m_paIdleList->Add(rgReaderStates[nIndex].szReader);
				}
			}
		}
		m_csLock.Unlock();

		// inform caller
		if (NULL != m_hCallbackWnd)
		{
			::PostMessage(m_hCallbackWnd,
						  WM_SCARD_CARDSTATUS,
						  uState,
						  0);
		}

    }

    if (NULL != m_hCallbackWnd)
    {
        ::PostMessage(m_hCallbackWnd,
                      WM_SCARD_CARDSTATUS_EXIT,
                      0, 0);
    }

    AfxEndThread(0);
    return TRUE; // to make compiler happy
}

void CCardStatusThrd::CopyIdleList(CStringArray* paStr)
{
	if (NULL == paStr)
	{
		return;
	}

	m_csLock.Lock();
	{
		paStr->Copy(*m_paIdleList);
	}
	m_csLock.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\notfywin.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    NotfyWin

Abstract:

	This file contains the definition of the CNotifyWind class.
	
Author:

    Chris Dudley 7/28/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	Amanda Matlosz	4/30/1998	-- threading redone, PnP awareness added,
									replaced CSCardEnv, et. al with CScStatusMonitor

	Amanda Matlosz	12/21/1998	-- removed certificate propagation code
	
Notes:

--*/

#ifndef __NOTFYWIN_H__
#define __NOTFYWIN_H__


/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "ScAlert.h"
#include "statdlg.h"
#include "ResMgrSt.h"

// forward decl
class CSCStatusApp;

/////////////////////////////////////////////////////////////////////////////
//
// CNotifyWin dialog
//

class CNotifyWin :	public CWnd
{
	// Construction
public:
	CNotifyWin()
	{
		m_pApp = NULL;

		// state management
		m_fShutDown = FALSE;

		m_lpStatusDlgThrd = NULL;
		m_lpResMgrStsThrd = NULL;
		m_lpNewReaderThrd = NULL;
		m_lpCardStatusThrd = NULL;
		m_lpRemOptThrd = NULL;

		m_hKillNewReaderThrd = NULL;
		m_hKillResMgrStatusThrd = NULL;
		m_hKillRemOptThrd= NULL;

		// other mem.vars
		m_aIdleList.RemoveAll();
	}
	
	~CNotifyWin() { FinalRelease(); }

	BOOL FinalConstruct(void);		// Implements two phase construction
	void FinalRelease(void);


	// Implementation
protected:
	HICON m_hIcon;
	NOTIFYICONDATA m_nidIconData;
	CSCStatusApp* m_pApp;

	// Generated message map functions
	//{{AFX_MSG(CSCStatusDlg)
	afx_msg LONG OnSCardStatusDlgExit( UINT , LONG ); 
	afx_msg LONG OnCertPropThrdExit( UINT , LONG ); 
    afx_msg LONG OnSCardNotify( UINT , LONG );	// task bar notification
    afx_msg LONG OnResMgrExit( UINT , LONG );
	afx_msg LONG OnResMgrStatus( UINT ui, LONG l); // ui is the WPARAM
	afx_msg LONG OnNewReader( UINT , LONG );
	afx_msg LONG OnNewReaderExit( UINT , LONG );
	afx_msg LONG OnCardStatus( UINT uStatus, LONG );
	afx_msg LONG OnCardStatusExit( UINT , LONG );
	afx_msg LONG OnRemovalOptionsChange ( UINT, LONG );
	afx_msg LONG OnRemovalOptionsExit ( UINT, LONG );
	afx_msg void OnContextClose();
	afx_msg void OnContextStatus();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void CheckSystemStatus(BOOL fForceUpdate=FALSE);
	void SetSystemStatus(BOOL fCalaisUp, BOOL fForceUpdate=FALSE, DWORD dwState=k_State_Unknown);

	// members
protected: 
	CMenu			m_ContextMenu;		// Context/pop-up menu pointer

	// state management 
	BOOL			m_fCalaisUp;		// TRUE if Smart card stack is running
	DWORD			m_dwCardState;		// one of four: see cmnstat.h
	BOOL			m_fShutDown;		// for state checkin
	CStringArray	m_aIdleList;
	CCriticalSection	m_ThreadLock;

	// child threads to do the dirty work
	CSCStatusDlgThrd*	m_lpStatusDlgThrd;	// Pointer to the status dlg thread
	CResMgrStatusThrd*	m_lpResMgrStsThrd;	// Pointer to IsResMgrBackUpYet? thread
	CNewReaderThrd*		m_lpNewReaderThrd;	// Pointer to AreThereNewReaders? thread
	CCardStatusThrd*	m_lpCardStatusThrd;	// Pointer to the status dlg thread
	CRemovalOptionsThrd*	m_lpRemOptThrd;	// Pointer to the RemovalOptions change thread

	// kill-thread events
	HANDLE			m_hKillNewReaderThrd;
	HANDLE			m_hKillResMgrStatusThrd;
	HANDLE			m_hKillRemOptThrd;

public:
	CString		m_sClassName;				// The Window class name for this window
};


/////////////////////////////////////////////////////////////////////////////////////////

#endif // __NOTFYWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\scalert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scalert.h
//
//--------------------------------------------------------------------------

// SCStatus.h : main header file for the SCSTATUS application
//

#if !defined(AFX_SCSTATUS_H__2F127492_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_SCSTATUS_H__2F127492_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include <winscard.h>
#include "resource.h"		// main symbols
#include "cmnstat.h"		// Common headers/defines,etc.
#include "notfywin.h"

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp:
// See SCStatus.cpp for the implementation of this class
//

class CSCStatusApp : public CWinApp
{
public:

	// Construction
	CSCStatusApp();

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSCStatusApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

	// Implementation
	//{{AFX_MSG(CSCStatusApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Members
public:
	void SetRemovalOptions(void);

private:

	void SetAlertOptions(bool fRead = true);
	SCARDCONTEXT	m_hSCardContext;	// Context with smartcard resource manager

public:

	HICON	m_hIconCard;
	HICON	m_hIconRdrEmpty;
	HICON	m_hIconCardInfo;
	HICON	m_hIconCalaisDown;			// Icons for Calais system state

	DWORD	m_dwState;
	DWORD	m_dwAlertOption;

	CString	m_strLogonReader;		// strings for handling ScRemovalOptions
	CString	m_strRemovalText;		// removal -> log off, removal -> lock wks.
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCSTATUS_H__2F127492_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\scalert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scalert.cpp
//
//--------------------------------------------------------------------------

// SCAlert.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "SCAlert.h"
#include "miscdef.h"
#include "cmnstat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


LPTSTR szAlertOptionsValue = TEXT("AlertOptions");
LPTSTR szScRemoveOptionsValue = TEXT("ScRemoveOption");
LPTSTR szScLogonReaderValue = TEXT("ScLogonReader");

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp

BEGIN_MESSAGE_MAP(CSCStatusApp, CWinApp)
    //{{AFX_MSG_MAP(CSCStatusApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// The one and only CSCStatusApp object

CSCStatusApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp construction

CSCStatusApp::CSCStatusApp()
{
	m_strLogonReader.Empty();
	m_strRemovalText.Empty();
}

/////////////////////////////////////////////////////////////////////////////
// CSCStatusApp initialization

BOOL CSCStatusApp::InitInstance()
{
    // Locals
    BOOL fReturn = TRUE;
    DWORD dwStatus = 0;
    CNotifyWin* pNotifyWin = NULL;
    CString     sWindowName;

    try
    {
        // set params
        m_hSCardContext = NULL;
        m_pMainWnd = NULL;
        m_dwState = k_State_Unknown;

        SetAlertOptions();
		SetRemovalOptions();	

        // Enable ActiveX control usage
        AfxEnableControlContainer();

        // Enable 3D Contols
        #ifdef _AFXDLL
            Enable3dControls();         // Call this when using MFC in a shared DLL
        #else
            Enable3dControlsStatic();   // Call this when linking to MFC statically
        #endif

        // Load the icons
        m_hIconCard = LoadIcon(MAKEINTRESOURCE(IDI_SC_READERLOADED_V2));
        m_hIconCalaisDown = LoadIcon(MAKEINTRESOURCE(IDI_SC_READERERR));
        m_hIconRdrEmpty = LoadIcon(MAKEINTRESOURCE(IDI_SC_READEREMPTY_V2));
        m_hIconCardInfo = LoadIcon(MAKEINTRESOURCE(IDI_SC_INFO));

        // Create the "main" window for this app
        m_pMainWnd = (CWnd*)new(CNotifyWin);
        if (m_pMainWnd == NULL)
            throw (FALSE);

        // Get pointer to CNotifyWin class
        pNotifyWin = (CNotifyWin*)m_pMainWnd;

        if (!pNotifyWin->FinalConstruct())
        {
            delete pNotifyWin;
            m_pMainWnd = NULL;
            throw (FALSE);
        }

        // Get the window name
        fReturn = sWindowName.LoadString(IDS_NOTIFY_WIN_NAME);
        if (!fReturn)
            throw (fReturn);

        // Create the window
        fReturn = m_pMainWnd->CreateEx( 0,
                                        pNotifyWin->m_sClassName,
                                        sWindowName,
                                        0,
                                        0,0,0,0,
                                        NULL,
                                        NULL,
                                        NULL);
        if (!fReturn)
            throw (fReturn);

    }
    catch (...) {
        fReturn = FALSE;
        TRACE_CATCH_UNKNOWN(_T("CSCStatusApp::InitInstance"));
    }

    return fReturn;
}


/*++

void SetAlertOptions:

    Set User's alert options according to regkey settings (or default)

Arguments:
Return Value:

    None.

Author:

    Amanda Matlosz  5/13/99

--*/
void CSCStatusApp::SetAlertOptions(bool fRead)
{
    long lSts = ERROR_SUCCESS;
    HKEY hKey = NULL;

    // Either read the AlertOptions from the registry...
    if (fRead)
    {
        DWORD dwOption = -1;
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = 0;

        lSts = RegOpenKeyEx(
                    HKEY_CURRENT_USER,
                    szAlertOptionsKey,
                    0,
                    KEY_READ,
                    &hKey);

        if (ERROR_SUCCESS == lSts)
        {

            lSts = RegQueryValueEx(
                        hKey,
                        szAlertOptionsValue,
                        0,
                        &dwType,
                        (PBYTE)&dwOption,
                        &dwSize
                        );
        }

        if (k_AlertOption_IconMsg < dwOption)
        {
            // default value is "IconSoundMessage"
            m_dwAlertOption = k_AlertOption_IconSoundMsg;
        }
        else
        {
            m_dwAlertOption = dwOption;
        }

    }
    // Or set the value of the registry "AlertOptions"
    else
    {
        DWORD dw = 0; // don't really care about this param

        lSts = RegCreateKeyEx(
                    HKEY_CURRENT_USER,
                    szAlertOptionsKey,
                    0,
                    TEXT(""),
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dw);

        if (ERROR_SUCCESS == lSts)
        {
            RegSetValueEx(
                hKey,
                szAlertOptionsValue,
                0,
                REG_DWORD,
                (PBYTE)&m_dwAlertOption,
                sizeof(DWORD)
                );
        }

    }

    // cleanup
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
}


/*++

void SetRemovalOptions:

    Determine if user has set ScremoveOption for smart card logon, and
	set behavior for ScAlert accordingly.
		
Arguments:
Return Value:

	None.
		
Author:

	Amanda Matlosz	6/02/99

--*/
void CSCStatusApp::SetRemovalOptions()
{
	long lSts = ERROR_SUCCESS;
	HKEY hKey = NULL;
	DWORD dwType = 0;
	DWORD dwSize = 2*sizeof(TCHAR);

	TCHAR szRemoveOption[2];
    lSts = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szScRemoveOptionKey,
                0,
                KEY_READ,
                &hKey);

	if (ERROR_SUCCESS == lSts)
	{
		// this value must be either '0', '1', '2', or nonexistent.
		lSts = RegQueryValueEx(
					hKey,
					szScRemoveOptionsValue,
					0,
					&dwType,
					(PBYTE)szRemoveOption,
					&dwSize
					);
	}

	if (ERROR_SUCCESS == lSts)
	{
		// if '1' or '2' find out what reader was used for logon, if any.
		if('1' == *szRemoveOption)
		{
			m_strRemovalText.LoadString(IDS_SC_REMOVAL_LOCK);
		}
		else if ('2' == *szRemoveOption)
		{
			m_strRemovalText.LoadString(IDS_SC_REMOVAL_LOGOFF);
		}
	}

	if (!m_strRemovalText.IsEmpty())
	{
		dwSize = 0;
		LPTSTR szLogonReader = NULL;

		lSts = RegQueryValueEx(
					hKey,
					szScLogonReaderValue,
					0,
					&dwType,
					NULL,
					&dwSize
					);

		if (ERROR_SUCCESS == lSts)
		{
			szLogonReader = m_strLogonReader.GetBuffer(dwSize);

			lSts = RegQueryValueEx(
						hKey,
						szScLogonReaderValue,
						0,
						&dwType,
						(PBYTE)szLogonReader,
						&dwSize
						);
			
			m_strLogonReader.ReleaseBuffer();
		}
	}

	// cleanup
	if (NULL != hKey)
	{
		RegCloseKey(hKey);
	}
}



/*++

void ExitInstance:

    Does instance uninitialization

Arguments:

    None.

Return Value:

    Win32 error codes. 0 indicates no error occured.

Author:

    Chris Dudley 7/30/1997

Note:

--*/

int CSCStatusApp::ExitInstance()
{
    // save the alert options
    SetAlertOptions(false);

    // Release calais if required
    if (m_hSCardContext != NULL)
    {
        SCardReleaseContext(m_hSCardContext);
    }

    // Make sure the window is deleted
    if (m_pMainWnd != NULL)
    {
        delete m_pMainWnd;
    }

    return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

// Include multi-thread classes
#include <afxmt.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#include <atlconv.h>		// ATL Conversion macros

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\chngpdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       chngpdlg.cpp
//
//--------------------------------------------------------------------------

// chngpdlg.cpp : implementation file
//

#include "stdafx.h"
#include "scuidlg.h"
#include "scdlg.h"
#include "chngpdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg dialog


CChangePinDlg::CChangePinDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CChangePinDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CChangePinDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CChangePinDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChangePinDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChangePinDlg, CDialog)
	//{{AFX_MSG_MAP(CChangePinDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg message handlers
/////////////////////////////////////////////////////////////////////////////
// CGetPinDlg dialog


CGetPinDlg::CGetPinDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGetPinDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGetPinDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CGetPinDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetPinDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetPinDlg, CDialog)
	//{{AFX_MSG_MAP(CGetPinDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetPinDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCStatus.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\statdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statdlg.cpp
//
//--------------------------------------------------------------------------

// StatDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ScAlert.h"
#include "miscdef.h"
#include "statmon.h"
#include "StatDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {                    // Assume C declarations for C++
#endif  // __cplusplus

#ifdef __cplusplus
}
#endif  /* __cplusplus */


/////////////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlgThrd
//

IMPLEMENT_DYNCREATE(CSCStatusDlgThrd, CWinThread)

/*++

InitInstance

    Must override init instance to perform UI thread initialization
		
Arguments:

		
Return Value:
	
	TRUE on build start message loop. FALSE otherwise

	
Author:

    Chris Dudley 2/27/1997

--*/
BOOL CSCStatusDlgThrd::InitInstance( void )
{
	INT_PTR nResult = -1; // error creating dialog
	LONG lReturn = SCARD_S_SUCCESS;
	SCARDCONTEXT hSCardContext = NULL;

	// Acquire context with resource manager
	lReturn = SCardEstablishContext(	SCARD_SCOPE_USER,
										NULL,
										NULL,
										&hSCardContext);
	if (lReturn != SCARD_S_SUCCESS)
	{
		nResult = IDCANCEL;
	}
	else
	{
		m_StatusDlg.SetContext(hSCardContext);

		// Run the dialog as Modal

		m_fStatusDlgUp = TRUE;

		nResult = m_StatusDlg.DoModal();// if the dialog is shut down by a
										// cancellation of the SCARDCONTEXT,
										// it will return IDCANCEL
		m_fStatusDlgUp = FALSE;
	}

	// Release context
	if (NULL != hSCardContext)
	{
		SCardReleaseContext(hSCardContext);
	}

	// Post message that the thread is exiting, based on return...
	if (NULL != m_hCallbackWnd)
	{
		::PostMessage(	m_hCallbackWnd,
						WM_SCARD_STATUS_DLG_EXITED, // CANCELLATION (0), or ERROR (1)
						0, 0);
	}

	AfxEndThread(0);
	return TRUE;	// to make compiler happy
}


/*++

void ShowDialog:

	Brings dialog to front if already open

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::ShowDialog( int nCmdShow, CStringArray* paIdleList )
{
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.ShowWindow(nCmdShow);
		m_StatusDlg.SetIdleList(paIdleList);
	}
}


/*++

void UpdateStatus:

	If the dialog is up, updates idle list and status text

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::UpdateStatus( CStringArray* paIdleList )
{
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.UpdateLogonLockInfo();
		m_StatusDlg.SetIdleList(paIdleList);
		m_StatusDlg.UpdateStatusText();
	}
}


/*++

void UpdateStatusText:

	If the dialog is up, updates Status Text and 

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::UpdateStatusText( void )
{
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.UpdateStatusText();
	}
}


/*++

void Close:

	Closes modal dialog if already open

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::Close( void )
{
	// Setup for close
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.EndDialog(IDOK);
	}
	m_fStatusDlgUp = FALSE;
}


/*++

void Update:

	This routine updates the UI.

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlgThrd::Update( void )
{
	// Tell the dialog to update its statmonitor, if it's up.
	if (m_fStatusDlgUp)
	{
		m_StatusDlg.RestartMonitor();
	}

	// Do other updating
	UpdateStatusText();
}


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg dialog
//

CSCStatusDlg::CSCStatusDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSCStatusDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSCStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDI_SC_READERLOADED_V2);

	// Other initialization
	m_fEventsGood = FALSE;
	m_hSCardContext = NULL;
	m_aIdleList.RemoveAll();

	UpdateLogonLockInfo();
}

void CSCStatusDlg::UpdateLogonLockInfo(void)
{
	m_pstrLogonReader = &(((CSCStatusApp*)AfxGetApp())->m_strLogonReader);
	m_pstrRemovalText = &(((CSCStatusApp*)AfxGetApp())->m_strRemovalText);
	m_fLogonLock = (!(m_pstrLogonReader->IsEmpty()));
}

void CSCStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSCStatusDlg)
	DDX_Control(pDX, IDC_SCARD_LIST, m_SCardList);
	DDX_Control(pDX, IDC_ALERT, m_btnAlert);
	DDX_Control(pDX, IDC_INFO, m_ediInfo);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSCStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CSCStatusDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_CLOSE()
	ON_MESSAGE( WM_READERSTATUSCHANGE, OnReaderStatusChange )
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_ALERT, OnAlertOptions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg Implementation


/*++

BOOL SetContext:

	Sets the Context with the resource manager
	
Arguments:

	SCardContext - the context
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/6/1997

Revision History:

	Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::SetContext(SCARDCONTEXT hSCardContext)
{
	m_hSCardContext = hSCardContext;
}


/*++

void CleanUp:

	Routine cleans up for exit
	
Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/11/1997

Revision History:

	Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::CleanUp ( void )
{
	m_monitor.Stop();

	m_SCardList.DeleteAllItems();
}



/*++

void SetIdleList:

    Make a local copy of the app's list of readers with idle cards.

Notes:
--*/
void CSCStatusDlg::SetIdleList(CStringArray* paIdleList)
{
	m_aIdleList.Copy(*paIdleList);
	long lResult = UpdateSCardListCtrl();
}


/*++

void UpdateStatusText:

    Reflect card usage status in text.  (alert message, howto, etc.)

Notes:
	Not localization friendly.  Move strings to resources.
--*/
void CSCStatusDlg::UpdateStatusText( void )
{
	CString str;
	if (k_State_CardIdle == ((CSCStatusApp*)AfxGetApp())->m_dwState)
	{
		str = _T("A smart card has been left idle.  You may safely remove it now.");
	}
	else
	{
		str = _T("Click the button on the left to change your alert options.");
	}
	m_ediInfo.SetWindowText(str);
}


/*++

void InitSCardListCtrl:

    This routine sets up the CListCtrl properly for display
		
Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 3/6/1997

Revision History:

	Chris Dudley 5/13/1997

--*/
void CSCStatusDlg::InitSCardListCtrl( void )
{
	CString strHeader;
	CImageList imageList;
	HICON hicon;

	// Create columns in list control
	strHeader.LoadString(IDS_SC_READER);
	m_SCardList.InsertColumn(READER_COLUMN,
							strHeader,
							LVCFMT_LEFT,
							100,
							-1);

	strHeader.LoadString(IDS_SC_CARDSTATUS);
	m_SCardList.InsertColumn(STATUS_COLUMN,
							strHeader,
							LVCFMT_LEFT,
							600,
							-1);

	strHeader.LoadString(IDS_SC_CARD);
	m_SCardList.InsertColumn(CARD_COLUMN,
							strHeader,
							LVCFMT_LEFT,
							100,
							-1);

	// Create the image list & give it to the list control
	imageList.Create (	IMAGE_WIDTH,
						IMAGE_HEIGHT,
						TRUE,				// list does not include masks
						NUMBER_IMAGES,
						0);					// list won't grow

	// Build the list
	for (int ix = 0; ix < NUMBER_IMAGES; ix++ )
	{
		// Load icon and add it to image list
		hicon = ::LoadIcon(AfxGetInstanceHandle(),
							MAKEINTRESOURCE(IMAGE_LIST_IDS[ix]) );
		imageList.Add(hicon);
	}

	// Be sure that all the small icons were added.
	_ASSERTE(imageList.GetImageCount() == NUMBER_IMAGES);

	m_SCardList.SetImageList(&imageList, (int) LVSIL_SMALL);

	imageList.Detach();	// leave the images intact when we go out of scope
}


/*++

LONG UpdateSCardListCtrl:

    This routine updates the list box display.
		
Arguments:

	None.
		
Return Value:
	
    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.

Author:

    Chris Dudley 3/7/1997

Revision History:

	Chris Dudley 5/13/1997

Notes:
	
	1. Strings need to be converted from type stored in the smartcard
	thread help classes to this dialog's build type (i.e. UNICODE/ANSI)!!!!

--*/
LONG CSCStatusDlg::UpdateSCardListCtrl( void )
{
	LONG lReturn = SCARD_S_SUCCESS;
	LONG lMoreReaders = SCARD_S_SUCCESS;
	CSCardReaderState* pReader;
	int nImage = 0;
	LV_ITEM	lv_item;
	CString strCardStatus, strCardName;

	//
	// If the status monitor is not running,
	// Don't bother to update SCardListCtrl
	// If there used to be readers, display an error and shut down dialog
	//

	if (CScStatusMonitor::running != m_monitor.GetStatus())
	{
		m_SCardList.EnableWindow(FALSE);

		DoErrorMessage();
		return lReturn;
	}

	// Setup LV_ITEM struct
	lv_item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;

	// Remove old items from list if required
	m_SCardList.DeleteAllItems();

	//
	// Update the reader information
	//

	m_monitor.GetReaderStatus(m_aReaderState);

	//
	// Recreate the items in the reader list (UI)
	//

	int nNumReaders = (int)m_aReaderState.GetSize();
	for(int nIndex = 0; nIndex < nNumReaders; nIndex++)
	{
		// Setup struct for system reader list
		pReader = m_aReaderState[nIndex];

		lv_item.state = 0;
		lv_item.stateMask = 0;
		lv_item.iItem = nIndex;
		lv_item.iSubItem = 0;
		lv_item.pszText = _T("");
		lv_item.cchTextMax = MAX_ITEMLEN;
		lv_item.iImage = (int)READEREMPTY;

		if (NULL != pReader)
		{
			lv_item.pszText = (LPTSTR)(LPCTSTR)((m_aReaderState[nIndex])->strReader);

			// Get the card status: image
			DWORD dwState = (m_aReaderState[nIndex])->dwState;
			if (dwState == SC_STATUS_NO_CARD)
			{
				lv_item.iImage = (int)READEREMPTY;
			}
			else if (dwState == SC_STATUS_ERROR)
			{
				lv_item.iImage = (int)READERERROR;
			}
			else
			{
				// normally, this would be a "card loaded"...
				lv_item.iImage = (int)READERLOADED;

				// ...unless the card is the logon/locked card or idle
				if (m_fLogonLock && 
					(0 == m_pstrLogonReader->Compare((m_aReaderState[nIndex])->strReader)))
				{
					lv_item.iImage = (int)READERLOCK;
				}
				else
				{
					for (int n1=(int)m_aIdleList.GetUpperBound(); n1>=0; n1--)
					{
						if (m_aIdleList[n1] == (m_aReaderState[nIndex])->strReader)
						{
							lv_item.iImage = (int)READERINFO;
							break;
						}
					}
				}
			}

			// Add Reader Item
			m_SCardList.InsertItem(&lv_item);

			// Add Card Name sub item
			if (dwState != SC_STATUS_NO_CARD && dwState != SC_STATUS_ERROR)
			{
				// Set card name if not available
				strCardName = (LPCTSTR)(m_aReaderState[nIndex])->strCard;
				if (strCardName.IsEmpty())
				{
					strCardName.LoadString(IDS_SC_NAME_UNKNOWN);
				}
				m_SCardList.SetItemText(nIndex,
										CARD_COLUMN,
										strCardName);
			}

			// Add Card Status sub item
			ASSERT(dwState >= SC_STATUS_FIRST && dwState <= SC_STATUS_LAST);
			strCardStatus.LoadString(CARD_STATUS_IDS[dwState]);

			if (m_fLogonLock && 
				(0 == m_pstrLogonReader->Compare((m_aReaderState[nIndex])->strReader)))
			{
				CString strTemp = *m_pstrRemovalText + strCardStatus;
				strCardStatus = strTemp;
			}

			m_SCardList.SetItemText(nIndex,
									STATUS_COLUMN,
									strCardStatus);

			strCardStatus.Empty();
			strCardName.Empty();
		}		

	}

	// If we got this far, things are OK.  Make sure the window is enabled.
	m_SCardList.EnableWindow(TRUE);

	return lReturn;
}


/*++

void RestartMonitor:

    This routine forces the monitor to refresh its list of readers.
		
Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Amanda Matlosz 11/04/1998

Notes:
	

--*/
void CSCStatusDlg::RestartMonitor( void )
{
	m_monitor.Start(m_hWnd, WM_READERSTATUSCHANGE);
}


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg message handlers
//


/*++

void OnInitDialog:

	Performs dialog initialization.

Arguments:

	None.
		
Return Value:
	
	TRUE if successful and dialog should be displayed. FALSE otherwise.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
BOOL CSCStatusDlg::OnInitDialog()
{
	LONG lReturn = SCARD_S_SUCCESS;

	CDialog::OnInitDialog();

	//
	// Initialize the CScStatusMonitor
	//

	m_monitor.Start(m_hWnd, WM_READERSTATUSCHANGE);

	//
	// Initialize the list control -- whether or not the monitor has started!
	//

	InitSCardListCtrl();

	lReturn = UpdateSCardListCtrl();

	//
	// Show the dialog IFF the above succeeded
	//

	if (SCARD_S_SUCCESS == lReturn)
	{
		// Set the status text
		UpdateStatusText();

		// Set the icon for this dialog.  The framework does this automatically
		//  when the application's main window is not a dialog

		SetIcon(m_hIcon, TRUE);			// Set big icon
		SetIcon(m_hIcon, FALSE);		// Set small icon
		
		// set icon for Alerts button
		HICON hIcon = AfxGetApp()->LoadIcon(IDI_SC_INFO);
		SendDlgItemMessage(IDC_ALERT, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

		// Center the dialog and bring it to top
		CenterWindow();
		SetWindowPos(	&wndTop,
						0,0,0,0,
						SWP_NOMOVE | SWP_NOSIZE);
		SetActiveWindow();

		// Set Parent to desktop
		SetParent(NULL);
	}
	else
	{
		//
		// If any of the initialization depending on the resource manager failed,
		// give up and report a death-due-to-some-error to the caller
		//

		PostMessage(WM_CLOSE, 0, 0);  // need to CANCEL, instead of close...
		TRACE_CATCH_UNKNOWN(_T("OnInitDialog"));
	}

	return TRUE;  // return TRUE  unless you set the focus to a control
}


/*++

void OnPaint:

	Used to paint dialog. In this case, used to draw the icon for the dialog
	while minimized/maximized.

Arguments:

	None.
		
Return Value:
	
	None.

Author:

    Chris Dudley 7/30/1997

Note:

--*/
void CSCStatusDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}


/*++

void OnQueryDragIcon:

	The system calls this to obtain the cursor to display while the user drags
	the minimized window.		

Arguments:

	None.
		
Return Value:
	
	HCURSOR handle to cursor to display

Author:

    Chris Dudley 7/30/1997

Note:

--*/
HCURSOR CSCStatusDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


/*++

void DestroyWindow:

	This is called by MFC whenever the dialog is closed, whether that is
	through WM_CLOSE (sysmenu "X") or EndDialog(IDOK/IDCANCEL)...

Arguments:

	None.
		
Return Value:
	
	Base class version of DestroyWindow.

Author:

	Amanda Matlosz 4/29/98

Note:

--*/
BOOL CSCStatusDlg::DestroyWindow()
{
	CleanUp();

	return CDialog::DestroyWindow();
}


/*++

void OnReaderStatusChange:

    This message handler is called by the status thread when smartcard status
	has changed.
		
Arguments:

	None.
		
Return Value:
	
	None

Author:

    Chris Dudley 3/9/1997

Revision History:

	Chris Dudley 5/13/1997

Note:

	1. No formal parameters are declared. These are not used and
	will stop compiler warnings from being generated.

--*/
LONG CSCStatusDlg::OnReaderStatusChange( UINT , LONG )
{

	// Update the display
	UpdateSCardListCtrl();

	return 0;
}



/*++
allow user to set alert options (sound, pop-up, neither)
--*/
void CSCStatusDlg::OnAlertOptions()
{
	COptionsDlg dlg;
	dlg.DoModal();
}
/*++

void DoErrorMessage:

    This is a helper routine to keep the UI stuff in one place and make sure
	the same error messages are handled consistently throughout.
		
Arguments:

	None.
		
Return Value:
	
	None

Author:

	Amanda Matlosz	5/21/98

Revision History:


Note:

	1. Consider taking an error code as well as m_monitor.GetStatus()

--*/
void CSCStatusDlg::DoErrorMessage( void )
{
	CString strMsg;
	BOOL fShutDownDlg = FALSE;

	switch(m_monitor.GetStatus())
	{
	case CScStatusMonitor::no_service:
		fShutDownDlg = TRUE;
		strMsg.LoadString(IDS_NO_SYSTEM_STATUS);
		break;

	case CScStatusMonitor::no_readers:
		// for now, do nothing!
		break;

	case CScStatusMonitor::stopped:
		// do nothing!  This is a clean stop on the way to shutting down.
		break;

	case CScStatusMonitor::uninitialized:
	case CScStatusMonitor::unknown:
	case CScStatusMonitor::running:
		fShutDownDlg = TRUE;
		strMsg.LoadString(IDS_UNKNOWN_ERROR);	
	}

	if (!strMsg.IsEmpty())
	{
		CString strTitle;
		strTitle.LoadString(IDS_TITLE_ERROR);
		MessageBox(strMsg, strTitle, MB_OK | MB_ICONINFORMATION);
	}

	if (fShutDownDlg)
	{
		PostMessage(WM_CLOSE, 0, 0);
	}
}

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog


COptionsDlg::COptionsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(COptionsDlg::IDD, pParent)
{
	BOOL fSound = FALSE;
	BOOL fDlg = FALSE;

	switch(((CSCStatusApp*)AfxGetApp())->m_dwAlertOption)
	{
		case k_AlertOption_IconSound:
			fSound = TRUE;
			break;
		case k_AlertOption_IconSoundMsg:
			fSound = TRUE;
		case k_AlertOption_IconMsg:
			fDlg = TRUE;
			break;
	}

	//{{AFX_DATA_INIT(COptionsDlg)
	m_fDlg = fDlg;
	m_fSound = fSound;
	//}}AFX_DATA_INIT
}


void COptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COptionsDlg)
	DDX_Check(pDX, IDC_DIALOG, m_fDlg);
	DDX_Check(pDX, IDC_SOUND, m_fSound);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COptionsDlg, CDialog)
	//{{AFX_MSG_MAP(COptionsDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg message handlers

void COptionsDlg::OnOK() 
{
	// use status of check boxes to set alert options state for app
	UpdateData(TRUE);

	if (TRUE == m_fSound)
	{
		if (TRUE == m_fDlg)
		{
			((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconSoundMsg;
		}
		else
		{
			((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconSound;
		}
	}
	else if (TRUE == m_fDlg)
	{
		((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconMsg;
	}
	else
	{
		((CSCStatusApp*)AfxGetApp())->m_dwAlertOption = k_AlertOption_IconOnly;
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scalert\statdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       statdlg.h
//
//--------------------------------------------------------------------------

// StatDlg.h : header file
//

#if !defined(AFX_STATDLG_H__2F127494_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STATDLG_H__2F127494_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "cmnstat.h"
#include "statmon.h"

/////////////////////////////////////////////////////////////////////////////
//
// Constants for dialog
//

// Columns in list view
#define     READER_COLUMN       0           
#define     CARD_COLUMN         1
#define     STATUS_COLUMN       2
#define     MAX_ITEMLEN         255

// Image list properties
#define     IMAGE_WIDTH         16
#define     IMAGE_HEIGHT        16
#define     NUMBER_IMAGES       5
const UINT  IMAGE_LIST_IDS[] = {IDI_SC_READERLOADED_V2,
                                IDI_SC_READEREMPTY_V2,
                                IDI_SC_READERERR,
								IDI_SC_INFO,
								IDI_SC_LOGONLOCK };
// Image list indicies
#define     READERLOADED        0
#define     READEREMPTY         1
#define     READERERROR         2
#define		READERINFO			3
#define		READERLOCK			4

// Card status string IDs
const UINT CARD_STATUS_IDS[] = {IDS_SC_STATUS_NO_CARD,
								IDS_SC_STATUS_UNKNOWN,
								IDS_SC_STATUS_AVAILABLE,
                                IDS_SC_STATUS_SHARED,
                                IDS_SC_STATUS_IN_USE,
								IDS_SC_STATUS_ERROR};
#define MAX_INDEX               255


/////////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlg dialog
//

class CSCStatusDlg : public CDialog
{
	// members
private:
	BOOL				m_fEventsGood;		// is the thread alive?
	SCARDCONTEXT		m_hSCardContext;	// Context with smartcard resource manager

	CScStatusMonitor	m_monitor;			// see statmon.h
	CSCardReaderStateArray	m_aReaderState; //  ""
	CStringArray		m_aIdleList;
	CString*			m_pstrLogonReader;	// from scalert.h
	CString*			m_pstrRemovalText;	//	""
	BOOL				m_fLogonLock;

	// Construction
public:
	CSCStatusDlg(CWnd* pParent = NULL);	// standard constructor

	// Dialog Data
	//{{AFX_DATA(CSCStatusDlg)
	enum { IDD = IDD_SCSTATUS_DIALOG };
	CListCtrl	m_SCardList;
	CButton		m_btnAlert;
	CEdit		m_ediInfo;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSCStatusDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

	// Implementation
private:

    // UI routines
    void CleanUp( void );

	void DoErrorMessage( void ); // TODO: maybe take an error code?

    // Smartcard related routines
    void InitSCardListCtrl( void );
    LONG UpdateSCardListCtrl( void );

public:
	void SetContext(SCARDCONTEXT hSCardContext);
	void RestartMonitor( void );
	void UpdateStatusText( void );
	void SetIdleList(CStringArray* paIdleList);
	void UpdateLogonLockInfo( void );

protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CSCStatusDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
    afx_msg LONG OnReaderStatusChange( UINT , LONG );
	afx_msg void OnAlertOptions();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////
//
// CSCStatusDlgThrd
//

class CSCStatusDlgThrd: public CWinThread
{
	// Declare class dynamically creatable
	DECLARE_DYNCREATE(CSCStatusDlgThrd)

public:
	// Construction / Destruction
	CSCStatusDlgThrd()
	{
		m_bAutoDelete = FALSE;
		m_hCallbackWnd = NULL;
		m_fStatusDlgUp = FALSE;
	}

	~CSCStatusDlgThrd() {}


	// Implementation
	void Close( void );
	virtual BOOL InitInstance();
	void ShowDialog( int nCmdShow, CStringArray* paIdleList );
	void Update( void );
	void UpdateStatus( CStringArray* paIdleList );
	void UpdateStatusText( void );

	// members

private:
	CSCStatusDlg	m_StatusDlg;
	BOOL			m_fStatusDlgUp;

public:
	HWND			m_hCallbackWnd;


};


/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog

class COptionsDlg : public CDialog
{
// Construction
public:
	COptionsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(COptionsDlg)
	enum { IDD = IDD_OPTIONSDLG };
	BOOL	m_fDlg;
	BOOL	m_fSound;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(COptionsDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STATDLG_H__2F127494_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\miscdef.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MiscDef.h

Abstract:

	This file contains miscellanious definitions, including the debug trace macros
	written by Chris Dudley

Author:

    Amanda Matlosz 12/15/97

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

  intended only for use in the scarddlg project

--*/

#ifndef __MISC_H__
#define __MISC_H__

#ifdef _DEBUG
	#define TRACE_STR(name,sz) \
				TRACE(_T("SCardDlg.DLL: %s: %s\n"), name, sz)
	#define TRACE_CODE(name,code) \
				TRACE(_T("SCardDlg.DLL: %s: error = 0x%x\n"), name, code)
	#define TRACE_CATCH(name,code)		TRACE_CODE(name,code)
	#define TRACE_CATCH_UNKNOWN(name)	TRACE_STR(name,_T("An unidentified exception has occurred!"))
#else
	#define TRACE_STR(name,sz)			((void)0)
	#define TRACE_CODE(name,code)		((void)0)
	#define TRACE_CATCH(name,code)		((void)0)
	#define TRACE_CATCH_UNKNOWN(name)	((void)0)
#endif  // _DEBUG

#endif // __MISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\chngpdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       chngpdlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_CHANGEPINDLG_H__0CB030DC_0631_11D2_BEDB_0000F87A49E0__INCLUDED_)
#define AFX_CHANGEPINDLG_H__0CB030DC_0631_11D2_BEDB_0000F87A49E0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// chngpdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg dialog

class CChangePinDlg : public CDialog
{
// Construction
public:
	CChangePinDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CChangePinDlg)
	enum { IDD = IDD_CHANGE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

public:
	bool SetAttributes(LPCHANGEPIN pPinPrompt) { return false; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangePinDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CChangePinDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CGetPinDlg dialog

class CGetPinDlg : public CDialog
{
// Construction
public:
	CGetPinDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGetPinDlg)
	enum { IDD = IDD_ENTER };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

public:
	bool SetAttributes(LPPINPROMPT pPinPrompt) { return false; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetPinDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation

protected:

	// Generated message map functions
	//{{AFX_MSG(CGetPinDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHANGEPINDLG_H__0CB030DC_0631_11D2_BEDB_0000F87A49E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scarddlg.rc
//
#define IDS_SC_UNKNOWN_NO               1
#define IDS_SC_KNOWN_INCORRECT          2
#define IDS_SC_DEAD                     3
#define IDS_SC_BUSY                     4
#define IDS_SC_STATUS_NOT_IN_USE        6
#define IDS_SC_NAME_UNKNOWN             7
#define IDHELP                          9
#define IDS_SC_CONNECT_FAILED           10
#define IDS_SC_SELECT                   11
#define IDS_SC_TITLE_ERROR              12
#define IDS_SC_FOUND                    13
#define IDS_SC_FOUND_BUSY               14
#define IDS_SC_READER                   15
#define IDS_SC_CARDSTATUS               16
#define IDS_SC_CARD                     17
#define IDS_SC_NOMATCH                  18
#define IDS_DETAILS_SHOW                21
#define IDS_DETAILS_HIDE                22
#define IDS_DETAILS_CAP                 23
#define IDS_READERS_CAP                 24
#define IDS_NAME_CAP                    25
#define IDS_STATUS_CAP                  26
#define IDS_SC_RM_ERR                   27
#define IDS_UNKNOWN_ERROR               28
#define IDS_SC_NO_READERS               29
#define IDS_SC_STATUS_NO_CARD           30
#define IDS_SC_STATUS_UNKNOWN           31
#define IDS_SC_STATUS_AVAILABLE         32
#define IDS_SC_STATUS_SHARED            33
#define IDS_SC_STATUS_IN_USE            34
#define IDS_SC_STATUS_ERROR             35
#define IDS_PROMPT_ONECARD              36
#define IDS_PROMPT_CARDS                37
#define IDS_SC_CANT_USE                 38
#define IDS_SC_PROMPT_ANYCARD           39
#define IDD_SCARDDLG_BAR                104
#define IDD_SCARDDLG1                   105
#define IDD_SCARDDLG                    129
#define IDI_SC_WRONGCARD                140
#define IDI_SC_READERERR                141
#define IDI_SC_READEREMPTY_V2           142
#define IDI_SC_READERLOADED_V2          143
#define IDI_SC_CARD                     144
#define IDI_SC_CARDUNKNOWN              145
#define IDD_ENTER                       146
#define IDD_CHANGE                      147
#define IDC_DLGBAR                      1000
#define IDC_BUTTON_BOTTOM               1001
#define IDC_READERS                     1001
#define IDC_NAME                        1003
#define IDC_STATUS                      1004
#define IDC_DETAILS                     1005
#define IDC_SCARD_LIST                  1006
#define IDC_CARDNAME                    1007
#define IDC_GROUPDROPLIST               1008
#define IDC_SEARCH_LIST                 1009
#define IDC_HELP_TEXT                   1010
#define IDC_CARD_PIC                    1013
#define IDC_PROMPT                      1014
#define IDC_USERICON                    1015
#define IDC_DETAILS_CAPTION             1016
#define IDC_READERS_CAPTION             1017
#define IDC_NAME_CAPTION                1018
#define IDC_STATUS_CAPTION              1019
#define IDC_EDIT1                       1020
#define IDC_CHECK1                      1021
#define IDC_EDIT2                       1021
#define IDC_EDIT3                       1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        148
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\schlparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       schlparr.h
//
//--------------------------------------------------------------------------

#ifndef _SC_HELP_ARR_
#define _SC_HELP_ARR_

#define	IDH_DLG1_DETAILS_BTN	70009050
#define	IDH_SCBAR_NAME	70009076
#define	IDH_SCBAR_READERS	70009075
#define	IDH_SCBAR_STATUS	70009077


const DWORD g_aHelpIDs_IDD_SCARDDLG_BAR[]=
{
	IDC_STATUS,IDH_SCBAR_STATUS,
	IDC_NAME,IDH_SCBAR_NAME,
	IDC_READERS,IDH_SCBAR_READERS,
	0,0
};

const DWORD g_aHelpIDs_IDD_SCARDDLG1[]=
{
	IDC_DETAILS,IDH_DLG1_DETAILS_BTN,
	0,0
};

#endif // _SC_HELP_ARR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scdlg.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCDlg

Abstract:

	This file defines the CSCardDlgApp class for the SmartCard
	Common Control DLL
	
Author:

    Chris Dudley 2/27/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:


Notes:

--*/

#ifndef __SCDLG_H__
#define __SCDLG_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
//
// CSCardDlgApp
//

class CSCardDlgApp : public CWinApp
{
public:
	CSCardDlgApp();

// Overrides

	BOOL InitInstance();

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSCardDlgApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CSCardDlgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

#endif //__SCDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scarddlg.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCardDlg

Abstract:

	This file contains the outline implementation of the DLL exports
	for the Smartcard Common Dialogs
	
Author:

    Chris Dudley 2/27/1997

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	Amanda Matlosz 07/09/1998	incorporated new select card,
								get pin and change pin dlgs.

Notes:

--*/


/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include "stdafx.h"
#include <atlconv.cpp>
#include "resource.h"
#include "miscdef.h"
#include "SCDlg.h"
#include "ScSearch.h"
#include "ScInsDlg.h"
#include "chngpdlg.h"

#include "ScUIDlg.h" // will someday be just <winscard.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Decls -- Helper functions defined @ eof
void MString2CommaList(CString& str, LPWSTR szmString);
void MString2CommaList(CString& str, LPSTR szmString);

/////////////////////////////////////////////////////////////////////////////
// CSCardDlgApp

BEGIN_MESSAGE_MAP(CSCardDlgApp, CWinApp)
	//{{AFX_MSG_MAP(CSCardDlgApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*++

CSCardDlgApp:

    Construction.
		
Arguments:

		
Return Value:

	
Author:

    Chris Dudley 2/27/1997

--*/
CSCardDlgApp::CSCardDlgApp()
{

}

/////////////////////////////////////////////////////////////////////////////
//
// The one CSCardDlgApp object
//

CSCardDlgApp theApp;


/*++

InitInstance:

    Override for the instance initializaion.
		
Arguments:

    None
		
Return Value:

	TRUE on success; FALSE otherwise resulting in DLL NOT be loaded.
	
Author:

    Chris Dudley 2/27/1997

--*/
BOOL CSCardDlgApp::InitInstance()
{
	BOOL fResult = FALSE;

	// Disable all DLL notifications...Force exported API entry point.
	fResult = DisableThreadLibraryCalls(m_hInstance);

	_ASSERTE(fResult); // DisableThreadLibraryCalls failed; can't init dll

	return fResult;
}

/////////////////////////////////////////////////////////////////////////////
//
// Exported APIs from the DLL
//


/*++

GetOpenCardName:

    This is the SDK v1.0 entry point routine to open the common dialog box.
	It has been retained for backwards compatibility; it is now a wrapper
	call for GetOpenCardNameEx().
		
Arguments:

    pOCNA - Pointer to an ANSI open card name structure.
	-or-
	pOCNW - Popinter to a UNICODE open card name structure
		
Return Value:

    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.
	
Author:

    Chris Dudley 2/27/1997

--*/

LONG WINAPI GetOpenCardNameA(LPOPENCARDNAMEA pOCNA)
{
	// Setup the correct module state information
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	USES_CONVERSION;

	// Locals
	LONG lReturn = SCARD_S_SUCCESS;
	OPENCARDNAMEA_EX openCardNameEx;
	OPENCARD_SEARCH_CRITERIAA openCardSearchCriteria;

	try
	{
		// Check Params
		if (NULL == pOCNA)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		if (pOCNA->dwStructSize != sizeof(OPENCARDNAMEA))
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}


		// Translate the OPENCARDNAME struct to OPENCARDNAME_EX
		ZeroMemory((PVOID)&openCardNameEx, sizeof(openCardNameEx));
		openCardNameEx.dwStructSize = sizeof(openCardNameEx);

		openCardNameEx.hwndOwner = pOCNA->hwndOwner;
		openCardNameEx.hSCardContext = pOCNA->hSCardContext;
		openCardNameEx.lpstrTitle = pOCNA->lpstrTitle;
		openCardNameEx.dwFlags = pOCNA->dwFlags;
		openCardNameEx.lpstrRdr = pOCNA->lpstrRdr;
		openCardNameEx.nMaxRdr = pOCNA->nMaxRdr;
		openCardNameEx.lpstrCard = pOCNA->lpstrCard;
		openCardNameEx.nMaxCard = pOCNA->nMaxCard;
		openCardNameEx.lpfnConnect = pOCNA->lpfnConnect;
		openCardNameEx.pvUserData = pOCNA->pvUserData;
		openCardNameEx.dwShareMode = pOCNA->dwShareMode;
		openCardNameEx.dwPreferredProtocols = pOCNA->dwPreferredProtocols;

		// Build a OPENCARD_SEARCH_CRITERIA struct
		ZeroMemory((PVOID)&openCardSearchCriteria, sizeof(openCardSearchCriteria));
		openCardSearchCriteria.dwStructSize = sizeof(openCardSearchCriteria);

		openCardSearchCriteria.lpstrGroupNames = pOCNA->lpstrGroupNames;
		openCardSearchCriteria.nMaxGroupNames = pOCNA->nMaxGroupNames;
		openCardSearchCriteria.rgguidInterfaces = pOCNA->rgguidInterfaces;
		openCardSearchCriteria.cguidInterfaces = pOCNA->cguidInterfaces;
		openCardSearchCriteria.lpstrCardNames = pOCNA->lpstrCardNames;
		openCardSearchCriteria.nMaxCardNames = pOCNA->nMaxCardNames;
		openCardSearchCriteria.lpfnCheck = pOCNA->lpfnCheck;
		openCardSearchCriteria.lpfnConnect = pOCNA->lpfnConnect;
		openCardSearchCriteria.lpfnDisconnect = pOCNA->lpfnDisconnect;
		openCardSearchCriteria.pvUserData = pOCNA->pvUserData;
		openCardSearchCriteria.dwShareMode = pOCNA->dwShareMode;
		openCardSearchCriteria.dwPreferredProtocols = pOCNA->dwPreferredProtocols;

		openCardNameEx.pOpenCardSearchCriteria = &openCardSearchCriteria;

		// Create a "search description" based on requested card names
		CString strPrompt;
		strPrompt.Empty();
		if (NULL != pOCNA->lpstrCardNames)
		{
			DWORD cNames = AnsiMStringCount(pOCNA->lpstrCardNames);

			if (1 == cNames)
			{
				strPrompt.Format(
					IDS_PROMPT_ONECARD,
					A2W(pOCNA->lpstrCardNames));
			}
			else if (1 < cNames)
			{

				CString strCommaList;
				MString2CommaList(strCommaList, pOCNA->lpstrCardNames);

				strPrompt.Format(
					IDS_PROMPT_CARDS,
					strCommaList);
			}
		}
		if (!strPrompt.IsEmpty())
		{
			openCardNameEx.lpstrSearchDesc = (LPCSTR)W2A(strPrompt);
		}

		// Call the updated routine
		lReturn = SCardUIDlgSelectCardA(&openCardNameEx);

		// Update the (const) return values of the OPENCARDNAME struct
		pOCNA->nMaxRdr = openCardNameEx.nMaxRdr;
		pOCNA->nMaxCard = openCardNameEx.nMaxCard;
		pOCNA->dwActiveProtocol = openCardNameEx.dwActiveProtocol;
		pOCNA->hCardHandle = openCardNameEx.hCardHandle;

	}
	catch (LONG hr)
	{
		lReturn = hr;
		TRACE_CATCH(_T("GetOpenCardNameA"),hr);
	}

	catch (...) {
		lReturn = (LONG) SCARD_E_UNEXPECTED;
		TRACE_CATCH_UNKNOWN(_T("GetOpenCardNameA"));
	}

	return lReturn;
}

LONG WINAPI GetOpenCardNameW(LPOPENCARDNAMEW pOCNW)
{
	// Setup the correct module state information
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Locals
	LONG lReturn = SCARD_S_SUCCESS;
	OPENCARDNAMEW_EX openCardNameEx;
	OPENCARD_SEARCH_CRITERIAW openCardSearchCriteria;

	try
	{
		// Check Params
		if (NULL == pOCNW)
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}
		if (pOCNW->dwStructSize != sizeof(OPENCARDNAMEW))
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}

		// Translate the OPENCARDNAME struct to OPENCARDNAME_EX
		ZeroMemory((PVOID)&openCardNameEx, sizeof(openCardNameEx));
		openCardNameEx.dwStructSize = sizeof(openCardNameEx);

		openCardNameEx.hwndOwner = pOCNW->hwndOwner;
		openCardNameEx.hSCardContext = pOCNW->hSCardContext;
		openCardNameEx.lpstrTitle = pOCNW->lpstrTitle;
		openCardNameEx.dwFlags = pOCNW->dwFlags;
		openCardNameEx.lpstrRdr = pOCNW->lpstrRdr;
		openCardNameEx.nMaxRdr = pOCNW->nMaxRdr;
		openCardNameEx.lpstrCard = pOCNW->lpstrCard;
		openCardNameEx.nMaxCard = pOCNW->nMaxCard;
		openCardNameEx.lpfnConnect = pOCNW->lpfnConnect;
		openCardNameEx.pvUserData = pOCNW->pvUserData;
		openCardNameEx.dwShareMode = pOCNW->dwShareMode;
		openCardNameEx.dwPreferredProtocols = pOCNW->dwPreferredProtocols;

		// Build a OPENCARD_SEARCH_CRITERIA struct
		ZeroMemory((PVOID)&openCardSearchCriteria, sizeof(openCardSearchCriteria));
		openCardSearchCriteria.dwStructSize = sizeof(openCardSearchCriteria);

		openCardSearchCriteria.lpstrGroupNames = pOCNW->lpstrGroupNames;
		openCardSearchCriteria.nMaxGroupNames = pOCNW->nMaxGroupNames;
		openCardSearchCriteria.rgguidInterfaces = pOCNW->rgguidInterfaces;
		openCardSearchCriteria.cguidInterfaces = pOCNW->cguidInterfaces;
		openCardSearchCriteria.lpstrCardNames = pOCNW->lpstrCardNames;
		openCardSearchCriteria.nMaxCardNames = pOCNW->nMaxCardNames;
		openCardSearchCriteria.lpfnCheck = pOCNW->lpfnCheck;
		openCardSearchCriteria.lpfnConnect = pOCNW->lpfnConnect;
		openCardSearchCriteria.lpfnDisconnect = pOCNW->lpfnDisconnect;
		openCardSearchCriteria.pvUserData = pOCNW->pvUserData;
		openCardSearchCriteria.dwShareMode = pOCNW->dwShareMode;
		openCardSearchCriteria.dwPreferredProtocols = pOCNW->dwPreferredProtocols;

		openCardNameEx.pOpenCardSearchCriteria = &openCardSearchCriteria;

		// Create a "search description" based on requested card names
		CString strPrompt;
		strPrompt.Empty();
		if (NULL != pOCNW->lpstrCardNames)
		{
			DWORD cNames = MStringCount(pOCNW->lpstrCardNames);

			if (1 == cNames)
			{
				strPrompt.Format(
					IDS_PROMPT_ONECARD,
					pOCNW->lpstrCardNames);
			}
			else if (1 < cNames)
			{

				CString strCommaList;
				MString2CommaList(strCommaList, pOCNW->lpstrCardNames);

				strPrompt.Format(
					IDS_PROMPT_CARDS,
					strCommaList);
			}
		}
		if (!strPrompt.IsEmpty())
		{
			openCardNameEx.lpstrSearchDesc = (LPCWSTR)strPrompt;
		}

		// Call the updated routine
		lReturn = SCardUIDlgSelectCardW(&openCardNameEx);

		// Update the (const) return values of the OPENCARDNAME struct
		pOCNW->nMaxRdr = openCardNameEx.nMaxRdr;
		pOCNW->nMaxCard = openCardNameEx.nMaxCard;
		pOCNW->dwActiveProtocol = openCardNameEx.dwActiveProtocol;
		pOCNW->hCardHandle = openCardNameEx.hCardHandle;

	}
	catch (LONG hr)
	{
		lReturn = hr;
		TRACE_CATCH(_T("GetOpenCardNameW"),hr);
	}

	catch (...) {
		lReturn = (LONG) SCARD_E_UNEXPECTED;
		TRACE_CATCH_UNKNOWN(_T("GetOpenCardNameW"));
	}

	return lReturn;
}


/*++

LONG SCardDlgExtendedError:

    This is an old entry point for getting extended errors from the
	dialog. Please use the lLastError member of the OPENCARDNAME struct.
		
Arguments:

    None.
		
Return Value:

	None.
	
Author:

    Chris Dudley 2/27/1997

--*/
LONG WINAPI	SCardDlgExtendedError (void)
{
	// Setup the correct module state information
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	LONG		lReturn = E_NOTIMPL;

	// NO LONGER IMPLEMENTED

	return lReturn;
}


/*++

SCardUIDlgSelectCard:

    This is the entry point routine to open the common dialog box, introduced
	in the Microsoft Smart Card SDK v1.x.
		
Arguments:

    pOCNA - Pointer to an ANSI open card name (ex) structure.
	-or-
	pOCNW - Pointer to a UNICODE open card name (ex) structure.
		
Return Value:

    A LONG value indicating the status of the requested action. Please
	see the Smartcard header files for additional information.
	
Author:

    Amanda Matlosz	6/11/98

--*/

LONG WINAPI SCardUIDlgSelectCardA(LPOPENCARDNAMEA_EX pOCNA)
{
	// Setup the correct module state information
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Locals
	LONG lReturn = SCARD_S_SUCCESS;
	CWnd wndParent;
	BOOL fEnableUI = FALSE;
	INT_PTR nResponse = IDCANCEL;
	int nResult = 0;
	DWORD dwOKCards = 0;

	try
	{
		// Check Params
		if (!CheckOCN(pOCNA))
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}

		// Determine names of all acceptable cards
		CTextMultistring mstrOKCards;
		ListAllOKCardNames(pOCNA, mstrOKCards);
				
		//
		// Do a silent search intially to determine # of suitable cards
		// currently available and/or connect to a card if min or no UI
		//
		lReturn = NoUISearch(pOCNA, &dwOKCards, (LPCSTR)mstrOKCards);

		//
		// If we haven't successfully selected a card and we can show UI,
		// raise the dialog
		//
		if (SCARD_S_SUCCESS != lReturn && !(pOCNA->dwFlags & SC_DLG_NO_UI))
		{
			// Now we can init the common dialog
			wndParent.Attach(pOCNA->hwndOwner);
			CScInsertDlg dlgCommon(&wndParent);

			lReturn = dlgCommon.Initialize(pOCNA, dwOKCards, (LPCSTR)mstrOKCards);
			if(SCARD_S_SUCCESS != lReturn)
			{
				throw lReturn;
			}

			nResponse = dlgCommon.DoModal();

			// If cancel/closed return error
			switch (nResponse)
			{
			case IDOK: // absolutely sure of total success!
				break;
			case IDCANCEL:
				lReturn = dlgCommon.m_lLastError;
				if (0 == lReturn)
					lReturn = SCARD_W_CANCELLED_BY_USER; // not SCARD_E_CANCELLED
				break;
			default:
				_ASSERTE(FALSE);
			case -1:
			case IDABORT:
				lReturn = dlgCommon.m_lLastError;
				if (0 == lReturn)
					lReturn = SCARD_F_UNKNOWN_ERROR;
				break;
			}
		}
	}
	catch (LONG hr)
	{
		lReturn = hr;
		TRACE_CATCH(_T("SCardUIDlgSelectCardA"),hr);
	}

	catch (...) {
		lReturn = (LONG) SCARD_E_UNEXPECTED;
		TRACE_CATCH_UNKNOWN(_T("SCardUIDlgSelectCardA"));
	}

	if (NULL != wndParent.m_hWnd)
	{
		wndParent.Detach();
	}

	return lReturn;
}


LONG WINAPI SCardUIDlgSelectCardW(LPOPENCARDNAMEW_EX pOCNW)
{
	// Setup the correct module state information
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Locals
	LONG lReturn = SCARD_S_SUCCESS;
	CWnd wndParent;
	BOOL fEnableUI = FALSE;
	INT_PTR nResponse = IDCANCEL;
	DWORD dwOKCards = 0;

	try
	{
		// Check Params
		if (!CheckOCN(pOCNW))
		{
			throw (LONG)SCARD_E_INVALID_VALUE;
		}

		// Determine names of all acceptable cards
		CTextMultistring mstrOKCards;
		ListAllOKCardNames(pOCNW, mstrOKCards);

		//
		// Do a silent search intially to determine # of suitable cards and/or
		// connect to a card according to display mode (min or no UI)
		//
		lReturn = NoUISearch(pOCNW, &dwOKCards, (LPCWSTR)mstrOKCards);

		//
		// If we haven't successfully selected a card and we can show UI,
		// raise the dialog
		//
		if (SCARD_S_SUCCESS != lReturn && !(pOCNW->dwFlags & SC_DLG_NO_UI))
		{

			// Now we can init the common dialog
			wndParent.Attach(pOCNW->hwndOwner);
			CScInsertDlg dlgCommon(&wndParent);

			// Store Pointer and open dialog
			lReturn = dlgCommon.Initialize(pOCNW, dwOKCards, (LPCWSTR)mstrOKCards);
			if (SCARD_S_SUCCESS != lReturn)
			{
				throw (lReturn);
			}

            nResponse = dlgCommon.DoModal();

            // If cancel/closed return error
            switch (nResponse)
            {
            case IDOK:  // absolutely sure of total success!
                break;
            case IDCANCEL:
                lReturn = SCARD_W_CANCELLED_BY_USER; // not SCARD_E_CANCELLED
                break;
            default:
                _ASSERTE(FALSE);
            case -1:
            case IDABORT:
                lReturn = dlgCommon.m_lLastError;
                if (0 == lReturn)
                    lReturn = SCARD_F_UNKNOWN_ERROR;
                break;
            }
        }
	}
	catch (LONG lErr)
	{
		lReturn = lErr;
		TRACE_CATCH(_T("SCardUIDlgSelectCardW"),lReturn);
	}
	catch (...) {
		lReturn = (LONG) SCARD_E_UNEXPECTED;
		TRACE_CATCH_UNKNOWN(_T("SCardUIDlgSelectCardW"));
	}

	if (NULL != wndParent.m_hWnd)
	{
		wndParent.Detach();
	}

	return lReturn;
}


/*++

SCardUIDlgGetPIN:

		
Arguments:

		
Return Value:

    A LONG value indicating the status of the requested action.
	
Author:

    Amanda Matlosz	06/18/1998

--*/

LONG WINAPI SCardUIDlgGetPINA(LPPINPROMPT pPinPrompt)
{
	// Setup the correct module state information
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	INT_PTR nResponse = IDCANCEL; // result of DoModal.

	CWnd wndParent;
	wndParent.Attach(pPinPrompt->hwndOwner);

	CGetPinDlg dlgGetPin(&wndParent);
	if (dlgGetPin.SetAttributes(pPinPrompt))
	{
		nResponse = dlgGetPin.DoModal();
	}

	if (NULL != wndParent.m_hWnd)
	{
		wndParent.Detach();
	}

	return (LONG)nResponse;
}


/*++

SCardUIDlgChangePIN:

		
Arguments:

		
Return Value:

    A LONG value indicating the status of the requested action.
	
Author:

    Amanda Matlosz	06/18/1998

--*/

LONG WINAPI SCardUIDlgChangePINA(LPCHANGEPIN pChangePin)
{
	// Setup the correct module state information
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	INT_PTR nResponse = IDCANCEL; // result of DoModal.

	CWnd wndParent;
	wndParent.Attach(pChangePin->hwndOwner);

	CChangePinDlg dlgChangePin(&wndParent);
	if (dlgChangePin.SetAttributes(pChangePin))
	{
		nResponse = dlgChangePin.DoModal();
	}

	if (NULL != wndParent.m_hWnd)
	{
		wndParent.Detach();
	}

	return (LONG)nResponse;
}



///////////////////////////////////////////////////////////////////////////////
// Helper functions

void MString2CommaList(CString& str, LPWSTR szmString)
{
	str.Empty();

	if (NULL == szmString)
	{
		return;
	}

	LPCWSTR szm = szmString;
	szm = FirstString(szm);
	str = szm;
	for(szm = NextString(szm); NULL != szm; szm = NextString(szm))
	{
		str += ", ";
		str += szm;
	}
}

void MString2CommaList(CString& str, LPSTR szmString)
{
	USES_CONVERSION;

	str.Empty();

	if (NULL == szmString)
	{
		return;
	}

	LPCSTR szm = szmString;
	str += A2W(szm);
	szm = szm + (sizeof(CHAR)*(strlen(szm)+1));
	while (NULL != szm && NULL != *szm)
	{
		str += ", ";
		str += A2W(szm);
		szm = szm + (sizeof(CHAR)*(strlen(szm)+1));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCardDlg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scinsdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsDlg.cpp
//
//--------------------------------------------------------------------------

// ScInsDlg.cpp : implementation file
//

#include "stdafx.h"
#include <atlconv.h>
#include "resource.h"
#include "scdlg.h"
#include "ScSearch.h"
#include "ScInsDlg.h"
#include "statmon.h"
#include "scHlpArr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScInsertDlg dialog


CScInsertDlg::CScInsertDlg(CWnd* pParent/*=NULL*/)
    : CDialog(CScInsertDlg::IDD, pParent)
{

    // Member Initialization
    m_lLastError = SCARD_S_SUCCESS;
    m_ParentHwnd = pParent;
    m_pOCNW = NULL;
    m_pOCNA = NULL;
    m_pSelectedReader = NULL;
    m_pSubDlg = NULL;

    m_strTitle.Empty();
    m_strPrompt.Empty();
    m_mstrAllCards = "";

    //{{AFX_DATA_INIT(CScInsertDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


CScInsertDlg::~CScInsertDlg()
{
    // Stop status monitor
    m_monitor.Stop();

    // Clean up status list!
    if (0 != m_aReaderState.GetSize())
    {
        for (int i = (int)m_aReaderState.GetUpperBound(); i>=0; i--)
        {
            delete m_aReaderState[i];
        }

        m_aReaderState.RemoveAll();
    }
}


void CScInsertDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CScInsertDlg)
    DDX_Control(pDX, IDC_DETAILS, m_btnDetails);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScInsertDlg, CDialog)
    //{{AFX_MSG_MAP(CScInsertDlg)
    ON_MESSAGE( WM_READERSTATUSCHANGE, OnReaderStatusChange )
    ON_BN_CLICKED(IDC_DETAILS, OnDetails)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScInsertDlg data methods

/*++

LONG Initialize:

    Stores the open card name pointer in the proper internal struct.
    Determines whether to show the dialog in details or brief mode.

Arguments:

    pOCN(x) - pointer to an open card name ex struct

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Amanda Matlosz  07/09/1998

--*/

// ANSI
LONG CScInsertDlg::Initialize(LPOPENCARDNAMEA_EX pOCNA, DWORD dwNumOKCards, LPCSTR mszOKCards)
{
    _ASSERTE(NULL != pOCNA);
    if (NULL == pOCNA)
    {
        return SCARD_F_UNKNOWN_ERROR;
    }

    m_pOCNA = pOCNA;

    m_strTitle = m_pOCNA->lpstrTitle;
    m_strPrompt = m_pOCNA->lpstrSearchDesc;
    m_mstrAllCards = mszOKCards;
    m_hIcon = pOCNA->hIcon;

    // hide details if no suitable cards available, else show details
    m_fDetailsShown = (0==dwNumOKCards) ? FALSE : TRUE;

    // prepare critical section for UI routines
    m_pCritSec = new CCriticalSection();
    if (NULL == m_pCritSec)
    {
        return ERROR_OUTOFMEMORY; // TODO: is another errorcode more appropriate?
    }

	// put dialog on top
	SetForegroundWindow();

    return SCARD_S_SUCCESS;
}

//UNICODE
HRESULT CScInsertDlg::Initialize(LPOPENCARDNAMEW_EX pOCNW, DWORD dwNumOKCards, LPCWSTR mszOKCards)
{
    _ASSERTE(NULL != pOCNW);
    if (NULL == pOCNW)
    {
        return SCARD_F_UNKNOWN_ERROR;
    }

    m_pOCNW = pOCNW;

    m_strTitle = m_pOCNW->lpstrTitle;
    m_strPrompt = m_pOCNW->lpstrSearchDesc;
    m_mstrAllCards = mszOKCards;
    m_hIcon = pOCNW->hIcon;

    // hide details if no suitable cards available, else show details
    m_fDetailsShown = (0==dwNumOKCards) ? FALSE : TRUE;

    // prepare critical section for UI routines
    m_pCritSec = new CCriticalSection();
    if (NULL == m_pCritSec)
    {
        return ERROR_OUTOFMEMORY; // TODO: is another errorcode more appropriate?
    }

	// put dialog on top
	SetForegroundWindow();

    return SCARD_S_SUCCESS;
}


void CScInsertDlg::EnableOK(BOOL fEnabled)
{
    CButton* pBtn = (CButton*)GetDlgItem(IDOK);
    _ASSERTE(NULL != pBtn);

    pBtn->EnableWindow(fEnabled);

    //
    // Change prompt text accordingly and set the OK button
    // to be default if it's enabled
    //

    CString strPrompt;

    if (fEnabled)
    {
        strPrompt.LoadString(IDS_SC_FOUND);

        // set <OK> default, remove <Cancel> default
        pBtn->SetButtonStyle(BS_DEFPUSHBUTTON);
        pBtn = (CButton*)GetDlgItem(IDCANCEL);
        _ASSERTE(NULL != pBtn);
        pBtn->SetButtonStyle(BS_PUSHBUTTON);
        pBtn = (CButton*)GetDlgItem(IDC_DETAILS); // details can sometimes get set to default
        _ASSERTE(NULL != pBtn);
        pBtn->SetButtonStyle(BS_PUSHBUTTON);

    }
    else
    {
        _ASSERTE(!m_strPrompt.IsEmpty());
        strPrompt = m_strPrompt;

        // remove <OK> default, set <Cancel> default
        pBtn->SetButtonStyle(BS_PUSHBUTTON);
        pBtn = (CButton*)GetDlgItem(IDCANCEL);
        _ASSERTE(NULL != pBtn);
        pBtn->SetButtonStyle(BS_DEFPUSHBUTTON);
        pBtn = (CButton*)GetDlgItem(IDC_DETAILS); // details can sometimes get set to default
        _ASSERTE(NULL != pBtn);
        pBtn->SetButtonStyle(BS_PUSHBUTTON);
    }

    CWnd* pDlgItem = GetDlgItem(IDC_PROMPT);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->SetWindowText(strPrompt);
}


void CScInsertDlg::DisplayError(UINT uiErrorMsg)
{
    CString strTitle, strMsg;

    strTitle.LoadString(IDS_SC_TITLE_ERROR);
    strMsg.LoadString(uiErrorMsg);

    MessageBox(strMsg, strTitle, MB_OK | MB_ICONEXCLAMATION);
}


void CScInsertDlg::SetSelection(CSCardReaderState* pRdrSt)
{
    m_pSelectedReader = pRdrSt;
    EnableOK(IsSelectionOK());
}


BOOL CScInsertDlg::SameCard(CSCardReaderState* p1, CSCardReaderState* p2)
{
    _ASSERTE(NULL != p1);
    _ASSERTE(NULL != p2);

    if ((NULL == p1) && (NULL == p2))
    {
        return TRUE;
    }

    if ((NULL == p1) || (NULL == p2))
    {
        return FALSE;
    }

    // same reader & card?
    if ((0 == p1->strReader.Compare(p2->strReader)) &&
        (0 == p1->strCard.Compare(p2->strCard)))
    {
        // no drastic state change?
        if(p1->dwState == p2->dwState)
        {
            return TRUE;
        }

        if(((p1->dwState == SC_SATATUS_AVAILABLE) ||
            (p1->dwState == SC_STATUS_SHARED) ||
            (p1->dwState == SC_STATUS_EXCLUSIVE)) &&
           ((p2->dwState == SC_SATATUS_AVAILABLE) ||
            (p2->dwState == SC_STATUS_SHARED) ||
            (p2->dwState == SC_STATUS_EXCLUSIVE)) )
        {
            return TRUE;
        }
    }
    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScInsertDlg message handlers

/*++

void ShowHelp:

    Helper function for OnHelpInfo and OnContextMenu.

BOOL OnHelpInfo:

    Called by the MFC framework when the user hits F1.

void OnContextMenu

    Called by the MFC framework when the user right-clicks.

Author:

    Amanda Matlosz  03/04/1999

Note:

    These three functions work together to provide context-sensitive
    help for the insertdlg.  Similar functions are declared for
    CScInsertBar

--*/
void CScInsertDlg::ShowHelp(HWND hWnd, UINT nCommand)
{

    ::WinHelp(hWnd, _T("SCardDlg.hlp"), nCommand, (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_SCARDDLG1);
}

afx_msg BOOL CScInsertDlg::OnHelpInfo(LPHELPINFO lpHelpInfo)
{
    _ASSERTE(NULL != lpHelpInfo);

    ShowHelp((HWND)lpHelpInfo->hItemHandle, HELP_WM_HELP);

    return TRUE;
}

afx_msg void CScInsertDlg::OnContextMenu(CWnd* pWnd, CPoint pt)
{
    _ASSERTE(NULL != pWnd);

    ShowHelp(pWnd->m_hWnd, HELP_CONTEXTMENU);
}


/*++

void OnReaderStatusChange:

    This message handler is called by the status thread when smartcard status
    has changed.

Arguments:

    None.

Return Value:

    IGNORED BY CALLER. Long indicating status of ResMgr calls.

Author:

    Amanda Matlosz  07/09/1998

Note:

    No formal parameters are declared. These are not used and
    will stop compiler warnings from being generated.
    The long param takes the result of no_service or stopped

--*/
LONG CScInsertDlg::OnReaderStatusChange(UINT uint, LONG lParam)
{
    // Is monitor still alive?

    CScStatusMonitor::status status = m_monitor.GetStatus();
    if (CScStatusMonitor::running != status)
    {
        m_pSubDlg->EnableStatusList(FALSE);
        SetSelection(NULL); // JIC

        // display appropriate error & set m_lLastError
        switch(status)
        {
        case CScStatusMonitor::no_service:
        case CScStatusMonitor::stopped:
            m_lLastError = lParam;
            DisplayError(IDS_SC_RM_ERR);
            break;
        case CScStatusMonitor::no_readers:
            m_lLastError = SCARD_E_NO_READERS_AVAILABLE;
            DisplayError(IDS_SC_NO_READERS);
            break;
        default:
            m_lLastError = SCARD_F_UNKNOWN_ERROR;
            DisplayError(IDS_UNKNOWN_ERROR);
            break;
        }
    }
    else
    {
        // crit section around member reader/card status array
        _ASSERTE(m_pCritSec);
        if (m_pCritSec)
        {
            m_pCritSec->Lock();
        }

        // make local copy of recent reader state array,
        // so we know which cards have already been checked
        CSCardReaderStateArray aPreviousReaderState;
        aPreviousReaderState.RemoveAll();
        for (int nCopy = (int)m_aReaderState.GetUpperBound(); nCopy>=0; nCopy--)
        {
            CSCardReaderState* pReader = NULL;
            pReader = new CSCardReaderState(m_aReaderState[nCopy]);
            if (NULL != pReader)
            {
                aPreviousReaderState.Add(pReader);
            }
        }

        // udpate array from CStatusMonitor
        // check cards that have not been previously checked,
        // & update UI

        m_monitor.GetReaderStatus(m_aReaderState);
        for (int n = (int)m_aReaderState.GetUpperBound(); n>=0; n--)
        {
            CSCardReaderState* pReader = m_aReaderState[n];
            BOOL fAlreadyChecked = FALSE;

            // have we checked this card before?
            for (int nPrev = (int)aPreviousReaderState.GetUpperBound();
                 (nPrev>=0 && !fAlreadyChecked);
                 nPrev--)
            {
                if (SameCard(pReader, aPreviousReaderState[nPrev]))
                {
                    pReader->fOK = (aPreviousReaderState[nPrev])->fOK;
                    fAlreadyChecked = TRUE;
                }
            }

            // if this is a new card, or if the card's status has changed
            // drastically since we last looked at it, check it again
            if (!fAlreadyChecked)
            {
                if (NULL != m_pOCNW)
                {
                    m_aReaderState[n]->fOK = CheckCardAll(
                                                m_aReaderState[n],
                                                m_pOCNW,
                                                (LPCWSTR)m_mstrAllCards);
                }
                else
                {
                    _ASSERTE(NULL != m_pOCNA);
                    m_aReaderState[n]->fOK = CheckCardAll(
                                                m_aReaderState[n],
                                                m_pOCNA,
                                                (LPCWSTR)m_mstrAllCards);
                }
            }
        }

        // the subdialog will handle automatic reader selection
        m_pSubDlg->UpdateStatusList(&m_aReaderState);

        // clean up
        for (int nX = (int)aPreviousReaderState.GetUpperBound(); nX>=0; nX--)
        {
            delete aPreviousReaderState[nX];
        }
        aPreviousReaderState.RemoveAll();

        // end crit section
        if (m_pCritSec)
        {
            m_pCritSec->Unlock();
        }

    }

    return (long)SCARD_S_SUCCESS; // there's no one to receive this.
}


void CScInsertDlg::OnDetails()
{
    //
    // If the details are currently shown, hide them...
    // otherwise, show them.
    //
    CRect rectWin;

    GetWindowRect(&rectWin);

    CRect rectButtonBottom;

    CString strDetailsCaption;

    //
    // Determine the new height of the dialog & resize
    //

    int nNewHeight = 0;
    if (m_fDetailsShown)
    {
        nNewHeight = m_SmallHeight;
        strDetailsCaption.LoadString(IDS_DETAILS_SHOW);
    }
    else
    {
        nNewHeight = m_BigHeight;
        strDetailsCaption.LoadString(IDS_DETAILS_HIDE);
    }

    ScreenToClient(&rectButtonBottom);
    rectWin.bottom = rectWin.top + nNewHeight;

    SetWindowPos(NULL,
                    rectWin.left,
                    rectWin.top,
                    rectWin.Width(),
                    rectWin.Height(),
                    SWP_NOMOVE | SWP_NOZORDER);

    //
    // change captions, move buttons, show or hide the details section
    //

    m_btnDetails.SetWindowText(strDetailsCaption);

    MoveButton(IDC_DETAILS, nNewHeight - m_yMargin);
    MoveButton(IDOK, nNewHeight - m_yMargin);
    MoveButton(IDCANCEL, nNewHeight - m_yMargin);

    ToggleSubDialog();

    //
    // remember our new state
    //

    m_fDetailsShown = !m_fDetailsShown;
}


BOOL CScInsertDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // Initialize bits to query RM; if these fail, there's no point to go on
    // but the user should see an error message.
    //

    // kick off CSCStatusMonitor
    m_lLastError = m_monitor.Start(m_hWnd, WM_READERSTATUSCHANGE);

    // if not running or no readers available
    CScStatusMonitor::status status = m_monitor.GetStatus();

    if (SCARD_S_SUCCESS != m_lLastError)
    {
        switch(status)
        {
        case CScStatusMonitor::no_service:
            DisplayError(IDS_SC_RM_ERR);
            break;
        case CScStatusMonitor::no_readers:
//            DisplayError(IDS_SC_NO_READERS);	// Bug 15742 -> will die quietly (no UI)
            break;
        case CScStatusMonitor::running:
            _ASSERTE(FALSE); // How can this be running if an error was returned??????
            // no break; go ahead an report an 'unknown error'
        default:
            DisplayError(IDS_UNKNOWN_ERROR);
            break;
        }

        PostMessage(WM_CLOSE, 0, 0);
        return TRUE;
    }
    _ASSERTE(status == CScStatusMonitor::running);

    //
    // Determine constant offsets for resizing window (on details)
    //

    CRect rectWin, rectDlgItem;
    GetWindowRect(&rectWin);

    m_SmallHeight = rectWin.Height();

    CWnd* pDlgItem = GetDlgItem(IDOK);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->GetWindowRect(&rectDlgItem);
    ScreenToClient(rectDlgItem);

    m_yMargin = m_SmallHeight - rectDlgItem.bottom;

    pDlgItem = GetDlgItem(IDC_BUTTON_BOTTOM);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->GetWindowRect(&rectDlgItem);
    ScreenToClient(rectDlgItem);

    m_BigHeight = rectDlgItem.bottom + m_yMargin;

    //
    // Add user-provided or ReaderLoaded icon
    //

    if (NULL == m_hIcon)
    {
        m_hIcon = AfxGetApp()->LoadIcon(IDI_SC_READERLOADED_V2);
    }
    _ASSERTE(NULL != m_hIcon);

    pDlgItem = GetDlgItem(IDC_USERICON);
    _ASSERTE(NULL != pDlgItem);

    pDlgItem->SetIcon(m_hIcon, TRUE); // TRUE: 32x32 icon

    //
    // Add other User-Customization bits
    //

    if (!m_strTitle.IsEmpty())
    {
        SetWindowText(m_strTitle);
    }

    if (m_strPrompt.IsEmpty())
    {
        // Use the default prompt text.
        m_strPrompt.LoadString(IDS_SC_PROMPT_ANYCARD);
    }
    pDlgItem = GetDlgItem(IDC_PROMPT);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->SetWindowText(m_strPrompt);

    // by default, <OK> is not enabled (subdlg's OnInitDlg might change that)
    EnableOK(FALSE);

    //
    // Set HELP ID(s) for context help
    //

    pDlgItem = GetDlgItem(IDC_DETAILS);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->SetWindowContextHelpId(IDH_DLG1_DETAILS_BTN);

    //
    // Add CScInsertBar (actually, a CDialog-derivative) to our dialog
    //

    pDlgItem = GetDlgItem(IDC_DLGBAR);
    _ASSERTE(NULL != pDlgItem);
    pDlgItem->GetWindowRect(&rectDlgItem);
    ScreenToClient(rectDlgItem);

    m_pSubDlg = new CScInsertBar(this);
    _ASSERTE(NULL != m_pSubDlg);
    if (NULL == m_pSubDlg)
    {
        m_lLastError = ERROR_OUTOFMEMORY;
        PostMessage(WM_CLOSE, 0, 0);
        return TRUE;
    }

    m_pSubDlg->Create(IDD_SCARDDLG_BAR, this);
    m_pSubDlg->SetWindowPos(NULL,
                rectDlgItem.left,
                rectDlgItem.top,
                0,
                0,
                SWP_NOSIZE | SWP_NOACTIVATE); // TODO: SWP_NOZORDER ??

    //
    // Set the dialog to alter itself to match how it was called
    //

    m_fDetailsShown = !m_fDetailsShown;
    OnDetails();

    if (m_fDetailsShown)
    {
        return FALSE; // focus should be set to list control
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CScInsertDlg::MoveButton(UINT nID, int newBottom)
{
    CWnd* pBtn = GetDlgItem(nID);
    _ASSERTE(NULL != pBtn);

    CRect rect;
    pBtn->GetWindowRect(&rect);
    ScreenToClient(&rect);
    rect.top = newBottom - rect.Height();

    pBtn->SetWindowPos(NULL,
                rect.left,
                rect.top,
                0,
                0,
                SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
}


void CScInsertDlg::ToggleSubDialog()
{
    //
    // All you need to do to toggle the sub dialog's accessibility
    // is to hide&disable or show&enable the window.
    //

    if (m_fDetailsShown)
    {
        m_pSubDlg->ShowWindow(SW_HIDE);
        m_pSubDlg->EnableWindow(FALSE);
    }
    else
    {
        m_pSubDlg->ShowWindow(SW_SHOW);
        m_pSubDlg->EnableWindow(TRUE);
    }
}


BOOL CScInsertDlg::DestroyWindow()
{
    if (NULL != m_pSubDlg)
    {
        m_pSubDlg->DestroyWindow();
        delete m_pSubDlg;
    }

    return CDialog::DestroyWindow();
}


/*++

void OnOK:

    Handle user's <OK>, error if can't complete

Arguments:

    None.

Return Value:

    None

Author:

    Amanda Matlosz  4/28/98
--*/
void CScInsertDlg::OnOK()
{
    USES_CONVERSION;

    // Must have something selected to exit

    if (NULL == m_pSelectedReader || m_pSelectedReader->strCard.IsEmpty())
    {
        DisplayError(IDS_SC_SELECT);
        return;
    }

    // Must have selected something we're looking for...

    if (!(m_pSelectedReader->fOK))
    {
        DisplayError(IDS_SC_NOMATCH);
        return;
    }

    // Call the correct method to set the *real* card selection

    if(NULL != m_pOCNA)
    {

        LPSTR szCard = W2A(m_pSelectedReader->strCard);
        LPSTR szReader = W2A(m_pSelectedReader->strReader);

        m_lLastError = SetFinalCardSelection(szReader, szCard, m_pOCNA);
    }
    else
    {
        _ASSERTE(NULL != m_pOCNW);

        LPWSTR szCard = m_pSelectedReader->strCard.GetBuffer(1);
        LPWSTR szReader = m_pSelectedReader->strReader.GetBuffer(1);

        m_lLastError = SetFinalCardSelection(szReader, szCard, m_pOCNW);

        m_pSelectedReader->strCard.ReleaseBuffer();
        m_pSelectedReader->strReader.ReleaseBuffer();
    }

    if (SCARD_S_SUCCESS != m_lLastError)
    {
        DisplayError(IDS_SC_CONNECT_FAILED); // Either connect failed or out of memory - close enough.
        return;
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scsearch.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScSearch

Abstract:

	header for miscellaneous smart card search and check functions
	See ScSearch.cpp for details.
	
Author:

	Amanda Matlosz	5/7/98

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:

	
Notes:

  Ansi and Widechar versions
--*/

#include "ScUIDlg.h" // winscard.h
#include "statmon.h"

DWORD AnsiMStringCount(LPCSTR msz);	// ansi-only

BOOL CheckOCN(LPOPENCARDNAMEA_EX pOCNA); // ansi-only
BOOL CheckOCN(LPOPENCARDNAMEW_EX pOCNW); // unicode-only

void ListAllOKCardNames(LPOPENCARDNAMEA_EX pOCNA, CTextMultistring& mstrAllCards); // ansi-only
void ListAllOKCardNames(LPOPENCARDNAMEW_EX pOCNW, CTextMultistring& mstrAllCards); // unicode-only

LONG NoUISearch(OPENCARDNAMEA_EX* pOCN, DWORD* pdwOKCards, LPCSTR mszCards); // ansi-only
LONG NoUISearch(OPENCARDNAMEW_EX* pOCN, DWORD* pdwOKCards, LPCWSTR mszCards); // unicode-only

BOOL CheckCardCallback(LPSTR szReader, LPSTR szCard, OPENCARDNAMEA_EX* pOCN); // Does the callback stuff
BOOL CheckCardCallback(LPWSTR szReader, LPWSTR szCard, OPENCARDNAMEW_EX* pOCN); // Does the callback stuff

BOOL CheckCardAll(CSCardReaderState* pReader, OPENCARDNAMEA_EX* pOCN, LPCWSTR mszCards); // ditto
BOOL CheckCardAll(CSCardReaderState* pReader, OPENCARDNAMEW_EX* pOCN, LPCWSTR mszCards); // ditto

LONG SetFinalCardSelection(LPSTR szReader, LPSTR szCard, OPENCARDNAMEA_EX* pOCN);
LONG SetFinalCardSelection(LPWSTR szReader, LPWSTR szCard, OPENCARDNAMEW_EX* pOCN);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scinsbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsBar.cpp
//
//--------------------------------------------------------------------------

// ScInsBar.cpp : implementation file
//

#include "stdafx.h"
#include "scdlg.h"
#include "scinsdlg.h"
#include "ScInsBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScEdit special edit boxes (CardName, CardStatus)

BEGIN_MESSAGE_MAP(CScEdit, CEdit)
    //{{AFX_MSG_MAP(CScEdit)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CScEdit::OnContextMenu(CWnd* pWnd, CPoint pt)
{
    ::WinHelp(m_hWnd, _T("SCardDlg.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_SCARDDLG_BAR);
}


/////////////////////////////////////////////////////////////////////////////
// CScInsertBar dialog


CScInsertBar::CScInsertBar(CWnd* pParent /*=NULL*/)
    : CDialog(CScInsertBar::IDD, pParent)
{
    m_paReaderState = NULL;
    //{{AFX_DATA_INIT(CScInsertBar)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

void CScInsertBar::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CScInsertBar)
    DDX_Control(pDX, IDC_NAME, m_ediName);
    DDX_Control(pDX, IDC_STATUS, m_ediStatus);
    DDX_Control(pDX, IDC_READERS, m_lstReaders);
    //}}AFX_DATA_MAP
}


void CScInsertBar::OnCancel()
{
    CScInsertDlg* pParent = (CScInsertDlg*)GetParent();
    _ASSERTE(NULL != pParent);
    if (NULL != pParent)
    {
        pParent->PostMessage(IDCANCEL);
    }
}

BEGIN_MESSAGE_MAP(CScInsertBar, CDialog)
    //{{AFX_MSG_MAP(CScInsertBar)
    ON_WM_DESTROY()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_READERS, OnReaderItemChanged)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScInsertBar UI & smart card methods


/*++

InitializeReaderList:

    Initialize the list control w/ large images, and set up the
    CStringArray of image (reader/card status) descriptions...

Arguments:

    None.

Return Value:

    None.

Author:

    Amanda Matlosz 07/14/1998

--*/
void CScInsertBar::InitializeReaderList(void)
{
    HICON hicon;
    CImageList imageList;
    CString str;

    // Create the image list & give it to the list control
    imageList.Create (
                        IMAGE_WIDTH,
                        IMAGE_HEIGHT,
                        TRUE,       // list does include masks
                        NUMBER_IMAGES,
                        0);                 // list won't grow

    // Build the image list
    for (int i = 0; i < NUMBER_IMAGES; i++ )
    {
        // Load icon and add it to image list
        hicon = NULL;
        hicon = ::LoadIcon (    AfxGetInstanceHandle(),
                                MAKEINTRESOURCE(IMAGE_LIST_IDS[i]) );
        if (NULL==hicon) {
            break; // what can we do?
        }
        imageList.Add (hicon);

    }

    // Be sure that all the small icons were added.
    _ASSERTE(imageList.GetImageCount() == NUMBER_IMAGES);

    m_lstReaders.SetImageList(&imageList, (int) LVSIL_NORMAL);
    imageList.Detach();
}


/*++

UpdateStatusList:

    This routine resets the list box display

Arguments:

    None.

Return Value:

    A LONG value indicating the status of the requested action. Please
    see the Smartcard header files for additional information.

Author:

    Amanda Matlosz  06/15/1998

Notes:

    Strings need to be converted from type stored in the smartcard
    thread help classes to this dialog's build type (i.e. UNICODE/ANSI)!!!!

--*/
void CScInsertBar::UpdateStatusList(CSCardReaderStateArray* paReaderState)
{

    CString strCardStatus, strCardName;
    CSCardReaderState* pReader = NULL;
    CSCardReaderState* pSelectedRdr = NULL;
    LV_ITEM lv_item;

    //
    // Update the reader information
    //

    m_paReaderState = paReaderState;

    // reset previous knowledge re: reader/card status
    m_ediName.SetWindowText(_T(""));
    m_ediStatus.SetWindowText(_T(""));
    m_lstReaders.DeleteAllItems();

    if (NULL != m_paReaderState)
    {
        // Insert (new) items

        lv_item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
        lv_item.cchTextMax = MAX_ITEMLEN;

        int nNumReaders = (int)m_paReaderState->GetSize();
        for(int nIndex = 0; nIndex < nNumReaders; nIndex++)
        {
            // Setup struct for system reader list
            pReader = m_paReaderState->GetAt(nIndex);
            _ASSERTE(NULL != pReader);

            lv_item.iItem = nIndex;
            lv_item.stateMask = 0;
            lv_item.state = 0;
            lv_item.iSubItem = 0;
            lv_item.iImage = (int)READEREMPTY;
            lv_item.pszText = NULL;
            // set lparam to the reader ptr so we can fetch the readerinfo later
            lv_item.lParam = (LPARAM)pReader;

            //
            // Get the card status: image, and select OK card
            //

            if (NULL != pReader)
            {
                lv_item.pszText = (LPTSTR)(LPCTSTR)(pReader->strReader);

                DWORD dwState = pReader->dwState;
                if (dwState == SC_STATUS_NO_CARD)
                {
                    lv_item.iImage = (int)READEREMPTY;
                }
                else if (dwState == SC_STATUS_ERROR)
                {
                    lv_item.iImage = (int)READERERROR;
                }
                else
                {
                    if (pReader->fOK)
                    {
                        lv_item.iImage = (int)READERLOADED;
                    }
                    else
                    {
                        lv_item.iImage = (int)WRONGCARD;
                    }
                }

                // Select if this is a search card
                if (pReader->fOK && (NULL==pSelectedRdr))
                {
                    lv_item.state = LVIS_SELECTED | LVIS_FOCUSED;

                    // Set that a selection has occurred
                    pSelectedRdr = pReader;
                }
            }

            // Add Item
            m_lstReaders.InsertItem(&lv_item);
        }

        // indicate that the reader selection has changed
        if (NULL != pSelectedRdr)
        {
            OnReaderSelChange(pSelectedRdr);
        }
        else
        {
            // select the first item in the list
            m_lstReaders.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, 0);
            OnReaderSelChange(m_paReaderState->GetAt(0));
        }
        m_lstReaders.SetFocus(); // TODO: ?? Remove this? ??
    }
}


/////////////////////////////////////////////////////////////////////////////
// CScInsertBar message handlers


/*++

void ShowHelp:

    Helper function for OnHelpInfo and OnContextMenu.

BOOL OnHelpInfo:

    Called by the MFC framework when the user hits F1.

void OnContextMenu

    Called by the MFC framework when the user right-clicks.

Author:

    Amanda Matlosz  03/04/1999

Note:

    These three functions work together to provide context-sensitive
    help for the insertdlg.

--*/
void CScInsertBar::ShowHelp(HWND hWnd, UINT nCommand)
{

    ::WinHelp(hWnd, _T("SCardDlg.hlp"), nCommand, (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_SCARDDLG_BAR);
}

afx_msg BOOL CScInsertBar::OnHelpInfo(LPHELPINFO lpHelpInfo)
{
    _ASSERTE(NULL != lpHelpInfo);

    ShowHelp((HWND)lpHelpInfo->hItemHandle, HELP_WM_HELP);

    return TRUE;
}

afx_msg void CScInsertBar::OnContextMenu(CWnd* pWnd, CPoint pt)
{
    _ASSERTE(NULL != pWnd);

    ShowHelp(pWnd->m_hWnd, HELP_CONTEXTMENU);
}

void CScInsertBar::OnDestroy()
{
    // clean up image list
    m_SCardImages.DeleteImageList();

    CDialog::OnDestroy();
}


BOOL CScInsertBar::OnInitDialog()
{

    CDialog::OnInitDialog();

    //
    // prepare list control
    //

    InitializeReaderList();

    //
    // TODO: try SubclassWindow() trick. What's up with MFC?
    //
    CWnd* pEdit = NULL;
    pEdit = GetDlgItem(IDC_NAME);
    if (NULL != pEdit) m_ediName.SubclassWindow(pEdit->m_hWnd);
    pEdit = NULL;
    pEdit = GetDlgItem(IDC_STATUS);
    if (NULL != pEdit) m_ediStatus.SubclassWindow(pEdit->m_hWnd);

    return  TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


/*++

OnReaderItemChanged:

    Routine processes a selection change in the list control --
    if a card name is selected, it is displayed in a separate control

Arguments:

    pNMHDR - pointer to notification structure
    pResult - pointer to LRESULT

Return Value:

    Returns TRUE on success; FALSE otherwise.

Author:

    Amanda Matlosz  09/26/1998

Revision History:

--*/
void CScInsertBar::OnReaderItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
    int nItem = m_lstReaders.GetNextItem(-1, LVNI_SELECTED);

    if (nItem != -1)
    {
        CSCardReaderState* pRdrSt = (CSCardReaderState*)m_lstReaders.GetItemData(nItem);
        OnReaderSelChange(pRdrSt);
    }

    *pResult = 0;
}


void CScInsertBar::OnReaderSelChange(CSCardReaderState* pSelectedRdr)
{
    _ASSERTE(pSelectedRdr);
    if (NULL != pSelectedRdr)
    {
        //
        // Change UI to show selection details
        //

        CString strStatus, strName;
        DWORD dwState = pSelectedRdr->dwState;

        strStatus.LoadString(IDS_SC_STATUS_NO_CARD + dwState - SC_STATUS_NO_CARD);

        if (dwState != SC_STATUS_NO_CARD)
        {
            strName = pSelectedRdr->strCard;
            strName.TrimLeft();
            if (strName.IsEmpty() || dwState == SC_STATUS_UNKNOWN)
            {
                strName.LoadString(IDS_SC_NAME_UNKNOWN);
            }

            if (!pSelectedRdr->fOK && (dwState >= SC_SATATUS_AVAILABLE && dwState <= SC_STATUS_EXCLUSIVE))
            {
                CString strAdd;
                strAdd.LoadString(IDS_SC_CANT_USE);
                strStatus += "  ";
                strStatus += strAdd;
            }
        }

        m_ediName.SetWindowText(strName);
        m_ediStatus.SetWindowText(strStatus);
    }

    //
    // Inform parent of change in selection, even if that sel is "NULL"
    //

    CScInsertDlg* pParent = (CScInsertDlg*)GetParent();
    _ASSERTE(NULL != pParent);
    if (NULL != pParent)
    {
        pParent->SetSelection(pSelectedRdr);
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scinsdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsDlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SCINSDLG_H__D7E6F001_DDE8_11D1_803B_0000F87A49E0__INCLUDED_)
#define AFX_SCINSDLG_H__D7E6F001_DDE8_11D1_803B_0000F87A49E0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ScInsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
//#include "statthrd.h"
#include "ScUIDlg.h" // includes winscard.h
#include "statmon.h"
#include "ScInsBar.h"


/////////////////////////////////////////////////////////////////////////////
// CScInsertDlg dialog

class CScInsertDlg : public CDialog
{
// Construction
public:
    CScInsertDlg(CWnd* pParent = NULL);
    ~CScInsertDlg();

// Dialog Data
    //{{AFX_DATA(CScInsertDlg)
    enum { IDD = IDD_SCARDDLG1 };
    CButton m_btnDetails;
    CListCtrl m_lstReaders;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScInsertDlg)
    public:
    virtual BOOL DestroyWindow();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    LONG Initialize(LPOPENCARDNAMEA_EX pOCNA, DWORD dwNumOKCards, LPCSTR mszOKCards);
    LONG Initialize(LPOPENCARDNAMEW_EX pOCNW, DWORD dwNumOKCards, LPCWSTR mszOKCards);
    void SetSelection(CSCardReaderState* pRdrSt);

protected:

    // UI routines
    void DisplayError(UINT uiErrorMsg=IDS_UNKNOWN_ERROR);

    // data routines
    bool IsSelectionOK()
    {
        return (((NULL==m_pSelectedReader)?false:m_pSelectedReader->fOK) != 0);
    }
    bool MatchesSelection(CSCardReaderState* pRdrSt)
    {
        return (pRdrSt == m_pSelectedReader);
    }

protected:

    // UI
    HICON m_hIcon;          // Handle to the ICON
    BOOL m_fDetailsShown;
    int m_yMargin, m_SmallHeight, m_BigHeight;
    CString m_strTitle;
    CString m_strPrompt;

    CWnd* m_ParentHwnd;
    CScInsertBar* m_pSubDlg;    // a CDialog-derived object

    void MoveButton(UINT nID, int newBottom);
    void ToggleSubDialog();
    void EnableOK(BOOL fEnabled=TRUE);

    // Data
public:
    LONG                m_lLastError;       // Last error

protected:
    LPOPENCARDNAMEA_EX  m_pOCNA;
    LPOPENCARDNAMEW_EX  m_pOCNW;

    CTextMultistring m_mstrAllCards;

    CScStatusMonitor    m_monitor;          // see statmon.h
    CSCardReaderStateArray  m_aReaderState; //  "
    CSCardReaderState* m_pSelectedReader;

    CCriticalSection*   m_pCritSec;

    // Generated message map functions
    //{{AFX_MSG(CScInsertDlg)
    afx_msg LONG OnReaderStatusChange(UINT uint, LONG lParam);
    afx_msg void OnDetails();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg BOOL OnHelpInfo(LPHELPINFO lpHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt);
//  afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // helper function
    BOOL SameCard(CSCardReaderState* p1, CSCardReaderState* p2);
    void ShowHelp(HWND hWnd, UINT nCommand);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCINSDLG_H__D7E6F001_DDE8_11D1_803B_0000F87A49E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scinsbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ScInsBar.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SCINSBAR_H__D7E6F002_DDE8_11D1_803B_0000F87A49E0__INCLUDED_)
#define AFX_SCINSBAR_H__D7E6F002_DDE8_11D1_803B_0000F87A49E0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ScInsBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "statmon.h"
#include "scHlpArr.h"

/////////////////////////////////////////////////////////////////////////////
//
// Constants for (sub)dialog
//
#define     MAX_ITEMLEN         255

// Image list properties
#define     IMAGE_WIDTH         32
#define     IMAGE_HEIGHT        32
#define     NUMBER_IMAGES       5
const UINT  IMAGE_LIST_IDS[] = {IDI_SC_READERLOADED_V2,
                                IDI_SC_READEREMPTY_V2,
                                IDI_SC_WRONGCARD,
                                IDI_SC_READERERR,
                                IDI_SC_CARDUNKNOWN};
#define     READERLOADED    0
#define     READEREMPTY     1
#define     WRONGCARD       2
#define     READERERROR     3
#define     UKNOWNCARD      4

/////////////////////////////////////////////////////////////////////////////
// CScEdit -- Edit boxes that pass OnContextMenu messages to parent
class CScEdit : public CEdit
{
protected:
    // Generated message map functions
    //{{AFX_MSG(CScEdit)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CScInsertBar dialog

class CScInsertBar : public CDialog
{
// Construction
public:
    CScInsertBar(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CScInsertBar)
    enum { IDD = IDD_SCARDDLG_BAR };
    CScEdit m_ediName;
    CScEdit m_ediStatus;
    CListCtrl   m_lstReaders;
    //}}AFX_DATA

    void ResetReaderList(void);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScInsertBar)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    // UI routines
    void EnableStatusList(bool f) { m_lstReaders.EnableWindow(f); }
    void UpdateStatusList(CSCardReaderStateArray* paReaderState);

protected:

    // UI routines
    void InitializeReaderList(void);
    void OnReaderSelChange(CSCardReaderState* pSelectedRdr);

    // Data
    CImageList  m_SCardImages;
    CSCardReaderStateArray* m_paReaderState;

    // Generated message map functions
    //{{AFX_MSG(CScInsertBar)
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    afx_msg void OnReaderItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
    virtual void OnCancel();
    afx_msg BOOL OnHelpInfo(LPHELPINFO lpHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // helper function
    void ShowHelp(HWND hWnd, UINT nCommand);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCINSBAR_H__D7E6F002_DDE8_11D1_803B_0000F87A49E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scuisupp\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SCStatus.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scuidlg.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    ScUIDlg

Abstract:

    This header file provides the definitions and symbols necessary for an
    Application or Smart Card Service Provider to use the Microsoft Smart
	Card dialogs.

Author:

    Amanda Matlosz (amatlosz) 06/11/1998

Environment:

    Win32

Notes:

	This will be added to winscard.h.

--*/

#ifndef _SCUIDLG_H_
#define _SCUIDLG_H_

#include <winscard.h>

//
// SCardUIDlgGetPIN
//

/*
	GetPIN dialog contains: large icon-sized bitmap for brand name
	standard prompt (caller can't change)
	checkbox for "Change PIN" (like Schlumberger CSP's)

	OnOK() calls lpfnVerifyPIN, raises some error message for 
	"BAD_PIN" and "CARD_LOCKED"

	lpfnVerifyPIN returns a code meaning "OK" "TRY_AGAIN" "CARD_LOCKED"

	returns standard dialog codes: IDOK, IDCANCEL, or ID_ABORT
*/
typedef LONG (WINAPI *LPVERIFYPINPROC) (IN LPSTR, IN PVOID);

typedef struct {
	DWORD			dwStructSize;		// REQUIRED
	HWND			hwndOwner;			// OPTIONAL
	HBITMAP			hBitmap;			// OPTIONAL 32x32 bmp for your brand insignia
	DWORD			dwFlags;			// OPTIONAL only SC_DLG_NOCHANGEPIN currently defined
	BOOL			fChangePin;			// OUT user checked change pin checkbox
	LPVERIFYPINPROC	lpfnVerifyPIN;		// REQUIRED
} PINPROMPT, *PPINPROMPT, *LPPINPROMPT;

extern WINSCARDAPI LONG WINAPI
SCardUIDlgGetPIN(
	LPPINPROMPT);

//
// SCardUIDlgChangePIN
//

/*
	ChangePIN dialog contains: large icon-sized bitmap for brand name
	Some Standard Prompt,
	boxes for old pin, new pin, and confirm new pin

	lpfnChangePIN takes szOldPIN, szNewPIN, and pvUserData; 
	returns a code "OK" "BAD_PIN" (incorrect old pin) "CARD LOCKED" "INVALID_PIN" (new pin is not long enough, etc.)

// TODO: should lpfnChangePIN respond with exact error messages re: invalid (new) pin,
// TODO: like "too short, too long, min length is:X, max length is:X, used invalid characters" etc.???
// TODO: should caller have option of returning an error message to be displayed? (localization issues?)

	returns standard dialog codes: IDOK, IDCANCEL, or ID_ABORT
*/
typedef LONG (WINAPI *LPCHANGEPINPROC) (IN LPSTR, IN LPSTR, IN PVOID);

typedef struct {
	DWORD			dwStructSize;		// REQUIRED
	HWND			hwndOwner;			// OPTIONAL
	HBITMAP			hBitmap;			// OPTIONAL 32x32 bmp for your brand insignia
	LPCHANGEPINPROC	lpfnChangePIN;		// REQUIRED
} CHANGEPIN, *PCHANGEPIN, *LPCHANGEPIN;

extern WINSCARDAPI LONG WINAPI
SCardUIDLgChangePIN(
	LPCHANGEPIN);


#endif // _SCUIDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\scsearch.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScSearch

Abstract:

    This file contains the outline implementation of
    miscellaneous smart card search and check functions
    for the Microsoft Smart Card Common Dialog

Author:

    Amanda Matlosz  5/7/98

Environment:

    Win32, C++ w/Exceptions, MFC

Revision History:


Notes:

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#include "stdafx.h"
// #include <atlconv.cpp>
#include <winscard.h>
#include "ScSearch.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Helpers
//

LPSTR GetCardNameA(SCARDCONTEXT hSCardContext, LPBYTE pbAtr)
{
    LPSTR szCard = NULL;
    DWORD dwNameLength = SCARD_AUTOALLOCATE;

    LONG lReturn = SCardListCardsA(
                        hSCardContext,
                        pbAtr,
                        NULL,
                        0,
                        (LPSTR)&szCard,
                        &dwNameLength);

    if (SCARD_S_SUCCESS != lReturn)
    {
        if (NULL != szCard)
        {
            SCardFreeMemory(hSCardContext, (PVOID)szCard);
            szCard = NULL;
        }
    }

    return szCard;
}


LPWSTR GetCardNameW(SCARDCONTEXT hSCardContext, LPBYTE pbAtr)
{
    LPWSTR szCard = NULL;
    DWORD dwNameLength = SCARD_AUTOALLOCATE;

    LONG lReturn = SCardListCardsW(
                        hSCardContext,
                        pbAtr,
                        NULL,
                        0,
                        (LPWSTR)&szCard,
                        &dwNameLength);

    if (SCARD_S_SUCCESS != lReturn)
    {
        if (NULL != szCard)
        {
            SCardFreeMemory(hSCardContext, (PVOID)szCard);
            szCard = NULL;
        }
    }

    return szCard;
}


DWORD AnsiMStringCount(LPCSTR msz)
{
    DWORD dwRet = 0;

    while (NULL != msz)
    {
        if (NULL == *msz)
        {
            msz = NULL;
        }
        else
        {
            DWORD cchLen = strlen(msz);
            msz = msz+(sizeof(CHAR)*(cchLen+1));
            dwRet++;
        }
    }

    return dwRet;
}


void
MatchInterfacesW(
    SCARDCONTEXT hSCardContext,
    LPCGUID pGUIDInterfaces,
    DWORD cGUIDInterfaces,
    CTextMultistring& mstrAllCards)
{
    //
    // Append all cards that support the requested guidInterfaces
    //

    if (NULL != pGUIDInterfaces && 0 < cGUIDInterfaces)
    {
        LONG lResult = SCARD_S_SUCCESS;
        LPWSTR szListCards = NULL;
        DWORD dwCards = SCARD_AUTOALLOCATE;

        lResult = SCardListCardsW(
        hSCardContext,
        NULL,
        pGUIDInterfaces,
        cGUIDInterfaces,
        (LPWSTR) &szListCards,
        &dwCards);


        if (SCARD_S_SUCCESS == lResult)
        {
            // append them to the list of all possible card names
            mstrAllCards += szListCards;
        }

        if (NULL != szListCards)
        {
            SCardFreeMemory(hSCardContext, (PVOID)szListCards);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Methods
//

/*++

BOOL CheckOCN:

    Routine performs simple parameter checks on OPENCARDNAME and
    OPENCARD_SEARCH_CRITERIA structs

Return Value:

    FALSE if invalid parameter, otherwise TRUE.

Author:

    Amanda Matlosz  09/16/1998

--*/
BOOL CheckOCN(LPOPENCARDNAMEA_EX pOCNA)
{
    if (NULL == pOCNA)
    {
        return FALSE;
    }

    if (pOCNA->dwStructSize != sizeof(OPENCARDNAMEA_EX))
    {
        return FALSE;
    }

    if (NULL == pOCNA->hSCardContext)
    {
        return FALSE;
    }

    if (0 == pOCNA->nMaxRdr || NULL == pOCNA->lpstrRdr)
    {
        return FALSE;
    }

    if (0 == pOCNA->nMaxCard || NULL == pOCNA->lpstrCard)
    {
        return FALSE;
    }

    BOOL fOneFlagOnly = FALSE;
    if (0 != (pOCNA->dwFlags & SC_DLG_MINIMAL_UI))
    {
        fOneFlagOnly = TRUE;
    }
    if (0 != (pOCNA->dwFlags & SC_DLG_FORCE_UI))
    {
        if (fOneFlagOnly)
        {
            return FALSE;
        }
        fOneFlagOnly = TRUE;
    }
    if (0 != (pOCNA->dwFlags & SC_DLG_NO_UI))
    {
        if (fOneFlagOnly)
        {
            return FALSE;
        }
        fOneFlagOnly = TRUE;
    }

    // Now check POPENCARD_SEARCH_CRITERIAA, if applicable
    if (NULL != pOCNA->pOpenCardSearchCriteria)
    {
        DWORD dwShareMode = pOCNA->pOpenCardSearchCriteria->dwShareMode;
        DWORD dwPreferredProtocols = pOCNA->pOpenCardSearchCriteria->dwPreferredProtocols;

        if (NULL != pOCNA->pOpenCardSearchCriteria->lpfnCheck)
        {
            // either lpfnConnect and lpfnDisconnect must be set
            if ( (NULL != pOCNA->pOpenCardSearchCriteria->lpfnConnect) &&
                (NULL != pOCNA->pOpenCardSearchCriteria->lpfnDisconnect) )
            {
                return TRUE;
            }

            if ( (  SCARD_SHARE_EXCLUSIVE == dwShareMode ||
                    SCARD_SHARE_SHARED == dwShareMode ||
                    SCARD_SHARE_DIRECT == dwShareMode ) &&
                (   SCARD_PROTOCOL_T0 == dwPreferredProtocols ||
                    SCARD_PROTOCOL_T1 == dwPreferredProtocols ||
                    (SCARD_PROTOCOL_Tx) == dwPreferredProtocols ||
                    SCARD_PROTOCOL_RAW == dwPreferredProtocols ||
                    SCARD_PROTOCOL_DEFAULT == dwPreferredProtocols ||
                    SCARD_PROTOCOL_OPTIMAL == dwPreferredProtocols )
                    )
            {
                return TRUE;
            }

            return FALSE;
        }
    }

    // if all the tests have passed, it must be OK.
    return TRUE;
}


BOOL CheckOCN(LPOPENCARDNAMEW_EX pOCNW)
{
    if (NULL == pOCNW)
    {
        return FALSE;
    }

    if (pOCNW->dwStructSize != sizeof(OPENCARDNAMEW_EX))
    {
        return FALSE;
    }

    if (NULL == pOCNW->hSCardContext)
    {
        return FALSE;
    }

    if (0 == pOCNW->nMaxRdr || NULL == pOCNW->lpstrRdr)
    {
        return FALSE;
    }

    if (0 == pOCNW->nMaxCard || NULL == pOCNW->lpstrCard)
    {
        return FALSE;
    }

    BOOL fOneFlagOnly = FALSE;
    if (0 != (pOCNW->dwFlags & SC_DLG_MINIMAL_UI))
    {
        fOneFlagOnly = TRUE;
    }
    if (0 != (pOCNW->dwFlags & SC_DLG_FORCE_UI))
    {
        if (fOneFlagOnly)
        {
            return FALSE;
        }
        fOneFlagOnly = TRUE;
    }
    if (0 != (pOCNW->dwFlags & SC_DLG_NO_UI))
    {
        if (fOneFlagOnly)
        {
            return FALSE;
        }
        fOneFlagOnly = TRUE;
    }

    // Now check POPENCARD_SEARCH_CRITERIAW, if applicable
    if (NULL != pOCNW->pOpenCardSearchCriteria)
    {
        DWORD dwShareMode = pOCNW->pOpenCardSearchCriteria->dwShareMode;
        DWORD dwPreferredProtocols = pOCNW->pOpenCardSearchCriteria->dwPreferredProtocols;

        if (NULL != pOCNW->pOpenCardSearchCriteria->lpfnCheck)
        {
            // either lpfnConnect and lpfnDisconnect must be set
            if ( (NULL != pOCNW->pOpenCardSearchCriteria->lpfnConnect) &&
                (NULL != pOCNW->pOpenCardSearchCriteria->lpfnDisconnect) )
            {
                return TRUE;
            }

            if ( (  SCARD_SHARE_EXCLUSIVE == dwShareMode ||
                    SCARD_SHARE_SHARED == dwShareMode ||
                    SCARD_SHARE_DIRECT == dwShareMode ) &&
                (   SCARD_PROTOCOL_T0 == dwPreferredProtocols ||
                    SCARD_PROTOCOL_T1 == dwPreferredProtocols ||
                    (SCARD_PROTOCOL_Tx) == dwPreferredProtocols ||
                    SCARD_PROTOCOL_RAW == dwPreferredProtocols ||
                    SCARD_PROTOCOL_DEFAULT == dwPreferredProtocols ||
                    SCARD_PROTOCOL_OPTIMAL == dwPreferredProtocols )
                )
            {
                return TRUE;
            }

            return FALSE;
        }
    }

    // if all the tests have passed, it must be OK.
    return TRUE;
}


/*++

void ListAllOKCardNames:

    Routine creates a multistring list of card names that match the
    search criteria for both ATR (as determined by the list of card
    names) and supported interfaces.  This list of card names is not
    displayed to the user, but is used internally.

    This is a complete list of possible cards.  Note that the list of
    supported interfaces is an _additive_ criteria, not a restrictive
    one.

    TODO: ?? recheck that assumption re: additive vs. restrictive. ??

Arguments:

    pOCSC - POPENCARD_SEARCH_CRITERIAA

    mstrAllCards - referece to a CTextMultistring to take list of all OK cards

Return Value:

    None.

Author:

    Amanda Matlosz  09/16/1998

--*/
void ListAllOKCardNames(LPOPENCARDNAMEA_EX pOCNA, CTextMultistring& mstrAllCards) // ANSI
{
    POPENCARD_SEARCH_CRITERIAA pOCSC = pOCNA->pOpenCardSearchCriteria;

    if ((NULL == pOCSC) || (NULL == pOCSC->lpstrCardNames))
    {
        // No cards specified
        return;
    }
    mstrAllCards = pOCSC->lpstrCardNames;

    //
    // List all cards that support the requested guidInterfaces
    //

    MatchInterfacesW(
        pOCNA->hSCardContext,
        pOCSC->rgguidInterfaces,
        pOCSC->cguidInterfaces,
        mstrAllCards);

}


void ListAllOKCardNames(LPOPENCARDNAMEW_EX pOCNW, CTextMultistring& mstrAllCards) // UNICODE
{
    POPENCARD_SEARCH_CRITERIAW pOCSC = pOCNW->pOpenCardSearchCriteria;

    if ((NULL == pOCSC) || (NULL == pOCSC->lpstrCardNames))
    {
        // No cards specified
        return;
    }
    mstrAllCards = pOCSC->lpstrCardNames;

    //
    // List all cards that support the requested guidInterfaces
    //

    MatchInterfacesW(
        pOCNW->hSCardContext,
        pOCSC->rgguidInterfaces,
        pOCSC->cguidInterfaces,
        mstrAllCards);
}


// pdwOKCards is used so the caller can decide what additional actions to take
// based on how many suitable cards were found
LONG NoUISearch(OPENCARDNAMEA_EX* pOCN, DWORD* pdwOKCards, LPCSTR mszCards) // ansi-only
{
    USES_CONVERSION;

    _ASSERTE(pOCN != NULL);

    *pdwOKCards = 0;

    LONG lReturn = SCARD_S_SUCCESS;

    SCARD_READERSTATEA* pReaderStatus = NULL;
    DWORD dwReaders = 0;

    const DWORD dwMeetsCriteria = 1;
    LPSTR szGroupNames = NULL;
    LPSTR szReaderNames = NULL;
    DWORD dw=0;
    DWORD dwNameLength = SCARD_AUTOALLOCATE;

    //
    // get list of readers we'll consider
    //

    if (NULL != pOCN->pOpenCardSearchCriteria &&
        NULL != pOCN->pOpenCardSearchCriteria->lpstrGroupNames)
    {
        szGroupNames = pOCN->pOpenCardSearchCriteria->lpstrGroupNames;
    }
    else
    {
        szGroupNames = W2A(SCARD_DEFAULT_READERS);
    }

    lReturn = SCardListReadersA(pOCN->hSCardContext,
        szGroupNames,
        (LPSTR)&szReaderNames,
        &dwNameLength);

    if(SCARD_S_SUCCESS == lReturn)
    {
        //
        // use the list of readers to build a readerstate array
        //
        dwReaders = AnsiMStringCount(szReaderNames);
        _ASSERTE(0 != dwReaders);
        pReaderStatus = new SCARD_READERSTATEA[dwReaders];
        if (NULL != pReaderStatus)
        {
            LPCSTR pchReader = szReaderNames;
            int nIndex = 0;
            while(0 != *pchReader)
            {
                pReaderStatus[nIndex].szReader = pchReader;
                pReaderStatus[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
                pchReader += strlen(pchReader)+1;
                nIndex++;
            }
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }
    }

    //
    // If there are no readers, there's no point to go on.
    //

    if (0 == dwReaders || SCARD_S_SUCCESS != lReturn)
    {
        goto CleanUp;
    }

    //
    // Search for cards: use SCardLocateCards to find cards that match
    // ATR & interfaces supported if mszCards is not empty,
    // otherwise use SCardGetStatusChange() to look for any card
    //

    if (0 < AnsiMStringCount(mszCards))
    {
        lReturn = SCardLocateCardsA(pOCN->hSCardContext,
        mszCards,
        pReaderStatus,
        dwReaders);

        if (SCARD_S_SUCCESS == lReturn)
        {
            // for any that have SCARD_STATE_ATRMATCH set & don't have SCARD_STATE_EXCLUSIVE,
            // set pvUserData to dwMeetsCriteria

            for (dw=0; dw<dwReaders; dw++)
            {
                if ((pReaderStatus[dw].dwEventState & SCARD_STATE_ATRMATCH) &&
                    !(pReaderStatus[dw].dwEventState & SCARD_STATE_EXCLUSIVE))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                }
            }
        }
    }
    else
    {
        lReturn = SCardGetStatusChangeA(
                        pOCN->hSCardContext,
                        0,
                        pReaderStatus,
                        dwReaders);

        if (SCARD_S_SUCCESS == lReturn)
        {
            // for any that have SCARD_STATE_PRESENT & don't have SCARD_STATE_EXCLUSIVE,
            // set pvUserData to dwMeetsCriteria

            for (dw=0; dw<dwReaders; dw++)
            {
                if ((pReaderStatus[dw].dwEventState & SCARD_STATE_PRESENT) &&
                    !(pReaderStatus[dw].dwEventState & SCARD_STATE_EXCLUSIVE))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                }
            }
        }
    }

    //
    // check each card to see if it's OK (meets callback criteria)
    //

    for (dw=0; dw<dwReaders; dw++)
    {
        if (dwMeetsCriteria == (DWORD)((DWORD_PTR)pReaderStatus[dw].pvUserData))
        {
            pReaderStatus[dw].pvUserData = NULL;

            // get the card name for CheckCardCallback;
            // if there's no name, don't accept it

            LPSTR szCard = NULL;
            szCard = GetCardNameA(pOCN->hSCardContext, pReaderStatus[dw].rgbAtr);

            if (NULL != szCard && NULL != *szCard)
            {
                if (CheckCardCallback((LPSTR)pReaderStatus[dw].szReader, szCard, pOCN))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                    (*pdwOKCards)++;
                }
            }

            if (NULL != szCard)
            {
                SCardFreeMemory(pOCN->hSCardContext, (PVOID)szCard);
            }
        }
    }

    //
    // if SC_DLG_MIN_UI and only found one OK card, connect to that one
    // if SC_DLG_NO_UI and found one or more OK card, connect to the first
    //

    if ((0 != (pOCN->dwFlags & SC_DLG_MINIMAL_UI) && 1 == *pdwOKCards) ||
        (0 != (pOCN->dwFlags & SC_DLG_NO_UI) && 1 <= *pdwOKCards))
    {
        DWORD dwSel = 0;
        while (dwSel < dwReaders)
        {
            if (dwMeetsCriteria == (DWORD)((DWORD_PTR)pReaderStatus[dwSel].pvUserData))
            {
                break;
            }

            dwSel++;
        }

        _ASSERTE(dwSel<dwReaders); // Why didn't it find any OK cards?

        // get the card name for SetFinalCardSelection; can be NULL
        LPSTR szCard = NULL;
        szCard = GetCardNameA(pOCN->hSCardContext, pReaderStatus[dwSel].rgbAtr);

        lReturn = SetFinalCardSelection((LPSTR)(pReaderStatus[dwSel].szReader), szCard, pOCN);

        // let go of CardName
        if (NULL != szCard)
        {
            SCardFreeMemory(pOCN->hSCardContext, (PVOID)szCard);
        }
    }
    else
    {
        if (SCARD_S_SUCCESS == lReturn)
        {
            lReturn = SCARD_E_CANCELLED; // any non-SCARD_S_SUCCESS return val will do
        }
    }

CleanUp:

    //
    // Clean up
    //

    if (NULL != pReaderStatus)
    {
        delete [] pReaderStatus;
    }
    if (NULL != szReaderNames)
    {
        SCardFreeMemory(pOCN->hSCardContext, (PVOID)szReaderNames);
    }

    return lReturn;
}


LONG NoUISearch(OPENCARDNAMEW_EX* pOCN, DWORD* pdwOKCards, LPCWSTR mszCards) // UNICODE
{
    _ASSERTE(pOCN != NULL);

    *pdwOKCards = 0;

    LONG lReturn = SCARD_S_SUCCESS;

    SCARD_READERSTATEW* pReaderStatus = NULL;
    DWORD dwReaders = 0;

    const DWORD dwMeetsCriteria = 1;
    LPWSTR szGroupNames = NULL;
    LPWSTR szReaderNames = NULL;
    DWORD dw=0;
    DWORD dwNameLength = SCARD_AUTOALLOCATE;

    //
    // get list of readers we'll consider
    //

    if (NULL != pOCN->pOpenCardSearchCriteria &&
        NULL != pOCN->pOpenCardSearchCriteria->lpstrGroupNames)
    {
        szGroupNames = pOCN->pOpenCardSearchCriteria->lpstrGroupNames;
    }
    else
    {
        szGroupNames = SCARD_DEFAULT_READERS;
    }

    lReturn = SCardListReadersW(pOCN->hSCardContext,
                szGroupNames,
                (LPWSTR)&szReaderNames,
                &dwNameLength);

    if(SCARD_S_SUCCESS == lReturn)
    {
        //
        // use the list of readers to build a readerstate array
        //
        dwReaders = MStringCount(szReaderNames);
        _ASSERTE(0 != dwReaders);
        pReaderStatus = new SCARD_READERSTATEW[dwReaders];
        if (NULL != pReaderStatus)
        {
            LPCWSTR pchReader = szReaderNames;
            int nIndex = 0;
            while(0 != *pchReader)
            {
                pReaderStatus[nIndex].szReader = pchReader;
                pReaderStatus[nIndex].dwCurrentState = SCARD_STATE_UNAWARE;
                pchReader += lstrlen(pchReader)+1;
                nIndex++;
            }
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }
    }

    //
    // If there are no readers, there's no point to go on.
    //

    if (0 == dwReaders)
    {
        goto CleanUp;
    }

    //
    // Search for cards: use SCardLocateCards to find cards that match
    // ATR & interfaces supported if mszCards is not empty,
    // otherwise use SCardGetStatusChange() to look for any card
    //

    if (0 < MStringCount(mszCards))
    {
        lReturn = SCardLocateCardsW(pOCN->hSCardContext,
        mszCards,
        pReaderStatus,
        dwReaders);

        if (SCARD_S_SUCCESS == lReturn)
        {
            // for any that have SCARD_STATE_ATRMATCH set & don't have SCARD_STATE_EXCLUSIVE,
            // set pvUserData to dwMeetsCriteria

            for (dw=0; dw<dwReaders; dw++)
            {
                if ((pReaderStatus[dw].dwEventState & SCARD_STATE_ATRMATCH) &&
                    !(pReaderStatus[dw].dwEventState & SCARD_STATE_EXCLUSIVE))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                }
            }
        }
    }
    else
    {
        lReturn = SCardGetStatusChangeW(
        pOCN->hSCardContext,
        0,
        pReaderStatus,
        dwReaders);

        if (SCARD_S_SUCCESS == lReturn)
        {
            // for any that have SCARD_STATE_PRESENT & don't have SCARD_STATE_EXCLUSIVE,
            // set pvUserData to dwMeetsCriteria

            for (dw=0; dw<dwReaders; dw++)
            {
                if ((pReaderStatus[dw].dwEventState & SCARD_STATE_PRESENT) &&
                    !(pReaderStatus[dw].dwEventState & SCARD_STATE_EXCLUSIVE))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                }
            }
        }
    }

    //
    // check each card to see if it's OK (meets callback criteria)
    //

    for (dw=0; dw<dwReaders; dw++)
    {
        if (dwMeetsCriteria == (DWORD)((DWORD_PTR)pReaderStatus[dw].pvUserData))
        {
            pReaderStatus[dw].pvUserData = NULL;

            // get the card name for CheckCardCallback;
            // if there's no name, don't accept it

            LPWSTR szCard = NULL;
            szCard = GetCardNameW(pOCN->hSCardContext, pReaderStatus[dw].rgbAtr);

            if (NULL != szCard && 0 != lstrlen(szCard))
            {
                if (CheckCardCallback((LPWSTR)pReaderStatus[dw].szReader, szCard, pOCN))
                {
                    pReaderStatus[dw].pvUserData = ULongToHandle(dwMeetsCriteria);
                    (*pdwOKCards)++;
                }
            }

            // let go of CardName
            if (NULL != szCard)
            {
                SCardFreeMemory(pOCN->hSCardContext, (PVOID)szCard);
            }
        }
    }

    //
    // if SC_DLG_MIN_UI and only found one OK card, connect to that one
    // if SC_DLG_NO_UI and found one or more OK card, connect to the first
    //

    if ((0 != (pOCN->dwFlags & SC_DLG_MINIMAL_UI) && 1 == *pdwOKCards) ||
        (0 != (pOCN->dwFlags & SC_DLG_NO_UI) && 1 <= *pdwOKCards))
    {
        DWORD dwSel = 0;
        while (dwSel < dwReaders)
        {
            if (dwMeetsCriteria == (DWORD)((DWORD_PTR)pReaderStatus[dwSel].pvUserData))
            {
                break;
            }

            dwSel++;
        }

        _ASSERTE(dwSel<dwReaders); // Why didn't it find any OK cards?

        // get the card name for SetFinalCardSelection; can be NULL
        LPWSTR szCard = NULL;
        szCard = GetCardNameW(pOCN->hSCardContext, pReaderStatus[dwSel].rgbAtr);

        lReturn = SetFinalCardSelection((LPWSTR)(pReaderStatus[dwSel].szReader), szCard, pOCN);

        // let go of CardName
        if (NULL != szCard)
        {
            SCardFreeMemory(pOCN->hSCardContext, (PVOID)szCard);
        }
    }
    else
    {
        if (SCARD_S_SUCCESS == lReturn)
        {
            lReturn = SCARD_E_CANCELLED; // any non-SCARD_S_SUCCESS return val will do
        }
    }

CleanUp:

    //
    // Clean up
    //

    if (NULL != pReaderStatus)
    {
        delete [] pReaderStatus;
    }
    if (NULL != szReaderNames)
    {
        SCardFreeMemory(pOCN->hSCardContext, (PVOID)szReaderNames);
    }

    return lReturn;
}


/*++

BOOL CheckCardCallback:

    Routine connects to the indicated card/reader, calls user-
    supplied "check" function, and disconnects from card
    according to search criteria members.

Arguments:

    szReader - indicated reader.

    szCard - indicated card name.

    pOCN - OPENCARDNAME_EX struct containing search criteria

Return Value:

    TRUE if connection, check, and disconnection succeeds, otherwise
    FALSE.

Author:

    Amanda Matlosz  07/09/1998

--*/
BOOL CheckCardCallback(LPSTR szReader, LPSTR szCard, OPENCARDNAMEA_EX* pOCN)
{
    BOOL fReturn = FALSE;

    //
    // Check parameters
    //

    // if no check callback, succeed by default
    if (!(NULL != pOCN->pOpenCardSearchCriteria &&
        NULL != pOCN->pOpenCardSearchCriteria->lpfnCheck))
    {
        return TRUE;
    }

    // in order to connect, we either need to have dwShareMode set to non-0
    // or both the conenct and disconnect callbacks have to be valid.
    // This should have been caught in SetOCN()!
    if (0 == pOCN->pOpenCardSearchCriteria->dwShareMode &&
        (NULL == pOCN->pOpenCardSearchCriteria->lpfnConnect
        || NULL == pOCN->pOpenCardSearchCriteria->lpfnDisconnect))
    {
        return FALSE;
    }

    LPOCNCONNPROCA lpfnConnect = pOCN->pOpenCardSearchCriteria->lpfnConnect;
    LPOCNCHKPROC lpfnCheck = pOCN->pOpenCardSearchCriteria->lpfnCheck;
    LPOCNDSCPROC lpfnDisconnect = pOCN->pOpenCardSearchCriteria->lpfnDisconnect;
    PVOID pvUserData = pOCN->pOpenCardSearchCriteria->pvUserData;

    //
    // Connect, preferably through the callback
    //

    SCARDHANDLE hCard = NULL;

    if (NULL != lpfnConnect)
    {
        hCard = lpfnConnect(pOCN->hSCardContext,
                    szReader,
                    szCard,
                    pvUserData);
    }
    else
    {
        DWORD dw = 0; // Don't need to know the active protocol

        LONG lReturn = SCardConnectA(pOCN->hSCardContext,
                            (LPCSTR)szReader,
                            pOCN->pOpenCardSearchCriteria->dwShareMode,
                            pOCN->pOpenCardSearchCriteria->dwPreferredProtocols,
                            &hCard,
                            &dw);

        // TODO: ?? maybe want to trace failure of lReturn... ??
    }

    // if the connect failed, there's no way we can check the card!
    if (NULL == hCard)
    {
        return fReturn;
    }

    //
    // Check the card
    //

    fReturn = lpfnCheck(pOCN->hSCardContext,
                        hCard,
                        pvUserData);

    //
    // Disconnect from the card and clean up.
    //

    if (NULL != lpfnDisconnect)
    {
        lpfnDisconnect(pOCN->hSCardContext,
                        hCard,
                        pvUserData);
    }
    else
    {
        SCardDisconnect(hCard, SCARD_UNPOWER_CARD);
    }

    return fReturn;
}


BOOL CheckCardCallback(LPWSTR szReader, LPWSTR szCard, OPENCARDNAMEW_EX* pOCN)
{
    BOOL fReturn = FALSE;

    //
    // Check parameters
    //

    // if no check callback, succeed by default
    if (!(NULL != pOCN->pOpenCardSearchCriteria &&
        NULL != pOCN->pOpenCardSearchCriteria->lpfnCheck))
    {
        return TRUE;
    }

    // in order to connect, we either need to have dwShareMode set to non-0
    // or both the conenct and disconnect callbacks have to be valid.
    // This should have been caught in SetOCN()!
    if (0 == pOCN->pOpenCardSearchCriteria->dwShareMode &&
        (NULL == pOCN->pOpenCardSearchCriteria->lpfnConnect
        || NULL == pOCN->pOpenCardSearchCriteria->lpfnDisconnect))
    {
        return FALSE;
    }

    LPOCNCONNPROCW lpfnConnect = pOCN->pOpenCardSearchCriteria->lpfnConnect;
    LPOCNCHKPROC lpfnCheck = pOCN->pOpenCardSearchCriteria->lpfnCheck;
    LPOCNDSCPROC lpfnDisconnect = pOCN->pOpenCardSearchCriteria->lpfnDisconnect;
    PVOID pvUserData = pOCN->pOpenCardSearchCriteria->pvUserData;

    //
    // Connect, preferably through the callback
    //

    SCARDHANDLE hCard = NULL;

    if (NULL != lpfnConnect)
    {
        hCard = lpfnConnect(pOCN->hSCardContext,
                            szReader,
                            szCard,
                            pvUserData);
    }
    else
    {
        DWORD dw = 0; // Don't need to know the active protocol

        LONG lReturn = SCardConnectW(pOCN->hSCardContext,
                            (LPCWSTR)szReader,
                            pOCN->pOpenCardSearchCriteria->dwShareMode,
                            pOCN->pOpenCardSearchCriteria->dwPreferredProtocols,
                            &hCard,
                            &dw);

        // TODO: ?? maybe want to trace failure of lReturn... ??
    }

    // if the connect failed, there's no way we can check the card!
    if (NULL == hCard)
    {
        return fReturn;
    }

    //
    // Check the card
    //

    fReturn = lpfnCheck(pOCN->hSCardContext,
                hCard,
                pvUserData);

    //
    // Disconnect from the card and clean up.
    //

    if (NULL != lpfnDisconnect)
    {
        lpfnDisconnect(pOCN->hSCardContext,
                        hCard,
                        pvUserData);
    }
    else
    {
        SCardDisconnect(hCard, SCARD_UNPOWER_CARD);
    }

    return fReturn;
}


/*++

BOOL CheckCardAll:

    Routine checks to see whether or not the indicated card meets
    the search criteria.  ATR, supported interfaces, and callbacks
    are all checked.

Arguments:

    pReader - Reader containing card to check acceptability of

    pOCN - OPENCARDNAME[A|W]_EX struct containing search criteria, etc.

    mszCards - a multistring containing names of ALL acceptable cards

Return Value:

    A BOOL value indicating the acceptibility of the given card.

Author:

    Amanda Matlosz  07/09/1998

--*/
BOOL CheckCardAll(CSCardReaderState* pReader, OPENCARDNAMEA_EX* pOCN, LPCWSTR mszCards) // ANSI
{
    USES_CONVERSION;

    BOOL fReturn = FALSE; // assume no match

    _ASSERTE(NULL != pReader && NULL != pOCN);
    if (NULL == pReader || NULL == pOCN)
    {
        return FALSE;
    }

    // Check Name & interfaces

    if (!pReader->strCard.IsEmpty())
    {
        LPCWSTR msz = mszCards;
        if (0 < MStringCount(msz))
        {
            msz = FirstString(mszCards);
            while (!fReturn && msz != NULL)
            {
                // compare if OK fReturn = TRUE;
                if (0 == pReader->strCard.Compare(msz) || 0==lstrlen(msz))
                {
                    fReturn = TRUE;
                }
                else
                {
                    msz = NextString(msz);
                }
            }
        }
        else
        {
            fReturn = TRUE;
        }
    }

    // Check Callback

    if (fReturn)
    {
        // turn CStrings into LPSTRs
        LPSTR szReader = W2A(pReader->strReader);
        LPSTR szCard = W2A(pReader->strCard);

        fReturn = CheckCardCallback(szReader, szCard, pOCN);
    }

    // note in readerstate whether or not the card passed all tests
    pReader->fOK = fReturn;

    return fReturn;
}


BOOL CheckCardAll(CSCardReaderState* pReader, OPENCARDNAMEW_EX* pOCN, LPCWSTR mszCards) // UNICODE
{
    BOOL fReturn = FALSE; // assume no match

    _ASSERTE(NULL != pReader && NULL != pOCN);
    if (NULL == pReader || NULL == pOCN)
    {
        return FALSE;
    }

    // Check Name & interfaces

    if (!pReader->strCard.IsEmpty())
    {
        LPCWSTR msz = mszCards;
        if (0 < MStringCount(msz))
        {
            msz = FirstString(mszCards);
            while (!fReturn && msz != NULL)
            {
                // compare if OK fReturn = TRUE;
                if (0 == pReader->strCard.Compare(msz) || 0==lstrlen(msz))
                {
                    fReturn = TRUE;
                }
                else
                {
                    msz = NextString(msz);
                }
            }
        }
        else
        {
            fReturn = TRUE;
        }
    }

    // Check Callback

    if (fReturn)
    {
        // turn CStrings into LPSTRs
        LPWSTR szReader = pReader->strReader.GetBuffer(1);
        LPWSTR szCard = pReader->strCard.GetBuffer(1);

        fReturn = CheckCardCallback(szReader, szCard, pOCN);

        pReader->strReader.ReleaseBuffer();
        pReader->strCard.ReleaseBuffer();
    }

    // note in readerstate whether or not the card passed all tests
    pReader->fOK = fReturn;

    return fReturn;
}


/*++

LONG SetFinalCardSelection:

    Routine connects to a selected reader, and sets the user-provided structs
    to contain the reader&cardname.  Returns an error if the user-provided struct's
    buffers aren't long enough.

Arguments:

    dwSelectedReader - index used to select which reader to connect to.

Return Value:

    A LONG value indicating the status of the requested action.
    See the Smartcard header files for additional information.

Author:

    Amanda Matlosz  07/09/1998

--*/
LONG SetFinalCardSelection(LPSTR szReader, LPSTR szCard, OPENCARDNAMEA_EX* pOCN) // ANSI
{
    _ASSERTE(NULL != pOCN);

    pOCN->hCardHandle = NULL;
    LONG lReturn = SCARD_S_SUCCESS;

    //
    // Set return values in OCN
    //

	if (NULL == szReader)
	{
		lReturn = SCARD_F_INTERNAL_ERROR;
	}
	else
	{
		if (pOCN->nMaxRdr >= strlen(szReader)+1)
		{
			::CopyMemory(   (LPVOID)pOCN->lpstrRdr,
							(CONST LPVOID)szReader,
							strlen(szReader)+1);
		}
		else
		{
			pOCN->nMaxRdr = strlen(szReader)+1;
			lReturn = SCARD_E_NO_MEMORY;
		}
	}

    if (SCARD_S_SUCCESS == lReturn)
    {
		if (NULL == szCard)
		{
			lReturn = SCARD_F_INTERNAL_ERROR;
		}
		else
		{
			if (pOCN->nMaxCard >= strlen(szCard)+1)
			{
				::CopyMemory(   (LPVOID)pOCN->lpstrCard,
								(CONST LPVOID)szCard,
								strlen(szCard)+1);
			}
			else
			{
				pOCN->nMaxCard = strlen(szCard)+1;
				lReturn = SCARD_E_NO_MEMORY;
			}
		}
	}
    //
    // Connect to card only if we're still in a successful state,
    //

    if (SCARD_S_SUCCESS == lReturn)
    {
        if(NULL != pOCN->lpfnConnect)
        {
            pOCN->hCardHandle = pOCN->lpfnConnect(
            pOCN->hSCardContext,
            szReader,
            szCard,
            pOCN->pvUserData);
        }
        else if (0 != pOCN->dwShareMode)
        {
            lReturn = SCardConnectA(pOCN->hSCardContext,
            (LPCSTR)szReader,
            pOCN->dwShareMode,
            pOCN->dwPreferredProtocols,
            &pOCN->hCardHandle,
            &pOCN->dwActiveProtocol);

            if (SCARD_S_SUCCESS != lReturn)
            {
                // must return hCardHandle of NULL
                pOCN->hCardHandle = NULL;
            }
        }
    }

    return lReturn;
}


LONG SetFinalCardSelection(LPWSTR szReader, LPWSTR szCard, OPENCARDNAMEW_EX* pOCN) // UNICODE
{
    _ASSERTE(NULL != pOCN);

    pOCN->hCardHandle = NULL;
    LONG lReturn = SCARD_S_SUCCESS;

    //
    // Set return values in OCN
    //

	if (NULL == szReader)
	{
		lReturn = SCARD_F_INTERNAL_ERROR;
	}
	else
	{
		if (pOCN->nMaxRdr >= (DWORD)lstrlen(szReader)+1)
		{
			::CopyMemory(   (LPVOID)pOCN->lpstrRdr,
							(CONST LPVOID)szReader,
							sizeof(WCHAR)*(lstrlen(szReader)+1));
		}
		else
		{
			pOCN->nMaxRdr = lstrlen(szReader)+1;
			lReturn = SCARD_E_NO_MEMORY;
		}
	}

    if (SCARD_S_SUCCESS == lReturn)
    {
		if (NULL == szCard)
		{
			lReturn = SCARD_F_INTERNAL_ERROR;
		}
		else
		{
			if (pOCN->nMaxCard >= (DWORD)lstrlen(szCard)+1)
			{
				::CopyMemory(   (LPVOID)pOCN->lpstrCard,
								(CONST LPVOID)szCard,
								sizeof(WCHAR)*(lstrlen(szCard)+1));
			}
			else
			{
				pOCN->nMaxCard = lstrlen(szCard)+1;
				lReturn = SCARD_E_NO_MEMORY;
			}
		}
	}

    //
    // Connect to card only if we're still in a successful state,
    //

    if (SCARD_S_SUCCESS == lReturn)
    {
        if(NULL != pOCN->lpfnConnect)
        {
            pOCN->hCardHandle = pOCN->lpfnConnect(
            pOCN->hSCardContext,
            szReader,
            szCard,
            pOCN->pvUserData);
        }
        else if (0 != pOCN->dwShareMode)
        {
            lReturn = SCardConnectW(pOCN->hSCardContext,
            (LPCWSTR)szReader,
            pOCN->dwShareMode,
            pOCN->dwPreferredProtocols,
            &pOCN->hCardHandle,
            &pOCN->dwActiveProtocol);

            if (SCARD_S_SUCCESS != lReturn)
            {
                // must return hCardHandle of NULL
                pOCN->hCardHandle = NULL;
            }
        }
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scuisupp\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
#define AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

// Include multi-thread classes
#include <afxmt.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#include <atlconv.h>		// ATL Conversion macros

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2F127496_0854_11D1_BC85_00C04FC298B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\buffers.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    buffers

Abstract:

    This header file provides dynamic buffer and string classes for general use.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32, C++ w/ Exception Handling

Notes:



--*/

#ifndef _BUFFERS_H_
#define _BUFFERS_H_


//
//==============================================================================
//
//  CBuffer
//

class CBuffer
{
public:

    //  Constructors & Destructor

    CBuffer()           // Default Initializer
    { Initialize(); };

    CBuffer(            // Initialize with starting length.
        IN DWORD cbLength)
    { Initialize();
      Presize(cbLength, FALSE); };

    CBuffer(            // Initialize with starting data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength)
    { Initialize();
      Set(pbSource, cbLength); };

    virtual ~CBuffer()  // Tear down.
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void);        // Free up any allocated memory.

    LPBYTE
    Reset(void);        // Return to default state (don't loose memory.)

    LPBYTE
    Presize(            // Make sure the buffer is big enough.
        IN DWORD cbLength,
        IN BOOL fPreserve = FALSE);

    LPBYTE
    Resize(         // Make sure the buffer & length are the right size.
        DWORD cbLength,
        BOOL fPreserve = FALSE);

    LPBYTE
    Set(            // Load a value.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    LPBYTE
    Append(         // Append more data to the existing data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    DWORD
    Length(         // Return the length of the data.
        void) const
    { return m_cbDataLength; };

    DWORD
    Space(          // Return the length of the buffer.
        void) const
    { return m_cbBufferLength; };

    LPBYTE
    Access(         // Return the data, starting at an offset.
        DWORD offset = 0)
    const
    {
        if (m_cbBufferLength <= offset)
            return (LPBYTE)TEXT("\x00");
        else
            return &m_pbBuffer[offset];
    };

    int
    Compare(
        const CBuffer &bfSource)
    const;


    //  Operators

    CBuffer &
    operator=(
        IN const CBuffer &bfSource)
    { Set(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    CBuffer &
    operator+=(
        IN const CBuffer &bfSource)
    { Append(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    BYTE &
    operator[](
        DWORD offset)
        const
    { return *Access(offset); };

    int
    operator==(
        IN const CBuffer &bfSource)
        const
    { return 0 == Compare(bfSource); };

    int
    operator!=(
        IN const CBuffer &bfSource)
        const
    { return 0 != Compare(bfSource); };

    operator LPCBYTE(void)
    { return (LPCBYTE)Access(); };

    operator LPCTSTR(void)
    { return (LPCTSTR)Access(); };


protected:

    //  Properties

    LPBYTE m_pbBuffer;
    DWORD m_cbDataLength;
    DWORD m_cbBufferLength;


    //  Methods

    void
    Initialize(void)
    {
        m_pbBuffer = NULL;
        m_cbDataLength = 0;
        m_cbBufferLength = 0;
    };

    CBuffer(           //  Object assignment constructor.
        IN const CBuffer &bfSourceOne,
        IN const CBuffer &bfSourceTwo);

    friend
        CBuffer &
        operator+(
            IN const CBuffer &bfSourceOne,
            IN const CBuffer &bfSourceTwo);
};

#endif // _BUFFERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scarddlg\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// Include the template class(s)
#include <afxtempl.h>

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <atlbase.h>

// Define local message for notification
#ifndef _WM_READERSTATUSCHANGE
#define WM_READERSTATUSCHANGE		(WM_USER+1)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\noncom.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    noncom

Abstract:

    This header file describes the implementation of the Non-Com subsystem.

Author:

    Doug Barlow (dbarlow) 1/4/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _NONCOM_H_
#define _NONCOM_H_
#ifndef __cplusplus
        #error NonCOM requires C++ compilation (use a .cpp suffix)
#endif
// #define UNDER_TEST

#ifdef _UNICODE
    #ifndef UNICODE
        #define UNICODE         // UNICODE is used by Windows headers
    #endif
#endif

#ifdef UNICODE
    #ifndef _UNICODE
        #define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
    #endif
#endif

#ifdef _DEBUG
    #ifndef DEBUG
        #define DEBUG
    #endif
#endif

STDAPI_(void)
NoCoStringFromGuid(
    IN LPCGUID pguidResult,
    OUT LPTSTR szGuid);

#ifdef UNDER_TEST
STDAPI
NoCoInitialize(
    LPVOID pvReserved);

STDAPI_(void)
NoCoUninitialize(
    void);
#endif

STDAPI
NoCoGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv);

STDAPI
NoCoCreateInstance(
    REFCLSID rclsid,
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppv);

#ifdef SCARD_NO_COM
#define CoGetClassObject(rclsid, dwClsContext, pServerInfo, riid, ppv) \
    NoCoGetClassObject(rclsid, riid, ppv)
#define CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv) \
    NoCoCreateInstance(rclsid, pUnkOuter, riid, ppv)
#define CoCreateInstanceEx(rclsid, punkOuter, dwClsCtx, pServerInfo, cmq, pResults) \
    NoCoCreateInstanceEx(rclsid, punkOuter, cmq, pResults)
#endif

#endif // _NONCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\changedb.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    changeDB

Abstract:

    This header file defines the internal Calais Database modification routines.

Author:

    Doug Barlow (dbarlow) 1/29/1997

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _CHANGEDB_H_
#define _CHANGEDB_H_

extern void
IntroduceReaderGroup(
    IN DWORD dwScope,
    IN LPCTSTR szGroupName);

extern void
ForgetReaderGroup(
    IN DWORD dwScope,
    IN LPCTSTR szGroupName);

extern void
IntroduceReader(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szDeviceName);

extern void
ForgetReader(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName);

extern void
AddReaderToGroup(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szGroupName);

extern void
RemoveReaderFromGroup(
    IN DWORD dwScope,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szGroupName);

extern void
IntroduceCard(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen);

extern void
SetCardTypeProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCTSTR szProvider);

extern void
ForgetCard(
    IN DWORD dwScope,
    IN LPCTSTR szCardName);

#ifdef ENABLE_SCARD_TEMPLATES
extern void
IntroduceCardTypeTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen);

extern void
SetCardTypeTemplateProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szTemplateName,
    IN DWORD dwProviderId,
    IN LPCTSTR szProvider);

extern void
ForgetCardTypeTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName);

extern void
IntroduceCardTypeFromTemplate(
    IN DWORD dwScope,
    IN LPCTSTR szVendorName,
    IN LPCTSTR szFriendlyName = NULL);
#endif // ENABLE_SCARD_TEMPLATES

#endif // _CHANGEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\clbmisc.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ClbMisc

Abstract:

    This header file describes the miscellaneous services of the Calais Library.

Author:

    Doug Barlow (dbarlow) 7/16/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _CLBMISC_H_
#define _CLBMISC_H_

#include <stdio.h>
#include <tchar.h>

//
// Miscellaneous definitions.
//

extern int
MemCompare(             // Non CRTL memory compare routine.
    IN LPCBYTE pbOne,
    IN LPCBYTE pbTwo,
    IN DWORD cbLength);

extern DWORD
MStrAdd(                // Add an ANSI string to a multistring.
    IN OUT CBuffer &bfMsz,
    IN LPCSTR szAdd);
extern DWORD
MStrAdd(                // Add a wide string to a multistring.
    IN OUT CBuffer &bfMsz,
    IN LPCWSTR szAdd);

extern DWORD
MStrLen(               // Return the length of an ANSI Multistring, in chars.
    LPCSTR mszString);
extern DWORD
MStrLen(               // Return the length of a wide Multistring, in chars.
    LPCWSTR mszString);

extern LPCTSTR
FirstString(            // Return first string segment in a multistring.
    IN LPCTSTR szMultiString);

extern LPCTSTR
NextString(             // Return next string segment in a multistring.
    IN LPCTSTR szMultiString);

extern LPCTSTR
StringIndex(            // Return n'th string segment in a multistring.
    IN LPCTSTR szMultiString,
    IN DWORD dwIndex);

extern DWORD
MStringCount(
        LPCTSTR mszInString);   // count strings in multistring

extern DWORD
MStringSort(            // Sort multistring, removing duplicates.
    LPCTSTR mszInString,
    CBuffer &bfOutString);

extern DWORD
MStringMerge(           // Merge two multistrings, eliminating duplicates.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern DWORD
MStringCommon(          // Get the intersection of two multistrings.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern DWORD
MStringRemove(          // Remove 2nd string entries from 1st string.
    LPCTSTR mszOne,
    LPCTSTR mszTwo,
    CBuffer &bfOutString);

extern BOOL
ParseAtr(               // Parse a smartcard ATR string.
    LPCBYTE pbAtr,
    LPDWORD pdwAtrLen = NULL,
    LPDWORD pdwHistOffset = NULL,
    LPDWORD pcbHistory = NULL,
    DWORD cbMaxLen = 33);

extern BOOL
AtrCompare(             // Compare an ATR to an ATR/Mask pair.
    LPCBYTE pbAtr1,
    LPCBYTE pbAtr2,
    LPCBYTE pbMask,  // = NULL
    DWORD cbAtr2);  // = 0

extern DWORD
MoveString(             // Move an ANSI string into a buffer, converting to
    CBuffer &bfDst,     // TCHARs.
    LPCSTR szSrc,
    DWORD dwLength = (DWORD)(-1));

extern DWORD
MoveString(             // Move a UNICODE string into a buffer, converting to
    CBuffer &bfDst,     // TCHARs.
    LPCWSTR szSrc,
    DWORD dwLength = (DWORD)(-1));

extern DWORD
MoveToAnsiString(       // Move a string into a UNICODE buffer, converting from
    LPSTR szDst,        // TCHARs.
    LPCTSTR szSrc,
    DWORD cchLength);

extern DWORD
MoveToUnicodeString(    // Move a string into an ANSI buffer, converting from
    LPWSTR szDst,       // TCHARs.
    LPCTSTR szSrc,
    DWORD cchLength);

extern DWORD
MoveToAnsiMultiString(  // Move a multistring into an ANSI buffer, converting
    LPSTR mszDst,       // from TCHARs.
    LPCTSTR mszSrc,
    DWORD cchLength);

extern DWORD
MoveToUnicodeMultiString(   // Move a multistring into a UNICODE buffer,
    LPWSTR mszDst,          // converting from TCHARs.
    LPCTSTR mszSrc,
    DWORD cchLength);

extern LPCTSTR
ErrorString(                // Convert an error code into a string.
    DWORD dwErrorCode);

extern void
FreeErrorString(            // Free the string returned from ErrorString.
    LPCTSTR szErrorString);

extern DWORD
SelectString(               // Index a given string against a list of possible
    LPCTSTR szSource,       // strings.  Last parameter is NULL.
    ...);

extern void
StringFromGuid(
    IN LPCGUID pguidResult, // GUID to convert to text
    OUT LPTSTR szGuid);     // 39+ character buffer to receive GUID as text.


//
//==============================================================================
//
//  CErrorString
//
//  A trivial class to simplify the use of the ErrorString service.
//

class CErrorString
{
public:

    //  Constructors & Destructor
    CErrorString(DWORD dwError = 0)
    {
        m_szErrorString = NULL;
        SetError(dwError);
    };

    ~CErrorString()
    {
		if (m_szErrorString != m_szHexError)
			FreeErrorString(m_szErrorString);
    };

    //  Properties
    //  Methods
    void SetError(DWORD dwError)
    {
        m_dwError = dwError;
    };

    LPCTSTR Value(void)
    {
		LPCTSTR szErr = NULL;
		if (m_szErrorString != m_szHexError)
	        FreeErrorString(m_szErrorString);
		try {
			szErr = ErrorString(m_dwError);
		} catch (...) {}
		if (NULL == szErr)
		{
			_stprintf(m_szHexError, _T("0x%08x"), m_dwError);
			m_szErrorString = m_szHexError;
		}
		else
			m_szErrorString = szErr;
        return m_szErrorString;
    };

    //  Operators
    operator LPCTSTR(void)
    {
        return Value();
    };

protected:
    //  Properties
    DWORD m_dwError;
    LPCTSTR m_szErrorString;
	TCHAR m_szHexError[11];		// Big enough to hold 0x%08x\0

    //  Methods
};

#endif // _CLBMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\handles.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    handles

Abstract:

    This header file describes the handle management service.

Author:

    Doug Barlow (dbarlow) 5/9/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _HANDLES_H_
#define _HANDLES_H_

#ifndef HANDLE_TYPE
#define HANDLE_TYPE DWORD_PTR
#endif

#if defined(_WIN64) || defined(WIN64)
static const DWORD_PTR
    HANDLE_INDEX_MASK   = 0x000000007fffffff,
    HANDLE_COUNT_MASK   = 0x00ffffff00000000,
    HANDLE_ID_MASK      = 0xff00000000000000;
static const DWORD
    HANDLE_INDEX_OFFSET = 0,
    HANDLE_COUNT_OFFSET = 32,
    HANDLE_ID_OFFSET    = 56;
#elif defined(_WIN32) || defined(WIN32)
static const DWORD_PTR
    HANDLE_INDEX_MASK   = 0x0000ffff,
    HANDLE_COUNT_MASK   = 0x00ff0000,
    HANDLE_ID_MASK      = 0xff000000;
static const DWORD
    HANDLE_INDEX_OFFSET = 0,
    HANDLE_COUNT_OFFSET = 16,
    HANDLE_ID_OFFSET    = 24;
#else
#error "Unsupported handle type length"
#endif

class CHandleList;


//
//==============================================================================
//
//  CCritSect
//

class CCritSect
{
public:
    CCritSect(LPCRITICAL_SECTION pCritSect)
    {
        m_pCritSect = pCritSect;
        EnterCriticalSection(m_pCritSect);
    };

    ~CCritSect()
    {
        LeaveCriticalSection(m_pCritSect);
    };

protected:
    LPCRITICAL_SECTION m_pCritSect;
};


//
//==============================================================================
//
//  CHandle
//

class CHandle
{
public:
    BOOL IsBad(void)
    { return m_fIsBad;};

protected:
    //  Constructors & Destructor

    CHandle()
    {
        m_dwCount = 0;
        m_dwIndex = (DWORD)(HANDLE_INDEX_MASK >> HANDLE_INDEX_OFFSET);
        m_fIsBad = FALSE;
    };

    virtual ~CHandle() { /* Mandatory Base Class Destructor */ };


    //  Properties

    DWORD m_dwCount;
    DWORD m_dwIndex;
    BOOL m_fIsBad;


    //  Methods

    virtual void Cancel(void) {};
    virtual void MarkAsBad(BOOL fCancel)
    {
        m_fIsBad = TRUE;
        if (fCancel)
            Cancel();
    };

    friend class CHandleList;
};


//
//==============================================================================
//
//  CHandleList
//

class CHandleList
{
public:

    //  Constructors & Destructor

    CHandleList(DWORD dwHandleId)
    {
        m_dwId = dwHandleId;
        m_Max = m_Mac = 0;
        m_phList = NULL;
        m_fInitFailed = FALSE;

        try {
            if (! InitializeCriticalSectionAndSpinCount(
                    &m_critSect, 0x80000000))
                m_fInitFailed = TRUE;
        }
        catch (HRESULT hr) {
            m_fInitFailed = TRUE;
        }
    };

    virtual ~CHandleList()
    {
        if (m_fInitFailed)
            return;

        Clear();
        DeleteCriticalSection(&m_critSect);
    };


    //  Properties
    //  Methods

    DWORD Count(void)
    {
        CCritSect csLock(&m_critSect);
        return m_Mac;
    };

    void
    Clear(void)
    {
        CCritSect csLock(&m_critSect);
        if (NULL != m_phList)
        {
            for (DWORD index = 0; index < m_Mac; index += 1)
                if (NULL != m_phList[index].phObject)
                    delete m_phList[index].phObject;
            delete[] m_phList;
            m_phList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    CHandle *
    Close(
        IN HANDLE_TYPE hItem);

    HANDLE_TYPE
    Add(
        IN CHandle *phItem);

    CHandle * const
    GetQuietly(
        IN HANDLE_TYPE hItem);

    CHandle * const
    Get(
        IN HANDLE_TYPE hItem);

    HANDLE_TYPE
    IndexHandle(
        DWORD nItem);

    BOOL
    InitFailed(void)
    { return m_fInitFailed; }


    //  Operators

    CHandle * const
    operator[](HANDLE_TYPE hItem)
    { return Get(hItem); };

    void MarkContentAsBad(BOOL fCancel)
    {
        CCritSect csLock(&m_critSect);
        if (NULL != m_phList)
        {
            for (DWORD index = 0; index < m_Mac; index += 1)
            {
                if (NULL != m_phList[index].phObject)
                    m_phList[index].phObject->MarkAsBad(fCancel);
            }
        }
    }

    CHandle *
    GetFirst()
    {
        DWORD index = 0;

        while (index < m_Mac)
        {
            if (NULL != m_phList[index].phObject)
                return (m_phList[index].phObject);

            index++;
        }

        return NULL;
    }

    CHandle * 
    GetNext(
        IN CHandle * phObject)
    {
        DWORD index = 0;

        while (index < m_Mac)
        {
            if (phObject == m_phList[index].phObject)
                break;

            index++;
        }

        if (index < m_Mac)
        {
            index++;

            while (index < m_Mac)
            {
                if (NULL != m_phList[index].phObject)
                    return (m_phList[index].phObject);
    
                index++;
            }  
        }

        return NULL;
    }

protected:

    struct HandlePtr
    {
        CHandle *phObject;
        DWORD dwCount;
    };

    //  Properties


    DWORD
        m_dwId;          // Id number of handle list.
    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    HandlePtr *
        m_phList;       // The elements.
    CRITICAL_SECTION
        m_critSect;     // Handle list access control.
    BOOL
        m_fInitFailed;  // InitCritSec failed in constructor

    //  Methods

    HandlePtr *
    GetHandlePtr(
        IN HANDLE_TYPE hItem)
    const;
};


/*++

Close:

    This routine closes an item in the handle array.

Arguments:

    hItem - Supplies the handle to the object to be closed.

Throws:

    ERROR_INVALID_HANDLE - The supplied handle value is invalid.


Return Value:

    The referenced object.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle *
CHandleList::Close(
    IN HANDLE_TYPE hItem)
{
    CHandle *phItem;
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        throw (DWORD)ERROR_INVALID_HANDLE;

    phItem = pHandlePtr->phObject;
    if (NULL == phItem)
        throw (DWORD)ERROR_INVALID_HANDLE;
    pHandlePtr->phObject = NULL;
    pHandlePtr->dwCount += 1;
    return phItem;
}


/*++

Add:

    This method adds an item to the Handle list.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The resultant handle of the Add operation.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

inline HANDLE_TYPE
CHandleList::Add(
    IN CHandle *phItem)
{
    DWORD index;
    HandlePtr * pHndl = NULL;


    //
    // Look for a vacant handle slot.  We look through m_Max instead of m_Mac,
    // so that if all the official ones are used, we fall into unused territory.
    //

    CCritSect csLock(&m_critSect);
    for (index = 0; index < m_Max; index += 1)
    {
        pHndl = &m_phList[index];
        if (NULL == pHndl->phObject)
            break;
        pHndl = NULL;
    }


    //
    // Make sure the array was big enough.
    //

    if (NULL == pHndl)
    {
        DWORD newSize = (0 == m_Max ? 4 : m_Max * 2);
        if ((HANDLE_INDEX_MASK >> HANDLE_INDEX_OFFSET) < newSize)
            throw (DWORD)ERROR_OUTOFMEMORY;
        pHndl = new HandlePtr[newSize];
        if (NULL == pHndl)
            throw (DWORD)ERROR_OUTOFMEMORY;
        if (NULL != m_phList)
        {
            CopyMemory(pHndl, m_phList, sizeof(HandlePtr) * m_Mac);
            delete[] m_phList;
        }
        ZeroMemory(&pHndl[m_Mac], sizeof(HandlePtr) * (newSize - m_Mac));
        m_phList = pHndl;
        m_Max = (DWORD)newSize;
        index = m_Mac++;
        pHndl = &m_phList[index];
    }
    else
    {
        if (m_Mac <= index)
            m_Mac = index + 1;
    }


    //
    // Cross index the list element and the object.
    //

    ASSERT(NULL == pHndl->phObject);
    pHndl->phObject = phItem;
    if (0 == pHndl->dwCount)
        pHndl->dwCount = 1;
    phItem->m_dwCount = (DWORD)(pHndl->dwCount
                                & (HANDLE_COUNT_MASK >> HANDLE_COUNT_OFFSET));
    phItem->m_dwIndex = index;
    return (HANDLE_TYPE)(
                  ((((HANDLE_TYPE)m_dwId)          << HANDLE_ID_OFFSET)   & HANDLE_ID_MASK)
                | ((((HANDLE_TYPE)pHndl->dwCount) << HANDLE_COUNT_OFFSET) & HANDLE_COUNT_MASK)
                | ((((HANDLE_TYPE)index)          << HANDLE_INDEX_OFFSET) & HANDLE_INDEX_MASK));
}


/*++

GetQuietly:

    This method returns the element at the given handle.  If the handle is
    invalid, it returns NULL.  It does not expand the array.

Arguments:

    hItem - Supplies the index into the list.

Return Value:

    The value stored at that handle in the list, or NULL if the handle is
    invalid.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle * const
CHandleList::GetQuietly(
    HANDLE_TYPE hItem)
{
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        return NULL;
    return pHandlePtr->phObject;
}


/*++

Get:

    This method returns the element at the given handle.  If the handle is
    invalid, it throws an error.  It does not expand the array.

Arguments:

    hItem - Supplies the index into the list.

Return Value:

    The value stored at that handle in the list.

Throws:

    ERROR_INVALID_HANDLE - Invalid handle value.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

inline CHandle * const
CHandleList::Get(
    HANDLE_TYPE hItem)
{
    CCritSect csLock(&m_critSect);
    HandlePtr *pHandlePtr = GetHandlePtr(hItem);
    if (NULL == pHandlePtr)
        throw (DWORD)ERROR_INVALID_HANDLE;
    return pHandlePtr->phObject;
}


/*++

GetHandlePtr:

    This routine finds the HandlePtr structure corresponding to a given handle.

Arguments:

    hItem supplies the handle to look up.

Return Value:

    The address of the HandlePtr structure corresponding to the handle, or NULL
    if none exists.

Author:

    Doug Barlow (dbarlow) 5/9/1996

--*/

inline CHandleList::HandlePtr *
CHandleList::GetHandlePtr(
    HANDLE_TYPE hItem)
    const
{
    try
    {
        HandlePtr *pHandlePtr;
        DWORD_PTR dwItem  = (DWORD_PTR)hItem;
        DWORD dwId    = (DWORD)((dwItem & HANDLE_ID_MASK)    >> HANDLE_ID_OFFSET);
        DWORD dwCount = (DWORD)((dwItem & HANDLE_COUNT_MASK) >> HANDLE_COUNT_OFFSET);
        DWORD dwIndex = (DWORD)((dwItem & HANDLE_INDEX_MASK) >> HANDLE_INDEX_OFFSET);

        if (dwId != (m_dwId & (HANDLE_ID_MASK >> HANDLE_ID_OFFSET))
                || (m_Mac <= dwIndex))
            return NULL;

        pHandlePtr = &m_phList[dwIndex];
        if (dwCount
                != (pHandlePtr->dwCount
                    & (HANDLE_ID_MASK >> HANDLE_ID_OFFSET)))
            return NULL;

        return pHandlePtr;
    }
    catch (...)
    {
        // Swallow the error.
    }
    return NULL;
}


/*++

IndexHandle:

    This method converts an index into a handle.  The handle is NULL if there is
    no element stored at that index.

Arguments:

    nItem supplies the index of the object to reference.

Return Value:

    The handle of the object, or NULL if there is no object at that index.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/3/1997

--*/

inline HANDLE_TYPE
CHandleList::IndexHandle(
    DWORD nItem)
{
    HANDLE_TYPE hItem = NULL;
    HandlePtr * pHndl;

    CCritSect csLock(&m_critSect);
    if (m_Mac > nItem)
    {
        pHndl = &m_phList[nItem];
        if (NULL != pHndl->phObject)
        {
            hItem =
                  ((((HANDLE_TYPE)m_dwId)         << HANDLE_ID_OFFSET) & HANDLE_ID_MASK)
                | ((((HANDLE_TYPE)pHndl->dwCount) << HANDLE_COUNT_OFFSET) & HANDLE_COUNT_MASK)
                | ((((HANDLE_TYPE)nItem)          << HANDLE_INDEX_OFFSET) & HANDLE_INDEX_MASK);
        }
    }
    return hItem;
}

#endif // _HANDLES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\ntacls.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    NTacls

Abstract:

    This header file describes the classes used in managing ACLs within Calais.

Author:

    Doug Barlow (dbarlow) 1/24/1997

Environment:

    Windows NT, Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _NTACLS_H_
#define _NTACLS_H_

#include <wtypes.h>
#include <Malloc.h>
#include "buffers.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor

class CSecurityDescriptor
{
public:

    typedef struct {
        SID_IDENTIFIER_AUTHORITY sid;
        DWORD dwRidCount;   // Actual number of RIDs following
        DWORD rgRids[2];
    } SecurityId;

    static const SecurityId
        SID_Null,
        SID_World,
        SID_Local,
        SID_Owner,
        SID_Group,
        SID_Admins,
        SID_SrvOps,
        SID_DialUp,
        SID_Network,
        SID_Batch,
        SID_Interactive,
        SID_Service,
        SID_System,
        SID_LocalService,
        SID_SysDomain;

    CSecurityDescriptor();
	~CSecurityDescriptor();

public:
	PSECURITY_DESCRIPTOR m_pSD;
	PSID m_pOwner;
	PSID m_pGroup;
	PACL m_pDACL;
	PACL m_pSACL;
	SECURITY_ATTRIBUTES m_saAttrs;
	BOOL m_fInheritance;


public:
	HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
	HRESULT AttachObject(HANDLE hObject);
	HRESULT Initialize();
	HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
	HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
	HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
	HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
	HRESULT Allow(const SecurityId *psidPrincipal, DWORD dwAccessMask);
	HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT AllowOwner(DWORD dwAccessMask);
	HRESULT Deny(const SecurityId *psidPrincipal, DWORD dwAccessMask);
	HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Revoke(LPCTSTR pszPrincipal);
	void	SetInheritance (BOOL fInheritance) {m_fInheritance = fInheritance;};

	HRESULT AddAccessAllowedACEToACL(PACL *Acl, DWORD dwAccessMask);

	// utility functions
	// Any PSID you get from these functions should be free()ed
	static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
	static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
	static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
	static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
	static HRESULT CopyACL(PACL pDest, PACL pSrc);
	static HRESULT GetCurrentUserSID(PSID *ppSid);
	static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, const SecurityId *psidPrincipal, DWORD dwAccessMask);
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, const SecurityId *psidPrincipal, DWORD dwAccessMask);
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

	operator PSECURITY_DESCRIPTOR()
	{
		return m_pSD;
	}

	operator LPSECURITY_ATTRIBUTES();

};



#endif // _NTACLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\querydb.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    QueryDB

Abstract:

    This header file provides the definitions of the Calais Query Database
    utility routines.

Author:

    Doug Barlow (dbarlow) 11/25/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _QUERYDB_H_
#define _QUERYDB_H_

extern void
ListReaderGroups(
    IN DWORD dwScope,
    OUT CBuffer &bfGroups);

extern void
ListReaders(
    IN DWORD dwScope,
    IN LPCTSTR mszGroups,
    OUT CBuffer &bfReaders);

extern void
ListReaderNames(
    IN DWORD dwScope,
    IN LPCTSTR szDevice,
    OUT CBuffer &bfNames);

extern void
ListCards(
    DWORD dwScope,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT CBuffer &bfCards);

extern BOOL
GetReaderInfo(
    IN DWORD dwScope,
    IN LPCTSTR szReader,
    OUT CBuffer *pbfGroups = NULL,
    OUT CBuffer *pbfDevice = NULL);

extern BOOL
GetCardInfo(
    IN DWORD dwScope,
    IN LPCTSTR szCard,
    OUT CBuffer *pbfAtr,
    OUT CBuffer *pbfAtrMask,
    OUT CBuffer *pbfInterfaces,
    OUT CBuffer *pbfProvider);

extern void
GetCardTypeProviderName(
    IN DWORD dwScope,
    IN LPCTSTR szCardName,
    IN DWORD dwProviderId,
    OUT CBuffer &bfProvider);

#ifdef ENABLE_SCARD_TEMPLATES
extern BOOL
ListCardTypeTemplates(
    IN  DWORD dwScope,
    IN  LPCBYTE pbAtr,
    OUT CBuffer &bfTemplates);
#endif // ENABLE_SCARD_TEMPLATES

#endif // _QUERYDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\controls\scuisupp\scuisupp.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    scuisupp

Abstract:

    Support for smart card certificate selection UI

Author:

    Klaus Schutz

--*/

#include "stdafx.h"
#include <wincrypt.h>
#include <winscard.h>
#include <winwlx.h>
#include <string.h>

#include "calaislb.h"
#include "scuisupp.h"
#include "StatMon.h"    // smart card reader status monitor
#include "scevents.h"

#include <mmsystem.h>

typedef struct _READER_DATA 
{
	CERT_ENUM			CertEnum;
	LPTSTR				pszReaderName;
	LPTSTR				pszCardName;
	LPTSTR				pszCSPName;

} READER_DATA, *PREADER_DATA;

typedef struct _THREAD_DATA
{
	// handle to heap of this thread
	HANDLE				hHeap;

	// the smart card context we use
	SCARDCONTEXT		hSCardContext;	

	// the window we send messages to
	HWND				hWindow;

	// event to signal that the monitor thread can terminate
	HANDLE				hClose;

	// thread handle for the monitor thread
    HANDLE				hThread;

	// number of readers detected
	DWORD				dwNumReaders;

	// messages to be sent to parent
	UINT				msgReaderArrival;
	UINT				msgReaderRemoval;
	UINT				msgSmartCardInsertion;
	UINT				msgSmartCardRemoval;
	UINT				msgSmartCardStatus;
	UINT				msgSmartCardCertAvail;

	// reader state array
	PSCARD_READERSTATE	rgReaders;

	// number of removed readers
	DWORD				dwRemovedReaders;

	// pointer array of removed reader data 
	PREADER_DATA		*ppRemovedReaderData;

} THREAD_DATA, *PTHREAD_DATA;

#ifndef TEST

#define SC_DEBUG(a) 

#else

#define SC_DEBUG(a) _DebugPrint a

#undef PostMessage
#define PostMessage(a,b,c,d) _PostMessage(a, b, c, d)

#undef RegisterWindowMessage
#define RegisterWindowMessage(a) _RegisterWindowMessage(a)

void
__cdecl
_DebugPrint(
    LPCTSTR szFormat,
    ...
    )
{
    TCHAR szBuffer[1024];
    va_list ap;

    va_start(ap, szFormat);
    _vstprintf(szBuffer, szFormat, ap);
    OutputDebugString(szBuffer); 
	_tprintf(szBuffer);
}

#define MAX_MESSAGES 10

static struct {

	UINT	dwMessage;
	LPCTSTR lpMessage;

} Messages[MAX_MESSAGES];

UINT
_RegisterWindowMessage(
	LPCTSTR lpString
	)
{
	for (DWORD dwIndex = 0; dwIndex < MAX_MESSAGES; dwIndex += 1) {

		if (Messages[dwIndex].lpMessage == NULL) {

			break;
		}

		if (_tcscmp(lpString, Messages[dwIndex].lpMessage) == 0) {

			return Messages[dwIndex].dwMessage;
		}
	}

	Messages[dwIndex].lpMessage = lpString;
	Messages[dwIndex].dwMessage = dwIndex;

	return dwIndex;
}

LPCTSTR
_GetWindowMessageString(
	UINT dwMessage
	)
{
	for (DWORD dwIndex = 0; dwIndex < MAX_MESSAGES; dwIndex += 1) {

		if (Messages[dwIndex].lpMessage == NULL) {

			return  TEXT("(NOT DEFINED)");
		}

		if (dwMessage == Messages[dwIndex].dwMessage) {

			return Messages[dwIndex].lpMessage;
		}
	}

	return TEXT("(INTERNAL ERROR)");
}

LRESULT
_PostMessage(
	HWND hWindow,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam
	)
{
	SC_DEBUG((TEXT("Received message %s\n"), _GetWindowMessageString(Msg)));

	return 0;	
}

#endif

static 
LPCTSTR
FirstString(
    IN LPCTSTR szMultiString
    )
/*++

FirstString:

    This routine returns a pointer to the first string in a multistring, or NULL
    if there aren't any.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the first null-terminated string in the structure, or NULL if
    there are no strings.

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/
{
    LPCTSTR szFirst = NULL;

    try
    {
        if (0 != *szMultiString)
            szFirst = szMultiString;
    }
    catch (...) {}

    return szFirst;
}

static
LPCTSTR
NextString(
    IN LPCTSTR szMultiString)
/*++

NextString:

    In some cases, the Smartcard API returns multiple strings, separated by Null
    characters, and terminated by two null characters in a row.  This routine
    simplifies access to such structures.  Given the current string in a
    multi-string structure, it returns the next string, or NULL if no other
    strings follow the current string.

Arguments:

    szMultiString - This supplies the address of the current position within a
         Multi-string structure.

Return Value:

    The address of the next Null-terminated string in the structure, or NULL if
    no more strings follow.

Author:

    Doug Barlow (dbarlow) 8/12/1996

--*/
{
    LPCTSTR szNext;

    try
    {
        DWORD cchLen = lstrlen(szMultiString);
        if (0 == cchLen)
            szNext = NULL;
        else
        {
            szNext = szMultiString + cchLen + 1;
            if (0 == *szNext)
                szNext = NULL;
        }
    }

    catch (...)
    {
        szNext = NULL;
    }

    return szNext;
}

static 
void
FreeReaderData(
	PTHREAD_DATA pThreadData,
	PREADER_DATA pReaderData
	)
{
	if (pThreadData->hSCardContext && pReaderData->pszCardName) {

		SCardFreeMemory(pThreadData->hSCardContext, pReaderData->pszCardName);
		pReaderData->pszCardName = NULL;
		pReaderData->CertEnum.pszCardName = NULL;
	}

	if (pThreadData->hSCardContext && pReaderData->pszCSPName) {

		SCardFreeMemory(pThreadData->hSCardContext, pReaderData->pszCSPName);
		pReaderData->pszCSPName = NULL;
	}

	if (pReaderData->CertEnum.pCertContext) {

		CertFreeCertificateContext(pReaderData->CertEnum.pCertContext);
		pReaderData->CertEnum.pCertContext = NULL;
	}

	pReaderData->CertEnum.dwStatus = 0;
}

static
void 
UpdateCertificates(
	PTHREAD_DATA pThreadData,
	PSCARD_READERSTATE pReaderState
	)
{
	PREADER_DATA pReaderData = (PREADER_DATA) pReaderState->pvUserData;

	FreeReaderData(pThreadData, pReaderData);

	SC_DEBUG((TEXT("Enumerating certificates on %s...\n"), pReaderState->szReader));

	LPTSTR pszContainerName = NULL;
	LPTSTR pszDefaultContainerName = NULL;
	PBYTE pbCert = NULL;
	HCRYPTKEY hKey = NULL;
	HCRYPTPROV hCryptProv = NULL;

	__try {

		pReaderData->CertEnum.dwStatus = SCARD_F_UNKNOWN_ERROR;

		// Get the name of the card
		DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
		LONG lReturn = SCardListCards(   
			pThreadData->hSCardContext,
			pReaderState->rgbAtr,
			NULL,
			0,
			(LPTSTR)&pReaderData->pszCardName,
			&dwAutoAllocate
			);

		if (lReturn != SCARD_S_SUCCESS) {

			SC_DEBUG((TEXT("Failed to get card name for card in %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = lReturn;
			__leave;
		}

		pReaderData->CertEnum.pszCardName = pReaderData->pszCardName;

		dwAutoAllocate = SCARD_AUTOALLOCATE;
		lReturn = SCardGetCardTypeProviderName(
			pThreadData->hSCardContext,
			pReaderData->pszCardName,
			SCARD_PROVIDER_CSP,
			(LPTSTR)&pReaderData->pszCSPName,
			&dwAutoAllocate
			);

		if (lReturn != SCARD_S_SUCCESS) {

			SC_DEBUG((TEXT("Failed to get CSP name from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = SCARD_E_UNKNOWN_CARD;
			__leave;
		}

		pszContainerName = (LPTSTR) HeapAlloc(
			pThreadData->hHeap,
			HEAP_ZERO_MEMORY, 
			(_tcslen(pReaderState->szReader) + 10) * sizeof(TCHAR)
			);

		if (pszContainerName == NULL) {

			pReaderData->CertEnum.dwStatus = SCARD_E_NO_MEMORY;
			__leave;
		}

		_stprintf(
			pszContainerName, 
			TEXT("\\\\.\\%s\\"),  
			pReaderState->szReader);

		BOOL fSuccess = CryptAcquireContext(
			&hCryptProv,
			pszContainerName, 
			pReaderData->pszCSPName,
			PROV_RSA_FULL,
			CRYPT_SILENT 
			);

		if (fSuccess == FALSE) {

			SC_DEBUG((
				TEXT("Failed to acquire context on %s (%lx)\n"), 
				pReaderState->szReader, GetLastError()
				));

			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		// Get the default container name, so we can use it
		DWORD cbDefaultContainerName;
		fSuccess = CryptGetProvParam(
			hCryptProv,
			PP_CONTAINER,
			NULL,
			&cbDefaultContainerName,
			0
			);

		if (!fSuccess) {

			SC_DEBUG((TEXT("Failed to get default container name from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		pszDefaultContainerName = 
			(LPTSTR) HeapAlloc(pThreadData->hHeap, HEAP_ZERO_MEMORY, cbDefaultContainerName * sizeof(TCHAR));

		if (NULL == pszContainerName) {

			pReaderData->CertEnum.dwStatus = SCARD_E_NO_MEMORY;
			__leave;
		}

		fSuccess = CryptGetProvParam(
			hCryptProv,
			PP_CONTAINER,
			(PBYTE)pszDefaultContainerName,
			&cbDefaultContainerName,
			0
			);

		if (!fSuccess) {

			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		fSuccess = CryptGetUserKey(
			hCryptProv,
			AT_KEYEXCHANGE,
			&hKey
			);

		if (fSuccess == FALSE) {

			SC_DEBUG((TEXT("Failed to get key from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		// get length of certificate
		DWORD cbCertLen = 0;
		fSuccess = CryptGetKeyParam(
			hKey,
			KP_CERTIFICATE,
			NULL,
			&cbCertLen, 
			0
			);

		DWORD dwError = GetLastError();

		if (fSuccess == FALSE && dwError != ERROR_MORE_DATA) {

			SC_DEBUG((TEXT("Failed to get certificate from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		pbCert = (LPBYTE) HeapAlloc(pThreadData->hHeap, HEAP_ZERO_MEMORY, cbCertLen);

		if (pbCert == NULL)
		{
			pReaderData->CertEnum.dwStatus = SCARD_E_NO_MEMORY;
			__leave;
		}

		// read the certificate off the card
		fSuccess = CryptGetKeyParam(
			hKey,
			KP_CERTIFICATE,
			pbCert,
			&cbCertLen,
			0
			);

		if (fSuccess == FALSE) {

			SC_DEBUG((TEXT("Failed to get certificate from %s\n"), pReaderState->szReader));
			pReaderData->CertEnum.dwStatus = GetLastError();
			__leave;
		}

		PCERT_CONTEXT pCertContext = (PCERT_CONTEXT) CertCreateCertificateContext(
			X509_ASN_ENCODING,
			pbCert,
			cbCertLen
			);

		if (pCertContext == NULL) {

			__leave;
		}

		pReaderData->CertEnum.dwStatus = SCARD_S_SUCCESS;
		pReaderData->CertEnum.pCertContext = pCertContext;
		SC_DEBUG((TEXT("Found new certificate on %s\n"), pReaderState->szReader));

		PostMessage(
			pThreadData->hWindow, 
			pThreadData->msgSmartCardCertAvail, 
			(WPARAM) &pReaderData->CertEnum,
			0 
			);
    } 

	__finally {

		//
		// free all allocated memory
		//
 		if (NULL != pszContainerName)
		{
			HeapFree(pThreadData->hHeap, 0, pszContainerName);
		}

		if (NULL != pszDefaultContainerName)
		{
			HeapFree(pThreadData->hHeap, 0, pszDefaultContainerName);
		}

		if (NULL != pbCert)
		{
			HeapFree(pThreadData->hHeap, 0, pbCert);                                    
		}

		if (NULL != hKey)
		{
			CryptDestroyKey(hKey);
		}

		if (NULL != hCryptProv)
		{
			CryptReleaseContext(hCryptProv, 0);
		}
	}
}

static
void
StopMonitorReaders(
    PTHREAD_DATA pThreadData
    )
{
    _ASSERT(pThreadData != NULL);

    SetEvent(pThreadData->hClose);

    if (pThreadData->hSCardContext) {
     	
        SCardCancel(pThreadData->hSCardContext);  	
    }
}

static 
void
RemoveCard(
	PTHREAD_DATA pThreadData,
	PREADER_DATA pReaderData
	)
{
	SC_DEBUG((TEXT("Smart Card removed from %s\n"), pReaderData->CertEnum.pszReaderName));

	PostMessage(
		pThreadData->hWindow, 
		pThreadData->msgSmartCardRemoval, 
		(WPARAM) &pReaderData->CertEnum,
		0					
		);
}

static
BOOL
AddReader(
	PTHREAD_DATA pThreadData,
	LPCTSTR pszNewReader
	)
{
	PSCARD_READERSTATE pScardReaderState = 
		(PSCARD_READERSTATE) HeapReAlloc(
		   pThreadData->hHeap,
		   HEAP_ZERO_MEMORY,
		   pThreadData->rgReaders, 
		   (pThreadData->dwNumReaders + 1) * (sizeof(SCARD_READERSTATE))
		   );

	if (pScardReaderState == NULL) {

		return FALSE;
	}

	pThreadData->rgReaders = pScardReaderState;

	PREADER_DATA pReaderData = 
		(PREADER_DATA) HeapAlloc(
			pThreadData->hHeap, 
			HEAP_ZERO_MEMORY, 
			sizeof(READER_DATA)
			);

	if (pReaderData == NULL) {

		return FALSE;
	}

	pThreadData->rgReaders[pThreadData->dwNumReaders].pvUserData = 
		pReaderData;

	LPTSTR pszReaderName = 
		(LPTSTR) HeapAlloc(
			pThreadData->hHeap, 
			HEAP_ZERO_MEMORY, 
			(_tcslen(pszNewReader) + 1) * sizeof(TCHAR)
			);

	if (pszReaderName == NULL) {

		return FALSE;		
	}

	_tcscpy(pszReaderName, pszNewReader);

	pReaderData->pszReaderName = pszReaderName;

	pThreadData->rgReaders[pThreadData->dwNumReaders].szReader = 
		pszReaderName;

	pThreadData->rgReaders[pThreadData->dwNumReaders].dwCurrentState = 
		SCARD_STATE_EMPTY;

	pReaderData->CertEnum.pszReaderName = (LPTSTR) pszReaderName;
	pThreadData->dwNumReaders++;

	PostMessage(
		pThreadData->hWindow,
		pThreadData->msgReaderArrival,
		(WPARAM) &pReaderData->CertEnum,
		0
		);

	return TRUE;
}

static
BOOL
RemoveReader(
	PTHREAD_DATA pThreadData,
	PSCARD_READERSTATE pReaderState
	)
{
	PREADER_DATA pReaderData = 
		(PREADER_DATA) pReaderState->pvUserData;

	if (pReaderState->dwCurrentState & SCARD_STATE_PRESENT) {

		RemoveCard(
			pThreadData,
			pReaderData
			);
	}

	SC_DEBUG((TEXT("Reader %s removed\n"), pReaderData->CertEnum.pszReaderName));

	PostMessage(
		pThreadData->hWindow,
		pThreadData->msgReaderRemoval,
		(WPARAM) &pReaderData->CertEnum,
		0
		);

	// build an array of reader data that needs to be deleted on exit
	PREADER_DATA *ppRemovedReaderData = NULL;

	if (pThreadData->dwRemovedReaders == 0) {

		ppRemovedReaderData = (PREADER_DATA *) HeapAlloc(
			pThreadData->hHeap,
			HEAP_ZERO_MEMORY, 
			sizeof(PREADER_DATA)
			);

	} else {

		ppRemovedReaderData = (PREADER_DATA *) HeapReAlloc(
			pThreadData->hHeap,
			HEAP_ZERO_MEMORY,
			pThreadData->ppRemovedReaderData, 
			(pThreadData->dwRemovedReaders + 1) * sizeof(PREADER_DATA)
			);
	}

	if (ppRemovedReaderData == NULL) {

		return FALSE;
	}

	// add the reader data to the list of stuff that needs to be freed on exit
	pThreadData->ppRemovedReaderData = ppRemovedReaderData;
	pThreadData->ppRemovedReaderData[pThreadData->dwRemovedReaders] = pReaderData;

	for (DWORD dwIndex = 1; dwIndex < pThreadData->dwNumReaders; dwIndex += 1) {

		if (pReaderState == &pThreadData->rgReaders[dwIndex]) {

			// check if the reader we remove is not the last or the only one.
			if (pThreadData->dwNumReaders > 1 && dwIndex != pThreadData->dwNumReaders - 1) {

				// put the reader from the end of the list into this available slot
				pThreadData->rgReaders[dwIndex] = 
					pThreadData->rgReaders[pThreadData->dwNumReaders - 1];
			}

			// shrink the reader state array
			PSCARD_READERSTATE pReaders = (PSCARD_READERSTATE) HeapReAlloc(
				pThreadData->hHeap,
				0,
				pThreadData->rgReaders,
				(pThreadData->dwNumReaders - 1) * sizeof(SCARD_READERSTATE)
				);

			if (pReaders == NULL) {

				 return FALSE;
			}

			pThreadData->rgReaders = pReaders;

			break;
		}
	}

	pThreadData->dwNumReaders -= 1;
	pThreadData->dwRemovedReaders += 1;

	return TRUE;
}

static
BOOL
RemoveAllReaders(
	PTHREAD_DATA pThreadData
	)
{
	if (pThreadData->rgReaders == NULL) {

		return TRUE;
	}

		// This loop will destroy all the readers starting with the first one
		// dwIndex doesn't have to be incremented. pThreadData->dwNumReaders is
		// decremented in RemoveReader
	for (DWORD dwIndex = 1; dwIndex < pThreadData->dwNumReaders; ) {

		if (RemoveReader(
			   pThreadData,
			   &pThreadData->rgReaders[dwIndex]
			   ) == FALSE) {

			return FALSE;
		}
	}

		// Remove the PnP pseudo reader
	HeapFree(
		pThreadData->hHeap, 
		0, 
		pThreadData->rgReaders
		);
	pThreadData->rgReaders = NULL;

	return TRUE;
}

static 
DWORD
StartMonitorReaders( 
	LPVOID pData
    )
{
    PTHREAD_DATA pThreadData = (PTHREAD_DATA) pData;
	LPCTSTR szReaderNameList = NULL;

    //
    // We use this outer loop to restart in case the 
    // resource manager was stopped
    //
	__try {

		pThreadData->rgReaders = 
			(PSCARD_READERSTATE) HeapAlloc(
				pThreadData->hHeap, 
				HEAP_ZERO_MEMORY, 
				sizeof(SCARD_READERSTATE)
				);

		if (pThreadData->rgReaders == NULL) {

			__leave;
		}

		pThreadData->rgReaders[0].szReader = SCPNP_NOTIFICATION;
		pThreadData->rgReaders[0].dwCurrentState = 0;
		pThreadData->dwNumReaders = 1;

		while (WaitForSingleObject(pThreadData->hClose, 0) == WAIT_TIMEOUT) {

			// Acquire context with resource manager
			LONG lReturn = SCardEstablishContext(
				SCARD_SCOPE_USER,
				NULL,
				NULL,
				&pThreadData->hSCardContext
				);

			if (SCARD_S_SUCCESS != lReturn) {

				// The prev. call should never fail
				// It's better to terminate this thread.
				__leave;
			}

			szReaderNameList = NULL;
			DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
			// now list the available readers
			lReturn = SCardListReaders( 
				pThreadData->hSCardContext,
				SCARD_DEFAULT_READERS,
				(LPTSTR)&szReaderNameList,
				&dwAutoAllocate
				);

			if (SCARD_S_SUCCESS == lReturn)
			{
				// bugbug - this pointer should not be modified
				for (LPCTSTR szReader = FirstString( szReaderNameList ); 
					 szReader != NULL; 
					 szReader = NextString(szReader)) {

					BOOL fFound = FALSE;

					// now check if this reader is already in the reader array
					for (DWORD dwIndex = 1; dwIndex < pThreadData->dwNumReaders; dwIndex++) {

						if (lstrcmp(
							   szReader, 
							   pThreadData->rgReaders[dwIndex].szReader
							   ) == 0) {

							fFound = TRUE;
							break;
						}
					}

					if (fFound == FALSE) {

						if (AddReader(pThreadData, szReader) == FALSE) {

							__leave;
						}
					}
				}
			}

			BOOL fNewReader = FALSE;

			// analyze newly inserted cards 
			while (WaitForSingleObject(pThreadData->hClose, 0) == WAIT_TIMEOUT &&
				   fNewReader == FALSE) {

				lReturn = SCardGetStatusChange( 
					pThreadData->hSCardContext,
					INFINITE,
					pThreadData->rgReaders,
					pThreadData->dwNumReaders
					);

				if (SCARD_E_SYSTEM_CANCELLED == lReturn) {

					// the smart card system has been stopped
					// send notification that all readers are gone
					if (RemoveAllReaders(pThreadData) == FALSE) {

						__leave;
					}

					// Wait until it restarted
					HANDLE hCalaisStarted = CalaisAccessStartedEvent();

					if (hCalaisStarted == NULL) {

						// no way to recover. stop cert prop
						StopMonitorReaders(pThreadData);
						break;             	
					}

					HANDLE lHandles[2] = { hCalaisStarted, pThreadData->hClose };

					lReturn = WaitForMultipleObjectsEx(
						2,
						lHandles,
						FALSE,
						INFINITE,
						FALSE
						);         
            
					if (lReturn != WAIT_OBJECT_0) {

						// We stop if an error occured
						StopMonitorReaders(pThreadData);
						break;             	
					}

					// Otherwise the resource manager has been restarted
					break;
				}

				if (SCARD_S_SUCCESS != lReturn)
				{
					StopMonitorReaders(pThreadData);
					break;
				}

				// Enumerate the readers and for every card change send a message
 				for (DWORD dwIndex = 1; dwIndex < pThreadData->dwNumReaders; dwIndex++)
				{
					// Check if the reader has been removed
					if ((pThreadData->rgReaders[dwIndex].dwEventState & SCARD_STATE_UNAVAILABLE)) {

						if (RemoveReader(
							   pThreadData,
							   &pThreadData->rgReaders[dwIndex]
							   ) == FALSE) {

							__leave;
						}

							// Continue the loop with the same index
						dwIndex--;
						continue;
					}

					// check if this is a card insertion
					if ((pThreadData->rgReaders[dwIndex].dwCurrentState & SCARD_STATE_EMPTY) &&
						(pThreadData->rgReaders[dwIndex].dwEventState & SCARD_STATE_PRESENT)) {

						PREADER_DATA pReaderData = 
							(PREADER_DATA) pThreadData->rgReaders[dwIndex].pvUserData;

						SC_DEBUG((TEXT("Smart Card inserted into %s\n"), pThreadData->rgReaders[dwIndex].szReader));

						PostMessage(
							pThreadData->hWindow, 
							pThreadData->msgSmartCardInsertion, 
							(WPARAM) &pReaderData->CertEnum,
							0 
							);

						// read in all certificates
						UpdateCertificates(
							pThreadData,
							&pThreadData->rgReaders[dwIndex]
							);

						PostMessage(
							pThreadData->hWindow, 
							pThreadData->msgSmartCardStatus, 
							(WPARAM) &pReaderData->CertEnum,
							0 
							);
					}

					// check if this is a card removal
					if ((pThreadData->rgReaders[dwIndex].dwCurrentState & SCARD_STATE_PRESENT) &&
						(pThreadData->rgReaders[dwIndex].dwEventState & SCARD_STATE_EMPTY)) {

						PREADER_DATA pReaderData = (PREADER_DATA) pThreadData->rgReaders[dwIndex].pvUserData;

						RemoveCard(pThreadData,	pReaderData);

						// we can't update the certificates because it would delete
						// some memory data that the caller could reference.
					}

					// Update the "current state" of this reader
					pThreadData->rgReaders[dwIndex].dwCurrentState = 
						pThreadData->rgReaders[dwIndex].dwEventState;
				}

				// check if a new reader showed up
				if ((pThreadData->dwNumReaders == 1 || 
					 pThreadData->rgReaders[0].dwCurrentState != 0) && 
					 pThreadData->rgReaders[0].dwEventState & SCARD_STATE_CHANGED) {
                
					fNewReader = TRUE;
				}

				pThreadData->rgReaders[0].dwCurrentState = 
					pThreadData->rgReaders[0].dwEventState;

			}

			// Clean up
			if (NULL != szReaderNameList)
			{
				SCardFreeMemory(pThreadData->hSCardContext, (PVOID) szReaderNameList);
				szReaderNameList = NULL;
			}

			if (NULL != pThreadData->hSCardContext)                 
			{
				SCardReleaseContext(pThreadData->hSCardContext);
				pThreadData->hSCardContext = NULL;
			}
		}
	}
	__finally {

		if (NULL != szReaderNameList)
		{
			SCardFreeMemory(pThreadData->hSCardContext, (PVOID) szReaderNameList);
		}

		if (NULL != pThreadData->hSCardContext)                 
		{
			SCardReleaseContext(pThreadData->hSCardContext);
			pThreadData->hSCardContext = NULL;
		}

		RemoveAllReaders(pThreadData);

		SC_DEBUG((TEXT("Terminating monitor thread\n")));
	}

    return TRUE;
}

HSCARDUI 
WINAPI
SCardUIInit(
    HWND hWindow
    )
{
	PTHREAD_DATA pThreadData = 
		(PTHREAD_DATA) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(THREAD_DATA));

	BOOL fSuccess = FALSE;

    __try {

		if (pThreadData == NULL) {

			__leave;
		}

		pThreadData->hHeap = GetProcessHeap();

		pThreadData->hWindow = hWindow;

		pThreadData->msgReaderArrival = 
			RegisterWindowMessage(TEXT(SCARDUI_READER_ARRIVAL));
		pThreadData->msgReaderRemoval = 
			RegisterWindowMessage(TEXT(SCARDUI_READER_REMOVAL));
		pThreadData->msgSmartCardInsertion = 
			RegisterWindowMessage(TEXT(SCARDUI_SMART_CARD_INSERTION));
		pThreadData->msgSmartCardRemoval = 
			RegisterWindowMessage(TEXT(SCARDUI_SMART_CARD_REMOVAL));
		pThreadData->msgSmartCardStatus = 
			RegisterWindowMessage(TEXT(SCARDUI_SMART_CARD_STATUS));
 		pThreadData->msgSmartCardCertAvail = 
			RegisterWindowMessage(TEXT(SCARDUI_SMART_CARD_CERT_AVAIL));

       pThreadData->hClose = CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

        if (pThreadData->hClose == NULL) {

            __leave;         	
        }

        pThreadData->hThread = CreateThread(
            NULL,
            0,
            StartMonitorReaders,
            (LPVOID) pThreadData,         
	        CREATE_SUSPENDED,
            NULL
            );

        if (pThreadData->hThread == NULL) {

            __leave;         	
        }

        ResumeThread(pThreadData->hThread);

		fSuccess = TRUE;
    }

    __finally {

		if (fSuccess == FALSE) {

			if (pThreadData && pThreadData->hClose) {

				CloseHandle(pThreadData->hClose);
			}

			if (pThreadData) {

				HeapFree(pThreadData->hHeap, 0, pThreadData);
				pThreadData = NULL;
			}
		}
    }

    return (HSCARDUI) pThreadData;
}

DWORD 
WINAPI
SCardUIExit(
	HSCARDUI hSCardUI
    )
/*++

Routine Description:
    Stops cert. propagation when the user logs out.

Arguments:
    lpvParam - Winlogon notification info.

--*/
{
	PTHREAD_DATA pThreadData = (PTHREAD_DATA) hSCardUI;

	if(NULL != pThreadData->hThread)
	{
        DWORD dwStatus;

        StopMonitorReaders(pThreadData);

        dwStatus = WaitForSingleObject(
            pThreadData->hThread, 
            INFINITE
            );
        _ASSERT(dwStatus == WAIT_OBJECT_0);

        CloseHandle(pThreadData->hClose);

		// now free all data
		for (DWORD dwIndex = 0; dwIndex < pThreadData->dwRemovedReaders; dwIndex++) {

			FreeReaderData(
				pThreadData,
				pThreadData->ppRemovedReaderData[dwIndex]
				);

			HeapFree(
				pThreadData->hHeap, 
				0, 
				pThreadData->ppRemovedReaderData[dwIndex]->pszReaderName
				);

			HeapFree(
				pThreadData->hHeap, 
				0, 
				pThreadData->ppRemovedReaderData[dwIndex]
				);
		}

		HeapFree(pThreadData->hHeap, 0, pThreadData);
	}

    return ERROR_SUCCESS;
}

#ifdef TEST
#include <conio.h>
__cdecl
main(
    int argc,
    char ** argv
    )
{
	HSCARDUI hScardUi;

	hScardUi = SCardUIInit(NULL);

	while (TRUE) {

		_sleep(1000);

		if (_kbhit()) {

			_getch();
			SCardUIExit(hScardUi);
			break;
		}
	}

	hScardUi = SCardUIInit(NULL);

	while (TRUE) {

		_sleep(1000);

		if (_kbhit()) {

			SCardUIExit(hScardUi);
			return 0;
		}
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\calaislb.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CalaisLb

Abstract:

    This header file incorporates the various other header files of classes
    supported by the Calais Library, and provides for common definitions.
    Things defined by this header file shouldn't be shared with the public.

Author:

    Doug Barlow (dbarlow) 7/16/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _CALAISLB_H_
#define _CALAISLB_H_

#include "SCardLib.h"
#include "QueryDB.h"
#include "ChangeDB.h"
#include "NTacls.h"


//
////////////////////////////////////////////////////////////////////////////////
//
//  Registry access names.
//

static const TCHAR
    SCARD_REG_SCARD[]     = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais"),
    SCARD_REG_READERS[]   = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers"),
    SCARD_REG_CARDS[]     = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
    SCARD_REG_DEVICE[]    = TEXT("Device"),
    SCARD_REG_GROUPS[]    = TEXT("Groups"),
    SCARD_REG_ATR[]       = TEXT("ATR"),
    SCARD_REG_ATRMASK[]   = TEXT("ATRMask"),
    SCARD_REG_GUIDS[]     = TEXT("Supported Interfaces"),
    SCARD_REG_PPV[]       = TEXT("Primary Provider"),
    SCARD_REG_CSP[]       = TEXT("Crypto Provider"),
    SCARD_REG_OEMCFG[]    = TEXT("OEM Configuration");
#ifdef ENABLE_SCARD_TEMPLATES
static const TCHAR
    SCARD_REG_TEMPLATES[] = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCard Templates");
#else
#define SCARD_REG_TEMPLATES NULL
#endif // ENABLE_SCARD_TEMPLATES
#endif // _CALAISLB_H_
=== C:/Users/treeman/Desk