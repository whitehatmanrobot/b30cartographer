sStr( *ppszDirString );
            *ppszDirString = NULL;
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   DirectoryStrings
//
// Synopsis:   This function is used to process ldap schema elements 
//          of the form qdstrings. This is defined in the RFC in detail :
//
//    space           = 1*" "
//    whsp            = [ space ]
//    utf8            = <any sequence of octets formed from the UTF-8 [9]
//                       transformation of a character from ISO10646 [10]>
//    dstring         = 1*utf8
//    qdstring        = whsp "'" dstring "'" whsp
//    qdstringlist    = [ qdstring *( qdstring ) ]
//    qdstrings       = qdstring / ( whsp "(" qdstringlist ")" whsp )
//
// Arguments:  pTokenizer       -   The schema lexer object to use.
//             pppszDirStrings  -   Return value for strings.
//             pdwCount         -   Return value of number of strings.
//
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   N/A.
//
// History:    7-12-2000 AjayR created.
//
//----------------------------------------------------------------------------
HRESULT
DirectoryStrings(
    CSchemaLexer * pTokenizer,
    LPTSTR **pppszDirStrings,
    PDWORD pdwCount
    )
{
    HRESULT hr = S_OK;
    TCHAR szToken[MAX_TOKEN_LENGTH];
    LPWSTR *ppszTmp = NULL;
    LPWSTR pszTmp = NULL;
    DWORD dwToken, dwNumStrings = 0;
    BOOL fNeedCloseBracket = FALSE;

    ADsAssert(pTokenizer);
    ADsAssert(pdwCount);

    DWORD dwDummy = sizeof(ADS_ATTR_INFO);
    *pdwCount = 0;
    //
    // Get the token type of the first token.
    //
    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_ON_FAILURE(hr);

    if (dwToken == TOKEN_OPENBRACKET) {
        //
        // In this case we know that there is more than one string.
        // We can ignore the open bracket and continue to the next
        // token which should be a quote.
        //
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_ON_FAILURE(hr);

        fNeedCloseBracket = TRUE;
    }

    //
    // Need to push what should be the quote in either case,
    // back into the tokenizer (only then will the dirString
    // routine work correctly.
    //
    hr = pTokenizer->PushBackToken();
    BAIL_ON_FAILURE(hr);

    if ( dwToken != TOKEN_QUOTE ) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // While there remain strings to be processed.
    //
    while (dwToken == TOKEN_QUOTE) {
    
        hr = DirectoryString(
                 pTokenizer,
                 &pszTmp
                 );
        BAIL_ON_FAILURE(hr);
    
        if (dwNumStrings == 0) {
            //
            // Since we NULL terminate the array it should have
            // at least 2 elements in this case.
            //
            ppszTmp = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * 2);
            if (!ppszTmp) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        } 
        else {
            LPWSTR *ppszLocal;
            //
            // To avoid passing the variable itself to local alloc.
            //
            ppszLocal = (LPWSTR *) ReallocADsMem(
                                       ppszTmp,
                                       sizeof(LPWSTR) * (dwNumStrings + 1),
                                       sizeof(LPWSTR) * (dwNumStrings + 2)
                                       );
            if (ppszLocal) {
                ppszTmp = ppszLocal;
            } 
            else {
                //
                // Realloc failed, the old ptr is still valid.
                //
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }
    
        ppszTmp[dwNumStrings] = pszTmp;
        ppszTmp[++dwNumStrings] = NULL;
    
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_ON_FAILURE(hr);
    
        pTokenizer->PushBackToken();
    } // end of while.

    //
    // If this was qdescrs and not just qdstring.
    //
    if (fNeedCloseBracket) {
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_ON_FAILURE(hr);

        if (dwToken != TOKEN_CLOSEBRACKET) {
            //
            // Not properly formed - should be just ignore ?
            //
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

    //
    // The count is the actual number not including the NULL string.
    //
    *pdwCount = dwNumStrings;
    *pppszDirStrings = ppszTmp;

error:
    if (FAILED(hr)) {
        if (ppszTmp) {
            //
            // Free the strings if any and then the array itself.
            //
            for (DWORD dwCount = 0; dwCount < dwNumStrings; dwCount++) {
                if (ppszTmp[dwCount]) {
                    FreeADsStr(ppszTmp[dwCount]);
                }
            }
            FreeADsMem(ppszTmp);
            ppszTmp = NULL;
        }
        //
        // Need to reset the count.
        //
        *pdwCount = 0;
    }


    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   FreeDirectoryStrings
//
// Synopsis:   This function is used to free the entries returned from
//          the DirectoryStrings routine.
//
// Arguments:  ppszDirStrings    -   List of strings to free.
//             dwCount           -   Number of strings to free.
//             fSkipFirstElement -   If true, do not free the 1st element.
//
//
// Returns:    N/A.
//
// Modifies:   ppszDirStrings contents is freed including the array.
//
// History:    8-01-2000 AjayR created.
//
//----------------------------------------------------------------------------
void FreeDirectoryStrings(
    LPTSTR *ppszDirStrings,
    DWORD dwCount,
    DWORD dwElementsToFree
    )
{
    DWORD dwCtr;
    if (!ppszDirStrings) {
        return;
    }

    switch (dwElementsToFree) {
    
    case FREE_ALL_BUT_FIRST :
        dwCtr = 1;
        break;

    case FREE_ALL :
        dwCtr = 0;
        break;
        
    case FREE_ARRAY_NOT_ELEMENTS :
        dwCtr = dwCount;
        break;
    }

    for (; dwCtr < dwCount; dwCtr++) {
        if (ppszDirStrings[dwCtr]) {
            FreeADsStr(ppszDirStrings[dwCtr]);
            ppszDirStrings[dwCtr] = NULL;
        }
    }

    FreeADsMem(ppszDirStrings);
    return;
}

//+---------------------------------------------------------------------------
// Function:   AddNewNamesToPropertyArray   --- Helper function.
//
// Synopsis:   This function adds new entries to the property info array.
//          Specifically, this fn is called when there are multiple names
//          associated with the description of a single property. The new
//          entries will have the same information as the current element
//          but the appropriate new name.
//
// Arguments:  ppPropArray       -   Property array containing current
//                                 elements. This array is updated to contain
//                                 the new elements on success and is
//                                 untouched otherwise.
//             dwCurPos          -   The current element being processed.
//             dwCount          -    The current count of elements.
//             ppszNewNames      -   Array of names to add (1st element is
//                                 already a part of the property array).
//
// Returns:    S_OK or E_OUTOFMEMORY.
//
// Modifies:   *ppPropArray is modified in all success cases and some failure
//          cases (realloc succeeds but not the subsequent string allocs).
//
// History:    10-03-2000 AjayR created.
//
//----------------------------------------------------------------------------
HRESULT 
AddNewNamesToPropertyArray(
    PROPERTYINFO **ppPropArray,
    DWORD dwCurPos,
    DWORD dwCount,
    LPWSTR *ppszNewNames,
    DWORD dwNewNameCount
    )
{
    HRESULT hr = S_OK;
    PPROPERTYINFO pNewPropArray = NULL;
    DWORD dwAdditions = 0;
    DWORD dwCurCount = dwCount;

    //
    // The first element is already in the array.
    //
    dwAdditions = --dwNewNameCount;

    if (!dwNewNameCount) {
        RRETURN(hr);
    }

    //
    // We need to realloc the new array and copy over the new elements.
    //
    pNewPropArray = (PROPERTYINFO *) 
                    ReallocADsMem(
                        *ppPropArray,
                        (dwCurCount) * sizeof(PROPERTYINFO),
                        (dwCurCount + dwAdditions) * sizeof(PROPERTYINFO)
                        );
    if (!pNewPropArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // If the alloc succeeded we must return the new array.
    //
    *ppPropArray = pNewPropArray;

    for (DWORD dwCtr = 0; dwCtr < dwAdditions; dwCtr++ ) {
        PROPERTYINFO propOriginal = pNewPropArray[dwCurPos];
        PROPERTYINFO *pPropNew = pNewPropArray + (dwCurPos + dwCtr + 1);

        //
        // Copy over the property. First all data that is not ptrs.
        //
        pPropNew->lMaxRange = propOriginal.lMaxRange;
        pPropNew->lMinRange = propOriginal.lMinRange;
        pPropNew->fSingleValued = propOriginal.fSingleValued;

        pPropNew->fObsolete = propOriginal.fObsolete;
        pPropNew->fCollective = propOriginal.fCollective;
        pPropNew->fDynamic = propOriginal.fDynamic;
        
        pPropNew->fNoUserModification = propOriginal.fNoUserModification;
        pPropNew->dwUsage = propOriginal.dwUsage;
        pPropNew->fProcessedSuperiorClass = propOriginal.fProcessedSuperiorClass;

        //
        // Now the strings.
        //
        pPropNew->pszOID = AllocADsStr(propOriginal.pszOID);
        if (propOriginal.pszOID && !pPropNew->pszOID) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pPropNew->pszSyntax = AllocADsStr(propOriginal.pszSyntax);
        if (propOriginal.pszSyntax && !pPropNew->pszSyntax) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        pPropNew->pszDescription = AllocADsStr(propOriginal.pszDescription);
        if (propOriginal.pszDescription && !pPropNew->pszDescription) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        pPropNew->pszOIDSup = AllocADsStr(propOriginal.pszOIDSup);
        if (propOriginal.pszOIDSup && !pPropNew->pszOIDSup) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pPropNew->pszOIDEquality = AllocADsStr(propOriginal.pszOIDEquality);
        if (propOriginal.pszOIDEquality && !pPropNew->pszOIDEquality) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pPropNew->pszOIDOrdering = AllocADsStr(propOriginal.pszOIDOrdering);
        if (propOriginal.pszOIDOrdering && !pPropNew->pszOIDOrdering) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pPropNew->pszOIDSubstr = AllocADsStr(propOriginal.pszOIDSubstr);
        if (propOriginal.pszOIDSubstr && !pPropNew->pszOIDSubstr) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        //
        // This is just a copy from the array.
        //
        pPropNew->pszPropertyName = ppszNewNames[dwCtr + 1];
    }

    //
    // Success case.
    //
    RRETURN(hr);

error:

    //
    // Something failed, try and cleanup some pieces
    //
    if (pNewPropArray && (dwCtr != (DWORD)-1) ) {
        //
        // Cleanup the new elements added.
        //
        for (DWORD i = 0; i <= dwCtr; i++) {
            PROPERTYINFO *pPropFree = pNewPropArray + (dwCurPos + i + 1);
            //
            // Free all the strings in this element except name.
            //
            if (pPropFree->pszOID) {
                FreeADsStr(pPropFree->pszOID);
                pPropFree->pszOID = NULL;
            }

            if (pPropFree->pszSyntax) {
                FreeADsStr(pPropFree->pszSyntax);
                pPropFree->pszSyntax = NULL;
            }

            if (pPropFree->pszDescription) {
                FreeADsStr(pPropFree->pszDescription);
                pPropFree->pszDescription = NULL;
            }
            
            if (pPropFree->pszOIDSup) {
                FreeADsStr(pPropFree->pszOIDSup);
                pPropFree->pszOIDSup = NULL;
            }

            if (pPropFree->pszOIDEquality) {
                FreeADsStr(pPropFree->pszOIDEquality);
                pPropFree->pszOIDEquality = NULL;
            }

            if (pPropFree->pszOIDOrdering) {
                FreeADsStr(pPropFree->pszOIDOrdering);
                pPropFree->pszOIDOrdering = NULL;
            }

            if (pPropFree->pszOIDSubstr) {
                FreeADsStr(pPropFree->pszOIDSubstr);
                pPropFree->pszOIDSubstr = NULL;
            }
        } // for
    } // if we have elements to free

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   AddNewNamesToClassArray   --- Helper function.
//
// Synopsis:   This function adds new entries to the class info array.
//          Specifically, this fn is called when there are multiple names
//          associated with the description of a single class. The new
//          entries will have the same information as the current element
//          but the appropriate new name.
//
// Arguments:  ppClassArray      -   Class array containing current
//                                 elements. This array is updated to contain
//                                 the new elements on success and is
//                                 untouched otherwise.
//             dwCurPos          -   The current element being processed.
//             dwCount           -    The current count of elements.
//             ppszNewNames      -   Array of names to add (1st element is
//                                 already a part of the property array).
//             dwNewNameCount    -   Number of elements in the new array.
//
// Returns:    N/A.
//
// Modifies:   *ppClassArray always on success and in some failure cases.
//
// History:    10-06-2000 AjayR created.
//
//----------------------------------------------------------------------------
HRESULT
AddNewNamesToClassArray(
    CLASSINFO **ppClassArray,
    DWORD dwCurPos,
    DWORD dwCount,
    LPWSTR *ppszNewNames,
    DWORD dwNewNameCount
    )
{
    HRESULT hr = S_OK;
    PCLASSINFO pNewClassArray = NULL;
    DWORD dwAdditions = 0;
    DWORD dwCurCount = dwCount;
    int nCount;

    //
    // The first element is already in the array.
    //
    dwAdditions = --dwNewNameCount;

    if (!dwNewNameCount) {
        RRETURN(hr);
    }

    //
    // We need to realloc the new array and copy over the new elements.
    //
    pNewClassArray = (CLASSINFO *) 
                     ReallocADsMem(
                         *ppClassArray,
                         (dwCurCount) * sizeof(CLASSINFO),
                         (dwCurCount + dwAdditions) * sizeof(CLASSINFO)
                         );
    if (!pNewClassArray) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // If the alloc succeeded we must return the new array.
    //
    *ppClassArray = pNewClassArray;

    for (DWORD dwCtr = 0; dwCtr < dwAdditions; dwCtr++ ) {
        CLASSINFO classOriginal = pNewClassArray[dwCurPos];
        CLASSINFO *pClassNew = pNewClassArray + (dwCurPos + dwCtr + 1);

        //
        // Copy over the property. First all data that is not ptrs.
        //
        pClassNew->dwType = classOriginal.dwType;
        pClassNew->lHelpFileContext = classOriginal.lHelpFileContext;
        pClassNew->fObsolete = classOriginal.fObsolete;

        pClassNew->fProcessedSuperiorClasses = 
            classOriginal.fProcessedSuperiorClasses;
        pClassNew->IsContainer = classOriginal.IsContainer;

        //
        // Now the strings and other pointers.
        //
        pClassNew->pszOID = AllocADsStr(classOriginal.pszOID);
        if (classOriginal.pszOID && !pClassNew->pszOID) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        //
        // The GUIDs are not copied over as they are not used or freed.
        //
        
        pClassNew->pszHelpFileName = AllocADsStr(classOriginal.pszHelpFileName);
        if (classOriginal.pszHelpFileName && !pClassNew->pszHelpFileName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pClassNew->pszDescription = AllocADsStr(classOriginal.pszDescription);
        if (classOriginal.pszDescription && !pClassNew->pszDescription) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        //
        // pOIDsSuperiorClasses and pOIDsAuxClasses are arrays.
        //
        if (classOriginal.pOIDsSuperiorClasses) {
            pClassNew->pOIDsSuperiorClasses = 
                CopyStringArray(classOriginal.pOIDsSuperiorClasses);

            if (!pClassNew->pOIDsSuperiorClasses) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        if (classOriginal.pOIDsAuxClasses) {
            pClassNew->pOIDsAuxClasses = 
                CopyStringArray(classOriginal.pOIDsAuxClasses);

            if (!pClassNew->pOIDsAuxClasses) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

        //
        // Now the int arrays. Note that all of these will tag on the
        // the last element (-1), -1 is not included in the count.
        //
        if (classOriginal.pOIDsMustContain) {

            nCount = classOriginal.nNumOfMustContain + 1;
            pClassNew->pOIDsMustContain = 
                (int *) AllocADsMem(sizeof(int) * nCount);

            if (!pClassNew->pOIDsMustContain) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pClassNew->pOIDsMustContain,
                classOriginal.pOIDsMustContain,
                sizeof(int) * nCount
                );

            pClassNew->nNumOfMustContain = --nCount;
        }

        if (classOriginal.pOIDsMayContain) {

            nCount = classOriginal.nNumOfMayContain + 1;
            pClassNew->pOIDsMayContain = 
                (int *) AllocADsMem(sizeof(int) * nCount);

            if (!pClassNew->pOIDsMayContain) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pClassNew->pOIDsMayContain,
                classOriginal.pOIDsMayContain,
                sizeof(int) * nCount
                );
            pClassNew->nNumOfMayContain = --nCount;
        }

        if (classOriginal.pOIDsNotContain) {
            
            nCount = classOriginal.nNumOfNotContain + 1;
            pClassNew->pOIDsNotContain = 
                (int *) AllocADsMem(sizeof(int) * nCount);
            
            if (!pClassNew->pOIDsNotContain) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pClassNew->pOIDsNotContain,
                classOriginal.pOIDsNotContain,
                sizeof(int) * nCount
                );
            pClassNew->nNumOfNotContain = --nCount;
        }


        //
        // This is just a copy from the array.
        //
        pClassNew->pszName = ppszNewNames[dwCtr + 1];
    }

    //
    // Success case.
    //
    RRETURN(hr);

error:

    //
    // Something failed, try and cleanup some pieces
    //
    if (pNewClassArray && (dwCtr != (DWORD)-1) ) {
        //
        // Cleanup the new elements added.
        //
        for (DWORD i = 0; i <= dwCtr; i++) {
            CLASSINFO *pClassFree = pNewClassArray + (dwCurPos + i + 1);
            //
            // Free all the strings in this element except name.
            //
            if (pClassFree->pszOID) {
                FreeADsStr(pClassFree->pszOID);
                pClassFree->pszOID = NULL;
            }

            if (pClassFree->pszHelpFileName) {
                FreeADsStr(pClassFree->pszHelpFileName);
                pClassFree->pszHelpFileName = NULL;
            }

            if (pClassFree->pszDescription) {
                FreeADsStr(pClassFree->pszDescription);
                pClassFree->pszDescription = NULL;
            }
            
            //
            // Now the string arrays.
            //
            if (pClassFree->pOIDsSuperiorClasses) {
                nCount = 0;
                LPTSTR pszTemp;
                
                while (pszTemp = (pClassFree->pOIDsSuperiorClasses)[nCount]) {
                    FreeADsStr(pszTemp);
                    nCount++;
                }

                FreeADsMem(pClassFree->pOIDsSuperiorClasses);
                pClassFree->pOIDsSuperiorClasses = NULL;
            }

            if (pClassFree->pOIDsAuxClasses) {
                nCount = 0;
                LPTSTR pszTemp;

                while (pszTemp = (pClassFree->pOIDsAuxClasses)[nCount]) {
                    FreeADsStr(pszTemp);
                    nCount++;
                }
                FreeADsMem(pClassFree->pOIDsAuxClasses);
                pClassFree->pOIDsAuxClasses = NULL;
            }

            if (pClassFree->pOIDsMustContain) {
                FreeADsMem(pClassFree->pOIDsMustContain);
                pClassFree->pOIDsMustContain = NULL;
                pClassFree->nNumOfMustContain = 0;
            }

            if (pClassFree->pOIDsMayContain) {
                FreeADsMem(pClassFree->pOIDsMayContain);
                pClassFree->pOIDsMayContain = NULL;
                pClassFree->nNumOfMayContain = 0;
            }

            if (pClassFree->pOIDsNotContain) {
                FreeADsMem(pClassFree->pOIDsNotContain);
                pClassFree->pOIDsNotContain = NULL;
                pClassFree->nNumOfNotContain = 0;
            }

        } // for
    } // if we have elements to free

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CSchemaLexer::CSchemaLexer(LPTSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _fInQuotes(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CSchemaLexer::~CSchemaLexer()
{
    FreeADsStr(_Buffer);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CSchemaLexer::GetNextToken(LPTSTR szToken, LPDWORD pdwToken)
{
    TCHAR c;
    DWORD state = 0;
    LPTSTR pch = szToken;

    memset(szToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    _dwLastTokenLength = 0;

    while (1) {
        c = NextChar();
        switch (state) {

        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            switch (c) {
            case TEXT('(') :
                *pdwToken = TOKEN_OPENBRACKET;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(')') :
                *pdwToken = TOKEN_CLOSEBRACKET;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('\'') :
                *pdwToken = TOKEN_QUOTE;
                _dwLastToken = *pdwToken;
                _fInQuotes = !_fInQuotes;
                RRETURN(S_OK);
                break;

            case TEXT('$') :
                *pdwToken = TOKEN_DOLLAR;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(' ') :
                pch--;
                _dwLastTokenLength--;
                break;

            case TEXT('\0') :
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('{') :
                *pdwToken = TOKEN_OPEN_CURLY;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('}') :
                *pdwToken = TOKEN_CLOSE_CURLY;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            default:
                state = 1;
                break;

            } // end of switch c
            break;

        case 1:
            switch (c) {
            case TEXT('(')  :
            case TEXT(')')  :
            case TEXT('\'') :
            case TEXT('$')  :
            case TEXT(' ')  :
            case TEXT('\0') :
            case TEXT('{')  :
            case TEXT('}')  :

                if ( _fInQuotes && c != TEXT('\''))
                {
                    if ( c == TEXT('\0'))
                        RRETURN(E_FAIL);

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;
                }
                else // Not in quotes or in quotes and reach the matching quote
                {
                    PushbackChar();
                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN (S_OK);
                }
                break;

            default :
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            } // switch c

            break;

        default:
            RRETURN(E_FAIL);
        } // switch state
    }
}

HRESULT
CSchemaLexer::GetNextToken2(LPTSTR szToken, LPDWORD pdwToken)
{
    TCHAR c;
    DWORD state = 0;
    LPTSTR pch = szToken;

    memset(szToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    _dwLastTokenLength = 0;

    while (1) {
        c = NextChar();
        switch (state) {

        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            switch (c) {
            case TEXT('(') :
                *pdwToken = TOKEN_OPENBRACKET;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(')') :
                *pdwToken = TOKEN_CLOSEBRACKET;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('\'') :
                *pdwToken = TOKEN_QUOTE;
                _dwLastToken = *pdwToken;
                _fInQuotes = !_fInQuotes;
                RRETURN(S_OK);
                break;

            case TEXT('$') :
                *pdwToken = TOKEN_DOLLAR;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('\0') :
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('{') :
                *pdwToken = TOKEN_OPEN_CURLY;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('}') :
                *pdwToken = TOKEN_CLOSE_CURLY;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            default:
                state = 1;
                break;

            } // end of switch c
            break;

        case 1:
            switch (c) {
            case TEXT('(')  :
            case TEXT(')')  :
            case TEXT('\'') :
            case TEXT('$')  :
            case TEXT(' ')  :
            case TEXT('\0') :
            case TEXT('{')  :
            case TEXT('}')  :

                if ( _fInQuotes && c != TEXT('\''))
                {
                    if ( c == TEXT('\0'))
                        RRETURN(E_FAIL);

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;
                }
                else // Not in quotes or in quotes and reach the matching quote
                {
                    PushbackChar();
                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN (S_OK);
                }
                break;

            default :
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            } // switch c

            break;

        default:
            RRETURN(E_FAIL);
        } // switch state
    }
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
TCHAR
CSchemaLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == TEXT('\0')) {
        _dwEndofString = TRUE;
        return(TEXT('\0'));
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis: ONLY ONE TOKEN CAN BE PUSHED BACK.
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//

//----------------------------------------------------------------------------
HRESULT
CSchemaLexer::PushBackToken()
{

    DWORD i = 0;

    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }

    for (i=0; i < _dwLastTokenLength; i++) {
        if (*(--_ptr) == TEXT('\'') )  {
            _fInQuotes = !_fInQuotes;
        }
    }

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CSchemaLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CSchemaLexer::IsKeyword(LPTSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < g_dwSchemaKeywordListSize; i++) {
        if (!_tcsicmp(szToken, g_aSchemaKeywordList[i].Keyword)) {
            *pdwToken = g_aSchemaKeywordList[i].dwTokenId;
            return(TRUE);
        } 
        else if (!_wcsnicmp(szToken, L"X-", 2)) {
            //
            // Terms begining with X- are special tokens for schema.
            //
            *pdwToken = TOKEN_X;
            return(TRUE);                 
        }
    }
    *pdwToken = 0;
    return(FALSE);
}

int _cdecl searchentrycmp( const void *s1, const void *s2 )
{
    SEARCHENTRY *srch1 = (SEARCHENTRY *) s1;
    SEARCHENTRY *srch2 = (SEARCHENTRY *) s2;

    return ( _tcsicmp( srch1->pszName, srch2->pszName ));
}

int _cdecl intcmp( const void *s1, const void *s2 )
{
    int n1 = *((int *) s1);
    int n2 = *((int *) s2);
    int retval;

    if ( n1 == n2 )
        retval = 0;
    else if ( n1 < n2 )
        retval = -1;
    else
        retval = 1;

    return retval;
}


long CompareUTCTime(
    LPTSTR pszTime1,
    LPTSTR pszTime2
)
{
    SYSTEMTIME sysTime1;
    SYSTEMTIME sysTime2;
    FILETIME fTime1;
    FILETIME fTime2;

    memset( &sysTime1, 0, sizeof(sysTime1));
    memset( &sysTime2, 0, sizeof(sysTime2));

    //
    // We are ignoring the last part which might be a float.
    // The time window is sufficiently small for us not to
    // worry about this value.
    //
    _stscanf( pszTime1, TEXT("%4d%2d%2d%2d%2d%2d"),
              &sysTime1.wYear,
              &sysTime1.wMonth,
              &sysTime1.wDay,
              &sysTime1.wHour,
              &sysTime1.wMinute,
              &sysTime1.wSecond
              );

    _stscanf( pszTime2, TEXT("%4d%2d%2d%2d%2d%2d"),
              &sysTime2.wYear,
              &sysTime2.wMonth,
              &sysTime2.wDay,
              &sysTime2.wHour,
              &sysTime2.wMinute,
              &sysTime2.wSecond
              );

    if (  SystemTimeToFileTime( &sysTime1, &fTime1 )
       && SystemTimeToFileTime( &sysTime2, &fTime2 )
       )
    {
        return CompareFileTime( &fTime1, &fTime2 );
    }

    // If SystemTimeToFileTime failed, then assume that pszTime1 is in cache,
    // pszTime2 is on the server and if we cannot get the correct time, we
    // should always read from the server again. Hence, return -1;

    return -1;

}

int FindEntryInSearchTable( LPTSTR pszName, SEARCHENTRY *aSearchTable, DWORD nSearchTableSize)
{
    SEARCHENTRY searchEntry;
    SEARCHENTRY *matchedEntry = NULL;

    searchEntry.pszName = pszName;
    matchedEntry = (SEARCHENTRY *) bsearch(
                        (SEARCHENTRY *) &searchEntry,
                        aSearchTable, nSearchTableSize,
                        sizeof(SEARCHENTRY), searchentrycmp );

    if ( matchedEntry )
    {
        return matchedEntry->nIndex;
    }

    return -1;
}

int FindSearchTableIndex( LPTSTR pszName, SEARCHENTRY *aSearchTable, DWORD nSearchTableSize )
{
    SEARCHENTRY searchEntry;
    SEARCHENTRY *matchedEntry = NULL;

    searchEntry.pszName = pszName;
    matchedEntry = (SEARCHENTRY *) bsearch(
                        (SEARCHENTRY *) &searchEntry,
                        aSearchTable, nSearchTableSize,
                        sizeof(SEARCHENTRY), searchentrycmp );

    if ( matchedEntry )
    {
        return (int)( matchedEntry - aSearchTable );  // return index of search table
    }

    return -1;
}


HRESULT
ReadSubSchemaSubEntry(
    LPWSTR pszLDAPServer,
    LPWSTR * ppszSubSchemaEntry,
    OUT BOOL *pfBoundOk,           // have we at least once bound to domain
                                   // successfully, OPTIONAL (can be NULL)
    CCredentials& Credentials,
    DWORD dwPort
    )
{

    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(ppszSubSchemaEntry);

    *ppszSubSchemaEntry = NULL;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             pfBoundOk,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( !rootDSE.pszSubSchemaEntry ) {
        //
        // SubschemaEntry must be found
        //

        BAIL_ON_FAILURE(hr = E_FAIL);
    }
    else {
        *ppszSubSchemaEntry = rootDSE.pszSubSchemaEntry;
    }


error:

    RRETURN(hr);
}


HRESULT
ReadPagingSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfPagingSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfPagingSupported);
    *pfPagingSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfPagingSupported = rootDSE.fPagingSupported;

error:

    RRETURN(hr);
}


HRESULT
ReadSortingSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfSortingSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfSortingSupported);
    *pfSortingSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfSortingSupported = rootDSE.fSortingSupported;

error:

    RRETURN(hr);
}


HRESULT
ReadAttribScopedSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfAttribScopedSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfAttribScopedSupported);
    *pfAttribScopedSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfAttribScopedSupported = rootDSE.fAttribScopedSupported;

error:

    RRETURN(hr);
}


HRESULT
ReadVLVSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfVLVSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfVLVSupported);
    *pfVLVSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfVLVSupported = rootDSE.fVLVSupported;

error:

    RRETURN(hr);
}


//
// Returns the info about SecDesc Control if appropriate
//
HRESULT
ReadSecurityDescriptorControlType(
    LPWSTR pszLDAPServer,
    DWORD * pdwSecDescType,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pdwSecDescType);
    *pdwSecDescType = ADSI_LDAPC_SECDESC_NONE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pdwSecDescType = rootDSE.dwSecDescType;

error:

    //
    // Since the error case is uninteresting, if there was an
    // error, we will continue with no sec desc
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE))
        RRETURN (S_OK);
    else
        RRETURN(hr);
}


//
// This is to see if we support the domain scope control.
// If we do we can set it to reduce server load.
//
HRESULT
ReadDomScopeSupportedAttr(
    LPWSTR pszLDAPServer,
    BOOL * pfDomScopeSupported,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfDomScopeSupported);
    *pfDomScopeSupported = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfDomScopeSupported = rootDSE.fDomScopeSupported;

error:

    RRETURN(hr);
}


//
// This is to see if we support the domain scope control.
// If we do we can set it to reduce server load.
//
HRESULT
ReadServerSupportsIsADControl(
    LPWSTR pszLDAPServer,
    BOOL * pfServerIsAD,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfServerIsAD);
    *pfServerIsAD = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfServerIsAD = rootDSE.fTalkingToAD;

error:

    RRETURN(hr);
}

//
// This is to see if we are talking to enhacned AD servers so we 
// can process the aux classes correctly.
//
HRESULT
ReadServerSupportsIsEnhancedAD(
    LPWSTR pszLDAPServer,
    BOOL * pfServerIsEnhancedAD,
    BOOL * pfServerIsADControl,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    ROOTDSENODE rootDSE = {0};

    ADsAssert(pfServerIsEnhancedAD);
    ADsAssert(pfServerIsADControl);

    *pfServerIsEnhancedAD = FALSE;
    *pfServerIsADControl = FALSE;

    //
    // Call the generic function
    //

    hr = ReadRootDSENode(
             pszLDAPServer,
             &rootDSE,
             NULL,
             Credentials,
             dwPort
         );
    BAIL_ON_FAILURE(hr);

    if ( rootDSE.pszSubSchemaEntry) {

        FreeADsStr (rootDSE.pszSubSchemaEntry);
    }

    *pfServerIsEnhancedAD = rootDSE.fTalkingToEnhancedAD;
    *pfServerIsADControl = rootDSE.fTalkingToAD;

error:

    RRETURN(hr);
}

BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    )
{
    if (!pszTargetServer && !pszSourceServer) {
        return(TRUE);
    }

    if (pszTargetServer && pszSourceServer) {

#ifdef WIN95
        if (!_wcsicmp(pszTargetServer, pszSourceServer)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszTargetServer,
                -1,
                pszSourceServer,
                -1
                ) == CSTR_EQUAL ) {
#endif
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL
EquivalentUsers(
    LPWSTR pszUser1,
    LPWSTR pszUser2
    )
{
    if (!pszUser1 && !pszUser2) {
        return(TRUE);
    }

    if (pszUser1 && pszUser2) {

#ifdef WIN95
        if (!_wcsicmp(pszUser1, pszUser2)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszUser1,
                -1,
                pszUser2,
                -1
                ) == CSTR_EQUAL ) {
#endif
            return(TRUE);
        }
    }

    return(FALSE);
}

HRESULT
ReadRootDSENode(
    LPWSTR pszLDAPServer,
    PROOTDSENODE pRootDSE,
    OUT BOOL * pfBoundOk,           // have we at least once bound to domain
                                    // successfully, OPTIONAL (can be NULL)
    CCredentials& Credentials,
    DWORD dwPort
    )
{

    HRESULT hr = S_OK;

    PSCHEMALIST pTemp = NULL;
    PSCHEMALIST pNewNode = NULL;
    ADS_LDP * ld = NULL;
    int nCount1 = 0, nCount2 = 0, nCount3 = 0;
    LPWSTR *aValues1 = NULL, *aValues2 = NULL, *aValues3 = NULL;
    LDAPMessage * res = NULL;
    LDAPMessage *e = NULL;
    LPWSTR aStrings[4];             // Attributes to fetch.
    BOOL fBoundOk = FALSE;          // have we at least once bound to
                                    // domain successfully?
    BOOL fNoData = FALSE;

    ADsAssert(pRootDSE);

    memset (pRootDSE, 0x00, sizeof(ROOTDSENODE));

    ENTER_SUBSCHEMA_CRITSECT();

    pTemp = gpSubSchemaList;

    while (pTemp) {

        if (EquivalentServers(pszLDAPServer, pTemp->pszLDAPServer)){

            if (pTemp->fNoDataGot) {
                //
                // This is necessary for V2 server
                // If BoundOk is not set we may end up not loading
                // the default schema
                //
                fBoundOk = TRUE;

                LEAVE_SUBSCHEMA_CRITSECT();

                BAIL_ON_FAILURE(
                    hr = HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)
                    );
            }

            pRootDSE->fPagingSupported = pTemp->fPagingSupported;
            pRootDSE->fSortingSupported = pTemp->fSortingSupported;
            pRootDSE->fVLVSupported = pTemp->fVLVSupported;
            pRootDSE->fAttribScopedSupported = pTemp->fAttribScopedSupported;

            pRootDSE->dwSecDescType = pTemp->dwSecDescType;
            pRootDSE->fDomScopeSupported = pTemp->fDomScopeSupported;

            pRootDSE->fTalkingToAD = pTemp->fTalkingToAD;
            pRootDSE->fTalkingToEnhancedAD = pTemp->fTalkingToEnhancedAD;

            pRootDSE->fNoDataGot = pTemp->fNoDataGot;

            pRootDSE->pszSubSchemaEntry = AllocADsStr(pTemp->pszSubSchemaEntry);

            if (!pRootDSE->pszSubSchemaEntry) {

                hr = E_OUTOFMEMORY;
            }

            LEAVE_SUBSCHEMA_CRITSECT();

            //
            // we have at least once bound successfully to the domain
            //

            fBoundOk = TRUE;

            goto error;     // can't return direct, need clean up
       }

       pTemp = pTemp->pNext;

    }

    LEAVE_SUBSCHEMA_CRITSECT();

    hr = LdapOpenObject(
                pszLDAPServer,
                NULL,
                &ld,
                Credentials,
                dwPort
                );

    BAIL_ON_FAILURE(hr);

    //
    // we have once bound to the node successfully - just now
    //

    fBoundOk=TRUE;

    //
    // Ask only for the attributes we are intersted in.
    //
    aStrings[0] = LDAP_OPATT_SUBSCHEMA_SUBENTRY_W;
    aStrings[1] = LDAP_OPATT_SUPPORTED_CONTROL_W;
    aStrings[2] = LDAP_OPATT_SUPPORTED_CAPABILITIES_W;
    aStrings[3] = NULL;

    hr = LdapSearchS(
                ld,
                NULL,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                aStrings,
                0,
                &res );

    // Only one entry should be returned

    if (  FAILED(hr)
       || FAILED(hr = LdapFirstEntry( ld, res, &e ))
       )
    {
       goto error;
    }

    hr = LdapGetValues(
            ld,
            e,
            LDAP_OPATT_SUBSCHEMA_SUBENTRY_W,
            &aValues1,
            &nCount1
            );

    if (SUCCEEDED(hr) && nCount1==0) {
        //
        // No data flag indicates that we read nothing but the
        // search was a success.
        //
        fNoData = TRUE;

    }

    BAIL_ON_FAILURE(hr);


    hr = LdapGetValues(
            ld,
            e,
            LDAP_OPATT_SUPPORTED_CONTROL_W,
            &aValues2,
            &nCount2
            );

    //
    // okay to have no values for supportedControl
    //
    if (FAILED(hr)) {
        //
        // Reset the error because we were really succesful
        // in reading critical information.
        //
        hr = S_OK;
    }

    hr = LdapGetValues(
            ld,
            e,
            LDAP_OPATT_SUPPORTED_CAPABILITIES_W,
            &aValues3,
            &nCount3
            );

    //
    // okay to have no values for supportedControl
    //
    if (FAILED(hr)) {
        //
        // Reset the error because we were really succesful
        // in reading critical information.
        //
        hr = S_OK;
    }

    ENTER_SUBSCHEMA_CRITSECT();

    pTemp =  gpSubSchemaList;
    while (pTemp) {

        if (EquivalentServers(pszLDAPServer, pTemp->pszLDAPServer)) {
            //
            // Found a match -looks like someone has come in before us
            //
            if (pTemp->fNoDataGot) {
                //
                // This is necessary for V2 server
                //
                
                LEAVE_SUBSCHEMA_CRITSECT();

                BAIL_ON_FAILURE(
                    hr = HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)
                    );
            }

            pRootDSE->fPagingSupported = pTemp->fPagingSupported;
            pRootDSE->fSortingSupported = pTemp->fSortingSupported;
            pRootDSE->fVLVSupported = pTemp->fVLVSupported;
            pRootDSE->fAttribScopedSupported = pTemp->fAttribScopedSupported;
            
            pRootDSE->dwSecDescType = pTemp->dwSecDescType;
            pRootDSE->fDomScopeSupported = pTemp->fDomScopeSupported;

            pRootDSE->fTalkingToAD = pTemp->fTalkingToAD;
            pRootDSE->fTalkingToEnhancedAD = pTemp->fTalkingToEnhancedAD;

            pRootDSE->fNoDataGot = pTemp->fNoDataGot;

            pRootDSE->pszSubSchemaEntry = AllocADsStr(pTemp->pszSubSchemaEntry);

            if (!pRootDSE->pszSubSchemaEntry) {

                hr = E_OUTOFMEMORY;
            }

            LEAVE_SUBSCHEMA_CRITSECT();

            goto error;         // clean up first before return
        }

        pTemp = pTemp->pNext;

    }

    pNewNode = (PSCHEMALIST)AllocADsMem(sizeof(SCHEMALIST));

    if (!pNewNode) {

        hr = E_OUTOFMEMORY;
        LEAVE_SUBSCHEMA_CRITSECT();

        goto error;         // clean up first before return
    }

    pNewNode->pNext = gpSubSchemaList;

    pNewNode->pszLDAPServer = AllocADsStr(pszLDAPServer);

    if (aValues1 && aValues1[0]) {

        pNewNode->pszSubSchemaEntry = AllocADsStr(aValues1[0]);
        pNewNode->fNoDataGot = FALSE;
    }
    else {

        pNewNode->pszSubSchemaEntry = NULL;
        pNewNode->fNoDataGot = TRUE;
    }

    //
    // Default to this value
    //
    pNewNode->dwSecDescType = ADSI_LDAPC_SECDESC_NONE;

    if (aValues2) {

        for (int j=0; j<nCount2; j++) {

            if (_wcsicmp(aValues2[j], LDAP_PAGED_RESULT_OID_STRING_W) == 0) {
                pNewNode->fPagingSupported = TRUE;
            }
            else if (_wcsicmp(aValues2[j], LDAP_SERVER_SORT_OID_W) == 0) {
                pNewNode->fSortingSupported = TRUE;
            }
            else if (_wcsicmp(aValues2[j], LDAP_SERVER_SD_FLAGS_OID_W) == 0) {
                pNewNode->dwSecDescType = ADSI_LDAPC_SECDESC_NT;
            }
            else if (_wcsicmp(aValues2[j], ADSI_LDAP_OID_SECDESC_OLD) == 0) {
                pNewNode->dwSecDescType = ADSI_LDAPC_SECDESC_OTHER;
            }
            else if (_wcsicmp(aValues2[j], LDAP_SERVER_DOMAIN_SCOPE_OID_W)
                     == 0) {
                pNewNode->fDomScopeSupported = TRUE;
            }
            else if (_wcsicmp(aValues2[j], LDAP_CONTROL_VLVREQUEST_W) == 0) {
                pNewNode->fVLVSupported = TRUE;
            }
            else if (_wcsicmp(aValues2[j], LDAP_SERVER_ASQ_OID_W) == 0) {
                pNewNode->fAttribScopedSupported = TRUE;
            }
        }
    }
    else {

        pNewNode->fPagingSupported = FALSE;
        pNewNode->fSortingSupported = FALSE;
        pNewNode->fDomScopeSupported = FALSE;
        pNewNode->fVLVSupported = FALSE;
        pNewNode->fAttribScopedSupported = FALSE;
    }

    if (aValues3) {
        for (int j=0; j<nCount3; j++) {
            if (_wcsicmp(aValues3[j], LDAP_CAP_ACTIVE_DIRECTORY_OID_W)
                == 0) {
                pNewNode->fTalkingToAD = TRUE;
            } 
            else if (_wcsicmp(aValues3[j],
                              LDAP_CAP_ACTIVE_DIRECTORY_V51_OID_W)
                      == 0) {
                //
                // Replace with correct OID from ntldap.h.
                //
                pNewNode->fTalkingToEnhancedAD = TRUE;
            }
        }

    }
    else {
        //
        // Should already be false but just in case.
        //
        pNewNode->fTalkingToAD = FALSE;
        pNewNode->fTalkingToEnhancedAD = FALSE;
    }


    gpSubSchemaList = pNewNode;

    if (fNoData == FALSE) {

        pRootDSE->fPagingSupported = pNewNode->fPagingSupported;
        pRootDSE->fSortingSupported = pNewNode->fSortingSupported;
        pRootDSE->fVLVSupported = pNewNode->fVLVSupported;
        pRootDSE->fAttribScopedSupported = pNewNode->fAttribScopedSupported;

        pRootDSE->fNoDataGot = pNewNode->fNoDataGot;
        pRootDSE->dwSecDescType = pNewNode->dwSecDescType;
        pRootDSE->fDomScopeSupported = pNewNode->fDomScopeSupported;
        pRootDSE->fTalkingToAD = pNewNode->fTalkingToAD;
        pRootDSE->fTalkingToEnhancedAD = pNewNode->fTalkingToEnhancedAD;

        pRootDSE->pszSubSchemaEntry = AllocADsStr(pNewNode->pszSubSchemaEntry);

        if (!pRootDSE->pszSubSchemaEntry) {

            hr = E_OUTOFMEMORY;
        }
    }

    LEAVE_SUBSCHEMA_CRITSECT();

error:

    if (aValues1) {

        LdapValueFree(aValues1);
    }

    if (aValues2) {

        LdapValueFree(aValues2);
    }

    if (aValues3) {
        LdapValueFree(aValues3);
    }

    if (res) {

        LdapMsgFree(res);
    }

    if (ld) {

        LdapCloseObject(ld);
    }

    //
    // return to caller if we have at least once bound succsufully
    // to the node
    //

    if (pfBoundOk)
        *pfBoundOk = fBoundOk;

    //
    // Need to special case fNoData to ensure that the other code
    // that relies on this eCode from this routine continues to
    // work properly
    //
    if (fNoData) {
        RRETURN(HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE));
    } else
        RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\ldap2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       ldap2ods.cxx
//
//  Contents:   LDAP Object to DSObject Copy Routines
//
//  Functions:
//
//  History:    2/20/96 yihsins Created.
//
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"

void
AdsTypeFreeAdsObjects(
    PADSVALUE pAdsDestValues,
    DWORD dwNumObjects
    )
{
    LPBYTE pMem = NULL;
    PADS_DN_WITH_BINARY pDNBin = NULL;
    PADS_DN_WITH_STRING pDNStr = NULL;

    for ( DWORD i = 0; i < dwNumObjects; i++ )
    {
        pMem = NULL;

        switch ( pAdsDestValues[i].dwType )
        {
            case ADSTYPE_DN_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].DNString;
                break;

            case ADSTYPE_CASE_EXACT_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].CaseExactString;
                break;

            case ADSTYPE_CASE_IGNORE_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].CaseIgnoreString;
                break;

            case ADSTYPE_PRINTABLE_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].PrintableString;
                break;

            case ADSTYPE_NUMERIC_STRING:
                pMem = (LPBYTE) pAdsDestValues[i].NumericString;
                break;

            case ADSTYPE_OCTET_STRING:
                pMem = pAdsDestValues[i].OctetString.lpValue;
                break;

            case ADSTYPE_PROV_SPECIFIC:
                pMem = pAdsDestValues[i].ProviderSpecific.lpValue;
                break;

            case ADSTYPE_NT_SECURITY_DESCRIPTOR:
                pMem = pAdsDestValues[i].SecurityDescriptor.lpValue;
                break;

            case ADSTYPE_DN_WITH_STRING:
                pDNStr = pAdsDestValues[i].pDNWithString;

                if (pDNStr) {
                    if (pDNStr->pszStringValue) {
                        FreeADsStr(pDNStr->pszStringValue);
                    }
                    if (pDNStr->pszDNString) {
                        FreeADsStr(pDNStr->pszDNString);
                    }
                }

                FreeADsMem(pDNStr);
                pDNStr = NULL;

                break;

            case ADSTYPE_DN_WITH_BINARY:

                pDNBin = pAdsDestValues[i].pDNWithBinary;

                if (pDNBin) {
                    if (pDNBin->lpBinaryValue) {
                        FreeADsMem(pDNBin->lpBinaryValue);
                    }

                    if (pDNBin->pszDNString) {
                        FreeADsStr(pDNBin->pszDNString);
                    }
                }

                FreeADsMem(pDNBin);
                pDNBin = NULL;

                break;

            default:
                break;
        }

        if ( pMem )
            FreeADsMem( pMem );
    }

    FreeADsMem( pAdsDestValues );
    return;
}

HRESULT
LdapTypeToAdsTypeDNString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_DN_STRING;

    pAdsDestValue->DNString = AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->DNString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeCaseExactString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    pAdsDestValue->CaseExactString =
                        AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->CaseExactString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}


HRESULT
LdapTypeToAdsTypeCaseIgnoreString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )

{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    pAdsDestValue->CaseIgnoreString =
                        AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->CaseIgnoreString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}


HRESULT
LdapTypeToAdsTypePrintableString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    pAdsDestValue->PrintableString =
                        AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->PrintableString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeNumericString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    pAdsDestValue->NumericString =
                        AllocADsStr( LDAPOBJECT_STRING(pLdapSrcObject));

    if ( pAdsDestValue->NumericString == NULL )
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeBoolean(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPTSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);

    pAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    if ( _tcsicmp( pszSrc, TEXT("TRUE")) == 0 )
    {
        pAdsDestValue->Boolean = TRUE;
    }
    else if ( _tcsicmp( pszSrc, TEXT("FALSE")) == 0 )
    {
        pAdsDestValue->Boolean = FALSE;
    }
    else
    {
        hr = E_ADS_CANT_CONVERT_DATATYPE;
    }

    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeInteger(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_INTEGER;

    pAdsDestValue->Integer = _ttol(LDAPOBJECT_STRING(pLdapSrcObject));

    RRETURN(hr);

}

HRESULT
LdapTypeToAdsTypeOctetString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLen = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);
    LPBYTE pBuffer = NULL;

    pAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    if ( (pBuffer = (LPBYTE) AllocADsMem( dwLen )) == NULL )
        RRETURN(E_OUTOFMEMORY);

    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL(pLdapSrcObject), dwLen );

    pAdsDestValue->OctetString.dwLength = dwLen;

    pAdsDestValue->OctetString.lpValue = pBuffer;

    RRETURN(hr);

}


HRESULT
LdapTypeToAdsTypeNTSecurityDescriptor(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLen = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);
    LPBYTE pBuffer = NULL;

    pAdsDestValue->dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;

    if ( (pBuffer = (LPBYTE) AllocADsMem( dwLen )) == NULL )
        RRETURN(E_OUTOFMEMORY);

    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL(pLdapSrcObject), dwLen );

    pAdsDestValue->SecurityDescriptor.dwLength = dwLen;

    pAdsDestValue->SecurityDescriptor.lpValue = pBuffer;

    RRETURN(hr);

}

HRESULT
UTCTimeStringToUTCTime(
    LPWSTR szTime,
    SYSTEMTIME *pst)
{
    FILETIME ft;
    TCHAR sz[3];
    LPWSTR pszSrc = szTime;
    SYSTEMTIME st;
    BOOL fSucceeded = FALSE;
    HRESULT hr = S_OK;

    //
    // Year
    //
    sz[0] = pszSrc[0];
    sz[1] = pszSrc[1];
    sz[2] = TEXT('\0');
    st.wYear = (WORD)_ttoi(sz);
    if (st.wYear < 50)
    {
        st.wYear += 2000;
    }
    else
    {
        st.wYear += 1900;
    }
    //
    // Month
    //
    sz[0] = pszSrc[2];
    sz[1] = pszSrc[3];
    st.wMonth = (WORD)_ttoi(sz);
    //
    // Day
    //
    sz[0] = pszSrc[4];
    sz[1] = pszSrc[5];
    st.wDay = (WORD)_ttoi(sz);
    //
    // Hour
    //
    sz[0] = pszSrc[6];
    sz[1] = pszSrc[7];
    st.wHour = (WORD)_ttoi(sz);
    //
    // Minute
    //
    sz[0] = pszSrc[8];
    sz[1] = pszSrc[9];
    st.wMinute = (WORD)_ttoi(sz);
    //
    // Second
    //
    sz[0] = pszSrc[10];
    sz[1] = pszSrc[11];
    st.wSecond = (WORD)_ttoi(sz);
    st.wMilliseconds = 0;

    //
    // This gets us the day of week, as per bug 87387.
    // SystemTimeToFileTime ignores the wDayOfWeek member, and
    // FileTimeToSystemTime sets it.  A FileTime is precise down to
    // 100 nanoseconds, so there will never be conversion loss.
    //

    fSucceeded = SystemTimeToFileTime(&st, &ft);
    if (!fSucceeded) {
        BAIL_ON_FAILURE (hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    fSucceeded = FileTimeToSystemTime(&ft, &st);
    if (!fSucceeded) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    *pst = st;

error:

    RRETURN(hr);

}

//
// GenTimeStringToUTCTime -- parse a GeneralizedTime string.
//
// An LDAP GeneralizedTime is the same as the ASN.1 GeneralizedTime.
// Format given by:
//
//   Type GeneralizedTime takes values of the year, month, day, hour,
//   time, minute, second, and second fraction in any of three forms.
//     1. Local time only. "YYYYMMDDHHMMSS.fff", where the optional fff
//        is accurate to three decimal places.
//     2. Universal time (UTC time) only. "YYYYMMDDHHMMSS.fffZ".
//     3. Difference between local and UTC times.
//         "YYYYMMDDHHMMSS.fff+-HHMM".
//
// I'm being a little more lenient; if the string ends "early", i.e.
// doesn't fill in all the required fields, it sets the rest to zero.
// I'm doing this in particular because it's not clear if the "SS" for
// seconds is optional.  If this is a bad thing, change the #if below so
// it signals an error conditions.
//
#if 1
#define FINISH goto cleanup
#else
#define FINISH do { BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE); } while(0)
#endif
HRESULT
GenTimeStringToUTCTime(
    LPWSTR szTime,
    SYSTEMTIME *pst)
{
    HRESULT hr = S_OK;

    PWSTR pszSrc = szTime;
    DWORD dwStrlen = wcslen(pszSrc);

    SYSTEMTIME st, stZulu;
    WCHAR sz[5];

    // Make sure everything is zero first, in case we bail.
    memset((void *)&st, 0, sizeof(st));

    //
    // Year
    //
    if (dwStrlen < 4) FINISH;
    sz[0] = pszSrc[0];
    sz[1] = pszSrc[1];
    sz[2] = pszSrc[2];
    sz[3] = pszSrc[3];
    sz[4] = TEXT('\0');
    st.wYear = (WORD)_wtoi(sz);

    //
    // Month
    //
    if (dwStrlen < 6)
        goto cleanup;
    sz[0] = pszSrc[4];
    sz[1] = pszSrc[5];
    sz[2] = TEXT('\0');
    st.wMonth = (WORD)_wtoi(sz);

    //
    // Day
    //
    if (dwStrlen < 8) FINISH;
    sz[0] = pszSrc[6];
    sz[1] = pszSrc[7];
    st.wDay = (WORD)_wtoi(sz);

    //
    // Hour
    //
    if (dwStrlen < 10) FINISH;
    sz[0] = pszSrc[8];
    sz[1] = pszSrc[9];
    st.wHour = (WORD)_wtoi(sz);

    //
    // Minute
    //
    if (dwStrlen < 12) FINISH;
    sz[0] = pszSrc[10];
    sz[1] = pszSrc[11];
    st.wMinute = (WORD)_wtoi(sz);

    //
    // Second
    //
    if (dwStrlen < 14) FINISH;
    sz[0] = pszSrc[12];
    sz[1] = pszSrc[13];
    st.wSecond = (WORD)_wtoi(sz);

    //
    // Check for milliseconds.
    //
    pszSrc = pszSrc + 14;       // we've read the first 14 characters
    if (*pszSrc == TEXT('.')) {
        pszSrc++;

        //
        // Milliseconds are defined as "optional", but it's unclear if this
        // means "all three digits or none at all".  So play it safe.
        //
        PWSTR psz = sz;
        WORD wDigits = 0;
        while (*pszSrc != TEXT('\0') && iswdigit(*pszSrc) && wDigits < 3) {
            wDigits++;
            *psz++ = *pszSrc++;
        }
        while (wDigits < 3) {
            wDigits++;
            *psz++ = TEXT('0');
        }
        *psz = TEXT('\0');

        st.wMilliseconds = (WORD)_wtoi(sz);
    }

    //
    // Copy the systemTime into stZulu so it has the correct val.
    //
    memcpy((void *)&stZulu,(const void *)&st, sizeof(SYSTEMTIME));

    //
    // Now check if there's a time zone listed.
    //
    if (*pszSrc != TEXT('\0')) {
        switch (*pszSrc) {

            case TEXT('-'):
            case TEXT('+'):
                {
                    BOOL fPositive = (*pszSrc == (TEXT('+')));
                    pszSrc++;

                    WORD wHours, wMinutes;
                    sz[0] = *pszSrc++;
                    sz[1] = *pszSrc++;
                    sz[2] = 0;
                    wHours = (WORD)_wtoi(sz);
                    sz[0] = *pszSrc++;
                    sz[1] = *pszSrc++;
                    wMinutes = _wtoi(sz) + 60 * wHours;

                    TIME_ZONE_INFORMATION tziOffset;
                    tziOffset.Bias = wMinutes * (fPositive ? 1 : -1);
                    tziOffset.StandardName[0] = TEXT('0');
                    tziOffset.StandardDate.wMonth = 0;
                    tziOffset.DaylightName[0] = TEXT('0');
                    tziOffset.DaylightDate.wMonth = 0;
                    if (!SystemTimeToTzSpecificLocalTime(
                        &tziOffset,
                        &st,
                        &stZulu)) {
                        RRETURN(hr = GetLastError());
                    }

                }
                //
                // Now it's converted to Zulu time, so convert it back
                // to local time.
                //
                /*FALLTHROUGH*/

            case TEXT('Z'):
                {
                    /*
                    //
                    // We want to return zulu time
                    // not local uncomment to enable conversion
                    // to localTime.
                    //
                    if (*pszSrc == TEXT('Z'))
                        // and not '+' or '-'...
                        memcpy((void *)&stZulu,
                            (const void *)&st,
                            sizeof(SYSTEMTIME));

                    TIME_ZONE_INFORMATION tziLocal;
                    GetTimeZoneInformation(&tziLocal);
                    if (!SystemTimeToTzSpecificLocalTime(
                        &tziLocal,
                        &stZulu,
                        &st)) {
                        RRETURN(hr = GetLastError());
                    }
                    */

                    //
                    // At this point we have the correct value
                    // in stZulu either way.
                    //
                    memcpy(
                        (void *) &st,
                        (const void *)&stZulu,
                        sizeof(SYSTEMTIME)
                    );

                }
                break;

            default:
                RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }
    }

cleanup:
    *pst = st;

    RRETURN(hr);
}


HRESULT
LdapTypeToAdsTypeUTCTime(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME st;

    PTSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);
    hr = UTCTimeStringToUTCTime(pszSrc,
                         &st);
    BAIL_ON_FAILURE(hr);

    pAdsDestValue->dwType = ADSTYPE_UTC_TIME;
    pAdsDestValue->UTCTime = st;
error:
    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeGeneralizedTime(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME st;

    PWSTR pszSrc = LDAPOBJECT_STRING(pLdapSrcObject);
    hr = GenTimeStringToUTCTime(pszSrc,
                                &st);
    BAIL_ON_FAILURE(hr);

    pAdsDestValue->dwType = ADSTYPE_UTC_TIME;
    pAdsDestValue->UTCTime = st;
error:
    RRETURN(hr);
}

HRESULT
LdapTypeToAdsTypeLargeInteger(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{

    HRESULT hr = S_OK;

    pAdsDestValue->dwType = ADSTYPE_LARGE_INTEGER;

    swscanf (LDAPOBJECT_STRING(pLdapSrcObject), L"%I64d", &pAdsDestValue->LargeInteger);

    RRETURN(hr);

}



//
// Just calls the helper routine - the helper is needed
// because of the way in which IDirectorySearch works
//
HRESULT
LdapTypeToAdsTypeDNWithBinary(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{

    RRETURN(LdapDNWithBinToAdsTypeHelper(
                LDAPOBJECT_STRING(pLdapSrcObject),
                pAdsDestValue
                )
            );
}


//
// Wire format of DNWithBinary is :
// B:32:a9d1ca15768811d1aded00c04fd8d5cd:dc=ntdev,dc=microsoft,dc=com
//
HRESULT
LdapDNWithBinToAdsTypeHelper(
    LPWSTR pszLdapSrcString,
    PADSVALUE pAdsDestValue
    )
{

    HRESULT hr = S_OK;
    DWORD dwCount = 0;
    DWORD dwBinLen = 0;
    LPWSTR pszLdapStr = NULL;
    LPBYTE lpByte = NULL;
    PADS_DN_WITH_BINARY pDNBin = NULL;
    WCHAR wCurChar;

    pAdsDestValue->dwType = ADSTYPE_DN_WITH_BINARY;

    pDNBin = (PADS_DN_WITH_BINARY) AllocADsMem(sizeof(ADS_DN_WITH_BINARY));

    if (!pDNBin) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pszLdapStr = pszLdapSrcString;

    if (!pszLdapStr) {
        //
        // NULL value
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (wcslen(pszLdapStr) < 5 ) {
        //
        // B:x:: is the smallest string
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    wCurChar = *pszLdapStr++;

    //
    // String should begin with B
    //
    if (wCurChar != L'B') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    //
    // Skip the : and get the length
    //
    *pszLdapStr++;

    dwCount = swscanf(pszLdapStr, L"%ld", &dwBinLen);

    //
    // This is the actual length of the byte array
    //
    dwBinLen /= 2;

    if (dwCount != 1) {
        //
        // Trouble reading the length
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    //
    // Go onto the start of the encoded string
    //
    while(*pszLdapStr && (wCurChar != L':')) {
        wCurChar = *pszLdapStr++;
    }

    if (wCurChar != L':') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }


    //
    // Get the byte array from string if there are any elements in it
    //
    if (dwCount != 0) {

        //
        // The DWORD cushion is to make sure we do not overwrite
        // the buffer while reading from the string.
        //
        lpByte = (LPBYTE) AllocADsMem(dwBinLen + sizeof(DWORD));

        if (!lpByte) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (dwCount = 0; dwCount < dwBinLen; dwCount++) {
            swscanf(pszLdapStr, L"%02X", &lpByte[dwCount]);
            pszLdapStr += 2;
        }

        pDNBin->lpBinaryValue = lpByte;
    }

    //
    // Get the DN
    //
    wCurChar = *pszLdapStr++;

    if (wCurChar != L':') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pDNBin->pszDNString = AllocADsStr(pszLdapStr);

    if (!pszLdapStr && !pDNBin->pszDNString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pDNBin->dwLength = dwBinLen;
    pAdsDestValue->pDNWithBinary = pDNBin;

    RRETURN(hr);

error:

    if (pDNBin) {
        if (pDNBin->pszDNString) {
            FreeADsStr(pDNBin->pszDNString);
        }
        FreeADsMem(pDNBin);
    }

    if (lpByte) {
        FreeADsMem(lpByte);
    }

    RRETURN(hr);

}

//
// Calls the helper that does the work - helper is needed by
// IDirectorySearch when returning columns.
//
HRESULT
LdapTypeToAdsTypeDNWithString(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{

    RRETURN(LdapDNWithStrToAdsTypeHelper(
                LDAPOBJECT_STRING(pLdapSrcObject),
                pAdsDestValue
                )
            );
}



//
// Wire format of DNWithString is :
// S:9:OurDomain:dc=ntdev,dc=microsoft,dc=com
//
HRESULT
LdapDNWithStrToAdsTypeHelper(
    LPWSTR pszLdapSrcString,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount = 0;
    DWORD dwStrLen = 0;
    LPWSTR pszLdapStr = NULL;
    PADS_DN_WITH_STRING pDNStr = NULL;
    WCHAR wCurChar;

    pAdsDestValue->dwType = ADSTYPE_DN_WITH_STRING;

    pDNStr = (PADS_DN_WITH_STRING) AllocADsMem(sizeof(ADS_DN_WITH_STRING));

    if (!pDNStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pszLdapStr = pszLdapSrcString;

    if (!pszLdapStr) {
        //
        // NULL value
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (wcslen(pszLdapStr) < 5) {
        //
        // S:x:: being the minimum
        //
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    wCurChar = *pszLdapStr++;

    if (wCurChar != L'S') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    //
    // Skip : and go onto the length
    //
    *pszLdapStr++;

    dwCount = swscanf(pszLdapStr, L"%ld:", &dwStrLen);

    wCurChar = *pszLdapStr;

    //
    // Go onto the start of the string
    //
    while (*pszLdapStr && (wCurChar != L':')) {
        wCurChar = *pszLdapStr++;
    }

    if (wCurChar != L':') {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    //
    // Copy over the string value if applicable
    //
    if (dwStrLen != 0) {

        pDNStr->pszStringValue = (LPWSTR)
                                    AllocADsMem((dwStrLen + 1) * sizeof(WCHAR));

        if (!pDNStr->pszStringValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcsncat(pDNStr->pszStringValue, pszLdapStr, dwStrLen);
    }

    //
    // Move past to begining of the DN
    //
    pszLdapStr += (dwStrLen+1);

    pDNStr->pszDNString = AllocADsStr(pszLdapStr);

    if (pszLdapStr && !pDNStr->pszDNString) {
        //
        // DN was not NULL and we could not alloc.
        //
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pAdsDestValue->pDNWithString = pDNStr;

    RRETURN(hr);

error:

    if (pDNStr) {

        if (pDNStr->pszStringValue) {
            FreeADsStr(pDNStr->pszStringValue);
        }

        if (pDNStr->pszDNString) {
            FreeADsStr(pDNStr->pszDNString);
        }

        FreeADsMem(pDNStr);
    }

    RRETURN(hr);

}


HRESULT
LdapTypeToAdsTypeProvSpecific(
    PLDAPOBJECT pLdapSrcObject,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLen = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);
    LPBYTE pBuffer = NULL;

    pAdsDestValue->dwType = ADSTYPE_PROV_SPECIFIC;

    if ( (pBuffer = (LPBYTE) AllocADsMem( dwLen )) == NULL )
        RRETURN(E_OUTOFMEMORY);

    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL(pLdapSrcObject), dwLen );

    pAdsDestValue->ProviderSpecific.dwLength = dwLen;

    pAdsDestValue->ProviderSpecific.lpValue = pBuffer;

    RRETURN(hr);

}

HRESULT
LdapTypeToAdsTypeCopy(
    PLDAPOBJECT pLdapSrcObject,
    DWORD dwSyntaxId,
    PADSVALUE pAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch ( dwSyntaxId ) {

        case LDAPTYPE_DN:
            hr = LdapTypeToAdsTypeDNString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_CASEEXACTSTRING:
            hr = LdapTypeToAdsTypeCaseExactString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_CASEIGNORESTRING:
//      case LDAPTYPE_CASEIGNOREIA5STRING:
        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING:
        case LDAPTYPE_IA5STRING:
        case LDAPTYPE_OID:
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:

        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER:
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_PRESENTATIONADDRESS:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_DSAQUALITYSYNTAX:
        case LDAPTYPE_DATAQUALITYSYNTAX:
        case LDAPTYPE_MAILPREFERENCE:
        case LDAPTYPE_OTHERMAILBOX:
        case LDAPTYPE_ACCESSPOINTDN:
        case LDAPTYPE_ORNAME:
        case LDAPTYPE_ORADDRESS:

            hr = LdapTypeToAdsTypeCaseIgnoreString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_PRINTABLESTRING:
            hr = LdapTypeToAdsTypePrintableString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;


        case LDAPTYPE_NUMERICSTRING:
            hr = LdapTypeToAdsTypeNumericString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_BOOLEAN:
            hr = LdapTypeToAdsTypeBoolean(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_INTEGER:
            hr = LdapTypeToAdsTypeInteger(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
            hr = LdapTypeToAdsTypeOctetString(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;


        case LDAPTYPE_SECURITY_DESCRIPTOR:
            hr = LdapTypeToAdsTypeNTSecurityDescriptor(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_UTCTIME:
            hr = LdapTypeToAdsTypeUTCTime(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_GENERALIZEDTIME:
            hr = LdapTypeToAdsTypeGeneralizedTime(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;

        case LDAPTYPE_INTEGER8:
            hr = LdapTypeToAdsTypeLargeInteger(
                    pLdapSrcObject,
                    pAdsDestValue
                    );
            break;


#if 0
        case LDAPTYPE_CASEEXACTLIST:
        case LDAPTYPE_CASEIGNORELIST:
#endif

        case LDAPTYPE_DNWITHBINARY:
            hr = LdapTypeToAdsTypeDNWithBinary(
                     pLdapSrcObject,
                     pAdsDestValue
                     );
            break;

        case LDAPTYPE_DNWITHSTRING:
            hr = LdapTypeToAdsTypeDNWithString(
                     pLdapSrcObject,
                     pAdsDestValue
                     );
            break;

        //
        // Treat unknown as provider specific blob.
        //

        case LDAPTYPE_UNKNOWN:
            hr = LdapTypeToAdsTypeProvSpecific(
                     pLdapSrcObject,
                     pAdsDestValue
                     );
            break;


        default:

            //
            // LDPATYPE_UNKNOWN (e.g schemaless server property)
            //

            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;
    }

    RRETURN(hr);
}


HRESULT
LdapTypeToAdsTypeCopyConstruct(
    LDAPOBJECTARRAY ldapSrcObjects,
    DWORD dwSyntaxId,
    LPADSVALUE *ppAdsDestValues,
    PDWORD pdwNumAdsValues,
    PDWORD pdwAdsType
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;
    DWORD dwNumObjects = ldapSrcObjects.dwCount;

    *ppAdsDestValues = NULL;
    *pdwNumAdsValues = dwNumObjects;
    *pdwAdsType = ADSTYPE_UNKNOWN;

    if (dwNumObjects != 0) {

        pAdsDestValues = (LPADSVALUE) AllocADsMem(
                                        dwNumObjects * sizeof(ADSVALUE)
                                        );

        if (!pAdsDestValues)
            RRETURN(E_OUTOFMEMORY);

        for ( i = 0; i < dwNumObjects; i++ ) {
            hr = LdapTypeToAdsTypeCopy(
                     ldapSrcObjects.pLdapObjects + i,
                     dwSyntaxId,
                     pAdsDestValues + i
                     );
            BAIL_ON_FAILURE(hr);
        }

        *ppAdsDestValues = pAdsDestValues;

        //
        // We will set the pdwAdsType value to the first type
        //

        *pdwAdsType = (pAdsDestValues)->dwType;
    } else {

        // Set the pddwAdsType appropriately, values are null.
        *pdwAdsType = MapLDAPTypeToADSType(dwSyntaxId);
    }


    RRETURN(S_OK);

error:

    if (pAdsDestValues) {

        AdsTypeFreeAdsObjects(
            pAdsDestValues,
            i
            );
    }

    *ppAdsDestValues = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\ldaptype.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ldaptype.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      25-Jun-96   yihsins   Created.
//
//  Warnings:

//----------------------------------------------------------------------------
#include "ldapc.hxx"


HRESULT
LdapFormatBinaryToString(
    IN PLDAPOBJECTARRAY pldapBinaryArray,
    IN OUT PLDAPOBJECTARRAY pldapStringArray
    );


VOID
LdapTypeFreeLdapObjects(
    LDAPOBJECTARRAY *pLdapObjectArray
    )
{
    DWORD i = 0;
    PLDAPOBJECT pLdapObject = pLdapObjectArray->pLdapObjects;

    if ( pLdapObjectArray->pLdapObjects == NULL )
        return;

    for ( i = 0; i < pLdapObjectArray->dwCount; i++ )
    {
        if ( pLdapObjectArray->fIsString )
        {
            if ( LDAPOBJECT_STRING( pLdapObject + i))
                FreeADsMem( LDAPOBJECT_STRING( pLdapObject + i));
        }
        else
        {
            if ( LDAPOBJECT_BERVAL( pLdapObject + i))
                FreeADsMem( LDAPOBJECT_BERVAL( pLdapObject + i));
        }
    }

    FreeADsMem( pLdapObjectArray->pLdapObjects );

    pLdapObjectArray->dwCount = 0;
    pLdapObjectArray->pLdapObjects = NULL;

    return;
}

HRESULT
LdapTypeCopy(
    PLDAPOBJECT pLdapSrcObject,
    PLDAPOBJECT pLdapDestObject,
    BOOL        fIsString
    )
{
    HRESULT hr = S_OK;

    if ( fIsString )
    {
        if ( (LDAPOBJECT_STRING(pLdapDestObject) =
                 AllocADsStr(LDAPOBJECT_STRING(pLdapSrcObject))) == NULL )

        {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }
    }
    else
    {
        DWORD nSize = LDAPOBJECT_BERVAL_LEN(pLdapSrcObject);

        if ( (LDAPOBJECT_BERVAL(pLdapDestObject) =
                 (struct berval *) AllocADsMem(sizeof(struct berval) + nSize))
            == NULL )
        {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }

        LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = nSize;
        LDAPOBJECT_BERVAL_VAL(pLdapDestObject) =
            (char *) ( (LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject)
                     + sizeof(struct berval));

        memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
                LDAPOBJECT_BERVAL_VAL(pLdapSrcObject),
                LDAPOBJECT_BERVAL_LEN(pLdapSrcObject) );
    }

    RRETURN(S_OK);
}

HRESULT
LdapTypeCopyConstruct(
    LDAPOBJECTARRAY ldapSrcObjects,
    LDAPOBJECTARRAY *pLdapDestObjects
    )
{
    DWORD i = 0;
    PLDAPOBJECT pLdapTempObjects = NULL;
    HRESULT hr = S_OK;
    LDAPOBJECTARRAY DummyObjectArray;
    //
    // Init as we will need info on failures
    //
    LDAPOBJECTARRAY_INIT(DummyObjectArray);

    pLdapTempObjects = (PLDAPOBJECT)AllocADsMem(
                           (ldapSrcObjects.dwCount + 1) * sizeof(LDAPOBJECT));

    DummyObjectArray.pLdapObjects = pLdapTempObjects;


    if (!pLdapTempObjects) {
        RRETURN(E_OUTOFMEMORY);
    }

     for (i = 0; i < ldapSrcObjects.dwCount; i++ ) {
         hr = LdapTypeCopy( &(ldapSrcObjects.pLdapObjects[i]),
                            pLdapTempObjects + i,
                            ldapSrcObjects.fIsString );
         if ( hr != S_OK )
             break;
         DummyObjectArray.dwCount = i + 1;
     }

     if ( hr == S_OK )
     {
         pLdapDestObjects->fIsString = ldapSrcObjects.fIsString;
         pLdapDestObjects->dwCount = ldapSrcObjects.dwCount;
         pLdapDestObjects->pLdapObjects = pLdapTempObjects;
     }

     //
     // Need to free if we failed an pLdapTempObjects is valid.
     //
     if (FAILED(hr) && pLdapTempObjects) {
         LdapTypeFreeLdapObjects(&DummyObjectArray);
     }
     RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////////
//
// If [dwLdapSyntax] indicates binary format,
//      return S_FALSE and an empty [ldapStringArray].
//
// If [dwLdapSyntax] indicates string format,
//      convert data from binary format [ldapBinaryArray] to string format
//      [ldapStringArray] and return S_OK.
//
// If [dwldapSyntax] is invalid,
//      return E_ADS_CANT_CONVERT_DATATYPE.
//
////////////////////////////////////////////////////////////////////////////

HRESULT
LdapTypeBinaryToString(
    IN DWORD dwLdapSyntax,
    IN PLDAPOBJECTARRAY pldapBinaryArray,
    IN OUT PLDAPOBJECTARRAY pldapStringArray
    )
{
    HRESULT hr = S_FALSE;


    //
    // dll exported function, don't use assert
    //

    if (!pldapBinaryArray || !pldapStringArray)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }


    switch (dwLdapSyntax) {

        //
        // syntax indicates binary data
        //

        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_SECURITY_DESCRIPTOR:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
        case LDAPTYPE_UNKNOWN:
        {
            //
            // no conversion needed, return empty string objects for efficiency
            //

            pldapStringArray->dwCount = 0;
            pldapStringArray->pLdapObjects = NULL;

            hr = S_FALSE;
            break;
        }


        //
        // syntax indicates string data
        //

        case LDAPTYPE_BITSTRING:
        case LDAPTYPE_PRINTABLESTRING:
        case LDAPTYPE_DIRECTORYSTRING:
        case LDAPTYPE_COUNTRYSTRING :
        case LDAPTYPE_DN:
        case LDAPTYPE_DELIVERYMETHOD:
        case LDAPTYPE_ENHANCEDGUIDE:
        case LDAPTYPE_FACSIMILETELEPHONENUMBER :
        case LDAPTYPE_GUIDE:
        case LDAPTYPE_NAMEANDOPTIONALUID:
        case LDAPTYPE_NUMERICSTRING:
        case LDAPTYPE_OID:
        case LDAPTYPE_POSTALADDRESS:
        case LDAPTYPE_PRESENTATIONADDRESS :
        case LDAPTYPE_TELEPHONENUMBER:
        case LDAPTYPE_TELEXNUMBER:
        case LDAPTYPE_UTCTIME:
        case LDAPTYPE_BOOLEAN:
        case LDAPTYPE_DSAQUALITYSYNTAX   :
        case LDAPTYPE_DATAQUALITYSYNTAX  :
        case LDAPTYPE_IA5STRING          :
        case LDAPTYPE_MAILPREFERENCE     :
        case LDAPTYPE_OTHERMAILBOX       :
        case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
        case LDAPTYPE_GENERALIZEDTIME    :
        case LDAPTYPE_INTEGER            :
        case LDAPTYPE_OBJECTCLASSDESCRIPTION:
        // The following are for NTDS
        case LDAPTYPE_CASEIGNORESTRING   :
        case LDAPTYPE_INTEGER8           :
        case LDAPTYPE_ACCESSPOINTDN      :
        case LDAPTYPE_ORNAME             :
        case LDAPTYPE_CASEEXACTSTRING    :
        case LDAPTYPE_DNWITHBINARY       :
        case LDAPTYPE_DNWITHSTRING       :
        case LDAPTYPE_ORADDRESS:
        {
            //
            // convert to string format
            //
            hr = LdapFormatBinaryToString(
                        pldapBinaryArray,
                        pldapStringArray
                        );
            BAIL_ON_FAILURE(hr);

            break;
        }


        //
        // syntax is invalid
        //

        default:
        {
            pldapStringArray->dwCount = 0;
            pldapStringArray->pLdapObjects = NULL;

            hr = E_FAIL;
            break;
        }
    }


error:


    RRETURN(hr);

}


///////////////////////////////////////////////////////////////////////////
//
// Convert LDAPOBJECTARRAY from binary [pldapBinaryArray] to string
// [pldaStringArray] format.
//
// Return S_OK or E_ADS_CANT_CONVERT_DATATYPE.
//
///////////////////////////////////////////////////////////////////////////

HRESULT
LdapFormatBinaryToString(
    IN PLDAPOBJECTARRAY pldapBinaryArray,
    IN OUT PLDAPOBJECTARRAY pldapStringArray
    )
{
    HRESULT hr = S_OK;
    PLDAPOBJECT pldapBinary = NULL;
    PLDAPOBJECT pldapString = NULL;
    LPTSTR lpszMaxString = NULL;
    DWORD i =0;
    DWORD dwMaxLen = 0;
    DWORD dwCurrentLen = 0;
    DWORD dwObjectCount = 0;
    DWORD dwObjectBlockSize = 0;


    //
    // in case of dll exporting this funct'n later, don't use assert
    //

    if (!pldapBinaryArray || !pldapStringArray)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    dwObjectCount = pldapBinaryArray->dwCount;
    dwObjectBlockSize = dwObjectCount * sizeof (PLDAPOBJECT);

    //
    // initialize in ldapStringArray structure
    //

    pldapStringArray->fIsString = TRUE;
    pldapStringArray->dwCount = dwObjectCount;
    pldapStringArray->pLdapObjects = (PLDAPOBJECT) AllocADsMem(
                                                        dwObjectBlockSize
                                                        );
    if (!(pldapStringArray->pLdapObjects))
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset( pldapStringArray->pLdapObjects, 0, dwObjectBlockSize);

    //
    // find max size of binary object in pldapBinaryArray
    //

    for (i=0; i<dwObjectCount; i++)
    {
        pldapBinary = &(pldapBinaryArray->pLdapObjects[i]);

        dwCurrentLen = LDAPOBJECT_BERVAL_LEN(pldapBinary);

        (dwCurrentLen > dwMaxLen) ? (dwMaxLen = dwCurrentLen) : 1;
    }


    //
    // allocate string of max size in pldapStringArray:
    //      - binary data in UTF8 (a MBCS) format, worst case each UTF8 char
    //        represents one char in string
    //      - +1 for '\0' just in case
    //

    lpszMaxString = (LPTSTR) AllocADsMem(
                                (dwMaxLen + 1) * sizeof (WCHAR)
                                );
    if (!lpszMaxString)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    //
    // convert each ldap object from binary to string format
    //

    for (i=0; i<pldapBinaryArray->dwCount; i++)
    {
        pldapBinary = &(pldapBinaryArray->pLdapObjects[i]);
        pldapString = &(pldapStringArray->pLdapObjects[i]);

        memset (lpszMaxString, 0, (dwMaxLen+1) * sizeof(WCHAR));


        if (LDAPOBJECT_BERVAL_LEN(pldapBinary)>0)
        {

            (VOID)  LdapUTF8ToUnicode(
                        LDAPOBJECT_BERVAL_VAL(pldapBinary),
                        LDAPOBJECT_BERVAL_LEN(pldapBinary),
                        (LPWSTR) lpszMaxString,
                        dwMaxLen+1
                        );

            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);

            LDAPOBJECT_STRING(pldapString) = AllocADsStr(
                                                lpszMaxString
                                                );
            if (!pldapString)
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }

        else
        {
            //
            // in case ldap binary object empty, string counter part already
            // set to null during initialization
            //
        }
    }


error:

    if (lpszMaxString)
        FreeADsStr(lpszMaxString);


    if (FAILED(hr))
    {
        pldapStringArray->dwCount = i;  // clean up object 0th to (i-1)th
        LdapTypeFreeLdapObjects(pldapStringArray);  //return empty string array
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\ldaputil.cxx ===
#include "ldapc.hxx"
#pragma hdrstop

//
// Local helpers
//

extern "C" {
DWORD
GetDefaultLdapServer(
    LPWSTR Addresses[],
    LPDWORD Count,
    BOOL Verify,
    DWORD dwPort
    ) ;

}

WINLDAPAPI ULONG LDAPAPI ldap_get_optionW(
                             LDAP *ld,
                             int option,
                             void *outvalue
                             );

DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

int ConvertToAscii( WCHAR *pszUnicode, char **pszAscii );
int ConvertLDAPMod( LDAPModW **mods, LDAPModA ***modsA );
void FreeLDAPMod( LDAPModA **modsA );
BOOLEAN LDAPCodeWarrantsRetry(HRESULT hr);


HRESULT LdapSearchHelper(
    LDAP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
);


HRESULT
GetOneToken(
    LPWSTR pszSource,
    LPWSTR * ppszToken,
    DWORD * pdwTokenLen,
    BOOL * pfMore
    );

DWORD
    MaskKnownFlagsNotChecked(DWORD dwFlags)
{
    DWORD dwRetVal = dwFlags;

    dwRetVal &= ~(ADS_PROMPT_CREDENTIALS
                        | ADS_FAST_BIND
                        | ADS_READONLY_SERVER
                        | ADS_USE_SIGNING
                        | ADS_USE_SEALING
                        | ADS_USE_DELEGATION
                        | ADS_SERVER_BIND
                        | ADS_AUTH_RESERVED
                        );

    return dwRetVal;

}


LPWSTR gpszServerName = NULL;
LPWSTR gpszDomainName = NULL;

//
// High level Open/Close object functions
//
HRESULT LdapOpenObject(
    LPWSTR szLDAPServer,
    LPWSTR szLDAPDn,
    ADS_LDP  **ld,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    return LdapOpenObject2(
               szLDAPServer,
               NULL,
               szLDAPDn,
               ld,
               Credentials,
               dwPort
               );
}


HRESULT LdapOpenObject2(
    LPWSTR szDomainName,
    LPWSTR szLDAPServer,
    LPWSTR szLDAPDn,
    ADS_LDP  **ld,
    CCredentials& Credentials,
    DWORD dwPort
)
{

    HRESULT hr = S_OK;
    int     err = NO_ERROR;
    LUID Luid, ModifiedId;
    PADS_LDP pCacheEntry = NULL ;
    BOOL fAddToCache = TRUE ;

    LPWSTR aAddresses[5];
    BOOL fServerNotSpecified = FALSE;
    BOOL fVerify = FALSE;
    WCHAR szDomainDnsName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];

    DWORD dwFlags = Credentials.GetAuthFlags();
    BOOL fStickyServerSpecified = (gpszServerName != NULL);

    //
    // start by nulling out this return value
    //
    *ld = NULL ;

    //
    //  Now if the server name is Null - Get a serverName
    //

    if (!szDomainName) {


RetryGetDefaultServer:

        err = GetDefaultServer(
                  dwPort,
                  fVerify,
                  szDomainDnsName,
                  szServerName,
                  !(dwFlags & ADS_READONLY_SERVER) ? TRUE : FALSE
                  );

        if (err != NOERROR) {
            return HRESULT_FROM_WIN32(err);
        }

        if (fStickyServerSpecified) {
            //
            // We need to change the name of the domain to be that of
            // the server we want to target. The swap is made if 
            // 1) gpszDomainName == NULL, that implies that just 
            // a serverName was set and not which domain it applies to.
            // 2) If a domainName is specified, then the domainName
            // from above should be that set in the global pointer for
            // the target server to be changed.
            //
            if ((gpszDomainName
                 && (!_wcsicmp(szDomainDnsName, gpszDomainName))
                 )
                || (gpszDomainName == NULL)
                ) {
                //
                // We need to change the target to the server.
                //
                wcscpy(szDomainDnsName,gpszServerName);
                szServerName[0] = L'\0';
                //
                // Make sure if server is down we go to another
                // server on the retryGetDefault server path.
                //
                fStickyServerSpecified = FALSE;
            }
        }

        szDomainName = szDomainDnsName;
        szLDAPServer = szServerName;
        fServerNotSpecified = TRUE;
    }

#ifndef WIN95
    //
    // try the cache first. if find entry, just use it (this bumps ref count
    // up by one). if we cant get LUID, we dont use the cache.
    //
    if ((err = BindCacheGetLuid(&Luid, &ModifiedId)) == NO_ERROR) {

        //
        // Try the cache for the passed in credentials.
        //

        if (pCacheEntry = BindCacheLookup(szDomainName, Luid, ModifiedId, Credentials, dwPort)) {

             *ld = pCacheEntry ;
             return S_OK ;
        }


    }
    else {

        //
        // pick something that would NOT match anything else. and
        // never put this in the cache
        //
        Luid = ReservedLuid ;
        ModifiedId = ReservedLuid;

        fAddToCache = FALSE ;

    }

#else
    //
    // In the case of win95, however, we always make the Luid to be the reserved
    // one and lookup the cache. If found use it, otherwise, add it.
    //

    Luid = ReservedLuid ;
    ModifiedId = ReservedLuid;

    if (pCacheEntry = BindCacheLookup(szDomainName, Luid, ModifiedId, Credentials, dwPort)) {

         *ld = pCacheEntry ;
         return S_OK ;
    }

#endif



    //
    // allocate the pseudo handle (also the cache entry).
    //

    err = BindCacheAllocEntry(&pCacheEntry) ;

    if (err != NO_ERROR) {

        return HRESULT_FROM_WIN32(err);
    }


    if (!Credentials.IsNullCredentials()) {

        hr = LdapOpenBindWithCredentials(
                  szDomainName,
                  szLDAPServer,
                  Credentials,
                  pCacheEntry,
                  dwPort
                  );

    }else {

        //
        // We just want to try with NULL and NULL and
        // whatever flags were passed in. No longer want
        // to try and get credentials from registry.
        //


        hr = LdapOpenBindWithDefaultCredentials(
                    szDomainName,
                    szLDAPServer,
                    Credentials,
                    pCacheEntry,
                    dwPort
                    );

    }


    //
    // This is the Server-Less case; where we retry with a force
    // server to get a valid ServerName.
    //

    if (((hr == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH)) ||
         (hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN))) &&
        !fVerify && fServerNotSpecified) {
        fVerify = TRUE;
        LdapUnbind(pCacheEntry);
        goto RetryGetDefaultServer ;
    }



    //
    // if success we add to cache. else unbind & cleanup.
    //
    if (SUCCEEDED(hr)) {

        if (!fAddToCache) {

            //
            // do not insert in cache since we didnt get LUID
            //

        }
        else {


            err = BindCacheAdd(szDomainName, Luid, ModifiedId, Credentials, dwPort, pCacheEntry) ;

            if (err != NO_ERROR) {

                LdapUnbind(pCacheEntry) ;
                hr = HRESULT_FROM_WIN32(err);
            }
        }
    }
    else {
        //
        // Bind failed, force err so that we will clean up
        // and return correct value
        //

        LdapUnbind(pCacheEntry) ;   // needed to close out connection
        //
        // Set error value so that we do not return pCacheEntry.
        //
        err = ERROR_GEN_FAILURE;

    }

    if (err == NO_ERROR) {

             *ld = pCacheEntry ;
    }
    else {

        FreeADsMem(pCacheEntry) ;
    }

    return hr;
}


void LdapCloseObject(
    ADS_LDP *ld
)
{
    //
    // We will delete only if the count is zero and the keeparound
    // flag is not set.
    //
    if ((BindCacheDeref(ld) == 0) && !ld->fKeepAround) {

        //
        // ref count has dropped to zero and its gone from cache.
        //
        LdapUnbind(ld);
        FreeADsMem(ld);
    }
}

//
// This routine adds a ref to the pointer. Note that to release
// you use the LdapCloseObject routine.
//
void LdapCacheAddRef(
    ADS_LDP *ld
    )
{
    ADsAssert(ld);
    BindCacheAddRef(ld);
}


//
// NOTE: Ldap\ibute returns S_OK if attribute [szAttr] has no
//       values (*[aValues]=NULL, *[ncount]=0) but all else ok.
//

HRESULT LdapReadAttribute(
    WCHAR *szLDAPServer,
    LPWSTR szLDAPDn,
    WCHAR *szAttr,
    WCHAR ***aValues,
    int   *nCount,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    return LdapReadAttribute2(
               szLDAPServer,
               NULL,
               szLDAPDn,
               szAttr,
               aValues,
               nCount,
               Credentials,
               dwPort
               );

}


//
// NOTE: LdapReadAttribute2 returns S_OK if attribute [szAttr] has no
//       values (*[aValues]=NULL, *[ncount]=0) but all else ok.
//

HRESULT LdapReadAttribute2(
    WCHAR *szDomainName,
    WCHAR *szLDAPServer,
    LPWSTR szLDAPDn,
    WCHAR *szAttr,
    WCHAR ***aValues,
    int   *nCount,
    CCredentials& Credentials,
    DWORD dwPort,
    LPWSTR szFilter // defaulted to NULL
)
{
    HRESULT hr = S_OK;
    ADS_LDP *ld = NULL;
    LPWSTR aStrings[2];
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPWSTR szFilterString = L"(objectClass=*)";

    if (szFilter != NULL) {
        szFilterString = szFilter;
    }

    hr = LdapOpenObject2(
                szDomainName,
                szLDAPServer,
                szLDAPDn,
                &ld,
                Credentials,
                dwPort
                );

    if (FAILED(hr))
        goto CleanExit;

    aStrings[0] = szAttr;
    aStrings[1] = NULL;

    ADsAssert(ld && ld->LdapHandle);

    hr = LdapSearchS( ld,
                      szLDAPDn,
                      LDAP_SCOPE_BASE,
                      szFilterString,
                      aStrings,
                      0,
                      &res );

    // Only one entry should be returned

    if (  FAILED(hr)
       || FAILED(hr = LdapFirstEntry( ld, res, &e ))
       || FAILED(hr = LdapGetValues( ld, e, szAttr, aValues, nCount ))
       )
    {
       goto CleanExit;
    }

CleanExit:

    if ( res )
        LdapMsgFree( res );

    if ( ld ){
        LdapCloseObject( ld );
    }

    return hr;
}


//
// This is similar to ReadAttribute but uses a handle to avoid
// the lookup in the bindCache
//
HRESULT LdapReadAttributeFast(
            ADS_LDP *ld,
            LPWSTR szLDAPDn,
            WCHAR *szAttr,
            WCHAR ***aValues,
            int   *nCount
            )
{
    HRESULT hr = S_OK;
    LPWSTR aStrings[2];
    LDAPMessage *res = NULL;
    LDAPMessage *entry = NULL;

    aStrings[0] = szAttr;
    aStrings[1] = NULL;

    hr = LdapSearchS(
             ld,
             szLDAPDn,
             LDAP_SCOPE_BASE,
             L"(objectClass=*)",
             aStrings,
             0,
             &res
             );

    // Only one entry should be returned

    if (  FAILED(hr)
          || FAILED(hr = LdapFirstEntry( ld, res, &entry ))
          || FAILED(hr = LdapGetValues( ld, entry, szAttr, aValues, nCount ))
          )
    {
        goto CleanExit;
    }

CleanExit:

    if ( res )
        LdapMsgFree( res );

    RRETURN(hr);

}



//
// Wrappers around the ldap functions
//

HRESULT LdapOpen( WCHAR *domainName, WCHAR *hostName, int portno, ADS_LDP *ld, DWORD dwFlags )
{
    HRESULT hr = 0;
    int ldaperr = 0;
    PADS_LDP pCacheEntry = ld ;
    DWORD dwOptions = 0;

    void *ldapOption;

    //
    // Reset the handle first
    //
    pCacheEntry->LdapHandle = NULL;

    pCacheEntry->LdapHandle = ldap_init( domainName, portno );

    if ( (pCacheEntry->LdapHandle) == NULL ) {

        hr = HRESULT_FROM_WIN32(ERROR_BAD_NETPATH);
        goto error;
    }

    ldaperr = ldap_get_option(pCacheEntry->LdapHandle, LDAP_OPT_GETDSNAME_FLAGS, &dwOptions);

    if (ldaperr != LDAP_SUCCESS) {
        CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
        goto error;
    }

    if (portno == GC_PORT || portno == GC_SSL_PORT) {

        dwOptions |= DS_GC_SERVER_REQUIRED;

    } else if (!(dwFlags & ADS_READONLY_SERVER) ) {

        dwOptions |= DS_WRITABLE_REQUIRED;

    }

    ldaperr = ldap_set_option(pCacheEntry->LdapHandle, LDAP_OPT_GETDSNAME_FLAGS,(void *)&dwOptions);

    if (ldaperr != LDAP_SUCCESS) {
        CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
        goto error;
    }

    //
    // Now process prompt for credentials
    //

    if (dwFlags & ADS_PROMPT_CREDENTIALS) {

        ldapOption = (void *) LDAP_OPT_ON;
    }else {
        ldapOption = (void *) LDAP_OPT_OFF;
    }

    ldaperr = ldap_set_option(pCacheEntry->LdapHandle, LDAP_OPT_PROMPT_CREDENTIALS, &(ldapOption));

    if (ldaperr != LDAP_SUCCESS) {
        CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
        goto error;
    }

    //
    // Now init SSL if encryption is required. This is essentially if this option is on and the
    // user did not specify an SSL port.
    //

    if (dwFlags & ADS_USE_ENCRYPTION) {
        ldapOption = (void *) LDAP_OPT_ON;
        ldaperr = ldap_set_option(pCacheEntry->LdapHandle, LDAP_OPT_SSL, &(ldapOption));

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }
    }

    //
    // Process the other options that can be set in the flags.
    //
    //
    if (dwFlags & ADS_USE_SIGNING) {
        //
        // User has requested that packets be signed
        //
        ldapOption = (void *) LDAP_OPT_ON;
        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_SIGN,
                      &(ldapOption)
                      );

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }
    }

    if (dwFlags & ADS_USE_SEALING) {
        //
        // User has requested that packet are sealed
        //
        ldapOption = (void *) LDAP_OPT_ON;
        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_ENCRYPT,
                      &(ldapOption)
                      );

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }
    }

    //
    // Now process versioning
    //

    ldapOption = (void *) LDAP_VERSION3;

    ldaperr = ldap_set_option(
                  pCacheEntry->LdapHandle,
                  LDAP_OPT_VERSION,
                  &(ldapOption)
                  );

    //
    // Non critical if the above fails
    //

    if (hostName) {
        ldapOption = (void *) hostName;

        ldaperr = ldap_set_optionW(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_HOST_NAME,
                      &(ldapOption)
                      );

        // Does not matter even if this setoption fails.
    }

    //
    // Process delegation if set
    //
    if (dwFlags & ADS_USE_DELEGATION) {

#ifndef Win95
        //
        // Relying on LDAP/server to enforce the requirement for
        // secure auth for this to work.
        //
        DWORD dwSSPIFlags = 0;

        //
        // Get the current values.
        //
        ldapOption = (void *)&dwSSPIFlags;
        ldaperr = ldap_get_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_SSPI_FLAGS,
                      ldapOption
                      );

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }

        //
        // Add delegation to the list.
        //
        dwSSPIFlags |= ISC_REQ_DELEGATE;

        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_SSPI_FLAGS,
                      ldapOption
                      );

        if (ldaperr != LDAP_SUCCESS) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }
#else
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
#endif

    }

    //
    // Set the AREC exclusive option if applicable.
    //
    if (dwFlags & ADS_SERVER_BIND) {

        ldapOption = (void *) LDAP_OPT_ON;
        
        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_AREC_EXCLUSIVE,
                      &(ldapOption)
                      );

        //
        // Should we ignore this error ?
        //
        if (ldaperr) {
            CheckAndSetExtendedError(pCacheEntry->LdapHandle, &hr, ldaperr);
            goto error;
        }

    }

    ldaperr = ldap_connect(pCacheEntry->LdapHandle, NULL);

    if (ldaperr) {

        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );
        goto error;

    }

    if (pCacheEntry->LdapHandle) {

        //
        // Set the option for this connection giving our Callback functions
        //
        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_REFERRAL_CALLBACK,
                      &g_LdapReferralCallBacks
                      );

        ldapOption = (void *) LDAP_CHASE_EXTERNAL_REFERRALS;

        ldaperr = ldap_set_option(
                      pCacheEntry->LdapHandle,
                      LDAP_OPT_REFERRALS,
                      &(ldapOption)
                      );

    }

    return hr;

error:

    if (pCacheEntry->LdapHandle != NULL) {

        LdapUnbind(pCacheEntry);
    }

    return hr;
}

HRESULT LdapBindS( ADS_LDP *ld, WCHAR *dn, WCHAR *passwd, BOOL fSimple )
{
    LPWSTR pszNTLMUser = NULL;
    LPWSTR pszNTLMDomain = NULL;

    HRESULT hr = 0;
    int ldaperr = 0;
    DWORD dwLastLdapError = 0;

    ADsAssert(ld && ld->LdapHandle);

    if (fSimple)  {

        ldaperr = ldap_simple_bind_s( ld->LdapHandle, dn, passwd ) ;
    }
    else {

        if (dn || passwd) {

            //
            // If we have a non-null dn and/or a non-null password, we pass in
            // a SEC_WINNT_AUTH_IDENTITY blob with the NTLM credentials
            //

            hr = LdapCrackUserDNtoNTLMUser2(
                        dn,
                        &pszNTLMUser,
                        &pszNTLMDomain
                        );

            if (FAILED(hr)) {
                hr = LdapCrackUserDNtoNTLMUser(
                        dn,
                        &pszNTLMUser,
                        &pszNTLMDomain
                        );
                BAIL_ON_FAILURE(hr);
            }


            SEC_WINNT_AUTH_IDENTITY AuthI;

            AuthI.User = (PWCHAR)pszNTLMUser;
            AuthI.UserLength = (pszNTLMUser == NULL)? 0: wcslen(pszNTLMUser);
            AuthI.Domain = (PWCHAR)pszNTLMDomain;
            AuthI.DomainLength = (pszNTLMDomain == NULL)? 0: wcslen(pszNTLMDomain);
            AuthI.Password = (PWCHAR)passwd;
            AuthI.PasswordLength = (passwd == NULL)? 0: wcslen(passwd);
            AuthI.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;




            ldaperr = ldap_bind_s( ld->LdapHandle, NULL, (WCHAR*)(&AuthI), LDAP_AUTH_SSPI );

        }else {

            //
            // Otherwise we've come in with NULL, NULL - pass in NULL, NULL. The reason we
            // do this is that ldap bind code oes not process NULL, NULL, NULL in the
            // SEC_WINNT_AUTH_IDENTITY blob !!!
            //


            ldaperr = ldap_bind_s( ld->LdapHandle, NULL, NULL, LDAP_AUTH_SSPI );

        }

    }

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    //
    // If it is a local error for secure bind try and get
    // more error info and store in ADsLastError.
    //
    if (!fSimple && (ldaperr == LDAP_LOCAL_ERROR)) {

        dwLastLdapError = LdapGetLastError();

        if (dwLastLdapError) {
            //
            // Set ADSI extended error code.
            //
            ADsSetLastError(
                dwLastLdapError,
                L"",
                L"LDAP Provider"
                );
        }
    }

error:

    if (pszNTLMUser) {

        FreeADsStr(pszNTLMUser);
    }

    if (pszNTLMDomain) {

        FreeADsStr(pszNTLMDomain);
    }


    return hr;
}

HRESULT LdapUnbind( ADS_LDP *ld )
{
    HRESULT hr = NO_ERROR;

    ADsAssert(ld);

    if (ld->LdapHandle) {

        int ldaperr = ldap_unbind( ld->LdapHandle );
        // Need to set the handle to null as we may call
        // unbind twice otherwise

        ld->LdapHandle = NULL;

        // There is nothing much we can do about err status
        // CheckAndSetExtendedError could cause further problems
        // if the handle is not valid so we return E_FAIL
        // if the unbind failed.

        if (ldaperr ) {
           hr = E_FAIL;
        }

    }


    return hr;
}

HRESULT LdapSearchHelper(
    LDAP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
)
{
    HRESULT hr = 0;
    int ldaperr = 0;

    if ( timeout == NULL )
    {
        ldaperr = ldap_search_s( ld,
                                 base,
                                 scope,
                                 filter,
                                 attrs,
                                 attrsonly,
                                 res );
    }
    else
    {
        ldaperr = ldap_search_st( ld,
                                  base,
                                  scope,
                                  filter,
                                  attrs,
                                  attrsonly,
                                  timeout,
                                  res );
    }

    if (ldaperr) {

       if (!ldap_count_entries( ld, *res )) {

           CheckAndSetExtendedError( ld, &hr, ldaperr, *res );
       }
    }else {

        hr = S_OK;
    }

    return hr;
}

HRESULT LdapSearchS(
    ADS_LDP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    LDAPMessage **res
)
{
    ADsAssert(ld && ld->LdapHandle);

    HRESULT hr = LdapSearchHelper(
                  ld->LdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  NULL,
                  res );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapSearchST(
    ADS_LDP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
)
{
    ADsAssert(ld && ld->LdapHandle);

    HRESULT hr = LdapSearchHelper(
                  ld->LdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  timeout,
                  res );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapSearch(
    ADS_LDP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    int   *msgid
)
{

    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *msgid = ldap_search( ld->LdapHandle,
                          base,
                          scope,
                          filter,
                          attrs,
                          attrsonly );

    if ( *msgid == -1 )
    {
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);
    }

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapModifyS(
    ADS_LDP  *ld,
    WCHAR *dn,
    LDAPModW *mods[]
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_modify_s( ld->LdapHandle, dn, mods);

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapModifyExtS(
    ADS_LDP  *ld,
    WCHAR *dn,
    LDAPModW *mods[],
    PLDAPControlW * ServerControls,
    PLDAPControlW * ClientControls
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_modify_ext_s( ld->LdapHandle, dn, mods, ServerControls, ClientControls);

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapModRdnS(
    ADS_LDP *ld,
    WCHAR *dn,
    WCHAR *newrdn
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_modrdn_s( ld->LdapHandle, dn, newrdn );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}



//+------------------------------------------------------------------------
//
//  Function:   LdapRenameExtS
//
//  Synopsis: Extended renam/modifyRDN which will move objects across
//          namespaces as opposed to modifyRDN which cannot do the same.
//
//
//  Arguments:  [ld]            -- ldap handle.
//              [dn]            -- dn of object to be moved.
//              [newRDN]        -- New RDN of the object being moved.
//              [newParent]     -- New Parent.
//              [deleteOldRDN]  --
//              [ServerControls]-- Server Control to be used.
//              [ClientControls]-- Client Control to be used.
//-------------------------------------------------------------------------
HRESULT LdapRenameExtS(
    ADS_LDP  *ld,
    WCHAR *dn,
    WCHAR *newRDN,
    WCHAR *newParent,
    int deleteOldRDN,
    PLDAPControlW * ServerControls,
    PLDAPControlW * ClientControls
    )
{
    HRESULT hr = S_OK;
    int ldaperr = 0;


    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_rename_ext_sW(
                  ld->LdapHandle,
                  dn,
                  newRDN,
                  newParent,
                  deleteOldRDN,
                  ServerControls,
                  ClientControls
                  );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;

    }

    return hr;
}


HRESULT LdapModDnS(
    ADS_LDP  *ld,
    WCHAR *dn,
    WCHAR *newdn,
    int   deleteoldrdn
    )
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_modrdn2_s(
                  ld->LdapHandle,
                  dn,
                  newdn,
                  deleteoldrdn );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;

    }

    return hr;
}

HRESULT LdapAddS(
    ADS_LDP  *ld,
    WCHAR *dn,
    LDAPModW *attrs[]
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_add_s( ld->LdapHandle, dn, attrs );

    CheckAndSetExtendedError( ld->LdapHandle , &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


//
// Add ext wrapper function
//
HRESULT LdapAddExtS(
    ADS_LDP  *ld,
    WCHAR *dn,
    LDAPModW *attrs[],
    PLDAPControl * ServerControls,
    PLDAPControl * ClientControls
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_add_ext_s(
                  ld->LdapHandle,
                  dn,
                  attrs,
                  ServerControls,
                  ClientControls
                  );

    CheckAndSetExtendedError( ld->LdapHandle , &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapDeleteS(
    ADS_LDP  *ld,
    WCHAR *dn
)
{
    HRESULT hr = 0;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_delete_s( ld->LdapHandle, dn );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapDeleteExtS(
    ADS_LDP  *ld,
    WCHAR *dn,
    PLDAPControlW * ServerControls,
    PLDAPControlW * ClientControls
    )
{
    HRESULT hr = 0;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_delete_ext_s(
                    ld->LdapHandle,
                    dn,
                    ServerControls,
                    ClientControls
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;

}


HRESULT
LdapCompareExt(
    ADS_LDP *ld,
    const LPWSTR pszDn,
    const LPWSTR pszAttribute,
    const LPWSTR pszValue,
    struct berval *berData,
    PLDAPControlW * ServerControls,
    PLDAPControlW * ClientControls
    )
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    ldaperr = ldap_compare_ext_s(
                  ld->LdapHandle,
                  pszDn,
                  pszAttribute,
                  pszValue,
                  berData,
                  ServerControls,
                  ClientControls
                  );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {
        BindCacheInvalidateEntry(ld) ;
    }

    RRETURN(hr);
}


HRESULT LdapAbandon(
    ADS_LDP  *ld,
    int   msgid
)
{
    ADsAssert(ld && ld->LdapHandle);

    // No error code, 0 if success, -1 otherwise
    return ldap_abandon( ld->LdapHandle, msgid );
}

HRESULT LdapResult(
    ADS_LDP   *ld,
    int    msgid,
    int    all,
    struct l_timeval *timeout,
    LDAPMessage **res,
    int    *restype
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *restype = ldap_result( ld->LdapHandle, msgid, all, timeout, res );

    if ( *restype == -1 )  // error
        ldaperr = LdapGetLastError();

    if (ldaperr) {

       if (!ldap_count_entries( ld->LdapHandle, *res )) {

           CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, *res );

            if ( LdapConnectionErr(hr, 0, NULL)) {

                BindCacheInvalidateEntry(ld) ;
            }
       }
    }else {

        hr = S_OK;
    }

    return hr;

}

void LdapMsgFree(
    LDAPMessage *res
)
{
    ldap_msgfree( res );  // Returns the type of message freed which
                          // is not interesting
}

int LdapResult2Error(
    ADS_LDP  *ld,
    LDAPMessage *res,
    int freeit
)
{
    ADsAssert(ld && ld->LdapHandle);

    return ldap_result2error( ld->LdapHandle, res, freeit );
}

HRESULT LdapFirstEntry(
    ADS_LDP *ld,
    LDAPMessage *res,
    LDAPMessage **pfirst
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *pfirst = ldap_first_entry( ld->LdapHandle, res );

    if ( *pfirst == NULL )
    {
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, res);
    }

    return hr;
}

HRESULT LdapNextEntry(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    LDAPMessage **pnext
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *pnext = ldap_next_entry( ld->LdapHandle, entry );

    if ( *pnext == NULL )
    {
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
    }

    return hr;
}
int LdapCountEntries(
    ADS_LDP  *ld,
    LDAPMessage *res
)
{
    ADsAssert(ld && ld->LdapHandle);

    return ldap_count_entries( ld->LdapHandle, res );
}

HRESULT LdapFirstAttribute(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    void  **ptr,
    WCHAR **pattr
)
{
    ADsAssert(ld && ld->LdapHandle);
    LPWSTR pAttrTemp = NULL;

    // NOTE: The return value from ldap_first_attribute is static and
    //       should not be freed

    pAttrTemp = ldap_first_attribute( ld->LdapHandle, entry,
                                   (struct berelement **) ptr );  // static data

    if ( pAttrTemp == NULL )
    {
        HRESULT hr = S_OK;
        int ldaperr = 0;

        // Error occurred or end of attributes

        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
        return hr;
    }

    //
    // Copy over the value as we can loose state if this fn is
    // called again - for example we read the attribute and are
    // now looking for schema information about it and end up
    // fetching the schema from the server.
    //
    *pattr = AllocADsStr(pAttrTemp);

    return NO_ERROR;

}

HRESULT LdapNextAttribute(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    void  *ptr,
    WCHAR **pattr
)
{
    ADsAssert(ld && ld->LdapHandle);
    LPWSTR pAttrTemp = NULL;

    // NOTE: The return value from ldap_next_attribute is static and
    //       should not be freed
    pAttrTemp = ldap_next_attribute( ld->LdapHandle, entry,
                                  (struct berelement *) ptr );  // static data

    if (pAttrTemp) {
        *pattr = AllocADsStr(pAttrTemp);
    } else {
        *pattr = NULL;
    }

#if 0   // Ignore the error code here since at the end of the enumeration,
        // we will probably get an error code here ( both Andy and umich's
        // dll will return errors sometimes. No error returned from NTDS,
        // but errors are returned from Exchange server  )

    if ( *pattr == NULL )
    {
        HRESULT hr = NO_ERROR;
        int ldaperr = 0;

        // Error occurred or end of attributes
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);
        return hr;
    }
#endif

    return S_OK;
}


//
// NOTE: LdapGetValues return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

HRESULT LdapGetValues(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    WCHAR *attr,
    WCHAR ***pvalues,
    int   *pcount
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *pvalues = ldap_get_values( ld->LdapHandle, entry, attr );

    if ( *pvalues == NULL ) {

        *pcount=0;

        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //

        ldaperr = LdapGetLastError();

        if (ldaperr) {
            CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
        }

        return hr;
    }

    *pcount = ldap_count_values( *pvalues );

    return S_OK;
}


//
// NOTE: LdapGetValuesLen return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

HRESULT LdapGetValuesLen(
    ADS_LDP  *ld,
    LDAPMessage *entry,
    WCHAR *attr,
    struct berval ***pvalues,
    int   *pcount
)
{
    //
    // NOTE: this can contain binary data as well as strings,
    //       strings are ascii, no conversion is done here
    //

    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ld && ld->LdapHandle);

    *pvalues = ldap_get_values_len( ld->LdapHandle, entry, attr );

    if ( *pvalues == NULL ){

        *pcount=0;

        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //

        ldaperr = LdapGetLastError();

        if (ldaperr) {
            CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
        }

        return hr;
    }

    *pcount = ldap_count_values_len( *pvalues );

    return S_OK;
}


void LdapValueFree(
    WCHAR **vals
)
{
    ldap_value_free( vals );
}

void LdapValueFreeLen(
    struct berval **vals
)
{
    ldap_value_free_len( vals );
}

void LdapMemFree(
    WCHAR *pszString
)
{
    ldap_memfree( pszString );
}

void LdapAttributeFree(
    WCHAR *pszString
)
{
    //
    // Since we made a copy of the string returned by LDAP, we
    // need to free it here.
    //

    FreeADsStr(pszString);
}

HRESULT LdapGetDn(
    ADS_LDP *ld,
    LDAPMessage *entry,
    WCHAR **pdn
)
{
    int ldaperr = 0;
    HRESULT hr = S_OK;

    ADsAssert(ld && ld->LdapHandle);

    *pdn = ldap_get_dn( ld->LdapHandle, entry );
    if ( *pdn == NULL )
    {
        // Error occurred
        ldaperr = LdapGetLastError();
        CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, entry);
        return hr;
    }

    return hr;
}

int ConvertToAscii( WCHAR *pszUnicode, char **pszAscii )
{

    int nSize;

    if ( pszUnicode == NULL )
    {
        *pszAscii = NULL;
        return NO_ERROR;
    }

    nSize = WideCharToMultiByte( CP_ACP,
                                 0,
                                 pszUnicode,
                                 -1,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL );

    if ( nSize == 0 )
        return GetLastError();

    *pszAscii = (char * ) AllocADsMem( nSize );

    if ( *pszAscii == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    if ( !WideCharToMultiByte( CP_ACP,
                               0,
                               pszUnicode,
                               -1,
                               *pszAscii,
                               nSize,
                               NULL,
                               NULL ))
    {
        FreeADsMem( *pszAscii );
        *pszAscii = NULL;
        return GetLastError();
    }

    return NO_ERROR;
}

int ConvertToUnicode( char *pszAscii, WCHAR **pszUnicode )
{
    int nSize;

    *pszUnicode = NULL;

    if ( pszAscii == NULL )
    {
        return NO_ERROR;
    }

    nSize = MultiByteToWideChar( CP_ACP,
                                 0,
                                 pszAscii,
                                 -1,
                                 NULL,
                                 0 );

    if ( nSize == 0 )
        return GetLastError();

    *pszUnicode = (WCHAR * ) AllocADsMem( nSize * sizeof(WCHAR));

    if ( *pszUnicode == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    if ( !MultiByteToWideChar( CP_ACP,
                               0,
                               pszAscii,
                               -1,
                               *pszUnicode,
                               nSize ))
    {
        FreeADsMem( *pszUnicode );
        *pszUnicode = NULL;
        return GetLastError();
    }

    return NO_ERROR;
}

// Dead function?
int ConvertLDAPMod( LDAPModW **mods, LDAPModA ***modsA )
{
    int nCount = 0;
    LDAPModA *aMods = NULL;
    int err = NO_ERROR;

    if ( mods == NULL )
    {
        *modsA = NULL;
        return NO_ERROR;
    }

    while ( mods[nCount] )
        nCount++;

    *modsA = (LDAPModA **) AllocADsMem((nCount+1) * sizeof(LDAPModA *));

    if ( *modsA == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    aMods = (LDAPModA *) AllocADsMem(nCount * sizeof(LDAPModA));

    if ( aMods == NULL )
    {
        FreeADsMem( *modsA );
        *modsA = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for ( int i = 0; i < nCount; i++ )
    {
        aMods[i].mod_op = mods[i]->mod_op;

        if ( err = ConvertToAscii( mods[i]->mod_type, &(aMods[i].mod_type)))
            break;

        if ( aMods[i].mod_op & LDAP_MOD_BVALUES )
        {
            aMods[i].mod_bvalues = mods[i]->mod_bvalues;
        }
        else
        {
            int nStrCount = 0;
            WCHAR **aStrings = mods[i]->mod_values;

            while ( aStrings[nStrCount] )
                   nStrCount++;

            aMods[i].mod_values = (char **) AllocADsMem(
                                            (nStrCount+1) * sizeof(char *));

            if ( aMods[i].mod_values != NULL )
            {
                for ( int j = 0; j < nStrCount; j++ )
                {
                    err =  ConvertToAscii( mods[i]->mod_values[j],
                                           &(aMods[i].mod_values[j]));
                    if ( err )
                    {
                        for ( int k = 0; k < j; k++ )
                            FreeADsMem( aMods[i].mod_values[k] );
                        FreeADsMem( aMods[i].mod_values );

                        break;
                    }
                }
            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }

            if ( err )
                break;
        }

        (*modsA)[i] = &aMods[i];
    }

    if ( err )
    {
        for ( int k = 0; k < i; k++ )
        {
            FreeADsMem( aMods[k].mod_type );

            if ( !(aMods[k].mod_op & LDAP_MOD_BVALUES ))
            {
                int j = 0;
                while ( aMods[k].mod_values[j] )
                    FreeADsMem( aMods[k].mod_values[j++] );

                if ( aMods[k].mod_values )
                    FreeADsMem( aMods[k].mod_values );
            }
        }

        FreeADsMem( aMods );
        FreeADsMem( *modsA );
        *modsA = NULL;
    }

    return err;
}

// Dead function?
void FreeLDAPMod( LDAPModA **modsA )
{
    int i = 0;
    while ( modsA[i] )
    {
        FreeADsMem( modsA[i]->mod_type );

        if ( !(modsA[i]->mod_op & LDAP_MOD_BVALUES ))
        {
            int j = 0;
            while ( modsA[i]->mod_values[j] )
                FreeADsMem( modsA[i]->mod_values[j++] );

            if ( modsA[i]->mod_values )
                FreeADsMem( modsA[i]->mod_values );
        }

        i++;
    }

    if ( modsA[0] )
        FreeADsMem( modsA[0] );

    FreeADsMem( modsA );
}


void
LdapGetCredentialsFromRegistry(
    CCredentials& Credentials
    )
{

    HKEY   hKey ;
    WCHAR  UserName[128], Password[128] ;
    LPWSTR pUserName = NULL;
    LPWSTR pPassword = NULL;
    DWORD  dwType, cbUserName = sizeof(UserName),
    cbPassword = sizeof(Password);
    int err = NO_ERROR;


    UserName[0] = Password[0] = 0 ;

    //
    // Open the registry Key
    //

    err = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services\\TcpIp\\Parameters",
                        0L,
                        KEY_READ,
                        &hKey) ;

    if (err == NO_ERROR) {

        err = RegQueryValueEx (hKey,
                               L"LdapUserName",
                               NULL,
                               &dwType,
                               (LPBYTE) UserName,
                               &cbUserName) ;

        if (err == NO_ERROR) {

            pUserName = UserName;
        }

        err = RegQueryValueEx (hKey,
                               L"LdapPassword",
                               NULL,
                               &dwType,
                               (LPBYTE) Password,
                               &cbPassword) ;

        if (err == NO_ERROR) {

            pPassword = Password;
        }

        Credentials.SetUserName(pUserName);

        Credentials.SetPassword(pPassword);

        RegCloseKey(hKey) ;
    }
}


HRESULT
LdapOpenBindWithCredentials(
    WCHAR *szDomainName,
    WCHAR *szServerName,
    CCredentials& Credentials,
    PADS_LDP pCacheEntry,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;
    DWORD dwFlagsChecked = 0;
    DWORD dwAuthFlags = 0;

    ULONG ulSSLPort, ulPort;

    hr = Credentials.GetUserName(&UserName);
    BAIL_ON_FAILURE(hr);


    hr = Credentials.GetPassword(&Password);
    BAIL_ON_FAILURE(hr);

    //
    // dwAuthFlags are the acutal flags set by the user
    //
    dwAuthFlags = Credentials.GetAuthFlags();

    //
    // dwFlagsChecked are the flags that we handle in this fn.
    //
    dwFlagsChecked = MaskKnownFlagsNotChecked(dwAuthFlags);

    if (dwPort == USE_DEFAULT_LDAP_PORT) {
        //
        // We can choose the appropriate LDAP port no.
        //
        ulSSLPort = LDAP_SSL_PORT;
        ulPort = LDAP_PORT;
    }
    else if ( dwPort == USE_DEFAULT_GC_PORT ) {
        //
        // We can choose the appropriate GC port no.
        //
        ulSSLPort = GC_SSL_PORT;
        ulPort = GC_PORT;
    }
    else {
        //
        // Port number explicitly specified; go with that
        //
        ulSSLPort = dwPort;
        ulPort = dwPort;
    }

    switch (dwFlagsChecked) {


    case (ADS_USE_ENCRYPTION |  ADS_SECURE_AUTHENTICATION):

        //
        // Case 1 - ADS_USE_ENCRYPTION AND  ADS_SECURE_AUTHENTICATION
        // We do a simple bind over SSL. We get secure authentication
        // for free over SSL. If opening the SSL port fails, we will
        // error out
        //

        hr = LdapOpen( szDomainName, szServerName, ulSSLPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

        if (FAILED(hr) && LDAPCodeWarrantsRetry(hr)) {

            //
            // Try setting the version number to V2.

            void *ldapOption = (void *) LDAP_VERSION2;

            ldap_set_option(
                pCacheEntry->LdapHandle,
                LDAP_OPT_VERSION,
                &(ldapOption)
                );

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );


            BAIL_ON_FAILURE(hr);

        }
        break;


    case (ADS_SECURE_AUTHENTICATION):

        //
        // Case 2 - ADS_SECURE_AUTHENTICATION
        // we will try  opening the LDAP port and authenticate with
        // SSPI.
        //

        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags);
        if (FAILED(hr)) {

            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );
        BAIL_ON_FAILURE(hr);

        break;

    case (ADS_USE_ENCRYPTION):

        //
        // Case 3 - ADS_USE_ENCRYPTION
        // We will first try open the SSL port. If this succeeds, we
        // will try a simple bind. If the open to the SSL port fails,
        // we will error out - (we can't provide encryption)
        //


        hr = LdapOpen( szDomainName, szServerName, ulSSLPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

        if (FAILED(hr) && LDAPCodeWarrantsRetry(hr)) {

            //
            // Try setting the version number to V2.

            void *ldapOption = (void *) LDAP_VERSION2;

            ldap_set_option(
                pCacheEntry->LdapHandle,
                LDAP_OPT_VERSION,
                &(ldapOption)
                );

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

            BAIL_ON_FAILURE(hr);
        }

        break;


    case 0:

        //
        // Case 4 - NOT ADS_SECURE_AUTHENTICATION AND NOT ADS_USE_ENCRYPTION

        // We will first try opening the LDAP port. Then we will do
        // a simple bind and "clear-text" authenticate.
        //

        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        //
        // Note there is no need to try an SSPI bind, as the user came with
        // explicit credentials and requested no authentication / no encryption
        // We just need to do a simple bind.

        // err = LdapBindS( pCacheEntry, UserName, Password, FALSE );
        hr = HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
        if (FAILED(hr)) {

            //
            // SSPI bind failed - try a simple bind.
            //

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );
            if (FAILED(hr) && LDAPCodeWarrantsRetry(hr)) {

                //
                // Try setting the version number to V2.

                void *ldapOption = (void *) LDAP_VERSION2;

                ldap_set_option(
                    pCacheEntry->LdapHandle,
                    LDAP_OPT_VERSION,
                    &(ldapOption)
                    );

                hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

                if (FAILED(hr)) {
                    goto error;
                }
            }
        }
        break;


    case ADS_NO_AUTHENTICATION:

        //
        // Case 10 - ADS_NO_AUTHENTICATION
        //
        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags);
        if (FAILED(hr)) {
            goto error;
        }
        break;


    default:

        //
        // Case 5 - Bogus values - if we come in with any bogus flags, we
        // will fail with ERROR_INVALID_PARAMETER.
        //

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        break;

    }


error:

    if (UserName) {
        FreeADsStr(UserName);
    }

    if (Password) {
        FreeADsStr(Password);
    }


    return(hr);
}


HRESULT
LdapOpenBindWithDefaultCredentials(
    WCHAR *szDomainName,
    WCHAR *szServerName,
    CCredentials& Credentials,
    PADS_LDP pCacheEntry,
    DWORD dwPort
    )
{
    HRESULT hr = S_OK;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;
    DWORD dwFlagsChecked = 0;
    DWORD dwAuthFlags = 0;

    ULONG ulSSLPort, ulPort;


    hr = Credentials.GetUserName(&UserName);
    BAIL_ON_FAILURE(hr);

    hr = Credentials.GetPassword(&Password);
    BAIL_ON_FAILURE(hr);

    //
    // These are the flags actually passed in.
    //
    dwAuthFlags = Credentials.GetAuthFlags();

    //
    // dwFlagsChecked contains only those flags we check for here.
    //
    dwFlagsChecked = MaskKnownFlagsNotChecked(dwAuthFlags);

    if (dwPort == USE_DEFAULT_LDAP_PORT) {
        //
        // We can choose the LDAP port number
        //
        ulSSLPort = LDAP_SSL_PORT;
        ulPort = LDAP_PORT;
    }
    else if ( dwPort == USE_DEFAULT_GC_PORT ) {
        //
        // We can choose the appropriate GC port number
        //
        ulSSLPort = GC_SSL_PORT;
        ulPort = GC_PORT;
    }
    else {
        //
        // Port number explicitly specified; go with that
        //
        ulSSLPort = dwPort;
        ulPort = dwPort;
    }

    switch (dwFlagsChecked) {

    case (ADS_USE_ENCRYPTION | ADS_SECURE_AUTHENTICATION):


        //
        // Case 1 - ADS_USE_ENCRYPTION AND  ADS_SECURE_AUTHENTICATION
        // We do a simple bind over SSL. We get secure authentication
        // for free over SSL. If opening the SSL port fails, we will
        // error out
        //

        hr = LdapOpen( szDomainName, szServerName, ulSSLPort, pCacheEntry, dwAuthFlags );
        BAIL_ON_FAILURE(hr);

        hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

        if (FAILED(hr)) {

            //
            // Try setting the version number to V2.

            void *ldapOption = (void *) LDAP_VERSION2;

            ldap_set_option(
                pCacheEntry->LdapHandle,
                LDAP_OPT_VERSION,
                &(ldapOption)
                );

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

            BAIL_ON_FAILURE(hr);

        }
        break;


    case (ADS_SECURE_AUTHENTICATION):

        //
        // Case 2 - ADS_SECURE_AUTHENTICATION
        // we will try  opening the LDAP port and authenticate with
        // SSPI.
        //

        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags);
        if (FAILED(hr)) {

            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );
        BAIL_ON_FAILURE(hr);

        break;

    case (ADS_USE_ENCRYPTION):

        //
        // Case 3 - ADS_USE_ENCRYPTION
        // We will first try open the SSL port. If this succeeds, we
        // will try a simple bind. If the open to the SSL port fails,
        // we will error out - (we can't provide encryption)
        //

        hr = LdapOpen( szDomainName, szServerName, ulSSLPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

        if (FAILED(hr)) {

            //
            // Try setting the version number to V2.

            void *ldapOption = (void *) LDAP_VERSION2;

            ldap_set_option(
                pCacheEntry->LdapHandle,
                LDAP_OPT_VERSION,
                &(ldapOption)
                );

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

            BAIL_ON_FAILURE(hr);

        }

        break;

    case 0:

        //
        // Case 4 - NOT ADS_SECURE_AUTHENTICATION AND NOT ADS_USE_ENCRYPTION

        // We will first try opening the LDAP port. If this succeeds, we
        // will try an SSPI bind. We still want to try and provide the user
        // with a secure authentication even though he/she is crazy enough
        // to unsecurely authenticate. If the SSPI bind fails, we will do
        // a simple bind and "clear-text" authenticate.
        //

        hr = LdapOpen( szDomainName, szServerName, ulPort, pCacheEntry, dwAuthFlags );
        if (FAILED(hr)) {
            goto error;
        }

        hr = LdapBindS( pCacheEntry, UserName, Password, FALSE );
        if (FAILED(hr) && hr != ERROR_LOGON_FAILURE) {

            hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

            if (FAILED(hr)) {

                //
                // Try setting the version number to V2.
                //
                void *ldapOption = (void *) LDAP_VERSION2;

                ldap_set_option(
                    pCacheEntry->LdapHandle,
                    LDAP_OPT_VERSION,
                    &(ldapOption)
                    );

                hr = LdapBindS( pCacheEntry, UserName, Password, TRUE );

                if (FAILED(hr)) {
                    goto error;
                }
            }
        }
        break;


    default:

        //
        // Case 5 - Bogus values - if we come in with any bogus flags, we
        // will fail with ERROR_INVALID_PARAMETER.
        //

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        break;

    }


error:

    if (UserName) {
        FreeADsStr(UserName);
    }

    if (Password) {
        FreeADsStr(Password);
    }


    return(hr);
}



//+---------------------------------------------------------------------------
//  Function:  LdapCrackUserDNToNTLMUser
//
//  Synopsis:   This call attempts to translate an LDAP-style DN into an NTLM
//              domain password form. The algorithm is to assume that the first
//              component will be of the form "CN=krishnaG" . This first component
//              will be taken as the user name. The subsequent components are
//              scanned till we find the first DC= component.
//
//  Arguments:  [LPTSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
LdapCrackUserDNtoNTLMUser(
    LPWSTR pszDN,
    LPWSTR * ppszNTLMUser,
    LPWSTR * ppszNTLMDomain
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    WCHAR szUserName[MAX_PATH];
    WCHAR szDomainName[MAX_PATH];
    LPWSTR szToken = NULL;

    LPWSTR pszSrcComp = NULL;
    LPWSTR pszSrcValue = NULL;

    DWORD i = 0;
    DWORD dwNumComponents = 0;

    HRESULT hr = S_OK;

    CLexer Lexer(pszDN);
    CLexer * pTokenizer = &Lexer;

    DWORD dwToken = 0;

    LPWSTR pszUserName = NULL;
    LPWSTR pszDomainName = NULL;


    *ppszNTLMUser = NULL;
    *ppszNTLMDomain = NULL;

    if (pszDN && !*pszDN) {
        //
        // Empty string.
        //
        *ppszNTLMUser = AllocADsStr(L"");

        if (!*ppszNTLMUser) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        *ppszNTLMDomain = AllocADsStr(L"");

        if (!*ppszNTLMDomain) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        RRETURN(hr);
    }

    hr = InitObjectInfo(pszDN, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    szUserName[0] = szDomainName[0] = L'\0';

    //
    // We don't want to treat ! as a special character
    //
    pTokenizer->SetExclaimnationDisabler(TRUE);

    while (1) {
                
        hr = Component(pTokenizer, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_ON_FAILURE(hr);

        if (dwToken == TOKEN_COMMA || dwToken == TOKEN_SEMICOLON) {
            continue;
        }

        if (dwToken == TOKEN_ATSIGN) {
            //
            // Need to return entire dn as username and no domain
            //
            *ppszNTLMUser = AllocADsStr(pszDN);

            if (!*ppszNTLMUser) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            *ppszNTLMDomain = AllocADsStr(L"");

            if (!*ppszNTLMDomain) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            goto exit;

        }

        if (dwToken == TOKEN_END) {
            break;
        }

    }

    dwNumComponents = pObjectInfo->NumComponents;

    if (dwNumComponents) {

        pszSrcComp = pObjectInfo->ComponentArray[0].szComponent;
        pszSrcValue = pObjectInfo->ComponentArray[0].szValue;

        if (pszSrcComp) {

            // if there was a LHS as in CN=krishnag

            if (!_wcsicmp(pszSrcComp, L"CN")) {

                wcscpy(szUserName, pszSrcValue);
            }else if (!pszSrcValue){
                wcscpy(szUserName, pszSrcComp);
            }
        }

        for (i = 1; i < dwNumComponents; i++) {

            pszSrcComp = pObjectInfo->ComponentArray[i].szComponent;
            pszSrcValue = pObjectInfo->ComponentArray[i].szValue;
            if (pszSrcComp) {

                // if there was a LHS as in DC=NTWKSTA

                if (!_wcsicmp(pszSrcComp, L"DC")) {

                    wcscpy(szDomainName, pszSrcValue);
                    break;
                }else if (!pszSrcValue){
                    wcscpy(szDomainName, pszSrcComp);
                    break;
                }
            }
        }
    }

    if (szUserName[0]) {


        pszUserName = AllocADsStr(szUserName);
        if (!pszUserName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        if (szDomainName[0]) {

            pszDomainName = AllocADsStr(szDomainName);
            if (!pszDomainName) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

        }

    }else {

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        BAIL_ON_FAILURE(hr);
    }

    *ppszNTLMUser = pszUserName;
    *ppszNTLMDomain = pszDomainName;

exit:
    //
    // Clean up the parser object
    //
    FreeObjectInfo(pObjectInfo);

    return(hr);

error:

    //
    // Clean up the parser object
    //
    FreeObjectInfo(pObjectInfo);


    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszDomainName) {
        FreeADsStr(pszDomainName);
    }

    if (*ppszNTLMUser) {
        FreeADsStr(*ppszNTLMUser);
    }

    if (*ppszNTLMDomain) {
        FreeADsStr(*ppszNTLMDomain);
    }

    //
    // Now we just return whatever is returned from the parser.
    //
    return(hr);
}


//
// would like to use WinNT codes path cracking codes - but doesn't
// work. Too messy, need to clean  up - move all path mgmt codes to common.
//
// use my own codes for quick fix for now
//
// Crack pszDN in "domain\user" format into *ppszNTLMUser="user" and
// *ppszNTLMDomain="domain".
//

HRESULT
LdapCrackUserDNtoNTLMUser2(
    IN  LPWSTR pszDN,
    OUT LPWSTR * ppszNTLMUser,
    OUT LPWSTR * ppszNTLMDomain
    )
{
    HRESULT hr = E_ADS_BAD_PATHNAME;
    DWORD dwTokenLen=0;
    BOOL fMore = FALSE;


    ASSERT(ppszNTLMUser);
    ASSERT(ppszNTLMDomain);

    *ppszNTLMUser=NULL;
    *ppszNTLMDomain=NULL;

    if (!pszDN) {
        RRETURN(S_OK);
    }


    hr = GetOneToken(
            pszDN,
            ppszNTLMDomain,
            &dwTokenLen,
            &fMore
            );
    BAIL_ON_FAILURE(hr);


    if (fMore && *(pszDN+dwTokenLen+1)!=L'\\') {

        hr = GetOneToken(
                pszDN+dwTokenLen+1,
                ppszNTLMUser,
                &dwTokenLen,
                &fMore
                );

    } else {

        hr = E_ADS_BAD_PATHNAME;
    }
    BAIL_ON_FAILURE(hr);


    RRETURN (hr);


error:

    if (*ppszNTLMUser) {
        FreeADsStr(*ppszNTLMUser);
        *ppszNTLMUser=NULL;
    }

    if (*ppszNTLMDomain) {
        FreeADsStr(*ppszNTLMDomain);
        *ppszNTLMDomain=NULL;
    }

    RRETURN (hr);
}


HRESULT
GetOneToken(
    LPWSTR pszSource,
    LPWSTR * ppszToken,
    DWORD * pdwTokenLen,
    BOOL * pfMore
    )
{
    LPWSTR pszToken = NULL;
    DWORD dwTokenLen= 0;
    LPWSTR pszCurrChar = pszSource;

    ASSERT(pszSource);
    ASSERT(ppszToken);
    ASSERT(pdwTokenLen);
    ASSERT(pfMore);

    *ppszToken=NULL;
    *pdwTokenLen = 0;
    *pfMore = FALSE;


    //
    // do we use exception handling code here ? what if caller passed
    // in a bad string -> not terminated?
    //

    while (*pszCurrChar!=L'\0' && *pszCurrChar!=L'\\') {
        dwTokenLen++;
        pszCurrChar++;
    }

    pszToken = (LPWSTR) AllocADsMem( (dwTokenLen+1) * sizeof(WCHAR) );
    if (!pszToken) {
        RRETURN(E_OUTOFMEMORY);
    }
    memcpy( pszToken, pszSource, dwTokenLen * sizeof(WCHAR) );
    (pszToken)[dwTokenLen]=L'\0';

    *pdwTokenLen = dwTokenLen;
    *ppszToken = pszToken;
    *pfMore = (*pszCurrChar==L'\0') ? FALSE : TRUE;

    RRETURN(S_OK);
}


VOID
CheckAndSetExtendedError(
    LDAP    *ld,
    HRESULT *perr,
    int     ldaperr,
    LDAPMessage *ldapResMsg
    )
{
    WCHAR  pszProviderName[MAX_PATH];
    INT    numChars;
    void   *option;
    DWORD dwStatus = NO_ERROR;
    DWORD dwErr = NO_ERROR;
    DWORD dwLdapErrParse = NO_ERROR;
    PWCHAR ppszLdapMessage = NULL;
    LPWSTR pszStopChar = NULL;


    // first set the dwErr, then we can see if we can get
    // more information from ldap_parse_resultW
    switch (ldaperr) {

    case LDAP_SUCCESS :
        dwErr = NO_ERROR;
        break;

    case LDAP_OPERATIONS_ERROR :
        dwErr =  ERROR_DS_OPERATIONS_ERROR;
        break;

    case LDAP_PROTOCOL_ERROR :
        dwErr =  ERROR_DS_PROTOCOL_ERROR;
        break;

    case LDAP_TIMELIMIT_EXCEEDED :
        dwErr = ERROR_DS_TIMELIMIT_EXCEEDED;
        break;

    case LDAP_SIZELIMIT_EXCEEDED :
        dwErr = ERROR_DS_SIZELIMIT_EXCEEDED;
        break;

    case LDAP_COMPARE_FALSE :
        dwErr = ERROR_DS_COMPARE_FALSE;
        break;

    case LDAP_COMPARE_TRUE :
        dwErr = ERROR_DS_COMPARE_TRUE;
        break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        dwErr = ERROR_DS_AUTH_METHOD_NOT_SUPPORTED;
        break;

    case LDAP_STRONG_AUTH_REQUIRED :
        dwErr =  ERROR_DS_STRONG_AUTH_REQUIRED;
        break;

    // LDAP_REFERRAL_V2 has same value as LDAP_PARTIAL_RESULTS
    case LDAP_PARTIAL_RESULTS :
            //
            // If the referral chasing is off for the handle
            // we really don't worry about this error
            //
            dwStatus = ldap_get_option(
                           ld,
                           LDAP_OPT_REFERRALS,
                           &(option)
                           );

            if (dwStatus == NO_ERROR && option == LDAP_OPT_OFF) {
                dwErr = NO_ERROR;
            }
            else {
                dwErr = ERROR_MORE_DATA;
            }

            break ;


    case LDAP_REFERRAL :
        dwErr =  ERROR_DS_REFERRAL;
        break;

    case LDAP_ADMIN_LIMIT_EXCEEDED :
        dwErr   = ERROR_DS_ADMIN_LIMIT_EXCEEDED;
        break;

    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        dwErr = ERROR_DS_UNAVAILABLE_CRIT_EXTENSION;
        break;

    case LDAP_CONFIDENTIALITY_REQUIRED :
        dwErr = ERROR_DS_CONFIDENTIALITY_REQUIRED;
        break;

    case LDAP_NO_SUCH_ATTRIBUTE :
        dwErr = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        break;

    case LDAP_UNDEFINED_TYPE :
        dwErr = ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED;
        break;

    case LDAP_INAPPROPRIATE_MATCHING :
        dwErr = ERROR_DS_INAPPROPRIATE_MATCHING;
        break;

    case LDAP_CONSTRAINT_VIOLATION :
        dwErr = ERROR_DS_CONSTRAINT_VIOLATION;
        break;

    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        dwErr = ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS;
        break;

    case LDAP_INVALID_SYNTAX :
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        break;

    case LDAP_NO_SUCH_OBJECT :
        dwErr = ERROR_DS_NO_SUCH_OBJECT;
        break;

    case LDAP_ALIAS_PROBLEM :
        dwErr = ERROR_DS_ALIAS_PROBLEM;
        break;

    case LDAP_INVALID_DN_SYNTAX :
        dwErr = ERROR_DS_INVALID_DN_SYNTAX;
        break;

    case LDAP_IS_LEAF :
        dwErr = ERROR_DS_IS_LEAF;
        break;

    case LDAP_ALIAS_DEREF_PROBLEM :
        dwErr = ERROR_DS_ALIAS_DEREF_PROBLEM;
        break;

    case LDAP_INAPPROPRIATE_AUTH :
        dwErr = ERROR_DS_INAPPROPRIATE_AUTH;
        break;

    case LDAP_INVALID_CREDENTIALS :
        dwErr = ERROR_LOGON_FAILURE;
        break;

    case LDAP_INSUFFICIENT_RIGHTS :
        dwErr = ERROR_ACCESS_DENIED;
        break;

    case LDAP_BUSY :
        dwErr = ERROR_DS_BUSY;
        break;

    case LDAP_UNAVAILABLE :
        dwErr = ERROR_DS_UNAVAILABLE;
        break;

    case LDAP_UNWILLING_TO_PERFORM :
        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
        break;

    case LDAP_LOOP_DETECT :
        dwErr = ERROR_DS_LOOP_DETECT;
        break;

    case LDAP_NAMING_VIOLATION :
        dwErr = ERROR_DS_NAMING_VIOLATION;
        break;

    case LDAP_OBJECT_CLASS_VIOLATION :
        dwErr = ERROR_DS_OBJ_CLASS_VIOLATION;
        break;

    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        dwErr = ERROR_DS_CANT_ON_NON_LEAF;
        break;

    case LDAP_NOT_ALLOWED_ON_RDN :
        dwErr = ERROR_DS_CANT_ON_RDN;
        break;

    case LDAP_ALREADY_EXISTS :
        dwErr = ERROR_OBJECT_ALREADY_EXISTS;
        break;

    case LDAP_NO_OBJECT_CLASS_MODS :
        dwErr = ERROR_DS_CANT_MOD_OBJ_CLASS;
        break;

    case LDAP_RESULTS_TOO_LARGE :
        dwErr = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        break;

    case LDAP_AFFECTS_MULTIPLE_DSAS :
        dwErr = ERROR_DS_AFFECTS_MULTIPLE_DSAS;
        break;

    case LDAP_OTHER :
        dwErr = ERROR_GEN_FAILURE;
        break;

    case LDAP_SERVER_DOWN :
        dwErr = ERROR_DS_SERVER_DOWN;
        break;

    case LDAP_LOCAL_ERROR :
        dwErr = ERROR_DS_LOCAL_ERROR;
        break;

    case LDAP_ENCODING_ERROR :
        dwErr = ERROR_DS_ENCODING_ERROR;
        break;

    case LDAP_DECODING_ERROR :
        dwErr = ERROR_DS_DECODING_ERROR;
        break;

    case LDAP_TIMEOUT :
        dwErr = ERROR_TIMEOUT;
        break;

    case LDAP_AUTH_UNKNOWN :
        dwErr = ERROR_DS_AUTH_UNKNOWN;
        break;

    case LDAP_FILTER_ERROR :
        dwErr = ERROR_DS_FILTER_UNKNOWN;
        break;

    case LDAP_USER_CANCELLED :
       dwErr = ERROR_CANCELLED;
       break;

    case LDAP_PARAM_ERROR :
        dwErr = ERROR_DS_PARAM_ERROR;
        break;

    case LDAP_NO_MEMORY :
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case LDAP_CONNECT_ERROR :
        dwErr = ERROR_CONNECTION_REFUSED;
        break;

    case LDAP_NOT_SUPPORTED :
        dwErr = ERROR_DS_NOT_SUPPORTED;
        break;

    case LDAP_NO_RESULTS_RETURNED :
        dwErr = ERROR_DS_NO_RESULTS_RETURNED;
        break;

    case LDAP_CONTROL_NOT_FOUND :
        dwErr = ERROR_DS_CONTROL_NOT_FOUND;
        break;

    case LDAP_MORE_RESULTS_TO_RETURN :
        dwErr = ERROR_MORE_DATA;
        break;

    case LDAP_CLIENT_LOOP :
        dwErr = ERROR_DS_CLIENT_LOOP;
        break;

    case LDAP_REFERRAL_LIMIT_EXCEEDED :
        dwErr = ERROR_DS_REFERRAL_LIMIT_EXCEEDED;
        break;

    default:
        //
        // It may not be a bad idea to add range checking here
        //
        dwErr = (DWORD) LdapMapErrorToWin32(ldaperr);

    }

    //
    // Set extended error only if it was not success and the
    // handle was not NULL
    //
    if ((ldaperr != LDAP_SUCCESS) && (ld !=NULL)) {

        dwStatus = ldap_get_optionW(
                       ld,
                       LDAP_OPT_SERVER_ERROR,
                       (void *)&ppszLdapMessage
                       );

        if (ppszLdapMessage != NULL && dwStatus == NO_ERROR) {
            dwLdapErrParse = wcstoul(ppszLdapMessage, &pszStopChar, 16);
            //
            // If the error code is zero and the message and stopChar
            // point to the same location, we must have invalid data.
            // We also have invalid data if the return value from the
            // call is ULONG_MAX.
            //
            if ((!dwLdapErrParse && (ppszLdapMessage == pszStopChar))
                || (dwLdapErrParse == (DWORD) -1)
                ) {
                dwLdapErrParse = ERROR_INVALID_DATA;
            }
        }

        ADsSetLastError(
            dwLdapErrParse,
            ppszLdapMessage,
            L"LDAP Provider"
            );

        if (ppszLdapMessage) {
            LdapMemFree(ppszLdapMessage);
            ppszLdapMessage = NULL;
        }

    } else {

        // We need to reset the last error with a well known value
        ADsSetLastError(
            NO_ERROR,
            NULL,
            L"LDAP Provider"
            );
    }


    *perr = HRESULT_FROM_WIN32(dwErr);


}

//
// Return TRUE if the error is a connection error. Ie. this bind handle is
// no longer valid and should not be reused.
//
BOOL LdapConnectionErr(
    int err,
    int ldaperr,
    BOOL *fTryRebind
    )
{

   (void) fTryRebind ;  // currently not used

   switch (err) {

       case ERROR_DS_UNAVAILABLE :
       case ERROR_GEN_FAILURE :
       case ERROR_DS_LOCAL_ERROR :
       case ERROR_DS_SERVER_DOWN :
           return TRUE ;

       default:
           return FALSE ;
    }
}

HRESULT LdapSearchExtSHelper(
    LDAP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    PLDAPControlW * ServerControls,
    PLDAPControlW *ClientControls,
    struct l_timeval *Timeout,
    ULONG SizeLimit,
    LDAPMessage **res
)
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ldaperr = ldap_search_ext_s( ld,
                              base,
                              scope,
                              filter,
                              attrs,
                              attrsonly,
                              ServerControls,
                              ClientControls,
                              Timeout,
                              SizeLimit,
                              res );

    if (ldaperr) {
           CheckAndSetExtendedError( ld, &hr, ldaperr, *res );
    }

    return hr;

}

HRESULT LdapSearchExtS(
    ADS_LDP  *ld,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    PLDAPControlW * ServerControls,
    PLDAPControlW *ClientControls,
    struct l_timeval *Timeout,
    ULONG           SizeLimit,
    LDAPMessage **res
)
{
    HRESULT hr = LdapSearchExtSHelper(
                  ld->LdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  ServerControls,
                  ClientControls,
                  Timeout,
                  SizeLimit,
                  res );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapSearchExt(
    ADS_LDP         *ld,
    WCHAR           *base,
    int             scope,
    WCHAR           *filter,
    WCHAR           *attrs[],
    int             attrsonly,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls,
    ULONG           TimeLimit,
    ULONG           SizeLimit,
    ULONG           *MessageNumber
)
{
    char *pszBaseA = NULL;
    int ldaperr = 0;
    HRESULT hr = 0;

    ldaperr = ldap_search_ext(
                  ld->LdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  ServerControls,
                  ClientControls,
                  TimeLimit,
                  SizeLimit,
                  MessageNumber
                  );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr);

    if (LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


ULONG _cdecl QueryForConnection(
    PLDAP       PrimaryConnection,
    PLDAP       ReferralFromConnection,
    PWCHAR      NewDN,
    PCHAR       HostName,
    ULONG       PortNumber,
    PVOID       SecAuthIdentity,    // if null, use CurrentUser below
    PVOID       CurrentUserToken,   // pointer to current user's LUID
    PLDAP       *ConnectionToUse
    )
{
    HRESULT hr = S_OK;
    PADS_LDP pCacheEntry = NULL;
    LPWSTR pszServer = NULL;

    PSEC_WINNT_AUTH_IDENTITY pSecAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) SecAuthIdentity;
    PLUID pLuid = (PLUID) CurrentUserToken;
    CCredentials Credentials;

    if (ConnectionToUse) {
        *ConnectionToUse = NULL;
    }

    if (!pLuid) {
        goto error;
    }

    if (pSecAuthIdentity) {
        hr = Credentials.SetUserName(pSecAuthIdentity->User);
        BAIL_ON_FAILURE(hr);

        hr = Credentials.SetPassword(pSecAuthIdentity->Password);
        BAIL_ON_FAILURE(hr);

        Credentials.SetAuthFlags(ADS_SECURE_AUTHENTICATION);
    }

    if (ConvertToUnicode(HostName, &pszServer ))
        goto error;

    if (!pszServer) {
        //
        // Cannot do a lookup without server name.
        //
        goto error;
    }
    if (pCacheEntry = BindCacheLookup(pszServer, *pLuid, ReservedLuid, Credentials, PortNumber)) {

         *ConnectionToUse = pCacheEntry->LdapHandle ;
    }

error:

    if (pszServer) {
        FreeADsMem(pszServer);
    }

    return 0;

}

BOOLEAN _cdecl NotifyNewConnection(
    PLDAP       PrimaryConnection,
    PLDAP       ReferralFromConnection,
    PWCHAR      NewDN,
    PCHAR       HostName,
    PLDAP       NewConnection,
    ULONG       PortNumber,
    PVOID       SecAuthIdentity,    // if null, use CurrentUser below
    PVOID       CurrentUser,        // pointer to current user's LUID
    ULONG       ErrorCodeFromBind
    )
{

    PADS_LDP pCacheEntry = NULL;
    PADS_LDP pPrimaryEntry = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszServer = NULL;
    DWORD err;

    BOOLEAN ret = FALSE;

    PSEC_WINNT_AUTH_IDENTITY pSecAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) SecAuthIdentity;
    PLUID pLuid = (PLUID) CurrentUser;
    CCredentials Credentials;

    if (!pLuid || !NewConnection) {
        goto error;
    }

    //
    // Get the cache entry corresponding to the Primary Connection
    // This is necessary so that we can link the new connection to the primary
    // connection so that we can decrease the reference
    //

    if ((pPrimaryEntry = GetCacheEntry(PrimaryConnection)) == NULL) {
        goto error;
    }

    err = BindCacheAllocEntry(&pCacheEntry) ;

    if (err != NO_ERROR) {
        goto error;
    }

    if ( ConvertToUnicode(HostName, &pszServer))
        goto error;

    if (pSecAuthIdentity) {
        hr = Credentials.SetUserName(pSecAuthIdentity->User);
        BAIL_ON_FAILURE(hr);

        hr = Credentials.SetPassword(pSecAuthIdentity->Password);
        BAIL_ON_FAILURE(hr);

        Credentials.SetAuthFlags(ADS_SECURE_AUTHENTICATION);
    }

    pCacheEntry->LdapHandle = NewConnection;

    err = BindCacheAdd(pszServer, *pLuid, ReservedLuid, Credentials, PortNumber, pCacheEntry) ;
    if (err == NO_ERROR) {

        if (!AddReferralLink(pPrimaryEntry, pCacheEntry)) {
            //
            // If the referral link could not be succesfully added, we don't
            // want to keep this connection.
            //
            BindCacheDeref(pCacheEntry);
            goto error;
        }

        //
        // return TRUE to indicate that we have succesfully cached the handle
        //
        ret = TRUE;
    }

error:

    if (pszServer) {
        FreeADsMem(pszServer);
    }

    if (!ret && pCacheEntry) {
        FreeADsMem(pCacheEntry);
    }

    return ret;
}


ULONG _cdecl DereferenceConnection(
    PLDAP       PrimaryConnection,
    PLDAP       ConnectionToDereference
    )
{

    PADS_LDP pCacheEntry;

    if (ConnectionToDereference) {

        if (pCacheEntry = GetCacheEntry(ConnectionToDereference)) {
            LdapCloseObject(pCacheEntry);
        }
    }

    return S_OK;
}

HRESULT LdapSearchInitPage(
    ADS_LDP         *ld,
    PWCHAR          base,
    ULONG           scope,
    PWCHAR          filter,
    PWCHAR          attrs[],
    ULONG           attrsonly,
    PLDAPControlW   *serverControls,
    PLDAPControlW   *clientControls,
    ULONG           pageTimeLimit,
    ULONG           totalSizeLimit,
    PLDAPSortKeyW   *sortKeys,
    PLDAPSearch     *ppSearch
    )
{
    HRESULT hr = S_OK;
    int ldaperr = 0;

    ADsAssert(ppSearch);

    *ppSearch = ldap_search_init_page(
                    ld->LdapHandle,
                    base,
                    scope,
                    filter,
                    attrs,
                    attrsonly,
                    serverControls,
                    clientControls,
                    pageTimeLimit,
                    totalSizeLimit,
                    sortKeys
                    );

    if (*ppSearch == NULL) {

        ldaperr = LdapGetLastError();
    }

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;

}


HRESULT LdapGetNextPage(
        ADS_LDP         *ld,
        PLDAPSearch     searchHandle,
        ULONG           pageSize,
        ULONG           *pMessageNumber
        )
{
    HRESULT hr = S_OK;

    int ldaperr = ldap_get_next_page(
                    ld->LdapHandle,
                    searchHandle,
                    pageSize,
                    pMessageNumber
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapGetNextPageS(
        ADS_LDP         *ld,
        PLDAPSearch     searchHandle,
        struct l_timeval  *timeOut,
        ULONG           pageSize,
        ULONG          *totalCount,
        LDAPMessage     **results
        )
{
    HRESULT hr = S_OK;

    int ldaperr = ldap_get_next_page_s(
                    ld->LdapHandle,
                    searchHandle,
                    timeOut,
                    pageSize,
                    totalCount,
                    results
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapGetPagedCount(
    ADS_LDP         *ld,
    PLDAPSearch     searchBlock,
    ULONG          *totalCount,
    PLDAPMessage    results
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_get_paged_count(
                    ld->LdapHandle,
                    searchBlock,
                    totalCount,
                    results
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, results );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}


HRESULT LdapSearchAbandonPage(
    ADS_LDP         *ld,
    PLDAPSearch     searchBlock
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_search_abandon_page(
                    ld->LdapHandle,
                    searchBlock
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    if ( LdapConnectionErr(hr, 0, NULL)) {

        BindCacheInvalidateEntry(ld) ;
    }

    return hr;
}

HRESULT LdapEncodeSortControl(
    ADS_LDP *ld,
    PLDAPSortKeyW  *SortKeys,
    PLDAPControlW  Control,
    BOOLEAN Criticality
    )
{
    HRESULT hr = S_OK;

    int ldaperr = ldap_encode_sort_controlW (
                      ld->LdapHandle,
                      SortKeys,
                      Control,
                      Criticality
                      );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    return hr;
}

BOOL IsGCNamespace(
    LPWSTR szADsPath
    )
{

    WCHAR szNamespace[MAX_PATH];
    HRESULT hr = S_OK;

    hr = GetNamespaceFromADsPath(
             szADsPath,
             szNamespace
             );
    if (FAILED(hr))
        return FALSE;

    return (_wcsicmp(szNamespace, szGCNamespaceName) == 0);

}


HRESULT LdapCreatePageControl(
    ADS_LDP         *ld,
    ULONG           dwPageSize,
    struct berval   *Cookie,
    BOOL            fIsCritical,
    PLDAPControl    *Control        // Use LdapControlFree to free
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_create_page_control(
                    ld->LdapHandle,
                    dwPageSize,
                    Cookie,
                    (UCHAR) fIsCritical,
                     Control
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    return hr;
}

HRESULT LdapParsePageControl(
    ADS_LDP         *ld,
    PLDAPControl    *ServerControls,
    ULONG           *TotalCount,
    struct berval   **Cookie        // Use BerBvFree to free
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_parse_page_control(
                    ld->LdapHandle,
                    ServerControls,
                    TotalCount,
                    Cookie
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr );

    return hr;
}


HRESULT LdapCreateVLVControl(
    ADS_LDP         *pld,
    PLDAPVLVInfo    pVLVInfo,
    UCHAR           fCritical,
    PLDAPControl    *ppControl        // Use LdapControlFree to free
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_create_vlv_control(
                    pld->LdapHandle,
                    pVLVInfo,
                    fCritical,
                    ppControl
                    );

    CheckAndSetExtendedError( pld->LdapHandle, &hr, ldaperr );

    return hr;
}



HRESULT LdapParseVLVControl(
    ADS_LDP         *pld,
    PLDAPControl    *ppServerControls,
    ULONG           *pTargetPos,
    ULONG           *pListCount,
    struct berval   **ppCookie        // Use BerBvFree to free
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_parse_vlv_control(
                    pld->LdapHandle,
                    ppServerControls,
                    pTargetPos,
                    pListCount,
                    ppCookie,
                    NULL
                    );

    CheckAndSetExtendedError( pld->LdapHandle, &hr, ldaperr );

    return hr;
}


HRESULT LdapParseResult(
    ADS_LDP         *ld,
    LDAPMessage *ResultMessage,
    ULONG *ReturnCode OPTIONAL,          // returned by server
    PWCHAR *MatchedDNs OPTIONAL,         // free with LdapMemFree
    PWCHAR *ErrorMessage OPTIONAL,       // free with LdapMemFree
    PWCHAR **Referrals OPTIONAL,         // free with LdapValueFree
    PLDAPControlW **ServerControls OPTIONAL,    // free with LdapFreeControls
    BOOL Freeit
    )
{

    HRESULT hr = S_OK;

    int ldaperr = ldap_parse_result(
                      ld->LdapHandle,
                      ResultMessage,
                      ReturnCode,
                      MatchedDNs,
                      ErrorMessage,
                      Referrals,
                      ServerControls,
                      (BOOLEAN) Freeit
                    );

    CheckAndSetExtendedError( ld->LdapHandle, &hr, ldaperr, ResultMessage );

    return hr;
}


void
LdapControlsFree(
    PLDAPControl    *ppControl
    )
{
    ldap_controls_free( ppControl );

}

void
LdapControlFree(
    PLDAPControl    pControl
    )
{
    ldap_control_free( pControl );

}

void
BerBvFree(
    struct berval *bv
    )
{
    ber_bvfree( bv );

}

//
// This function looks at the LDAP error code to see if we
// should try and bind again using a lower version level or
// alternate mechanism
//
BOOLEAN
LDAPCodeWarrantsRetry(
    HRESULT hr
    )
{
    BOOLEAN fretVal = FALSE;

    switch (hr) {

    case HRESULT_FROM_WIN32(ERROR_DS_OPERATIONS_ERROR) :
        fretVal = TRUE;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_PROTOCOL_ERROR) :
        fretVal = TRUE;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED) :
        fretVal = TRUE;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN) :
        fretVal = TRUE;
        break;

    case HRESULT_FROM_WIN32(ERROR_DS_NOT_SUPPORTED) :
        fretVal = TRUE;
        break;

    default:
        fretVal = FALSE;
        break;
    } // end case

    return fretVal;
}



HRESULT
LdapcSetStickyServer(
    LPWSTR pszDomainName,
    LPWSTR pszServerName
    )
    {
    HRESULT hr = S_OK;

    if (gpszServerName) {
        FreeADsStr(gpszServerName);
        gpszServerName = NULL;
    }

    if (pszServerName) {
        gpszServerName = AllocADsStr(pszServerName);

        if (!gpszServerName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    if (gpszDomainName) {
        FreeADsStr(gpszDomainName);
        gpszDomainName = NULL;
    }

    if (pszDomainName) {
        gpszDomainName = AllocADsStr(pszDomainName);
        
        if (!gpszDomainName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    RRETURN(hr);

error :

    if (gpszServerName) {
        FreeADsStr(gpszServerName);
        gpszServerName = NULL;
    }

    if (gpszDomainName) {
        FreeADsStr(gpszDomainName);
        gpszDomainName = NULL;
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

#if DBG==1

#include "formtrck.hxx"
extern "C" {
#include "caiheap.h"
}

extern CRITICAL_SECTION g_csDP;   // for debugprint
extern CRITICAL_SECTION g_csOT;   // for otracker
extern CRITICAL_SECTION g_csMem;  // for MemAlloc
#endif

extern CRITICAL_SECTION g_DomainDnsCache;

//
// External references to handles for libs we load dynamically.
//
extern HANDLE g_hDllNetApi32;
extern HANDLE g_hDllSecur32;

extern DWORD LsaDeregisterLogonProcessWrapper(
    IN HANDLE LsaHandle
    );

//
// Variables needed for localized strings.
//
WCHAR g_szNT_Authority[100];
BOOL g_fStringsLoaded = FALSE;


HINSTANCE g_hInst = NULL;

//
// LSA handle (needed by GetUserDomainFlatName)
//
extern HANDLE g_hLsa;

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     AllocArenaDump( NULL );
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Need to handle case of crit sect init failing.
        //
        __try {

            InitADsMem() ;
            //
            // Initialize the error records
            //
            memset(&ADsErrorRecList, 0, sizeof(ERROR_RECORD));

            InitializeCriticalSection(&ADsErrorRecCritSec);

            BindCacheInit() ;
            SchemaInit() ;

            InitializeCriticalSection(&g_DomainDnsCache);

            g_hInst = hInst;

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT); // Used by Object Tracker
            InitializeCriticalSection(&g_csMem); // Used by Object Tracker
#endif
            InitializeCriticalSection(&g_csDP); // Used by ADsDebug
#endif
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical faliure
            //
            return FALSE;
        }

        //
        // Time to load localized strings if applicable.
        //
        if (!g_fStringsLoaded) {
            //
            // Load NT AUthority
            //
            if (!LoadStringW(
                     g_hInst,
                     LDAPC_NT_AUTHORITY,
                     g_szNT_Authority,
                     sizeof( g_szNT_Authority ) / sizeof( WCHAR )
                     )
                ) {
                wcscpy(g_szNT_Authority, L"NT AUTHORITY");
            }
            g_fStringsLoaded = TRUE;
        }

        break;


    case DLL_PROCESS_DETACH:
        ADsFreeAllErrorRecords();

        SchemaCleanup();
        BindCacheCleanup();

#if (!defined WIN95)
        if (g_hLsa != INVALID_HANDLE_VALUE) {
            LsaDeregisterLogonProcessWrapper(g_hLsa);
        }
#endif

        if (g_hDllNetApi32) {
            FreeLibrary((HMODULE)g_hDllNetApi32);
            g_hDllNetApi32 = NULL;
        }

        if (g_hDllSecur32) {
            FreeLibrary((HMODULE)g_hDllSecur32);
            g_hDllSecur32 = NULL;
        }

        DeleteCriticalSection(&ADsErrorRecCritSec);
        DeleteCriticalSection(&g_DomainDnsCache);

#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT); // Used by Object Tracker
        DeleteCriticalSection(&g_csMem); // Used by Object Tracker
#endif
        DeleteCriticalSection(&g_csDP); // Used by ADsDebug
#endif

        if (gpszServerName) {
            FreeADsStr(gpszServerName);
            gpszServerName = NULL;
        }

        if (gpszDomainName) {
            FreeADsStr(gpszDomainName);
            gpszDomainName = NULL;
        }

#if DBG==1
    DumpMemoryTracker();
#endif

#if DBG==1
        DeleteCriticalSection(&ADsMemCritSect);
#endif
        break;

    case DLL_THREAD_DETACH:
        ADsFreeThreadErrorRecords();
        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\memory.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include "dswarn.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "symhelp.h"
#include "oledsdbg.h"


#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemoryLog = 0;

#define MAXDEPTH 10

typedef struct _ADSMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} ADSMEMTAG, *PADSMEMTAG ;

LIST_ENTRY       ADsMemList ;
DWORD            ADsMemCount ;
CRITICAL_SECTION ADsMemCritSect ;

/*++

Routine Description:

    This function initializes the ADs mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitADsMem(
    VOID
)
{
    InitializeCriticalSection(&ADsMemCritSect) ;
    InitializeListHead(&ADsMemList) ;
    ADsMemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertADsMemLeaks(
    VOID
)
{
    ADsAssert(IsListEmpty(&ADsMemList)) ;
}

#endif

LPVOID
AllocADsMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
#if DBG
    DWORD    cbNew ;
    PADSMEMTAG pMem ;

    ULONG ulHash;

    //
    // adjust size for our tag and one spare dword at end
    // and allocate the memory
    //
    cb = DWORD_ALIGN_UP(cb);

    cbNew = cb + ( sizeof(ADSMEMTAG) + sizeof(DWORD) );

    pMem=(PADSMEMTAG)LocalAlloc(LPTR, cbNew);

    if (!pMem) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    //
    // fill in deadbeef at end and tag info.
    // and insert it into the ADsMemList
    //

    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD)) = 0xdeadbeef;
    pMem->Tag = 0xB00FB00F ;
    pMem->Size = cb ;


    //
    // Capture a backtrace at this spot for debugging.
    //

#if (defined(i386) && !defined(WIN95))

    pMem->uDepth = RtlCaptureStackBackTrace(
                            0,
                            MAXDEPTH,
                            pMem->pvBackTrace,
                            &ulHash
                            );



#else

    pMem->uDepth = 0;

#endif


    EnterCriticalSection(&ADsMemCritSect) ;
    InsertHeadList(&ADsMemList, &pMem->List) ;
    ADsMemCount++ ;
    LeaveCriticalSection(&ADsMemCritSect) ;

    //
    // skip past the mem tag
    //
    pMem++ ;
    return (LPVOID)(pMem);
#else
    return(LocalAlloc(LPTR, cb));
#endif

}

BOOL
FreeADsMem(
   LPVOID pMem
)
{
#if DBG
    DWORD        cb;
    DWORD        cbNew = 0;
    PADSMEMTAG pNewMem ;
    LPDWORD      pRetAddr;
    DWORD i = 0;


    //
    // This apparently is a C++ requiremen - that you can call
    // delete on a null pointer and it should be handled
    //
    if (pMem == NULL) {
        return 0;
    }

    pNewMem = (PADSMEMTAG)pMem;
    pNewMem -- ;

    cb = pNewMem->Size;
    cbNew = cb + sizeof(DWORD) + sizeof(ADSMEMTAG);

    //
    // check the trailing deadbeef and remove from list
    //

    if (*(LPDWORD)(((LPBYTE)pNewMem) + cbNew - sizeof(DWORD)) != 0xdeadbeef) {
        ADsAssert(!"Freeing memory not allocated by AllocADsMem") ;
        return FALSE;
    }

    EnterCriticalSection(&ADsMemCritSect) ;
    RemoveEntryList(&pNewMem->List) ;
    ADsMemCount-- ;
    LeaveCriticalSection(&ADsMemCritSect) ;


    for (i = 0; i < pNewMem->uDepth; i++) {

        if (pNewMem->pszSymbol[i]) {
            LocalFree(pNewMem->pszSymbol[i]);
        }
    }


    //
    // Whack freed memory with known pattern
    //

    memset(pMem, 0x65, cb);
    return(LocalFree((LPVOID)pNewMem) == NULL);

#else

    return(LocalFree(pMem) == NULL);

#endif


}

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocADsMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreeADsMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocADsStr(
    LPCWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocADsMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreeADsStr(
   LPWSTR pStr
)
{
   return pStr ? FreeADsMem(pStr)
               : FALSE;
}

BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   FreeADsStr(*ppStr);
   *ppStr=AllocADsStr(pStr);

   return TRUE;
}


#if DBG
VOID
DumpMemoryTracker(
    VOID
    )
{
#if !defined(WIN95) && defined(_X86_)
   LIST_ENTRY* pEntry;
   ADSMEMTAG*  pMem;
   BYTE*       pTemp;
   DWORD i = 0;
   CHAR szSymbolPath[MAX_PATH+1];
   DWORD dwCount = 0;

   pEntry   = ADsMemList.Flink;

   if (!dwMemoryLog) {
      return;
   }


   if ( pEntry == &ADsMemList ) {
       OutputDebugStringA( "No Memory leaks found\n" );
   }

   while( pEntry != &ADsMemList )
   {
      CHAR szLeak[1024];

      pTemp = (BYTE*)pEntry;
      pTemp = pTemp - sizeof(DWORD) - sizeof(DWORD)
              - sizeof(DWORD) -
              (sizeof(CHAR*) + sizeof(LPVOID))*( MAXDEPTH +1);
      pMem  = (ADSMEMTAG*)pTemp;

      sprintf(
        szLeak,
        "[oleds] Memory leak!!! Addresss = %.8x Size = %ld \n",
        pMem + 1,
        pMem->Size
        );
      OutputDebugStringA( szLeak );


     for (i = 0; i < pMem->uDepth; i++) {

         dwCount = TranslateAddress(
                     (ULONG)pMem->pvBackTrace[ i ],
                     szSymbolPath,
                     MAX_PATH
                     );
         szSymbolPath[dwCount] = '\0';
         sprintf(szLeak, "%s\n",szSymbolPath);
         OutputDebugStringA( szLeak);

     }

      pEntry   = pEntry->Flink;
   }
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\ods2ldap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       ods2ldap.cxx
//
//  Contents:   DSObject to LDAP Object Copy Routines
//
//  Functions:
//
//  History:    25-Feb-97   yihsins   Created.
//
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"


HRESULT
AdsTypeToLdapTypeCopyDNString(
    PADSVALUE  lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr( lpAdsSrcValue->DNString );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_DN;

    RRETURN(S_OK);
}

HRESULT
AdsTypeToLdapTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr(lpAdsSrcValue->CaseExactString);

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_CASEEXACTSTRING;


    RRETURN(S_OK);
}


HRESULT
AdsTypeToLdapTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr(lpAdsSrcValue->CaseIgnoreString);

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_CASEIGNORESTRING;

    RRETURN(S_OK);
}


HRESULT
AdsTypeToLdapTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr( lpAdsSrcValue->PrintableString);

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_PRINTABLESTRING;

    RRETURN(S_OK);
}

HRESULT
AdsTypeToLdapTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) =
        (LPTSTR) AllocADsStr( lpAdsSrcValue->NumericString );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_NUMERICSTRING;

    RRETURN(S_OK);
}

HRESULT
AdsTypeToLdapTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    LPTSTR  pszStr = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if ( lpAdsSrcValue->Boolean )
        pszStr = TEXT("TRUE");
    else
        pszStr = TEXT("FALSE");

    LDAPOBJECT_STRING(lpLdapDestObject) = (LPTSTR) AllocADsStr( pszStr );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_BOOLEAN;

    RRETURN(S_OK);
}


HRESULT
AdsTypeToLdapTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    _itot( lpAdsSrcValue->Integer, Buffer, 10 );

    LDAPOBJECT_STRING(lpLdapDestObject) = (LPTSTR) AllocADsStr( Buffer );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_INTEGER;

    RRETURN(S_OK);
}

HRESULT
AdsTypeToLdapTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;

    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwNumBytes );

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
            lpAdsSrcValue->OctetString.lpValue,
            dwNumBytes );

    *pdwSyntaxId = LDAPTYPE_OCTETSTRING;


error:

    RRETURN(hr);
}


HRESULT
AdsTypeToLdapTypeCopySecurityDescriptor(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NT_SECURITY_DESCRIPTOR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    dwNumBytes =  lpAdsSrcValue->SecurityDescriptor.dwLength;

    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwNumBytes );

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) =
        (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject)
                  + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
            lpAdsSrcValue->SecurityDescriptor.lpValue,
            dwNumBytes );

    // Note that the type is set to OctetString as
    // LDAP does not know about the ntSecurityDescriptor type.
    *pdwSyntaxId = LDAPTYPE_SECURITY_DESCRIPTOR;


error:

    RRETURN(hr);
}


HRESULT
AdsTypeToLdapTypeCopyTime(
    PADSVALUE pAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME *st = &pAdsSrcValue->UTCTime;

    //
    // For ldap server, we can only handle 1950 to 2049. So return an
    // error to user instead of translating time incorrectly without
    // warning. GeneralizedTime handles a much larger range and should
    // be used for new attributes.
    //
    if ( st->wYear<1950 || st->wYear>2049)
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);


    if (pAdsSrcValue->dwType != ADSTYPE_UTC_TIME)
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);

    // The string is just "YYMMDDHHMMSSZ".
    LDAPOBJECT_STRING(pLdapDestObject) =
        (PWSTR) AllocADsMem((13 + 1) * sizeof(WCHAR));
    if (LDAPOBJECT_STRING(pLdapDestObject) == NULL)
        RRETURN(hr = E_OUTOFMEMORY);

    wsprintf(LDAPOBJECT_STRING(pLdapDestObject),
        TEXT("%02d%02d%02d%02d%02d%02dZ"),
        st->wYear % 100, st->wMonth, st->wDay,
        st->wHour, st->wMinute, st->wSecond);


    *pdwSyntaxId = LDAPTYPE_UTCTIME;

    RRETURN(hr);
}

//
// This is currently only used in ldapc\var2ldap.cxx.
//
HRESULT
AdsTypeToLdapTypeCopyGeneralizedTime(
    PADSVALUE pAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME *st = &pAdsSrcValue->UTCTime;

    if (pAdsSrcValue->dwType != ADSTYPE_UTC_TIME)
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);

    //
    // ASN.1 spec says a GeneralizedTime can be no more than 24 chars.
    //
    LDAPOBJECT_STRING(pLdapDestObject) =
        (PWSTR) AllocADsMem((24 + 1) * sizeof(WCHAR));
    if (LDAPOBJECT_STRING(pLdapDestObject) == NULL)
        RRETURN(hr = E_OUTOFMEMORY);

    wsprintf(LDAPOBJECT_STRING(pLdapDestObject),
        TEXT("%04d%02d%02d%02d%02d%02d.%03dZ"),
        st->wYear, st->wMonth, st->wDay,
        st->wHour, st->wMinute, st->wSecond,
        st->wMilliseconds);

    *pdwSyntaxId = LDAPTYPE_GENERALIZEDTIME;

    RRETURN(hr);
}

HRESULT
AdsTypeToLdapTypeCopyLargeInteger(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD pdwSyntaxId
    )
{

    HRESULT hr = S_OK;
    TCHAR Buffer[64];

    if(lpAdsSrcValue->dwType != ADSTYPE_LARGE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    swprintf (Buffer, L"%I64d", lpAdsSrcValue->LargeInteger);

    LDAPOBJECT_STRING(lpLdapDestObject) = (LPTSTR) AllocADsStr( Buffer );

    if ( LDAPOBJECT_STRING(lpLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        RRETURN(hr);
    }

    *pdwSyntaxId = LDAPTYPE_INTEGER8;

    RRETURN(S_OK);

}

HRESULT
AdsTypeToLdapTypeCopyProvSpecific(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT pLdapDestObject,
    PDWORD pdwSyntaxId
    )
{
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PROV_SPECIFIC){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    dwNumBytes =  lpAdsSrcValue->ProviderSpecific.dwLength;

    LDAPOBJECT_BERVAL(pLdapDestObject) =
        (struct berval *) AllocADsMem( sizeof(struct berval) + dwNumBytes );

    if ( LDAPOBJECT_BERVAL(pLdapDestObject) == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    LDAPOBJECT_BERVAL_LEN(pLdapDestObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapDestObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapDestObject) + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapDestObject),
            lpAdsSrcValue->ProviderSpecific.lpValue,
            dwNumBytes );

    *pdwSyntaxId = LDAPTYPE_OCTETSTRING;

error:

    RRETURN(hr);
}



//
// Conversion routine for DN With String.
// Dn With String has the format :
//
//      S:9:OurDomain:dc=ntdev,dc=microsoft,dc=com
//
// (9 chars in OurDomain) on the server.
//
//
HRESULT
AdsTypeToLdapTypeCopyDNWithString(
    PADSVALUE   lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD      pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszLdapStrVal = NULL;
    DWORD dwLengthStr = 0;
    DWORD dwTotalLength = 0;
    PADS_DN_WITH_STRING pDNStr = NULL;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_STRING) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pDNWithString) {
        RRETURN(hr = E_FAIL);
    }

    pDNStr = lpAdsSrcValue->pDNWithString;

    //
    // Length is S:dwLength:Strval:
    //            2  9+1     dwLengthStr+2 (the : and \0)
    //

    dwTotalLength = 2 + 10 + 2;
    if (pDNStr->pszStringValue) {

        dwLengthStr = wcslen(pDNStr->pszStringValue);
        dwTotalLength += dwLengthStr;
    }

    if (pDNStr->pszDNString) {
        dwTotalLength += wcslen(pDNStr->pszDNString) + 1;
    }

    pszLdapStrVal = (LPWSTR) AllocADsMem(dwTotalLength * sizeof(WCHAR));

    if (!pszLdapStrVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wsprintf(pszLdapStrVal, L"S:%ld:",dwLengthStr);
    //
    // tag on the string val if appropriate
    //
    if (dwLengthStr) {
        wcscat(pszLdapStrVal, pDNStr->pszStringValue);
    }

    wcscat(pszLdapStrVal, L":");

    //
    // Now for the actual DN - if one is there
    //
    if (pDNStr->pszDNString) {
        wcscat(pszLdapStrVal, pDNStr->pszDNString);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) = pszLdapStrVal;

    *pdwSyntaxId = LDAPTYPE_DNWITHSTRING;

error:

    RRETURN(hr);

}



//
// Conversion routine for DN With Binary.
// Dn With Binary has the format :
//
//      B:32:a9d1ca15768811d1aded00c04fd8d5cd:dc=ntdev,dc=microsoft,dc=com
//
// (32 wchars = 16 bytes in this case a guid).
//
//
HRESULT
AdsTypeToLdapTypeCopyDNWithBinary(
    PADSVALUE   lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    PDWORD      pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    WCHAR pszSmallStr[5];
    LPWSTR pszLdapStrVal = NULL;
    DWORD dwTotalLength = 0;
    PADS_DN_WITH_BINARY pDNBin = NULL;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_BINARY) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pDNWithBinary) {
        RRETURN(E_FAIL);
    }

    pDNBin = lpAdsSrcValue->pDNWithBinary;

    //
    // B:xxx:octStr:DNString\0 at the end
    //  2+10+  x + 1 +   y + 1 = 14 + x + y
    //
    dwTotalLength = 14;

    if (pDNBin->dwLength) {

        //
        // Add 2 * OctetString length as it is encoded as str.
        //
        dwTotalLength += 2 * (pDNBin->dwLength);
    }

    if (pDNBin->pszDNString) {
        dwTotalLength += wcslen(pDNBin->pszDNString);
    }

    pszLdapStrVal = (LPWSTR) AllocADsMem(dwTotalLength * sizeof(WCHAR));

    if (!pszLdapStrVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wsprintf(pszLdapStrVal, L"B:%ld:",(pDNBin->dwLength) * 2);
    //
    // tag on the hex encoded string if appropriate
    //
    if (pDNBin->dwLength) {
        if (!pDNBin->lpBinaryValue) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        for (DWORD i = 0; i < pDNBin->dwLength; i++) {
            wsprintf(pszSmallStr, L"%02x", pDNBin->lpBinaryValue[i]);
            wcscat(pszLdapStrVal, pszSmallStr);
        }
    }

    wcscat(pszLdapStrVal, L":");

    //
    // Now for the actual DN - if one is there
    //
    if (pDNBin->pszDNString) {
        wcscat(pszLdapStrVal, pDNBin->pszDNString);
    }

    LDAPOBJECT_STRING(lpLdapDestObject) = pszLdapStrVal;

    *pdwSyntaxId = LDAPTYPE_DNWITHBINARY;

error:

    if (FAILED(hr)) {
        FreeADsMem(pszLdapStrVal);
    }

    RRETURN(hr);

}


HRESULT
AdsTypeToLdapTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PLDAPOBJECT lpLdapDestObject,
    BOOL *pfIsString,
    PDWORD pdwSyntaxId,
    BOOL fGenTime
    )
{
    HRESULT hr = S_OK;

    *pfIsString = TRUE;  // This will only be FALSE when the ADSVALUE
                         // contains octet strings

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        hr = AdsTypeToLdapTypeCopyDNString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        hr = AdsTypeToLdapTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToLdapTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        hr = AdsTypeToLdapTypeCopyPrintableString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        hr = AdsTypeToLdapTypeCopyNumericString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToLdapTypeCopyBoolean(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToLdapTypeCopyInteger(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;


    case ADSTYPE_OCTET_STRING:
        *pfIsString = FALSE;
        hr = AdsTypeToLdapTypeCopyOctetString(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_UTC_TIME:
        if (fGenTime) {
            //
            // Treat as gentime not UTCTime
            //
            hr = AdsTypeToLdapTypeCopyGeneralizedTime(
                     lpAdsSrcValue,
                     lpLdapDestObject,
                     pdwSyntaxId
                     );
        }
        else {

            hr = AdsTypeToLdapTypeCopyTime(
                    lpAdsSrcValue,
                    lpLdapDestObject,
                    pdwSyntaxId
                    );
        }

        break;

    case ADSTYPE_LARGE_INTEGER:
        hr = AdsTypeToLdapTypeCopyLargeInteger(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_PROV_SPECIFIC:
        *pfIsString = FALSE;
        hr = AdsTypeToLdapTypeCopyProvSpecific(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        *pfIsString = FALSE;
        hr = AdsTypeToLdapTypeCopySecurityDescriptor(
                lpAdsSrcValue,
                lpLdapDestObject,
                pdwSyntaxId
                );
        break;

    case ADSTYPE_DN_WITH_BINARY:
        *pfIsString = TRUE;
        hr = AdsTypeToLdapTypeCopyDNWithBinary(
                 lpAdsSrcValue,
                 lpLdapDestObject,
                 pdwSyntaxId
                 );
        break;

    case ADSTYPE_DN_WITH_STRING:
        *pfIsString = TRUE;
        hr = AdsTypeToLdapTypeCopyDNWithString(
                 lpAdsSrcValue,
                 lpLdapDestObject,
                 pdwSyntaxId
                 );
        break;

    default:
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        *pdwSyntaxId =0;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToLdapTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LDAPOBJECTARRAY *pLdapDestObjects,
    PDWORD pdwSyntaxId,
    BOOL fGenTime
    )
{

    DWORD i = 0;
    HRESULT hr = S_OK;

    if ( dwNumObjects == 0 )
    {
        pLdapDestObjects->dwCount = 0;
        pLdapDestObjects->pLdapObjects = NULL;
        RRETURN(S_OK);
    }

    pLdapDestObjects->pLdapObjects = (PLDAPOBJECT)AllocADsMem(
                                         (dwNumObjects+1) * sizeof(LDAPOBJECT));

    if ( pLdapDestObjects->pLdapObjects == NULL )
        RRETURN(E_OUTOFMEMORY);

    pLdapDestObjects->dwCount = dwNumObjects;

    for (i = 0; i < dwNumObjects; i++ ) {

         hr = AdsTypeToLdapTypeCopy(
                    pAdsSrcValues + i,
                    pLdapDestObjects->pLdapObjects + i,
                    &(pLdapDestObjects->fIsString),
                    pdwSyntaxId,
                    fGenTime
                    );
         BAIL_ON_FAILURE(hr);
    }

    RRETURN(S_OK);

error:

    LdapTypeFreeLdapObjects( pLdapDestObjects );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\ldpcache.cxx ===
#include "ldapc.hxx"
#pragma hdrstop

ADS_LDP           BindCache ;
DWORD             BindCacheCount = 0 ;
CRITICAL_SECTION  BindCacheCritSect ;
LUID              ReservedLuid = { 0, 0 } ;

//
// Wait for 1000ms * 60 * minutes
//
#define RETIRE_HANDLE (1000 * 60 * 5)
//
// Return the LUID for current credentials. Note we only use LUID. In theory
// it may be better to use SourceName as well as identifier but the former
// doesnt seem to always return the same string.
//
DWORD BindCacheGetLuid(LUID *Luid, LUID *ModifiedId)
{
    HANDLE           TokenHandle = NULL ;
    TOKEN_STATISTICS TokenInformation ;
    DWORD            ReturnLength ;


    //
    // Try thread first. If fail, try process.
    //
    if (!OpenThreadToken(
             GetCurrentThread(),
             TOKEN_QUERY,
             TRUE,
             &TokenHandle)) {

        if (!OpenProcessToken(
                 GetCurrentProcess(),
                 TOKEN_QUERY,
                 &TokenHandle)) {

            return(GetLastError()) ;
        }
    }

    //
    // Get the TokenSource info.
    //
    if (!GetTokenInformation(
            TokenHandle,
            TokenStatistics,
            &TokenInformation,
            sizeof(TokenInformation),
            &ReturnLength)) {

        CloseHandle(TokenHandle) ;
        return(GetLastError()) ;
    }

    *Luid = TokenInformation.AuthenticationId ;
    *ModifiedId = TokenInformation.ModifiedId;

    CloseHandle(TokenHandle) ;
    return(NO_ERROR) ;
}

//
// Initializes a cache entry
//
DWORD BindCacheAllocEntry(ADS_LDP **ppCacheEntry)
{

    ADS_LDP *pCacheEntry ;

    *ppCacheEntry = NULL ;

    if (!(pCacheEntry = (PADS_LDP)AllocADsMem(sizeof(ADS_LDP)))) {

        return(GetLastError()) ;
    }

    pCacheEntry->RefCount = 0;
    pCacheEntry->Flags = 0;
    pCacheEntry->List.Flink = NULL ;
    pCacheEntry->List.Blink = NULL ;

    pCacheEntry->ReferralEntries = NULL ;
    pCacheEntry->nReferralEntries = 0 ;
    pCacheEntry->fKeepAround = FALSE;

    *ppCacheEntry =  pCacheEntry ;
    return NO_ERROR ;
}

//
// Invalidates a cache entry so it will not be used.
//
VOID BindCacheInvalidateEntry(ADS_LDP *pCacheEntry)
{
    pCacheEntry->Flags |= LDP_CACHE_INVALID ;
}


//
// !!!WARNING!!! Make sure you hold the bindcache critsect
// when calling this function.
//
VOID CommonRemoveEntry(ADS_LDP *pCacheEntry, LIST_ENTRY *DeleteReferralList)
{

    for (DWORD i=0; i < pCacheEntry->nReferralEntries; i++) {

        if (BindCacheDerefHelper( pCacheEntry->ReferralEntries[i], DeleteReferralList) == 0 ) {
            InsertTailList( DeleteReferralList, &(pCacheEntry->ReferralEntries[i])->ReferralList );           
        }
    }


    //
    // Cleanup the entry
    //
    //

    --BindCacheCount ;

    (void) FreeADsMem(pCacheEntry->Server) ;
    pCacheEntry->Server = NULL ;

    delete pCacheEntry->pCredentials;
    pCacheEntry->pCredentials = NULL;

    if (pCacheEntry->ReferralEntries) {
        FreeADsMem(pCacheEntry->ReferralEntries);
    }
    
    RemoveEntryList(&pCacheEntry->List) ;    

    return;
}

#if 0
VOID BindCacheCleanTimedOutEntries()
{
    DWORD dwCurrTick = 0;
    DWORD dwLastTick = 0;
    BOOL fRemoved = FALSE;
    ADS_LDP *ldRemove = NULL;

    ENTER_BIND_CRITSECT();

    PADS_LDP pEntry = (PADS_LDP) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     servername & LUID matches, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        //
        // See if this one is keepAround entry that is old
        //
        if (pEntry->RefCount == 0) {

            ADsAssert(pEntry->fKeepAround);

            //
            // GetCurrent tick and see if we need to del the entry
            //
            dwCurrTick = GetTickCount();
            dwLastTick = pEntry->dwLastUsed;

            if ((dwLastTick == 0)
                || ((dwLastTick <= dwCurrTick)
                    && ((dwCurrTick - dwLastTick) > RETIRE_HANDLE))
                || ((dwLastTick > dwCurrTick)
                    && ((dwCurrTick + (((DWORD)(-1)) - dwLastTick))
                                                    > RETIRE_HANDLE)))
                {

                //
                // Entry needs to be removed.
                //
                CommonRemoveEntry(pEntry);
                fRemoved = TRUE;
            }
        } // refCount == 0

        if (fRemoved) {
            LdapUnbind(pEntry);
            ldRemove = pEntry;
        }

        pEntry = (PADS_LDP)pEntry->List.Flink ;

        if (ldRemove) {
            FreeADsMem(ldRemove);
            ldRemove = NULL;
        }
    }

    LEAVE_BIND_CRITSECT();
    return;
}
#endif

//
// Lookup an entry in the cache. Does not take into account timeouts.
// Increments ref count if found.
//
PADS_LDP
BindCacheLookup(
    LPWSTR Address,
    LUID Luid,
    LUID ModifiedId,
    CCredentials& Credentials,
    DWORD dwPort
    )
{
    DWORD i ;

    ENTER_BIND_CRITSECT() ;

    PADS_LDP pEntry = (PADS_LDP) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     servername & LUID matches, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        if ((pEntry->Server != NULL) &&
            !(pEntry->Flags & LDP_CACHE_INVALID) &&
            (wcscmp(pEntry->Server, Address) == 0) &&
            pEntry->PortNumber == dwPort &&
            (memcmp(&Luid,&(pEntry->Luid),sizeof(Luid))==0) &&
            ((memcmp(&ModifiedId, &(pEntry->ModifiedId), sizeof(Luid)) == 0) ||
             (memcmp(&ModifiedId, &ReservedLuid, sizeof(Luid)) == 0))) {

            if ((*(pEntry->pCredentials) == Credentials) ||
                CanCredentialsBeReused(pEntry->pCredentials, &Credentials))
            {
                ++pEntry->RefCount ;

                LEAVE_BIND_CRITSECT() ;
                return(pEntry) ;
            }
        }

        pEntry = (PADS_LDP)pEntry->List.Flink ;
    }

    LEAVE_BIND_CRITSECT() ;
    //
    // Before we leave clean out stale entries
    //
    //BindCacheCleanTimedOutEntries();

    return NULL ;
}


//
// Check if credentials can be reused. They can be reused if username and
// non-ignored auth flags match and incoming credentials thesame password.  
// Ignored auth flags are those defined by
// BIND_CACHE_IGNORED_FLAGS as not to be used in considering whether to
// reuse a connection.
//

BOOL
CanCredentialsBeReused(
    CCredentials *pCachedCreds,
    CCredentials *pIncomingCreds
    )
{
    PWSTR pszIncomingUser = NULL;
    PWSTR pszIncomingPwd = NULL;
    PWSTR pszCachedUser = NULL;
    PWSTR pszCachedPwd = NULL;
    HRESULT hr;
    BOOL rc = FALSE;

    //
    // Test that the non-ignored auth flags match.
    // We need to be smart and reuse the credentials based on the flags.
    //
    if ( (~BIND_CACHE_IGNORED_FLAGS & pCachedCreds->GetAuthFlags()) != 
         (~BIND_CACHE_IGNORED_FLAGS & pIncomingCreds->GetAuthFlags()))
    {
        return FALSE;
    }


    //
    // Get the user names
    //
    hr = pCachedCreds->GetUserName(&pszCachedUser);
    BAIL_ON_FAILURE(hr);

    hr = pIncomingCreds->GetUserName(&pszIncomingUser);
    BAIL_ON_FAILURE(hr);

    
    //
    // Get the password
    //
    hr = pIncomingCreds->GetPassword(&pszIncomingPwd);
    BAIL_ON_FAILURE(hr);

    hr = pCachedCreds->GetPassword(&pszCachedPwd);
    BAIL_ON_FAILURE(hr);
    
    //
    // Only when both username and password match, will we reuse the connection handle
    //

    if (((pszCachedUser && pszIncomingUser &&
        wcscmp(pszCachedUser, pszIncomingUser) == 0) ||
        (!pszCachedUser && !pszIncomingUser)) 
        &&
        ((pszCachedPwd && pszIncomingPwd &&
    	wcscmp(pszCachedPwd, pszIncomingPwd) == 0) ||
    	(!pszCachedPwd && !pszIncomingPwd)))
    {
        rc = TRUE;
    }     
    
error:
    if (pszCachedUser)
    {
        FreeADsStr(pszCachedUser);
    }
    if (pszIncomingUser)
    {
        FreeADsStr(pszIncomingUser);
    }
    if (pszCachedPwd)
    {
        FreeADsStr(pszCachedPwd);
    }
    if (pszIncomingPwd)
    {
        FreeADsStr(pszIncomingPwd);
    }

    return rc;
}

//
// Lookup an entry in the cache based on the Ldap Handle
// DOES NOT Increment ref count
//
PADS_LDP
GetCacheEntry(PLDAP pLdap)
{

    ENTER_BIND_CRITSECT() ;


    PADS_LDP pEntry = (PADS_LDP) BindCache.List.Flink ;

    //
    // Loop thru looking for match. A match is defined as:
    //     servername & LUID matches, and it is NOT invalid.
    //
    while (pEntry != &BindCache) {

        if (pEntry->LdapHandle == pLdap) {

            LEAVE_BIND_CRITSECT() ;
            return(pEntry) ;
        }

        pEntry = (PADS_LDP)pEntry->List.Flink ;
    }

    LEAVE_BIND_CRITSECT() ;
    return NULL ;
}



//
// Add entry to cache
//
DWORD
BindCacheAdd(
    LPWSTR Address,
    LUID Luid,
    LUID ModifiedId,
    CCredentials& Credentials,
    DWORD dwPort,
    PADS_LDP pCacheEntry)
{

    ENTER_BIND_CRITSECT() ;



    if (BindCacheCount > MAX_BIND_CACHE_SIZE) {

        //
        // If exceed limit, just dont put in cache. Since we leave the
        // RefCount & the Links unset, the deref will simply note that
        // this entry is not in cache and allow it to be freed.
        //
        // We limit cache so that if someone leaks handles we dont over
        // time end up traversing this huge linked list.
        //
        LEAVE_BIND_CRITSECT() ;
        return(NO_ERROR) ;
    }

    LPWSTR pServer = (LPWSTR) AllocADsMem(
                                   (wcslen(Address)+1)*sizeof(WCHAR)) ;

    if (!pServer) {

        LEAVE_BIND_CRITSECT() ;
        return(GetLastError()) ;
    }

    CCredentials * pCredentials = new CCredentials(Credentials);

    if (!pCredentials) {

        FreeADsMem(pServer);

        LEAVE_BIND_CRITSECT();
        return(GetLastError());
    }



    //
    // setup the data
    //
    wcscpy(pServer,Address) ;



    pCacheEntry->pCredentials = pCredentials;
    pCacheEntry->PortNumber       = dwPort;
    pCacheEntry->Server    = pServer ;
    pCacheEntry->RefCount  = 1 ;
    pCacheEntry->Luid      = Luid ;
    pCacheEntry->ModifiedId = ModifiedId;



    //
    // insert into list
    //
    InsertHeadList(&BindCache.List, &pCacheEntry->List) ;
    ++BindCacheCount ;
    LEAVE_BIND_CRITSECT() ;

    return NO_ERROR ;
}

//
// Bump up the reference count of the particular cache entry
// Returns the final ref count or zero if not there.
//
BOOL BindCacheAddRef(ADS_LDP *pCacheEntry)
{

    DWORD dwCount = 0;

    ENTER_BIND_CRITSECT() ;

    if ((pCacheEntry->List.Flink == NULL) &&
        (pCacheEntry->List.Blink == NULL) &&
        (pCacheEntry->RefCount == NULL)) {

        //
        // this is one of them entries that has no LUID.
        // ie. it never got into the cache.
        //
        LEAVE_BIND_CRITSECT() ;
        return(0) ;
    }

    ADsAssert(pCacheEntry->List.Flink) ;
    ADsAssert(pCacheEntry->RefCount > 0) ;

    pCacheEntry->RefCount++ ;

    //
    // Save info onto stack variable as we are going
    // to leave the critsect before we exit.
    //
    dwCount = pCacheEntry->RefCount;

    LEAVE_BIND_CRITSECT() ;

    return(dwCount) ;
}

//
// Adds a referral entry of pNewEntry to pPrimaryEntry. Increments the reference
// count of pPrimaryEntry if succesful.
//

BOOL
AddReferralLink(
    PADS_LDP pPrimaryEntry,
    PADS_LDP pNewEntry
    )
{
    ENTER_BIND_CRITSECT() ;

    if (!pPrimaryEntry) {
        goto error;
    }
    if (!pPrimaryEntry->ReferralEntries) {
        pPrimaryEntry->ReferralEntries = (PADS_LDP *) AllocADsMem(
                                             sizeof(PADS_LDP) * MAX_REFERRAL_ENTRIES);

        if (!pPrimaryEntry->ReferralEntries) {
            goto error;
        }
        pPrimaryEntry->nReferralEntries = 0;
    }

    if (pPrimaryEntry->nReferralEntries >= MAX_REFERRAL_ENTRIES) {
        //
        // We won't remember more than this
        //
        goto error;
    }

    pPrimaryEntry->ReferralEntries[pPrimaryEntry->nReferralEntries] = pNewEntry;

    if (!BindCacheAddRef(pNewEntry)) {
        goto error;
    }

    pPrimaryEntry->nReferralEntries++;
    LEAVE_BIND_CRITSECT() ;
    return TRUE;

error:
    LEAVE_BIND_CRITSECT();
    return FALSE;

}

DWORD BindCacheDeref(ADS_LDP *pCacheEntry)
{

   DWORD dwCount = 0; 
   LIST_ENTRY DeleteReferralList;
   PLIST_ENTRY pEntry;
   PADS_LDP EntryInfo;

   InitializeListHead(&DeleteReferralList);

      
   dwCount = BindCacheDerefHelper(pCacheEntry, &DeleteReferralList);

  
    // Delete the cached entries
    //

    while (!IsListEmpty (&DeleteReferralList))  {

        pEntry = RemoveHeadList (&DeleteReferralList);
        EntryInfo = CONTAINING_RECORD (pEntry, ADS_LDP, ReferralList);


        LdapUnbind(EntryInfo);

        FreeADsMem(EntryInfo);
        
    }

    return dwCount;
        
}

//
// Dereference an entry in the cache. Removes if ref count is zero.
// Returns the final ref count or zero if not there. If zero, caller
// should close the handle.
//
DWORD BindCacheDerefHelper(ADS_LDP *pCacheEntry, LIST_ENTRY * DeleteReferralList)
{

    DWORD dwCount=0;
    
    ENTER_BIND_CRITSECT() ;

    if ((pCacheEntry->List.Flink == NULL) &&
        (pCacheEntry->List.Blink == NULL) &&
        (pCacheEntry->RefCount == NULL)) {

        //
        // this is one of them entries that has no LUID.
        // ie. it never got into the cache.
        //
        LEAVE_BIND_CRITSECT() ;
        return(0) ;
    }

    ADsAssert(pCacheEntry->List.Flink) ;
    ADsAssert(pCacheEntry->RefCount > 0) ;

    //
    // Dereference by one. If result is non zero, just return.
    //
    --pCacheEntry->RefCount ;

    if (pCacheEntry->RefCount) {

        //
        // Use a stack variable for this value as
        // we call return outside the critsect.
        //
        dwCount = pCacheEntry->RefCount;

        LEAVE_BIND_CRITSECT() ;

        return(dwCount);
    }

    //
    // Before clearing the entry away verify that
    // we do not need to KeepAround this one.
    //
    if (pCacheEntry->fKeepAround) {
        //
        // Set the timer on this entry and leave.
        //
        pCacheEntry->dwLastUsed = GetTickCount();
        LEAVE_BIND_CRITSECT() ;

    }
    else {

        //
        // Now that this entry is going away, deref all the referred entries.
        //
        CommonRemoveEntry(pCacheEntry, DeleteReferralList);
        LEAVE_BIND_CRITSECT() ;

               

    }

    
    //
    // Look for any other entries that need to be cleaned out
    //
    //BindCacheCleanTimedOutEntries();

    return 0 ;
}


VOID
BindCacheInit(
    VOID
    )
{
    InitializeCriticalSection(&BindCacheCritSect) ;
    InitializeListHead(&BindCache.List) ;
}

VOID
BindCacheCleanup(
    VOID
    )
{
    PADS_LDP pEntry = (PADS_LDP) BindCache.List.Flink ;

    while (pEntry != &BindCache) {

        PADS_LDP pNext = (PADS_LDP) pEntry->List.Flink;

        (void) FreeADsMem(pEntry->Server) ;

        pEntry->Server = NULL ;

        if (pEntry->ReferralEntries) {
            FreeADsMem(pEntry->ReferralEntries);
        }

        RemoveEntryList(&pEntry->List) ;

        pEntry = pNext;
    }

    //
    // Delte the critical section initialized in BindCacheInit
    //
    DeleteCriticalSection(&BindCacheCritSect) ;
}

//
// Mark handle so that we keep it even after the object count
// has hit zero and remove only after a x mins of zero count.
//
HRESULT
LdapcKeepHandleAround(ADS_LDP *ld)
{

    ADsAssert(ld);

    ld->fKeepAround = TRUE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\oledserr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oledserr.c

Abstract:

    Contains the entry point for
        ADsGetLastError
        ADsSetLastError
        ADsFreeAllErrorRecords

    Also contains the following support routines:
        ADsAllocErrorRecord
        ADsFreeErrorRecord
        ADsFindErrorRecord

Author:


    Ram Viswanathan (ramv) 09-24-1996
    appropriated from mpr project. Originally written by danl.

Environment:

    User Mode - Win32

Revision History:

    09-Sep-1996 ramv
        Copied from mpr project and made the following modifications.
        Renamed all errors to Active Directory errors. ADsGetLastError and
        ADsSetLastError now return an HRESULT giving status.

--*/
//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>

#include "memory.h"
#include "oledsdbg.h"
#include "oledserr.h"


#if DBG
DECLARE_INFOLEVEL(ADsErr);
DECLARE_DEBUG(ADsErr);
#define ADsErrDebugOut(x) ADsErrInlineDebugOut x
#else
#define ADsErrDebugOut(x)
#endif

//
// Global Data Structures
//

ERROR_RECORD        ADsErrorRecList;    // Initialized to zeros by loader
CRITICAL_SECTION    ADsErrorRecCritSec; // Initialized in libmain.cxx


HRESULT
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    )

/*++

Routine Description:

    This function allows users to obtain the error code and accompanying
    text when they receive a ERROR_EXTENDED_ERROR in response to a ADs API
    function call.

Arguments:

    lpError - This is a pointer to the location that will receive the
        error code.

    lpErrorBuf - This points to a buffer that will receive the null
        terminated string describing the error.

    dwErrorBufLen - This value that indicates the size (in characters) of
        lpErrorBuf.
        If the buffer is too small to receive an error string, the
        string will simply be truncated.  (it is still guaranteed to be
        null terminated).  A buffer of at least 256 bytes is recommended.

    lpNameBuf - This points to a buffer that will receive the name of
        the provider that raised the error.

    dwNameBufLen - This value indicates the size (in characters) of lpNameBuf.
        If the buffer is too small to receive an error string, the
        string will simply be truncated.  (it is still guaranteed to be
        null terminated).

Return Value:

    S_OK- if the call was successful.

    E_POINTER - One or more of the passed in pointers is bad.

    ERROR_BAD_DEVICE - This indicates that the threadID for the current
        thread could not be found in that table anywhere.  This should
        never happen.

--*/
{
    LPERROR_RECORD  errorRecord;
    DWORD           dwNameStringLen;
    DWORD           dwTextStringLen;
    HRESULT         hr = S_OK;
    DWORD           dwStatus = ERROR_SUCCESS;


    //
    // Screen the parameters as best we can.
    //
    if (!lpError || !lpErrorBuf || !lpNameBuf) {

        // some error, the user is never going to see this
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        hr = E_POINTER;

    }

    if (dwStatus != ERROR_SUCCESS) {
        return(hr);
    }

    //
    // Get the current thread's error record.
    //
    errorRecord = ADsFindErrorRecord();

    if (errorRecord != NULL) {
        //
        // The record was found in the linked list.
        // See if there is a buffer to put data into.
        //
        if (dwErrorBufLen > 0) {
            //
            // Check to see if there is error text to return.
            // If not, indicate a 0 length string.
            //
            if(errorRecord->pszErrorText == NULL) {
                *lpErrorBuf = L'\0';
            }
            else {
                //
                // If the error text won't fit into the user buffer, fill it
                // as best we can, and NULL terminate it.
                //
                dwTextStringLen = (DWORD) wcslen(errorRecord->pszErrorText);

                if(dwErrorBufLen < dwTextStringLen + 1) {
                    dwTextStringLen = dwErrorBufLen - 1;
                }

                //
                // dwTextStringLen now contains the number of characters we
                // will copy without the NULL terminator.
                //
                wcsncpy(lpErrorBuf, errorRecord->pszErrorText, dwTextStringLen);
                *(lpErrorBuf + dwTextStringLen) = L'\0';
            }
        }

        //
        // If there is a Name Buffer to put the provider into, then...
        //
        if (dwNameBufLen > 0) {
            //
            // See if the Provider Name will fit in the user buffer.
            //
            dwNameStringLen = errorRecord->pszProviderName ?
                 ((DWORD)wcslen(errorRecord->pszProviderName) + 1) :
                 1 ;

            //
            // If the user buffer is smaller than the required size,
            // set up to copy the smaller of the two.
            //
            if(dwNameBufLen < dwNameStringLen + 1) {
                dwNameStringLen = dwNameBufLen - 1;
            }

            if (errorRecord->pszProviderName) {
                wcsncpy(lpNameBuf, errorRecord->pszProviderName, dwNameStringLen);
                *(lpNameBuf + dwNameStringLen) = L'\0';
            }
            else {
                *lpNameBuf = L'\0';
            }
        }
        *lpError = errorRecord->dwErrorCode;

        return(S_OK);
    }
    else {

        //
        // If we get here, a record for the current thread could not be found.
        //
        *lpError = ERROR_SUCCESS;
        if (dwErrorBufLen > 0) {
            *lpErrorBuf = L'\0';
        }
        if (dwNameBufLen > 0) {
            *lpNameBuf  = L'\0';
        }
        return(S_OK);
    }
}


VOID
ADsSetLastError(
    IN  DWORD   dwErr,
    IN  LPCWSTR  pszError,
    IN  LPCWSTR  pszProvider
    )

/*++

Routine Description:

    This function is used by Active Directory Providers to set extended errors.
    It saves away the error information in a "per thread" data structure.


Arguments:

    dwErr - The error that occured.  This may be a Windows defined error,
        in which case pszError is ignored.  or it may be ERROR_EXTENDED_ERROR
        to indicate that the provider has a network specific error to report.

    pszError - String describing a network specific error.

    pszProvider - String naming the network provider raising the error.

Return Value:

    none


--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPERROR_RECORD  errorRecord;

    //
    // Get the Error Record for the current thread.
    //
    errorRecord = ADsFindErrorRecord();

    //
    // if there isn't a record for the current thread, then add it.
    //
    if (errorRecord == NULL)
    {
        errorRecord = ADsAllocErrorRecord();

        if (errorRecord == NULL)
        {
            ADsErrDebugOut((DEB_TRACE,
                 "ADsSetLastError:Could not allocate Error Record\n"));
            return;
        }
    }

    //
    // Update the error code in the error record.  At the same time,
    // free up any old strings since they are now obsolete, and init
    // the pointer to NULL.  Also set the ProviderName pointer in the
    // ErrorRecord to point to the provider's name.
    //

    errorRecord->dwErrorCode = dwErr;

    if(errorRecord->pszProviderName){
        FreeADsMem(errorRecord->pszProviderName);
    }

    errorRecord->pszProviderName = NULL;

    if(errorRecord->pszErrorText){
        FreeADsMem(errorRecord->pszErrorText);
    }

    errorRecord->pszErrorText = NULL;

    //
    // Allocate memory for the provider name.
    //
    if (pszProvider) {

        errorRecord->pszProviderName = (WCHAR *)AllocADsMem(
            ((DWORD)wcslen(pszProvider) +1) * sizeof(WCHAR));

        if (!(errorRecord->pszProviderName)) {

            dwStatus = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // Copy the string to the newly allocated buffer.
            //
            wcscpy(errorRecord->pszProviderName, pszProvider);
        }
    }

    if (dwStatus != ERROR_SUCCESS) {
        return;
    }


    //
    //  Allocate memory for the storage of the error text.
    //
    if (pszError) {

        errorRecord->pszErrorText = (WCHAR *) AllocADsMem(
            ((DWORD)wcslen(pszError) +1)* sizeof(WCHAR));

        if (errorRecord->pszErrorText) {

            //
            // Copy the error text into the newly allocated buffer.
            //
            wcscpy(errorRecord->pszErrorText, pszError);
        }

        // We do not really care about an error because we
        // are going to return anyway.

    }
    return;
}


LPERROR_RECORD
ADsFindErrorRecord(
    VOID)

/*++

Routine Description:

    Looks through the linked list of ErrorRecords in search of one for
    the current thread.

Arguments:

    none

Return Value:

    Returns LPERROR_RECORD if an error record was found.  Otherwise, it
    returns NULL.

--*/
{
    LPERROR_RECORD  errorRecord;
    DWORD           dwCurrentThreadId = GetCurrentThreadId();

    EnterCriticalSection(&ADsErrorRecCritSec);
    for (errorRecord = ADsErrorRecList.Next;
         errorRecord != NULL;
         errorRecord = errorRecord->Next)
    {
        if (errorRecord->dwThreadId == dwCurrentThreadId)
        {
            break;
        }
    }
    LeaveCriticalSection(&ADsErrorRecCritSec);
    return(errorRecord);
}


LPERROR_RECORD
ADsAllocErrorRecord(
    VOID)

/*++

Routine Description:

    This function allocates and initializes an Error Record for the
    current thread.  Then it places the error record in the global
    ADsErrorRecList.
    Even if the thread exits, the record is not freed until the DLL unloads.
    This is OK because this function is called only if a provider calls
    ADsSetLastError, which is rare.

Arguments:

    none

Return Value:

    TRUE - The operation completed successfully

    FALSE - An error occured in the allocation.

Note:


--*/
{
    LPERROR_RECORD  record;
    LPERROR_RECORD  errorRecord;

    //
    //  Allocate memory for the storage of the error message
    //  and add the record to the linked list.
    //
    errorRecord = (LPERROR_RECORD)AllocADsMem(sizeof (ERROR_RECORD));

    if (errorRecord == NULL) {
        ADsErrDebugOut((
            DEB_TRACE,
            "ADsAllocErrorRecord:LocalAlloc Failed %d\n",
            GetLastError()
            ));
        return NULL;
    }

    //
    // Initialize the error record
    //
    errorRecord->dwThreadId = GetCurrentThreadId();
    errorRecord->dwErrorCode = ERROR_SUCCESS;
    errorRecord->pszErrorText = NULL;

    //
    // Add the record to the linked list.
    //
    EnterCriticalSection(&ADsErrorRecCritSec);

    record = &ADsErrorRecList;
    ADD_TO_LIST(record, errorRecord);

    LeaveCriticalSection(&ADsErrorRecCritSec);

    return errorRecord;
}


VOID
ADsFreeAllErrorRecords(
    VOID)

/*++

Routine Description:

    This function is called when the DLL is unloading due to a FreeLibrary
    call.  It frees all the error records (for all threads) that have been
    created since the DLL was loaded.  If there is a pointer to a text string
    in a record, the buffer for that string is freed also.

Arguments:


Return Value:


Note:


--*/
{
    LPERROR_RECORD nextRecord;
    LPERROR_RECORD record;

    EnterCriticalSection(&ADsErrorRecCritSec);

    for (record = ADsErrorRecList.Next;
         record != NULL;
         record = nextRecord)
    {
        ADsErrDebugOut(
            (DEB_TRACE,
             "ADsFreeErrorRecord: Freeing Record for thread 0x%x\n",
            record->dwThreadId ));

        if(record->pszErrorText){
            FreeADsMem(record->pszErrorText);
        }

        record->pszErrorText = NULL;

        if(record->pszProviderName){
            FreeADsMem(record->pszProviderName);
        }
        record->pszProviderName = NULL;

        nextRecord = record->Next;

        if(record){
            FreeADsMem(record);
        }
        record = NULL;
    }

    ADsErrorRecList.Next = NULL;

    LeaveCriticalSection(&ADsErrorRecCritSec);
}

VOID
ADsFreeThreadErrorRecords(
    VOID)

/*++

Routine Description:

    This function is called when the DLL is unloading due to a FreeLibrary
    call.  It frees all the error records (for all threads) that have been
    created since the DLL was loaded.  If there is a pointer to a text string
    in a record, the buffer for that string is freed also.

Arguments:


Return Value:


Note:


--*/
{
    LPERROR_RECORD record;
    DWORD dwThreadId = GetCurrentThreadId();

    EnterCriticalSection(&ADsErrorRecCritSec);

    for (record = ADsErrorRecList.Next;
         record != NULL;
         record = record->Next)
    {
        ADsErrDebugOut(
            (DEB_TRACE,
             "ADsFreeErrorRecord: Freeing Record for thread 0x%x\n",
            record->dwThreadId ));

        if (record->dwThreadId == dwThreadId) {
            REMOVE_FROM_LIST(record);
            if(record->pszErrorText){
                FreeADsMem(record->pszErrorText);
                record->pszErrorText = NULL;
            }
            if(record->pszProviderName){
                FreeADsMem(record->pszProviderName);
                record->pszProviderName = NULL;
            }
            FreeADsMem(record);
            break;
        }
    }
    LeaveCriticalSection(&ADsErrorRecCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\odsmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       odsmrshl.cxx
//
//  Contents:   DSObject Copy Routines
//
//  Functions:
//
//  History:    25-Feb-97   yihsins   Created.
//
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"

LPBYTE
AdsTypeCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);


    lpAdsDestValue->DNString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->DNString);

    dwLength = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);

    lpAdsDestValue->CaseExactString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseExactString);

    dwLength = (wcslen(lpAdsSrcValue->CaseExactString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )

{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);

    lpAdsDestValue->CaseIgnoreString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseIgnoreString);

    dwLength = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);

    lpAdsDestValue->PrintableString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->PrintableString);

    dwLength = (wcslen(lpAdsSrcValue->PrintableString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    //
    // The target buffer has to be WCHAR (WORD) aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);

    lpAdsDestValue->NumericString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->NumericString);

    dwLength = (wcslen(lpAdsSrcValue->NumericString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}



LPBYTE
AdsTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean = lpAdsSrcValue->Boolean;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer = lpAdsSrcValue->Integer;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;

    //
    // The target buffer should be worst-case aligned
    //

    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);

    memcpy(
        lpBuffer,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopySecurityDescriptor(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NT_SECURITY_DESCRIPTOR){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;

    dwNumBytes =  lpAdsSrcValue->SecurityDescriptor.dwLength;

    //
    // The target buffer should be worst-case aligned
    //

    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);

    memcpy(
        lpBuffer,
        lpAdsSrcValue->SecurityDescriptor.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->SecurityDescriptor.dwLength = dwNumBytes;

    lpAdsDestValue->SecurityDescriptor.lpValue =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyTime(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    lpAdsDestValue->UTCTime = lpAdsSrcValue->UTCTime;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyLargeInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_LARGE_INTEGER){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_LARGE_INTEGER;

    lpAdsDestValue->LargeInteger = lpAdsSrcValue->LargeInteger;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyProvSpecific(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PROV_SPECIFIC){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_PROV_SPECIFIC;

    dwNumBytes = lpAdsSrcValue->ProviderSpecific.dwLength;

    //
    // The target buffer should be worst-case aligned
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);

    memcpy(
        lpBuffer,
        lpAdsSrcValue->ProviderSpecific.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->ProviderSpecific.dwLength = dwNumBytes;

    lpAdsDestValue->ProviderSpecific.lpValue = lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyDNWithBinary(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;
    PADS_DN_WITH_BINARY pDNBin = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_BINARY){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_WITH_BINARY;

    //
    // Worse-case align the target buffer for the structure itself
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);


    lpAdsDestValue->pDNWithBinary = (PADS_DN_WITH_BINARY) lpBuffer;
    lpBuffer += sizeof(ADS_DN_WITH_BINARY);

    if (!lpAdsSrcValue->pDNWithBinary) {
        return(lpBuffer);
    }

    pDNBin = lpAdsSrcValue->pDNWithBinary;

    dwLength = pDNBin->dwLength;

    //
    // Copy the byte array over if applicable.
    //
    if (dwLength) {

        //
        // Worse-case align the target buffer for the binary data
        //
        lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);


        memcpy(
               lpBuffer,
               pDNBin->lpBinaryValue,
               lpAdsSrcValue->pDNWithBinary->dwLength
               );

        lpAdsDestValue->pDNWithBinary->dwLength = dwLength;

        lpAdsDestValue->pDNWithBinary->lpBinaryValue = lpBuffer;

    }

    lpBuffer += dwLength;

    //
    // Now for the string
    //
    if (pDNBin->pszDNString) {

        //
        // The target buffer has to be WCHAR (WORD) aligned
        // for the string
        //
        lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);


        dwLength = wcslen(pDNBin->pszDNString);

        wcscpy((LPWSTR) lpBuffer, pDNBin->pszDNString);

        lpAdsDestValue->pDNWithBinary->pszDNString = (LPWSTR) lpBuffer;

        //
        // For the trailing \0 of the string
        //
        dwLength++;

        lpBuffer += (dwLength * sizeof(WCHAR));
    }

    return lpBuffer;
}



LPBYTE
AdsTypeCopyDNWithString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwStrLen = 0;
    DWORD dwDNLen = 0;
    PADS_DN_WITH_STRING pDNStr = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_WITH_STRING;

    //
    // Worst-case align the target buffer for the structure
    //
    lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORST);


    lpAdsDestValue->pDNWithString = (PADS_DN_WITH_STRING) lpBuffer;
    lpBuffer += sizeof(ADS_DN_WITH_STRING);

    if (!lpAdsSrcValue->pDNWithString) {
        return(lpBuffer);
    }

    pDNStr = lpAdsSrcValue->pDNWithString;

    //
    // Copy the string over if applicable.
    //
    if (pDNStr->pszStringValue) {

        //
        // The target buffer has to be WCHAR (WORD) aligned
        //
        lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);


        dwStrLen = wcslen(pDNStr->pszStringValue);

        wcscpy((LPWSTR)lpBuffer, pDNStr->pszStringValue);

        lpAdsDestValue->pDNWithString->pszStringValue = (LPWSTR) lpBuffer;

        //
        // +1 for trailing \0
        //
        lpBuffer += (sizeof(WCHAR) * ( dwStrLen + 1));

    }

    //
    // Now for the DN String
    //
    if (pDNStr->pszDNString) {

        //
        // The target buffer has to be WCHAR (WORD) aligned
        //
        lpBuffer = (LPBYTE) ROUND_UP_POINTER(lpBuffer, ALIGN_WORD);


        dwDNLen = wcslen(pDNStr->pszDNString);

        wcscpy((LPWSTR) lpBuffer, pDNStr->pszDNString);

        lpAdsDestValue->pDNWithString->pszDNString = (LPWSTR) lpBuffer;

        //
        // For the trailing \0 of the string
        //
        dwDNLen++;

        lpBuffer += (dwDNLen * sizeof(WCHAR));
    }

    return lpBuffer;
}



LPBYTE
AdsTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        lpBuffer = AdsTypeCopyDNString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        lpBuffer = AdsTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        lpBuffer = AdsTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        lpBuffer = AdsTypeCopyPrintableString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        lpBuffer = AdsTypeCopyNumericString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_BOOLEAN:
        lpBuffer = AdsTypeCopyBoolean(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_INTEGER:
        lpBuffer = AdsTypeCopyInteger(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_OCTET_STRING:
        lpBuffer = AdsTypeCopyOctetString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_UTC_TIME:
        lpBuffer = AdsTypeCopyTime(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_LARGE_INTEGER:
        lpBuffer = AdsTypeCopyLargeInteger(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_PROV_SPECIFIC:
        lpBuffer = AdsTypeCopyProvSpecific(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        lpBuffer = AdsTypeCopySecurityDescriptor(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_DN_WITH_BINARY:
        lpBuffer = AdsTypeCopyDNWithBinary(
                       lpAdsSrcValue,
                       lpAdsDestValue,
                       lpBuffer
                       );
        break;

    case ADSTYPE_DN_WITH_STRING:
        lpBuffer = AdsTypeCopyDNWithString(
                       lpAdsSrcValue,
                       lpAdsDestValue,
                       lpBuffer
                       );
        break;

    default:

        break;
    }

    return(lpBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\odssz.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       odssz.cxx
//
//  Contents:   DSObject Size Routines
//
//  Functions:
//
//  History:    25-Feb-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"

DWORD
AdsTypeDNStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}

DWORD
AdsTypeCaseExactStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->CaseExactString) + 1) *sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}


DWORD
AdsTypeCaseIgnoreStringSize(
    PADSVALUE lpAdsSrcValue
    )

{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1) *sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}


DWORD
AdsTypePrintableStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->PrintableString) + 1) *sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}

DWORD
AdsTypeNumericStringSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(0);
    }

    //
    // strings must be WCHAR (WORD) aligned
    //
    dwSize = (wcslen(lpAdsSrcValue->NumericString) + 1)* sizeof(WCHAR) +
             (ALIGN_WORD-1);

    return(dwSize);
}



DWORD
AdsTypeBooleanSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(0);
    }

    return(0);
}


DWORD
AdsTypeIntegerSize(
    PADSVALUE lpAdsSrcValue
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeOctetStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(0);
    }

    //
    // Add bytes to the size as we need to align all the
    // OctetStrings on at least 8 byte boundaries.  We'll
    // worst-case align to be conservative for IA64.
    // ALIGN_WORST is defined in priv inc which also defines
    // the ROUND_UP macro used.
    //
    dwNumBytes = lpAdsSrcValue->OctetString.dwLength + ALIGN_WORST - 1;

    return(dwNumBytes);
}


DWORD
AdsTypeSecurityDescriptorSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NT_SECURITY_DESCRIPTOR){
        return(0);
    }

    //
    // Security Descriptors need to be DWORD aligned but we
    // provide worst case alignment as C structs have 8 bytes alignment
    // (at least on x86).
    // ALIGN_WORST defined in align.h in priv inc, which also
    // has the round up macro used.
    //
    dwNumBytes = lpAdsSrcValue->SecurityDescriptor.dwLength + ALIGN_WORST - 1;

    return(dwNumBytes);
}


DWORD
AdsTypeTimeSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeLargeIntegerSize(
    PADSVALUE lpAdsSrcValue
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_LARGE_INTEGER){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeProvSpecificSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PROV_SPECIFIC){
        return(0);
    }

    //
    // We don't know what it contains, so assume worst-case alignment
    //
    dwNumBytes =  lpAdsSrcValue->ProviderSpecific.dwLength + (ALIGN_WORST-1);

    return(dwNumBytes);
}


//
// Computes size of the data in the DNWithBinary object
//
DWORD
AdsTypeDNWithBinarySize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwStrLen = 0;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_BINARY) {
        return 0;
    }

    if (!lpAdsSrcValue->pDNWithBinary) {
        return(0);
    }

    //
    // The length is EncodedBinLen+dnlen+:+:+:+B+10 (for int len)
    //

    if (lpAdsSrcValue->pDNWithBinary->pszDNString) {
        dwStrLen = (wcslen(lpAdsSrcValue->pDNWithBinary->pszDNString)+1);

        //
        // strings must be WCHAR (WORD) aligned
        //
        dwSize += dwStrLen * sizeof(WCHAR) + (ALIGN_WORD-1);

    }

    //
    // Each byte is 2 wchars in the final string
    //
    if (lpAdsSrcValue->pDNWithBinary->dwLength) {
        dwSize += (lpAdsSrcValue->pDNWithBinary->dwLength);
        //
        // our cushion when reading from string encoded binary value
        // to byte array and one WCHAR for \0 of string
        //
        // worst-case align the binary data, since we don't know
        // how it will be accessed
        //
        dwSize += sizeof(DWORD) + sizeof(WCHAR) + (ALIGN_WORST-1);
    }

    //
    // provide worst-case alignment of the structure
    //
    dwSize += sizeof(ADS_DN_WITH_BINARY) + (ALIGN_WORST-1);
    return dwSize;
}

//
// Computes size of the data in the DNWithString object.
//
DWORD
AdsTypeDNWithStringSize(
    PADSVALUE pAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwStrLen = 0;

    if (pAdsSrcValue->dwType != ADSTYPE_DN_WITH_STRING) {
        return 0;
    }

    if (!pAdsSrcValue->pDNWithString) {
        return(0);
    }

    //
    // align the strings on WCHAR (WORD) boundaries
    // provide worst-case alignment for the structure
    //
    if (pAdsSrcValue->pDNWithString->pszDNString) {
        dwStrLen = wcslen(pAdsSrcValue->pDNWithString->pszDNString) + 1;
        dwSize += dwStrLen * sizeof(WCHAR) + (ALIGN_WORD-1);
    }

    if (pAdsSrcValue->pDNWithString->pszStringValue) {
        dwStrLen = wcslen(pAdsSrcValue->pDNWithString->pszStringValue) + 1;
        dwSize += dwStrLen * sizeof(WCHAR) + (ALIGN_WORD-1);
    }

    //
    // Now for the strcut itself.
    //

    dwSize += sizeof(ADS_DN_WITH_STRING) + (ALIGN_WORST-1);

    return dwSize;
}


DWORD
AdsTypeSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        dwSize = AdsTypeDNStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        dwSize = AdsTypeCaseExactStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        dwSize = AdsTypeCaseIgnoreStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        dwSize = AdsTypePrintableStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        dwSize = AdsTypeNumericStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_BOOLEAN:
        dwSize = AdsTypeBooleanSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_INTEGER:
        dwSize = AdsTypeIntegerSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_OCTET_STRING:
        dwSize = AdsTypeOctetStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_UTC_TIME:
        dwSize = AdsTypeTimeSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_LARGE_INTEGER:
        dwSize = AdsTypeLargeIntegerSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_PROV_SPECIFIC:
        dwSize = AdsTypeProvSpecificSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        dwSize = AdsTypeSecurityDescriptorSize(
                lpAdsSrcValue
                );
    break;

    case ADSTYPE_DN_WITH_BINARY:
        dwSize = AdsTypeDNWithBinarySize(
                     lpAdsSrcValue
                     );
        break;

    case ADSTYPE_DN_WITH_STRING:
        dwSize = AdsTypeDNWithStringSize(
                     lpAdsSrcValue
                     );
        break;

    default:
        break;
    }

    return(dwSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\parse.cxx ===
//--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  parse.cxx
//
//  Contents:  LDAP Pathname Parser
//
//    The Pathname Parser is a key component in ADs providers. It checks for
//    syntactic validity of an ADs pathname that has been passed to this
//    provider. If the syntax is valid, then an OBJECTINFO structure is
//    constructed. This OBJECTINFO structure contains a componentized version
//    of the ADs pathname for this object.
//
//    Note all that is being done is a syntax check. Rather than special-case
//    every single new nuance to pathnames, all path checking must conform to
//    the grammar rules laid out by the parser.
//
//
//
//  History:
//----------------------------------------------------------------------------

#include <stdlib.h>
#include "ldapc.hxx"

#pragma hdrstop

// Object -> PathName, Type, eos
// Object -> PathName, eos

KWDLIST KeywordList[] =
{
    { TOKEN_DOMAIN,      DOMAIN_CLASS_NAME },
    { TOKEN_USER,        USER_CLASS_NAME },
    { TOKEN_GROUP,       GROUP_CLASS_NAME },
    { TOKEN_COMPUTER,    COMPUTER_CLASS_NAME },
    { TOKEN_PRINTER,     PRINTER_CLASS_NAME },
    { TOKEN_SERVICE,     SERVICE_CLASS_NAME },
    { TOKEN_FILESERVICE, FILESERVICE_CLASS_NAME },
    { TOKEN_FILESHARE,   FILESHARE_CLASS_NAME },
    { TOKEN_SCHEMA,      SCHEMA_CLASS_NAME },
    { TOKEN_CLASS,       CLASS_CLASS_NAME },
    { TOKEN_PROPERTY,    PROPERTY_CLASS_NAME },
    { TOKEN_SYNTAX,      SYNTAX_CLASS_NAME },
    { TOKEN_LOCALITY,     LOCALITY_CLASS_NAME },
    { TOKEN_ORGANIZATION, ORGANIZATION_CLASS_NAME },
    { TOKEN_ORGANIZATIONUNIT, ORGANIZATIONUNIT_CLASS_NAME },
    { TOKEN_COUNTRY,      COUNTRY_CLASS_NAME },
    { TOKEN_ROOTDSE,     ROOTDSE_CLASS_NAME}
};


DWORD gdwKeywordListSize = sizeof(KeywordList)/sizeof(KWDLIST);

HRESULT
InitObjectInfo(
    LPWSTR pszADsPathName,
    POBJECTINFO pObjectInfo
    )
{
    DWORD dwLen = 0;
    HRESULT hr = S_OK;

    ADsAssert(pObjectInfo);
    ADsAssert(pszADsPathName);

    memset(pObjectInfo, 0x0, sizeof(OBJECTINFO));

    dwLen = wcslen(pszADsPathName) * sizeof(WCHAR) * 3;
    if( dwLen ) {
        pObjectInfo->szStrBuf = (LPWSTR) AllocADsMem(dwLen);
        pObjectInfo->szDisplayStrBuf = (LPWSTR) AllocADsMem(dwLen);

        if (!pObjectInfo->szStrBuf || !pObjectInfo->szDisplayStrBuf) {
            RRETURN(E_OUTOFMEMORY);
        }

        pObjectInfo->szStrBufPtr = pObjectInfo->szStrBuf;
        pObjectInfo->szDisplayStrBufPtr = pObjectInfo->szDisplayStrBuf;
    }

    RRETURN(hr);
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    if (pObjectInfo->szStrBuf) {
        FreeADsStr( pObjectInfo->szStrBuf );
    }
    if (pObjectInfo->szDisplayStrBuf) {
        FreeADsStr( pObjectInfo->szDisplayStrBuf );
    }
}


HRESULT
ADsObject(
    LPWSTR pszADsPathName,
    POBJECTINFO pObjectInfo
    )
{
    HRESULT hr = S_OK;

    CLexer Lexer(pszADsPathName);

    hr = InitObjectInfo(pszADsPathName, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->ObjectType = TOKEN_LDAPOBJECT;

    hr = ADsObjectParse(&Lexer, pObjectInfo);

error:

    RRETURN(hr);
}


HRESULT
GetNextToken(
    CLexer *pTokenizer,
    POBJECTINFO pObjectInfo,
    LPWSTR *ppszToken,
    LPWSTR *ppszDisplayToken,
    DWORD *pdwToken
    )
{

    HRESULT hr = S_OK;

    ADsAssert(ppszToken);
    *ppszToken = NULL;

    if (ppszDisplayToken) {
        *ppszDisplayToken = NULL;
    }

    hr = pTokenizer->GetNextToken(
             pObjectInfo->szStrBufPtr,
             pObjectInfo->szDisplayStrBufPtr,
             pdwToken
             );
    BAIL_ON_FAILURE(hr);

    *ppszToken = pObjectInfo->szStrBufPtr;

    if (ppszDisplayToken) {
        *ppszDisplayToken = pObjectInfo->szDisplayStrBufPtr;
    }

    pObjectInfo->szStrBufPtr += wcslen(pObjectInfo->szStrBufPtr) + 1;
    pObjectInfo->szDisplayStrBufPtr += wcslen(pObjectInfo->szDisplayStrBufPtr) + 1;

error:

    RRETURN (hr);


}


HRESULT
GetNextToken(
    CLexer *pTokenizer,
    POBJECTINFO pObjectInfo,
    LPWSTR *ppszToken,
    DWORD *pdwToken
    )
{
    return (GetNextToken(
                pTokenizer,
                pObjectInfo,
                ppszToken,
                NULL,
                pdwToken
                ));

}
//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <LDAPObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsObjectParse(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch ( dwToken ) {
        case TOKEN_END:
            RRETURN(S_OK);

        default:
            hr = pTokenizer->PushBackToken();
            BAIL_IF_ERROR(hr);

            hr = LDAPObject(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            break;
    }

cleanup:

    RRETURN(hr);

}



//+---------------------------------------------------------------------------
//  Function:   LDAPObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <LDAPObject> -> "\\""identifier""\" <LDAPObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
LDAPObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    LPWSTR szDisplayToken;
    DWORD dwToken, dwPort;
    HRESULT hr;
    WCHAR c = L'\0';

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    if (!_wcsicmp(szToken, L"schema")) {

        hr = pTokenizer->PushBackToken();  // push back the identifier
        BAIL_IF_ERROR(hr);

        pObjectInfo->dwServerPresent = FALSE;

        hr = PathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);

    } else if (!_wcsicmp(szToken, L"rootdse")) {

       hr = pTokenizer->PushBackToken(); // push back the identifier
       BAIL_IF_ERROR(hr);

       pObjectInfo->dwServerPresent = FALSE;

       hr = PathName(pTokenizer, pObjectInfo);
       BAIL_IF_ERROR(hr);

       hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
       BAIL_IF_ERROR(hr);

    } else if (((c = (CHAR)pTokenizer->NextChar()) == TEXT('=')) || (c == TEXT(','))  || (c == TEXT(';')))
    {
        pTokenizer->PushbackChar();  // push back =

        hr = pTokenizer->PushBackToken();  // push back the identifier
        BAIL_IF_ERROR(hr);

        pObjectInfo->dwServerPresent = FALSE;


        hr = PathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);
    }
    else
    {
        pTokenizer->PushbackChar();

        hr = AddTreeName(pObjectInfo, szToken, szDisplayToken);
        BAIL_IF_ERROR(hr);

        pObjectInfo->dwServerPresent = TRUE;

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        //
        // Check if we have an explicit port number
        //

        if ( dwToken == TOKEN_COLON) {

            //
            // Get the port number and set it in the ObjectInfo structure
            //

            hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
            BAIL_IF_ERROR(hr);

            if (dwToken == TOKEN_END) {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

            dwPort = _wtoi(szToken);
            if (dwPort == 0) {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

            AddPortNumber(pObjectInfo, dwPort);

            hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
            BAIL_IF_ERROR(hr);

        }

        //
        // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
        //

        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }

        if (dwToken == TOKEN_FSLASH) {

            hr = PathName(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);

            hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
            BAIL_IF_ERROR(hr);

        } else if ( dwToken == TOKEN_COMMA || dwToken == TOKEN_SEMICOLON ) {
            // do nothing here
        } else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }
    }

    switch (dwToken) {
    case TOKEN_END:
        RRETURN(S_OK);

    default:
        RRETURN(E_ADS_BAD_PATHNAME);

    }
cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    DWORD dwToken;
    HRESULT hr;
    DWORD dwPort;

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);
        hr = AddNamespaceName(pObjectInfo, szToken);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }
    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);
        hr = AddNamespaceName(pObjectInfo, szToken);

        hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Add the default port number depending on the namespace.
    // If an explicit port number is specified, that will override
    //

    if ( _wcsicmp( pObjectInfo->NamespaceName, szGCNamespaceName) == 0 ) {
        dwPort = (DWORD) USE_DEFAULT_GC_PORT;
    }
    else {
        dwPort = (DWORD) USE_DEFAULT_LDAP_PORT;
    }

    AddPortNumber(pObjectInfo, dwPort);

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component
HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    DWORD dwToken;
    HRESULT hr;

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    LPWSTR szToken = NULL;
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (!pObjectInfo->dwPathType) {

        if (dwToken == TOKEN_FSLASH) {

            pObjectInfo->dwPathType = PATHTYPE_WINDOWS;
            RRETURN (PathName(pTokenizer, pObjectInfo));
        }else if (dwToken == TOKEN_COMMA || dwToken == TOKEN_SEMICOLON){

            pObjectInfo->dwPathType = PATHTYPE_X500;
            RRETURN (PathName(pTokenizer, pObjectInfo));
        }else{
            hr = pTokenizer->PushBackToken();
            RRETURN (S_OK);
        }
    }else if (pObjectInfo->dwPathType == PATHTYPE_WINDOWS){

        if (dwToken == TOKEN_FSLASH) {
                RRETURN (PathName(pTokenizer, pObjectInfo));
        }else{
            hr = pTokenizer->PushBackToken();
            RRETURN (S_OK);
        }
    }else if (pObjectInfo->dwPathType == PATHTYPE_X500){

        if (dwToken == TOKEN_COMMA || dwToken == TOKEN_SEMICOLON) {
                RRETURN (PathName(pTokenizer, pObjectInfo));
        }else{
            hr = pTokenizer->PushBackToken();
            RRETURN (S_OK);
        }
    }else {

        //
        // We should never hit this point
        //

        hr = E_FAIL;
    }

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szValue = NULL;
    LPWSTR szDisplayValue = NULL;
    LPWSTR szEqual = NULL;
    LPWSTR szComponent = NULL;
    LPWSTR szDisplayComponent = NULL;
    DWORD dwToken;
    HRESULT hr = S_OK;

    hr = GetNextToken(pTokenizer, pObjectInfo, &szComponent, &szDisplayComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        BAIL_IF_ERROR( hr = E_ADS_BAD_PATHNAME);
    }

    hr = GetNextToken(pTokenizer, pObjectInfo, &szEqual, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_EQUAL) {

        hr = GetNextToken(pTokenizer, pObjectInfo, &szValue, &szDisplayValue, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            BAIL_IF_ERROR(hr = E_ADS_BAD_PATHNAME);
        }

        hr = AddComponent(pObjectInfo, szComponent, szValue, szDisplayComponent, szDisplayValue);
        BAIL_IF_ERROR(hr);

    }else {

        hr = AddComponent(pObjectInfo, szComponent, NULL, szDisplayComponent, NULL);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->PushBackToken();
        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    LPWSTR szToken = NULL;
    DWORD dwToken;
    HRESULT hr;

    hr = GetNextToken(pTokenizer, pObjectInfo, &szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            BAIL_IF_ERROR(hr);
        }
        pObjectInfo->ObjectClass = szToken;
    }

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
__declspec(dllexport)
CLexer::CLexer(LPTSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE),
                _bFSlashDisabled(FALSE),
                _bExclaimDisabled(FALSE) 
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
__declspec(dllexport)
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPTSTR szToken, LPTSTR szDisplayToken, LPDWORD pdwToken)
{
    TCHAR c, cnext;
    DWORD state = 0;
    LPTSTR pch = szToken;
    LPTSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    if (!szToken) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();

        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            switch (c) {

            case TEXT('"') :
                //
                // Quoting;
                //

                fQuotingOn = TRUE;

                state = 1;
                break;

            case TEXT('\\') :
                //
                // Escaping; Ignore the '\' in the token and check to make
                // sure that the next character exists
                //
                cnext = NextChar();
                if (cnext == TEXT('/')) {
                    pch--;
                }
                PushbackChar();

                fEscapeOn = TRUE;

                state = 1;
                break;

            case TEXT('/') :
                if (!_bFSlashDisabled) {
                    *pdwToken = TOKEN_FSLASH;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }
                else {
                    state = 1;
                }
                break;
            case TEXT(',') :
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(';') :
                *pdwToken = TOKEN_SEMICOLON;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('=') :
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT(':') :
                if (!_bAtDisabled && !_bExclaimDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
                break;

            case TEXT('\0') :
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
                break;

            case TEXT('@') :

                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
                break;

            case TEXT('!') :

                if (!_bAtDisabled && !_bExclaimDisabled) {
                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
                break;

            case TEXT(' ') :
                pch--;
                _dwLastTokenLength--;
                break;

            default:
                state = 1;
                break;

            }
            break;

        case 1:

            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_ADS_BAD_PATHNAME);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                } 
                else if (c == TEXT('\\')) {
                    //
                    // This is a special case, where a \ is 
                    // being passed in to escape something inside
                    // quotes.
                    //
                    fEscapeOn = TRUE;
                    _dwLastTokenLength++;

                    *pch++ = c;

                    cnext = NextChar();
                    if (cnext == '/') {
                        pch--;
                    }
                    PushbackChar();
                    state = 1;
                    break;
                }
                *pch++ = c;
                _dwLastTokenLength++;
                break;
            }
            //
            // Ok to put a switch here as all have breaks above.
            //
            switch (c) {
            case TEXT('\\') :

                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                *pch++ = c;

                cnext = NextChar();
                if (cnext == '/') {
                    pch--;
                }
                PushbackChar();

                break;

            case TEXT('"') :
                fQuotingOn = TRUE;
                *pch++ = c;
                _dwLastTokenLength++;
                break;

            case TEXT('\0'):
            case TEXT(',') :
            case TEXT('=') :
            case TEXT(';') :
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);
                break;

            case TEXT('/') :
                if (!_bFSlashDisabled) {
                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }
                else {
                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                }
                break;
            case TEXT('!') :
            case TEXT(':') :
                if (!_bAtDisabled && !_bExclaimDisabled) {

                    PushbackChar();
                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);

                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }
            case TEXT('@') :          
                if (!_bAtDisabled) {

                    PushbackChar();
                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);

                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }

            default :
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            break;
        default:
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}


__declspec(dllexport)
HRESULT
CLexer::GetNextToken(LPTSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
TCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == TEXT('\0')) {
        _dwEndofString = TRUE;
        return(TEXT('\0'));
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPTSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < gdwKeywordListSize; i++) {
        if (!_tcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo,
             LPTSTR szComponent,
             LPTSTR szValue,
             LPTSTR szDisplayComponent,
             LPTSTR szDisplayValue
             )
{
    if (!szComponent || !*szComponent || !szDisplayComponent || !*szDisplayComponent) {
        RRETURN(E_FAIL);
    }

    if ( pObjectInfo->NumComponents < MAXCOMPONENTS ) {

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                    szComponent;

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                    szValue;

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szComponent =
                    szDisplayComponent;

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szValue =
                    szDisplayValue;

        pObjectInfo->NumComponents++;

        RRETURN(S_OK);

    } else {

        RRETURN(E_ADS_BAD_PATHNAME);
    }

}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPTSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }


    if (_tcscmp(szToken, szLDAPNamespaceName) == 0 ||
        _tcscmp(szToken, szGCNamespaceName) == 0) {

        //
        // szProviderName is the provider name for both LDAP and GC namespaces
        //

        pObjectInfo->ProviderName = szProviderName;
    }
    else {

        //
        // Not one of the namespaces we handle, just copy
        //

        pObjectInfo->ProviderName = szToken;
    }

    RRETURN(S_OK);
}

HRESULT
AddNamespaceName(POBJECTINFO pObjectInfo, LPTSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->NamespaceName = szToken;

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPTSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken || !szDisplayToken || !*szDisplayToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = szToken;
    pObjectInfo->DisplayTreeName = szDisplayToken;

    RRETURN(S_OK);
}


HRESULT
AddPortNumber(POBJECTINFO pObjectInfo, DWORD dwPort)
{
    pObjectInfo->PortNumber = dwPort;

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}

void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}

void
CLexer::SetFSlashDisabler(
    BOOL bFlag
    )
{
    _bFSlashDisabled = bFlag;
}

BOOL
CLexer::GetFSlashDisabler()
{
    return(_bFSlashDisabled);
}

void
CLexer::SetExclaimnationDisabler(
    BOOL bFlag
    )
{
    _bExclaimDisabled = bFlag;
}

BOOL
CLexer::GetExclaimnationDisabler()
{
    return(_bExclaimDisabled);
}

HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;

    BOOL        fQuoteMode = FALSE; // TRUE means we're processing between
                                    // quotation marks
    BOOL        fEscaped = FALSE;   // TRUE means next one char to be 
                                    // processed should be treated as literal

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;

    //
    // Parsing Algorithm:
    //
    // If this char follows an unescaped backslash:
    //      Treat as literal, treat next char regularly (set fEscaped = FALSE)
    // Else, if we're between quotation marks:
    //      If we see a quotation mark, leave quote mode
    //      Else, treat as literal
    // Else, if we're not between quote marks, and we see a quote mark:
    //      Enter quote mode
    // Else, if we see a backslash (and we're not already in escape or quote
    // mode):
    //      Treat next char as literal (set fEscaped = TRUE)
    // Else, if we see a forward-slash (and we're not in escape or quote mode):
    //      We need to escape it by prefixing with a backslash
    // Else:
    //      Do nothing, just a plain old character
    // Go on to next character, and repeat
    //
    // Backslashes inside quotation marks are always treated as literals,
    // since that is the definition of being inside quotation marks
    //
    while (*pch) {
        if (fEscaped) {
            fEscaped = FALSE;
        }
        else if (fQuoteMode) {
            if (*pch == L'"') {
                fQuoteMode = FALSE;
            }
        }
        else if (*pch == L'"') {
            fQuoteMode = TRUE;
        }
        else if (*pch == L'\\') {
            fEscaped = TRUE;
        }
        else if (*pch == L'/') {
            //
            // include space for the escape char
            // we'll need to add
            //
            len++;
        }

        len++;

        pch++;
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName;
    pszDisplayCh = pszDisplay;

    fEscaped = FALSE;
    fQuoteMode = FALSE;

    while (*pch) {
        if (fEscaped) {
            fEscaped = FALSE;
        }
        else if (fQuoteMode) {
            if (*pch == L'"') {
                fQuoteMode = FALSE;
            }
        }
        else if (*pch == L'"') {
            fQuoteMode = TRUE;
        }
        else if (*pch == L'\\') {
            fEscaped = TRUE;
        }
        else if (*pch == L'/') {
            //
            // unescaped forward slash needs to get escaped
            //
            *pszDisplayCh++ = L'\\';
        }

        *pszDisplayCh++ = *pch;

        pch++;
    }
    
    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}

//
// Convert an ADs path to LDAP path
//

HRESULT
GetLDAPTypeName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{
    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = NULL;
    LPWSTR pszDisplayCh = NULL;
    LPWSTR pszDisplay = NULL;    
    

    if (!ppszDisplayName ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (E_ADS_BAD_PATHNAME);
    }

    pch = szName;

    //
    // Parsing algorithm
    // if this character is an escaped back slash
    //    if next character is a forward slash (we know this is a kind of ADsPath)
    //        we will remove the back slash
    // accepts the current character
    // goes on to process the next character
    //

    while (*pch) {
    	if(*pch == L'\\') {

    		pch++;
    		//
    		// If next character is /, we need to remove the escape character
    		//
    		if(*pch != L'/') {
    			len++;
    		}
    		    		
    	}

    	if(*pch) {
    		len++;
            pch++;		
    	}
    	
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName;
    pszDisplayCh = pszDisplay;

    

    while (*pch) {
    	if(*pch == L'\\') {
    		//
    		// If next character is /, we need to remove the escape character
    		//
    		pch++;
    		
    		if(*pch != L'/') {
    			*pszDisplayCh++ = L'\\';
    		}
    		   		
    	}    	

        if(*pch) {
        	*pszDisplayCh++ = *pch;
            pch++;		
        }
    	
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;    

error:    	

    RRETURN(hr);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\pathmgmt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pathmgmt.cxx
//
//  Contents:
//
//  Functions:
//
//  History:    25-April-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "ldapc.hxx"
#pragma hdrstop


#define STRING_LENGTH(p) ( p ? wcslen(p) : 0)

HRESULT
BuildADsParentPathFromObjectInfo2(
    POBJECTINFO pObjectInfo,
    LPWSTR *ppszParent,
    LPWSTR *ppszCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR pszComponent = NULL, pszValue = NULL;


    hr = ComputeAllocateParentCommonNameSize(pObjectInfo, ppszParent, ppszCommonName);
    BAIL_ON_FAILURE(hr);


    hr = BuildADsParentPathFromObjectInfo(
                    pObjectInfo,
                    *ppszParent,
                    *ppszCommonName
                    );
    BAIL_ON_FAILURE(hr);



    RRETURN(hr);


error:
    if (*ppszParent) {

        FreeADsMem(*ppszParent);
    }

    if (*ppszCommonName) {

        FreeADsMem(*ppszCommonName);
    }


    RRETURN(hr);
}


HRESULT
BuildADsParentPath(
    LPWSTR szBuffer,
    LPWSTR *ppszParent,
    LPWSTR *ppszCommonName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    HRESULT hr = S_OK;
    LPWSTR pszCommonName = NULL;
    LPWSTR pszParent = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(szBuffer, pObjectInfo);
    BAIL_ON_FAILURE(hr);


    // The length of pszParent or pszCommon is definitely less than the
    // length of the total buffer.

    pszParent = (LPWSTR) AllocADsMem( (_tcslen(szBuffer) + 1) * sizeof(TCHAR));

    if ( pszParent == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pszCommonName = (LPWSTR) AllocADsMem( (_tcslen(szBuffer) + 1) * sizeof(TCHAR));

    if ( pszCommonName == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildADsParentPathFromObjectInfo(
                 pObjectInfo,
                 pszParent,
                 pszCommonName
                );
    BAIL_ON_FAILURE(hr);

    *ppszParent = pszParent;
    *ppszCommonName = pszCommonName;

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (pszCommonName) {
        FreeADsMem(pszCommonName);
    }

    if (pszParent) {
        FreeADsMem(pszParent);
    }

    FreeObjectInfo( &ObjectInfo );


    RRETURN(hr);
}


HRESULT
BuildADsParentPathFromObjectInfo(
    POBJECTINFO pObjectInfo,
    LPWSTR pszParent,
    LPWSTR pszCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR pszComponent = NULL, pszValue = NULL;

    dwNumComponents = pObjectInfo->NumComponents;

    if (!dwNumComponents && !pObjectInfo->DisplayTreeName) {

        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(pszParent,L"ADs:");
        wsprintf(pszCommonName, L"%s:", pObjectInfo->NamespaceName);

        hr = S_OK;

    } else if (!dwNumComponents && pObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @NDS! object


        wsprintf(pszParent, L"%s:", pObjectInfo->NamespaceName);

        //
        // And the common name is the TreeName (and port)
        //

        if ( IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {

            wsprintf(pszCommonName,L"%s:%d", pObjectInfo->TreeName, pObjectInfo->PortNumber);
        }
        else {

            wsprintf(pszCommonName,L"%s", pObjectInfo->TreeName);
        }

        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        switch (pObjectInfo->dwServerPresent) {

        case TRUE:

            if ( IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {

                wsprintf(
                     pszParent, L"%s://%s:%d",
                     pObjectInfo->NamespaceName,
                     pObjectInfo->DisplayTreeName,
                     pObjectInfo->PortNumber
                     );
            }
            else {

                wsprintf(
                     pszParent, L"%s://%s",
                     pObjectInfo->NamespaceName,
                     pObjectInfo->DisplayTreeName
                     );
            }
            break;


        case FALSE:
                  wsprintf(
                       pszParent, L"%s:",
                       pObjectInfo->NamespaceName
                       );
                  break;

        }


        switch (pObjectInfo->dwPathType) {

        case PATHTYPE_X500:
        default: // where we cannot make a determination whether its X500 or Windows style

            if (dwNumComponents > 1) {

               if (pObjectInfo->dwServerPresent) {
                   wcscat(pszParent, L"/");
               }else {
                  wcscat(pszParent,L"//");
               }

                for (i = 1; i < dwNumComponents; i++) {

                    AppendComponent(pszParent, &(pObjectInfo->DisplayComponentArray[i]));

                    if (i < (dwNumComponents - 1)) {
                        wcscat(pszParent, L",");
                    }
                }
            }

            //
            // And the common name is the last component
            //

            pszComponent =  pObjectInfo->DisplayComponentArray[0].szComponent;
            pszValue = pObjectInfo->DisplayComponentArray[0].szValue;


            if (pszComponent && pszValue) {

                wsprintf(pszCommonName, L"%s=%s",pszComponent, pszValue);

            }else if (pszComponent){

                wsprintf(pszCommonName, L"%s", pszComponent);

            }else {
                //
                // Error - we should never hit this case!!
                //

            }
            hr = S_OK;
            break;




        case PATHTYPE_WINDOWS:

             switch (pObjectInfo->dwServerPresent) {
             case FALSE:

                if (dwNumComponents > 1) {

                   wcscat(pszParent,L"//");

                   for (i = 0; i < dwNumComponents - 1; i++) {
                      if (i ) {
                         wcscat(pszParent, L"/");
                      }

                      AppendComponent(pszParent, &(pObjectInfo->DisplayComponentArray[i]));

                   }

                }
                break;


             case TRUE:
                for (i = 0; i < dwNumComponents - 1; i++) {


                    wcscat(pszParent, L"/");

                    AppendComponent(pszParent, &(pObjectInfo->DisplayComponentArray[i]));

                }
                break;

             }

            //
            // And the common name is the last component
            //

            pszComponent =  pObjectInfo->DisplayComponentArray[dwNumComponents - 1].szComponent;
            pszValue = pObjectInfo->DisplayComponentArray[dwNumComponents - 1].szValue;


            if (pszComponent && pszValue) {

                wsprintf(pszCommonName, L"%s=%s",pszComponent, pszValue);

            }else if (pszComponent){

                wsprintf(pszCommonName, L"%s", pszComponent);

            }else {
                //
                // Error - we should never hit this case!!
                //

            }
            break;


        }

    }

    RRETURN(hr);
}

HRESULT
AppendComponent(
    LPWSTR pszADsPathName,
    PCOMPONENT pComponent
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszComponent = NULL, pszValue = NULL;

    pszComponent =  pComponent->szComponent;
    pszValue = pComponent->szValue;


    if (pszComponent && pszValue) {

        wcscat(
            pszADsPathName,
            pComponent->szComponent
            );
        wcscat(pszADsPathName,L"=");
        wcscat(
            pszADsPathName,
            pComponent->szValue
            );
    }else if (pszComponent){

        wcscat(
            pszADsPathName,
            pComponent->szComponent
            );

    }else {
        //
        // Error - we should never hit this case!!
        //

    }

    RRETURN(S_OK);
}



HRESULT
ComputeAllocateParentCommonNameSize(
    POBJECTINFO pObjectInfo,
    LPWSTR * ppszParent,
    LPWSTR * ppszCommonName
    )
{

    HRESULT hr = S_OK;
    LPWSTR pszParent = NULL;
    LPWSTR pszCommonName = NULL;
    DWORD dwPathSz = 0;
    WCHAR szPort[32];
    DWORD i = 0;


    //
    // the ADsPath of the Parent is atleast as long as the standard
    // pathname
    //

    //
    // the CommonName is atleast as long as the parent name
    //

    dwPathSz += STRING_LENGTH(pObjectInfo->NamespaceName);
    dwPathSz += STRING_LENGTH(pObjectInfo->ProviderName);
    dwPathSz += 2;
    dwPathSz += STRING_LENGTH(pObjectInfo->DisplayTreeName);

    //
    // If an explicit port has been specified
    //

    if ( IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
        wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
        dwPathSz += wcslen(szPort);
    }

    dwPathSz += 1;

    for (i = 0; i < pObjectInfo->NumComponents; i++) {

        dwPathSz += STRING_LENGTH(pObjectInfo->DisplayComponentArray[i].szComponent);
        dwPathSz += 1;
        dwPathSz += STRING_LENGTH(pObjectInfo->DisplayComponentArray[i].szValue);
        dwPathSz += 1;
    }

    dwPathSz += 1;

    pszCommonName = (LPWSTR)AllocADsMem((dwPathSz)*sizeof(WCHAR));
    if (!pszCommonName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    pszParent = (LPWSTR)AllocADsMem((dwPathSz)*sizeof(WCHAR));
    if (!pszParent) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *ppszCommonName = pszCommonName;

    *ppszParent  = pszParent;

    RRETURN(hr);


error:

    if (pszCommonName ) {
        FreeADsMem(pszCommonName);
    }

    if (pszParent) {
        FreeADsMem(pszParent);
    }


    RRETURN(hr);


}

HRESULT
BuildADsPathFromParent(
    LPWSTR Parent,
    LPWSTR Name,
    LPWSTR *ppszADsPath
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pParentObjectInfo = &ObjectInfo;
    HRESULT hr = S_OK;
    LPWSTR pszCommonName = NULL;
    LPWSTR pszADsPath  = NULL;

    memset(pParentObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(Parent, pParentObjectInfo);
    BAIL_ON_FAILURE(hr);

    // The length of the pszADsPath is the total path + name + 1;

    //
    // The length of pszParent or pszCommon is definitely less than the
    // length of the total buffer.
    //
    // The Name part may be expanded to include escaping characters. In
    // the worst case, the number of characters will double. Extra 2+1 is for
    // the "//" and a NULL
    //

    pszADsPath = (LPWSTR) AllocADsMem( (_tcslen(Parent) + (_tcslen(Name)*2) +  2 + 1) * sizeof(TCHAR));

    if (!pszADsPath) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildADsPathFromParentObjectInfo(
                 pParentObjectInfo,
                 Name,
                 pszADsPath
                );
    BAIL_ON_FAILURE(hr);

    *ppszADsPath = pszADsPath;


cleanup:

    if (pParentObjectInfo) {

        FreeObjectInfo( pParentObjectInfo );
    }


    RRETURN(hr);

error:

    if (pszADsPath) {
        FreeADsMem(pszADsPath);
    }

    goto cleanup;
}



HRESULT
BuildADsPathFromParentObjectInfo(
    POBJECTINFO pParentObjectInfo,
    LPWSTR pszName,
    LPWSTR pszADsPath
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName = NULL;

    //
    // Get the display name for the name; The display name will have the proper
    // escaping for characters that have special meaning in an ADsPath like
    // '/' etc.
    //
    hr = GetDisplayName(
             pszName,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pParentObjectInfo->NumComponents;

    if (!dwNumComponents && !pParentObjectInfo->DisplayTreeName) {

        //
        // Should never happen --- ADs is the root of the tree,
        // and has no parent
        //
        ADsAssert(_wcsicmp(pszDisplayName, L"ADs:") != 0);

        if (!_wcsicmp(pParentObjectInfo->NamespaceName, L"ADs")) {

            //
            // In this one particular case we take in LDAP: as the Name
            // or GC: as the name
            //

            //
            // Do not add another : - so bogus!! Krishna
            //



            wsprintf(pszADsPath, L"%s", pszDisplayName);
        }else {

            //
            // There are no CNs in this pathname and
            // no tree name specified. This is the
            // namespace object

            //
            // Its pszName is a TreeName and we will concatenate
            // the treename with a slash slash
            //

            wsprintf(pszADsPath,
                     L"%s://%s",
                     pParentObjectInfo->NamespaceName,
                     pszDisplayName
                     );

        }

        hr = S_OK;

    } else if (!dwNumComponents && pParentObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified.
        //

        if (IS_EXPLICIT_PORT(pParentObjectInfo->PortNumber) ) {

            wsprintf(
                pszADsPath,
                L"%s://%s:%d/%s",
                pParentObjectInfo->NamespaceName,
                pParentObjectInfo->DisplayTreeName,
                pParentObjectInfo->PortNumber,
                pszDisplayName
                );
        }
        else {

            wsprintf(
                pszADsPath,
                L"%s://%s/%s",
                pParentObjectInfo->NamespaceName,
                pParentObjectInfo->DisplayTreeName,
                pszDisplayName
                );
        }

        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //
        switch (pParentObjectInfo->dwServerPresent) {
        case TRUE:

            if ( IS_EXPLICIT_PORT(pParentObjectInfo->PortNumber) ) {

                wsprintf(
                   pszADsPath, L"%s://%s:%d",
                   pParentObjectInfo->NamespaceName,
                   pParentObjectInfo->DisplayTreeName,
                   pParentObjectInfo->PortNumber
                   );
            }
            else {

                wsprintf(
                   pszADsPath, L"%s://%s",
                   pParentObjectInfo->NamespaceName,
                   pParentObjectInfo->DisplayTreeName
                   );
            }
            break;

        case FALSE:
           wsprintf(
               pszADsPath, L"%s://",
               pParentObjectInfo->NamespaceName
               );
        }
        switch (pParentObjectInfo->dwPathType) {
        case PATHTYPE_WINDOWS:

            switch (pParentObjectInfo->dwServerPresent) {
            case TRUE:
               for (i = 0; i < dwNumComponents; i++) {

                   wcscat(pszADsPath, L"/");

                   AppendComponent(pszADsPath, &(pParentObjectInfo->DisplayComponentArray[i]));

               }
               wcscat(pszADsPath, L"/");
               wcscat(pszADsPath, pszDisplayName);

               hr = S_OK;
               break;

            case FALSE:
                for (i = 0; i < dwNumComponents; i++) {

                   if (i ) {
                       wcscat(pszADsPath, L"/");
                   }

                    AppendComponent(pszADsPath, &(pParentObjectInfo->DisplayComponentArray[i]));

                }
                wcscat(pszADsPath, L"/");
                wcscat(pszADsPath, pszDisplayName);

                hr = S_OK;
                break;
            }
            break;

        case PATHTYPE_X500:
        default:

           switch (pParentObjectInfo->dwServerPresent) {
           case TRUE:
              wcscat(pszADsPath, L"/");
              break;

           case FALSE:
              break;
           }

            wcscat(pszADsPath, pszDisplayName);
            wcscat(pszADsPath, L",");

            for (i = 0; i < dwNumComponents; i++) {

                AppendComponent(pszADsPath, &(pParentObjectInfo->DisplayComponentArray[i]));

                if (i < (dwNumComponents - 1)) {
                    wcscat(pszADsPath, L",");
                }
            }
            hr = S_OK;
            break;

        }

    }

error:

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);

}

HRESULT
BuildLDAPPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR *pszLDAPPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR szLDAPPathName = NULL;

    *pszLDAPPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(szADsPathName, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    //
    // Assumption LDAPPath is always less than the ADsPath
    //

    szLDAPPathName = AllocADsStr(szADsPathName);
    if (!szLDAPPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!pObjectInfo->TreeName) {

        //
        // At the very minimum, we need a treename
        //

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }else if (pObjectInfo->TreeName && !dwNumComponents){

        _tcscpy(szLDAPPathName, TEXT("\\\\"));
        _tcscat(szLDAPPathName, pObjectInfo->TreeName);

    }else if (pObjectInfo->TreeName && dwNumComponents){

        _tcscpy(szLDAPPathName, TEXT("\\\\"));
        _tcscat(szLDAPPathName, pObjectInfo->TreeName);
        _tcscat(szLDAPPathName, TEXT("\\"));

        switch (pObjectInfo->dwPathType) {

        case PATHTYPE_X500:
        default:
            for (i = 0; i < dwNumComponents; i++) {

                AppendComponent(
                    szLDAPPathName,
                     &(pObjectInfo->ComponentArray[i])
                    );

                if (i < (dwNumComponents - 1)){
                    _tcscat(szLDAPPathName, TEXT(","));
                }
            }
            break;


        case PATHTYPE_WINDOWS:
            for (i = dwNumComponents; i >  0; i--) {

                AppendComponent(
                    szLDAPPathName,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

                if ((i - 1) > 0){
                    _tcscat(szLDAPPathName, TEXT(","));
                }
            }
            break;

        }

    }

    *pszLDAPPathName = szLDAPPathName;

error:

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}

HRESULT
BuildADsPathFromLDAPPath(
    LPWSTR szADsPathContext,
    LPWSTR szTargetLdapDN,
    LPWSTR * ppszADsPathName
    )
{
    LPWSTR pszADsPathName = NULL;
    PKEYDATA pKeyData = NULL;
    DWORD dwCount = 0, dwLen = 0;
    DWORD i = 0;
    int cHostNameLen;
    HRESULT hr;
    LPWSTR pszHostName = NULL, pszTemp = NULL;
    LPWSTR pszLDAPServer = NULL;
    LPWSTR pszLDAPDn = NULL;
    WCHAR szPort[32];
    DWORD dwPortNumber = 0;

    OBJECTINFO ObjectInfo, ObjectInfo2;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    POBJECTINFO pObjectInfo2 = &ObjectInfo2;

    LPWSTR pszDisplayDN = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    memset(pObjectInfo2, 0, sizeof(OBJECTINFO));

    if (!szADsPathContext || !szTargetLdapDN) {
        RRETURN(E_FAIL);
    }

    hr = GetDisplayName(
             szTargetLdapDN,
             &pszDisplayDN
             );
    BAIL_ON_FAILURE(hr);

    if (!pszDisplayDN) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    *ppszADsPathName = NULL;

    hr = ADsObject(szADsPathContext, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
                  szADsPathContext,
                  &pszLDAPServer,
                  &pszLDAPDn,
                  &dwPortNumber
                  );
    BAIL_ON_FAILURE(hr);

    dwLen = STRING_LENGTH(pObjectInfo->NamespaceName) +
            STRING_LENGTH(pszLDAPServer) +
            STRING_LENGTH(pszDisplayDN) +
            STRING_LENGTH(L"://") +
            STRING_LENGTH(L"/") +
            1;

    if (IS_EXPLICIT_PORT(dwPortNumber) ) {
        wsprintf(szPort, L":%d", dwPortNumber);
        dwLen += wcslen(szPort);
    }

    pszADsPathName = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );
    pszTemp = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );

    if(!pszADsPathName) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    switch (pObjectInfo->dwPathType) {

    case PATHTYPE_WINDOWS:

        //
        // Simplistic way to do this is to create the X500 based name and then
        // reparse it to generate the Windows style name
        //

        switch (pObjectInfo->dwServerPresent) {
        case TRUE:

            wsprintf(pszADsPathName,L"%s://", pObjectInfo->NamespaceName);
            wcscat(pszADsPathName, pszLDAPServer);
            if (IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
                wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
                wcscat(pszADsPathName, szPort);
            }
            wcscat(pszADsPathName, L"/");
            wcscpy(pszTemp, pszADsPathName);

            wcscat(pszADsPathName, pszDisplayDN);
            break;

        case FALSE:
            wsprintf(pszADsPathName,L"%s://", pObjectInfo->NamespaceName);
            wcscpy(pszTemp, pszADsPathName);

            wcscat(pszADsPathName, pszDisplayDN);
            break;
        }

        hr = ADsObject(pszADsPathName, pObjectInfo2);
        BAIL_ON_FAILURE(hr);


        wcscpy (pszADsPathName, pszTemp);
        for (i = pObjectInfo2->NumComponents; i >  0; i--) {

            AppendComponent(
                pszADsPathName,
                &(pObjectInfo2->DisplayComponentArray[i-1])
                );

            if ((i - 1) > 0){
                _tcscat(pszADsPathName, TEXT("/"));
            }
        }
        break;


    case PATHTYPE_X500:
    default:

        switch (pObjectInfo->dwServerPresent) {
        case TRUE:
            wsprintf(pszADsPathName,L"%s://", pObjectInfo->NamespaceName);
            wcscat(pszADsPathName, pszLDAPServer);

            if (IS_EXPLICIT_PORT(pObjectInfo->PortNumber) ) {
                wsprintf(szPort, L":%d", pObjectInfo->PortNumber);
                wcscat(pszADsPathName, szPort);
            }

            wcscat(pszADsPathName, L"/");
            wcscat(pszADsPathName, pszDisplayDN);
            break;

        case FALSE:
            wsprintf(pszADsPathName,L"%s://", pObjectInfo->NamespaceName);
            wcscat(pszADsPathName, pszDisplayDN);
            break;
        }

        break;

    }

    *ppszADsPathName = pszADsPathName;

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    if (pObjectInfo2) {
        FreeObjectInfo(pObjectInfo2);
    }

    if (pszTemp) {
        FreeADsMem(pszTemp);
    }

    if (pszLDAPServer) {
       FreeADsStr(pszLDAPServer);
    }

    if (pszLDAPDn) {
       FreeADsStr(pszLDAPDn);
    }

    if (pszDisplayDN) {
        FreeADsMem(pszDisplayDN);
    }

    RRETURN(hr);
}



PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData,
    WCHAR ch
    )
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;
    WCHAR szTokenList[MAX_PATH];


    if (!psz || !*psz)
        return NULL;

    _stprintf(szTokenList, TEXT("%c"), ch);

    cTokens=1;

    // Scan through the string looking for commas,
    // ensuring that each is followed by a non-NULL character:

    while ((psz = wcschr(psz, ch)) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +
         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocADsMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    // Then copy the key data buffer there:

    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;


    // Remember, wcstok has the side effect of replacing the delimiter
    // by NULL, which is precisely what we want:

    psz = wcstok (pDest, szTokenList);

    while (psz) {

        *ppToken++ = psz;
        psz = wcstok (NULL, szTokenList);
    }

    pResult->cTokens = cTokens;

    return( pResult );
}



HRESULT
BuildLDAPPathFromADsPath2(
    LPWSTR szADsPathName,
    LPWSTR *pszLDAPServer,
    LPWSTR *pszLDAPDn,
    DWORD * pdwPort
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr = S_OK;
    LPWSTR szLDAPServer = NULL;
    LPWSTR szLDAPDn = NULL;
    DWORD dwPortNumber = 0;

    *pszLDAPServer = NULL;
    *pszLDAPDn = NULL;
    *pdwPort = 0;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(szADsPathName, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwPortNumber = pObjectInfo->PortNumber;


    dwNumComponents = pObjectInfo->NumComponents;

    //
    // Assumption LDAPPath is always less than the ADsPath
    //

    if (!pObjectInfo->TreeName && !dwNumComponents) {

        //
        // At the very minimum, we need a treename
        //

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (pObjectInfo->TreeName){

       szLDAPServer = (LPWSTR)AllocADsMem((wcslen(szADsPathName) +1)*sizeof(WCHAR));
       if (!szLDAPServer) {
           hr = E_OUTOFMEMORY;
           BAIL_ON_FAILURE(hr);
       }

        _tcscat(szLDAPServer, pObjectInfo->TreeName);

    }

    if (dwNumComponents){

       szLDAPDn = (LPWSTR)AllocADsMem((wcslen(szADsPathName) +1)*sizeof(WCHAR));

       if (!szLDAPDn) {
          hr = E_OUTOFMEMORY;
          BAIL_ON_FAILURE(hr);
       }

        switch (pObjectInfo->dwPathType) {

        case PATHTYPE_X500:
        default:
            for (i = 0; i < dwNumComponents; i++) {

                AppendComponent(
                    szLDAPDn,
                     &(pObjectInfo->ComponentArray[i])
                    );

                if (i < (dwNumComponents - 1)){
                    _tcscat(szLDAPDn, TEXT(","));
                }
            }
            break;


        case PATHTYPE_WINDOWS:
            for (i = dwNumComponents; i >  0; i--) {

                AppendComponent(
                    szLDAPDn,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

                if ((i - 1) > 0){
                    _tcscat(szLDAPDn, TEXT(","));
                }
            }
            break;

        }

    }

    if (szLDAPServer  && *szLDAPServer) {
       *pszLDAPServer = szLDAPServer;
    }

   if (szLDAPDn && *szLDAPDn) {
       *pszLDAPDn = szLDAPDn;
   }

   *pdwPort =  dwPortNumber;

error:

    if (szLDAPServer  && (*szLDAPServer == NULL)) {
       FreeADsMem(szLDAPServer);
    }

    if (szLDAPDn  && (*szLDAPDn == NULL)) {
       FreeADsMem(szLDAPDn);
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}


HRESULT
BuildADsPathFromLDAPPath2(
    DWORD  dwServerPresent,
    LPWSTR szADsNamespace,
    LPWSTR szLDAPServer,
    DWORD  dwPort,
    LPWSTR szLDAPDn,
    LPWSTR * ppszADsPathName
    )
{
    LPWSTR pszADsPathName = NULL;
    HRESULT hr = S_OK;
    DWORD dwLen;
    WCHAR szPort[32];
    LPWSTR pszDisplayDN = NULL;

    hr = GetDisplayName(
             szLDAPDn,
             &pszDisplayDN
             );
    BAIL_ON_FAILURE(hr);

    dwLen = STRING_LENGTH(szADsNamespace) +
            STRING_LENGTH(szLDAPServer) +
            STRING_LENGTH(pszDisplayDN) +
            STRING_LENGTH(L"//") +
            STRING_LENGTH(L"/") +
            1;

    if (IS_EXPLICIT_PORT(dwPort) ) {
        wsprintf(szPort, L":%d", dwPort);
        dwLen += STRING_LENGTH(szPort);
    }


    pszADsPathName = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );

    if(!pszADsPathName) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wsprintf(pszADsPathName,L"%s//", szADsNamespace);

    if (dwServerPresent) {

        if (szLDAPServer && *szLDAPServer) {

            wcscat(pszADsPathName, szLDAPServer);

            if (IS_EXPLICIT_PORT(dwPort) ) {

                wsprintf(szPort, L":%d", dwPort);
                wcscat(pszADsPathName, szPort);

            }

        }

        if (pszDisplayDN && *pszDisplayDN) {

            wcscat(pszADsPathName, L"/");
            wcscat(pszADsPathName, pszDisplayDN);

        }

    }else {

        if (pszDisplayDN && *pszDisplayDN) {
            wcscat(pszADsPathName, pszDisplayDN);
        }


    }

    *ppszADsPathName = pszADsPathName;

error:
    if (pszDisplayDN) {
        FreeADsMem(pszDisplayDN);
    }

    RRETURN(hr);
}


HRESULT
GetNamespaceFromADsPath(
    LPWSTR szADsPath,
    LPWSTR pszNamespace
    )
{
    LPWSTR pszTemp;

    // Get the namespace name

    pszTemp = _tcschr( szADsPath, TEXT(':'));
    if (!pszTemp) {
        RRETURN(E_FAIL);
    }
    _tcsncpy (pszNamespace, szADsPath, (int)(pszTemp - szADsPath));
    pszNamespace[pszTemp - szADsPath] = L'\0';

    RRETURN(S_OK);

}

//
// Change the separator of a DN from '\' to '/' so that it can be used in
// an ADsPath

HRESULT
ChangeSeparator(
    LPWSTR pszDN
    )
{

    LPWSTR ptr;

    if (pszDN) {

        while (ptr = wcschr(pszDN, '\\')) {
            *ptr = '/';
        }

    }

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\schmgmt.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  schmgmt.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop


HRESULT
ADsEnumAttributes(
    LPWSTR pszLdapServer,
    LPWSTR pszLdapDn,
    CCredentials Credentials,
    DWORD dwPort,
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    HRESULT hr = S_OK;

    LDAP_SCHEMA_HANDLE hSchema = NULL;
    DWORD cAttributes, cClasses;
    PROPERTYINFO *pPropertyInfo;

    DWORD dwMemSize = 0, dwStrBufSize = 0;

    DWORD dwLdapSyntax;

    LPBYTE pBuffer = NULL;
    LPWSTR pszNameEntry = NULL;
    PADS_ATTR_DEF pAttrDefEntry = NULL;

    ULONG i;

    if ( !ppAttrDefinition || !pdwNumAttributes ||
        (((LONG)dwNumAttributes) < 0 && ((LONG)dwNumAttributes) != -1) ) {
        RRETURN (E_INVALIDARG);
    }

    *ppAttrDefinition = NULL;
    *pdwNumAttributes = NULL;

    hr = SchemaOpen(
             pszLdapServer,
             &hSchema,
             Credentials,
             dwPort
             );
    BAIL_ON_FAILURE(hr);

    if (dwNumAttributes != (DWORD)-1) {
        //
        // List of attributes specified;
        //

        cAttributes = 0;

        for (i=0; i < dwNumAttributes; i++) {

            hr = SchemaGetPropertyInfo(
                     hSchema,
                     ppszAttrNames[i],
                     &pPropertyInfo);

            BAIL_ON_FAILURE(hr);

            if (pPropertyInfo != NULL) {
                cAttributes++;
                dwStrBufSize += (wcslen(ppszAttrNames[i]) + 1) * sizeof (WCHAR);
            }

        }

        dwMemSize = sizeof(ADS_ATTR_DEF) * cAttributes + dwStrBufSize;

        pBuffer = (LPBYTE) AllocADsMem(dwMemSize);

        if (!pBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pAttrDefEntry = (PADS_ATTR_DEF) pBuffer;
        pszNameEntry = (LPWSTR) (pBuffer + cAttributes * sizeof(ADS_ATTR_DEF));


        for (i=0; i < dwNumAttributes; i++) {

            hr = SchemaGetPropertyInfo(
                     hSchema,
                     ppszAttrNames[i],
                     &pPropertyInfo);

            BAIL_ON_FAILURE(hr);

            if (pPropertyInfo == NULL)
                continue;

            dwLdapSyntax = LdapGetSyntaxIdFromName(
                                           pPropertyInfo->pszSyntax);

            pAttrDefEntry->dwADsType = MapLDAPTypeToADSType(dwLdapSyntax);

            pAttrDefEntry->dwMinRange = pPropertyInfo->lMinRange;

            pAttrDefEntry->dwMaxRange = pPropertyInfo->lMaxRange;

            pAttrDefEntry->fMultiValued = !(pPropertyInfo->fSingleValued);

            wcscpy(pszNameEntry, ppszAttrNames[i]);
            pAttrDefEntry->pszAttrName = pszNameEntry;

            pszNameEntry += wcslen(ppszAttrNames[i]) + 1;
            pAttrDefEntry ++;
        }
    }
    else {
        //
        // Get all the attribute definitions
        //
        hr = SchemaGetObjectCount(
                 hSchema,
                 &cClasses,
                 &cAttributes);

        BAIL_ON_FAILURE(hr);

        dwMemSize = sizeof(ADS_ATTR_DEF) * cAttributes;

        //
        // Calculate the size of the buffer
        //

        for (i=0; i < cAttributes; i++) {

            hr = SchemaGetPropertyInfoByIndex(
                     hSchema,
                     i,
                     &pPropertyInfo);
            BAIL_ON_FAILURE(hr);

            dwMemSize += (wcslen(pPropertyInfo->pszPropertyName) + 1) * sizeof (WCHAR);

        }

        pBuffer = (LPBYTE) AllocADsMem(dwMemSize);

        if (!pBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pAttrDefEntry = (PADS_ATTR_DEF) pBuffer;
        pszNameEntry = (LPWSTR) (pBuffer + cAttributes * sizeof(ADS_ATTR_DEF));

        for (i=0; i < cAttributes; i++) {

            hr = SchemaGetPropertyInfoByIndex(
                     hSchema,
                     i,
                     &pPropertyInfo);
            BAIL_ON_FAILURE(hr);

            dwLdapSyntax = LdapGetSyntaxIdFromName(
                                           pPropertyInfo->pszSyntax);

            pAttrDefEntry->dwADsType = MapLDAPTypeToADSType(dwLdapSyntax);

            pAttrDefEntry->dwMinRange = pPropertyInfo->lMinRange;

            pAttrDefEntry->dwMaxRange = pPropertyInfo->lMaxRange;

            pAttrDefEntry->fMultiValued = !(pPropertyInfo->fSingleValued);

            wcscpy(pszNameEntry, pPropertyInfo->pszPropertyName);
            pAttrDefEntry->pszAttrName = pszNameEntry;

            pszNameEntry += wcslen(pPropertyInfo->pszPropertyName) + 1;
            pAttrDefEntry ++;
        }

    }

    *ppAttrDefinition = (PADS_ATTR_DEF) pBuffer;
    *pdwNumAttributes = cAttributes;


error:

    if ( hSchema )
        SchemaClose( &hSchema );

    RRETURN(hr);
}


HRESULT
ADsCreateAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
ADsWriteAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
ADsDeleteAttributeDefinition(
    LPWSTR pszAttributeName
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
ADsEnumClasses(
    LPWSTR * ppszAttrNames,
    DWORD dwNumClasses,
    PADS_CLASS_DEF * ppAttrDefinition,
    DWORD * pdwNumClasses
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
ADsCreateClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
ADsWriteClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF  pClassDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
ADsDeleteClassDefinition(
    LPWSTR pszClassName
    )
{
    RRETURN (E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\sconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  sconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

#define NULL_TERMINATED 0

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}


DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //

    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


HRESULT
UnicodeToUTF8String(
    LPCWSTR pUnicode,
    LPSTR *ppUTF8
    )
{
    HRESULT hr = S_OK;

    int UnicodeLength = 0;

    LPSTR pUTF8Temp = NULL;
    int UTF8TempLength = 0;

    LPSTR pUTF8 = NULL;
    int UTF8Length = 0;

    if (!pUnicode || !ppUTF8)
        BAIL_ON_FAILURE(hr = E_INVALIDARG)

    UnicodeLength = wcslen(pUnicode);
    UTF8TempLength = (UnicodeLength+1) * 4;
    
    pUTF8Temp = (char*) AllocADsMem(UTF8TempLength);
    if (!pUTF8Temp)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    UTF8Length = LdapUnicodeToUTF8(pUnicode,
                                   UnicodeLength+1,
                                   pUTF8Temp,
                                   UTF8TempLength);
    if (UTF8Length == 0)
        BAIL_ON_FAILURE(hr = E_FAIL);


    pUTF8 = (char*) AllocADsMem(UTF8Length);
    if (!pUTF8)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    
    memcpy(pUTF8, pUTF8Temp, UTF8Length);

    *ppUTF8 = pUTF8;

    FreeADsMem(pUTF8Temp);

    return(hr);

error:
    if (pUTF8)
        FreeADsMem(pUTF8);

    if (pUTF8Temp)
        FreeADsMem(pUTF8Temp);

    return (hr);
}


HRESULT
UTF8ToUnicodeString(
    LPCSTR   pUTF8,
    LPWSTR *ppUnicode
    )
{
    HRESULT hr = S_OK;

    int UTF8Length = 0;

    LPWSTR pUnicodeTemp = NULL;
    int UnicodeTempLength = 0;

    LPWSTR pUnicode = NULL;
    int UnicodeLength = 0;

    if (!pUTF8 || !ppUnicode)
        BAIL_ON_FAILURE(hr = E_INVALIDARG)

    UTF8Length = strlen(pUTF8);
    UnicodeTempLength = (UTF8Length+1) * 4;
    
    pUnicodeTemp = (PWCHAR) AllocADsMem(UnicodeTempLength);
    if (!pUnicodeTemp)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    UnicodeLength = LdapUTF8ToUnicode(pUTF8,
                                      UTF8Length+1,
                                      pUnicodeTemp,
                                      UnicodeTempLength);
    if (UnicodeLength == 0)
        BAIL_ON_FAILURE(hr = E_FAIL);


    pUnicode = (PWCHAR) AllocADsMem(UnicodeLength);
    if (!pUnicode)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    
    memcpy(pUnicode, pUnicodeTemp, UnicodeLength);

    *ppUnicode = pUnicode;

    FreeADsMem(pUnicodeTemp);

    return(hr);

error:
    if (pUnicode)
        FreeADsMem(pUnicode);

    if (pUnicodeTemp)
        FreeADsMem(pUnicodeTemp);

    return (hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\secutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       secutil.cxx
//
//  Contents:   Helper routines for conversion - LDAP specific
//
//  Functions:
//
//  History:    09-27-98 by splitting ldap\var2sec.cxx
//              and distributing between ldapc and router - AjayR
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

//
// Definition need as this is not a part of the headers
//
extern "C" {
HRESULT
ADsEncodeBinaryData (
   PBYTE   pbSrcData,
   DWORD   dwSrcLen,
   LPWSTR  * ppszDestData
   );
}

HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    WCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;
    HRESULT hr = S_OK;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;


    if (!IsValidSid( pSid )) {
        *String= L'\0';
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        RRETURN(hr);
    }

    wsprintf(Buffer, L"S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    wcscpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        wsprintf(Buffer, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        wcscat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        wsprintf(Buffer, L"%lu", Tmp);
        wcscat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        wsprintf(Buffer, L"-%lu", *(GetSidSubAuthority(pSid, i)));
        wcscat(String, Buffer);
    }

    RRETURN(S_OK);

}


HRESULT
ConvertU2TrusteeToSid(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    LPWSTR pszTrustee,
    LPBYTE Sid,
    PDWORD pdwSidSize
    )
{
    PADSLDP pLdapHandle = NULL;
    HRESULT hr = S_OK;
    LPWSTR *SidAttribute = NULL;
    DWORD nCount = 0;
    DWORD dwStatus = 0;
    struct berval **ppBerValue = NULL;
    LPWSTR Attributes[2];
    LDAPMessage *res = NULL;
    LDAPMessage *entry = NULL;
    DWORD dwNumberOfEntries = 0;
    DWORD dwSidLength = 0;
    LPBYTE lpByte = NULL;
    WCHAR szSid[MAX_PATH];

    Attributes[0] = L"Sid";
    Attributes[1] = NULL;

    ConvertSidToString( Sid, szSid);

    dwStatus = LdapOpenObject(
                pszServerName,
                pszTrustee,
                &pLdapHandle,
                Credentials,
                FALSE
                );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = LdapSearchS(
                    pLdapHandle,
                    pszTrustee,
                    LDAP_SCOPE_BASE,
                    L"(objectClass=*)",
                    Attributes,
                    0,
                    &res
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwNumberOfEntries = LdapCountEntries( pLdapHandle, res );

    if ( dwNumberOfEntries == 0 )
        RRETURN(S_OK);

    dwStatus = LdapFirstEntry( pLdapHandle, res, &entry );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = LdapGetValuesLen(
                    pLdapHandle,
                    entry,
                    L"Sid",
                    &ppBerValue,
                    (int *)&nCount
                    );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwSidLength = ((struct berval **)ppBerValue)[0]->bv_len;
    lpByte = (LPBYTE)((struct berval **) ppBerValue)[0]->bv_val;


    memcpy( Sid, lpByte, dwSidLength);
    *pdwSidSize = dwSidLength;

error:

    if (res) {
        LdapMsgFree( res );
    }

    RRETURN(hr);
}


HRESULT
ConvertSidToU2Trustee(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PSID pSid,
    LPWSTR szTrustee
    )
{
    HRESULT hr = S_OK;
    PUCHAR pSidAuthorityCount = NULL;
    LPWSTR pszQueryString = NULL;
    DWORD dwSidLength = 0;
    LDAPMessage *res = NULL;
    LPWSTR pszDN = NULL;
    LDAPMessage *entry = NULL;
    DWORD dwStatus = 0;

    DWORD dwNumberOfEntries  = 0;
    WCHAR szSearchExp[MAX_PATH];

    PADSLDP pLdapHandle = NULL;

    LPWSTR Attributes[] = {L"Sid", NULL};
    WCHAR szSid[MAX_PATH];


    ConvertSidToString( pSid, szSid);

    pSidAuthorityCount = GetSidSubAuthorityCount(pSid);

    if (!pSidAuthorityCount) {
        RRETURN(E_FAIL);
    }

    dwSidLength = GetSidLengthRequired(*pSidAuthorityCount);

    hr = ADsEncodeBinaryData (
            (LPBYTE)pSid,
            dwSidLength,
            &pszQueryString
            );
    BAIL_ON_FAILURE(hr);


    dwStatus = LdapOpenObject(
                pszServerName,
                NULL,
                &pLdapHandle,
                Credentials,
                FALSE
                );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(szSearchExp,L"(Sid=");
    wcscat(szSearchExp, pszQueryString);
    wcscat(szSearchExp, L")");

    dwStatus = LdapSearchS(
                    pLdapHandle,
                    NULL,
                    LDAP_SCOPE_SUBTREE,
                    szSearchExp,
                    Attributes,
                    0,
                    &res
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwNumberOfEntries = LdapCountEntries( pLdapHandle, res );

    if ( dwNumberOfEntries == 0 ){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = LdapFirstEntry( pLdapHandle, res, &entry );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = LdapGetDn( pLdapHandle, entry, &pszDN);
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(szTrustee, pszDN);

error:

    if (pszQueryString) {
        FreeADsStr(pszQueryString);
    }

    if (pszDN) {
        LdapMemFree(pszDN);
    }

    if (res) {
        LdapMsgFree( res );
    }

    if (pLdapHandle) {
        LdapCloseObject( pLdapHandle);
    }

    RRETURN(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\schutil.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      util.cxx
//
//  Contents:  Some misc helper functions
//
//  History:
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

BOOL
IsContainer(
    LPTSTR pszClassName,
    LDAP_SCHEMA_HANDLE hSchema
);

/******************************************************************/
/*  Class SCHEMAINFO
/******************************************************************/
SCHEMAINFO::SCHEMAINFO()
    : _cRef( 0 ),
      _fObsolete( FALSE ),
      fDefaultSchema( FALSE ),
      fAppearsV3(TRUE),
      pszServerName( NULL ),
      pszSubSchemaSubEntry( NULL ),
      pszTime( NULL ),
      Next( NULL ),
      aClasses( NULL ),
      nNumOfClasses( 0 ),
      aClassesSearchTable( NULL ),
      aProperties( NULL ),
      nNumOfProperties( 0 ),
      aPropertiesSearchTable( NULL ),
      pszUserName( NULL )
{
}

SCHEMAINFO::~SCHEMAINFO()
{
    if ( pszServerName )
        FreeADsStr( pszServerName );

    if ( pszUserName )
        FreeADsStr( pszUserName );

    if ( pszSubSchemaSubEntry )
        FreeADsStr( pszSubSchemaSubEntry );

    if ( pszTime )
        FreeADsStr( pszTime );

    if ( !fDefaultSchema )
    {
        if ( aClasses )
            FreeClassInfoArray( aClasses, nNumOfClasses );

        if ( aClassesSearchTable )
            FreeADsMem( aClassesSearchTable );

        if ( aProperties )
            FreePropertyInfoArray( aProperties, nNumOfProperties );

        if ( aPropertiesSearchTable )
            FreeADsMem( aPropertiesSearchTable );
    }
}

DWORD SCHEMAINFO::AddRef()
{
    return ++_cRef;
}

DWORD SCHEMAINFO::Release()
{
    if ( _cRef > 0 )
        return --_cRef;

    return 0;
}

//
// Helper routine that looks up the syntax tables (oid and name oid)
// and returns the correct syntax corresponding to the string name.
//
DWORD
LdapGetSyntaxIdOfAttribute(
    LPWSTR pszStringSyntax
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = -1;

    dwSyntaxId = FindEntryInSearchTable(
                     pszStringSyntax,
                     g_aSyntaxSearchTable,
                     g_nSyntaxSearchTableSize
                     );

    if (dwSyntaxId == -1) {
        //
        // We also need to search in the OID based syntax table.
        //
        dwSyntaxId = FindEntryInSearchTable(
                         pszStringSyntax,
                         g_aOidSyntaxSearchTable,
                         g_nOidSyntaxSearchTableSize
                         );
    }

    return dwSyntaxId;
}


 HRESULT
LdapGetSyntaxOfAttributeOnServerHelper(
    LPTSTR  pszServerPath,
    LPTSTR  pszAttrName,
    DWORD   *pdwSyntaxId,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;
    DWORD dwEntry;
    LPWSTR pszTemp = NULL;

    *pdwSyntaxId = LDAPTYPE_UNKNOWN;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );

    BAIL_IF_ERROR(hr);

    // Support for range attributes; for eg., objectClass=Range=0-1 We should
    // ignore everything after ';' inclusive.
    //

    if ((pszTemp = wcschr(pszAttrName, L';')) != NULL ) {
        *pszTemp = L'\0';
    }

    dwEntry = FindEntryInSearchTable(
                  pszAttrName,
                  pSchemaInfo->aPropertiesSearchTable,
                  pSchemaInfo->nNumOfProperties * 2 );

    //
    // Put back the ; if we had replaced it.
    //

    if (pszTemp)
        *pszTemp = L';';

    if ( dwEntry != -1 )
    {
        //
        // This helper routine will lookup both the oid table and the
        // name based syntax table and return -1 if unsuccesful.
        //
        *pdwSyntaxId = LdapGetSyntaxIdOfAttribute(
                           pSchemaInfo->aProperties[dwEntry].pszSyntax
                           );

        if ( *pdwSyntaxId == -1 ) {
            *pdwSyntaxId = LDAPTYPE_UNKNOWN;
        }
    }
    else
    {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_IF_ERROR(hr);
    }

cleanup:

    if ( pSchemaInfo )
        pSchemaInfo->Release();

    RRETURN(hr);
}

//
// This routine calls the helper and if the flag FromServer is TRUE,
// then if we cannot find the syntax on the server then we will
// mark as obsolete and retry. This will fix some not so obvious
// cases of problems with the schema across mutliple DC's. The
// underlying assumption is that if the server sent the info, then
// it should have the schema information to match.
//
HRESULT
LdapGetSyntaxOfAttributeOnServer(
    LPTSTR  pszServerPath,
    LPTSTR  pszAttrName,
    DWORD   *pdwSyntaxId,
    CCredentials& Credentials,
    DWORD dwPort,
    BOOL fFromServer // defaulted to FALSE
    )
{
    HRESULT hr = S_OK;

    hr = LdapGetSyntaxOfAttributeOnServerHelper(
             pszServerPath,
             pszAttrName,
             pdwSyntaxId,
             Credentials,
             dwPort
             );

    //
    // Reset and retry only if fFromServer is true, and
    // the failure was E_ADS_PROPERTY_NOT_FOUND. If this is
    // a v2 server then there will be no significant perf hit
    // as we do not refresh the default schema.
    //

    if (FAILED(hr)
        && (hr == E_ADS_PROPERTY_NOT_FOUND)
        && fFromServer) {
        //
        // Mark schema as old.
        //
        hr = LdapRemoveSchemaInfoOnServer(
                 pszServerPath,
                 Credentials,
                 dwPort,
                 TRUE // force update.
                 );

        BAIL_ON_FAILURE(hr);

        hr = LdapGetSyntaxOfAttributeOnServerHelper(
                 pszServerPath,
                 pszAttrName,
                 pdwSyntaxId,
                 Credentials,
                 dwPort
                 );

        BAIL_ON_FAILURE(hr);

    }
    else {
        //
        // This is the normal exit path.
        //
        RRETURN(hr);
    }

error :

    //
    // If we get here we need to return prop not found
    // other code may depend on that. Note that we will come
    // here only if we the first try failed and something went
    // wrong while trying to force a reload of the schema.
    //
    if (FAILED(hr)) {
        RRETURN(hr = E_ADS_PROPERTY_NOT_FOUND);
    }
    else  {
        RRETURN(hr);
    }

}

HRESULT
LdapIsClassNameValidOnServer(
    LPTSTR  pszServerPath,
    LPTSTR  pszClassName,
    BOOL    *pfValid,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    *pfValid = FALSE;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );

    BAIL_IF_ERROR(hr);

    if ( FindEntryInSearchTable(
             pszClassName,
             pSchemaInfo->aClassesSearchTable,
             pSchemaInfo->nNumOfClasses * 2 ) != -1 )
    {
        *pfValid = TRUE;
    }

cleanup:

    if ( pSchemaInfo )
        pSchemaInfo->Release();

    RRETURN(hr);
}

HRESULT
LdapGetSchemaObjectCount(
    LPTSTR  pszServerPath,
    DWORD   *pnNumOfClasses,
    DWORD   *pnNumOfProperties,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );

    BAIL_IF_ERROR(hr);

    *pnNumOfClasses = pSchemaInfo->nNumOfClasses;
    *pnNumOfProperties = pSchemaInfo->nNumOfProperties;

cleanup:

    if ( pSchemaInfo )
        pSchemaInfo->Release();

    RRETURN(hr);
}

HRESULT
LdapGetSubSchemaSubEntryPath(
    LPTSTR  pszServerPath,
    LPTSTR  *ppszSubSchemaSubEntryPath,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    *ppszSubSchemaSubEntryPath = NULL;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );
    BAIL_IF_ERROR(hr);

    if ( pSchemaInfo->pszSubSchemaSubEntry )
    {
        *ppszSubSchemaSubEntryPath =
            AllocADsStr( pSchemaInfo->pszSubSchemaSubEntry );

        if ( *ppszSubSchemaSubEntryPath == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_IF_ERROR(hr);
        }
    }

cleanup:

    if ( pSchemaInfo )
        pSchemaInfo->Release();

    RRETURN(hr);
}

HRESULT
LdapMakeSchemaCacheObsolete(
    LPTSTR  pszServerPath,
    CCredentials& Credentials,
    DWORD dwPort
)
{
    RRETURN( LdapRemoveSchemaInfoOnServer(
                 pszServerPath,
                 Credentials,
                 dwPort
                  )
             );
}


HRESULT
SchemaOpen(
    IN  LPTSTR  pszServerPath,
    OUT LDAP_SCHEMA_HANDLE *phSchema,
    IN CCredentials& Credentials,
    DWORD dwPort
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = NULL;

    *phSchema = NULL;

    hr = LdapGetSchema( pszServerPath,
                        &pSchemaInfo,
                        Credentials,
                        dwPort
                        );

    if ( FAILED(hr))
        RRETURN(hr);

    *phSchema = (HANDLE) pSchemaInfo;

    RRETURN(S_OK);
}

HRESULT
SchemaClose(
    IN OUT LDAP_SCHEMA_HANDLE  *phSchema
)
{
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) *phSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    if ( pSchemaInfo->Release() == 0 )
        *phSchema = NULL;

    RRETURN(S_OK);
}

HRESULT
SchemaAddRef(
    IN LDAP_SCHEMA_HANDLE  hSchema
)
{
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    pSchemaInfo->AddRef();

    RRETURN(S_OK);
}

HRESULT
SchemaGetObjectCount(
    LDAP_SCHEMA_HANDLE hSchema,
    DWORD   *pnNumOfClasses,
    DWORD   *pnNumOfProperties
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pnNumOfClasses = pSchemaInfo->nNumOfClasses;
    *pnNumOfProperties = pSchemaInfo->nNumOfProperties;

    RRETURN(hr);
}

HRESULT
SchemaGetClassInfoByIndex(
    LDAP_SCHEMA_HANDLE hSchema,
    DWORD     dwIndex,
    CLASSINFO **ppClassInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    *ppClassInfo = &(pSchemaInfo->aClasses[dwIndex]);

    RRETURN(hr);
}

HRESULT
SchemaGetPropertyInfoByIndex(
    LDAP_SCHEMA_HANDLE hSchema,
    DWORD     dwIndex,
    PROPERTYINFO **ppPropertyInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    *ppPropertyInfo = &(pSchemaInfo->aProperties[dwIndex]);

    RRETURN(hr);
}

HRESULT
SchemaGetClassInfo(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR  pszClassName,
    CLASSINFO **ppClassInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;
    DWORD dwIndex = (DWORD) -1;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    dwIndex = FindEntryInSearchTable(
                  pszClassName,
                  pSchemaInfo->aClassesSearchTable,
                  pSchemaInfo->nNumOfClasses * 2 );

    if ( dwIndex == -1 )
    {
        *ppClassInfo = NULL;
    }
    else
    {
        *ppClassInfo = &(pSchemaInfo->aClasses[dwIndex]);
    }

    RRETURN(hr);
}

HRESULT
SchemaGetPropertyInfo(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR  pszPropertyName,
    PROPERTYINFO **ppPropertyInfo
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;
    DWORD dwIndex = (DWORD) -1;
    LPWSTR pszTemp = NULL;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    // Support for range attributes; for eg., objectClass=Range=0-1 We should
    // ignore everything after ';' inclusive.
    //

    if ((pszTemp = wcschr(pszPropertyName, L';')) != NULL ) {
        *pszTemp = L'\0';
    }

    dwIndex = FindEntryInSearchTable(
                  pszPropertyName,
                  pSchemaInfo->aPropertiesSearchTable,
                  pSchemaInfo->nNumOfProperties * 2 );

    //
    // Put back the ; if we had replaced it.
    //

    if (pszTemp)
        *pszTemp = L';';

    if ( dwIndex == -1 )
    {
        *ppPropertyInfo = NULL;
    }
    else
    {
        *ppPropertyInfo = &(pSchemaInfo->aProperties[dwIndex]);
    }

    RRETURN(hr);
}

HRESULT
SchemaGetSyntaxOfAttribute(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR  pszAttrName,
    DWORD   *pdwSyntaxId
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;
    LPWSTR pszTemp = NULL;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pdwSyntaxId = LDAPTYPE_UNKNOWN;

    // Support for range attributes; for eg., objectClass=Range=0-1 We should
    // ignore everything after ';' inclusive.
    //

    if ((pszTemp = wcschr(pszAttrName, L';')) != NULL ) {
        *pszTemp = L'\0';
    }

    DWORD dwEntry = FindEntryInSearchTable(
                        pszAttrName,
                        pSchemaInfo->aPropertiesSearchTable,
                        pSchemaInfo->nNumOfProperties * 2 );

    //
    // Put back the ; if we had replaced it.
    //

    if (pszTemp)
        *pszTemp = L';';

    if ( dwEntry != -1 )
    {
        *pdwSyntaxId = FindEntryInSearchTable(
                           pSchemaInfo->aProperties[dwEntry].pszSyntax,
                           g_aSyntaxSearchTable,
                           g_nSyntaxSearchTableSize );


        if ( *pdwSyntaxId == -1 ) {

            //
            // We also need to search in the OID based syntax table.
            //
            *pdwSyntaxId = FindEntryInSearchTable(
                               pSchemaInfo->aProperties[dwEntry].pszSyntax,
                               g_aOidSyntaxSearchTable,
                               g_nOidSyntaxSearchTableSize
                               );

            if ( *pdwSyntaxId == -1 ) {
                *pdwSyntaxId = LDAPTYPE_UNKNOWN;
            }
        }

    }
    else
    {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_IF_ERROR(hr);
    }

cleanup:

    RRETURN(hr);
}

HRESULT
SchemaIsClassAContainer(
    LDAP_SCHEMA_HANDLE hSchema,
    LPTSTR pszClassName,
    BOOL *pfContainer
)
{
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    if (  ( _tcsicmp( pszClassName, TEXT("Container")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("organizationalUnit")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("organization")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("country")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("locality")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("device")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("DMD")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("mSFTDSA")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("Domain")) == 0 )
       )
    {
        *pfContainer = TRUE;
        RRETURN(S_OK);
    }

    *pfContainer = IsContainer( pszClassName, hSchema );
    RRETURN(S_OK);
}

HRESULT
SchemaGetStringsFromStringTable(
    LDAP_SCHEMA_HANDLE hSchema,
    int *propList,
    DWORD nCount,
    LPWSTR **paStrings
)
{
    HRESULT hr = S_OK;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;
    long i = 0;

    if ( !pSchemaInfo )
        RRETURN(E_ADS_BAD_PARAMETER);

    if ( (propList != NULL) && (*propList != -1) )
    {

        *paStrings = (LPWSTR *) AllocADsMem( (nCount+1)*sizeof(LPWSTR));
        if ( *paStrings == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        i = 0;
        while ( propList[i] != -1 )
        {
            (*paStrings)[i] = AllocADsStr(
                     pSchemaInfo->aProperties[pSchemaInfo->aPropertiesSearchTable[propList[i]].nIndex].pszPropertyName  );

            if ( (*paStrings)[i] == NULL )
            {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            i++;
        }

        (*paStrings)[i] = NULL;
    }
    else
    {
        *paStrings = NULL;
    }

    return S_OK;

error:

    if ( *paStrings )
    {
        i = 0;
        while ( (*paStrings)[i] )
        {
            FreeADsStr( (*paStrings)[i] );
            i++;
        }
        FreeADsMem( *paStrings );
    }

    RRETURN(hr);

}

BOOL
IsContainer(
    LPTSTR pszClassName,
    LDAP_SCHEMA_HANDLE hSchema
)
{
    int i = 0;
    CLASSINFO *pClassInfo;
    LPTSTR pszName;
    DWORD index;
    SCHEMAINFO *pSchemaInfo = (SCHEMAINFO *) hSchema;

    if (  ( _tcsicmp( pszClassName, TEXT("Container")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("organizationalUnit")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("organization")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("country")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("locality")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("device")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("DMD")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("mSFTDSA")) == 0 )
       || ( _tcsicmp( pszClassName, TEXT("Domain")) == 0 )
       )
    {
        return TRUE;
    }

    index = (DWORD) FindEntryInSearchTable(
                        pszClassName,
                        pSchemaInfo->aClassesSearchTable,
                        2 * pSchemaInfo->nNumOfClasses );

    if ( i == ((DWORD) -1) )
        return FALSE;

    pClassInfo = &(pSchemaInfo->aClasses[index]);

    if ( pClassInfo->pOIDsSuperiorClasses )
    {
        for ( i = 0;
              (pszName = pClassInfo->pOIDsSuperiorClasses[i]);
              i++  )
        {
            if ( IsContainer( pszName, hSchema ))
                return TRUE;
        }
    }

    if ( pClassInfo->pOIDsAuxClasses )
    {
        for ( i = 0;
              (pszName = pClassInfo->pOIDsAuxClasses[i]);
              i++  )
        {
            if ( IsContainer( pszName, hSchema ))
                return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\srchutil.cxx ===
//---------------------------------------------------------------------------;
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssrch.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

const int MAX_BYTES = 1048576;
const int NO_LDAP_RESULT_HANDLES = 32;

static BOOL
IsValidPrefValue(
    ADS_SEARCHPREF_INFO SearchPref
    );

static
HRESULT
LdapValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    VOID        **lpValue,
    ADS_SEARCH_COLUMN * pColumn
    );

HRESULT
UnicodeToUTF8String(
    LPCWSTR pUnicode,
    LPSTR *ppUTF8
    );

HRESULT
UTF8ToUnicodeString(
    LPCSTR   pUTF8,
    LPWSTR *ppUnicode
    );

//
// Sets the appropriate search preferences.
//


HRESULT
ADsSetSearchPreference(
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs,
    OUT LDAP_SEARCH_PREF * pLdapPref,
    IN LPWSTR pszLDAPServer,
    IN LPWSTR pszLDAPDn,
    IN CCredentials& Credentials,
    IN DWORD dwPort
    )
{

    HRESULT hr = S_OK;
    BOOL fWarning = FALSE;
    DWORD i, j;
    BOOL fPagedSearch = FALSE, fSorting = TRUE, fVLV = FALSE, fAttribScoped = FALSE;
    DWORD dwSecDescType = ADSI_LDAPC_SECDESC_NONE;

    PADS_SORTKEY pSortKeyArray = NULL;
    DWORD dwSortKeyArrayLen = 0, nKeys = 0;

    BOOL fSetCaching = FALSE; // TRUE if user explicitly set a caching preference
    BOOL fSetScope   = FALSE; // TRUE if user explicitly set a scope preference

    PADS_VLV pVLV  = NULL;
    DWORD dwVLVLen = 0;
    LPSTR pUTF8Target = NULL;
    DWORD dwUTF8TargetLen = 0;

    LPWSTR pAttribScoped  = NULL;

    DWORD dwSecurityMask;

    if (!pSearchPrefs && dwNumPrefs > 0 || !pLdapPref) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    for (i=0; i<dwNumPrefs; i++) {

        pSearchPrefs[i].dwStatus = ADS_STATUS_S_OK;

        if (!IsValidPrefValue(pSearchPrefs[i]) ) {
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
            fWarning = TRUE;
            continue;
        }

        switch(pSearchPrefs[i].dwSearchPref) {
        case ADS_SEARCHPREF_ASYNCHRONOUS:
            pLdapPref->_fAsynchronous = pSearchPrefs[i].vValue.Boolean;
            break;
        case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
            pLdapPref->_fAttrsOnly = pSearchPrefs[i].vValue.Boolean;
            break;
        case ADS_SEARCHPREF_SIZE_LIMIT:
            pLdapPref->_dwSizeLimit = pSearchPrefs[i].vValue.Integer;
            break;
        case ADS_SEARCHPREF_TIME_LIMIT:
            pLdapPref->_dwTimeLimit = pSearchPrefs[i].vValue.Integer;
            break;
        case ADS_SEARCHPREF_TIMEOUT:
            pLdapPref->_timeout.tv_sec = pSearchPrefs[i].vValue.Integer;
            break;
        case ADS_SEARCHPREF_PAGESIZE:

            if (pLdapPref->_fDirSync) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            ReadPagingSupportedAttr(
                         pszLDAPServer,
                         &fPagedSearch,
                         Credentials,
                         dwPort
                         ) ;

            if (fPagedSearch) {
                pLdapPref->_dwPageSize = pSearchPrefs[i].vValue.Integer;
            }
            else {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
            }
            break;
        case ADS_SEARCHPREF_PAGED_TIME_LIMIT:

            ReadPagingSupportedAttr(
                         pszLDAPServer,
                         &fPagedSearch,
                         Credentials,
                         dwPort
                         ) ;

            if (fPagedSearch) {
                pLdapPref->_dwPagedTimeLimit = pSearchPrefs[i].vValue.Integer;
            }
            else {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
            }
            break;
        case ADS_SEARCHPREF_DEREF_ALIASES:
            pLdapPref->_dwDerefAliases = pSearchPrefs[i].vValue.Integer;
            break;
        case ADS_SEARCHPREF_SEARCH_SCOPE:

            // if doing a attribute-scoped query and user tries to set scope
            // to anything other than ADS_SCOPE_BASE, reject
            if (pLdapPref->_pAttribScoped && (pSearchPrefs[i].vValue.Integer != ADS_SCOPE_BASE)) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }
        
            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_SCOPE_SUBTREE:
                pLdapPref->_dwSearchScope = LDAP_SCOPE_SUBTREE;
                break;
            case ADS_SCOPE_ONELEVEL:
                pLdapPref->_dwSearchScope = LDAP_SCOPE_ONELEVEL;
                break;
            case ADS_SCOPE_BASE:
                pLdapPref->_dwSearchScope = LDAP_SCOPE_BASE;
                break;
            }

            fSetScope = TRUE;   // set so if user later tries to do
                                // attrib-scoped query, and user set scope
                                // to other than ADS_SCOPE_BASE, can detect & reject
            
            break;
        case ADS_SEARCHPREF_CHASE_REFERRALS:
            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_CHASE_REFERRALS_NEVER:
                pLdapPref->_dwChaseReferrals = (DWORD) (DWORD_PTR)LDAP_OPT_OFF;
                break;
            case ADS_CHASE_REFERRALS_SUBORDINATE:
                pLdapPref->_dwChaseReferrals = LDAP_CHASE_SUBORDINATE_REFERRALS;
                break;
            case ADS_CHASE_REFERRALS_EXTERNAL:
                pLdapPref->_dwChaseReferrals = LDAP_CHASE_EXTERNAL_REFERRALS;
                break;
            case ADS_CHASE_REFERRALS_ALWAYS:
                pLdapPref->_dwChaseReferrals = (DWORD) (DWORD_PTR) LDAP_OPT_ON;
                break;
            }
            break;
        case ADS_SEARCHPREF_SORT_ON:

            ReadSortingSupportedAttr(
                         pszLDAPServer,
                         &fSorting,
                         Credentials,
                         dwPort
                         ) ;

            if (!fSorting) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
                continue;
            }
            //
            // The value is actually a pointer to the LDAP Sort Key whose
            // structure is as defined in the sort control RFC extension.
            //

            pSortKeyArray = (PADS_SORTKEY) pSearchPrefs[i].vValue.ProviderSpecific.lpValue;
            dwSortKeyArrayLen = pSearchPrefs[i].vValue.ProviderSpecific.dwLength;

            if (!pSortKeyArray || !dwSortKeyArrayLen ) {
                continue;
            }

            if (dwSortKeyArrayLen % sizeof(ADS_SORTKEY) != 0 ) {
                //
                // The data given does not seem to contain a proper SortKey
                // structure
                //
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            nKeys = dwSortKeyArrayLen / sizeof(ADS_SORTKEY);

            if (pLdapPref->_pSortKeys) {
                //
                // Free the previous one
                //
                FreeSortKeys(pLdapPref->_pSortKeys, pLdapPref->_nSortKeys);

            }

            pLdapPref->_pSortKeys = (PLDAPSortKey) AllocADsMem(
                                                sizeof(LDAPSortKey) * nKeys);
            if (!pLdapPref->_pSortKeys) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            for (j=0; j<nKeys; j++) {

                pLdapPref->_pSortKeys[j].sk_attrtype =
                                    AllocADsStr(pSortKeyArray[j].pszAttrType);
                pLdapPref->_pSortKeys[j].sk_matchruleoid =
                                    pSortKeyArray[j].pszReserved;
                pLdapPref->_pSortKeys[j].sk_reverseorder =
                                    pSortKeyArray[j].fReverseorder;
            }

            pLdapPref->_nSortKeys = nKeys;

            break;
        case ADS_SEARCHPREF_CACHE_RESULTS:
            // if doing a VLV search and user tries to turn on caching, reject
            if (pLdapPref->_pVLVInfo && pSearchPrefs[i].vValue.Boolean) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }
        
            pLdapPref->_fCacheResults = pSearchPrefs[i].vValue.Boolean;
            fSetCaching = TRUE; // set so if we later determine user wants to
                                // do a VLV search, we can reject if user tried
                                // to explicitly turn on caching
            break;

        //
        // Like paged, setting this preference will mean that we use it
        // by default, it is not used.
        //
        case ADS_SEARCHPREF_DIRSYNC:

            if (pLdapPref->_dwPageSize) {
                BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            pLdapPref->_fDirSync = TRUE;

            //
            // Check if previous value is set and free if necessary.
            //
            if (pLdapPref->_pProvSpecific) {
                if (pLdapPref->_pProvSpecific->lpValue) {
                    FreeADsMem(pLdapPref->_pProvSpecific->lpValue);
                    pLdapPref->_pProvSpecific->lpValue = NULL;
                }
                FreeADsMem(pLdapPref->_pProvSpecific);
                pLdapPref->_pProvSpecific = NULL;
            }

            //
            // Copy over the info here.
            //
            pLdapPref->_pProvSpecific =
                (PADS_PROV_SPECIFIC) AllocADsMem(sizeof(ADS_PROV_SPECIFIC));

            if (!pLdapPref->_pProvSpecific) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            pLdapPref->_pProvSpecific->dwLength =
                pSearchPrefs[i].vValue.ProviderSpecific.dwLength;

            //
            // If the octet string is anything other than NULL,
            // we need to copy it over. If it is NULL, then this is
            // the first time the control is being used.
            //
            if (pLdapPref->_pProvSpecific->dwLength > 0) {

                pLdapPref->_pProvSpecific->lpValue =
                    (PBYTE)AllocADsMem(pLdapPref->_pProvSpecific->dwLength);

                if (!pLdapPref->_pProvSpecific->lpValue) {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }

                memcpy(
                    pLdapPref->_pProvSpecific->lpValue,
                    pSearchPrefs[i].vValue.ProviderSpecific.lpValue,
                    pLdapPref->_pProvSpecific->dwLength
                    );
            }
            break;

        case ADS_SEARCHPREF_TOMBSTONE :
            pLdapPref->_fTombStone = pSearchPrefs[i].vValue.Boolean;
            break;

        case ADS_SEARCHPREF_VLV:

            // If user tried to explicitly turn on caching, reject
            // Later on, we'll turn off caching
            if ( fSetCaching && pLdapPref->_fCacheResults) {
                 BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            // test for server support of VLV
            ReadVLVSupportedAttr(
                         pszLDAPServer,
                         &fVLV,
                         Credentials,
                         dwPort
                         ) ;

            if (!fVLV) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
                continue;
            }


            // basic sanity checks of user-supplied data
            pVLV = (PADS_VLV) pSearchPrefs[i].vValue.ProviderSpecific.lpValue;
            dwVLVLen = pSearchPrefs[i].vValue.ProviderSpecific.dwLength;

            if (!pVLV || !dwVLVLen ) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            if (dwVLVLen != sizeof(ADS_VLV)) {
                //
                // The data given does not seem to contain a proper VLV
                // structure
                //
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            // free the previous LDAPVLVInfo, if one exists (generally, it shouldn't)
            if (pLdapPref->_pVLVInfo)
                FreeLDAPVLVInfo(pLdapPref->_pVLVInfo);

            // Copy the user's VLV search preferences into a LDAPVLVInfo
            // Note that we copy the dwOffset and dwContentCount even if the user
            // wants to do a greaterThanOrEqual-type VLV search.  This is because
            // we'll ignore those members if ldvlv_attrvalue != NULL.
            pLdapPref->_pVLVInfo = (PLDAPVLVInfo) AllocADsMem(sizeof(LDAPVLVInfo));
            if (!pLdapPref->_pVLVInfo)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pLdapPref->_pVLVInfo->ldvlv_version      = LDAP_VLVINFO_VERSION;    // 1
            pLdapPref->_pVLVInfo->ldvlv_before_count = pVLV->dwBeforeCount;
            pLdapPref->_pVLVInfo->ldvlv_after_count  = pVLV->dwAfterCount;
            pLdapPref->_pVLVInfo->ldvlv_offset       = pVLV->dwOffset;
            pLdapPref->_pVLVInfo->ldvlv_count        = pVLV->dwContentCount;
            pLdapPref->_pVLVInfo->ldvlv_attrvalue    = NULL;
            pLdapPref->_pVLVInfo->ldvlv_context      = NULL;
            pLdapPref->_pVLVInfo->ldvlv_extradata    = NULL;

            // copy the greaterThanOrEqual attribute, if provided by the user
            if (pVLV->pszTarget) {

                pLdapPref->_pVLVInfo->ldvlv_attrvalue = (PBERVAL) AllocADsMem(sizeof(BERVAL));
                if (!pLdapPref->_pVLVInfo->ldvlv_attrvalue)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                // convert Unicode to UDF-8
                // important: do NOT include the NULL terminator in the LDAPVLVInfo.ldvlv_attrvalue
                
                hr = UnicodeToUTF8String(pVLV->pszTarget, &pUTF8Target);
                BAIL_ON_FAILURE(hr);

                // we want the number of bytes, not the number of MBCS characters
                dwUTF8TargetLen = strlen(pUTF8Target);

                pLdapPref->_pVLVInfo->ldvlv_attrvalue->bv_len = dwUTF8TargetLen;
                pLdapPref->_pVLVInfo->ldvlv_attrvalue->bv_val = (PCHAR) AllocADsMem(dwUTF8TargetLen);
                if (!pLdapPref->_pVLVInfo->ldvlv_attrvalue->bv_val)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                memcpy(pLdapPref->_pVLVInfo->ldvlv_attrvalue->bv_val,
                       pUTF8Target,
                       dwUTF8TargetLen);
            }

            // copy the context ID, if provided by the user
            if (pVLV->lpContextID && pVLV->dwContextIDLength) {

                pLdapPref->_pVLVInfo->ldvlv_context = (PBERVAL) AllocADsMem(sizeof(BERVAL));
                if (pLdapPref->_pVLVInfo->ldvlv_context == NULL)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                
                pLdapPref->_pVLVInfo->ldvlv_context->bv_val = (PCHAR) AllocADsMem(pVLV->dwContextIDLength);
                if (pLdapPref->_pVLVInfo->ldvlv_context->bv_val == NULL)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                pLdapPref->_pVLVInfo->ldvlv_context->bv_len = pVLV->dwContextIDLength;
                memcpy(pLdapPref->_pVLVInfo->ldvlv_context->bv_val,
                       pVLV->lpContextID,
                       pVLV->dwContextIDLength);
            }

            // disable caching, since it's not supported in conjunction with VLV
            pLdapPref->_fCacheResults = FALSE;
            break;

        case ADS_SEARCHPREF_ATTRIBUTE_QUERY:

            // If user tried to explicitly set scope to other than "base", reject
            // Later on, we'll set it to base.
            if ( fSetScope && pLdapPref->_dwSearchScope != LDAP_SCOPE_BASE) {
                 BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
            }

            // test for server support of attribute-scoped query
            ReadAttribScopedSupportedAttr(
                         pszLDAPServer,
                         &fAttribScoped,
                         Credentials,
                         dwPort
                         ) ;

            if (!fAttribScoped) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
                continue;
            }
            
            // basic sanity checks of user-supplied data
            pAttribScoped = pSearchPrefs[i].vValue.CaseIgnoreString;

            if (!pAttribScoped) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            // free the previous ADS_ATTRIBUTE_QUERY, if one exists (generally, it shouldn't)
            if (pLdapPref->_pAttribScoped) {
                FreeADsStr(pLdapPref->_pAttribScoped);
                pLdapPref->_pAttribScoped = NULL;
            }

            // copy the ADS_ATTRIBUTE_QUERY
            pLdapPref->_pAttribScoped = AllocADsStr(pAttribScoped);
            if (!(pLdapPref->_pAttribScoped)) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            // set search scope to base (only scope supported by attrib-scoped query)
            pLdapPref->_dwSearchScope = LDAP_SCOPE_BASE;
            break;

        case ADS_SEARCHPREF_SECURITY_MASK:

            //
            // test for server support of security descriptor control
            //
            ReadSecurityDescriptorControlType(
                         pszLDAPServer,
                         &dwSecDescType,
                         Credentials,
                         dwPort
                         );

            if (dwSecDescType != ADSI_LDAPC_SECDESC_NT) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
                fWarning = TRUE;
                continue;
            }

            //
            // sanity check of user supplied data
            //
            dwSecurityMask = pSearchPrefs[i].vValue.Integer;

            if (dwSecurityMask > (OWNER_SECURITY_INFORMATION |
                                  GROUP_SECURITY_INFORMATION |
                                  SACL_SECURITY_INFORMATION  |
                                  DACL_SECURITY_INFORMATION)) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;                                  
            }

            //
            // enable the option
            //
            pLdapPref->_fSecurityDescriptorControl = TRUE;
            pLdapPref->_SecurityDescriptorMask = static_cast<SECURITY_INFORMATION>(dwSecurityMask);
            
            break;

        default:
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
            fWarning = TRUE;
            continue;
        }
    }


error:

    if (pUTF8Target)
        FreeADsMem(pUTF8Target);

    //
    // Need to return the hr if it was something like out of mem.
    // Most often though it will be either S_OK or s-error ocurred.
    //
    if (FAILED(hr)) {
        //
        // Free sort keys and dirsync data if applicable
        //
        if (pLdapPref->_pSortKeys) {
            FreeSortKeys(pLdapPref->_pSortKeys, pLdapPref->_nSortKeys);
            pLdapPref->_pSortKeys = NULL;
            pLdapPref->_nSortKeys = 0;
        }

        if (pLdapPref->_pProvSpecific) {
            if (pLdapPref->_pProvSpecific->lpValue) {
                FreeADsMem(pLdapPref->_pProvSpecific->lpValue);
            }
            FreeADsMem(pLdapPref->_pProvSpecific);
            pLdapPref->_pProvSpecific = NULL;
        }

        //
        // Free VLV information if applicable
        //
        if (pLdapPref->_pVLVInfo) {
            FreeLDAPVLVInfo(pLdapPref->_pVLVInfo);
            pLdapPref->_pVLVInfo = NULL;
        }

        //
        // Free attrib-scoped query if applicable
        //
        if (pLdapPref->_pAttribScoped) {
            FreeADsStr(pLdapPref->_pAttribScoped);
            pLdapPref->_pAttribScoped = NULL;
        }
        RRETURN(hr);
    }

    RRETURN (fWarning ? S_ADS_ERRORSOCCURRED : S_OK);
}


HRESULT
ADsExecuteSearch(
    IN LDAP_SEARCH_PREF LdapPref,
    IN LPWSTR pszADsPath,
    IN LPWSTR pszLdapServer,
    IN LPWSTR pszLdapDn,
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{
    PLDAP_SEARCHINFO phSearchInfo = NULL;
    LPWSTR szCurrAttr = NULL;
    DWORD dwAttrNamesLen = 0;
    HRESULT hr = S_OK;
    ULONG i, j;
    LPWSTR pszAttrNameBuffer = NULL, *ppszAttrs = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    //
    // Initilize so that we wont end up freeing bad data.
    //
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (!phSearchHandle ) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    //
    // Allocate search handle
    //
    phSearchInfo = (PLDAP_SEARCHINFO) AllocADsMem(sizeof(LDAP_SEARCHINFO));
    if(!phSearchInfo)
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);


    memset(phSearchInfo, 0, sizeof(LDAP_SEARCHINFO));

    phSearchInfo->_pszADsPathContext = AllocADsStr(pszADsPath);
    if(!(phSearchInfo->_pszADsPathContext))
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);

    if (pszSearchFilter) {
        phSearchInfo->_pszSearchFilter = AllocADsStr(pszSearchFilter);
    }
    else {
        phSearchInfo->_pszSearchFilter = AllocADsStr(L"(objectClass=*)");
    }
    if(!(phSearchInfo->_pszSearchFilter))
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);

    if (pszLdapServer) {
        phSearchInfo->_pszLdapServer = AllocADsStr(pszLdapServer);
        if (!phSearchInfo->_pszLdapServer) {
           BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    if (pszLdapDn) {
        phSearchInfo->_pszBindContextDn = AllocADsStr(pszLdapDn);
        if(!(phSearchInfo->_pszBindContextDn)){

            BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);
        }
    }

    phSearchInfo->_fADsPathPresent = FALSE;
    phSearchInfo->_fADsPathReturned = FALSE;
    phSearchInfo->_fADsPathOnly = FALSE;

    if (dwNumberAttributes == -1) {
        //
        // Specifies returning all attributes
        //

        phSearchInfo->_ppszAttrs = NULL;
        phSearchInfo->_pszAttrNameBuffer = NULL;
        phSearchInfo->_fADsPathPresent = TRUE;
    }
    else {
        ppszAttrs = (LPWSTR *) AllocADsMem(
                                  sizeof(LPWSTR) *
                                  (dwNumberAttributes + 1)
                                  );
        if (!ppszAttrs)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        for (i = 0; i < dwNumberAttributes; i++)
            dwAttrNamesLen+= (wcslen(pAttributeNames[i]) + 1) * sizeof(WCHAR);

        pszAttrNameBuffer = (LPWSTR) AllocADsMem(
                                         dwAttrNamesLen
                                         );
        if (!pszAttrNameBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        szCurrAttr = pszAttrNameBuffer;
        for (i = 0, j = 0; i < dwNumberAttributes; i++) {

            wcscpy(szCurrAttr, pAttributeNames[i]);
            ppszAttrs[j] = szCurrAttr;
            szCurrAttr += wcslen(ppszAttrs[j]) + 1;

            if(_wcsicmp(ppszAttrs[j], L"ADsPath") == 0) {
                //
                // This attribute need not be sent
                //

                phSearchInfo->_fADsPathPresent = TRUE;
            }
            else {

                j++;
            }

        }

        // If the query requests only ADsPath, then set ppszAttrs[0] to some
        // attribute. Setting it to NULL results in all attributes being
        // returned, which is a huge performance hit. Instead, request only
        // the objectclass (guaranteed to be present on all LDAP servers).
        if (0 == j)
        {
            FreeADsMem(pszAttrNameBuffer);
            pszAttrNameBuffer = (LPWSTR) AllocADsStr(L"objectClass");
            if(pszAttrNameBuffer == NULL) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            FreeADsMem(ppszAttrs);
            ppszAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * 2);
            if(ppszAttrs == NULL) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
                                  
            ppszAttrs[0] = pszAttrNameBuffer;
            ppszAttrs[1] = NULL;

            phSearchInfo->_fADsPathOnly = TRUE;
        }
        else
            ppszAttrs[j] = NULL;

        phSearchInfo->_ppszAttrs = ppszAttrs;
        phSearchInfo->_pszAttrNameBuffer = pszAttrNameBuffer;
    }


    hr = ADsObject(pszADsPath, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    phSearchInfo->_dwPort = pObjectInfo->PortNumber;

    phSearchInfo->_pConnection = NULL;
    phSearchInfo->_hPagedSearch = NULL;
    phSearchInfo->_pSearchResults = NULL;
    phSearchInfo->_cSearchResults = 0;
    phSearchInfo->_dwCurrResult = 0;
    phSearchInfo->_dwMaxResultGot = 0;
    phSearchInfo->_currMsgId = (DWORD) -1;
    phSearchInfo->_pCurrentRow = NULL;
    phSearchInfo->_pFirstAttr = NULL;
    phSearchInfo->_fLastResult = FALSE;
    phSearchInfo->_fLastPage = FALSE;
    phSearchInfo->_fBefFirstRow = TRUE;
    phSearchInfo->_hrLastSearch = S_OK;
    phSearchInfo->_fNonFatalErrors = FALSE;
    phSearchInfo->_fAbandon = FALSE;
    phSearchInfo->_dwVLVOffset = 0;
    phSearchInfo->_dwVLVCount  = 0;
    phSearchInfo->_pVLVContextID = NULL;
    phSearchInfo->_pBerValAttribScoped = NULL;

    //
    // Copy the search preference structure and also make a copy of the memory
    // that the internal pointers point to. This can probably be done better by
    // an assignment operator.
    //
    phSearchInfo->_SearchPref = LdapPref;
    phSearchInfo->_SearchPref._pVLVInfo = NULL;
    phSearchInfo->_SearchPref._pAttribScoped = NULL;

    // sorting
    if (LdapPref._pSortKeys) {

        phSearchInfo->_SearchPref._pSortKeys = (PLDAPSortKey) AllocADsMem(
                                            sizeof(LDAPSortKey) * LdapPref._nSortKeys);
        if (!phSearchInfo->_SearchPref._pSortKeys) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(
            phSearchInfo->_SearchPref._pSortKeys,
            LdapPref._pSortKeys,
            sizeof(LDAPSortKey) * LdapPref._nSortKeys
            );

        //
        // We need to copy over all the attibutes.
        //
        for (i=0; i < LdapPref._nSortKeys; i++) {
            phSearchInfo->_SearchPref._pSortKeys[i].sk_attrtype =
                AllocADsStr( LdapPref._pSortKeys[i].sk_attrtype);

            if (!phSearchInfo->_SearchPref._pSortKeys[i].sk_attrtype) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

    }

    // VLV
    if (LdapPref._pVLVInfo) {
        hr = CopyLDAPVLVInfo(LdapPref._pVLVInfo, &(phSearchInfo->_SearchPref._pVLVInfo));
        BAIL_ON_FAILURE(hr);
    }

    // Attribute-scoped query
    if (LdapPref._pAttribScoped) {
        phSearchInfo->_SearchPref._pAttribScoped = AllocADsStr(LdapPref._pAttribScoped);
        if (!(phSearchInfo->_SearchPref._pAttribScoped)) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    *phSearchHandle = phSearchInfo;

    FreeObjectInfo(pObjectInfo);

    RRETURN(S_OK);

error:

    FreeObjectInfo(pObjectInfo);

    if(phSearchInfo) {

       if (phSearchInfo->_pszLdapServer) {
          FreeADsStr(phSearchInfo->_pszLdapServer);
       }

        if(phSearchInfo->_pszBindContextDn)
            FreeADsStr(phSearchInfo->_pszBindContextDn);

        if(phSearchInfo->_pszADsPathContext)
            FreeADsStr(phSearchInfo->_pszADsPathContext);

        if(phSearchInfo->_pszSearchFilter)
            FreeADsStr(phSearchInfo->_pszSearchFilter);

        if(phSearchInfo->_ppszAttrs)
            FreeADsMem(phSearchInfo->_ppszAttrs);
        else if(ppszAttrs)
            FreeADsMem(ppszAttrs);

        if(phSearchInfo->_pszAttrNameBuffer)
            FreeADsMem(phSearchInfo->_pszAttrNameBuffer);
        else if(pszAttrNameBuffer)
            FreeADsMem(pszAttrNameBuffer);

        if (phSearchInfo->_SearchPref._pVLVInfo) {
            FreeLDAPVLVInfo(phSearchInfo->_SearchPref._pVLVInfo);
        }

        if (phSearchInfo->_SearchPref._pAttribScoped) {
            FreeADsStr(phSearchInfo->_SearchPref._pAttribScoped);
        }

        FreeADsMem(phSearchInfo);
    }

    RRETURN (hr);
}


HRESULT
ADsAbandonSearch(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    DWORD dwStatus = 0;

    // If there is an outstanding message id, call LdapAbandon
    //
    if (phSearchInfo->_currMsgId != (DWORD) -1) {

        dwStatus = LdapAbandon(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_currMsgId
                       );
    }
    //
    // Make sure that we don't do extra searches anymore. We only give back
    // whatever rows we have already received from the server
    //

    phSearchInfo->_fAbandon = TRUE;

    RRETURN(S_OK);

}
HRESULT
ADsCloseSearchHandle (
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{

    HRESULT hr = S_OK;
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    DWORD i=0;

    if (!phSearchInfo)
        RRETURN (E_ADS_BAD_PARAMETER);

    if (phSearchInfo->_pszLdapServer)
       FreeADsStr(phSearchInfo->_pszLdapServer);

    if(phSearchInfo->_pszBindContextDn)
        FreeADsStr(phSearchInfo->_pszBindContextDn);

    if(phSearchInfo->_pszADsPathContext)
        FreeADsStr(phSearchInfo->_pszADsPathContext);

    if(phSearchInfo->_pszSearchFilter)
        FreeADsStr(phSearchInfo->_pszSearchFilter);

    if(phSearchInfo->_ppszAttrs)
        FreeADsMem(phSearchInfo->_ppszAttrs);

    if(phSearchInfo->_pszAttrNameBuffer)
        FreeADsMem(phSearchInfo->_pszAttrNameBuffer);


    if (phSearchInfo->_pSearchResults) {
        for (DWORD i=0; i <= phSearchInfo->_dwMaxResultGot; i++) {
            LdapMsgFree(
                phSearchInfo->_pSearchResults[i]
                );
        }
        FreeADsMem(phSearchInfo->_pSearchResults);
    }

    if (phSearchInfo->_hPagedSearch) {
        LdapSearchAbandonPage( phSearchInfo->_pConnection,
                               phSearchInfo->_hPagedSearch
                               );
    }

    //
    // Free ServerControls
    //
    if (phSearchInfo->_ServerControls) {

        //
        // This code assumes there are only VLV, sort, dirsync,
        // security descriptor & attribute-scoped query controls.
        // If more controls are added, modify the code accordingly.
        // Nothing needs to be freed for the dirsync control for now.
        // Freeing the searchpref will take care of the controls data.
        //
        for (i=0; phSearchInfo->_ServerControls[i]; i++) {

            BOOL fSortControl = FALSE;
            BOOL fVLVControl = FALSE;
            BOOL fSecDescControl = FALSE;

            if (phSearchInfo->_ServerControls[i]->ldctl_oid) {
                // Compare with sort control
                if (wcscmp(
                        phSearchInfo->_ServerControls[i]->ldctl_oid,
                        LDAP_SERVER_SORT_OID_W
                        ) == 0 ) {
                    fSortControl = TRUE;
                } else {
                    fSortControl = FALSE;
                }

                // Compare with VLV control
                if (wcscmp(
                        phSearchInfo->_ServerControls[i]->ldctl_oid,
                        LDAP_CONTROL_VLVREQUEST_W
                        ) == 0 ) {
                    fVLVControl = TRUE;
                } else {
                    fVLVControl = FALSE;
                }

                // Compare with security descriptor control
                if (wcscmp(
                        phSearchInfo->_ServerControls[i]->ldctl_oid,
                        LDAP_SERVER_SD_FLAGS_OID_W
                        ) == 0 ) {
                    fSecDescControl = TRUE;
                } else {
                    fSecDescControl = FALSE;
                }
                
            }

            //
            // Free the sort control if this is it.
            //
            if (fSortControl) {

                if (phSearchInfo->_ServerControls[i]->ldctl_oid != NULL) {
                    ldap_memfree( phSearchInfo->_ServerControls[i]->ldctl_oid );
                }

                if (phSearchInfo->_ServerControls[i]->ldctl_value.bv_val != NULL) {
                    ldap_memfreeA( phSearchInfo->_ServerControls[i]->ldctl_value.bv_val );
                }

            }

            //
            // Free the security descriptor control if this is it
            //
            if (fSecDescControl) {
            
                if (phSearchInfo->_ServerControls[i]->ldctl_value.bv_val != NULL) {
                    FreeADsMem( phSearchInfo->_ServerControls[i]->ldctl_value.bv_val );
                }
            }
            
            //
            // Need to free the control if sort or not.
            // Exception: VLV control is freed with LdapControlFree,
            // not with FreeADsMem
            //
            if (fVLVControl) {
                LdapControlFree( phSearchInfo->_ServerControls[i] );
            }
            else {
                FreeADsMem( phSearchInfo->_ServerControls[i] );
            }
        }

        FreeADsMem( phSearchInfo->_ServerControls );

    }

    //
    // Free SearchPref data
    //
    FreeSortKeys(
        phSearchInfo->_SearchPref._pSortKeys,
        phSearchInfo->_SearchPref._nSortKeys
        );

    FreeLDAPVLVInfo(phSearchInfo->_SearchPref._pVLVInfo);

    if (phSearchInfo->_SearchPref._pAttribScoped)
        FreeADsStr(phSearchInfo->_SearchPref._pAttribScoped);

    //
    // Free Dirsync control infromation.
    //
    if (phSearchInfo->_SearchPref._fDirSync) {
        if (phSearchInfo->_SearchPref._pProvSpecific) {
            //
            // Free the data if applicable.
            //
            if (phSearchInfo->_SearchPref._pProvSpecific->lpValue) {
                FreeADsMem(phSearchInfo->_SearchPref._pProvSpecific->lpValue);
            }
            //
            // Free the struct itself
            //
            FreeADsMem(phSearchInfo->_SearchPref._pProvSpecific);
            phSearchInfo->_SearchPref._pProvSpecific = NULL;
        }
    }


    if (phSearchInfo->_pVLVContextID) {
        if (phSearchInfo->_pVLVContextID->bv_val) {
            FreeADsMem(phSearchInfo->_pVLVContextID->bv_val);
        }
        
        FreeADsMem(phSearchInfo->_pVLVContextID);
    }
    if (phSearchInfo->_pBerVal) {
        ber_bvfree(phSearchInfo->_pBerVal);
    }

    if (phSearchInfo->_pBerValAttribScoped) {
        ber_bvfree(phSearchInfo->_pBerValAttribScoped);
    }
    
    if(phSearchInfo->_pConnection)
        LdapCloseObject(
            phSearchInfo->_pConnection
            );

    FreeADsMem(phSearchInfo);


    RRETURN (hr);
}


HRESULT
ADsGetFirstRow(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN CCredentials& Credentials
    )
{

    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR, dwStatus2 = NO_ERROR;
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    LDAP *ld = NULL;
    BOOL fNewOptionSet = FALSE;

    DWORD oldOption = 0;
    DWORD newOption = 0;

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if(!phSearchInfo->_pConnection) {

        hr = LdapOpenObject(
                       phSearchInfo->_pszLdapServer,
                       phSearchInfo->_pszBindContextDn,
                       &phSearchInfo->_pConnection,
                       Credentials,
                       phSearchInfo->_dwPort
                       );
        BAIL_ON_FAILURE(hr);

        //
        // Set the preferences like deref aliases, time limit and size limit
        //
        if (ld = phSearchInfo->_pConnection->LdapHandle) {
            ld->ld_deref = phSearchInfo->_SearchPref._dwDerefAliases;
            ld->ld_sizelimit = phSearchInfo->_SearchPref._dwSizeLimit;
            ld->ld_timelimit = phSearchInfo->_SearchPref._dwTimeLimit;
        }

        hr = AddSearchControls(phSearchInfo, Credentials);
        BAIL_ON_FAILURE(hr);

    }

    ld = phSearchInfo->_pConnection->LdapHandle;
    dwStatus = ldap_get_option(
                   ld,
                   LDAP_OPT_REFERRALS,
                   &(oldOption)
                   );

    newOption = phSearchInfo->_SearchPref._dwChaseReferrals;

    dwStatus2 = ldap_set_option(
                    ld,
                    LDAP_OPT_REFERRALS,
                    &(newOption)
                    );

    if (dwStatus == NO_ERROR && dwStatus2 == NO_ERROR)
        fNewOptionSet = TRUE;

    if(!phSearchInfo->_pSearchResults) {
        //
        // Get the results. This function uses various members of pSearchInfo
        // and returns the result in phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
        // which can be used to call LdapFirstEntry and LdapNextEntry
        //
        hr = ADsGetResults(
                 phSearchInfo
                 );

        //
        // Update the VLV server response if applicable
        //
        if (phSearchInfo->_SearchPref._pVLVInfo
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrVLV = S_OK;

            hrVLV = StoreVLVInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );

            //
            // we only care if storing the cookie failed
            // if the search otherwise succeeded
            //
            if (FAILED(hrVLV) && SUCCEEDED(hr)) {
                hr = hrVLV;
            }
        }

        //
        // Update the Attribute-Scoped Query info if applicable
        //
        if (phSearchInfo->_SearchPref._pAttribScoped
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrASQ = S_OK;

            hrASQ = StoreAttribScopedInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );
                        
            //
            // we only care if storing the info failed
            // if the search otherwise succeeded
            //
            if (FAILED(hrASQ) && SUCCEEDED(hr)) {
                hr = hrASQ;
            }
            
        }
        
        //
        // Update the dirsync control cookie if applicable.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {
            //
            // Store the cookie info in searchprefs.
            //
            StoreDirSyncCookie(
                phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                phSearchInfo
                );

            while (hr == S_ADS_NOMORE_ROWS) {
                //
                // Try and get more results - this will handle the
                // case of the DirSync cookie indicating more rows
                // correctly.
                //
                hr = ADsGetMoreResultsDirSync(
                         phSearchInfo,
                         Credentials
                         );

                BAIL_ON_FAILURE(hr);

            }
        }

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS) {
            goto error;
        }

    }

    //
    // Need to set the cur result to 0 as it maybe a case
    // where we are now going back to the top of a multiple
    // page search. This will make no difference if the cache
    // is turned off.
    //
    phSearchInfo->_dwCurrResult = 0;

    hr = LdapFirstEntry(
                   phSearchInfo->_pConnection,
                   phSearchInfo->_pSearchResults[0],
                   &phSearchInfo->_pCurrentRow
                   );

    BAIL_ON_FAILURE(hr);

    if(phSearchInfo->_pCurrentRow) {
        phSearchInfo->_pFirstAttr = NULL;
        phSearchInfo->_fBefFirstRow = FALSE;
        hr = S_OK;
    }
    else {
        hr = S_ADS_NOMORE_ROWS;
        //
        // Might be DirSync case where we need to try fetch
        // more results.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_fMoreDirSync ) {
            //
            // Try and get more results - this will handle the
            // case of the DirSync cookie indicating more rows
            // correctly.
            //
            hr = ADsGetMoreResultsDirSync(
                     phSearchInfo,
                     Credentials
                     );

            BAIL_ON_FAILURE(hr);
        }
    }

error:

    if (ld && fNewOptionSet) {
        ldap_set_option(
            ld,
            LDAP_OPT_REFERRALS,
            &(oldOption)
        );
    }

    //
    // When there is no more rows to be returned, return whatever error
    // that was returned from the last search
    //
    if (hr == S_ADS_NOMORE_ROWS) {
        if (phSearchInfo->_hrLastSearch != S_OK) {
            RRETURN(phSearchInfo->_hrLastSearch);
        }
        else if (phSearchInfo->_fNonFatalErrors) {
            RRETURN(S_ADS_ERRORSOCCURRED);
        }
        else {
            RRETURN(hr);
        }
    }
    else {
        RRETURN(hr);
    }
}

HRESULT
ADsGetNextRow(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR, dwStatus2 = NO_ERROR;
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    LDAP *ld = NULL;
    BOOL fNewOptionSet = FALSE;


    DWORD oldOption = 0;
    DWORD newOption = 0;

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if(!phSearchInfo->_pConnection) {

        hr = LdapOpenObject(
                       phSearchInfo->_pszLdapServer,
                       phSearchInfo->_pszBindContextDn,
                       &phSearchInfo->_pConnection,
                       Credentials,
                       phSearchInfo->_dwPort
                       );
        BAIL_ON_FAILURE(hr);

        //
        // Set the preferences like deref aliases, time limit and size limit
        //
        if (ld = phSearchInfo->_pConnection->LdapHandle) {
            ld->ld_deref = phSearchInfo->_SearchPref._dwDerefAliases;
            ld->ld_sizelimit = phSearchInfo->_SearchPref._dwSizeLimit;
            ld->ld_timelimit = phSearchInfo->_SearchPref._dwTimeLimit;
        }

        hr = AddSearchControls(phSearchInfo, Credentials);
        BAIL_ON_FAILURE(hr);

    }

    ld = phSearchInfo->_pConnection->LdapHandle;
    dwStatus = ldap_get_option(
                  ld,
                  LDAP_OPT_REFERRALS,
                  &(oldOption)
                  );

    newOption = phSearchInfo->_SearchPref._dwChaseReferrals;

    dwStatus2 = ldap_set_option(
                   ld,
                   LDAP_OPT_REFERRALS,
                   &(newOption)
                   );

    if (dwStatus == NO_ERROR && dwStatus2 == NO_ERROR)
        fNewOptionSet = TRUE;

    if(!phSearchInfo->_pSearchResults) {
        //
        // Get the results. This function uses various members of pSearchInfo
        // and returns the result in phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
        // which can be used to call LdapFirstEntry and LdapNextEntry
        //
        hr = ADsGetResults(
                 phSearchInfo
                 );

        //
        // Update the dirsync control cookie if applicable.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {
            //
            // Store the cookie info in searchprefs.
            //
            StoreDirSyncCookie(
                phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                phSearchInfo
                );
        }


        //
        // Update the VLV server response if applicable
        //
        if (phSearchInfo->_SearchPref._pVLVInfo
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrVLV = S_OK;

            hrVLV = StoreVLVInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );

            //
            // we only care if storing the cookie failed if the search
            // otherwise succeeded
            //
            if (FAILED(hrVLV) && SUCCEEDED(hr)) {
                hr = hrVLV;
            }
        }

        //
        // Update the Attribute-Scoped Query info if applicable
        //
        if (phSearchInfo->_SearchPref._pAttribScoped
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrASQ = S_OK;

            hrASQ = StoreAttribScopedInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );
                        
            //
            // we only care if storing the info failed
            // if the search otherwise succeeded
            //
            if (FAILED(hrASQ) && SUCCEEDED(hr)) {
                hr = hrASQ;
            }
            
        }

        if (hr == S_ADS_NOMORE_ROWS) {
            //
            // Try and get more results - this will handle the
            // case of the DirSync cookie indicating more rows
            // correctly.
            //
            hr = ADsGetMoreResultsDirSync(
                     phSearchInfo,
                     Credentials
                     );

            BAIL_ON_FAILURE(hr);

        }

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS) {
            goto error;
        }

    }

    //
    // If the current row has not been obtained, get it now. Need to
    // distinguish between the case where we are after the end of the result
    // from the case where we are before the beginning of the result. In
    // both cases _pCurrentRow is NULL, but _fBefFirstRow is TRUE only in
    // the latter case.
    //
    if(!phSearchInfo->_pCurrentRow) {
        if(phSearchInfo->_fBefFirstRow)
        {
            //
            // Call the ldap specific function to get the first row.
            //
            hr = LdapFirstEntry(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                       &phSearchInfo->_pCurrentRow
                       );
        }
    }
    else {
        //
        // Call the ldap specific function to get the next row
        //
        hr = LdapNextEntry(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pCurrentRow,
                       &phSearchInfo->_pCurrentRow
                       );
    }

    if (!phSearchInfo->_pCurrentRow
        && (phSearchInfo->_dwCurrResult < phSearchInfo->_dwMaxResultGot)) {
        //
        // In this case we need to proceed to the next result in memory
        //
        hr = S_OK;
        while (!phSearchInfo->_pCurrentRow
               && phSearchInfo->_dwCurrResult < phSearchInfo->_dwMaxResultGot
               && SUCCEEDED(hr)) {

            //
            // With Dirsync we may have results that do not have
            // any entries in them, but the next one may.
            //

            phSearchInfo->_dwCurrResult++;

            hr = LdapFirstEntry(
                     phSearchInfo->_pConnection,
                     phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                     &phSearchInfo->_pCurrentRow
                     );

        }

    }
    else if (!phSearchInfo->_pCurrentRow
             && (!phSearchInfo->_fLastResult
                 || !phSearchInfo->_fLastPage
                 || phSearchInfo->_fMoreDirSync )
             ) {

        //
        // Now if both lastResult and page are true, we need to call
        // ADsGetMoreResultsDirSync. This is the unusual case.
        //
        if (phSearchInfo->_fLastResult && phSearchInfo->_fLastPage) {
            hr = ADsGetMoreResultsDirSync(
                     phSearchInfo,
                     Credentials
                     );
        }
        else {
            //
            // This means that there are more results to be obtained
            // although the current result has reached its end.
            // Call the function to get more results in
            // phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
            // It will increment _dwCurrResult and reallocate if needed.
            //
            hr = ADsGetMoreResults(
                     phSearchInfo
                     );
        }

        //
        // In async searches, we will know if we have to call
        // ADsGetMoreResultsAsync only now. So recheck.
        //
        if (hr == S_ADS_NOMORE_ROWS
            && phSearchInfo->_SearchPref._fAsynchronous
            ) {
            if (phSearchInfo->_fLastResult && phSearchInfo->_fLastPage) {
                hr = ADsGetMoreResultsDirSync(
                         phSearchInfo,
                         Credentials
                         );
            }
        }

        //
        // Update the dirsync control cookie if applicable.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {
            //
            // Store the cookie info in searchprefs.
            //
            StoreDirSyncCookie(
                phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                phSearchInfo
                );
        }

        //
        // Update the Attribute-Scoped Query info if applicable
        //
        if (phSearchInfo->_SearchPref._pAttribScoped
            && phSearchInfo->_pSearchResults
            && phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) {

            HRESULT hrASQ = S_OK;

            hrASQ = StoreAttribScopedInfo(
                        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                        phSearchInfo
                        );
                        
            //
            // we only care if storing the info failed
            // if the search otherwise succeeded
            //
            if (FAILED(hrASQ) && SUCCEEDED(hr)) {
                hr = hrASQ;
            }
            
        }

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS) {
            goto error;
        }

        hr = LdapFirstEntry(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                       &phSearchInfo->_pCurrentRow
                       );
        if (!phSearchInfo->_pCurrentRow) {
            //
            // This means that we can possibly have more results
            // but this time we did not get any - not yet a NULL
            // cookie on a paged search that is.
            //
            ADsSetLastError(
                ERROR_MORE_DATA,
                L"Calling GetNextRow can potentially return more results.",
                L"LDAP Provider"
                );
        }
    }

    BAIL_ON_FAILURE(hr);

    if(phSearchInfo->_pCurrentRow) {
        phSearchInfo->_pFirstAttr = NULL;
        phSearchInfo->_fBefFirstRow = FALSE;
        hr = S_OK;
    }
    else {
        hr = S_ADS_NOMORE_ROWS;
        //
        // Might be DirSync case where we need to try fetch
        // more results.
        //
        if (phSearchInfo->_SearchPref._fDirSync
            && phSearchInfo->_fMoreDirSync ) {
            //
            // Try and get more results - this will handle the
            // case of the DirSync cookie indicating more rows
            // correctly.
            //
            hr = ADsGetMoreResultsDirSync(
                     phSearchInfo,
                     Credentials
                     );
            BAIL_ON_FAILURE(hr);

        }
    }
error:

    if (ld && fNewOptionSet) {
        ldap_set_option(
            ld,
            LDAP_OPT_REFERRALS,
            &(oldOption)
        );
    }

    //
    // When there is no more rows to be returned, return whatever error
    // that was returned from the last search
    //
    if (hr == S_ADS_NOMORE_ROWS) {
        if (phSearchInfo->_hrLastSearch != S_OK) {
            RRETURN(phSearchInfo->_hrLastSearch);
        }
        else if (phSearchInfo->_fNonFatalErrors) {
            RRETURN(S_ADS_ERRORSOCCURRED);
        }
        else {
            RRETURN(hr);
        }
    }
    else {
        RRETURN(hr);
    }

}

//
// Function to get the results by performing the appropriate search depending
// on the preferences; Paged Results, Sorting, Synchronous, Asynchrnous or
// Timed Synchronous
//

HRESULT
ADsGetResults(
    IN PLDAP_SEARCHINFO phSearchInfo
    )
{

    HRESULT hr = S_OK;
    DWORD dwError;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    ULONG totalCount;
    int resType;

    ADsAssert(phSearchInfo);

    //
    // If abandon has been called, we don't get more results.
    //
    if (phSearchInfo->_fAbandon) {
        RRETURN(S_ADS_NOMORE_ROWS);
    }

    if(!phSearchInfo->_pSearchResults) {
        //
        // Allocate an array of handles to Search Results
        //
        phSearchInfo->_pSearchResults = (LDAPMessage **) AllocADsMem(
                                             sizeof(LDAPMessage *) *
                                             NO_LDAP_RESULT_HANDLES);
        if(!phSearchInfo->_pSearchResults) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        phSearchInfo->_dwCurrResult = 0;
        phSearchInfo->_cSearchResults = NO_LDAP_RESULT_HANDLES;
        //
        // Should also set the cur max to 0;
        //
        phSearchInfo->_dwMaxResultGot = 0;
    }

    // Initialize Result to NULL
    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult] = NULL;

    //
    // Call the ldap specific search function
    //
    if (phSearchInfo->_SearchPref._dwPageSize != 0) {
        //
        // Paged results
        //
        if(!phSearchInfo->_hPagedSearch ) {

            hr = LdapSearchInitPage(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_pszBindContextDn,
                           phSearchInfo->_SearchPref._dwSearchScope,
                           phSearchInfo->_pszSearchFilter,
                           phSearchInfo->_ppszAttrs,
                           phSearchInfo->_SearchPref._fAttrsOnly,
                           phSearchInfo->_ServerControls,
                           phSearchInfo->_ClientControls,
                           phSearchInfo->_SearchPref._dwPagedTimeLimit,
                           phSearchInfo->_SearchPref._dwSizeLimit,
                           NULL,
                           &phSearchInfo->_hPagedSearch
                           );

            BAIL_ON_FAILURE(hr);

        }

        if ( phSearchInfo->_SearchPref._fAsynchronous ) {

            hr = LdapGetNextPage(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           phSearchInfo->_SearchPref._dwPageSize,
                           (ULONG *)&phSearchInfo->_currMsgId
                           );

            if (FAILED(hr)) {
                if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                    phSearchInfo->_fLastPage = TRUE;
                    RRETURN(S_ADS_NOMORE_ROWS);
                } else {
                    BAIL_ON_FAILURE(hr);
                }
            }

            //
            // Wait for one page worth of results to get back.
            //

            hr = LdapResult(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_currMsgId,
                           LDAP_MSG_ALL,
                           phSearchInfo->_SearchPref._timeout.tv_sec ?
                           &phSearchInfo->_SearchPref._timeout : NULL,
                           &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                           &resType
                           );

            if (FAILED(hr)) {
                if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
                    (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
                    phSearchInfo->_fLastResult = TRUE;
                    RRETURN(S_ADS_NOMORE_ROWS);
                }
                else {
                     BAIL_ON_FAILURE(hr);                    
                }
            }

            hr = LdapGetPagedCount(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           &totalCount,
                           phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                           );
            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                     hr = S_OK;
            }
            
            //
            // if hr failed, we will do the corresponding according to whether there is any result returned in our mechanism later
            //
                
        }
        else {

            hr = LdapGetNextPageS(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           phSearchInfo->_SearchPref._timeout.tv_sec ?
                             &phSearchInfo->_SearchPref._timeout : NULL,
                           phSearchInfo->_SearchPref._dwPageSize,
                           &totalCount,
                           &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                           );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                     phSearchInfo->_fLastPage = TRUE;
                     RRETURN(S_ADS_NOMORE_ROWS);
                 }

            //
            // if hr failed, we will do the corresponding according to whether there is any result returned in our mechanism later
            //
                 
            phSearchInfo->_fLastResult = TRUE;
        }

    }
    else if (phSearchInfo->_SearchPref._fAsynchronous) {
        hr = LdapSearchExt(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pszBindContextDn,
                       phSearchInfo->_SearchPref._dwSearchScope,
                       phSearchInfo->_pszSearchFilter,
                       phSearchInfo->_ppszAttrs,
                       phSearchInfo->_SearchPref._fAttrsOnly,
                       phSearchInfo->_ServerControls,
                       phSearchInfo->_ClientControls,
                       phSearchInfo->_SearchPref._dwPagedTimeLimit,
                       phSearchInfo->_SearchPref._dwSizeLimit,
                       &phSearchInfo->_currMsgId
                       );

        BAIL_ON_FAILURE(hr);

        //
        // Wait for atleast one result
        //
        hr = LdapResult(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_currMsgId,
                       LDAP_MSG_RECEIVED,
                       phSearchInfo->_SearchPref._timeout.tv_sec ?
                         &phSearchInfo->_SearchPref._timeout : NULL,
                       &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                       &resType
                       );
        if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
            phSearchInfo->_fLastResult = TRUE;
            RRETURN(S_ADS_NOMORE_ROWS);
        }

        //
        // if hr failed, we will do the corresponding according to whether there is any result returned in our mechanism later
        //
        
        phSearchInfo->_fLastPage = TRUE;
    }
    else if (phSearchInfo->_SearchPref._timeout.tv_sec != 0) {
        hr = LdapSearchExtS(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pszBindContextDn,
                       phSearchInfo->_SearchPref._dwSearchScope,
                       phSearchInfo->_pszSearchFilter,
                       phSearchInfo->_ppszAttrs,
                       phSearchInfo->_SearchPref._fAttrsOnly,
                       phSearchInfo->_ServerControls,
                       phSearchInfo->_ClientControls,
                       &phSearchInfo->_SearchPref._timeout,
                       phSearchInfo->_SearchPref._dwSizeLimit,
                       &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                       );
        phSearchInfo->_fLastResult = TRUE;
        phSearchInfo->_fLastPage = TRUE;
    }
    else {
        hr = LdapSearchExtS(
                       phSearchInfo->_pConnection,
                       phSearchInfo->_pszBindContextDn,
                       phSearchInfo->_SearchPref._dwSearchScope,
                       phSearchInfo->_pszSearchFilter,
                       phSearchInfo->_ppszAttrs,
                       phSearchInfo->_SearchPref._fAttrsOnly,
                       phSearchInfo->_ServerControls,
                       phSearchInfo->_ClientControls,
                       NULL,
                       phSearchInfo->_SearchPref._dwSizeLimit,
                       &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                       );
        phSearchInfo->_fLastResult = TRUE;
        phSearchInfo->_fLastPage = TRUE;
    }

    //
    // Only if there are zero rows returned, return the error,
    // otherwise, store the error and return when GetNextRow is
    // called for the last time
    //
    if (FAILED(hr) &&
        (LdapCountEntries( phSearchInfo->_pConnection,
            phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) == 0)) {
        BAIL_ON_FAILURE(hr);
    }
    else {

         phSearchInfo->_hrLastSearch = hr;
         hr = S_OK;
    }

    phSearchInfo->_pCurrentRow = NULL;

error:

    RRETURN(hr);
}

//
// For Asynchronous or paged searches, more results need to be obtained, once
// the current result set is exhausted. This function gets the next result set
// if one is available. In the case of paged results, this might translate to
// getting the next page.
//

HRESULT
ADsGetMoreResults(
    IN PLDAP_SEARCHINFO phSearchInfo
    )
{

    HRESULT hr = S_OK;
    DWORD dwError;
    LPWSTR pszLDAPPath;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    ULONG totalCount;
    int resType;

    ADsAssert(phSearchInfo);

    //
    // If abandon has been called, we don't get more results.
    //
    if (phSearchInfo->_fAbandon) {
        RRETURN(S_ADS_NOMORE_ROWS);
    }

    if (phSearchInfo->_fLastResult && phSearchInfo->_fLastPage)
        RRETURN (S_ADS_NOMORE_ROWS);

    if (phSearchInfo->_fLastResult == FALSE) {

        //
        // if we need to cache the results, then we save the result in the
        // phSearchInfo->_pSearchResults array. If we don't need to cache it,
        // release the result and save it in the same place.

        if ( phSearchInfo->_SearchPref._fCacheResults ) {

            ADsAssert(phSearchInfo->_dwCurrResult
                      == phSearchInfo->_dwMaxResultGot);

            phSearchInfo->_dwCurrResult++;
            phSearchInfo->_dwMaxResultGot++;
            if (phSearchInfo->_dwCurrResult >= phSearchInfo->_cSearchResults) {
                //
                // Need to allocate more memory for handles
                //
                phSearchInfo->_pSearchResults = (LDAPMessage **) ReallocADsMem(
                                                     (void *) phSearchInfo->_pSearchResults,
                                                     sizeof(LDAPMessage *) *
                                                     phSearchInfo->_cSearchResults,
                                                     sizeof(LDAPMessage *) *
                                                     (phSearchInfo->_cSearchResults +
                                                     NO_LDAP_RESULT_HANDLES));
                if(!phSearchInfo->_pSearchResults) {
                    hr = E_OUTOFMEMORY;
                    phSearchInfo->_dwCurrResult--;
                    phSearchInfo->_dwMaxResultGot--;
                    goto error;
                }
                phSearchInfo->_cSearchResults += NO_LDAP_RESULT_HANDLES;

            }

        }
        else {
            //
            // Release and use the same space to store the next result.
            //
            LdapMsgFree(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
        }

        // Initialize Result to NULL
        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult] = NULL;

        hr = LdapResult(
                 phSearchInfo->_pConnection,
                 phSearchInfo->_currMsgId,
                 LDAP_MSG_RECEIVED,
                 phSearchInfo->_SearchPref._timeout.tv_sec ?
                   &phSearchInfo->_SearchPref._timeout : NULL,
                 &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                 &resType
                 );

        if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
            phSearchInfo->_fLastResult = TRUE;
        }
        else {
            phSearchInfo->_hrLastSearch = hr;
            hr = S_OK;
            RRETURN(hr);
        }

    }

    //
    // The last result has been reached. Check if we need to look for further
    // pages
    //

    if ( phSearchInfo->_fLastPage == FALSE) {

        //
        // if we need to cache the results, then we save the result in the
        // phSearchInfo->_pSearchResults array. If we don't need to cache it,
        // release the result and save it in the same place.

        if ( phSearchInfo->_SearchPref._fCacheResults ) {

            ADsAssert(phSearchInfo->_dwCurrResult
                        == phSearchInfo->_dwMaxResultGot);

            phSearchInfo->_dwCurrResult++;
            phSearchInfo->_dwMaxResultGot++;
            if (phSearchInfo->_dwCurrResult >= phSearchInfo->_cSearchResults) {
                //
                // Need to allocate more memory for handles
                //
                phSearchInfo->_pSearchResults = (LDAPMessage **) ReallocADsMem(
                                                     (void *) phSearchInfo->_pSearchResults,
                                                     sizeof(LDAPMessage *) *
                                                     phSearchInfo->_cSearchResults,
                                                     sizeof(LDAPMessage *) *
                                                     (phSearchInfo->_cSearchResults +
                                                     NO_LDAP_RESULT_HANDLES));
                if(!phSearchInfo->_pSearchResults) {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                phSearchInfo->_cSearchResults += NO_LDAP_RESULT_HANDLES;

            }
        }
        else {
            //
            // Release and use the same space to store the next result.
            //
            LdapMsgFree(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
        }

        // Initialize Result to NULL
        phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult] = NULL;

        if ( phSearchInfo->_SearchPref._fAsynchronous ) {

            hr = LdapGetNextPage(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           phSearchInfo->_SearchPref._dwPageSize,
                           (ULONG *) &phSearchInfo->_currMsgId
                           );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                phSearchInfo->_fLastPage = TRUE;

                if (phSearchInfo->_SearchPref._fCacheResults) {
                    phSearchInfo->_dwCurrResult--;
                    phSearchInfo->_dwMaxResultGot--;
                }

                RRETURN(S_ADS_NOMORE_ROWS);
            }
            BAIL_ON_FAILURE(hr);

            //
            // Wait for one page worth of results to get back.
            //
            hr = LdapResult(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_currMsgId,
                           LDAP_MSG_ALL,
                           phSearchInfo->_SearchPref._timeout.tv_sec ?
                             &phSearchInfo->_SearchPref._timeout : NULL,
                           &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                           &resType
                           );

            phSearchInfo->_fLastResult = FALSE;

            if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
                (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
                phSearchInfo->_fLastResult = TRUE;
                RRETURN(S_ADS_NOMORE_ROWS);
            }
            BAIL_ON_FAILURE(hr);

            hr = LdapGetPagedCount(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           &totalCount,
                           phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                           );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                hr = S_OK;
            }
            BAIL_ON_FAILURE(hr);

        }
        else {

            hr = LdapGetNextPageS(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_hPagedSearch,
                           phSearchInfo->_SearchPref._timeout.tv_sec ?
                             &phSearchInfo->_SearchPref._timeout : NULL,
                           phSearchInfo->_SearchPref._dwPageSize,
                           &totalCount,
                           &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                           );

            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED)) {
                //
                // Since we hit the last page we need to get the
                // count of the max and currResults down by one.
                //
                if (phSearchInfo->_SearchPref._fCacheResults) {
                    phSearchInfo->_dwCurrResult--;
                    phSearchInfo->_dwMaxResultGot--;
                }
                phSearchInfo->_fLastPage = TRUE;
                RRETURN(S_ADS_NOMORE_ROWS);
            }
            BAIL_ON_FAILURE(hr);

        }
        RRETURN(S_OK);
    }

    //
    // If we came here, we have reached the end
    //

    hr = S_ADS_NOMORE_ROWS;

error:

    RRETURN(hr);
}

HRESULT
ADsGetPreviousRow(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN CCredentials& Credentials
    )
{
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    LDAPMessage *pTmpRow, *pTargetRow, *pPrevRow = NULL;
    DWORD dwOrigCurrResult;
    HRESULT hr;

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if(!phSearchInfo->_pConnection) {
    // cannot ask for previous row if connection not established
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if(!phSearchInfo->_pSearchResults) {
    // cannot ask for previous row if no results have been obtained
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    // save value in case we need to restore later
    dwOrigCurrResult = phSearchInfo->_dwCurrResult;

    if(NULL == phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult])
    // we are at the end of the entire search result list
    {
        ADsAssert(!phSearchInfo->_pCurrentRow);

        if(phSearchInfo->_dwCurrResult > 0)
        // we need to get the last entry of the previous result
            phSearchInfo->_dwCurrResult--;
        else
        {
            phSearchInfo->_fBefFirstRow = TRUE;
            RRETURN(S_ADS_NOMORE_ROWS);
        }
    }

    ADsAssert(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    hr = LdapFirstEntry(phSearchInfo->_pConnection,
                    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                    &pTmpRow);
    BAIL_ON_FAILURE(hr);

    // row whose predecessor we are looking for (this may be NULL)
    pTargetRow = phSearchInfo->_pCurrentRow;

    if(pTmpRow == pTargetRow)
    // we are at the first row of the current result
    {
        if(phSearchInfo->_dwCurrResult > 0)
        {
            // we need to get the last entry of the previous result
            phSearchInfo->_dwCurrResult--;
            pTargetRow = NULL;

            hr = LdapFirstEntry(phSearchInfo->_pConnection,
                    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                    &pTmpRow);
            BAIL_ON_FAILURE(hr);
        }
        else
        {
            phSearchInfo->_pCurrentRow = NULL;
            phSearchInfo->_fBefFirstRow = TRUE;
            RRETURN(S_ADS_NOMORE_ROWS);
        }
    }

    while(pTmpRow != pTargetRow)
    {
        pPrevRow = pTmpRow;
        hr = LdapNextEntry(phSearchInfo->_pConnection,
                    pTmpRow,
                    &pTmpRow);
        BAIL_ON_FAILURE(hr);
    }

    ADsAssert(pPrevRow);

    phSearchInfo->_pCurrentRow = pPrevRow;
    phSearchInfo->_pFirstAttr = NULL;

    RRETURN(S_OK);

error:

    phSearchInfo->_dwCurrResult = dwOrigCurrResult;
    RRETURN(hr);
}


HRESULT
ADsGetColumn(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    IN CCredentials& Credentials,
    DWORD dwPort,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{

    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    VOID **ppValue = NULL;
    struct berval **ppBerValue = NULL;
    WCHAR **ppStrValue = NULL;
    int cValueCount;
    HRESULT hr = S_OK;
    DWORD dwStatus;
    LPWSTR pszDn, pszADsPathName = NULL;
    DWORD dwSyntaxId;
    DWORD dwError;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    PADS_VLV pVLV = NULL;

    if( !pColumn ||
        !phSearchInfo ||
        !phSearchInfo->_pSearchResults )
        RRETURN (E_ADS_BAD_PARAMETER);

    pColumn->pszAttrName = NULL;
    pColumn->dwADsType = ADSTYPE_INVALID;
    pColumn->pADsValues = NULL;
    pColumn->dwNumValues = 0;
    pColumn->hReserved = NULL;

    if(!phSearchInfo->_pConnection)
        RRETURN (E_ADS_BAD_PARAMETER);


    if (!phSearchInfo->_pCurrentRow
        && _wcsicmp(pszColumnName, ADS_DIRSYNC_COOKIE)
        && _wcsicmp(pszColumnName, ADS_VLV_RESPONSE)) {
        //
        // Current row is not valid and you are not asking for the
        // dirsync cookie - so we will fail.
        //
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    pColumn->pszAttrName = AllocADsStr(pszColumnName);
    if (!pColumn->pszAttrName)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    if(!_wcsicmp (pszColumnName, L"ADsPath")) {
        //
        // Get the DN of the entry.
        //
        hr = LdapGetDn(
                     phSearchInfo->_pConnection,
                     phSearchInfo->_pCurrentRow,
                     &pszDn
                     );
        BAIL_ON_FAILURE(hr);

        //
        // Build the ADsPath
        //

        hr = BuildADsPathFromLDAPPath(
                 phSearchInfo->_pszADsPathContext,
                 pszDn,
                 &pszADsPathName
                 );

        BAIL_ON_FAILURE(hr);

        LdapMemFree(pszDn);


        pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));
        if (!pColumn->pADsValues)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pColumn->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
        pColumn->dwNumValues = 1;
        pColumn->pADsValues[0].dwType = ADSTYPE_CASE_IGNORE_STRING;

        pColumn->pADsValues[0].CaseIgnoreString = AllocADsStr(pszADsPathName);
        if (!pColumn->pADsValues[0].CaseIgnoreString)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        FreeADsMem(pszADsPathName);

        RRETURN(S_OK);
    }
    else if (phSearchInfo->_SearchPref._fDirSync) {
        //
        // See if we need to return the dirsync control info.
        //
        if (!_wcsicmp (pszColumnName, ADS_DIRSYNC_COOKIE)) {

            pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));

            if (!pColumn->pADsValues)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->dwADsType = ADSTYPE_PROV_SPECIFIC;
            pColumn->dwNumValues = 1;
            pColumn->pADsValues[0].dwType = ADSTYPE_PROV_SPECIFIC;

            //
            // Copy the control over if appropriate if not we will
            // return NULL or empty data for the result.
            //
            if (phSearchInfo->_SearchPref._pProvSpecific->lpValue) {

                pColumn->pADsValues[0].ProviderSpecific.dwLength =
                    phSearchInfo->_SearchPref._pProvSpecific->dwLength;


                pColumn->pADsValues[0].ProviderSpecific.lpValue = (LPBYTE)
                    AllocADsMem(
                        pColumn->pADsValues[0].ProviderSpecific.dwLength
                        );
                if (!pColumn->pADsValues[0].ProviderSpecific.lpValue) {
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                }


                memcpy(
                    pColumn->pADsValues[0].ProviderSpecific.lpValue,
                    phSearchInfo->_SearchPref._pProvSpecific->lpValue,
                    phSearchInfo->_SearchPref._pProvSpecific->dwLength
                    );

            }
            RRETURN(S_OK);
        } // if DirSyncControlStruct is being asked for.
    } // if dirsync set.
    else if (phSearchInfo->_SearchPref._pVLVInfo) {
        //
        // See if we need to return the VLV control info.
        //
        if (!_wcsicmp (pszColumnName, ADS_VLV_RESPONSE)) {

            pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));

            if (!pColumn->pADsValues)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->dwADsType = ADSTYPE_PROV_SPECIFIC;
            pColumn->dwNumValues = 1;
            pColumn->pADsValues[0].dwType = ADSTYPE_PROV_SPECIFIC;

            pColumn->pADsValues[0].ProviderSpecific.dwLength = sizeof(ADS_VLV);
            pColumn->pADsValues[0].ProviderSpecific.lpValue = (LPBYTE) AllocADsMem(sizeof(ADS_VLV));
            if (!pColumn->pADsValues[0].ProviderSpecific.lpValue)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            // copy the VLV data into the ADS_VLV
            pVLV = (PADS_VLV) pColumn->pADsValues[0].ProviderSpecific.lpValue;

            pVLV->dwBeforeCount  = 0;
            pVLV->dwAfterCount   = 0;
            pVLV->dwOffset       = phSearchInfo->_dwVLVOffset;
            pVLV->dwContentCount = phSearchInfo->_dwVLVCount;
            pVLV->pszTarget     = NULL;

            // copy the VLV context ID, if available
            pVLV->lpContextID = NULL;
            pVLV->dwContextIDLength = 0;

            if (phSearchInfo->_pVLVContextID && phSearchInfo->_pVLVContextID->bv_len) {
                pVLV->lpContextID = (LPBYTE) AllocADsMem(phSearchInfo->_pVLVContextID->bv_len);
                if (!pVLV->lpContextID)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                pVLV->dwContextIDLength = phSearchInfo->_pVLVContextID->bv_len;
                memcpy(pVLV->lpContextID,
                       phSearchInfo->_pVLVContextID->bv_val,
                       phSearchInfo->_pVLVContextID->bv_len);
            }

            RRETURN(S_OK);
        } // if VLV response is being asked for
    } // if VLV set


    if (phSearchInfo->_fADsPathOnly) {
        //
        // Only ADsPath attribute requested in the search,
        // so don't return any other column values.
        //
        RRETURN (E_ADS_COLUMN_NOT_SET);
    }

    if (phSearchInfo->_SearchPref._fAttrsOnly) {
        //
        // Only Names got. So, don't return any values
        //
        RRETURN (S_OK);
    }


    //
    // Call the helper function to get the LDAP specific type
    //
    hr = LdapGetSyntaxOfAttributeOnServer(
             phSearchInfo->_pszLdapServer,
             pszColumnName,
             &dwSyntaxId,
             Credentials,
             dwPort
             );

    if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
        //
        // This means that the server didn't give back the schema and we don't
        // have it in the default schema. Return an octet blob.
        //
        dwSyntaxId = LDAPTYPE_OCTETSTRING;
        hr = S_OK;
    }

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        //
        // Not on the server, we will return as provider specific.
        // LDAPTYPE_UNKNOWN will be mapped to ADSTYPE_PROVIDER_SPECIFIC
        // when we build the ADsColumn.
        //
        dwSyntaxId = LDAPTYPE_UNKNOWN;
        hr = S_OK;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Now get the data
    //
    switch ( dwSyntaxId )
    {
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_SECURITY_DESCRIPTOR:
        case LDAPTYPE_UNKNOWN:
            hr = LdapGetValuesLen(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_pCurrentRow,
                           pszColumnName,
                           &ppBerValue,
                           &cValueCount
                           );

            ppValue = (VOID **) ppBerValue;
            break;

        default:
            hr = LdapGetValues(
                           phSearchInfo->_pConnection,
                           phSearchInfo->_pCurrentRow,
                           pszColumnName,
                           &ppStrValue,
                           &cValueCount
                           );
            ppValue = (VOID **) ppStrValue;
            break;
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)) {
        hr=E_ADS_COLUMN_NOT_SET;
    }
    BAIL_ON_FAILURE(hr);

    hr = LdapValueToADsColumn(
             pszColumnName,
             dwSyntaxId,
             cValueCount,
             ppValue,
             pColumn
             );
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:

    ADsFreeColumn(pColumn);

    if (pszADsPathName)
        FreeADsMem(pszADsPathName);

    RRETURN (hr);
}



HRESULT
ADsGetNextColumnName(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{

    HRESULT hr = S_OK;
    PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;
    DWORD dwStatus, dwError;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];

    if( !phSearchInfo ||
        !phSearchInfo->_pSearchResults ||
        !ppszColumnName)
        RRETURN (E_ADS_BAD_PARAMETER);

    *ppszColumnName = NULL;

    if (!phSearchInfo->_fADsPathOnly) {

        if (!phSearchInfo->_pFirstAttr)
            hr = LdapFirstAttribute(
                            phSearchInfo->_pConnection,
                            phSearchInfo->_pCurrentRow,
                            &phSearchInfo->_pFirstAttr,
                            ppszColumnName
                            );
        else
            hr = LdapNextAttribute(
                            phSearchInfo->_pConnection,
                            phSearchInfo->_pCurrentRow,
                            phSearchInfo->_pFirstAttr,
                            ppszColumnName
                            );

        BAIL_ON_FAILURE(hr);
    }

    if (*ppszColumnName) {

        // Nothing to do in this case.
    }
    else if ( phSearchInfo->_fADsPathPresent) {

        //
        // If ADsPath was specified return it as the last column
        //

        if (!phSearchInfo->_fADsPathReturned) {

            *ppszColumnName = AllocADsStr(L"ADsPath");
            phSearchInfo->_fADsPathReturned = TRUE;
        }
        else {

            //
            // We need to reset it back so that we return it for the next
            // row
            //

            phSearchInfo->_fADsPathReturned = FALSE;
            hr = S_ADS_NOMORE_COLUMNS;
        }
    }
    else {

        hr = S_ADS_NOMORE_COLUMNS;
    }

error:

    RRETURN (hr);
}



HRESULT
ADsFreeColumn(
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    if(!pColumn)
        RRETURN (E_ADS_BAD_PARAMETER);

    switch(pColumn->dwADsType) {
    case ADSTYPE_OCTET_STRING:
    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
    case ADSTYPE_PROV_SPECIFIC:
        //
        // Call the LDAP free value routine if not DirSyncControl
        // or VLV
        //
        if (pColumn->pszAttrName
            && !_wcsicmp(ADS_VLV_RESPONSE, pColumn->pszAttrName)) {
            //
            // VLV, so free the ADS_VLV and its members
            //
            if (pColumn->pADsValues && pColumn->pADsValues[0].ProviderSpecific.lpValue) {

                if (((PADS_VLV)(pColumn->pADsValues[0].ProviderSpecific.lpValue))->lpContextID) {
                    FreeADsMem(((PADS_VLV)(pColumn->pADsValues[0].ProviderSpecific.lpValue))->lpContextID);
                }

                FreeADsMem(pColumn->pADsValues[0].ProviderSpecific.lpValue);
            }
            
        }
        else if (pColumn->pszAttrName
            && _wcsicmp(ADS_DIRSYNC_COOKIE, pColumn->pszAttrName)
            ) {

            LdapValueFreeLen((struct berval **)pColumn->hReserved);
            pColumn->hReserved = NULL;
        } else {
            //
            // DirSyncControlStruct - so we free the ADsValue.
            //
            if (pColumn->pADsValues[0].ProviderSpecific.lpValue) {
                FreeADsMem(pColumn->pADsValues[0].ProviderSpecific.lpValue);
            }
        }

        break;

    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_DN_STRING:
    case ADSTYPE_CASE_EXACT_STRING:
        if(!pColumn->hReserved) {
            //
            // The column just contains a DN.
            //
            FreeADsMem(pColumn->pADsValues[0].CaseIgnoreString);
        }
        else {
            LdapValueFree( (WCHAR **)pColumn->hReserved);
            pColumn->hReserved = NULL;
        }
        break;

    case ADSTYPE_INTEGER:
    case ADSTYPE_LARGE_INTEGER:
    case ADSTYPE_BOOLEAN:
    case ADSTYPE_UTC_TIME:
        // Nothing to free
        break;

    case ADSTYPE_DN_WITH_BINARY:
    case ADSTYPE_DN_WITH_STRING:

        AdsTypeFreeAdsObjects(
            pColumn->pADsValues,
            pColumn->dwNumValues
            );

        //
        // Do not want to free this twice
        //
        pColumn->pADsValues = NULL;
        break;

    case ADSTYPE_INVALID:
    	//
    	// This comes from the result of search by setting _SearchPref._fAttrsOnly
    	// nothing need to be done
    	//
    	break;

    default:
        // unknown type;
        hr = E_ADS_BAD_PARAMETER;
    }

    if (pColumn->pszAttrName)
        FreeADsStr(pColumn->pszAttrName);

    if (pColumn->pADsValues) {
        FreeADsMem(pColumn->pADsValues);
        pColumn->pADsValues = NULL;
    }

    RRETURN(hr);
}

BOOL
IsValidPrefValue(
    ADS_SEARCHPREF_INFO SearchPref
    )
{

    switch(SearchPref.dwSearchPref) {

    case ADS_SEARCHPREF_ASYNCHRONOUS:
    case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
    case ADS_SEARCHPREF_CACHE_RESULTS:
    case ADS_SEARCHPREF_TOMBSTONE:
        if (SearchPref.vValue.dwType != ADSTYPE_BOOLEAN)
            return FALSE;
        break;

    case ADS_SEARCHPREF_DEREF_ALIASES:
    case ADS_SEARCHPREF_SIZE_LIMIT:
    case ADS_SEARCHPREF_TIME_LIMIT:
    case ADS_SEARCHPREF_SEARCH_SCOPE:
    case ADS_SEARCHPREF_TIMEOUT:
    case ADS_SEARCHPREF_PAGESIZE:
    case ADS_SEARCHPREF_PAGED_TIME_LIMIT:
    case ADS_SEARCHPREF_CHASE_REFERRALS:
        if (SearchPref.vValue.dwType != ADSTYPE_INTEGER)
            return FALSE;
        break;

    case ADS_SEARCHPREF_SORT_ON:
        if (SearchPref.vValue.dwType != ADSTYPE_PROV_SPECIFIC)
            return FALSE;
        break;

    case ADS_SEARCHPREF_DIRSYNC:
        if (SearchPref.vValue.dwType != ADSTYPE_PROV_SPECIFIC)
            return FALSE;
        break;

    case ADS_SEARCHPREF_VLV:
        if (SearchPref.vValue.dwType != ADSTYPE_PROV_SPECIFIC)
            return FALSE;
        break;

    case ADS_SEARCHPREF_ATTRIBUTE_QUERY:
        if (SearchPref.vValue.dwType != ADSTYPE_CASE_IGNORE_STRING)
            return FALSE;
        break;

    case ADS_SEARCHPREF_SECURITY_MASK:
        if (SearchPref.vValue.dwType != ADSTYPE_INTEGER)
            return FALSE;
        break;


    default:
        return FALSE;
    }

    return TRUE;
}


HRESULT
LdapValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    VOID        **ppValue,
    ADS_SEARCH_COLUMN * pColumn
    )
{
    HRESULT hr = S_OK;
    DWORD i, j;

    if(!pszColumnName || !pColumn)
        RRETURN(E_ADS_BAD_PARAMETER);

    pColumn->hReserved = (HANDLE) ppValue;
    pColumn->dwNumValues = dwValues;

    if (dwValues < 1) {
        //
        // Need to set the ADsValue struct to NULL as it does
        // not make sense to return any ADsValues
        //
        pColumn->pADsValues = NULL;

    } else {

        pColumn->pADsValues = (PADSVALUE) AllocADsMem(
                                          sizeof(ADSVALUE) * dwValues
                                          );
        if (!pColumn->pADsValues)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pColumn->dwADsType = MapLDAPTypeToADSType(dwSyntaxId);

    switch (dwSyntaxId) {
    case LDAPTYPE_BITSTRING:
    case LDAPTYPE_PRINTABLESTRING:
    case LDAPTYPE_DIRECTORYSTRING:
    case LDAPTYPE_COUNTRYSTRING:
    case LDAPTYPE_DN:
    case LDAPTYPE_NUMERICSTRING:
    case LDAPTYPE_IA5STRING:
    case LDAPTYPE_CASEIGNORESTRING:
    case LDAPTYPE_OID:
    case LDAPTYPE_TELEPHONENUMBER:
    case LDAPTYPE_ATTRIBUTETYPEDESCRIPTION:
    case LDAPTYPE_OBJECTCLASSDESCRIPTION:
    case LDAPTYPE_DELIVERYMETHOD:
    case LDAPTYPE_ENHANCEDGUIDE:
    case LDAPTYPE_FACSIMILETELEPHONENUMBER:
    case LDAPTYPE_GUIDE:
    case LDAPTYPE_NAMEANDOPTIONALUID:
    case LDAPTYPE_POSTALADDRESS:
    case LDAPTYPE_PRESENTATIONADDRESS:
    case LDAPTYPE_TELEXNUMBER:
    case LDAPTYPE_DSAQUALITYSYNTAX:
    case LDAPTYPE_DATAQUALITYSYNTAX:
    case LDAPTYPE_MAILPREFERENCE:
    case LDAPTYPE_OTHERMAILBOX:
    case LDAPTYPE_ACCESSPOINTDN:
    case LDAPTYPE_ORNAME:
    case LDAPTYPE_ORADDRESS:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].CaseIgnoreString = (LPWSTR) ppValue[i];
        }
        break;

    case LDAPTYPE_CASEEXACTSTRING:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].CaseExactString = (LPWSTR) ppValue[i];
        }
        break;

    case LDAPTYPE_UTCTIME:
        for (i=0; i < dwValues; i++) {
            SYSTEMTIME st;
            hr = UTCTimeStringToUTCTime((LPWSTR)ppValue[i],
                                        &st);
            BAIL_ON_FAILURE(hr);
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].UTCTime = st;
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;

    case LDAPTYPE_GENERALIZEDTIME:
        for (i=0; i < dwValues; i++) {
            SYSTEMTIME st;
            hr = GenTimeStringToUTCTime((LPWSTR)ppValue[i],
                                         &st);
            BAIL_ON_FAILURE(hr);
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].UTCTime = st;
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;

    case LDAPTYPE_CERTIFICATE:
    case LDAPTYPE_CERTIFICATELIST:
    case LDAPTYPE_CERTIFICATEPAIR:
    case LDAPTYPE_PASSWORD:
    case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
    case LDAPTYPE_AUDIO:
    case LDAPTYPE_JPEG:
    case LDAPTYPE_FAX:
    case LDAPTYPE_OCTETSTRING:
    case LDAPTYPE_SECURITY_DESCRIPTOR:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].OctetString.dwLength = ((struct berval **)ppValue)[i]->bv_len;
            pColumn->pADsValues[i].OctetString.lpValue = (LPBYTE)
                                        ((struct berval **) ppValue)[i]->bv_val;
        }
        break;

    case LDAPTYPE_BOOLEAN:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            if ( _wcsicmp( (WCHAR *) ppValue[i], L"TRUE") == 0 ) {
                pColumn->pADsValues[i].Boolean = TRUE;
            }
            else if ( _wcsicmp( (WCHAR *) ppValue[i], L"FALSE") == 0 ) {
                pColumn->pADsValues[i].Boolean = FALSE;
            }
            else {
                BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
            }
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;

    case LDAPTYPE_INTEGER:
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].Integer = _wtol((WCHAR *) ppValue[i]);
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;

    case LDAPTYPE_INTEGER8:

        for (i=0; i < dwValues; i++) {

            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            swscanf ((WCHAR *) ppValue[i], L"%I64d", &pColumn->pADsValues[i].LargeInteger);

        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;


    case LDAPTYPE_DNWITHBINARY:

        for (i=0; i < dwValues; i++) {
            hr = LdapDNWithBinToAdsTypeHelper(
                     (LPWSTR) ppValue[i],
                     &pColumn->pADsValues[i]
                     );
            BAIL_ON_FAILURE(hr);
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;


    case LDAPTYPE_DNWITHSTRING:

        for (i=0; i < dwValues; i++) {
            hr = LdapDNWithStrToAdsTypeHelper(
                     (LPWSTR) ppValue[i],
                     &pColumn->pADsValues[i]
                     );
            BAIL_ON_FAILURE(hr);
        }
        LdapValueFree((WCHAR **)pColumn->hReserved);
        pColumn->hReserved = NULL;
        break;


    default:
        pColumn->dwADsType = ADSTYPE_PROV_SPECIFIC;
        for (i=0; i < dwValues; i++) {
            pColumn->pADsValues[i].dwType = ADSTYPE_PROV_SPECIFIC;
            pColumn->pADsValues[i].ProviderSpecific.dwLength =
                 ((struct berval **)ppValue)[i]->bv_len;
            pColumn->pADsValues[i].ProviderSpecific.lpValue =
                (LPBYTE) ((struct berval **) ppValue)[i]->bv_val;
        }
        break;
    }
    RRETURN(hr);


error:

    if (pColumn->pADsValues) {
        FreeADsMem(pColumn->pADsValues);
        pColumn->pADsValues = NULL;
        pColumn->dwNumValues = 0;
    }

    RRETURN(hr);
}

//
// To add the server controls. The controls will be set internally in the
// handle. Right now, we support sort, dirsync and domain scope controls.
//
HRESULT
AddSearchControls(
   PLDAP_SEARCHINFO phSearchInfo,
   CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    PLDAPSortKey *ppSortKeys = NULL;
    PLDAPControl pSortControl = NULL, *ppServerControls = NULL;
    PLDAPControl pDirSyncControl = NULL;
    PLDAPControl pDomCtrl = NULL;
    PLDAPControl pTombStoneCtrl = NULL;
    PLDAPControl pVLVControl = NULL;
    PLDAPControl pAttribScopedCtrl = NULL;
    PLDAPControl pSecurityDescCtrl = NULL;
    PBERVAL pBerVal = NULL;
    DWORD nKeys=0, i=0;
    DWORD dwControls = 0;
    DWORD dwCurControl = 0;
    BOOL fDomainScopeControl = FALSE;
    BOOL fTombStone = FALSE;
    BYTE * pbSecDescValue = NULL;

    if (phSearchInfo->_SearchPref._pSortKeys) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._fDirSync) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._fTombStone) {
        dwControls++;
        fTombStone = TRUE;
    }

    if (phSearchInfo->_SearchPref._pVLVInfo) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._pAttribScoped) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._fSecurityDescriptorControl) {
        dwControls++;
    }

    if (phSearchInfo->_SearchPref._dwChaseReferrals == LDAP_CHASE_EXTERNAL_REFERRALS
        || phSearchInfo->_SearchPref._dwChaseReferrals == (DWORD)(DWORD_PTR)LDAP_OPT_OFF) {
        //
        // Try and see if we can add the additional ADControl.
        //
        hr = ReadDomScopeSupportedAttr(
                 phSearchInfo->_pszLdapServer,
                 &fDomainScopeControl,
                 Credentials,
                 phSearchInfo->_dwPort
                 );

        if (FAILED(hr)) {
            hr = S_OK;
            fDomainScopeControl = FALSE;
        }
        else if (fDomainScopeControl == TRUE) {
            dwControls++;
        }
    }

    if (!dwControls) {
        RRETURN(S_OK);
    }
    ADsAssert(phSearchInfo);

    if (phSearchInfo->_ServerControls) {
        while (phSearchInfo->_ServerControls[i]) {

            //
            // Free the pre-existing controls in preparation for adding in a new
            // batch.
            //
            // The algorithm is:
            //   If this is the VLV control, free it with LdapControlFree
            //   All other controls are freed with FreeADsMem
            //     The sort & security descriptor controls also have additional
            //     memory associated with them that must be freed here.
            //     (some other controls, like ASQ or DirSync, also have additonal
            //      memory that must be freed, but this memory is tracked via
            //      _ldap_searchinfo and the freeing is done when we actually
            //      process adding the new control below)
            //

            //
            // If this is the VLV control, need to free it
            // using LdapControlFree
            //
            if ((phSearchInfo->_ServerControls[i]->ldctl_oid)
                && (wcscmp(
                       phSearchInfo->_ServerControls[i]->ldctl_oid,
                       LDAP_CONTROL_VLVREQUEST_W
                       ) == 0)) {
                       
                    LdapControlFree(phSearchInfo->_ServerControls[i]);
            }
            else {
                //
                // If this is the sort or security descriptor control, we
                // need to free some additional stuff.
                //            
                if ((phSearchInfo->_ServerControls[i]->ldctl_oid)
                && (wcscmp(
                       phSearchInfo->_ServerControls[i]->ldctl_oid,
                       LDAP_SERVER_SORT_OID_W
                       ) == 0)
                ) {
                    //
                    // This is a sort control
                    //
                    if (phSearchInfo->_ServerControls[i]->ldctl_oid) {
                        ldap_memfree(phSearchInfo->_ServerControls[i]->ldctl_oid);
                    }

                    if (phSearchInfo->_ServerControls[i]->ldctl_value.bv_val) {
                        ldap_memfreeA(
                            phSearchInfo->_ServerControls[i]->ldctl_value.bv_val
                            );
                    }
                }
                else if ((phSearchInfo->_ServerControls[i]->ldctl_oid)
                          && (wcscmp(phSearchInfo->_ServerControls[i]->ldctl_oid,
                                     LDAP_SERVER_SD_FLAGS_OID_W) == 0)) {

                    //
                    // This is a security descriptor control
                    //
                    if (phSearchInfo->_ServerControls[i]->ldctl_value.bv_val) {
                        FreeADsMem(phSearchInfo->_ServerControls[i]->ldctl_value.bv_val);
                    }

                }
                // free the control (for any control except VLV, which
                // we already freed above)
                FreeADsMem(phSearchInfo->_ServerControls[i]);
            }
            
            i++;
        }
        FreeADsMem(phSearchInfo->_ServerControls);
        phSearchInfo->_ServerControls = NULL;        
    }

    nKeys = phSearchInfo->_SearchPref._nSortKeys;
    //
    // One more than our dwControls is the number we need.
    //
    ppServerControls = (PLDAPControl *)
        AllocADsMem( sizeof(PLDAPControl) * (dwControls+1) );
    if (!ppServerControls) {
        RRETURN(E_OUTOFMEMORY);
    }


    //
    // Process the VLV control
    //
    if (phSearchInfo->_SearchPref._pVLVInfo) {

        hr = LdapCreateVLVControl(phSearchInfo->_pConnection,
                                  phSearchInfo->_SearchPref._pVLVInfo,
                                  TRUE,
                                  &pVLVControl
                                  );
        BAIL_ON_FAILURE(hr);

        ppServerControls[dwCurControl++] = pVLVControl;
    }

    //
    // Process the sort control.
    //
    if (phSearchInfo->_SearchPref._pSortKeys) {

        ppSortKeys = (PLDAPSortKey *) AllocADsMem( sizeof(PLDAPSortKey) *
                                                (nKeys+1) );
        if (!ppSortKeys) {
            RRETURN(E_OUTOFMEMORY);
        }

        pSortControl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pSortControl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        for (i=0; i<nKeys; i++) {
            ppSortKeys[i] = &(phSearchInfo->_SearchPref._pSortKeys[i]);
        }
        ppSortKeys[nKeys] = NULL;

        hr = LdapEncodeSortControl(
                 phSearchInfo->_pConnection,
                 ppSortKeys,
                 pSortControl,
                 TRUE
                 );

        BAIL_ON_FAILURE(hr);

        ppServerControls[dwCurControl++] = pSortControl;

        if (ppSortKeys) {
            FreeADsMem(ppSortKeys);
        }
    }

    //
    // Handle the dirsync control if applicable
    //
    if (phSearchInfo->_SearchPref._fDirSync) {
        pDirSyncControl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pDirSyncControl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = BerEncodeReplicationCookie(
                 phSearchInfo->_SearchPref._pProvSpecific->lpValue,
                 phSearchInfo->_SearchPref._pProvSpecific->dwLength,
                 &pBerVal
                 );

        BAIL_ON_FAILURE(hr);

        pDirSyncControl->ldctl_oid = LDAP_SERVER_DIRSYNC_OID_W;
        pDirSyncControl->ldctl_value.bv_len = pBerVal->bv_len;

        pDirSyncControl->ldctl_value.bv_val = (PCHAR) pBerVal->bv_val;
        pDirSyncControl->ldctl_iscritical = TRUE;

        //
        // Clear the info in the search handle if applicable
        //
        if (phSearchInfo->_pBerVal) {
            ber_bvfree(phSearchInfo->_pBerVal);
        }

        phSearchInfo->_pBerVal = pBerVal;

        ppServerControls[dwCurControl++] = pDirSyncControl;
    }

    //
    // Process the DomainScope control if applicable
    //
    if (fDomainScopeControl) {
        pDomCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pDomCtrl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pDomCtrl->ldctl_oid = LDAP_SERVER_DOMAIN_SCOPE_OID_W;
        pDomCtrl->ldctl_value.bv_len = 0;
        pDomCtrl->ldctl_value.bv_val = NULL;
        pDomCtrl->ldctl_iscritical = FALSE;

        ppServerControls[dwCurControl++] = pDomCtrl;
    }

    //
    // Process the tombstone control if applicable
    //
    if (fTombStone) {
        pTombStoneCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pTombStoneCtrl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pTombStoneCtrl->ldctl_oid = LDAP_SERVER_SHOW_DELETED_OID_W;
        pTombStoneCtrl->ldctl_value.bv_len = 0;
        pTombStoneCtrl->ldctl_value.bv_val = NULL;
        pTombStoneCtrl->ldctl_iscritical = TRUE;

        ppServerControls[dwCurControl++] = pTombStoneCtrl;

    }

    //
    // Process the attribute scoped query control
    //
    if (phSearchInfo->_SearchPref._pAttribScoped) {
        pAttribScopedCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pAttribScopedCtrl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = BerEncodeAttribScopedControlValue(phSearchInfo->_SearchPref._pAttribScoped,
                                               &pBerVal);
        BAIL_ON_FAILURE(hr);
        
        pAttribScopedCtrl->ldctl_oid = LDAP_SERVER_ASQ_OID_W;
        pAttribScopedCtrl->ldctl_value.bv_len = pBerVal->bv_len;
        pAttribScopedCtrl->ldctl_value.bv_val = pBerVal->bv_val;
        pAttribScopedCtrl->ldctl_iscritical = TRUE;

        //
        // Clear the info in the search handle if applicable
        //
        if (phSearchInfo->_pBerValAttribScoped) {
            ber_bvfree(phSearchInfo->_pBerValAttribScoped);
        }

        phSearchInfo->_pBerValAttribScoped = pBerVal;

        ppServerControls[dwCurControl++] = pAttribScopedCtrl;
        
    }

    //
    // Process the security descriptor control
    //
    if (phSearchInfo->_SearchPref._fSecurityDescriptorControl) {
    
        pSecurityDescCtrl = (LDAPControl *) AllocADsMem(sizeof(LDAPControl));

        if (!pSecurityDescCtrl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pbSecDescValue = (BYTE *) AllocADsMem(5);

        if (!pbSecDescValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        ZeroMemory(pbSecDescValue, 5);

        pbSecDescValue[0] = 0x30; // Start sequence tag
        pbSecDescValue[1] = 0x03; // Length in bytes of following
        pbSecDescValue[2] = 0x02; // Actual value this and next 2
        pbSecDescValue[3] = 0x01;
        pbSecDescValue[4] = (BYTE) ((ULONG)phSearchInfo->_SearchPref._SecurityDescriptorMask);

        pSecurityDescCtrl->ldctl_oid = LDAP_SERVER_SD_FLAGS_OID_W;
        pSecurityDescCtrl->ldctl_value.bv_len = 5;
        pSecurityDescCtrl->ldctl_value.bv_val = (PCHAR) pbSecDescValue;
        pSecurityDescCtrl->ldctl_iscritical = TRUE;

        ppServerControls[dwCurControl++] = pSecurityDescCtrl;        
    }
    
    
    ppServerControls[dwControls] = NULL;
    phSearchInfo->_ServerControls = ppServerControls;

    RRETURN(S_OK);

error:

    if (ppServerControls) {
        FreeADsMem(ppServerControls);
    }


    if (pSortControl) {
        FreeADsMem(pSortControl);
    }

    if (pDirSyncControl) {
        FreeADsMem(pSortControl);
    }

    if (pDomCtrl) {
        FreeADsMem(pDomCtrl);
    }

    if (pTombStoneCtrl) {
        FreeADsMem(pTombStoneCtrl);
    }

    if (pAttribScopedCtrl) {            
        FreeADsMem(pAttribScopedCtrl);
    }

    if (pVLVControl) {
        LdapControlFree(pVLVControl);
    }

    if (pSecurityDescCtrl) {
        FreeADsMem(pSecurityDescCtrl);
    }

    if (ppSortKeys) {
        FreeADsMem(ppSortKeys);
    }

    if (pbSecDescValue) {
        FreeADsMem(pbSecDescValue);
    }

    RRETURN(hr);

}

void
FreeSortKeys(
    IN PLDAPSortKey pSortKeys,
    IN DWORD   dwSortKeys
    )
{
    for (DWORD i=0; i < dwSortKeys; i++) {

        if (pSortKeys[i].sk_attrtype) {
            FreeADsStr(pSortKeys[i].sk_attrtype);
        }
    }

    if (pSortKeys) {
        FreeADsMem(pSortKeys);
    }
}

//
// Copy a LDAPVLVInfo (and the data it points to) from
// *pVLVInfoSource to **ppVLVInfoTarget.
//
// Note that pVLVInfoSource->ldvlv_extradata is not copied,
// and is set to NULL in **ppVLVInfoTarget.  If the caller
// uses this for anything, copying it is the caller's
// responsibility.
//
HRESULT
CopyLDAPVLVInfo(
    PLDAPVLVInfo pVLVInfoSource,
    PLDAPVLVInfo *ppVLVInfoTarget
    )
{
    HRESULT hr = S_OK;

    PLDAPVLVInfo pVLVInfo = NULL;

    if (!pVLVInfoSource || !ppVLVInfoTarget)
        BAIL_ON_FAILURE(hr = E_INVALIDARG);

    *ppVLVInfoTarget = NULL;
    
    pVLVInfo = (PLDAPVLVInfo) AllocADsMem(sizeof(LDAPVLVInfo));
    if (!pVLVInfo)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    // copy the non-pointer members
    *pVLVInfo = *pVLVInfoSource;
    pVLVInfo->ldvlv_attrvalue = NULL;
    pVLVInfo->ldvlv_context = NULL;
    pVLVInfo->ldvlv_extradata = NULL;

    // copy the pointer members
    if (pVLVInfoSource->ldvlv_attrvalue) {
    
        pVLVInfo->ldvlv_attrvalue = (PBERVAL) AllocADsMem(sizeof(BERVAL));
        if (!pVLVInfo->ldvlv_attrvalue)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pVLVInfo->ldvlv_attrvalue->bv_len = pVLVInfoSource->ldvlv_attrvalue->bv_len;
        pVLVInfo->ldvlv_attrvalue->bv_val = (PCHAR) AllocADsMem(pVLVInfo->ldvlv_attrvalue->bv_len);
        if (!pVLVInfo->ldvlv_attrvalue->bv_val)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        memcpy(pVLVInfo->ldvlv_attrvalue->bv_val,
               pVLVInfoSource->ldvlv_attrvalue->bv_val,
               pVLVInfo->ldvlv_attrvalue->bv_len);
    }

    if (pVLVInfoSource->ldvlv_context) {
    
        pVLVInfo->ldvlv_context = (PBERVAL) AllocADsMem(sizeof(BERVAL));
        if (!pVLVInfo->ldvlv_context)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pVLVInfo->ldvlv_context->bv_len = pVLVInfoSource->ldvlv_context->bv_len;
        pVLVInfo->ldvlv_context->bv_val = (PCHAR) AllocADsMem(pVLVInfo->ldvlv_context->bv_len);
        if (!pVLVInfo->ldvlv_context->bv_val)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        memcpy(pVLVInfo->ldvlv_context->bv_val,
               pVLVInfoSource->ldvlv_context->bv_val,
               pVLVInfo->ldvlv_context->bv_len);
    }

    *ppVLVInfoTarget = pVLVInfo;
    RRETURN(hr);

error:

    FreeLDAPVLVInfo(pVLVInfo);
    RRETURN(hr);
}

//
// Free a LDAPVLVInfo (and the data it points to)
//
// Note that pVLVInfoSource->ldvlv_extradata is not freed.
// If the caller uses this for anything, freeing it before
// calling this function is the caller's responsibility.
//
void
FreeLDAPVLVInfo(
    IN PLDAPVLVInfo pVLVInfo
    )
{
    if (pVLVInfo) {

        if (pVLVInfo->ldvlv_attrvalue) {

            if (pVLVInfo->ldvlv_attrvalue->bv_val) {
                FreeADsMem(pVLVInfo->ldvlv_attrvalue->bv_val);
            }

            FreeADsMem(pVLVInfo->ldvlv_attrvalue);
        }


        if (pVLVInfo->ldvlv_context) {
        
            if (pVLVInfo->ldvlv_context->bv_val) {
                FreeADsMem(pVLVInfo->ldvlv_context->bv_val);
            }

            FreeADsMem(pVLVInfo->ldvlv_context);
        }


        FreeADsMem(pVLVInfo);
    }
}


HRESULT
StoreVLVInfo(
    LDAPMessage *pLDAPMsg,
    PLDAP_SEARCHINFO phSearchInfo
    )
{
    HRESULT hr = S_OK;

    PLDAPControl *ppServerControls = NULL;
    ULONG ulTarget = 0;
    ULONG ulCount = 0;
    PBERVAL pContextID = NULL;
    PBERVAL pContextIDCopy = NULL;


    if (!pLDAPMsg) {
        RRETURN(S_OK);
    }

    //
    // Retrieve the server controls 
    //
    hr = LdapParseResult(
             phSearchInfo->_pConnection,
             pLDAPMsg,
             NULL, // ret code
             NULL, // matched dn's
             NULL, // err msg's
             NULL, // referrals
             &ppServerControls,
             FALSE // freeIt
             );

    BAIL_ON_FAILURE(hr);


    if (!ppServerControls) {
        //
        // Could not get the control
        //
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    //
    // Parse the VLV response control
    //
    hr = LdapParseVLVControl(
            phSearchInfo->_pConnection,
            ppServerControls,
            &ulTarget,
            &ulCount,
            &pContextID
            );

    BAIL_ON_FAILURE(hr);


    //
    // Copy the new context ID, if one was returned by the server
    //
    if (pContextID && pContextID->bv_val && pContextID->bv_len) {

        pContextIDCopy = (PBERVAL) AllocADsMem(sizeof(BERVAL));
        if (!pContextIDCopy)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        pContextIDCopy->bv_len = pContextID->bv_len;
        pContextIDCopy->bv_val = (PCHAR) AllocADsMem(pContextID->bv_len);
        if (!pContextIDCopy->bv_val)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        memcpy(pContextIDCopy->bv_val,
               pContextID->bv_val,
               pContextID->bv_len);
    }

    //
    // Copy VLV response control info into the _ldap_searchinfo
    // If the server did not return context ID, pContextIDCopy == NULL.
    //
    phSearchInfo->_dwVLVOffset = ulTarget;
    phSearchInfo->_dwVLVCount = ulCount;

    // free the previous context ID
    if (phSearchInfo->_pVLVContextID) {
        if (phSearchInfo->_pVLVContextID->bv_val) {
            FreeADsMem(phSearchInfo->_pVLVContextID->bv_val);
        }

        FreeADsMem(phSearchInfo->_pVLVContextID);
    }

    phSearchInfo->_pVLVContextID = pContextIDCopy;

error :

    if (pContextID)
        BerBvFree(pContextID);

    if (ppServerControls) {
        ldap_controls_free(ppServerControls);
    }

    if (FAILED(hr)) {

        if (pContextIDCopy) {

            if (pContextIDCopy->bv_val) {
                FreeADsMem(pContextIDCopy->bv_val);
            }
            
            FreeADsMem(pContextIDCopy);
        }
    }

    RRETURN(hr);
}




HRESULT
StoreAttribScopedInfo(
    LDAPMessage *pLDAPMsg,
    PLDAP_SEARCHINFO phSearchInfo
    )
{
    HRESULT hr = S_OK;
    PLDAPControl *ppServerControls = NULL;
    DWORD dwCtr = 0;
    BERVAL berVal;
    BerElement *pBer = NULL;
    int retval = LDAP_SUCCESS;

    if (!pLDAPMsg) {
        RRETURN(S_OK);
    }

    hr = LdapParseResult(
             phSearchInfo->_pConnection,
             pLDAPMsg,
             NULL, // ret code
             NULL, // matched dn's
             NULL, // err msg's
             NULL, // referrals
             &ppServerControls,
             FALSE // freeIt
             );

    BAIL_ON_FAILURE(hr);

    //
    // See if the ASQ control is in there.
    //
    while (ppServerControls
           && ppServerControls[dwCtr]
           && wcscmp(
                  ppServerControls[dwCtr]->ldctl_oid,
                  LDAP_SERVER_ASQ_OID_W
                  ) != 0) {
        dwCtr++;
    }

    if (!ppServerControls || !ppServerControls[dwCtr]) {
        //
        // Could not get the control
        //
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }


    //
    // Get the info we need.
    //
    berVal.bv_len = ppServerControls[dwCtr]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControls[dwCtr]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    if (ber_scanf(pBer, "{e}", &retval) != NO_ERROR) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Test for non-fatal error codes
    //
    if (retval == LDAP_AFFECTS_MULTIPLE_DSAS)
        phSearchInfo->_fNonFatalErrors = TRUE;

error :

    if (ppServerControls) {
        ldap_controls_free(ppServerControls);
    }

    if (pBer) {
        ber_free(pBer, 1);
    }

    RRETURN(hr);
}


HRESULT
StoreDirSyncCookie(
    LDAPMessage *pLDAPMsg,
    PLDAP_SEARCHINFO phSearchInfo
    )
{
    HRESULT hr = S_OK;
    PADS_PROV_SPECIFIC pProvSpecific = NULL;
    PLDAPControl *ppServerControls = NULL;
    DWORD dwCtr = 0;
    BERVAL berVal;
    BerElement *pBer = NULL;
    PBERVAL pBerVal = NULL;
    DWORD dwSize;
    BOOL fMoreData = FALSE;

    if (!pLDAPMsg) {
        RRETURN(S_OK);
    }

    phSearchInfo->_fMoreDirSync = FALSE;
    //
    // Build the new value and then assign it to the searchpref
    // information. That way, if there are errors we wont loose
    // the last cookie.
    //
    hr = LdapParseResult(
             phSearchInfo->_pConnection,
             pLDAPMsg,
             NULL, // ret code
             NULL, // matched dn's
             NULL, // err msg's
             NULL, // referrals
             &ppServerControls,
             FALSE // freeIt
             );

    BAIL_ON_FAILURE(hr);

    //
    // See if the dirsync control is in there.
    //
    while (ppServerControls
           && ppServerControls[dwCtr]
           && wcscmp(
                  ppServerControls[dwCtr]->ldctl_oid,
                  LDAP_SERVER_DIRSYNC_OID_W
                  ) != 0) {
        dwCtr++;
    }

    if (!ppServerControls || !ppServerControls[dwCtr]) {
        //
        // Could not get the control
        //
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }


    //
    // Get the info we need.
    //
    berVal.bv_len = ppServerControls[dwCtr]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControls[dwCtr]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    ber_scanf(pBer, "{iiO}", &fMoreData, &dwSize, &pBerVal);

    phSearchInfo->_fMoreDirSync = fMoreData;

    pProvSpecific = (PADS_PROV_SPECIFIC)
                        AllocADsMem(sizeof(ADS_PROV_SPECIFIC));

    if (!pProvSpecific) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pProvSpecific->lpValue = (LPBYTE) AllocADsMem(pBerVal->bv_len);
    if (!pProvSpecific->lpValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pProvSpecific->dwLength = pBerVal->bv_len;
    memcpy(pProvSpecific->lpValue, (LPBYTE) pBerVal->bv_val, pBerVal->bv_len);


    //
    // At this point it is safe to clear the Info on the dirsync control
    //
    if (phSearchInfo->_SearchPref._pProvSpecific) {
        if (phSearchInfo->_SearchPref._pProvSpecific->lpValue) {
            FreeADsMem(phSearchInfo->_SearchPref._pProvSpecific->lpValue);
        }
        FreeADsMem(phSearchInfo->_SearchPref._pProvSpecific);
    }

    phSearchInfo->_SearchPref._pProvSpecific = pProvSpecific;

error :

    if (ppServerControls) {
        ldap_controls_free(ppServerControls);
    }

    if (FAILED(hr)) {
        //
        // Handle the Provider Specific struct if applicable.
        //
        if (pProvSpecific) {
            if (pProvSpecific->lpValue) {
                FreeADsMem(pProvSpecific->lpValue);
            }
            FreeADsMem(pProvSpecific);
        }
    }

    if (pBerVal) {
        ber_bvfree(pBerVal);
    }

    if (pBer) {
        ber_free(pBer, 1);
    }

    RRETURN(hr);
}

HRESULT
BerEncodeReplicationCookie(
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    )
{
    HRESULT hr = E_FAIL;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    if (!pBer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // flag - set to zero, so order of parent & child objects is not important
    //

    if (ber_printf(pBer, "{iio}", 0, MAX_BYTES, pCookie, dwLen) == -1) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = S_OK;

error:
    if (pBer) {
        ber_free(pBer,1);
    }

    return hr;
}


HRESULT
BerEncodeAttribScopedControlValue(
    LPCWSTR pAttribScoped,
    PBERVAL *ppBerVal
    )
{
    HRESULT hr = S_OK;
    BerElement *pBer = NULL;

    LPSTR pszAttribute = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    if (!pBer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Translate the Unicode strings to UTF-8
    //
    hr = UnicodeToUTF8String(pAttribScoped, &pszAttribute);
    BAIL_ON_FAILURE(hr);
    
    //
    // BER-encode the attributeScopedQueryRequestControlValue
    //
    if (ber_printf(pBer, "{s}", pszAttribute) == -1) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }


    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

error:
    if (pBer) {
        ber_free(pBer,1);
    }

    if (pszAttribute)
        FreeADsMem(pszAttribute);
    
    return hr;
}


//
// This is called only by ADsGetMoreResultsDirSync.
//
HRESULT
ADsGetMoreResultsDirSyncHelper(
    IN PLDAP_SEARCHINFO phSearchInfo,
    CCredentials& Credentials
    )
{

    HRESULT hr = S_OK;
    DWORD dwError;
    LPWSTR pszLDAPPath;
    WCHAR pszErrorBuf[MAX_PATH], pszNameBuf[MAX_PATH];
    ULONG totalCount;
    int resType;

    ADsAssert(phSearchInfo);

    //
    // If the searchpref is not dirsync, abandon has been called
    // or if the cookie indicated that there is no more data then
    // we should return right away.
    //
    if (!phSearchInfo->_SearchPref._fDirSync
        || phSearchInfo->_fAbandon
        || !phSearchInfo->_fMoreDirSync) {
        RRETURN(S_ADS_NOMORE_ROWS);
    }

    //
    // We need to update the controls
    //
    hr = AddSearchControls(
             phSearchInfo,
             Credentials
             );
    BAIL_ON_FAILURE(hr);

    //
    // Need to allocate more messages in the buffer
    //
    if ( phSearchInfo->_SearchPref._fCacheResults ) {

        ADsAssert(phSearchInfo->_dwCurrResult
                  == phSearchInfo->_dwMaxResultGot);

        phSearchInfo->_dwCurrResult++;
        phSearchInfo->_dwMaxResultGot++;
        if (phSearchInfo->_dwCurrResult >= phSearchInfo->_cSearchResults) {
            //
            // Need to allocate more memory for handles
            //
            phSearchInfo->_pSearchResults = (LDAPMessage **) ReallocADsMem(
                                                 (void *) phSearchInfo->_pSearchResults,
                                                 sizeof(LDAPMessage *) *
                                                 phSearchInfo->_cSearchResults,
                                                 sizeof(LDAPMessage *) *
                                                 (phSearchInfo->_cSearchResults +
                                                 NO_LDAP_RESULT_HANDLES));
            if(!phSearchInfo->_pSearchResults) {
                hr = E_OUTOFMEMORY;
                phSearchInfo->_dwCurrResult--;
                phSearchInfo->_dwMaxResultGot--;
                goto error;
            }
            phSearchInfo->_cSearchResults += NO_LDAP_RESULT_HANDLES;

        }

    }
    else {
        //
        // Release and use the same space to store the next result.
        //
        LdapMsgFree(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
    }


    //
    // Async and sync searches need to be handled differently.
    //
    if (phSearchInfo->_SearchPref._fAsynchronous) {
        //
        // Asynchronous search.
        //
        hr = LdapSearchExt(
                 phSearchInfo->_pConnection,
                 phSearchInfo->_pszBindContextDn,
                 phSearchInfo->_SearchPref._dwSearchScope,
                 phSearchInfo->_pszSearchFilter,
                 phSearchInfo->_ppszAttrs,
                 phSearchInfo->_SearchPref._fAttrsOnly,
                 phSearchInfo->_ServerControls,
                 phSearchInfo->_ClientControls,
                 phSearchInfo->_SearchPref._dwPagedTimeLimit,
                 phSearchInfo->_SearchPref._dwSizeLimit,
                 &phSearchInfo->_currMsgId
                 );

        BAIL_ON_FAILURE(hr);
        phSearchInfo->_fLastResult = FALSE;

        //
        // Wait for atleast one result
        //
        hr = LdapResult(
                 phSearchInfo->_pConnection,
                 phSearchInfo->_currMsgId,
                 LDAP_MSG_RECEIVED,
                 phSearchInfo->_SearchPref._timeout.tv_sec ?
                    &phSearchInfo->_SearchPref._timeout : NULL,
                 &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                 &resType
                 );
        if ((hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR)) ||
            (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))) {
            phSearchInfo->_fLastResult = TRUE;
            RRETURN(S_ADS_NOMORE_ROWS);
        }
        else {
            //
            // Only if there are zero rows returned, return the error,
            // otherwise, store the error and return when GetNextRow is
            // called for the last time
            //
            if (FAILED(hr) &&
                (LdapCountEntries( phSearchInfo->_pConnection,
                    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult])
                 == 0)) {

                BAIL_ON_FAILURE(hr);
            }
            else {

                 phSearchInfo->_hrLastSearch = hr;
                 hr = S_OK;
            }
        }
        phSearchInfo->_fLastPage = TRUE;

    }
    else {
        //
        // Synchronous search
        //
        hr = LdapSearchExtS(
                 phSearchInfo->_pConnection,
                 phSearchInfo->_pszBindContextDn,
                 phSearchInfo->_SearchPref._dwSearchScope,
                 phSearchInfo->_pszSearchFilter,
                 phSearchInfo->_ppszAttrs,
                 phSearchInfo->_SearchPref._fAttrsOnly,
                 phSearchInfo->_ServerControls,
                 phSearchInfo->_ClientControls,
                 (phSearchInfo->_SearchPref._timeout.tv_sec == 0) ?
                        NULL :
                        &phSearchInfo->_SearchPref._timeout,
                 phSearchInfo->_SearchPref._dwSizeLimit,
                 &phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]
                 );
        phSearchInfo->_fLastResult = TRUE;
        phSearchInfo->_fLastPage = TRUE;

    }

    //
    // Only if there are zero rows returned, return the error,
    // otherwise, store the error and return when GetNextRow is
    // called for the last time
    //
    if (FAILED(hr) &&
        (LdapCountEntries( phSearchInfo->_pConnection,
            phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]) == 0)) {
        BAIL_ON_FAILURE(hr);
    }
    else {

         phSearchInfo->_hrLastSearch = hr;
         hr = S_OK;
    }

error:

    RRETURN(hr);
}

//
// This function is very similar to GetMoreResults except that
// it will issue a new search if applicable for the dirsync control.
//
HRESULT
ADsGetMoreResultsDirSync(
    IN PLDAP_SEARCHINFO phSearchInfo,
    CCredentials& Credentials
    )
{
   HRESULT hr = S_OK;
   BOOL fTryAndGetResults = TRUE;

   //
   // If the searchpref is not dirsync, abandon has been called
   // or if the cookie indicated that there is no more data then
   // we should return right away.
   //
   if (!phSearchInfo->_SearchPref._fDirSync
       || phSearchInfo->_fAbandon
       || !phSearchInfo->_fMoreDirSync) {
       RRETURN(S_ADS_NOMORE_ROWS);
   }


   while (fTryAndGetResults) {
       fTryAndGetResults = FALSE;
       hr = ADsGetMoreResultsDirSyncHelper(
                phSearchInfo,
                Credentials
                );

       BAIL_ON_FAILURE(hr);

       StoreDirSyncCookie(
           phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
           phSearchInfo
           );

       if (hr == S_ADS_NOMORE_ROWS && phSearchInfo->_fMoreDirSync) {
           fTryAndGetResults = TRUE;
       }

       //
       // Now we want to see if the first row was valid. We could
       // get back an entry but then not have any rows, just a cookie
       //
       if (!fTryAndGetResults) {
           hr = LdapFirstEntry(
                    phSearchInfo->_pConnection,
                    phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult],
                    &phSearchInfo->_pCurrentRow
                    );

           BAIL_ON_FAILURE(hr);

           if(phSearchInfo->_pCurrentRow) {
               phSearchInfo->_pFirstAttr = NULL;
               phSearchInfo->_fBefFirstRow = FALSE;
               hr = S_OK;
           }
           else {
               hr = S_ADS_NOMORE_ROWS;
               if (phSearchInfo->_fMoreDirSync) {
                   fTryAndGetResults = TRUE;
               }
           }
       } // if !Try and get more results.
   } // while try and get more results.

error :

   RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   LdapInitializeSearchPreferences - Exported helper routine.
//
// Synopsis:   Initializes the search preferences struc to the default values.
//          With this function we can isolate the code in one place.
//
// Arguments:  pSearchPrefs     -   Ptr to search prefs being initialized.
//             fCacheResults    -   The cache results pref is set to this.
//
// Returns:    N/A.
//
// Modifies:   pSearchPrefs.
//
//----------------------------------------------------------------------------
void 
LdapInitializeSearchPreferences(
    LDAP_SEARCH_PREF *pSearchPrefs,
    BOOL fCacheResults
    )
{
    ADsAssert(pSearchPrefs);
    pSearchPrefs->_fAsynchronous = FALSE;
    pSearchPrefs->_dwDerefAliases = FALSE;
    pSearchPrefs->_dwSizeLimit = 0;
    pSearchPrefs->_dwTimeLimit = 0;
    pSearchPrefs->_fAttrsOnly = FALSE;
    pSearchPrefs->_dwSearchScope = LDAP_SCOPE_SUBTREE;
    pSearchPrefs->_timeout.tv_sec = 0;
    pSearchPrefs->_timeout.tv_usec = 0;
    pSearchPrefs->_dwPageSize = 0;
    pSearchPrefs->_dwPagedTimeLimit = 0;
    pSearchPrefs->_dwChaseReferrals = ADS_CHASE_REFERRALS_EXTERNAL;
    pSearchPrefs->_pSortKeys = NULL;
    pSearchPrefs->_nSortKeys = 0;
    pSearchPrefs->_fDirSync = FALSE;
    pSearchPrefs->_pProvSpecific = NULL;
    pSearchPrefs->_fTombStone = FALSE;
    pSearchPrefs->_fCacheResults = fCacheResults;
    pSearchPrefs->_pVLVInfo = NULL;
    pSearchPrefs->_pAttribScoped = NULL;
    pSearchPrefs->_fSecurityDescriptorControl = FALSE;
    
}


//+---------------------------------------------------------------------------
// Function:   ADsHelperGetCurrentRowMessage - used for Umi Search support.
//
// Synopsis:   This returns the current row and the handle of the search.
//          Neither are refCounted but this should not matter cause these
//          will no longer be in use by the caller beyond the scope of
//          the search (before the search is "closed", the handle and
//          message that are got from this search will no longer be in
//          use).
//
// Arguments:  hSearchHandle    -  Handle to the search.
//             ppAdsLdp         -  Pointer to hold returned lda handle.
//             ppLdapMsg        -  Pointer to hold the current "rows" msg.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppAdsLdp and ppLdapMsg if successful.
//
//----------------------------------------------------------------------------
HRESULT
ADsHelperGetCurrentRowMessage(
    IN  ADS_SEARCH_HANDLE hSearchHandle,
    OUT PADSLDP *ppAdsLdp,
    OUT LDAPMessage **ppLdapMsg
    )
{
    HRESULT hr = S_OK;
        PLDAP_SEARCHINFO phSearchInfo = (PLDAP_SEARCHINFO) hSearchHandle;

    if( !phSearchInfo 
        || !phSearchInfo->_pSearchResults) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    if (!phSearchInfo->_pConnection || !phSearchInfo->_pCurrentRow) {
        //
        // Dont have the info we need
        //
        RRETURN(E_FAIL);
    } 
    else {
        //
        // We have the handle and the row we need.
        //
        *ppAdsLdp = phSearchInfo->_pConnection;
        *ppLdapMsg = phSearchInfo->_pCurrentRow;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\symhelp.h ===
#ifndef _WIN64
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    symhelp.h

Abstract:

    Defines the interfaces to the SYMHELP dynamic link library.  Useful for programs
    that want to maintain a debug informaiton data base.

Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

    Mike Seaman (mikese) 20-Jan-1995    Added TranslateAddress

--*/

#ifndef _SYMHELP_
#define _SYMHELP_

typedef enum _LOAD_SYMBOLS_FILTER_REASON {
    LoadSymbolsPathNotFound,
    LoadSymbolsDeferredLoad,
    LoadSymbolsLoad,
    LoadSymbolsUnload,
    LoadSymbolsUnableToLoad
} LOAD_SYMBOLS_FILTER_REASON;

typedef BOOL (*PLOAD_SYMBOLS_FILTER_ROUTINE)(
    HANDLE UniqueProcess,
    LPSTR ImageFilePath,
    DWORD ImageBase,
    DWORD ImageSize,
    LOAD_SYMBOLS_FILTER_REASON Reason
    );

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    );

BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    );

BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    );

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    );

ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

//
// The following function is essentially identical in operation to
//  GetSymbolicNameForAddress, except that it:
//
//  1. Operates only on the calling process.
//  2. Does not require any previous calls to AddImageDebugInformation et al.
//     That is, debug information for all currently loaded modules will
//     be added automatically.

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\srvloc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ldapc.hxx
//
//  Contents:
//
//  History:    06-16-96   yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

CRITICAL_SECTION g_DomainDnsCache;

#define ENTER_DOMAINDNS_CRITSECT()  EnterCriticalSection(&g_DomainDnsCache)
#define LEAVE_DOMAINDNS_CRITSECT()  LeaveCriticalSection(&g_DomainDnsCache)

BOOL g_fDllsLoaded = FALSE;
HANDLE g_hDllNetApi32 = NULL;
HANDLE g_hDllSecur32   = NULL;

extern "C" {

typedef struct _WKSTA_USER_INFO_1A {
    LPSTR  wkui1_username;
    LPSTR  wkui1_logon_domain;
    LPSTR  wkui1_oth_domains;
    LPSTR  wkui1_logon_server;
}WKSTA_USER_INFO_1A, *PWKSTA_USER_INFO_1A, *LPWKSTA_USER_INFO_1A;


NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfoA (
    IN  LPSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

}


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    );

//
// Binds to all the dll's that we need to load dynamically.
// The list is
//          netapi32.dll
//          secur32.dll
//
// The global flag g_fDllsLoaded is updated appropriately.
//
void BindToDlls()
{
    if (g_fDllsLoaded) {
        return;
    }

    //
    // Use the domaindns critical section to control access.
    // There is no real need to define another CS for this as this
    // will utmost be called once.
    //
    DWORD dwLastErr = 0;
    ENTER_DOMAINDNS_CRITSECT();

    //
    // In case someones came in when we were loading the dll's.
    //
    if (g_fDllsLoaded) {
        LEAVE_DOMAINDNS_CRITSECT();
        return;
    }

    //
    // Load dll's - each load lib could have set an error if it fails.
    //

    if (!(g_hDllNetApi32 = LoadLibrary(L"NETAPI32.DLL"))) {
        dwLastErr = GetLastError();
    }

    g_hDllSecur32 = LoadLibrary(L"SECUR32.DLL");

    //
    // We need to set this as the last error since one of the
    // loads failed. This will not work as we add more dll's
    // but for now should be ok. This may not even be needed
    // cause finally we are interested in the actual functions
    // not just the ability to load/unload the dll.
    //
    if (dwLastErr) {
        SetLastError (dwLastErr);
    }

    g_fDllsLoaded = TRUE;

    LEAVE_DOMAINDNS_CRITSECT();

    return;
}

//
//   LoadNetApi32Function
//
//   Args:
//      Function to load.
//
//   Returns: function pointer if successfully loads the function from
//            NETAPI32.DLL. Returns NULL otherwise.
//
//
PVOID LoadNetApi32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllNetApi32) {
        return ((PVOID) GetProcAddress((HMODULE)g_hDllNetApi32, function));
    }

    return NULL;
}


//
//   LoadSecur32Function
//
//   Args:
//      Function to load.
//
//   Returns: function pointer if successfully loads the function from
//            secur32.DLL. Returns NULL otherwise.
//
//
PVOID LoadSecur32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllSecur32) {
        return ((PVOID) GetProcAddress((HMODULE)g_hDllSecur32, function));
    }

    return NULL;
}

//
// Definition for DsGetDcName
//
typedef DWORD (*PF_DsGetDcName) (
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
);

//
// Definition for LsaConnectUntrusted()
//
typedef DWORD (*PF_LsaConnectUntrusted) (
    OUT PHANDLE LsaHandle
    );

//
// For LsaCallAuthenticationPackage
//
typedef DWORD (*PF_LsaCallAuthenticationPackage) (
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

//
// For LsaDeregisterLogonProcess
//
typedef DWORD (*PF_LsaDeregisterLogonProcess) (
    IN HANDLE LsaHandle
    );

//
// For LsaFreeReturnBuffer
//
typedef DWORD (*PF_LsaFreeReturnBuffer) (
    IN PVOID Buffer
    );

#ifdef UNICODE
#define GETDCNAME_API        "DsGetDcNameW"
#else
#define GETDCNAME_API        "DsGetDcNameA"
#endif

//
// These are same for all entry points
//
#define LSACONNECT_UNTRUSTED  "LsaConnectUntrusted"
#define LSACALL_AUTH_PACAKAGE "LsaCallAuthenticationPackage"
#define LSA_DEREG_LOGON_PROC  "LsaDeregisterLogonProcess"
#define LSAFREE_RET_BUFFER    "LsaFreeReturnBuffer"


//
// We will always dynamically laod the dsgetdc api so that
// we can have  single binary for NT4.0 and NT5.0
//
DWORD
DsGetDcNameWrapper(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
    )
{
    static PF_DsGetDcName pfDsGetDcName = NULL ;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfDsGetDcName == NULL && !f_LoadAttempted) {
        pfDsGetDcName =
            (PF_DsGetDcName) LoadNetApi32Function(GETDCNAME_API) ;
        f_LoadAttempted = TRUE;
    }

    if (pfDsGetDcName != NULL) {

        return ((*pfDsGetDcName)(
                      ComputerName,
                      DomainName,
                      DomainGuid,
                      SiteName,
                      Flags,
                      DomainControllerInfo
                      )
                );
    } else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}

//
// Wrapper function for LsaConnectUntrusted.
//
DWORD
LsaConnectUntrustedWrapper(
    OUT PHANDLE LsaHandle
    )
{
    static PF_LsaConnectUntrusted pfLsaConnectUntrusted = NULL ;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfLsaConnectUntrusted == NULL && !f_LoadAttempted) {
        pfLsaConnectUntrusted =
            (PF_LsaConnectUntrusted) LoadSecur32Function(LSACONNECT_UNTRUSTED);
        f_LoadAttempted = TRUE;
    }

    if (pfLsaConnectUntrusted != NULL) {

        return ((*pfLsaConnectUntrusted)(
                      LsaHandle
                      )
                );
    }
    else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}


//
// Wrapper function for LsaCallAuthenticationPackage.
//
DWORD
LsaCallAuthenticationPackageWrapper(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    static PF_LsaCallAuthenticationPackage pfLsaCallAuthPackage = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfLsaCallAuthPackage == NULL && !f_LoadAttempted) {
        pfLsaCallAuthPackage =
            (PF_LsaCallAuthenticationPackage) LoadSecur32Function(
                                                  LSACALL_AUTH_PACAKAGE
                                                  );
        f_LoadAttempted = TRUE;
    }

    if (pfLsaCallAuthPackage != NULL) {

        return ((*pfLsaCallAuthPackage)(
                     LsaHandle,
                     AuthenticationPackage,
                     ProtocolSubmitBuffer,
                     SubmitBufferLength,
                     ProtocolReturnBuffer,
                     ReturnBufferLength,
                     ProtocolStatus
                     )
                );
    }
    else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}


//
// Wrapper function for LsaDeregisterLogonProcess.
//
DWORD
LsaDeregisterLogonProcessWrapper(
    IN HANDLE LsaHandle
    )
{
    static PF_LsaDeregisterLogonProcess pfLsaDerefLgnProc = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfLsaDerefLgnProc == NULL && !f_LoadAttempted) {
        pfLsaDerefLgnProc =
            (PF_LsaDeregisterLogonProcess) LoadSecur32Function(LSA_DEREG_LOGON_PROC);
        f_LoadAttempted = TRUE;
    }

    if (pfLsaDerefLgnProc != NULL) {

        return ((*pfLsaDerefLgnProc)(
                     LsaHandle
                     )
                );
    }
    else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}

//
// Wrapper function for LsaFreeReturnBuffer.
//
DWORD
LsaFreeReturnBufferWrapper(
    IN PVOID Buffer
    )
{
    static PF_LsaFreeReturnBuffer pfLsaFreeRetBuffer = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the function if necessary and only once.
    //
    if (pfLsaFreeRetBuffer == NULL && !f_LoadAttempted) {
        pfLsaFreeRetBuffer =
            (PF_LsaFreeReturnBuffer) LoadSecur32Function(LSAFREE_RET_BUFFER);
        f_LoadAttempted = TRUE;
    }

    if (pfLsaFreeRetBuffer != NULL) {

        return ((*pfLsaFreeRetBuffer)(
                     Buffer
                     )
                );
    }
    else {
        //
        // Could not load library
        //
        return (ERROR_GEN_FAILURE);
    }

}

HANDLE g_hLsa = INVALID_HANDLE_VALUE;

DWORD
GetUserDomainFlatName(
    LPWSTR pszUserName,
    LPWSTR pszDomainFlatName
    )
{

    NTSTATUS dwStatus = NO_ERROR, dwSubStatus = NO_ERROR;

    CHAR pszDomainFlatNameA[MAX_PATH];
    CHAR pszUserNameA[MAX_PATH];

    PWKSTA_USER_INFO_1 pNetWkstaUserInfo = NULL;

    PWKSTA_USER_INFO_1A pNetWkstaUserInfoA = NULL;

    PWKSTA_INFO_100 pNetWkstaInfo = NULL;

    NEGOTIATE_CALLER_NAME_REQUEST Req;
    PNEGOTIATE_CALLER_NAME_RESPONSE pResp = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTempUserName = NULL;
    
    PLSA_UNICODE_STRING pLsaStrUserNameTemp = NULL;
    PLSA_UNICODE_STRING pLsaStrDomainNameTemp = NULL;


#if (defined WIN95)
    dwStatus = NetWkstaUserGetInfoA(
                    NULL,
                    1,
                    (LPBYTE *)&pNetWkstaUserInfoA
                    );

    if (dwStatus != NO_ERROR && dwStatus != ERROR_NO_SUCH_LOGON_SESSION) {
        goto error;
    }

    if (dwStatus == NO_ERROR) {
        AnsiToUnicodeString(
                pNetWkstaUserInfoA->wkui1_logon_domain,
                pszDomainFlatName,
                0
                );
        AnsiToUnicodeString(
                pNetWkstaUserInfoA->wkui1_username,
                pszUserName,
                0
                );

    }

#else

    ENTER_DOMAINDNS_CRITSECT();
    if (g_hLsa == INVALID_HANDLE_VALUE) {
        dwStatus = LsaConnectUntrustedWrapper(&g_hLsa);
    }
    LEAVE_DOMAINDNS_CRITSECT();
    
    if (dwStatus == 0) {

        memset(&Req, 0, sizeof(Req));
        Req.MessageType = NegGetCallerName;

        dwStatus = LsaCallAuthenticationPackageWrapper(
                     g_hLsa,
                     0,
                     &Req,
                     sizeof(Req),
                     (void **)&pResp,
                     &dwSize,
                     &dwSubStatus
                     );

        if ((dwStatus == 0)
            && (dwSubStatus == 0)) {
            
            dwStatus = NO_ERROR;
            pszTempUserName = wcschr(pResp->CallerName, L'\\');
            if (!pszTempUserName) {
                //
                // Looks like there was no domain default to machine then
                //
                dwStatus = ERROR_NO_SUCH_LOGON_SESSION;
            } 
            else {
                //
                // Copy over the relevant information
                //
                *pszTempUserName = L'\0';
                wcscpy(pszDomainFlatName, pResp->CallerName);
                *pszTempUserName = L'\\';
                pszTempUserName++;
                wcscpy(pszUserName, pszTempUserName);
                LsaFreeReturnBufferWrapper(pResp);
            }
        } 
        else {
            if (!dwStatus) 
              dwStatus = dwSubStatus;
        }
          
    }
              

    if (dwStatus != NO_ERROR) {
        //
        // Call LsaGetUserName when there is a failure with the above.
        //
        dwStatus = LsaGetUserName(
                       &pLsaStrUserNameTemp,
                       &pLsaStrDomainNameTemp
                       );

        if (dwStatus == NO_ERROR) {
            //
            // Unicode string may not be NULL terminated.
            //
            memcpy(
                pszDomainFlatName,
                pLsaStrDomainNameTemp->Buffer,
                pLsaStrDomainNameTemp->Length
                );
            pszDomainFlatName[pLsaStrDomainNameTemp->Length / sizeof(WCHAR)] 
                  = L'\0';
            
            memcpy(
                   pszUserName,
                   pLsaStrUserNameTemp->Buffer,
                   pLsaStrUserNameTemp->Length
                   );
            pszUserName[pLsaStrUserNameTemp->Length / sizeof(WCHAR)] = L'\0';

            //
            // Can cleanup the LsaGetUserName mem
            //
            LsaFreeMemory(pLsaStrUserNameTemp->Buffer);
            LsaFreeMemory(pLsaStrUserNameTemp);
            LsaFreeMemory(pLsaStrDomainNameTemp->Buffer);
            LsaFreeMemory(pLsaStrDomainNameTemp);
        } 
        else if (dwStatus != ERROR_NO_SUCH_LOGON_SESSION){
            goto error;
        }

    }
    
    //
    // Make sure this is not NT AUTHORITY
    //
    if (dwStatus == NO_ERROR 
        && !_wcsicmp(g_szNT_Authority, pszDomainFlatName)
        ) 
      {
          //
          // Force fallback to NetWkstaGetInfo as we want machine domain
          //
          dwStatus = ERROR_NO_SUCH_LOGON_SESSION;
      }


    if (dwStatus == NO_ERROR) {
      
        //
        // Do nothing here, we need the else clause already have data.
        //
    }

#endif

    else {


        dwStatus = NetWkstaGetInfo(
                        NULL,
                        100,
                        (LPBYTE *)&pNetWkstaInfo
                        );
        if (dwStatus) {
            goto error;
        }

        wcscpy(pszDomainFlatName, pNetWkstaInfo->wki100_langroup);

    }

error:


    if (pNetWkstaUserInfoA) {

        NetApiBufferFree(pNetWkstaUserInfoA);
    }

    if (pNetWkstaUserInfo) {

        NetApiBufferFree(pNetWkstaUserInfo);
    }

    if (pNetWkstaInfo) {

        NetApiBufferFree(pNetWkstaInfo);
    }

    return(dwStatus);

}

DWORD
GetDomainDNSNameForDomain(
    LPWSTR pszDomainFlatName,
    BOOL fVerify,
    BOOL fWriteable,
    LPWSTR pszServerName,
    LPWSTR pszDomainDNSName
    )
{
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD dwStatus = 0;
    DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;

    if (fVerify)
        Flags |= DS_FORCE_REDISCOVERY ;

    if (fWriteable)
        Flags |= DS_WRITABLE_REQUIRED ;

    dwStatus = DsGetDcNameWrapper(
                   NULL,
                   pszDomainFlatName,
                   NULL,
                   NULL,
                   Flags,
                   &pDomainControllerInfo
                   ) ;

    if (dwStatus == NO_ERROR) {

        wcscpy(pszServerName,pDomainControllerInfo->DomainControllerName+2);

        wcscpy(pszDomainDNSName,pDomainControllerInfo->DomainName);

       (void) NetApiBufferFree(pDomainControllerInfo) ;


    }

    return(dwStatus);
}


typedef struct _domaindnslist {
   LPWSTR pszUserName;
   LPWSTR pszUserDomainName;
   LPWSTR pszDomainDns;
   LPWSTR pszServer;
   struct _domaindnslist *pNext;
} DOMAINDNSLIST, *PDOMAINDNSLIST;

PDOMAINDNSLIST gpDomainDnsList = NULL;

BOOL
EquivalentDomains(
    PDOMAINDNSLIST pTemp,
    LPWSTR pszUserDomainName
    );

DWORD
GetDefaultDomainName(
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable,
    BOOL fVerify
    )
{

    DWORD dwStatus = 0;
    WCHAR szUserDomainName[MAX_PATH];
    WCHAR szUserName[MAX_PATH];

    PDOMAINDNSLIST pTemp = NULL;
    PDOMAINDNSLIST pNewNode = NULL;


    dwStatus = GetUserDomainFlatName(
                        szUserName,
                        szUserDomainName
                        );
    if (dwStatus) {
        goto error;
    }

    // We want do a DsGetDc if the fVerify flags is specified
    // so we do not want to look at our list if that is the case.

    if (!fVerify) {

        ENTER_DOMAINDNS_CRITSECT();

        pTemp = gpDomainDnsList;

        while (pTemp) {

            if (EquivalentDomains(pTemp, szUserDomainName)){

                wcscpy(szDomainDnsName,pTemp->pszDomainDns);
                wcscpy(szServerName,pTemp->pszServer);

                LEAVE_DOMAINDNS_CRITSECT();

                return(NO_ERROR);
            }

            pTemp = pTemp->pNext;

        }

        LEAVE_DOMAINDNS_CRITSECT();
    }

    // We will hit this block if either fVerify == TRUE or if
    // we did not find a match in our list above.

    dwStatus = GetDomainDNSNameForDomain(
                        szUserDomainName,
                        fVerify,
                        fWriteable,
                        szServerName,
                        szDomainDnsName
                        );
    if (dwStatus) {
        goto error;
    }


    ENTER_DOMAINDNS_CRITSECT();

    pTemp =  gpDomainDnsList;

    while (pTemp) {

        if (EquivalentDomains(pTemp, szUserDomainName)) {
            //
            // Found a match -looks like someone has come in before us
            //

            wcscpy(szDomainDnsName, pTemp->pszDomainDns);
            wcscpy(szServerName,pTemp->pszServer);

            LEAVE_DOMAINDNS_CRITSECT();

            return(NO_ERROR);
        }

        pTemp = pTemp->pNext;

    }

    pNewNode = (PDOMAINDNSLIST)AllocADsMem(sizeof(DOMAINDNSLIST));

    if (!pNewNode) {

        LEAVE_DOMAINDNS_CRITSECT();

        return(dwStatus = (DWORD) E_OUTOFMEMORY);
    }

    pNewNode->pNext = gpDomainDnsList;


    pNewNode->pszUserName = AllocADsStr(szUserName);
    pNewNode->pszUserDomainName = AllocADsStr(szUserDomainName);
    pNewNode->pszDomainDns = AllocADsStr(szDomainDnsName);
    pNewNode->pszServer = AllocADsStr(szServerName);

    gpDomainDnsList = pNewNode;

    LEAVE_DOMAINDNS_CRITSECT();


error:

    return(dwStatus);
}


DWORD
GetGCDomainName(
    LPWSTR pszDomainDNSName,
    LPWSTR pszServerName
    )
{
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD dwStatus = 0;
    DWORD Flags = DS_GC_SERVER_REQUIRED | DS_RETURN_DNS_NAME;

    /*
    Flags |= DS_FORCE_REDISCOVERY ;
    Flags |= DS_WRITABLE_REQUIRED ;
    */

    dwStatus = DsGetDcNameWrapper(
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   Flags,
                   &pDomainControllerInfo
                   ) ;

    if (dwStatus == NO_ERROR) {

        wcscpy(pszServerName,pDomainControllerInfo->DomainControllerName+2);

        wcscpy(pszDomainDNSName,pDomainControllerInfo->DnsForestName);

       (void) NetApiBufferFree(pDomainControllerInfo) ;


    }

    return(dwStatus);
}

DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    )
{
    LPWSTR pszAddresses[5];
    DWORD dwStatus = NO_ERROR;

    if (dwPort == USE_DEFAULT_GC_PORT) {
        dwStatus = GetGCDomainName(
                            szDomainDnsName,
                            szServerName);
    }
    else {
        dwStatus = GetDefaultDomainName(
                            szDomainDnsName,
                            szServerName,
                            fWriteable,
                            fVerify
                            );
    }

    return(dwStatus);

}

//
// Helper to see if we can use the cache for an domain DNS name
// given a domain flat name.
//
BOOL
EquivalentDomains(
    PDOMAINDNSLIST pTemp,
    LPWSTR pszUserDomainName
    )
{

    if (!pszUserDomainName || !*pszUserDomainName) {
        return(FALSE);
    }

#ifdef WIN95
    if (!_wcsicmp(pszUserDomainName, pTemp->pszUserDomainName)) {
#else
    if (CompareStringW(
            LOCALE_SYSTEM_DEFAULT,
            NORM_IGNORECASE,
            pszUserDomainName,
            -1,
            pTemp->pszUserDomainName,
            -1
            ) == CSTR_EQUAL ) {
#endif
            return(TRUE);

    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\symhelp.c ===
#if !defined(WIN95) && defined(_X86_)
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    symhelp.c

Abstract:



Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

--*/


#define _SYMHELP_SOURCE_

#include "dswarn.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <symhelp.h>
#include <stdio.h>
#include <stdlib.h>

//
// Primitives to access symbolic debug information in an image file
//

typedef struct _RTL_SYMBOL_INFORMATION {
    ULONG Type;
    ULONG SectionNumber;
    ULONG Value;
    STRING Name;
} RTL_SYMBOL_INFORMATION, *PRTL_SYMBOL_INFORMATION;

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    );

typedef struct _PROCESS_DEBUG_INFORMATION {
    LIST_ENTRY List;
    HANDLE UniqueProcess;
    DWORD ImageBase;
    DWORD EndOfImage;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    UCHAR ImageFilePath[ MAX_PATH ];
} PROCESS_DEBUG_INFORMATION, *PPROCESS_DEBUG_INFORMATION;


PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilterRoutine;

RTL_CRITICAL_SECTION LoadedImageDebugInfoListCritSect;
LIST_ENTRY LoadedImageDebugInfoListHead;
LIST_ENTRY LoadedProcessDebugInfoListHead;

LPSTR SymbolSearchPath;

// This variable tracks how many times InitializeImageDebugInformation has been
//  called. Certain operations are performed only on the first call (as
//  NumInitCalls transitions from -1 to 0).
LONG NumInitCalls = -1;

LPSTR
GetEnvVariable(
    IN LPSTR VariableName
    )
{
    NTSTATUS Status;
    STRING Name, Value;
    UNICODE_STRING UnicodeName, UnicodeValue;

    RtlInitString( &Name, VariableName );
    RtlInitUnicodeString( &UnicodeValue, NULL );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (Status != STATUS_BUFFER_TOO_SMALL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    UnicodeValue.MaximumLength = UnicodeValue.Length + sizeof( UNICODE_NULL );
    UnicodeValue.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, UnicodeValue.MaximumLength );
    if (UnicodeValue.Buffer == NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlUnicodeStringToAnsiString( &Value, &UnicodeValue, TRUE );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Value.Buffer[ Value.Length ] = '\0';
    return Value.Buffer;
}

LPSTR
SetSymbolSearchPath( )
{
    ULONG Size, i, Attributes, NumberOfSymbolPaths;
    LPSTR s, SymbolPaths[ 4 ];

    if (SymbolSearchPath != NULL) {
        return SymbolSearchPath;
        }

    Size = 0;
    NumberOfSymbolPaths = 0;
    if (s = GetEnvVariable( "_NT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "_NT_ALT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "SystemRoot" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    SymbolPaths[ NumberOfSymbolPaths++ ] = ".";

    Size = 1;
    for (i=0; i<NumberOfSymbolPaths; i++) {
        Attributes = GetFileAttributesA( SymbolPaths[ i ] );
        if ( Attributes != 0xffffffff && (Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
            Size += 1 + strlen( SymbolPaths[ i ] );
            }
        else {
            SymbolPaths[ i ] = NULL;
            }
        }

    SymbolSearchPath = RtlAllocateHeap( RtlProcessHeap(), 0, Size );
    if (SymbolSearchPath == NULL) {
        return NULL;
        }
    *SymbolSearchPath = '\0';
    for (i=0; i<NumberOfSymbolPaths; i++) {
        if (s = SymbolPaths[ i ]) {
            if (*SymbolSearchPath != '\0') {
                strcat( SymbolSearchPath, ";" );
                }
            strcat( SymbolSearchPath, s );
            }
        }

    return SymbolSearchPath;
}

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    )
{
    PPEB Peb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    PLIST_ENTRY LdrHead, LdrNext;
    PPEB_LDR_DATA Ldr;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPSTR ImageFilePath;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    RTL_PROCESS_MODULES ModuleInfoBuffer;
    PRTL_PROCESS_MODULES ModuleInfo;
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo1;
    SIZE_T RequiredLength;
    ULONG ModuleNumber;

    // Is this the first call?
    if ( InterlockedIncrement ( &NumInitCalls ) == 0 )
    {
        // Yes
        SetSymbolSearchPath();
        InitializeListHead( &LoadedImageDebugInfoListHead );
        InitializeListHead( &LoadedProcessDebugInfoListHead );
        RtlInitializeCriticalSection( &LoadedImageDebugInfoListCritSect );
    }

    // The filter routine can be superceded at any time.
    LoadSymbolsFilterRoutine = LoadSymbolsFilter;

    if (GetKernelSymbols) {
        ModuleInfo = &ModuleInfoBuffer;
        RequiredLength = sizeof( *ModuleInfo );
        Status = NtQuerySystemInformation( SystemModuleInformation,
                                           ModuleInfo,
                                           (ULONG)RequiredLength,
                                           (PULONG)&RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            ModuleInfo = NULL;
            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &ModuleInfo,
                                              0,
                                              &RequiredLength,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );
            if (NT_SUCCESS( Status )) {
                Status = NtQuerySystemInformation( SystemModuleInformation,
                                                   ModuleInfo,
                                                   (ULONG)RequiredLength,
                                                   (PULONG)&RequiredLength
                                                 );
                if (NT_SUCCESS( Status )) {
                    ModuleInfo1 = &ModuleInfo->Modules[ 0 ];
                    for (ModuleNumber=0; ModuleNumber<ModuleInfo->NumberOfModules; ModuleNumber++) {
                        if ((DWORD)(ModuleInfo1->ImageBase) & 0x80000000) {
                            if (ImageFilePath = strchr( ModuleInfo1->FullPathName, ':')) {
                                ImageFilePath -= 1;
                                }
                            else {
                                ImageFilePath = ModuleInfo1->FullPathName +
                                                strlen( ModuleInfo1->FullPathName );
                                while (ImageFilePath > ModuleInfo1->FullPathName) {
                                    if (ImageFilePath[ -1 ] == '\\') {
                                        break;
                                        }
                                    else {
                                        ImageFilePath -= 1;
                                        }
                                    }
                                }

                            AddImageDebugInformation( NULL,
                                                      ImageFilePath,
                                                      (DWORD)ModuleInfo1->ImageBase,
                                                      ModuleInfo1->ImageSize
                                                    );
                            }

                        ModuleInfo1++;
                        }
                    }

                NtFreeVirtualMemory( NtCurrentProcess(),
                                     &ModuleInfo,
                                     &RequiredLength,
                                     MEM_RELEASE
                                   );
                }
            }
        }

    if (TargetProcess == NULL) {

        // Load module information for this process.

        TargetProcess = GetCurrentProcess();
        }

    Status = NtQueryInformationProcess( TargetProcess,
                                        ProcessBasicInformation,
                                        &ProcessInformation,
                                        sizeof( ProcessInformation ),
                                        NULL
                                      );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Peb = ProcessInformation.PebBaseAddress;

    if (NewProcess) {
        return TRUE;
        }

    //
    // Ldr = Peb->Ldr
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &Peb->Ldr,
                                  &Ldr,
                                  sizeof( Ldr ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &LdrHead->Flink,
                                  &LdrNext,
                                  sizeof( LdrNext ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    while (LdrNext != LdrHead) {
        LdrEntry = CONTAINING_RECORD( LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntry,
                                      &LdrEntryData,
                                      sizeof( LdrEntryData ),
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }

        UnicodeString.Length = LdrEntryData.FullDllName.Length;
        UnicodeString.MaximumLength = LdrEntryData.FullDllName.MaximumLength;
        UnicodeString.Buffer = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                UnicodeString.MaximumLength
                                              );
        if (!UnicodeString.Buffer) {
            return FALSE;
            }
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntryData.FullDllName.Buffer,
                                      UnicodeString.Buffer,
                                      UnicodeString.MaximumLength,
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
            return FALSE;
            }

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &UnicodeString,
                                      TRUE
                                    );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
        if (ImageFilePath = strchr( AnsiString.Buffer, ':')) {
            ImageFilePath -= 1;
            }
        else {
            ImageFilePath = AnsiString.Buffer;
            }

        AddImageDebugInformation( (HANDLE)ProcessInformation.UniqueProcessId,
                                  ImageFilePath,
                                  (DWORD)LdrEntryData.DllBase,
                                  LdrEntryData.SizeOfImage
                                );

        RtlFreeAnsiString( &AnsiString );

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }

    return TRUE;
}


BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo = NULL;
    PPROCESS_DEBUG_INFORMATION ProcessInfo = NULL;
    HANDLE FileHandle;
    UCHAR PathBuffer[ MAX_PATH ];

    FileHandle = FindExecutableImage( ImageFilePath, SymbolSearchPath, PathBuffer );
    if (FileHandle == NULL) {
        if (LoadSymbolsFilterRoutine != NULL) {
            (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                         ImageFilePath,
                                         ImageBase,
                                         ImageSize,
                                         LoadSymbolsPathNotFound
                                       );
            }

        return FALSE;
        }
    CloseHandle( FileHandle );
    if (LoadSymbolsFilterRoutine != NULL) {
        (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                     PathBuffer,
                                     ImageBase,
                                     ImageSize,
                                     LoadSymbolsDeferredLoad
                                   );
        }

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Head = &LoadedImageDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        DebugInfo = CONTAINING_RECORD( Next, IMAGE_DEBUG_INFORMATION, List );
        if (DebugInfo->ImageBase == ImageBase &&
            !_stricmp( PathBuffer, DebugInfo->ImageFilePath )
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        DebugInfo = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            !_stricmp( PathBuffer, ProcessInfo->ImageFilePath )
           ) {
            return TRUE;
            }

        Next = Next->Flink;
        }

    ProcessInfo = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( *ProcessInfo ) );
    if (ProcessInfo == NULL) {
        return FALSE;
        }
    ProcessInfo->ImageBase = ImageBase;
    ProcessInfo->EndOfImage = ImageBase + ImageSize;
    ProcessInfo->UniqueProcess = UniqueProcess;
    ProcessInfo->DebugInfo = DebugInfo;
    strcpy( ProcessInfo->ImageFilePath, PathBuffer );
    InsertTailList( &LoadedProcessDebugInfoListHead, &ProcessInfo->List );

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return TRUE;
}


BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    )
{
    PLIST_ENTRY Head, Next;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            (!ARGUMENT_PRESENT( ImageFilePath ) ||
             !_stricmp( ImageFilePath, ProcessInfo->ImageFilePath )
            )
           ) {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnload
                                           );
                }

            Next = Next->Blink;
            RemoveEntryList( &ProcessInfo->List );
            RtlFreeHeap( RtlProcessHeap(), 0, ProcessInfo );
            if (ARGUMENT_PRESENT( ImageFilePath )) {
                break;
                }
            }

        Next = Next->Flink;
        }

    return TRUE;
}

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    if (Address & 0x80000000) {
        UniqueProcess = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            Address >= ProcessInfo->ImageBase &&
            Address < ProcessInfo->EndOfImage
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
        return NULL;
        }

    DebugInfo = ProcessInfo->DebugInfo;
    if (DebugInfo == NULL) {
        DebugInfo = MapDebugInformation( NULL, ProcessInfo->ImageFilePath, SymbolSearchPath, ProcessInfo->ImageBase );
        if (DebugInfo != NULL) {
            DebugInfo->ImageBase = ProcessInfo->ImageBase;
            ProcessInfo->DebugInfo = DebugInfo;
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsLoad
                                           );
                }

            InsertTailList( &LoadedImageDebugInfoListHead, &DebugInfo->List );
            }
        else {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnableToLoad
                                           );
                }
            }
        }

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return DebugInfo;
}


ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    )
{
    NTSTATUS Status;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    RTL_SYMBOL_INFORMATION SymbolInformation;
    ULONG i, ModuleNameLength, Result, Offset;
    LPSTR s;

    DebugInfo = FindImageDebugInformation( UniqueProcess,
                                           Address
                                         );
    if (DebugInfo != NULL) {
        if (s = strchr( DebugInfo->ImageFileName, '.' )) {
            ModuleNameLength = (ULONG)(s - DebugInfo->ImageFileName);
            }
        else {
            ModuleNameLength = strlen( DebugInfo->ImageFileName );
            }

        //  [mikese] RtlLookupSymbolByAddress will fault if there is
        //  no COFF symbol information.
        if ( DebugInfo->CoffSymbols != NULL ) {
            Status = RtlLookupSymbolByAddress( (PVOID)DebugInfo->ImageBase,
                                       DebugInfo->CoffSymbols,
                                       (PVOID)Address,
                                       0x4000,
                                       &SymbolInformation,
                                       NULL
                                     );

            }
        else {
            Status = STATUS_UNSUCCESSFUL;
             }
        }
    else {
        ModuleNameLength = 0;
        Status = STATUS_UNSUCCESSFUL;
        }

    if (NT_SUCCESS( Status )) {
        s = SymbolInformation.Name.Buffer;
        i = 1;
        while (SymbolInformation.Name.Length > i &&
               isdigit( s[ SymbolInformation.Name.Length - i ] )
              ) {
            i += 1;
            }

        if (s[ SymbolInformation.Name.Length - i ] == '@') {
            SymbolInformation.Name.Length = (USHORT)(SymbolInformation.Name.Length - i);
            }

        s = Name;
        Result = _snprintf( s, MaxNameLength,
                            "%.*s!%Z",
                            ModuleNameLength,
                            DebugInfo->ImageFileName,
                            &SymbolInformation.Name
                          );
        Offset = (ULONG)(Address - DebugInfo->ImageBase) - SymbolInformation.Value;
        if (Offset != 0) {
            Result += _snprintf( s + Result, MaxNameLength - Result, "+0x%x", Offset );
            }
        }
    else {
        if (ModuleNameLength != 0) {
            Result = _snprintf( Name, MaxNameLength,
                                "%.*s!0x%08x",
                                ModuleNameLength,
                                DebugInfo->ImageFileName,
                                Address
                              );
            }
        else {
            Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }

    return Result;
}

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength )
{
    PRTL_DEBUG_INFORMATION p;
    NTSTATUS Status;
    DWORD ProcessId;
    ULONG Result = 0;
    ULONG Attempts = 0;

    // We need to call Initialize once to ensure that GetSymbolicNameForAddress
    //  does not fault.
    if ( NumInitCalls == -1 )
    {
        InitializeImageDebugInformation( LoadSymbolsFilterRoutine,
                                         NULL, FALSE, FALSE );
    }

    ProcessId = GetCurrentProcessId();

    while ( Result == 0 )
    {
        Result = GetSymbolicNameForAddress ( (HANDLE)ProcessId, Address,
                                             Name, MaxNameLength );
        if ( Result == 0 )
        {
            if ( ++Attempts < 2 )
            {
                // Try reintialising, to load any modules we missed on a previous
                //  occasion (or if we haven't initialised yet).
                // I don't need a load-symbols-filter, so just use whatever is
                //  already there, if any
                InitializeImageDebugInformation( LoadSymbolsFilterRoutine,
                                                 NULL, FALSE, FALSE );
            }
            else
            {
                // Apparently we are unable to do the right thing, so just return
                //  the address as hex.
                Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }
    }

    return Result;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    );

PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    );

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    )
/*++

Routine Description:

    Given a code address, this routine returns the nearest symbol
    name and the offset from the symbol to that name.  If the
    nearest symbol is not within ClosenessLimit of the location,
    STATUS_ENTRYPOINT_NOT_FOUND is returned.

Arguments:

    ImageBase - Supplies the base address of the image containing
                Address

    MappedBase - Optional parameter, that if specified means the image
                 was mapped as a data file and the MappedBase gives the
                 location it was mapped.  If this parameter does not
                 point to an image file base, then it is assumed that
                 this is a pointer to the coff debug info.

    ClosenessLimit - Specifies the maximum distance that Address can be
                     from the value of a symbol to be considered
                     "found".  Symbol's whose value is further away then
                     this are not "found".

    SymbolInformation - Points to a structure that is filled in by
                        this routine if a symbol table entry is found.

    NextSymbolInformation - Optional parameter, that if specified, is
                            filled in with information about these
                            symbol whose value is the next address above
                            Address


Return Value:

    Status of operation.

--*/

{
    NTSTATUS Status;
    ULONG AddressOffset, i;
    PIMAGE_SYMBOL PreviousSymbolEntry = NULL;
    PIMAGE_SYMBOL SymbolEntry;
    IMAGE_SYMBOL Symbol;
    PUCHAR StringTable;
    BOOLEAN SymbolFound;
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;

    DebugInfo = RtlpGetCoffDebugInfo( ImageBase, MappedBase );
    if (DebugInfo == NULL) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // Crack the symbol table.
    //

    SymbolEntry = (PIMAGE_SYMBOL)
        ((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);

    StringTable = (PUCHAR)
        ((ULONG)SymbolEntry + DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);


    //
    // Find the "header" symbol (skipping all the section names)
    //

    for (i = 0; i < DebugInfo->NumberOfSymbols; i++) {
        if (!strcmp( &SymbolEntry->N.ShortName[ 0 ], "header" )) {
            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                        IMAGE_SIZEOF_SYMBOL);
        }

    //
    // If no "header" symbol found, just start at the first symbol.
    //

    if (i >= DebugInfo->NumberOfSymbols) {
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
        i = 0;
        }

    //
    // Loop through all symbols in the symbol table.  For each symbol,
    // if it is within the code section, subtract off the bias and
    // see if there are any hits within the profile buffer for
    // that symbol.
    //

    AddressOffset = (ULONG)Address - (ULONG)ImageBase;
    SymbolFound = FALSE;
    for (; i < DebugInfo->NumberOfSymbols; i++) {

        //
        // Skip over any Auxilliary entries.
        //
        try {
            while (SymbolEntry->NumberOfAuxSymbols) {
                i = i + 1 + SymbolEntry->NumberOfAuxSymbols;
                SymbolEntry = (PIMAGE_SYMBOL)
                    ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL +
                     SymbolEntry->NumberOfAuxSymbols * IMAGE_SIZEOF_SYMBOL
                    );

                }

            RtlMoveMemory( &Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL );
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
            }

        //
        // If this symbol value is less than the value we are looking for.
        //

        if (Symbol.Value <= AddressOffset) {
            //
            // Then remember this symbol entry.
            //

            PreviousSymbolEntry = SymbolEntry;
            SymbolFound = TRUE;
            }
        else {
            //
            // All done looking if value of symbol is greater than
            // what we are looking for, as symbols are in address order
            //

            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)
            ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL);

        }

    if (!SymbolFound || (AddressOffset - PreviousSymbolEntry->Value) > ClosenessLimit) {
        return STATUS_ENTRYPOINT_NOT_FOUND;
        }

    Status = RtlpCaptureSymbolInformation( PreviousSymbolEntry, StringTable, SymbolInformation );
    if (NT_SUCCESS( Status ) && ARGUMENT_PRESENT( NextSymbolInformation )) {
        Status = RtlpCaptureSymbolInformation( SymbolEntry, StringTable, NextSymbolInformation );
        }

    return Status;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    )
{
    USHORT MaximumLength;
    PCHAR s;

    SymbolInformation->SectionNumber = SymbolEntry->SectionNumber;
    SymbolInformation->Type = SymbolEntry->Type;
    SymbolInformation->Value = SymbolEntry->Value;

    if (SymbolEntry->N.Name.Short) {
        MaximumLength = 8;
        s = &SymbolEntry->N.ShortName[ 0 ];
        }

    else {
        MaximumLength = 64;
        s = &StringTable[ SymbolEntry->N.Name.Long ];
        }

#if i386
    if (*s == '_') {
        s++;
        MaximumLength--;
        }
#endif

    SymbolInformation->Name.Buffer = s;
    SymbolInformation->Name.Length = 0;
    while (*s && MaximumLength--) {
        SymbolInformation->Name.Length++;
        s++;
        }

    SymbolInformation->Name.MaximumLength = SymbolInformation->Name.Length;
    return( STATUS_SUCCESS );
}


PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    )
{
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    ULONG DebugSize;
    ULONG NumberOfDebugDirectories;

    DosHeader = (PIMAGE_DOS_HEADER)MappedBase;
    if ( !DosHeader || DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {
        //
        // Locate debug section.
        //

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)(MappedBase == NULL ? ImageBase : MappedBase),
                                          (BOOLEAN)(MappedBase == NULL ? TRUE : FALSE),
                                          IMAGE_DIRECTORY_ENTRY_DEBUG,
                                          &DebugSize
                                        );

        if (!DebugDirectory ||
            (DebugSize < sizeof(IMAGE_DEBUG_DIRECTORY)) ||
            ((DebugSize % sizeof(IMAGE_DEBUG_DIRECTORY)) != 0)) {
            return NULL;
        }
        //
        // point debug directory at coff debug directory
        //
        NumberOfDebugDirectories = DebugSize / sizeof(*DebugDirectory);

        while ( NumberOfDebugDirectories-- ) {
            if ( DebugDirectory->Type == IMAGE_DEBUG_TYPE_COFF ) {
                break;
            }
            DebugDirectory++;
        }

        if (DebugDirectory->Type != IMAGE_DEBUG_TYPE_COFF ) {
            return NULL;
        }

        if (MappedBase == NULL) {
            if (DebugDirectory->AddressOfRawData == 0) {
                return(NULL);
            }
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) ImageBase + DebugDirectory->AddressOfRawData);
        } else {
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) MappedBase + DebugDirectory->PointerToRawData);
        }
    } else {
        DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)MappedBase;
    }
    return DebugInfo;
}
#else
//4602 nonstandard extension used : translation unit is empty
#pragma warning (disable:4206)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ldapc\util.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      util.cxx
//
//  Contents:  Some misc helper functions
//
//  History:
//----------------------------------------------------------------------------
#include "ldapc.hxx"
#pragma hdrstop

#if 0
// ADsGetSearchPreference code
//
// Must explicitly include here since adshlp.h
// is not #included.
//
#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI
ADsGetSearchPreference(
    ADS_SEARCH_HANDLE hSearchHandle,
    LPWSTR lpszPathName,
    PADS_SEARCHPREF_INFO *ppSearchPrefs,
    PDWORD pdwNumPrefs
    );

#ifdef __cplusplus
}
#endif


HRESULT
UTF8ToUnicodeString(
    LPCSTR   pUTF8,
    LPWSTR *ppUnicode
    );
#endif

//
// The following table needs to be sorted
//
SEARCHENTRY g_aSyntaxSearchTable[] =
{
  { TEXT("AccessPointDN"),   LDAPTYPE_ACCESSPOINTDN }, // in NTDS, not in LDAP
  { TEXT("AttributeTypeDescription"), LDAPTYPE_ATTRIBUTETYPEDESCRIPTION },
  { TEXT("Audio"),           LDAPTYPE_AUDIO },
  { TEXT("Binary"),          LDAPTYPE_OCTETSTRING },
  { TEXT("BitString"),       LDAPTYPE_BITSTRING },
  { TEXT("Boolean"),         LDAPTYPE_BOOLEAN },
  { TEXT("CaseExactString") ,LDAPTYPE_CASEEXACTSTRING },
  { TEXT("CaseIgnoreString"),LDAPTYPE_CASEIGNORESTRING },  // in NTDS, not in LDAP RFC
  { TEXT("Certificate"),     LDAPTYPE_CERTIFICATE },
  { TEXT("CertificateList"), LDAPTYPE_CERTIFICATELIST },
  { TEXT("CertificatePair"), LDAPTYPE_CERTIFICATEPAIR },
  { TEXT("Country"),         LDAPTYPE_COUNTRYSTRING },
  { TEXT("DataQualitySyntax"),LDAPTYPE_DATAQUALITYSYNTAX },
  { TEXT("DeliveryMethod"),  LDAPTYPE_DELIVERYMETHOD },
  { TEXT("DirectoryString"), LDAPTYPE_DIRECTORYSTRING },
  { TEXT("DN"),              LDAPTYPE_DN },
  { TEXT("DSAQualitySyntax"),LDAPTYPE_DSAQUALITYSYNTAX },
  { TEXT("EnhancedGuide"),   LDAPTYPE_ENHANCEDGUIDE },
  { TEXT("FacsimileTelephoneNumber"),   LDAPTYPE_FACSIMILETELEPHONENUMBER },
  { TEXT("Fax"),             LDAPTYPE_FAX },
  { TEXT("GeneralizedTime"), LDAPTYPE_GENERALIZEDTIME },
  { TEXT("Guide"),           LDAPTYPE_GUIDE },
  { TEXT("IA5String"),       LDAPTYPE_IA5STRING },
  { TEXT("INTEGER"),         LDAPTYPE_INTEGER },
  { TEXT("INTEGER8"),        LDAPTYPE_INTEGER8 }, // in NTDS, not in LDAP RFC
  { TEXT("JPEG"),            LDAPTYPE_JPEG },
  { TEXT("MailPreference"),  LDAPTYPE_MAILPREFERENCE },
  { TEXT("NameAndOptionalUID"), LDAPTYPE_NAMEANDOPTIONALUID },
  { TEXT("NumericString"),   LDAPTYPE_NUMERICSTRING },
  { TEXT("ObjectClassDescription"), LDAPTYPE_OBJECTCLASSDESCRIPTION },
  { TEXT("ObjectSecurityDescriptor"), LDAPTYPE_SECURITY_DESCRIPTOR},
  { TEXT("OctetString"),     LDAPTYPE_OCTETSTRING }, // in NTDS, not in LDAP RFC
  { TEXT("OID"),             LDAPTYPE_OID },
  { TEXT("ORAddress"),       LDAPTYPE_ORADDRESS },
  { TEXT("ORName"),          LDAPTYPE_ORNAME },  // in NTDS, not in LDAP RFC
  { TEXT("OtherMailbox"),    LDAPTYPE_OTHERMAILBOX },
  { TEXT("Password"),        LDAPTYPE_PASSWORD },
  { TEXT("PostalAddress"),   LDAPTYPE_POSTALADDRESS },
  { TEXT("PresentationAddress"), LDAPTYPE_PRESENTATIONADDRESS },
  { TEXT("PrintableString"), LDAPTYPE_PRINTABLESTRING },
  { TEXT("TelephoneNumber"), LDAPTYPE_TELEPHONENUMBER },
  { TEXT("TeletexTerminalIdentifier"), LDAPTYPE_TELETEXTERMINALIDENTIFIER },
  { TEXT("TelexNumber"),     LDAPTYPE_TELEXNUMBER },
  // 
  // Allegedly, "Time" started out as a bug in the schema (the correct description
  // is "GeneralizedTime").  However, we never delete items from the schema, so it
  // is still present in the current Whistler schema
  // (4/27/2000), so we'll keep in support for it.
  //
  { TEXT("Time"),            LDAPTYPE_GENERALIZEDTIME },
  { TEXT("UTCTIME"),         LDAPTYPE_UTCTIME }
};

DWORD g_nSyntaxSearchTableSize = ARRAY_SIZE(g_aSyntaxSearchTable );


//
// The following table needs to be sorted (lexicographically) on the first field
//

SEARCHENTRY g_aOidSyntaxSearchTable[] = {
  // the type is ORName a type of string -> mapped to string.
  { TEXT("1.2.840.113556.1.4.1221"),           LDAPTYPE_CASEIGNORESTRING },
  // the type is Undefined syntax in the server, so we are defaulting.
  { TEXT("1.2.840.113556.1.4.1222"),           LDAPTYPE_OCTETSTRING},
  { TEXT("1.2.840.113556.1.4.1362"),           LDAPTYPE_CASEEXACTSTRING},
  { TEXT("1.2.840.113556.1.4.903"),            LDAPTYPE_DNWITHBINARY},
  { TEXT("1.2.840.113556.1.4.904"),            LDAPTYPE_DNWITHSTRING},
  { TEXT("1.2.840.113556.1.4.905"),            LDAPTYPE_CASEIGNORESTRING },
  { TEXT("1.2.840.113556.1.4.906"),            LDAPTYPE_INTEGER8 },
  { TEXT("1.2.840.113556.1.4.907"),            LDAPTYPE_SECURITY_DESCRIPTOR },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.10"),     LDAPTYPE_CERTIFICATEPAIR },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.11"),     LDAPTYPE_COUNTRYSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.12"),     LDAPTYPE_DN },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.13"),     LDAPTYPE_DATAQUALITYSYNTAX },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.14"),     LDAPTYPE_DELIVERYMETHOD },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.15"),     LDAPTYPE_DIRECTORYSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.19"),     LDAPTYPE_DSAQUALITYSYNTAX },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.2"),      LDAPTYPE_ACCESSPOINTDN },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.21"),     LDAPTYPE_ENHANCEDGUIDE },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.22"),     LDAPTYPE_FACSIMILETELEPHONENUMBER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.23"),     LDAPTYPE_FAX },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.24"),     LDAPTYPE_GENERALIZEDTIME },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.25"),     LDAPTYPE_GUIDE },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.26"),     LDAPTYPE_IA5STRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.27"),     LDAPTYPE_INTEGER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.28"),     LDAPTYPE_JPEG },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.3"),      LDAPTYPE_ATTRIBUTETYPEDESCRIPTION },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.32"),     LDAPTYPE_MAILPREFERENCE },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.33"),     LDAPTYPE_ORADDRESS },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.34"),     LDAPTYPE_NAMEANDOPTIONALUID },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.36"),     LDAPTYPE_NUMERICSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.37"),     LDAPTYPE_OBJECTCLASSDESCRIPTION },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.38"),     LDAPTYPE_OID },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.39"),     LDAPTYPE_OTHERMAILBOX },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.4"),      LDAPTYPE_AUDIO },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.40"),     LDAPTYPE_OCTETSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.41"),     LDAPTYPE_POSTALADDRESS },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.43"),     LDAPTYPE_PRESENTATIONADDRESS },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.44"),     LDAPTYPE_PRINTABLESTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.5"),      LDAPTYPE_OCTETSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.50"),     LDAPTYPE_TELEPHONENUMBER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.51"),     LDAPTYPE_TELETEXTERMINALIDENTIFIER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.52"),     LDAPTYPE_TELEXNUMBER },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.53"),     LDAPTYPE_UTCTIME },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.6"),      LDAPTYPE_BITSTRING },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.7"),      LDAPTYPE_BOOLEAN },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.8"),      LDAPTYPE_CERTIFICATE },
  { TEXT("1.3.6.1.4.1.1466.115.121.1.9"),      LDAPTYPE_CERTIFICATELIST },
};

DWORD g_nOidSyntaxSearchTableSize = ARRAY_SIZE(g_aOidSyntaxSearchTable );

DWORD
GetSyntaxOfAttribute(
    LPWSTR pszAttrName,
    SCHEMAINFO *pSchemaInfo
)
{
    LPWSTR pszTemp = NULL;

    // Support for range attributes; for eg., objectClass=Range=0-1 We should
    // ignore everything after ';' inclusive.
    //

    if ((pszTemp = wcschr(pszAttrName, L';')) != NULL ) {
        *pszTemp = L'\0';
    }

    DWORD dwEntry = FindEntryInSearchTable( pszAttrName, pSchemaInfo->aPropertiesSearchTable, pSchemaInfo->nNumOfProperties * 2 );

    //
    // Put back the ; if we had replaced it.
    //

    if (pszTemp)
        *pszTemp = L';';

    if ( dwEntry != -1 )
    {
        DWORD dwSyntax = FindEntryInSearchTable( pSchemaInfo->aProperties[dwEntry].pszSyntax, g_aSyntaxSearchTable, ARRAY_SIZE(g_aSyntaxSearchTable) );

        if ( dwSyntax != -1 )
            return dwSyntax;
    }

    return LDAPTYPE_UNKNOWN;
}


DWORD
LdapGetSyntaxIdFromName(
    LPWSTR  pszSyntax
)
{
    DWORD dwSyntaxId;

    dwSyntaxId = FindEntryInSearchTable(
                      pszSyntax,
                      g_aSyntaxSearchTable,
                      g_nSyntaxSearchTableSize );

    if ( dwSyntaxId == -1 ) {

        //
        // We need to look at the OID table before defaulting
        //
        dwSyntaxId = FindEntryInSearchTable(
                         pszSyntax,
                         g_aOidSyntaxSearchTable,
                         g_nOidSyntaxSearchTableSize
                         );
    }

    if (dwSyntaxId == -1 ) {
        dwSyntaxId = LDAPTYPE_UNKNOWN;
    }

    return dwSyntaxId;
}


HRESULT
UnMarshallLDAPToLDAPSynID(
    LPWSTR  pszAttrName,
    ADS_LDP *ld,
    LDAPMessage *entry,
    DWORD dwSyntax,
    LDAPOBJECTARRAY *pldapObjectArray
)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    int nNumberOfValues;

    switch ( dwSyntax ) {

        // The cases below are binary data
        case LDAPTYPE_OCTETSTRING:
        case LDAPTYPE_SECURITY_DESCRIPTOR:
        case LDAPTYPE_CERTIFICATE:
        case LDAPTYPE_CERTIFICATELIST:
        case LDAPTYPE_CERTIFICATEPAIR:
        case LDAPTYPE_PASSWORD:
        case LDAPTYPE_TELETEXTERMINALIDENTIFIER:
        case LDAPTYPE_AUDIO:
        case LDAPTYPE_JPEG:
        case LDAPTYPE_FAX:
        case LDAPTYPE_UNKNOWN:
        {
            struct berval **bValues = NULL;

            hr = LdapGetValuesLen( ld, entry, pszAttrName,
                                   &bValues, &nNumberOfValues );
            BAIL_ON_FAILURE(hr);

            pldapObjectArray->fIsString = FALSE;
            pldapObjectArray->dwCount = nNumberOfValues;
            pldapObjectArray->pLdapObjects = (PLDAPOBJECT) bValues;

            break;
        }


        // otherwise it is a string
        default:
        {
            TCHAR **strValues = NULL;
            hr  = LdapGetValues( ld, entry, pszAttrName,
                                 &strValues, &nNumberOfValues );
            BAIL_ON_FAILURE(hr);

            pldapObjectArray->fIsString = TRUE;
            pldapObjectArray->dwCount = nNumberOfValues;
            pldapObjectArray->pLdapObjects = (PLDAPOBJECT) strValues;

            break;
        }
    }

error:

    RRETURN(hr);
}

#if 0
// ADsGetSearchPreference code

HRESULT WINAPI
ADsGetSearchPreference(
    ADS_SEARCH_HANDLE hSearchHandle,
    LPWSTR lpszPathName,
    PADS_SEARCHPREF_INFO *ppSearchPrefs,
    PDWORD pdwNumPrefs
    )
{
    HRESULT hr = S_OK;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    PLDAP_SEARCHINFO     phSearchInfo= (PLDAP_SEARCHINFO) hSearchHandle;
    PLDAP_SEARCH_PREF    pSearchPref    = NULL;
    PADS_SEARCHPREF_INFO pADsSearchPref = NULL;
    PBYTE                pbExtra        = NULL;

    DWORD dwNumberPrefs = 0;
    DWORD dwNumberExtraBytes = 0;

    //
    // sanity check
    //
    if (!lpszPathName || !ppSearchPrefs || !phSearchInfo || !pdwNumPrefs)
        RRETURN(E_INVALIDARG);

    *ppSearchPrefs = NULL;
    *pdwNumPrefs = 0;

    //
    // Make sure we're being called on an LDAP path
    //
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(lpszPathName, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    if (_tcscmp(pObjectInfo->ProviderName, szProviderName) != 0) {
        BAIL_ON_FAILURE(hr = E_NOTIMPL);
    }

    //
    // allocate space for the ADS_SEARCHPREF_INFO array we're
    // going to build
    //
    pSearchPref = &(phSearchInfo->_SearchPref);
    
    hr = CalcSpaceForSearchPrefs(pSearchPref, &dwNumberPrefs, &dwNumberExtraBytes);
    BAIL_ON_FAILURE(hr);

    // no search prefs were set
    if (dwNumberPrefs == 0) {
        *ppSearchPrefs = NULL;
        FreeObjectInfo(pObjectInfo);
        RRETURN(S_OK);
    }
    

    pADsSearchPref = (PADS_SEARCHPREF_INFO) AllocADsMem( (dwNumberPrefs * sizeof(ADS_SEARCHPREF_INFO)) + dwNumberExtraBytes);
    if (!pADsSearchPref)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    pbExtra = ((PBYTE)pADsSearchPref) + (dwNumberPrefs * sizeof(ADS_SEARCHPREF_INFO));
    

    //
    // construct the array of search prefs
    //
    hr = ConstructSearchPrefArray(pSearchPref, pADsSearchPref, pbExtra);
    BAIL_ON_FAILURE(hr);

    *ppSearchPrefs = pADsSearchPref;
    *pdwNumPrefs   = dwNumberPrefs;

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
    
error:

    if (pADsSearchPref)
        FreeADsMem(pADsSearchPref);

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }


    RRETURN(hr);
}


HRESULT
ConstructSearchPrefArray(
    PLDAP_SEARCH_PREF    pPrefs,
    PADS_SEARCHPREF_INFO pADsSearchPref,
    PBYTE                pbExtraBytes
    )
{
    HRESULT hr = S_OK;
    BOOL fDefault;

    LPSTR pUTF8 = NULL;
    LPWSTR pUnicode = NULL;

    if (!pPrefs || !pADsSearchPref || !pbExtraBytes)
        RRETURN(E_INVALIDARG);


    // ADS_SEARCHPREF_ASYNCHRONOUS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ASYNCHRONOUS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
        pADsSearchPref->vValue.dwType  = ADSTYPE_BOOLEAN;
        pADsSearchPref->vValue.Boolean = pPrefs->_fAsynchronous;
        pADsSearchPref++;
    }
    
    // ADS_SEARCHPREF_DEREF_ALIASES
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_DEREF_ALIASES,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwDerefAliases;
        pADsSearchPref++;
    }
    
    // ADS_SEARCHPREF_SIZE_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SIZE_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwSizeLimit;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_TIME_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TIME_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_TIME_LIMIT;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwTimeLimit;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_ATTRIBTYPES_ONLY
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
        pADsSearchPref->vValue.dwType  = ADSTYPE_BOOLEAN;
        pADsSearchPref->vValue.Boolean = pPrefs->_fAttrsOnly;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_SEARCH_SCOPE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SEARCH_SCOPE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        switch(pPrefs->_dwSearchScope) {
        case LDAP_SCOPE_SUBTREE:
            pADsSearchPref->vValue.Integer = ADS_SCOPE_SUBTREE;
            break;

        case LDAP_SCOPE_ONELEVEL:
            pADsSearchPref->vValue.Integer = ADS_SCOPE_ONELEVEL;
            break;
        
        case LDAP_SCOPE_BASE:
            pADsSearchPref->vValue.Integer = ADS_SCOPE_BASE;
            break;
        }

        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_TIMEOUT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TIMEOUT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_TIMEOUT;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_timeout.tv_sec;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_PAGESIZE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_PAGESIZE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwPageSize;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_PAGED_TIME_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_PAGED_TIME_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_PAGED_TIME_LIMIT;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        pADsSearchPref->vValue.Integer = pPrefs->_dwPagedTimeLimit;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_CHASE_REFERRALS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_CHASE_REFERRALS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
        pADsSearchPref->vValue.dwType  = ADSTYPE_INTEGER;
        switch(pPrefs->_dwChaseReferrals) {
        case (DWORD) (DWORD_PTR)LDAP_OPT_OFF:
            pADsSearchPref->vValue.Integer = ADS_CHASE_REFERRALS_NEVER;
            break;

        case LDAP_CHASE_SUBORDINATE_REFERRALS:
            pADsSearchPref->vValue.Integer = ADS_CHASE_REFERRALS_SUBORDINATE;
            break;
        
        case LDAP_CHASE_EXTERNAL_REFERRALS:
            pADsSearchPref->vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
            break;

        case (DWORD) (DWORD_PTR) LDAP_OPT_ON:
            pADsSearchPref->vValue.Integer = ADS_CHASE_REFERRALS_ALWAYS;
            break;

        }

        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_CACHE_RESULTS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_CACHE_RESULTS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
        pADsSearchPref->vValue.dwType  = ADSTYPE_BOOLEAN;
        pADsSearchPref->vValue.Boolean = pPrefs->_fCacheResults;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_TOMBSTONE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TOMBSTONE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_TOMBSTONE;
        pADsSearchPref->vValue.dwType  = ADSTYPE_BOOLEAN;
        pADsSearchPref->vValue.Boolean = pPrefs->_fTombStone;
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_DIRSYNC
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_DIRSYNC,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_DIRSYNC;
        pADsSearchPref->vValue.dwType  = ADSTYPE_PROV_SPECIFIC;
        pADsSearchPref->vValue.ProviderSpecific.dwLength = 0;
        pADsSearchPref->vValue.ProviderSpecific.lpValue = NULL;

        if (pPrefs->_pProvSpecific && pPrefs->_pProvSpecific->lpValue) {
            memcpy(pbExtraBytes, pPrefs->_pProvSpecific->lpValue, pPrefs->_pProvSpecific->dwLength);

            pADsSearchPref->vValue.ProviderSpecific.lpValue  = pbExtraBytes;
            pADsSearchPref->vValue.ProviderSpecific.dwLength = pPrefs->_pProvSpecific->dwLength;
            
            pbExtraBytes += pPrefs->_pProvSpecific->dwLength;
        }
        
        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_VLV
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_VLV,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_VLV;
        pADsSearchPref->vValue.dwType  = ADSTYPE_PROV_SPECIFIC;
        pADsSearchPref->vValue.ProviderSpecific.dwLength = sizeof(ADS_VLV);
        pADsSearchPref->vValue.ProviderSpecific.lpValue = pbExtraBytes;

        PADS_VLV pADsVLV = (PADS_VLV) pbExtraBytes;
        pbExtraBytes += sizeof(ADS_VLV);

        pADsVLV->dwBeforeCount  = pPrefs->_pVLVInfo->ldvlv_before_count;
        pADsVLV->dwAfterCount   = pPrefs->_pVLVInfo->ldvlv_after_count;
        pADsVLV->dwOffset       = pPrefs->_pVLVInfo->ldvlv_offset;
        pADsVLV->dwContentCount = pPrefs->_pVLVInfo->ldvlv_count;
        pADsVLV->pszTarget  = NULL;
        pADsVLV->lpContextID = NULL;
        pADsVLV->dwContextIDLength = 0;

        if (pPrefs->_pVLVInfo->ldvlv_attrvalue && pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_val) {
            // As stored, the attribute is a non-terminated UTF-8 string.
            // We need to return a NULL-terminated Unicode string.
            // We do this by constructing a NULL-terminated UTF-8 string, and then
            // converting that to a Unicode string.

            pUTF8 = (PCHAR) AllocADsMem(pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_len + 1);
            if (!pUTF8)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            memcpy(pUTF8,
                   pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_val,
                   pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_len);

            pUTF8[pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_len] = '\0';
                   
            hr = UTF8ToUnicodeString(pUTF8, &pUnicode);
            BAIL_ON_FAILURE(hr);
            
            memcpy(pbExtraBytes,
                   pUnicode,
                   (wcslen(pUnicode)+1) * sizeof(WCHAR));

            pADsVLV->pszTarget = (LPWSTR) pbExtraBytes;
            pbExtraBytes += (wcslen(pUnicode)+1) * sizeof(WCHAR);
        }

        if (pPrefs->_pVLVInfo->ldvlv_context && pPrefs->_pVLVInfo->ldvlv_context->bv_val) {
            memcpy(pbExtraBytes,
                   pPrefs->_pVLVInfo->ldvlv_context->bv_val,
                   pPrefs->_pVLVInfo->ldvlv_context->bv_len);

            pADsVLV->lpContextID = pbExtraBytes;
            pADsVLV->dwContextIDLength = pPrefs->_pVLVInfo->ldvlv_context->bv_len;
            pbExtraBytes += pPrefs->_pVLVInfo->ldvlv_context->bv_len;
        }

        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_SORT_ON
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SORT_ON,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_SORT_ON;
        pADsSearchPref->vValue.dwType  = ADSTYPE_PROV_SPECIFIC;
        pADsSearchPref->vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY) * pPrefs->_nSortKeys;
        pADsSearchPref->vValue.ProviderSpecific.lpValue  = pbExtraBytes;

        PADS_SORTKEY pSortKeys = (PADS_SORTKEY) pbExtraBytes;
        pbExtraBytes += (sizeof(ADS_SORTKEY) * pPrefs->_nSortKeys);

        DWORD i;
        for (i=0; i < pPrefs->_nSortKeys; i++) {
            pSortKeys[i].fReverseorder = pPrefs->_pSortKeys[i].sk_reverseorder;
            pSortKeys[i].pszReserved   = pPrefs->_pSortKeys[i].sk_matchruleoid;
            pSortKeys[i].pszAttrType   = (LPWSTR) pbExtraBytes;
            memcpy(pbExtraBytes,
                   pPrefs->_pSortKeys[i].sk_attrtype,
                   (wcslen(pPrefs->_pSortKeys[i].sk_attrtype)+1) * sizeof(WCHAR)
                   );
            pbExtraBytes += (wcslen(pPrefs->_pSortKeys[i].sk_attrtype)+1) * sizeof(WCHAR);
        }

        pADsSearchPref++;
    }

    // ADS_SEARCHPREF_ATTRIBUTE_QUERY
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ATTRIBUTE_QUERY,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        pADsSearchPref->dwSearchPref = ADS_SEARCHPREF_ATTRIBUTE_QUERY;
        pADsSearchPref->vValue.dwType  = ADSTYPE_CASE_IGNORE_STRING;
        pADsSearchPref->vValue.CaseIgnoreString = pbExtraBytes;
        
        // copy SourceAttribute
        DWORD dwLen = (wcslen(pPrefs->_pAttribScoped) + 1) * sizeof(WCHAR);
        
        memcpy(pbExtraBytes,
               pPrefs->_pAttribScoped,
               dwLen);
        pbExtraBytes += dwLen ;

        pADsSearchPref++;
    }
    
    
error:

    if (pUTF8)
        FreeADsMem(pUTF8);

    if (pUnicode)
        FreeADsMem(pUnicode);
        

    RRETURN(hr);
}


HRESULT
CalcSpaceForSearchPrefs(
    PLDAP_SEARCH_PREF pPrefs,
    PDWORD            pdwNumberPrefs,
    PDWORD            pdwNumberExtraBytes
    )
{
    if (!pPrefs || !pdwNumberPrefs || !pdwNumberExtraBytes)
        RRETURN(E_INVALIDARG);

    *pdwNumberPrefs = 0;
    *pdwNumberExtraBytes = 0;

    //
    // Calculate the number of ADS_SEARCHPREF_INFOs required
    // for search prefs that do _not_ require extra space.
    // (Currently, only _SORT_ON, _DIRSYNC, _VLV, _ATTRIBUTE_QUERY
    // require extra space).
    //
    // A ADS_SEARCHPREF_INFO is "required" if the corresponding
    // search pref is not set to its default value, as determined
    // by IsSearchPrefSetToDefault.
    //
    
    BOOL fDefault;
    HRESULT hr = S_OK;

    // ADS_SEARCHPREF_ASYNCHRONOUS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ASYNCHRONOUS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;
    
    // ADS_SEARCHPREF_DEREF_ALIASES
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_DEREF_ALIASES,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_SIZE_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SIZE_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_TIME_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TIME_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_ATTRIBTYPES_ONLY
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_SEARCH_SCOPE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SEARCH_SCOPE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_TIMEOUT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TIMEOUT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;
        
    // ADS_SEARCHPREF_PAGESIZE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_PAGESIZE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;
        
    // ADS_SEARCHPREF_PAGED_TIME_LIMIT
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_PAGED_TIME_LIMIT,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;
        
    // ADS_SEARCHPREF_CHASE_REFERRALS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_CHASE_REFERRALS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_CACHE_RESULTS
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_CACHE_RESULTS,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;

    // ADS_SEARCHPREF_TOMBSTONE
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_TOMBSTONE,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault)
        (*pdwNumberPrefs)++;


    //
    // _VLV, _DIRSYNC, _ATTRIBUTE_QUERY, and _SORT_ON require extra space in addition
    // to the ADS_SEARCHPREF_INFO structure.
    //

    // ADS_SEARCHPREF_DIRSYNC
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_DIRSYNC,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        (*pdwNumberPrefs)++;

        if (pPrefs->_pProvSpecific && pPrefs->_pProvSpecific->dwLength > 0) {
            *pdwNumberExtraBytes += pPrefs->_pProvSpecific->dwLength;
        }
    }

    // ADS_SEARCHPREF_VLV
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_VLV,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        (*pdwNumberPrefs)++;

        *pdwNumberExtraBytes += sizeof(ADS_VLV);

        if (pPrefs->_pVLVInfo->ldvlv_context) {
            *pdwNumberExtraBytes += pPrefs->_pVLVInfo->ldvlv_context->bv_len;
        }

        if (pPrefs->_pVLVInfo->ldvlv_attrvalue) {
            // As stored, the string is a UTF-8 string that is not NULL-terminated.
            // We need to calculate the size of a NULL-terminated Unicode string.

            int cch = MultiByteToWideChar(CP_UTF8,
                                          0,
                                          pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_val,
                                          pPrefs->_pVLVInfo->ldvlv_attrvalue->bv_len,
                                          NULL,
                                          0);
            if (!cch)
                BAIL_ON_FAILURE(hr = E_FAIL);
            
            // add one WCHAR for NULL terminator
            *pdwNumberExtraBytes += ((cch*sizeof(WCHAR)) + sizeof(WCHAR));
        }
    }

    // ADS_SEARCHPREF_SORT_ON
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_SORT_ON,
                                                  pPrefs,
                                                  &fDefault));
    if (!fDefault) {
        (*pdwNumberPrefs)++;

        *pdwNumberExtraBytes += (sizeof(ADS_SORTKEY) * pPrefs->_nSortKeys);

        DWORD i;
        for (i=0; i<pPrefs->_nSortKeys; i++) {
            *pdwNumberExtraBytes += ((wcslen(pPrefs->_pSortKeys[i].sk_attrtype)+1) * sizeof(WCHAR));
        }
    }

    // ADS_SEARCHPREF_ATTRIBUTE_QUERY
    BAIL_ON_FAILURE(hr = IsSearchPrefSetToDefault(ADS_SEARCHPREF_ATTRIBUTE_QUERY,
                                                  pPrefs,
                                                  &fDefault));

    if (!fDefault) {
        (*pdwNumberPrefs)++;

        *pdwNumberExtraBytes += ((wcslen(pPrefs->_pAttribScoped) + 1) * sizeof(WCHAR));

    }



error:
    RRETURN(hr);

}


//
// This function tests whether a given search pref is set
// to it's default value.
//
// Important: This function considers the "default value"
// to be the value currently set in CLDAPGenObject::InitSearchPrefs.
// If you ever change those defaults, update this function.
//
HRESULT
IsSearchPrefSetToDefault(
    ADS_SEARCHPREF_ENUM pref,
    PLDAP_SEARCH_PREF   pPrefs,
    PBOOL               pfDefault
    )
{

    if (!pPrefs || !pfDefault)
        RRETURN(E_INVALIDARG);

    *pfDefault = TRUE;

    switch(pref) {

    case ADS_SEARCHPREF_ASYNCHRONOUS:
        // default: not async
        if (pPrefs->_fAsynchronous)
            *pfDefault = FALSE;
        break;
    
    case ADS_SEARCHPREF_DEREF_ALIASES:
        // default: do not deref
        if (pPrefs->_dwDerefAliases)
            *pfDefault = FALSE;
        break;
    
    case ADS_SEARCHPREF_SIZE_LIMIT:
        // default: no size limit
        if (pPrefs->_dwSizeLimit)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_TIME_LIMIT:
        // default: no time limit
        if (pPrefs->_dwTimeLimit)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
        // default: not attribtypes only
        if (pPrefs->_fAttrsOnly)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_SEARCH_SCOPE:
        // default: LDAP_SCOPE_SUBTREE
        if (pPrefs->_dwSearchScope != LDAP_SCOPE_SUBTREE)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_TIMEOUT:
        // default: no timeout
        if  (pPrefs->_timeout.tv_sec || pPrefs->_timeout.tv_usec)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_PAGESIZE:
        // default: no pagesize
        if (pPrefs->_dwPageSize)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_PAGED_TIME_LIMIT:
        // default: no paged time limit
        if (pPrefs->_dwPagedTimeLimit)
            *pfDefault = FALSE;
       break;

    case ADS_SEARCHPREF_CHASE_REFERRALS:
        // default: ADS_CHASE_REFERRALS_EXTERNAL
        if (pPrefs->_dwChaseReferrals != ADS_CHASE_REFERRALS_EXTERNAL)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_SORT_ON:
        // default: no sorting
        if (pPrefs->_pSortKeys)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_CACHE_RESULTS:
        // default: cache results
        if (!pPrefs->_fCacheResults)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_DIRSYNC:
        // default: not a dirsync search
        if (pPrefs->_fDirSync)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_TOMBSTONE:
        // default: don't include tombstones
        if (pPrefs->_fTombStone)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_VLV:
        // default: not a VLV search
        if (pPrefs->_pVLVInfo)
            *pfDefault = FALSE;
        break;

    case ADS_SEARCHPREF_ATTRIBUTE_QUERY:
        // default: not an attribute-scoped query search
        if (pPrefs->_pAttribScoped)
            *pfDefault = FALSE;
        break;

    default:
        RRETURN(E_INVALIDARG);
    }

    RRETURN(S_OK);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\ccomp.cxx ===
Remove this file. No one us using it.

//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  oleds.odl
//
//  Contents:  Top level odl file for the ADs project
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aCompPropMapping[] =
{ // { TEXT("Description"), TEXT("description") },
  // { TEXT("Owner"), TEXT("owner") },
  { TEXT("Role"), TEXT("machineRole") },
  { TEXT("NetAddresses"), TEXT("networkAddress") }
};

//  Class CLDAPComputer

DEFINE_IDispatch_Implementation(CLDAPComputer)
DEFINE_CONTAINED_IADs_Implementation(CLDAPComputer)
DEFINE_CONTAINED_IADsContainer_Implementation(CLDAPComputer)


CLDAPComputer::CLDAPComputer()
    : _pADs(NULL),
      _pADsContainer(NULL),
      _pDispMgr(NULL)
      // _DomainName(NULL)
{
    ENLIST_TRACKING(CLDAPDomain);
}

HRESULT
CLDAPComputer::CreateComputer(
    IADs  *pADs,
    REFIID   riid,
    void   **ppvObj
    )
{
    CLDAPComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateComputerObject(
             pADs,
             &pComputer
             );
    BAIL_ON_FAILURE(hr);

    hr = pComputer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pComputer->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pComputer;
    RRETURN(hr);
}

#if 0
HRESULT
CLDAPComputer::CreateComputer(
    BSTR Parent,
    BSTR DomainName,
    BSTR ComputerName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateComputerObject(
                        &pComputer
                        );
    BAIL_ON_FAILURE(hr);


    hr = pComputer->InitializeCoreObject(
                Parent,
                ComputerName,
                COMPUTER_CLASS_NAME,
                COMPUTER_SCHEMA_NAME,
                CLSID_WinNTComputer,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &pComputer->_DomainName);
    BAIL_ON_FAILURE(hr);


    hr = pComputer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);


    pComputer->Release();

    RRETURN(hr);

error:

    delete pComputer;
    RRETURN(hr);
}
#endif


CLDAPComputer::~CLDAPComputer( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    delete _pDispMgr;
}

STDMETHODIMP
CLDAPComputer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputer))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputerOperations))
    {
        *ppv = (IADsComputerOperations FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer )
    {
       *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList )
    {
       *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CLDAPComputer::AllocateComputerObject(
    IADs *pADs,
    CLDAPComputer ** ppComputer
    )
{
    CLDAPComputer FAR * pComputer = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDispatch *pDispatch = NULL;

    pComputer = new CLDAPComputer();
    if (pComputer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsComputer,
                (IADsComputer *)pComputer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsComputerOperations,
                (IADsComputerOperations *)pComputer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pComputer,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pComputer,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(IID_IDispatch, (void **)&pDispatch);
    BAIL_ON_FAILURE(hr);
    pDispMgr->RegisterBaseDispatchPtr(pDispatch);

    pComputer->_pADs = pADs;
    pADs->AddRef();

    hr = pADs->QueryInterface(
                IID_IADsContainer,
                (void **) &pADsContainer );
    BAIL_ON_FAILURE(hr);

    pComputer->_pADsContainer = pADsContainer;

    pComputer->_pDispMgr = pDispMgr;
    *ppComputer = pComputer;

    RRETURN(hr);

error:

    if ( pADsContainer )
        pADsContainer->Release();

    delete pDispMgr;
    delete pComputer;

    RRETURN(hr);

}


/* IADs methods */

STDMETHODIMP
CLDAPComputer::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    LPTSTR pszPropName = bstrName;

    for ( DWORD i = 0; i < ARRAY_SIZE(aCompPropMapping); i++ )
    {
        if ( _tcsicmp(bstrName, aCompPropMapping[i].pszADsProp ) == 0 )
        {
            pszPropName = aCompPropMapping[i].pszLDAPProp;
            break;
        }
    }

    RRETURN(_pADs->Get( pszPropName, pvProp));
}

STDMETHODIMP
CLDAPComputer::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    LPTSTR pszPropName = bstrName;

    for ( DWORD i = 0; i < ARRAY_SIZE(aCompPropMapping); i++ )
    {
        if ( _tcsicmp(bstrName, aCompPropMapping[i].pszADsProp) == 0 )
        {
            pszPropName = aCompPropMapping[i].pszLDAPProp;
            break;
        }
    }

    RRETURN(_pADs->Put( pszPropName, vProp));
}

#if 0
STDMETHODIMP
CLDAPComputer::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    WCHAR szHostServerName[MAX_PATH];

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = WinNTGetCachedPDCName(
                        _DomainName,
                        szHostServerName
                        );
        BAIL_ON_FAILURE(hr);

        hr = WinNTCreateComputer(
                    (szHostServerName + 2),
                    _Name
                    );
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        RRETURN(E_NOTIMPL);
    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CLDAPComputer::GetInfo(THIS)
{
    RRETURN(GetInfo(4, TRUE));
}
#endif

/* IADsContainer methods */

#if 0
STDMETHODIMP
CLDAPComputer::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CLDAPComputerEnum::Create(
                (CLDAPComputerEnum **)&penum,
                _ADsPath,
                _DomainName,
                _Name,
                _vFilter
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPComputer::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IUnknown * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&ObjectType
                       );
    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo
                         );
    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(ObjectType,
                        pObjectInfo
                        );

    if(SUCCEEDED(hr)){
        hr = HRESULT_FROM_WIN32(NERR_ResourceExists);
        BAIL_ON_FAILURE(hr);
    }

    switch (ObjectType) {

    case WINNT_USER_ID:

        hr = CLDAPNTUser::CreateUser(_ADsPath,
                                    WINNT_COMPUTER_ID,
                                    NULL,
                                    _Name,
                                    RelativeName,
                                    ADS_OBJECT_UNBOUND,
                                    IID_IUnknown,
                                    (void **)ppObject
                                    );
        BAIL_ON_FAILURE(hr);

        break;


      case WINNT_PRINTER_ID:
        hr = CLDAPNTPrintQueue::CreatePrintQueue(_ADsPath,
                                      WINNT_COMPUTER_ID,
                                      pObjectInfo->ComponentArray[0],
                                      pObjectInfo->ComponentArray[1],
                                      RelativeName,
                                      ADS_OBJECT_UNBOUND,
                                      IID_IUnknown,
                                      (void**)ppObject
                                      );
        BAIL_ON_FAILURE(hr);
        break;


      case WINNT_GROUP_ID:
        hr = CLDAPNTGroup::CreateGroup(
                            _ADsPath,
                            WINNT_COMPUTER_ID,
                            NULL,
                            _Name,
                            RelativeName,
                            WINNT_GROUP_LOCAL,
                            ADS_OBJECT_UNBOUND,
                            IID_IUnknown,
                            (void **)ppObject
                            );

        BAIL_ON_FAILURE(hr);
        break;


      case WINNT_SERVICE_ID:
        hr = CLDAPNTService::Create(_ADsPath,
                                   pObjectInfo->ComponentArray[0],
                                   pObjectInfo->ComponentArray[1],
                                   RelativeName,
                                   ADS_OBJECT_UNBOUND,
                                   IID_IUnknown,
                                   (void**)ppObject
                                   );

        BAIL_ON_FAILURE(hr);
        break;


      default:
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

  error:
    FreeObjectInfo(pObjectInfo);
    RRETURN(hr);
}

STDMETHODIMP
CLDAPComputer::Delete(
    BSTR bstrClassName,
    BSTR bstrSourceName
    )
{
    ULONG ObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;
    WCHAR szUncServerName[MAX_PATH];

    hr = GetObjectType(gpFilters,
                      gdwMaxFilters,
                      bstrClassName,
                      (PDWORD)&ObjectType );

    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(
                _ADsPath,
                bstrSourceName,
                &pObjectInfo
                );

    BAIL_ON_FAILURE(hr);

    switch (ObjectType) {

    case WINNT_USER_ID:

      hr = WinNTDeleteUser(pObjectInfo);
      BAIL_ON_FAILURE(hr);
      break;

    case WINNT_GROUP_ID:

       hr = WinNTDeleteGroup(pObjectInfo);
       BAIL_ON_FAILURE(hr);
       break;

      case WINNT_PRINTER_ID:

        hr = WinNTDeletePrinter(pObjectInfo);
        BAIL_ON_FAILURE(hr);
        break;

      case WINNT_SERVICE_ID:

        hr = WinNTDeleteService(pObjectInfo);
        BAIL_ON_FAILURE(hr);
        break;

      default:
        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN(hr);
}
#endif

#if 0
WCHAR *szCurrentVersion = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
WCHAR *szHardwareInfo =  L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0";

STDMETHODIMP
CLDAPComputer::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{

    COMP_INFO_4 CompInfo4;
    PCOMP_INFO_4 pCompInfo4 = &CompInfo4;
    DWORD dwRet = 0;
    HKEY hKey = NULL;
    HKEY hCurrentKey = NULL;
    HKEY hHardwareKey = NULL;
    DWORD cbData = 0;
    HRESULT hr = S_OK;
    WCHAR lpszServerName[MAX_PATH];

    memset(pCompInfo4, 0, sizeof(COMP_INFO_4));
    switch (dwApiLevel) {
    case 4:

        hr = MakeUncName(_Name, lpszServerName);
        BAIL_ON_FAILURE(hr);

        dwRet = RegConnectRegistry(
                        lpszServerName,
                        HKEY_LOCAL_MACHINE,
                        &hKey
                        );
        if (dwRet !=ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        dwRet =  RegOpenKeyEx(
                        hKey,
                        szCurrentVersion,
                        0,
                        KEY_READ,
                        &hCurrentKey
                        );

        if (dwRet != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pCompInfo4->szOS, L"Windows NT");

        cbData = sizeof(pCompInfo4->szOSVersion);
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"CurrentVersion",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szOSVersion,
                    &cbData
                    );


        cbData = sizeof(pCompInfo4->szOwner);
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"RegisteredOwner",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szOwner,
                    &cbData
                    );


        cbData = sizeof(pCompInfo4->szDivision),
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"RegisteredOrganization",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szDivision,
                    &cbData
                    );

        cbData = sizeof(pCompInfo4->szProcessorCount),
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"CurrentType",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szProcessorCount,
                    &cbData
                    );

        dwRet =  RegOpenKeyEx(
                        hKey,
                        szHardwareInfo,
                        0,
                        KEY_READ,
                        &hHardwareKey
                        );
        if (dwRet != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        cbData = sizeof(pCompInfo4->szProcessor),
        dwRet = RegQueryValueEx(
                    hHardwareKey,
                    L"Identifier",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szProcessor,
                    &cbData
                    );


        hr = UnMarshall_Level4(fExplicit, pCompInfo4);

error:
        if (hCurrentKey) {
            RegCloseKey(hCurrentKey);
        }

        if (hHardwareKey) {
            RegCloseKey(hHardwareKey);
        }

        if (hKey) {
            RegCloseKey(hKey);
        }




        RRETURN(hr);

    default:
        RRETURN(E_FAIL);
    }


}

HRESULT
CLDAPComputer::UnMarshall_Level4(
    BOOL fExplicit,
    LPCOMP_INFO_4 pCompInfo4
    )
{
    HRESULT hr = S_OK;

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystem"),
                pCompInfo4->szOS,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystemVersion"),
                pCompInfo4->szOSVersion,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Owner"),
                pCompInfo4->szOwner,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Division"),
                pCompInfo4->szDivision,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("ProcessorCount"),
                pCompInfo4->szProcessorCount,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Processor"),
                pCompInfo4->szProcessor,
                fExplicit
                );


    RRETURN(S_OK);
}
#endif

/* IADsComputerOperations methods */

STDMETHODIMP
CLDAPComputer::Status(
    IDispatch * FAR * ppObject
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPComputer::Shutdown(
    VARIANT_BOOL bReboot
    )
{
    RRETURN(E_NOTIMPL);
}

/* IADsComputer methods */

STDMETHODIMP CLDAPComputer::get_ComputerID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, ComputerID);
}

STDMETHODIMP CLDAPComputer::get_Site(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Site);
}

STDMETHODIMP CLDAPComputer::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Description);
}

STDMETHODIMP CLDAPComputer::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Description);
}

STDMETHODIMP CLDAPComputer::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Location);
}

STDMETHODIMP CLDAPComputer::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Location);
}

STDMETHODIMP CLDAPComputer::get_PrimaryUser(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, PrimaryUser);
}

STDMETHODIMP CLDAPComputer::put_PrimaryUser(THIS_ BSTR bstrPrimaryUser)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, PrimaryUser);
}

STDMETHODIMP CLDAPComputer::get_Owner(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Owner);
}

STDMETHODIMP CLDAPComputer::put_Owner(THIS_ BSTR bstrOwner)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Owner);
}

STDMETHODIMP CLDAPComputer::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Division);
}

STDMETHODIMP CLDAPComputer::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Division);
}

STDMETHODIMP CLDAPComputer::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Department);
}

STDMETHODIMP CLDAPComputer::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Department);
}

STDMETHODIMP CLDAPComputer::get_Role(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Role);
}

STDMETHODIMP CLDAPComputer::put_Role(THIS_ BSTR bstrRole)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Role);
}

STDMETHODIMP CLDAPComputer::get_OperatingSystem(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CLDAPComputer::put_OperatingSystem(THIS_ BSTR bstrOperatingSystem)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CLDAPComputer::get_OperatingSystemVersion(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CLDAPComputer::put_OperatingSystemVersion(THIS_ BSTR bstrOperatingSystemVersion)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CLDAPComputer::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Model);
}

STDMETHODIMP CLDAPComputer::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Model);
}

STDMETHODIMP CLDAPComputer::get_Processor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Processor);
}

STDMETHODIMP CLDAPComputer::put_Processor(THIS_ BSTR bstrProcessor)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Processor);
}

STDMETHODIMP CLDAPComputer::get_ProcessorCount(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, ProcessorCount);
}

STDMETHODIMP CLDAPComputer::put_ProcessorCount(THIS_ BSTR bstrProcessorCount)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, ProcessorCount);
}

STDMETHODIMP CLDAPComputer::get_MemorySize(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, MemorySize);
}

STDMETHODIMP CLDAPComputer::put_MemorySize(THIS_ BSTR bstrMemorySize)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, MemorySize);
}

STDMETHODIMP CLDAPComputer::get_StorageCapacity(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, StorageCapacity);
}

STDMETHODIMP CLDAPComputer::put_StorageCapacity(THIS_ BSTR bstrStorageCapacity)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, StorageCapacity);
}

STDMETHODIMP CLDAPComputer::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsComputer *)this, NetAddresses);
}

STDMETHODIMP CLDAPComputer::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    PUT_PROPERTY_VARIANT((IADsComputer *)this, NetAddresses);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cdomain.cxx ===
krishna says this file should be removed


//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cdomain.cxx
//
//  Contents:  Windows NT 3.5
//
//
//  History:   09-23-96     yihsins   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

DECLARE_INFOLEVEL( Domain );
DECLARE_DEBUG( Domain );
#define DomainDebugOut(x) DomainInlineDebugOut x

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aDomainPropMapping[] =
{ { TEXT("MinPasswordLength"), TEXT("minPwdLength") },
  { TEXT("MinPasswordAge"), TEXT("minPwdAge") },
  { TEXT("MaxPasswordAge"), TEXT("maxPwdAge") },
  { TEXT("MaxBadPasswordsAllowed"), TEXT("lockoutThreshold") },
  { TEXT("PasswordHistoryLength"), TEXT("pwdHistoryLength") },
  { TEXT("PasswordAttributes"), TEXT("pwdProperties") },
  { TEXT("AutoUnlockInterval"), TEXT("lockoutDuration") },
  { TEXT("LockoutObservationInterval"), TEXT("lockOutObservationWindow") },
  // { TEXT("IsWorkgroup"), TEXT("IsWorkgroup") },  // ???
};

//
//  Class CLDAPDomain
//

DEFINE_IDispatch_Implementation(CLDAPDomain)
DEFINE_CONTAINED_IADs_Implementation(CLDAPDomain)
DEFINE_CONTAINED_IADsContainer_Implementation(CLDAPDomain)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CLDAPDomain)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CLDAPDomain)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CLDAPDomain)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPDomain, aDomainPropMapping)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CLDAPDomain)


CLDAPDomain::CLDAPDomain()
    : _pADs(NULL),
      _pADsContainer(NULL),
      _pDSObject(NULL),
      _pDSSearch(NULL),
      _pDispMgr(NULL),
      _pDSSchMgmt(NULL),
      _pADsPropList(NULL)
{
    ENLIST_TRACKING(CLDAPDomain);
}

HRESULT
CLDAPDomain::CreateDomain(
    IADs  *pADs,
    REFIID   riid,
    void   **ppvObj
    )
{
    CLDAPDomain FAR * pDomain = NULL;
    HRESULT hr = S_OK;

    hr = AllocateDomainObject( pADs, &pDomain);
    BAIL_ON_FAILURE(hr);

    hr = pDomain->QueryInterface( riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pDomain->Release();

    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pDomain;
    RRETURN(hr);
}

CLDAPDomain::~CLDAPDomain( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if ( _pDSObject )
        _pDSObject->Release();

    if ( _pDSSearch )
        _pDSSearch->Release();

    if ( _pDSSchMgmt )
        _pDSSchMgmt->Release();


    if (_pADsPropList) {

        _pADsPropList->Release();
    }

    delete _pDispMgr;

}

STDMETHODIMP
CLDAPDomain::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsDomain FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDomain))
    {
        *ppv = (IADsDomain FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer )
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject) && _pDSObject )
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch) && _pDSSearch )
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt) && _pDSSchMgmt )
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList )
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CLDAPDomain::AllocateDomainObject(
    IADs *pADs,
    CLDAPDomain **ppDomain
    )
{
    CLDAPDomain FAR * pDomain = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject FAR * pDSObject = NULL;
    IDirectorySearch FAR * pDSSearch= NULL;
    IDirectorySchemaMgmt FAR * pDSSchMgmt= NULL;
    IADsPropertyList FAR * pADsPropList = NULL;
    IDispatch *pDispatch = NULL;

    pDomain = new CLDAPDomain();
    if (pDomain == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsDomain,
                (IADsDomain *)pDomain,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pDomain,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pADsPropList,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(IID_IDispatch, (void **)&pDispatch);
    BAIL_ON_FAILURE(hr);
    pDispMgr->RegisterBaseDispatchPtr(pDispatch);

    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pDomain->_pADsContainer = pADsContainer;

    //
    // Store a pointer to the DSObject interface
    //

    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pDomain->_pDSObject = pDSObject;

    //
    // Store a pointer to the DSSearch interface
    //

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pDomain->_pDSSearch= pDSSearch;


    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pDomain->_pADsPropList = pADsPropList;


    //
    // Store a pointer to the DSSchMgmt interface
    //

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pDomain->_pDSSchMgmt= pDSSchMgmt;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pDomain->_pADs = pADs;
    pADs->AddRef();

    pDomain->_pDispMgr = pDispMgr;
    *ppDomain = pDomain;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pDomain;

    RRETURN(hr);
}


/* IADsContainer methods */

#if 0
STDMETHODIMP
CLDAPDomain::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CLDAPDomainEnum::Create(
                (CLDAPDomainEnum **)&penum,
                _ADsPath,
                _Name,
                _vFilter
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPDomain::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IUnknown * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(
                gpFilters,
                gdwMaxFilters,
                ClassName,
                (PDWORD)&ObjectType
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(
            _ADsPath,
            RelativeName,
            &pObjectInfo
            );
    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(
            ObjectType,
            pObjectInfo
            );

    if (SUCCEEDED(hr)) {
        hr = HRESULT_FROM_WIN32(NERR_ResourceExists);
        BAIL_ON_FAILURE(hr);
    }

    switch (ObjectType) {

    case WINNT_USER_ID:

        hr = CWinNTUser::CreateUser(
                            _ADsPath,
                            WINNT_DOMAIN_ID,
                            _Name,
                            NULL,
                            RelativeName,
                            ADS_OBJECT_UNBOUND,
                            IID_IUnknown,
                            (void **)ppObject
                            );
        BAIL_ON_FAILURE(hr);

        break;


    case WINNT_GROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            _ADsPath,
                            WINNT_DOMAIN_ID,
                            _Name,
                            NULL,
                            RelativeName,
                            WINNT_GROUP_GLOBAL,
                            ADS_OBJECT_UNBOUND,
                            IID_IUnknown,
                            (void **)ppObject
                            );
        BAIL_ON_FAILURE(hr);

        break;


    case WINNT_COMPUTER_ID:
        hr = E_NOTIMPL;
        /*hr = CWinNTComputer::CreateComputer(
                            _ADsPath,
                            _Name,
                            RelativeName,
                            ADS_OBJECT_UNBOUND,
                            IID_IUnknown,
                            (void **)ppObject
                            );*/
        BAIL_ON_FAILURE(hr);

        break;



    default:
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CLDAPDomain::Delete(
    BSTR bstrClassName,
    BSTR bstrSourceName
    )
{
    ULONG ObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;
    WCHAR szUncServerName[MAX_PATH];

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       bstrClassName,
                       (PDWORD)&ObjectType
                       );

    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(
                         _ADsPath,
                         bstrSourceName,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);

    switch (ObjectType) {

    case WINNT_USER_ID:

      hr = WinNTDeleteUser(pObjectInfo);
      BAIL_ON_FAILURE(hr);
      break;

    case WINNT_GROUP_ID:

       hr = WinNTDeleteGroup(pObjectInfo);
       BAIL_ON_FAILURE(hr);
       break;


    case WINNT_COMPUTER_ID:

       hr = WinNTDeleteComputer(pObjectInfo);
       BAIL_ON_FAILURE(hr);
       break;


    default:
        hr = E_ADS_UNKNOWN_OBJECT;
        BAIL_ON_FAILURE(hr);
    }

    RRETURN(hr);

error:
    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN(hr);
}
#endif

/* IADsDomain methods */

STDMETHODIMP
CLDAPDomain::get_IsWorkgroup(THIS_ VARIANT_BOOL FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPDomain::get_MinPasswordLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MinPasswordLength);
}

STDMETHODIMP
CLDAPDomain::put_MinPasswordLength(THIS_ long lMinPasswordLength)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MinPasswordLength);
}

STDMETHODIMP
CLDAPDomain::get_MinPasswordAge(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MinPasswordAge);
}

STDMETHODIMP CLDAPDomain::put_MinPasswordAge(THIS_ long lMinPasswordAge)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MinPasswordAge);
}

STDMETHODIMP CLDAPDomain::get_MaxPasswordAge(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MaxPasswordAge);
}

STDMETHODIMP CLDAPDomain::put_MaxPasswordAge(THIS_ long lMaxPasswordAge)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MaxPasswordAge);
}

STDMETHODIMP CLDAPDomain::get_MaxBadPasswordsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MaxBadPasswordsAllowed);

}
STDMETHODIMP CLDAPDomain::put_MaxBadPasswordsAllowed(THIS_ long lMaxBadPasswordsAllowed)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MaxBadPasswordsAllowed);

}
STDMETHODIMP CLDAPDomain::get_PasswordHistoryLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, PasswordHistoryLength);

}

STDMETHODIMP CLDAPDomain::put_PasswordHistoryLength(THIS_ long lPasswordHistoryLength)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, PasswordHistoryLength);

}

STDMETHODIMP CLDAPDomain::get_PasswordAttributes(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, PasswordAttributes);
}

STDMETHODIMP CLDAPDomain::put_PasswordAttributes(THIS_ long lPasswordAttributes)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, PasswordAttributes);
}

STDMETHODIMP CLDAPDomain::get_AutoUnlockInterval(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, AutoUnlockInterval);
}

STDMETHODIMP CLDAPDomain::put_AutoUnlockInterval(THIS_ long lAutoUnlockInterval)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, AutoUnlockInterval);
}

STDMETHODIMP CLDAPDomain::get_LockoutObservationInterval(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, LockoutObservationInterval);
}

STDMETHODIMP CLDAPDomain::put_LockoutObservationInterval(THIS_ long lLockoutObservationInterval)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, LockoutObservationInterval);
}

#if 0

STDMETHODIMP
CLDAPDomain::SetInfo(THIS)
{
    HRESULT hr;

    hr = SetInfo(0);

    hr = SetInfo(2);

    hr = SetInfo(3);

    RRETURN(hr);
}

STDMETHODIMP
CLDAPDomain::GetInfo(THIS)
{
    HRESULT hr;

    hr = GetInfo(0, TRUE);

    hr = GetInfo(2, TRUE);

    hr = GetInfo(3, TRUE);

    RRETURN(hr);
}

STDMETHODIMP
CLDAPDomain::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szPDCName[MAX_PATH];

    hr = WinNTGetCachedPDCName(
                _Name,
                szPDCName
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserModalsGet(
                    szPDCName,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall(lpBuffer, dwApiLevel, fExplicit);
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN(hr);
}


HRESULT
CLDAPDomain::UnMarshall(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 0:
        RRETURN(UnMarshall_Level0(fExplicit, (LPUSER_MODALS_INFO_0)lpBuffer));
        break;

    case 2:
        RRETURN(UnMarshall_Level2(fExplicit, (LPUSER_MODALS_INFO_2)lpBuffer));
        break;


    case 3:
        RRETURN(UnMarshall_Level3(fExplicit, (LPUSER_MODALS_INFO_3)lpBuffer));
        break;

    default:
        RRETURN(E_FAIL);

    }
}



HRESULT
CLDAPDomain::UnMarshall_Level0(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_0 pUserInfo0
    )
{

    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordLength"),
                pUserInfo0->usrmod0_min_passwd_len,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxPasswordAge"),
                pUserInfo0->usrmod0_max_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordAge"),
                pUserInfo0->usrmod0_min_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordHistoryLength"),
                pUserInfo0->usrmod0_password_hist_len,
                fExplicit
                );

    RRETURN(S_OK);
}



HRESULT
CLDAPDomain::UnMarshall_Level2(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_2 pUserInfo2
    )
{
    RRETURN(S_OK);
}


HRESULT
CLDAPDomain::UnMarshall_Level3(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_3 pUserInfo3
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("AutoUnlockInterval"),
                pUserInfo3->usrmod3_lockout_duration,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("LockoutObservationInterval"),
                pUserInfo3->usrmod3_lockout_observation_window,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxBadPasswordsAllowed"),
                pUserInfo3->usrmod3_lockout_threshold,
                fExplicit
                );

    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPDomain::SetInfo(THIS_ DWORD dwApiLevel)
{
    NET_API_STATUS nasStatus;
    HRESULT hr;
    LPBYTE lpBuffer = NULL;
    DWORD dwParamErr = 0;
    WCHAR szPDCName[MAX_PATH];


    hr = WinNTGetCachedPDCName(
                    _Name,
                    szPDCName
                    );
    BAIL_ON_FAILURE(hr);


    nasStatus = NetUserModalsGet(
                    szPDCName,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);



     hr = MarshallAndSet(szPDCName, lpBuffer, dwApiLevel);
     BAIL_ON_FAILURE(hr);

error:

     if (lpBuffer) {
         NetApiBufferFree(lpBuffer);
     }

     RRETURN(hr);
}


HRESULT
CLDAPDomain::MarshallAndSet(
    LPWSTR szServerName,
    LPBYTE lpBuffer,
    DWORD  dwApiLevel
    )
{
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 0:
        RRETURN(Marshall_Set_Level0(
                    szServerName,
                    (LPUSER_MODALS_INFO_0)lpBuffer
                    ));
        break;

    case 2:
        RRETURN(Marshall_Set_Level2(
                    szServerName,
                    (LPUSER_MODALS_INFO_2)lpBuffer
                    ));
        break;


    case 3:
        RRETURN(Marshall_Set_Level3(
                    szServerName,
                    (LPUSER_MODALS_INFO_3)lpBuffer
                    ));
        break;

    default:
        RRETURN(E_FAIL);

    }
}



HRESULT
CLDAPDomain::Marshall_Set_Level0(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_0 pUserInfo0)
{
    NET_API_STATUS nasStatus;
    DWORD dwParamErr = 0;
    HRESULT hr = S_OK;

    DWORD dwMinPasswdLen = 0;
    DWORD dwMaxPasswdAge = 0;
    DWORD dwMinPasswdAge = 0;
    DWORD dwPasswdHistLen = 0;

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MinPasswordLength"),
                    &dwMinPasswdLen
                    );

    if (SUCCEEDED(hr)) {

        pUserInfo0->usrmod0_min_passwd_len = dwMinPasswdLen;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxPasswordAge"),
                    &dwMaxPasswdAge
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo0->usrmod0_max_passwd_age = dwMaxPasswdAge;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MinPasswordAge"),
                    &dwMinPasswdAge
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo0->usrmod0_min_passwd_age = dwMinPasswdAge;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordHistoryLength"),
                    &dwPasswdHistLen
                    );

    if (SUCCEEDED(hr)) {

        pUserInfo0->usrmod0_password_hist_len = dwPasswdHistLen;
    }

    //
    // Now Set this Data. Remember that the property store
    // returns to us data in its own format. It is the caller's
    // responsibility to free all buffers for bstrs, variants
    // etc
    //

     nasStatus = NetUserModalsSet(
                     szServerName,
                     0,
                     (LPBYTE)pUserInfo0,
                     &dwParamErr
                     );
     hr = HRESULT_FROM_WIN32(nasStatus);
     BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
CLDAPDomain::Marshall_Set_Level2(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_2 pUserInfo2
    )
{
    RRETURN(S_OK);
}


HRESULT
CLDAPDomain::Marshall_Set_Level3(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_3 pUserInfo3
    )
{
    NET_API_STATUS nasStatus;
    HRESULT hr;
    DWORD dwParamErr =  0;

    DWORD dwAutoUnlockIntrvl = 0;
    DWORD dwLockoutObsIntrvl = 0;
    DWORD dwMaxBadPasswdsAllowed = 0;

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("AutoUnlockInterval"),
                    &dwAutoUnlockIntrvl
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_duration = dwAutoUnlockIntrvl;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LockoutObservationInterval"),
                    &dwLockoutObsIntrvl
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_observation_window  = dwLockoutObsIntrvl;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxBadPasswordsAllowed"),
                    &dwMaxBadPasswdsAllowed
                    );


    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_threshold = dwMaxBadPasswdsAllowed;
    }


    //
    // Now Set this Data. Remember that the property store
    // returns to us data in its own format. It is the caller's
    // responsibility to free all buffers for bstrs, variants
    // etc
    //

     nasStatus = NetUserModalsSet(
                     szServerName,
                     3,
                     (LPBYTE)pUserInfo3,
                     &dwParamErr
                     );
     hr = HRESULT_FROM_WIN32(nasStatus);
     BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregateeDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "ldap.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[200];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
    DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)
# define DispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(
    LONG ExtensionId,
    LONG TypeInfoId,
    LONG DispId,
    DISPID *pResult
    )
{
    if (DispId == DISPID_UNKNOWN){

        *pResult = DispId;

    }else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
                    DispId < 0 || DispId >= 0x10000){

        //
        // Might happen if some object has very large dispid's.
        // But we can't handle it if it does.
        //
        *pResult = DISPID_UNKNOWN;
    }
    else{

        *pResult = ((ExtensionId & 0xff) << 24) |((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

    }

}


static inline void
MakeDISPIDs(
    LONG ExtensionId,
    LONG TypeInfoId,
    DISPID *rgdispid,
    unsigned int cNames
    )
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(ExtensionId, TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct Def
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;

CRITICAL_SECTION g_ExtTypeInfoCritSect;

#define ENTER_EXT_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_ExtTypeInfoCritSect)
#define LEAVE_EXT_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_ExtTypeInfoCritSect)

LONG glnMSEXTObjCount = 0;
LONG glnMSEXTTypesOfInfo = 0;

PTYPEINFO_TABLE gpAggregateeTypeInfoTable = NULL;

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregateeDispMgr::CAggregateeDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _dwExtensionID = 0;
}

CAggregateeDispMgr::~CAggregateeDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnMSEXTObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_EXT_TYPEINFO_CRITSECT();

    if (glnMSEXTObjCount == glnMSEXTTypesOfInfo) {
        //
        // We need to clean up the list
        //
        AggregateeFreeTypeInfoTable();

        gpAggregateeTypeInfoTable = NULL;

        glnMSEXTObjCount = glnMSEXTTypesOfInfo = 0;

    }
    LEAVE_EXT_TYPEINFO_CRITSECT();
}

void
CAggregateeDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregateeDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {

            //
            // aggregatee no longer needs to include extension id
            // in dispid.
            //

            MakeDISPIDs(0, pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
    hr = S_OK;
    for (DWORD dw = 0; dw < cNames; dw++) {
        if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
            (PDWORD)(rgdispid + dw)))) {
        hr = DISP_E_UNKNOWNNAME;
        rgdispid[dw] = DISPID_UNKNOWN;
        }
    }
    if (SUCCEEDED(hr)) {

            //
            // aggregatee no longer needs to include extension id
            // in dispid.
            //

        MakeDISPIDs(0, _dwPropCacheID, rgdispid, cNames);
    }
    }

    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
    unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregateeDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregateeDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregateeDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

error:
    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
    unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregateeDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregateeDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregateeDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregateeDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregateeDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}


ITypeInfo *
AggregateeFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AggregateeAddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregateeLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregateeDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_EXT_TYPEINFO_CRITSECT();

    pTypeInfo = ::AggregateeFindTypeInfo(gpAggregateeTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_EXT_TYPEINFO_CRITSECT();
        hr = AggregateeLoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_EXT_TYPEINFO_CRITSECT();

        gpAggregateeTypeInfoTable = ::AggregateeAddTypeInfo(
                                          gpAggregateeTypeInfoTable,
                                          iid,
                                          pTypeInfo
                                          );

        if (!gpAggregateeTypeInfoTable) {
            LEAVE_EXT_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnMSEXTTypesOfInfo);

        InterlockedIncrement(&glnMSEXTObjCount);
    }

    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);
    if (FAILED(hr)) {
        LEAVE_EXT_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

     
    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnMSEXTObjCount);
    LEAVE_EXT_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
    hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
    hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
    pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregateeDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
AggregateeFreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpAggregateeTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }
}

HRESULT
CAggregateeDispMgr::InitializeDispMgr(
    DWORD dwExtensionID
    )
{
    if (dwExtensionID > 255) {
        return(E_FAIL);
    }
    _dwExtensionID = dwExtensionID;

    return(S_OK);
}

BOOL
AggregateeDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_EXT_TYPEINFO_CRITSECT();
    retVal = (glnMSEXTObjCount == 0);
    LEAVE_EXT_TYPEINFO_CRITSECT();

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumgrp.cxx
//
//  Contents:  LDAP GroupCollection Enumeration Code
//
//              CLDAPGroupCollectionEnum::
//              CLDAPGroupCollectionEnum::
//              CLDAPGroupCollectionEnum::
//              CLDAPGroupCollectionEnum::
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
BuildADsPathFromLDAPPath(
    LPWSTR szNamespace,
    LPWSTR szLdapDN,
    LPWSTR * ppszADsPathName
    );


//+---------------------------------------------------------------------------
//
//  Function:   LDAPEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollectionEnum::Create(
    CLDAPGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    BSTR ADsPath,
    BSTR GroupName,
    VARIANT vMembers,
    VARIANT vFilter,
    CCredentials& Credentials,
    IDirectoryObject * pIDirObj,
    BOOL fRangeRetrieval
    )
{
    HRESULT hr = NOERROR;
    CLDAPGroupCollectionEnum FAR* penumvariant = NULL;
    long lLBound = 0;
    long lUBound = 0;

    *ppenumvariant = NULL;

    penumvariant = new CLDAPGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_fRangeRetrieval = fRangeRetrieval;

    hr = ADsAllocString( Parent , &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy( &penumvariant->_vMembers, &vMembers );
    BAIL_ON_FAILURE(hr);

    if ( vMembers.vt == VT_BSTR )  // 1 member only
    {
        penumvariant->_lMembersCount = 1;
    }
    else
    {
        hr = SafeArrayGetLBound(V_ARRAY(&penumvariant->_vMembers),
                                1,
                                (long FAR *)&lLBound
                                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayGetUBound(V_ARRAY(&penumvariant->_vMembers),
                                1,
                                (long FAR *)&lUBound
                                );
        BAIL_ON_FAILURE(hr);

        penumvariant->_lMembersCount = lUBound - lLBound + 1;
   }

   hr = ObjectTypeList::CreateObjectTypeList(
                    vFilter,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    pIDirObj->QueryInterface(
                  IID_IDirectoryObject,
                  (void **) &(penumvariant->_pIDirObj)
                  );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollectionEnum::CLDAPGroupCollectionEnum()
    :   _Parent(NULL),
        _ADsPath(NULL),
        _GroupName(NULL),
        _lCurrentIndex(0),
        _lMembersCount(0),
        _pIDirObj(NULL),
        _fRangeRetrieval(FALSE),
        _fAllRetrieved(FALSE),
        _pszRangeToFetch(NULL),
        _pAttributeEntries(NULL),
        _pCurrentEntry(NULL),
        _dwCurRangeIndex(0),
        _dwCurRangeMax(0),
        _dwNumEntries(0),
        _fLastSet(FALSE)
{
    VariantInit( &_vMembers );
    _pObjList = NULL;

}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollectionEnum::CLDAPGroupCollectionEnum( ObjectTypeList ObjList )
    :   _Parent(NULL),
        _ADsPath(NULL),
        _GroupName(NULL),
        _lCurrentIndex(0),
        _lMembersCount(0)
{
    VariantInit( &_vMembers );
    _pObjList = NULL;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollectionEnum::~CLDAPGroupCollectionEnum()
{
    VariantClear( &_vMembers );
    delete _pObjList;

    if ( _Parent )
        ADsFreeString( _Parent );

    if ( _GroupName )
        ADsFreeString( _GroupName );

    if ( _ADsPath )
        ADsFreeString( _ADsPath );

    if (_pIDirObj) {
        _pIDirObj->Release();
    }

    if (_pszRangeToFetch) {
        FreeADsStr(_pszRangeToFetch);
    }

    if (_pAttributeEntries) {
        FreeADsMem(_pAttributeEntries);
    }

}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    IADs * pIADs = NULL;
    BSTR pszClass = NULL;
    DWORD dwClassID;
    BSTR pszFilterName = NULL;
    BOOL fFound = FALSE;
    BOOL fEmpty = TRUE;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (FAILED(hr)) {
            //
            // Set hr to S_FALSE as all our enumerators are not
            // built to handle a failure hr but only S_OK and S_FALSE.
            //
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }


        //
        // Apply the IADsMembers::put_Filter filter.
        // If the enumerated object is not one of the types to be returned,
        // go on to the next member of the group.
        //
        
        hr = pDispatch->QueryInterface(IID_IADs, (void **)&pIADs);
        BAIL_ON_FAILURE(hr);

        //
        // To check whether use specifies filter
        //
        fEmpty = _pObjList->IsEmpty();

        //
        // User specifies the filter
        //
        if (!fEmpty) {

            //
            // Determine the object class of the enumerated object and the corresponding
            // object class ID number (as specified in the Filters global array).
            //
            hr = pIADs->get_Class(&pszClass);
            BAIL_ON_FAILURE(hr);
            

            //
            // Enumerate through the object classes listed in the user-specified filter
            // until we either find a match (fFound = TRUE) or we reach the end of the
            // list.
            //
            hr = _pObjList->Reset();

            //
            // compare with the user defined filter
            //
            while (SUCCEEDED(hr)) {
                hr = _pObjList->GetCurrentObject(&pszFilterName);

                if (SUCCEEDED(hr)
                    && (!_wcsicmp(pszClass, pszFilterName))
                    ) {

                    fFound = TRUE;
                    
                    if(pszFilterName) {
                	    SysFreeString(pszFilterName);
                	    pszFilterName = NULL;
                    }
                    break;
                }

                if(pszFilterName) {
                	SysFreeString(pszFilterName);
                	pszFilterName = NULL;
                }

                hr = _pObjList->Next();
            }

            if (!fFound) {
                // 
                // not on the list of objects to return, try again
                // with the next member of the group
                //
                pDispatch->Release();

                pIADs->Release();
                
                if (pszClass) {
                    ADsFreeString(pszClass);
                    pszClass = NULL;
                }
                
                continue;
            }

            pIADs->Release();
        
            if (pszClass) {
                ADsFreeString(pszClass);
                pszClass = NULL;
            }

        }

        //
        // Return it.
        // 
        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;      
        
        
    }
    RRETURN_EXP_IF_ERR(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    RRETURN_EXP_IF_ERR(hr);    
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    VARIANT v;
    IUnknown *pObject = NULL;
    TCHAR *pszADsPath = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;
    BOOL fRangeUsed = FALSE;

    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);

    dwAuthFlags = _Credentials.GetAuthFlags();

    while ( TRUE )
    {
        VariantInit(&v);

        if ( _lCurrentIndex >= _lMembersCount ) {
            hr = S_FALSE;
            //
            // See if we need to fetch members using Rangeretrieval.
            //
            if (_fRangeRetrieval && !_fAllRetrieved) {
                hr = GetNextMemberRange(&v);
                BAIL_ON_FAILURE(hr);

                if (hr == S_FALSE) {
                    goto error;
                }

                fRangeUsed = TRUE;
            }
            else
                goto error;
        }

        //
        // Variant v will have correct value already if range
        // retrieval was used.
        //
        if (!fRangeUsed) {

            if ( _vMembers.vt == VT_BSTR )
            {
                hr = VariantCopy( &v, &_vMembers );
            }
            else
            {
                hr = SafeArrayGetElement( V_ARRAY(&_vMembers), &_lCurrentIndex, &v);
            }

            BAIL_ON_FAILURE(hr);

        }

        _lCurrentIndex++;

        LPTSTR pszMember = V_BSTR(&v);
        LPTSTR pszTemp = NULL;

        hr = BuildADsPathFromLDAPPath( _Parent, pszMember, &pszADsPath );
        BAIL_ON_FAILURE(hr);

        hr = ADsOpenObject(
                    pszADsPath,
                    pszUserName,
                    pszPassword,
                    dwAuthFlags,
                    IID_IUnknown,
                    (LPVOID *)&pObject
                    );


        if ( pszADsPath )
        {
            FreeADsStr( pszADsPath );
            pszADsPath = NULL;
        }

        if (pszPassword) {
            FreeADsStr(pszPassword);
            pszPassword = NULL;
        }

        if (pszUserName) {
            FreeADsStr(pszUserName);
            pszUserName = NULL;
        }

        VariantClear(&v);

        //
        // If we failed to get the current object, continue with the next one
        //
        if ( FAILED(hr))
            continue;

        hr = pObject->QueryInterface(
                          IID_IDispatch,
                          (LPVOID *) ppDispatch );
        BAIL_ON_FAILURE(hr);

        pObject->Release();

        RRETURN(S_OK);
    }

error:

    if ( pObject )
        pObject->Release();

    if ( pszADsPath )
        FreeADsStr( pszADsPath );

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    VariantClear(&v);

    *ppDispatch = NULL;

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CLDAPGroupCollectionEnum::UpdateRangeToFetch()
{
    HRESULT hr = S_OK;
    WCHAR szPath[512];

    //
    // szPath should be big enough to handle any range we
    // can reasonably expect and will be used to build the
    // member string.
    //

    if (_pszRangeToFetch == NULL) {
        //
        // Rather than ask for the first n elements again,
        // we can use the count we have in the variant array
        // to decide where we need to start.
        //

        wsprintf(szPath, L"member;range=%d-*", _lMembersCount);

        _pszRangeToFetch = AllocADsStr(szPath);
        if (!_pszRangeToFetch) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }
    else {
        //
        // In this case the call to GetObjectAttr has been made
        // and we need to get the info out of the name.
        //
        BOOL fUpdated = FALSE;
        for (DWORD i = 0; (i < _dwNumEntries) && !fUpdated; i++) {
            LPWSTR pszTemp = NULL;
            LPWSTR pszAttrName = _pAttributeEntries[i].pszAttrName;
            LPWSTR pszStar = NULL;

            if (wcslen(pszAttrName) > wcslen(L"member;range=")) {
                //
                // See if we have our string
                //
                if (!_wcsnicmp(
                         pszAttrName,
                         L"member;range=",
                         wcslen(L"member;range")
                         )
                    ) {

                    _pCurrentEntry = &(_pAttributeEntries[i]);
                    _dwCurRangeMax = _pCurrentEntry->dwNumValues;
                    _dwCurRangeIndex = 0;
                    pszTemp = wcschr(pszAttrName, L'=');

                    if (!pszTemp) {
                        //
                        // No chance of recovery from this.
                        //
                        BAIL_ON_FAILURE(hr = E_FAIL);
                    }

                    //
                    // Move the lower part of range.
                    //
                    *pszTemp++;
                    if (!*pszTemp) {
                        BAIL_ON_FAILURE(hr = E_FAIL);
                    }

                    pszStar = wcschr(pszTemp, L'*');
                    if (pszStar) {
                        //
                        // Do not bother with any udpate of the range,
                        // we have all the entries.
                        //
                        _fLastSet = TRUE;
                        goto error;
                    }

                    DWORD dwLower = 0;
                    DWORD dwHigher = 0;

                    if (!swscanf(pszTemp, L"%d-%d", &dwLower, &dwHigher)) {
                        BAIL_ON_FAILURE(hr = E_FAIL);
                    }

                    dwHigher++;
                    wsprintf(szPath, L"member;range=%d-*", dwHigher);

                    FreeADsStr(_pszRangeToFetch);
                    _pszRangeToFetch = AllocADsStr(szPath);
                    if (!_pszRangeToFetch) {
                        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                    }

                    //
                    // Set flag so we can get out of the loop.
                    //
                    fUpdated = TRUE;

                } // this was not member;

            } // is the length greater than that of member;

        } // for each entry in attribute entries.

        if (!fUpdated) {
            //
            // Failed cause there was no members or a range.
            //
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    } // _pszRangeToFetch was non NULL


error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPGroupCollectionEnum::GetNextMemberRange
//
//  Synopsis:   Returns a variant bstr with the dn of the next member in
//              the group or FALSE if there are no more. This routine will
//              will use IDirectoryObject to fetch more members if applicable.
//
//
//  Arguments:  [pVarMemberBstr] -- ptr to VARIANT for return bstr.
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//                      -- Other failure hr's.
//  Modifies:
//
//  History:    9-12-99   AjayR    Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollectionEnum::GetNextMemberRange(
    VARIANT FAR* pVarMemberBstr
    )
{
    HRESULT hr = S_FALSE;

    if (_fAllRetrieved) {
        RRETURN(S_FALSE);
    }

    //
    // Initialize the range to fetch if applicable.
    //
    if (_pszRangeToFetch == NULL) {
        hr = UpdateRangeToFetch();
        BAIL_ON_FAILURE(hr);
    }

    if (_dwCurRangeIndex == _dwCurRangeMax) {
        //
        // Call into wrapper for GetObjectAttributes.
        //
        if (_fLastSet) {
            _fAllRetrieved = TRUE;
            hr = S_FALSE;
        }
        else {
            hr = UpdateAttributeEntries();
            BAIL_ON_FAILURE(hr);
        }

        if (hr == S_FALSE) {
            goto error;
        }
    }

    //
    // At this point we should have the entries in our current
    // return set.
    //
    if (!_pCurrentEntry) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (_dwCurRangeIndex < _dwCurRangeMax) {

        hr = ADsAllocString(
                 _pCurrentEntry->pADsValues[_dwCurRangeIndex].DNString,
                 &V_BSTR(pVarMemberBstr)
                );
        BAIL_ON_FAILURE(hr);
    }

    _dwCurRangeIndex++;

error:

    RRETURN(hr);
}

HRESULT
CLDAPGroupCollectionEnum::UpdateAttributeEntries()
{
    HRESULT hr = S_OK;
    LPWSTR aStrings[2];

    ADsAssert(_pszRangeToFetch || !"Range is NULL internal error");

    if (_pAttributeEntries) {
        FreeADsMem(_pAttributeEntries);
        _pAttributeEntries = NULL;
    }

    aStrings[0] = _pszRangeToFetch;
    aStrings[1] = NULL;


    hr = _pIDirObj->GetObjectAttributes(
                        aStrings,
                        1,
                        &_pAttributeEntries,
                        &_dwNumEntries
                        );

    BAIL_ON_FAILURE(hr);

    if (_dwNumEntries == 0) {
        hr = S_FALSE;
    }
    else {
        //
        // Will return error if member was not there.
        //
        hr = UpdateRangeToFetch();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      cenumUserCollection.cxx
//
//  Contents:  Windows NT 3.5 UserCollection Enumeration Code
//
//              CLDAPUserCollectionEnum::CLDAPUserCollectionEnum()
//              CLDAPUserCollectionEnum::CLDAPUserCollectionEnum
//              CLDAPUserCollectionEnum::EnumObjects
//              CLDAPUserCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
BuildADsPathFromLDAPPath(
    LPWSTR szNamespace,
    LPWSTR szLdapDN,
    LPWSTR * ppszADsPathName
    );


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPUserCollectionEnum::Create(
    BSTR bstrUserName,
    CLDAPUserCollectionEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CLDAPUserCollectionEnum FAR* penumvariant = NULL;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;

    if ( V_VT(&var) == VT_BSTR )
    {
        dwSLBound = 0;
        dwSUBound = 0;
    }
    else
    {
        if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
            return(E_FAIL);
        }

        //
        // Check that there is only one dimension in this array
        //

        if ((V_ARRAY(&var))->cDims != 1) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // We know that this is a valid single dimension array
        //

        hr = SafeArrayGetLBound(
                 V_ARRAY(&var),
                 1,
                 (long FAR *)&dwSLBound
                 );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayGetUBound(
                 V_ARRAY(&var),
                 1,
                 (long FAR *)&dwSUBound
                 );
        BAIL_ON_FAILURE(hr);
    }

    *ppenumvariant = NULL;

    penumvariant = new CLDAPUserCollectionEnum();

    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString(bstrUserName, &(penumvariant->_bstrUserName));
    BAIL_ON_FAILURE(hr);


    hr = VariantCopy(&(penumvariant->_vMembers), &var);
    BAIL_ON_FAILURE(hr);

    penumvariant->_dwSUBound = dwSUBound;
    penumvariant->_dwSLBound = dwSLBound;
    penumvariant->_dwIndex =  dwSLBound;

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CLDAPUserCollectionEnum::CLDAPUserCollectionEnum():
    _dwSLBound(0),
    _dwSUBound(0),
    _dwIndex(0),
    _bstrUserName(NULL)
{
    VariantInit(&_vMembers);
}

CLDAPUserCollectionEnum::~CLDAPUserCollectionEnum()
{
    VariantClear(&_vMembers);

    if ( _bstrUserName )
        ADsFreeString( _bstrUserName );
}

HRESULT
CLDAPUserCollectionEnum::EnumUserMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserMemberObject(&pDispatch);
        if (FAILED(hr)) {
            //
            // Enumerators support code can only handle S_FALSE and S_OK,
            // so we cannot return other failure hr's for now.
            //
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPUserCollectionEnum::GetUserMemberObject(
    IDispatch ** ppDispatch
    )
{

    VARIANT v;
    HRESULT hr = S_OK;
    TCHAR *pszADsPathName = NULL;
    IUnknown *pObject = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;


    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);

    dwAuthFlags = _Credentials.GetAuthFlags();

    *ppDispatch = NULL;

    if (_dwIndex > _dwSUBound) {
        RRETURN(S_FALSE);
    }

    while ( TRUE )
    {
        VariantInit(&v);

        if ( _vMembers.vt == VT_BSTR )
        {
            hr = VariantCopy( &v, &_vMembers );
        }
        else
        {
            hr = SafeArrayGetElement(
                     V_ARRAY(&_vMembers),
                     (long FAR *)&_dwIndex,
                     &v
                     );
        }

        BAIL_ON_FAILURE(hr);

        _dwIndex++;

        hr = BuildADsPathFromLDAPPath( _bstrUserName,
                                     V_BSTR(&v),
                                     &pszADsPathName);
        BAIL_ON_FAILURE(hr);

        hr = ADsOpenObject(
                    pszADsPathName,
                    pszUserName,
                    pszPassword,
                    dwAuthFlags,
                    IID_IUnknown,
                    (LPVOID *)&pObject
                    );

        if ( pszADsPathName )
        {
            FreeADsStr( pszADsPathName );
            pszADsPathName = NULL;
        }

        if (pszPassword) {
            FreeADsStr(pszPassword);
            pszPassword = NULL;
        }

        if (pszUserName) {
            FreeADsStr(pszUserName);
            pszUserName = NULL;
        }


        VariantClear(&v);

        //
        // If we failed to get the current object, continue with the next one
        //
        if ( FAILED(hr))
            continue;

        hr = pObject->QueryInterface( IID_IDispatch, (LPVOID *) ppDispatch );
        BAIL_ON_FAILURE(hr);

        pObject->Release();

        RRETURN(S_OK);
    }

error:

    if ( pObject )
        pObject->Release();

    if ( pszADsPathName )
        FreeADsStr( pszADsPathName );


    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }


    VariantClear(&v);

    *ppDispatch = NULL;

    RRETURN(S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPUserCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUserCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumUserMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cdomaincf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Domain Object Class Factory Code
//
//             CLDAPDomainCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPDomainCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPDomainCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CLDAPDomain::CreateDomain(
                TEXT("ADs:"),
               TEXT("LDAP:"),
                Credentials,
                ADS_OBJECT_BOUND,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumvar.cxx
//
//  Contents:  LDAP Enumerator Code
//
//             CLDAPEnumVariant::Create
//             CLDAPEnumVariant::CLDAPEnumVariant
//             CLDAPEnumVariant::~CLDAPEnumVariant
//             CLDAPEnumVariant::QueryInterface
//             CLDAPEnumVariant::AddRef
//             CLDAPEnumVariant::Release
//             CLDAPEnumVariant::Next
//             CLDAPEnumVariant::Skip
//             CLDAPEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::CLDAPEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPEnumVariant::CLDAPEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::~CLDAPEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPEnumVariant::~CLDAPEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLDAPEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLDAPEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//             IADsGroup and IADsGroupOperation methods
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#include <winldap.h>
#include "..\ldapc\ldpcache.hxx"
#include "..\ldapc\ldaputil.hxx"
#include "..\ldapc\parse.hxx"


HRESULT
BuildLDAPPathFromADsPath2(
    LPWSTR szADsPathName,
    LPWSTR *pszLDAPServer,
    LPWSTR *pszLDAPDn,
    DWORD * pdwPort
    );


HRESULT
LdapGetSyntaxOfAttributeOnServer(
    LPTSTR  pszServerPath,
    LPTSTR  pszAttrName,
    DWORD   *pdwSyntaxId,
    CCredentials& Credentials,
    DWORD dwPort,
    BOOL fFromServer = FALSE
    );

HRESULT
ReadServerSupportsIsADControl(
    LPWSTR pszLDAPServer,
    BOOL * pfDomScopeSupported,
    CCredentials& Credentials,
    DWORD dwPort
    );

BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );

HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    );


BOOL
MapLdapClassToADsClass(
    LPTSTR *aLdapClasses,
    int nCount,
    LPTSTR pszADsClass
    );


struct _classmapping
{
    LPTSTR pszLdapClassName;
    LPTSTR pszADsClassName;
} aClassMap[] =
{
  { TEXT("user"),  USER_CLASS_NAME},  // NTDS
  { TEXT("group"),  GROUP_CLASS_NAME},
  { TEXT("localGroup"),  GROUP_CLASS_NAME},
  { TEXT("printQueue"), PRINTER_CLASS_NAME},
  { TEXT("country"), TEXT("Country") },
  { TEXT("locality"), TEXT("Locality") },
  { TEXT("organization"), TEXT("Organization")},
  { TEXT("organizationalUnit"), TEXT("Organizational Unit") },
  { TEXT("domain"), DOMAIN_CLASS_NAME},

  { TEXT("person"), USER_CLASS_NAME },
  { TEXT("organizationalPerson"), USER_CLASS_NAME },
  { TEXT("residentialPerson"), USER_CLASS_NAME },
  { TEXT("groupOfNames"), GROUP_CLASS_NAME },
  { TEXT("groupOfUniqueNames"), GROUP_CLASS_NAME }
};


//  Class CLDAPGroup


STDMETHODIMP CLDAPGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this, description);
}

STDMETHODIMP CLDAPGroup::put_Description(THIS_ BSTR bstrdescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this, description);
}


STDMETHODIMP
CLDAPGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    VARIANT v;
    HRESULT hr = S_OK;
    BSTR bstrParent = NULL;
    BSTR bstrName = NULL;
    BSTR bstrADsPath = NULL;
    IADsObjOptPrivate *pPrivOpt = NULL;
    BOOL fRangeRetrieval = FALSE;

    VariantInit(&v);
    hr = get_VARIANT_Property((IADs *) ((IADsGroup *) this),
                              TEXT("member"),
                              &v );

    if ( hr == E_ADS_PROPERTY_NOT_FOUND )
    {
        SAFEARRAY *aList = NULL;
        SAFEARRAYBOUND aBound;

        hr = S_OK;

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        V_VT(&v) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&v) = aList;
    }
    BAIL_ON_FAILURE(hr);

    hr = get_Parent( &bstrParent );
    BAIL_ON_FAILURE(hr);

    hr = get_Name( &bstrName );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath( &bstrADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // We need to see if range retrieval was used.
    // That info is needed in the enumerator.
    //
    hr = _pADs->QueryInterface(
             IID_IADsObjOptPrivate,
             (void **)&pPrivOpt
             );
    BAIL_ON_FAILURE(hr);

    //
    // Not a problem if this fails.
    //
    hr = pPrivOpt->GetOption (
             LDAP_MEMBER_HAS_RANGE,
             (void *) &fRangeRetrieval
             );

    hr = CLDAPGroupCollection::CreateGroupCollection(
             bstrParent,
             bstrADsPath,
             bstrName,
             &v,
             _Credentials,
             _pADs,
             IID_IADsMembers,
             fRangeRetrieval,
             (void **)ppMembers
             );
    BAIL_ON_FAILURE(hr);

error:

    if ( bstrParent )
        ADsFreeString( bstrParent );

    if ( bstrName )
        ADsFreeString( bstrName );

    if (bstrADsPath) {
        ADsFreeString( bstrADsPath);
    }

    if (pPrivOpt) {
        pPrivOpt->Release();
    }
    VariantClear(&v);

    RRETURN(hr);
}

STDMETHODIMP
CLDAPGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR *bMember
    )
{
    HRESULT hr = S_OK;

    if (_dwServerType == SERVER_TYPE_UNKNOWN) {
        hr = UpdateServerType();
        //
        // The only reason the above call shoudl fail is
        // if we could not read the ADsPath of the cgenobj.
        //
        BAIL_ON_FAILURE(hr);
    }

    if (_dwServerType == SERVER_TYPE_AD)  {
        hr = IsMemberOnAD(
                 bstrMember,
                 bMember
                 );
    }
    else {
        hr = IsMemberOnOther(
                 bstrMember,
                 bMember
                 );
    }

error:

    RRETURN(hr);
}


//
// Checks membership if the server is AD. This is because
// we know that AD supports the LDAPCompare operation. There
// is just one round trip on the wire this time.
//
HRESULT
CLDAPGroup::IsMemberOnAD(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR *bMember
    )
{
    HRESULT hr = S_OK;
    PADSLDP pLdp = NULL;
    BSTR bstrParentADsPath = NULL;
    IADsObjOptPrivate *pADsPrivateObjectOptions = NULL;

    LPWSTR pszGroupServer = NULL, pszGroupDn = NULL;
    LPWSTR pszMemberServer = NULL, pszMemberDn = NULL;
    DWORD dwGroupPort = 0, dwMemberPort = 0;

    if (!bstrMember || !*bstrMember || !bMember) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // Default to this value.
    //
    *bMember = VARIANT_FALSE;

    //
    // We need the ADsPath of the parent group object.
    // Since the input parameter is an ADsPath, we need to
    // make sure that the serverName if any matches before
    // going onto doing the LDAPCompare operation on the
    // DN to verify if the DN is part of member.
    //
    hr = _pADs->get_ADsPath(&bstrParentADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Split the path into components we are interesteed in.
    //
    hr = BuildLDAPPathFromADsPath2(
             bstrParentADsPath,
             &pszGroupServer,
             &pszGroupDn,
             &dwGroupPort
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             bstrMember,
             &pszMemberServer,
             &pszMemberDn,
             &dwMemberPort
             );

    BAIL_ON_FAILURE(hr);

    if ((pszMemberServer && !pszGroupServer)
        || (pszGroupServer && !pszMemberServer)
        || (dwMemberPort != dwGroupPort)
        || ( (pszMemberServer && pszGroupServer)
#ifdef WIN95
             && (_wcsicmp(pszMemberServer, pszGroupServer))
#else
             && (CompareStringW(
                     LOCALE_SYSTEM_DEFAULT,
                     NORM_IGNORECASE,
                     pszMemberServer,
                     -1,
                     pszGroupServer,
                     -1
                     )  != CSTR_EQUAL)
#endif
             )
        ) {

        //
        // Mismatched paths (e.g., bound to group with a serverless
        // path, user is passing in a server path)
        //
        *bMember = VARIANT_FALSE;
        hr = E_ADS_BAD_PARAMETER;
        goto error;
    }

    //
    // At this point we have a match on the server names and port.
    //
    hr = _pADs->QueryInterface(
                    IID_IADsObjOptPrivate,
                    (void **)&pADsPrivateObjectOptions
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADsPrivateObjectOptions->GetOption (
             LDP_CACHE_ENTRY,
             &pLdp
             );
    BAIL_ON_FAILURE(hr);

    //
    // We can now do a LDAPCompare to see if the object is a member.
    //
    hr = LdapCompareExt(
             pLdp,
             pszGroupDn,
             L"member",
             pszMemberDn,
             NULL, // Data
             NULL, // ClientControls
             NULL  // ServerControls
             );

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_COMPARE_FALSE)) {
        hr = S_OK;
        *bMember = VARIANT_FALSE;
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_DS_COMPARE_TRUE)) {
        hr = S_OK;
        *bMember = VARIANT_TRUE;
    } else if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)) {
        //
        // This is also valid as the member attribute might be empty.
        //
        hr = S_OK;
        *bMember = VARIANT_FALSE;
    }

    BAIL_ON_FAILURE(hr);



error:

    //
    // Cleanup all strings that could have been alloced.
    //
    if (bstrParentADsPath) {
        ADsFreeString(bstrParentADsPath);
    }

    if (pszGroupServer) {
        FreeADsStr(pszGroupServer);
    }

    if (pszGroupDn) {
        FreeADsStr(pszGroupDn);
    }

    if (pszMemberServer) {
        FreeADsStr(pszMemberServer);
    }

    if (pszMemberDn) {
        FreeADsStr(pszMemberDn);
    }

    //
    // Miscellaneous cleanup.
    //
    if (pADsPrivateObjectOptions) {
        pADsPrivateObjectOptions->Release();
    }

    RRETURN(hr);
}



//
// This routine is used if the server is not AD - preserves
// older behaviour. It creates an Enumerator, goes through that
// comparing the paths to see if there is a match. This is
// pretty network intensive.
//
HRESULT
CLDAPGroup::IsMemberOnOther(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        IADs *pObject ;

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );

        if (fMember) {
            fContinue = FALSE;
        }

        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE : VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN(hr);
}


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

#ifdef WIN95
        if (!_wcsicmp(bstrName, bstrMember)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                bstrName,
                -1,
                bstrMember,
                -1
                ) == CSTR_EQUAL
            ) {
#endif
            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}


STDMETHODIMP
CLDAPGroup::Add(THIS_ BSTR bstrNewItem)
{
    RRETURN( ModifyGroup(bstrNewItem, TRUE ));
}


STDMETHODIMP
CLDAPGroup::Remove(THIS_ BSTR bstrItemToBeRemoved)
{
    RRETURN( ModifyGroup(bstrItemToBeRemoved, FALSE ));
}

HRESULT
CLDAPGroup::ModifyGroup( THIS_ BSTR bstrItem, BOOL fAdd )
{

    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;

    TCHAR *pszLDAPServer = NULL;
    TCHAR *pszItemLDAPServer = NULL;

    TCHAR *pszLDAPDn = NULL;
    TCHAR *pszItemLDAPDn = NULL;

    BSTR  bstrADsPath = NULL;
    DWORD dwSyntaxId;
    ADS_LDP * ld = NULL;

    LDAPModW *aMod[2];
    LDAPModW ldapmod;
    WCHAR *aStrings[2];

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;    
    DWORD dwPort = 0;
    

    if (!bstrItem || !*bstrItem) {
        RRETURN(E_FAIL);
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    pObjectInfo->ObjectType = TOKEN_LDAPOBJECT;
    hr = ADsObject(bstrItem, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
             bstrItem,
             &pszItemLDAPServer,
             &pszItemLDAPDn,
             &dwPort
             );
    BAIL_ON_FAILURE(hr);

    hr = get_ADsPath( &bstrADsPath );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
                bstrADsPath,
                &pszLDAPServer,
                &pszLDAPDn,
                &dwPort
                );
    BAIL_ON_FAILURE(hr);    


    hr = LdapGetSyntaxOfAttributeOnServer(
             pszLDAPServer,
             TEXT("member"),
             &dwSyntaxId,
             _Credentials,
             pObjectInfo->PortNumber
             );

    BAIL_ON_FAILURE(hr);


    hr = LdapOpenObject(
                pszLDAPServer,
                pszLDAPDn,
                &ld,
                _Credentials,
                dwPort
                );
    BAIL_ON_FAILURE(hr);

    aMod[0] = &ldapmod;
    aMod[1] = NULL;
    aStrings[0] = pszItemLDAPDn;
    aStrings[1] = NULL;

    ldapmod.mod_type = L"member";
    ldapmod.mod_values = aStrings;
    ldapmod.mod_op = fAdd? LDAP_MOD_ADD : LDAP_MOD_DELETE;

    dwStatus = LdapModifyS(
                   ld,
                   pszLDAPDn,
                   aMod
                   );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

error:

    FreeObjectInfo( &ObjectInfo );

    if (pszItemLDAPServer)
        FreeADsStr( pszItemLDAPServer );

    if (pszItemLDAPDn) {
        FreeADsStr(pszItemLDAPDn);
    }

    if (pszLDAPDn) {
        FreeADsStr(pszLDAPDn);
    }

    if (pszLDAPServer)
        FreeADsStr( pszLDAPServer );

    if (bstrADsPath)
        ADsFreeString( bstrADsPath );

    if (ld) {
        LdapCloseObject(ld);
    }


    RRETURN(hr);
}

HRESULT
CLDAPGroup::UpdateServerType()
{
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    LPWSTR pszGroupServer = NULL;
    LPWSTR pszGroupDn = NULL;
    BOOL fServerIsAD = FALSE;
    DWORD dwGroupPort = 0;

    //
    // Read the servertype only if we have not already done so.
    //
    if (_dwServerType == SERVER_TYPE_UNKNOWN) {

        hr = _pADs->get_ADsPath( &bstrADsPath);
        BAIL_ON_FAILURE(hr);

        hr = BuildLDAPPathFromADsPath2(
                 bstrADsPath,
                 &pszGroupServer,
                 &pszGroupDn,
                 &dwGroupPort
                 );
        BAIL_ON_FAILURE(hr);

        hr = ReadServerSupportsIsADControl(
                 pszGroupServer,
                 &fServerIsAD,
                 _Credentials,
                 dwGroupPort
                 );

        //
        // Treat failure to mean server is not AD
        //
        if (FAILED(hr)) {
            fServerIsAD = FALSE;
            hr = S_OK;
        }

        if (fServerIsAD) {
            _dwServerType = SERVER_TYPE_AD;
        }
        else {
            _dwServerType = SERVER_TYPE_NOT_AD;
        }
    }

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszGroupServer) {
        FreeADsStr(pszGroupServer);
    }

    if (pszGroupDn) {
        FreeADsStr(pszGroupDn);
    }

    RRETURN(hr);

}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (_tcscmp(pObjectInfo->ProviderName, L"LDAP") == 0) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}



BOOL
MapLdapClassToADsClass(
    LPTSTR *aLdapClasses,
    int nCount,
    LPTSTR pszADsClass
)
{
    *pszADsClass = 0;

    if ( nCount == 0 )
        return FALSE;

    if ( _tcsicmp( aLdapClasses[nCount-1], TEXT("Top")) == 0 )
    {
        for ( int j = 0; j < nCount; j++ )
        {
            LPTSTR pszLdapClass = aLdapClasses[j];

            for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
            {
                if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
                {
                    _tcscpy( pszADsClass, aClassMap[i].pszADsClassName );
                    return TRUE;
                }
            }
        }

        _tcscpy( pszADsClass, aLdapClasses[0] );
        return FALSE;

    }
    else
    {
        for ( int j = nCount-1; j >= 0; j-- )
        {
            LPTSTR pszLdapClass = aLdapClasses[j];

            for ( int i = 0; i < ARRAY_SIZE(aClassMap); i++ )
            {
                if ( _tcsicmp( pszLdapClass, aClassMap[i].pszLdapClassName ) == 0 )
                {
                    _tcscpy( pszADsClass, aClassMap[i].pszADsClassName );
                    return TRUE;
                }
            }
        }

        _tcscpy( pszADsClass, aLdapClasses[nCount-1] );
        return FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cgroupcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Group Object Class Factory Code
//
//             CLDAPGroupCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPGroupCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPGroup::CreateGroup(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

//  Class CLDAPGroup

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aGroupPropMapping[] =
{
  { TEXT("Description"), TEXT("description") },
};


// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPGroup)

DEFINE_IPrivateDispatch_Implementation(CLDAPGroup)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPGroup)
DEFINE_CONTAINED_IADs_Implementation(CLDAPGroup)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPGroup, aGroupPropMapping)

CLDAPGroup::CLDAPGroup():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL),
        _dwServerType(SERVER_TYPE_UNKNOWN)
{
    ENLIST_TRACKING(CLDAPGroup);
}

HRESULT
CLDAPGroup::CreateGroup(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    CLDAPGroup FAR * pGroup = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pGroup = new CLDAPGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Ref Count = 1 from object tracker
    //

    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pGroup->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsGroup,
                (IADsGroup *)pGroup,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pGroup->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pGroup->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pGroup;


    RRETURN(hr);


error:

    if (pGroup)
        delete  pGroup;

    *ppvObj = NULL;

    RRETURN(hr);

}


CLDAPGroup::~CLDAPGroup( )
{

    //
    // Remember that the aggregatee has no reference counts to
    // decrement.
    //

    delete _pDispMgr;
}


STDMETHODIMP
CLDAPGroup::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{

    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}



STDMETHODIMP
CLDAPGroup::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IADsGroup.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}

STDMETHODIMP
CLDAPGroup::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPGroup::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPGroup::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPGroup::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPGroup::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\clocalcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Locality Object Class Factory Code
//
//             CLDAPLocalityCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPLocalityCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPLocalityCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPLocality::CreateLocality(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cgroups.cxx
//
//  Contents:  Group object
//
//  History:   July-18-1996     yihsins    Migrated.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//
//  Class CLDAPGroupCollection
//

DEFINE_IDispatch_Implementation(CLDAPGroupCollection)

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollection::CLDAPGroupCollection():
        _Parent(NULL),
        _ADsPath(NULL),
        _GroupName(NULL),
        _pDispMgr(NULL),
        _pIDirObj(NULL),
        _fRangeRetrieval(FALSE)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CLDAPGroupCollection);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollection::CreateGroupCollection(
    BSTR Parent,
    BSTR ADsPath,
    BSTR GroupName,
    VARIANT *pvMembers,
    CCredentials& Credentials,
    IADs *pIADs,
    REFIID riid,
    BOOL fRangeRetrieval,
    void **ppvObj
    )
{
    CLDAPGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(
             Credentials,
             &pGroup
             );
    BAIL_ON_FAILURE(hr);

    pGroup->_fRangeRetrieval = fRangeRetrieval;

    hr = ADsAllocString( Parent , &pGroup->_Parent);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(GroupName, &pGroup->_GroupName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ADsPath, &pGroup->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy( &(pGroup->_vMembers), pvMembers );
    BAIL_ON_FAILURE(hr);

    hr = pIADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&(pGroup->_pIDirObj)
                    );
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:

    if (pGroup->_pIDirObj) {
        pGroup->_pIDirObj->Release();
        pGroup->_pIDirObj = NULL;
    }

    *ppvObj = NULL;
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CLDAPGroupCollection::~CLDAPGroupCollection( )
{
    VariantClear( &_vMembers );
    VariantClear( &_vFilter );

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_GroupName) {
        ADsFreeString(_GroupName);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_pIDirObj) {
        _pIDirObj->Release();
    }
    delete _pDispMgr;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
    RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )                       
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::get_Count(
    long FAR* retval
    )
{
    HRESULT hr = S_OK;
    long lLBound = 0;
    long lUBound = 0;
    long lCount = 0;
    unsigned long ulFetch = 0;
    IEnumVARIANT *pEnum = NULL;
    IUnknown *pUnk = NULL;
    VARIANT vVar;

    //
    // If we used range retrieval we need to actually enumerate
    // all the entries before we can get the correct count.
    //
    if (!_fRangeRetrieval) {
        if (V_VT(&_vMembers) == VT_BSTR) {

            *retval = 1;

        }else if (V_VT(&_vMembers) == (VT_ARRAY|VT_VARIANT)){

            hr = SafeArrayGetLBound(V_ARRAY(&_vMembers),
                                    1,
                                    (long FAR *)&lLBound
                                    );
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayGetUBound(V_ARRAY(&_vMembers),
                                    1,
                                    (long FAR *)&lUBound
                                    );
            BAIL_ON_FAILURE(hr);

            *retval = lUBound - lLBound + 1;

        }else {

            hr = E_INVALIDARG;
            BAIL_ON_FAILURE(hr);

        }
    } 
    else {
        //
        // Need to go through all the results.
        //
        VariantInit(&vVar);

        hr = get__NewEnum(&pUnk);
        BAIL_ON_FAILURE(hr);

        hr = pUnk->QueryInterface(IID_IEnumVARIANT, (void **) &pEnum);
        BAIL_ON_FAILURE(hr);

        while(hr == S_OK) {
            hr = pEnum->Next(1, &vVar, &ulFetch);
            VariantClear(&vVar);
            BAIL_ON_FAILURE(hr);

            lCount += ulFetch;
        }

        *retval = lCount;

    }

error:

    if (pEnum) {
        pEnum->Release();
    }

    if (pUnk) {
        pUnk->Release();
    }
    if (hr == S_FALSE) {
        hr = S_OK;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    *retval = NULL;

    hr = CLDAPGroupCollectionEnum::Create(
             (CLDAPGroupCollectionEnum **)&penum,
             _Parent,
             _ADsPath,
             _GroupName,
             _vMembers,
             _vFilter,
             _Credentials,
             _pIDirObj,
             _fRangeRetrieval
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGroupCollection::AllocateGroupCollectionObject(
    CCredentials& Credentials,
    CLDAPGroupCollection ** ppGroup
    )
{
    CLDAPGroupCollection FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pGroup = new CLDAPGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsMembers,
             (IADsMembers *)pGroup,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pGroup->_Credentials = Credentials;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    if (pGroup) {
        delete pGroup;
    }

    if (pDispMgr) {
        delete  pDispMgr;
    }

    RRETURN_EXP_IF_ERR(hr);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cmacro.h ===
#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}




#define DEFINE_CONTAINED_IADsPutGet_Implementation(cls, ClassPropMapping)    \
STDMETHODIMP                                                                 \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Get( pszPropName, pvProp));                               \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                                 \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Put( pszPropName, vProp));                                \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                         \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->GetEx( pszPropName, pvProp));                             \
}                                                                            \
STDMETHODIMP                                                                 \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszLDAPProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->PutEx( lnControlCode, pszPropName, vProp));               \
}



#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectoryObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_INFO *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_INFO pAttributeEntries,                                 \
    DWORD dwNumAttributes,                                            \
    IDispatch * FAR* ppObject                                         \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        ppObject                                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectorySearch_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetSearchPreference(                                             \
    PADS_SEARCHPREF_INFO pSearchPrefs,                                \
    DWORD   dwNumPrefs                                                \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->SetSearchPreference(                             \
                         pSearchPrefs,                                \
                         dwNumPrefs                                   \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ExecuteSearch(                                                   \
    LPWSTR pszSearchFilter,                                           \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_SEARCH_HANDLE phSearchResult                                 \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->ExecuteSearch(                                   \
                         pszSearchFilter,                             \
                         pAttributeNames,                             \
                         dwNumberAttributes,                          \
                         phSearchResult                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::AbandonSearch(                                                   \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->AbandonSearch(                                   \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetFirstRow(                                                     \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetFirstRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextRow(                                                      \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPreviousRow(                                                  \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetPreviousRow(                                  \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextColumnName(                                               \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR * ppszColumnName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextColumnName(                               \
                         hSearchResult,                               \
                         ppszColumnName                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetColumn(                                                       \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR szColumnName,                                              \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetColumn(                                       \
                         hSearchResult,                               \
                         szColumnName,                                \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::FreeColumn(                                                      \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->FreeColumn(                                      \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CloseSearchHandle(                                               \
    ADS_SEARCH_HANDLE hSearchResult                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->CloseSearchHandle(                               \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(cls)              \
STDMETHODIMP                                                          \
cls::EnumAttributes(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumAttributes,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumAttributes                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->EnumAttributes(                                \
              ppszAttrNames,                                          \
              dwNumAttributes,                                        \
              ppAttrDefinition,                                       \
              pdwNumAttributes                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateAttributeDefinition(                                       \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF pAttributeDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->CreateAttributeDefinition(                     \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteAttributeDefinition(                                        \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF  pAttributeDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->WriteAttributeDefinition(                      \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteAttributeDefinition(                                       \
    LPWSTR pszAttributeName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->DeleteAttributeDefinition(                     \
              pszAttributeName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::EnumClasss(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumClasss,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumClasss                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->EnumClasss(                                \
              ppszAttrNames,                                          \
              dwNumClasss,                                        \
              ppAttrDefinition,                                       \
              pdwNumClasss                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateClassDefinition(                                       \
    LPWSTR pszClassName,                                          \
    PADS_ATTR_DEF pClassDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->CreateClassDefinition(                     \
              pszClassName,                                       \
              pClassDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteClassDefinition(                                        \
    LPWSTR pszClassName,                                          \
    PADS_ATTR_DEF  pClassDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->WriteClassDefinition(                      \
              pszClassName,                                       \
              pClassDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteClassDefinition(                                       \
    LPWSTR pszClassName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchMgmt->DeleteClassDefinition(                     \
              pszClassName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsObjectOptions_Implementation(cls)        \
STDMETHODIMP                                                          \
cls::GetOption(                                                       \
     THIS_ DWORD dwOption,                                            \
     void *pValue )                                                   \
{                                                                     \
    RRETURN(_pADsObjectOptions->GetOption(dwOption, pValue));         \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetOption(                                                       \
     THIS_ DWORD dwOption,                                            \
     void *pValue )                                                   \
{                                                                     \
    RRETURN(_pADsObjectOptions->SetOption(dwOption, pValue));          \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\corg.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cOrganization.cxx
//
//  Contents:  Organization object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aOrgPropMapping[] =
{ // { TEXT("Description"), TEXT("description") }, // does not exist in NTDS???
  { TEXT("LocalityName"), TEXT("l") },
  // { TEXT("PostalAddress"), TEXT("postalAddress") },
  // { TEXT("TelephoneNumber"), TEXT("telephoneNumber") },
  { TEXT("FaxNumber"), TEXT("facsimileTelephoneNumber") }
  // { TEXT("SeeAlso"), TEXT("seeAlso") }
};

//  Class CLDAPOrganization


// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPOrganization)

DEFINE_IPrivateDispatch_Implementation(CLDAPOrganization)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPOrganization)
DEFINE_CONTAINED_IADs_Implementation(CLDAPOrganization)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPOrganization, aOrgPropMapping)

CLDAPOrganization::CLDAPOrganization():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPOrganization);
}




HRESULT
CLDAPOrganization::CreateOrganization(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    CLDAPOrganization FAR * pOrganization = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pOrganization = new CLDAPOrganization();
    if (pOrganization == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Ref Count = 1 from object tracker
    //


    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pOrganization->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsO,
                (IADsO *)pOrganization,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pOrganization->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pOrganization->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pOrganization;


    RRETURN(hr);


error:

    if (pOrganization)
        delete  pOrganization;

    *ppvObj = NULL;

    RRETURN(hr);

}


CLDAPOrganization::~CLDAPOrganization( )
{
    //
    // You should never have to AddRef pointers
    // except for the real pointers that are
    // issued out.
    //


    delete _pDispMgr;
}

STDMETHODIMP
CLDAPOrganization::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{

    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}


STDMETHODIMP
CLDAPOrganization::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsO))
    {
        *ppv = (IADsO FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) { 

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();


    return S_OK;
}


STDMETHODIMP
CLDAPOrganization::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP CLDAPOrganization::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,Description);
}

STDMETHODIMP CLDAPOrganization::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsO *)this,Description);
}

STDMETHODIMP CLDAPOrganization::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,LocalityName);
}

STDMETHODIMP CLDAPOrganization::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsO *)this,LocalityName);
}

STDMETHODIMP CLDAPOrganization::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}

STDMETHODIMP CLDAPOrganization::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}

STDMETHODIMP CLDAPOrganization::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}

STDMETHODIMP CLDAPOrganization::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}

STDMETHODIMP CLDAPOrganization::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}

STDMETHODIMP CLDAPOrganization::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}

STDMETHODIMP CLDAPOrganization::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

STDMETHODIMP CLDAPOrganization::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

STDMETHODIMP
CLDAPOrganization::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPOrganization::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}

//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPOrganization::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPOrganization::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\common.cxx ===
#include "ldap.hxx"
#pragma hdrstop


FILTERS Filters[] = { { USER_CLASS_NAME, LDAP_USER_ID},
                      { GROUP_CLASS_NAME, LDAP_GROUP_ID},
                      { PRINTER_CLASS_NAME, LDAP_PRINTER_ID},
                      { DOMAIN_CLASS_NAME, LDAP_DOMAIN_ID},
                      { COMPUTER_CLASS_NAME, LDAP_COMPUTER_ID},
                      { SERVICE_CLASS_NAME, LDAP_SERVICE_ID},
                      { FILESERVICE_CLASS_NAME, LDAP_FILESERVICE_ID},
                      { FILESHARE_CLASS_NAME, LDAP_FILESHARE_ID},
                      { CLASS_CLASS_NAME, LDAP_CLASS_ID},
                      { SYNTAX_CLASS_NAME, LDAP_SYNTAX_ID},
                      { PROPERTY_CLASS_NAME, LDAP_PROPERTY_ID},
                      { TEXT("Locality"), LDAP_LOCALITY_ID },
                      { TEXT("Organization"), LDAP_O_ID},
                      { TEXT("Organizational Unit"), LDAP_OU_ID},
                      { TEXT("organizationalUnit"), LDAP_OU_ID},
                      { TEXT("Country"), LDAP_COUNTRY_ID},
                      { TEXT("localGroup"), LDAP_GROUP_ID},
                      { TEXT("groupOfNames"), LDAP_GROUP_ID},
                      { TEXT("groupOfUniqueNames"), LDAP_GROUP_ID},
                      { TEXT("person"), LDAP_USER_ID},
                      { TEXT("organizationalPerson"), LDAP_USER_ID},
                      { TEXT("residentialPerson"), LDAP_USER_ID},
                      { TEXT("inetOrgPerson"), LDAP_USER_ID}

                    };

#define MAX_FILTERS (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;

HRESULT
MakeUncName(
    LPTSTR szSrcBuffer,
    LPTSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    _tcscpy(szTargBuffer, TEXT("\\\\"));
    _tcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\clocalty.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cLocality.cxx
//
//  Contents:  Locality object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop


struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aLocalityPropMapping[] =
{ // { TEXT("Description"), TEXT("description") },
  { TEXT("LocalityName"), TEXT("l") },
  { TEXT("PostalAddress"), TEXT("street") } // NTDS
  // { TEXT("SeeAlso"), TEXT("seeAlso") }
};


//  Class CLDAPLocality



// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPLocality)

DEFINE_IPrivateDispatch_Implementation(CLDAPLocality)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPLocality)
DEFINE_CONTAINED_IADs_Implementation(CLDAPLocality)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPLocality, aLocalityPropMapping)

CLDAPLocality::CLDAPLocality():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPLocality);
}



HRESULT
CLDAPLocality::CreateLocality(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{

    HRESULT hr = S_OK;
    CLDAPLocality FAR * pLocality = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pLocality = new CLDAPLocality();
    if (pLocality == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Ref Count = 1 from object tracker
    //

    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pLocality->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsLocality,
                (IADsLocality *)pLocality,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //

    pLocality->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pLocality->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pLocality;


    RRETURN(hr);


error:

    if (pLocality)
        delete  pLocality;

    *ppvObj = NULL;

    RRETURN(hr);

}


CLDAPLocality::~CLDAPLocality( )
{
    //
    // Remember that the aggregatee has no reference counts to
    // decrement.
    //

    delete _pDispMgr;
}

STDMETHODIMP
CLDAPLocality::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{

    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}


STDMETHODIMP
CLDAPLocality::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsLocality)) {
        *ppv = (IADsLocality FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) { 

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}


STDMETHODIMP
CLDAPLocality::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CLDAPLocality::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP CLDAPLocality::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,Description);
}

STDMETHODIMP CLDAPLocality::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,Description);
}

STDMETHODIMP CLDAPLocality::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CLDAPLocality::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CLDAPLocality::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CLDAPLocality::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CLDAPLocality::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}

STDMETHODIMP CLDAPLocality::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}

STDMETHODIMP
CLDAPLocality::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPLocality::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPLocality::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\corgucf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP OrganizationalUnit Object Class Factory Code
//
//             CLDAPOrganizationalUnitCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPOrganizationalUnitCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPOrganizationUnitCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPOrganizationUnit::CreateOrganizationUnit(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cprintcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP PrintQueue Object Class Factory Code
//
//             CLDAPPrintQueueCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPPrintQueueCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPPrintQueueCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPPrintQueue::CreatePrintQueue(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\corgcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP Organization Object Class Factory Code
//
//             CLDAPOrganizationCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPOrganizationCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPOrganizationCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    //
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE)
        RRETURN(E_INVALIDARG);

    hr = CLDAPOrganization::CreateOrganization(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\corgu.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  OrganizationUnit object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aOrgUnitPropMapping[] =
{ // { TEXT("Description"), TEXT("description") }, // does not exist in NTDS ???
  { TEXT("LocalityName"), TEXT("l") },
  // { TEXT("PostalAddress"), TEXT("postalAddress") },
  // { TEXT("TelephoneNumber"), TEXT("telephoneNumber") },
  { TEXT("FaxNumber"), TEXT("facsimileTelephoneNumber") }
  // { TEXT("SeeAlso"), TEXT("seeAlso") },
  // { TEXT("BusinessCategory"), TEXT("businessCategory") }
};

//  Class CLDAPOrganizationUnit


// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPOrganizationUnit)

DEFINE_IPrivateDispatch_Implementation(CLDAPOrganizationUnit)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPOrganizationUnit)
DEFINE_CONTAINED_IADs_Implementation(CLDAPOrganizationUnit)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPOrganizationUnit, aOrgUnitPropMapping)

CLDAPOrganizationUnit::CLDAPOrganizationUnit():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPOrganizationUnit);
}

HRESULT
CLDAPOrganizationUnit::CreateOrganizationUnit(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    CLDAPOrganizationUnit FAR * pOrganizationUnit = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pOrganizationUnit = new CLDAPOrganizationUnit();
    if (pOrganizationUnit == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    //  Ref Count = 1 from object tracker 
    //


    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pOrganizationUnit->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsOU,
                (IADsOU *)pOrganizationUnit,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pOrganizationUnit->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pOrganizationUnit->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pOrganizationUnit;


    RRETURN(hr);


error:

    if (pOrganizationUnit)
        delete  pOrganizationUnit;

    *ppvObj = NULL;

    RRETURN(hr);

}


CLDAPOrganizationUnit::~CLDAPOrganizationUnit( )
{
    //
    // Remember that the aggregatee has no reference counts to
    // decrement.
    //

    delete _pDispMgr;
}

STDMETHODIMP
CLDAPOrganizationUnit::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}


STDMETHODIMP
CLDAPOrganizationUnit::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsOU))
    {
        *ppv = (IADsOU FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) { 

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();


    return S_OK;
}

STDMETHODIMP
CLDAPOrganizationUnit::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP CLDAPOrganizationUnit::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,Description);
}

STDMETHODIMP CLDAPOrganizationUnit::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,Description);
}

STDMETHODIMP CLDAPOrganizationUnit::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}

STDMETHODIMP CLDAPOrganizationUnit::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}

STDMETHODIMP CLDAPOrganizationUnit::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}

STDMETHODIMP CLDAPOrganizationUnit::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}

STDMETHODIMP CLDAPOrganizationUnit::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}

STDMETHODIMP CLDAPOrganizationUnit::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}

STDMETHODIMP CLDAPOrganizationUnit::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}

STDMETHODIMP CLDAPOrganizationUnit::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}

STDMETHODIMP CLDAPOrganizationUnit::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}

STDMETHODIMP CLDAPOrganizationUnit::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}

STDMETHODIMP CLDAPOrganizationUnit::get_BusinessCategory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}

STDMETHODIMP CLDAPOrganizationUnit::put_BusinessCategory(THIS_ BSTR bstrBusinessCategory)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}

STDMETHODIMP
CLDAPOrganizationUnit::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPOrganizationUnit::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}

//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPOrganizationUnit::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPOrganizationUnit::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              I
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           I
//        PROPERTY_RO(AccountCanExpire, boolean, 3)             I
//        PROPERTY_RO(PasswordCanExpire, boolean, 4)            I
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              I
//        PROPERTY_RW(IsAdmin, boolean, 8)                      I
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   I
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           I
//        PROPERTY_RW(MaxLogins, long, 11)                      I
//        PROPERTY_RW(MaxStorage, long, 12)                     I
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         I
//        PROPERTY_RW(PasswordRequired, boolean, 14)            I
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        I
//
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

#include <lm.h>
#include <winldap.h>
#include "..\ldapc\ldpcache.hxx"
#include "..\ldapc\ldaputil.hxx"
#include "..\ldapc\parse.hxx"
#include <dsgetdc.h>
#include <sspi.h>


HRESULT
BuildLDAPPathFromADsPath2(
    LPWSTR szADsPathName,
    LPWSTR *pszLDAPServer,
    LPWSTR *pszLDAPDn,
    DWORD * pdwPort
);


DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

HRESULT
GetDomainDNSNameFromHost(
    LPWSTR szHostName,
    SEC_WINNT_AUTH_IDENTITY& AuthI,
    CCredentials &Credentials,
    DWORD dwPort,
    LPWSTR * ppszHostName
    );

//
// The list of server entries - detailing SSL support
//
PSERVSSLENTRY gpServerSSLList = NULL;

//
// Critical Section and support routines to protect list
//
CRITICAL_SECTION g_ServerListCritSect;


//
// Flag that indicates if kerberos is being used.
//
const unsigned long KERB_SUPPORT_FLAGS = ISC_RET_MUTUAL_AUTH ;
//
// Routines that support cacheing server SSL info for perf
//


#define STRING_LENGTH(p) ( p ? wcslen(p) : 0)

//
// Get the status of SSL support on the server pszServerName
// 0 indicates that the server was not in our list.
//
DWORD ReadServerSupportsSSL( LPWSTR pszServerName)
{
    ENTER_SERVERLIST_CRITICAL_SECTION();
    PSERVSSLENTRY pServerList = gpServerSSLList;
    DWORD dwRetVal = 0;

    //
    // Keep going through the list until we hit the end or
    // we find an entry that matches.
    //
    while ((pServerList != NULL) && (dwRetVal == 0)) {

#ifdef WIN95
        if (!(_wcsicmp(pszServerName, pServerList->pszServerName))) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszServerName,
                -1,
                pServerList->pszServerName,
                -1
            ) == CSTR_EQUAL ) {
#endif
            dwRetVal = pServerList->dwFlags;
        }

        pServerList = pServerList->pNext;
    }

    LEAVE_SERVERLIST_CRITICAL_SECTION();

    return dwRetVal;
}


HRESULT UpdateServerSSLSupportStatus(
            PWSTR pszServerName,
            DWORD dwFlags
            )
{
    HRESULT hr = S_OK;
    PSERVSSLENTRY pServEntry = NULL;
    ENTER_SERVERLIST_CRITICAL_SECTION()
    PSERVSSLENTRY pServerList = gpServerSSLList;
    DWORD dwRetVal = 0;

    ADsAssert(pszServerName && *pszServerName);

    //
    // Keep going through the list until we hit the end or
    // we find an entry that matches.
    //
    while ((pServerList != NULL) && (dwRetVal == 0)) {

#ifdef WIN95
        if (!(_wcsicmp(pszServerName, pServerList->pszServerName))) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszServerName,
                -1,
                pServerList->pszServerName,
                -1
            ) == CSTR_EQUAL ) {
#endif
            pServerList->dwFlags = dwFlags;
            LEAVE_SERVERLIST_CRITICAL_SECTION()
            RRETURN(S_OK);
        }

        pServerList = pServerList->pNext;
    }


    pServEntry = (PSERVSSLENTRY) AllocADsMem(sizeof(SERVSSLENTRY));

    if (!pServEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pServEntry->pszServerName = AllocADsStr(pszServerName);
    if (!pServEntry->pszServerName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pServEntry->dwFlags = dwFlags;

    pServEntry->pNext = gpServerSSLList;
    gpServerSSLList = pServEntry;

error:
    if (FAILED(hr) && pServEntry) {
        //
        // Free only pServEntry as the string cannot have
        // a value in the error case
        //
        FreeADsMem(pServEntry);
    }

    LEAVE_SERVERLIST_CRITICAL_SECTION();

    RRETURN(hr);
}

void FreeServerSSLSupportList()
{
    PSERVSSLENTRY pList = gpServerSSLList;
    PSERVSSLENTRY pPrevEntry = NULL;

    while (pList) {
        pPrevEntry = pList;

        FreeADsStr(pList->pszServerName);
        pList = pList->pNext;

        FreeADsMem(pPrevEntry);
    }
}

#if (!defined(WIN95))
//
// Take a AuthI struct and return a cred handle.
//
HRESULT
ConvertAuthIdentityToCredHandle(
    SEC_WINNT_AUTH_IDENTITY& AuthI,
    OUT PCredHandle CredentialsHandle
    )
{
    SECURITY_STATUS secStatus = SEC_E_OK;
    TimeStamp Lifetime;

    secStatus = AcquireCredentialsHandleWrapper(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME_W,
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthI,
                    NULL,
                    NULL,
                    CredentialsHandle,
                    &Lifetime
                    );

    if (secStatus != SEC_E_OK) {

        RRETURN(E_FAIL);
    } else {
        RRETURN(S_OK);
    }

}

//
// ***** Caller must free the strings put in the    ****
// ***** AuthIdentity struct later.                 ****
//
HRESULT
GetAuthIdentityForCaller(
    CCredentials& Credentials,
    IADs * pIADs,
    OUT SEC_WINNT_AUTH_IDENTITY *pAuthI,
    BOOL fEnforceMutualAuth
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszNTLMUser = NULL;
    LPWSTR pszNTLMDomain = NULL;
    LPWSTR pszDefaultServer = NULL;
    LPWSTR dn = NULL;
    LPWSTR passwd = NULL;
    IADsObjOptPrivate * pADsPrivObjectOptions = NULL;
    ULONG ulFlags = 0;

    if (fEnforceMutualAuth) {

        hr = pIADs->QueryInterface(
                 IID_IADsObjOptPrivate,
                 (void **)&pADsPrivObjectOptions
                 );
        BAIL_ON_FAILURE(hr);

        hr = pADsPrivObjectOptions->GetOption (
                 LDAP_MUTUAL_AUTH_STATUS,
                 (void *) &ulFlags
                 );

        BAIL_ON_FAILURE(hr);

        if (!(ulFlags & KERB_SUPPORT_FLAGS)) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }
    }

    hr = Credentials.GetUserName(&dn);
    BAIL_ON_FAILURE(hr);

    hr = Credentials.GetPassword(&passwd);
    BAIL_ON_FAILURE(hr);

    //
    // Get the userName and password into the auth struct.
    //
    hr = LdapCrackUserDNtoNTLMUser2(
            dn,
            &pszNTLMUser,
            &pszNTLMDomain
            );

    if (FAILED(hr)) {
        hr = LdapCrackUserDNtoNTLMUser(
                dn,
                &pszNTLMUser,
                &pszNTLMDomain
                );
        BAIL_ON_FAILURE(hr);
    }

    //
    // If the domain name is NULL and enforceMutualAuth is false,
    // then we need to throw in the defaultDomainName. This will
    // be needed subsequently for the LogonUser call.
    //
    if (!fEnforceMutualAuth && !pszNTLMDomain) {
        //
        // Call GetDefaultServer.
        //
        pszDefaultServer = (LPWSTR) AllocADsMem(sizeof(WCHAR) * MAX_PATH);
        if (!pszDefaultServer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pszNTLMDomain = (LPWSTR) AllocADsMem(sizeof(WCHAR) * MAX_PATH);
        if (!pszNTLMDomain) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = GetDefaultServer(
                 -1, // this will use the default ldap port
                 FALSE,
                 pszNTLMDomain,
                 pszDefaultServer,
                 TRUE
                 );
        BAIL_ON_FAILURE(hr);
    }

    pAuthI->User = (PWCHAR)pszNTLMUser;
    pAuthI->UserLength = (pszNTLMUser == NULL)? 0: wcslen(pszNTLMUser);
    pAuthI->Domain = (PWCHAR)pszNTLMDomain;
    pAuthI->DomainLength = (pszNTLMDomain == NULL)? 0: wcslen(pszNTLMDomain);
    pAuthI->Password = (PWCHAR)passwd;
    pAuthI->PasswordLength = (passwd == NULL)? 0: wcslen(passwd);
    pAuthI->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;


error:

    if (FAILED(hr)) {

        //
        // Free the strings
        //
        if (pszNTLMUser) {
            FreeADsStr(pszNTLMUser);
        }

        if (pszNTLMDomain) {
            FreeADsStr(pszNTLMDomain);
        }

        if (passwd) {
            FreeADsStr(passwd);
        }
    }

    if (pADsPrivObjectOptions) {
        pADsPrivObjectOptions->Release();
    }

    //
    // Always free the dn
    //
    if (dn) {
        FreeADsStr(dn);
    }

    if (pszDefaultServer) {
        FreeADsMem(pszDefaultServer);
    }

    RRETURN(hr);
}
#endif

//  Class CLDAPUser

STDMETHODIMP
CLDAPUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
    if ( retval == NULL )
        RRETURN( E_ADS_BAD_PARAMETER );

    LONG lUserAcctControl;
    HRESULT hr = get_LONG_Property( (IADsUser *)this,
                                     TEXT("userAccountControl"),
                                     &lUserAcctControl );

    if ( SUCCEEDED(hr))
        *retval = lUserAcctControl & UF_ACCOUNTDISABLE ?
                      VARIANT_TRUE : VARIANT_FALSE;

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
    LONG lUserAcctControl;
    HRESULT hr = get_LONG_Property( (IADsUser *)this,
                                    TEXT("userAccountControl"),
                                    &lUserAcctControl );
    if ( SUCCEEDED(hr))
    {
        if ( fAccountDisabled )
            lUserAcctControl |= UF_ACCOUNTDISABLE;
        else
            lUserAcctControl &= ~UF_ACCOUNTDISABLE;

        hr = put_LONG_Property( (IADsUser *)this,
                                 TEXT("userAccountControl"),
                                 lUserAcctControl );
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CLDAPUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_FILETIME((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CLDAPUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{
    HRESULT hr = S_OK;

    VARIANT var;
    IADsLargeInteger *pLargeInt = NULL;

    LONG LowPart, HighPart;

    if ( retval == NULL )
        RRETURN( E_ADS_BAD_PARAMETER );

    VariantInit(&var);

    hr = _pADs->Get(TEXT("lockoutTime"), &var);

    if (SUCCEEDED(hr)) {
        //
        // There's a lockoutTime, we need to determine
        // if it equals 0 (== not locked-out).
        //
        ADsAssert(V_VT(&var) == VT_DISPATCH);

        if (V_VT(&var) != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        hr = V_DISPATCH(&var)->QueryInterface(IID_IADsLargeInteger,
                                              reinterpret_cast<void**>(&pLargeInt)
                                              );
        BAIL_ON_FAILURE(hr);

        hr = pLargeInt->get_LowPart(&LowPart);
        BAIL_ON_FAILURE(hr);
        
        hr = pLargeInt->get_HighPart(&HighPart);
        BAIL_ON_FAILURE(hr);

        if ( (LowPart != 0) || (HighPart != 0) ) {
            *retval = VARIANT_TRUE;
        }
        else {
            *retval = VARIANT_FALSE;
        }

    }
    else if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        //
        // If there's no lockoutTime, the account is not
        // locked-out.
        //
        *retval = VARIANT_FALSE;
        hr = S_OK;
    }
    else {
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pLargeInt) {
        pLargeInt->Release();
    }

    VariantClear(&var);
    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
    HRESULT hr = S_OK;

    if (fIsAccountLocked) {
        //
        // You cannot set an account to a locked state.
        //
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    hr = put_LONG_Property( (IADsUser *)this,
                             TEXT("lockoutTime"),
                             0 );

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CLDAPUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, LoginHours);
}

STDMETHODIMP
CLDAPUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_BSTRARRAY((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CLDAPUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    PUT_PROPERTY_BSTRARRAY((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CLDAPUser::get_MaxLogins(THIS_ long FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPUser::get_MaxStorage(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}


STDMETHODIMP
CLDAPUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}

STDMETHODIMP
CLDAPUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CLDAPUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CLDAPUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
    if ( retval == NULL )
        RRETURN( E_ADS_BAD_PARAMETER );

    LONG lUserAcctControl;
    HRESULT hr = get_LONG_Property( (IADsUser *)this,
                                     TEXT("userAccountControl"),
                                     &lUserAcctControl );

    if ( SUCCEEDED(hr))
        *retval = lUserAcctControl & UF_PASSWD_NOTREQD ?
                      VARIANT_FALSE: VARIANT_TRUE;

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
    LONG lUserAcctControl;
    HRESULT hr = get_LONG_Property( (IADsUser *)this,
                                    TEXT("userAccountControl"),
                                    &lUserAcctControl );
    if ( SUCCEEDED(hr))
    {
        if ( fPasswordRequired )
            lUserAcctControl &= ~UF_PASSWD_NOTREQD;
        else
            lUserAcctControl |= UF_PASSWD_NOTREQD;

        hr = put_LONG_Property( (IADsUser *)this,
                                 TEXT("userAccountControl"),
                                 lUserAcctControl );
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::get_PasswordMinimumLength(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CLDAPUser::put_PasswordMinimumLength(THIS_ LONG lPasswordMinimumLength)
{
    PUT_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CLDAPUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CLDAPUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

BOOLEAN
_cdecl   ServerCertCallback(
                      PLDAP Connection,
                      PCCERT_CONTEXT  pServerCert
                      )
{
   //
   // After the secure connection is established, this function is called by
   // LDAP. This gives the client an opportunity to verify the server cert.
   // If, for some reason, the client doesn't approve it, it should return FALSE
   // and the connection will be terminated. Else, return TRUE
   //

   fprintf( stderr, "Server cert callback has been called...\n" );

   //
   // Use some way to verify the server certificate.
   //

   return TRUE;
}

STDMETHODIMP
CLDAPUser::SetPassword(THIS_ BSTR bstrNewPassword)
{
    HRESULT hr = E_FAIL;
    BOOLEAN bUseLDAP = FALSE;

    LPWSTR pszServer = NULL;
    LPWSTR pszHostName = NULL;
    DWORD dwLen = 0;
    
    int err = 0;

    BSTR bstrADsPath = NULL;
    LPWSTR szServerSSL = NULL;
    LPWSTR szDn = NULL;
    DWORD dwPortSSL = 0;
    PADSLDP pAdsLdpSSL = NULL;

    IADsObjOptPrivate * pADsPrivObjectOptions = NULL;
    PADSLDP pAdsLdp = NULL;
    LDAPMessage *pMsgResult = NULL;
    LDAPMessage *pMsgEntry = NULL;
    LDAP *pLdapCurrent = NULL;
    LPWSTR Attributes[] = {L"objectClass", NULL};

    VARIANT varSamAccount;
    DWORD dwServerPwdSupport = SERVER_STATUS_UNKNOWN;
    LPWSTR pszHostDomainName = NULL;
    SEC_WINNT_AUTH_IDENTITY AuthI;
    BOOLEAN fPasswordSet = FALSE;
    LPWSTR pszTempPwd = NULL;
    ULONG ulFlags = 0;
    VARIANT varGetInfoEx;
    BOOL fCachePrimed = FALSE;

    BOOL fImpersonating = FALSE;
    HANDLE hUserToken = INVALID_HANDLE_VALUE;

    //
    // Init params we will need to free later.
    //
    AuthI.User = NULL;
    AuthI.Domain = NULL;
    AuthI.Password = NULL;
    VariantInit(&varSamAccount);
    VariantInit(&varGetInfoEx);

    //
    // Get the Ldap path of the user object
    //
    hr = _pADs->get_ADsPath( &bstrADsPath );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
                bstrADsPath,
                &szServerSSL,
                &szDn,
                &dwPortSSL
                );
    BAIL_ON_FAILURE(hr);

    //
    // Now do an LDAP Search with Referrals and get the handle to success
    // connection. This is where we can find the server the referred object
    // resides on
    //
    hr = _pADs->QueryInterface(
                    IID_IADsObjOptPrivate,
                    (void **)&pADsPrivObjectOptions
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADsPrivObjectOptions->GetOption (
             LDAP_SERVER,
             (void*)&pszHostName
             );

    BAIL_ON_FAILURE(hr);

    //
    // additional lengh 3 is for '\0' and "\\\\"
    //
    dwLen = STRING_LENGTH(pszHostName) + 3;
    pszServer = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );
    if (!pszServer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    wcscpy(pszServer,L"\\\\");
    wcscat(pszServer, pszHostName);        
            
    dwServerPwdSupport = ReadServerSupportsSSL(pszHostName);

    if (dwServerPwdSupport ==
                (  SERVER_STATUS_UNKNOWN
                 | SERVER_DOES_NOT_SUPPORT_SSL
                 | SERVER_DOES_NOT_SUPPORT_NETUSER
                 | SERVER_DOES_NOT_SUPPORT_KERBEROS )
        ) {
        //
        // All flags are set, we will reset and rebuild cache
        //
        UpdateServerSSLSupportStatus(
            pszHostName,
            SERVER_STATUS_UNKNOWN
            );
        dwServerPwdSupport = SERVER_STATUS_UNKNOWN;
    }

    if (dwServerPwdSupport == SERVER_STATUS_UNKNOWN
        || !(dwServerPwdSupport & SERVER_DOES_NOT_SUPPORT_SSL)) {

        //
        // Try to establish SSL connection for this Password Operation
        //
        hr = LdapOpenObject(
                    pszHostName,
                    szDn,
                    &pAdsLdpSSL,
                    _Credentials,
                    636
                    );

        if (SUCCEEDED(hr)) {
            int retval;
            SecPkgContext_ConnectionInfo  sslattr;

            retval = ldap_get_option( pAdsLdpSSL->LdapHandle, LDAP_OPT_SSL_INFO, &sslattr );
            if (retval == LDAP_SUCCESS) {
                //
                // If Channel is secure enough, enable LDAP Password Change
                //
                if (sslattr.dwCipherStrength >= 128) {
                    bUseLDAP = TRUE;
                }
            }
        }

        //
        // Update the SSL support if appropriate
        //
        if (dwServerPwdSupport == SERVER_STATUS_UNKNOWN
            || !bUseLDAP) {

            //
            // Set the server does not support ssl bit if necessary
            //
            UpdateServerSSLSupportStatus(
                pszHostName,
                bUseLDAP ?
                dwServerPwdSupport :
                dwServerPwdSupport |= SERVER_DOES_NOT_SUPPORT_SSL
            );
        }
    }

    if (bUseLDAP) {
        //
        // LDAP Password Set
        //
        PLDAPModW prgMod[2];
        LDAPModW ModReplace;
        struct berval* rgBerVal[2];
        struct berval BerVal;
        int ipwdLen;

        prgMod[0] = &ModReplace;
        prgMod[1] = NULL;

        ModReplace.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
        ModReplace.mod_type = L"unicodePwd";
        ModReplace.mod_bvalues = rgBerVal;
        rgBerVal[0] = &BerVal;
        rgBerVal[1] = NULL;

        //
        // 2 extra for "" to put the password in.
        //
        if (bstrNewPassword) {
            ipwdLen = (wcslen(bstrNewPassword) + 2) * sizeof(WCHAR);
        }
        else {
            ipwdLen = 2 * sizeof(WCHAR);
        }

        //
        // Add 1 for the \0.
        //
        pszTempPwd = (LPWSTR) AllocADsMem(ipwdLen + sizeof(WCHAR));
        if (!pszTempPwd) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcscpy(pszTempPwd, L"\"");
        if (bstrNewPassword) {
            wcscat(pszTempPwd, bstrNewPassword);
        }

        wcscat(pszTempPwd, L"\"");


        BerVal.bv_len = ipwdLen;
        BerVal.bv_val = (char*)pszTempPwd;

        hr = LdapModifyS(
                       pAdsLdpSSL,
                       szDn,
                       prgMod
                       );
        BAIL_ON_FAILURE(hr);

        //
        // Set flag so that we do not try any other methods.
        //
        fPasswordSet = TRUE;
    }


//
// Try kerberos setpassword if applicable
//
#if (!defined(WIN95))
//
// Only valid on Win2k
//
    if (!fPasswordSet) {

        //
        // If we cached the server as not supporting Kerberos, most likely it
        // was because we were not mutually authenticated.  Do a quick check to
        // see if that has changed, so that we can update our cached information
        // if necessary.
        //
        if (dwServerPwdSupport & SERVER_DOES_NOT_SUPPORT_KERBEROS) {

            hr = pADsPrivObjectOptions->GetOption (
                     LDAP_MUTUAL_AUTH_STATUS,
                     (void *) &ulFlags
                     );

            BAIL_ON_FAILURE(hr);

            if ((ulFlags & KERB_SUPPORT_FLAGS)) {
                UpdateServerSSLSupportStatus(
                    pszHostName,
                    dwServerPwdSupport &= (~SERVER_DOES_NOT_SUPPORT_KERBEROS)
                    );
            }
        }
    
        if (!(dwServerPwdSupport & SERVER_DOES_NOT_SUPPORT_KERBEROS)) {

            //
            // Kerberos set password
            //
            CredHandle secCredHandle = {0};
            SECURITY_STATUS SecStatus;
            DWORD dwStatus = 0;
            LPWSTR pszSamAccountArr[] = {L"sAMAccountName"};

            if (!fCachePrimed) {
                hr = ADsBuildVarArrayStr( pszSamAccountArr, 1, &varGetInfoEx );
                BAIL_ON_FAILURE(hr);

                hr = _pADs->GetInfoEx(varGetInfoEx, 0);
                BAIL_ON_FAILURE(hr);

                fCachePrimed = TRUE;
            }
            
            hr = _pADs->Get(L"sAMAccountName", &varSamAccount);
            BAIL_ON_FAILURE(hr);

            //
            // The AuthIdentity structure is ueful down the road.
            // This routine will fail if we were not bound using
            // kerberos to the server.
            //
            hr = GetAuthIdentityForCaller(
                     _Credentials,
                     _pADs,
                     &AuthI,
                     TRUE // enforce mutual auth.
                     );

            if (FAILED(hr)) {
                UpdateServerSSLSupportStatus(
                    pszHostName,
                    dwServerPwdSupport |= SERVER_DOES_NOT_SUPPORT_KERBEROS
                    );
            }
            else {

                //
                // Kerb really needs this handle.
                //
                hr = ConvertAuthIdentityToCredHandle(
                         AuthI,
                         &secCredHandle
                         );

                if (FAILED(hr)) {
                    UpdateServerSSLSupportStatus(
                        pszHostName,
                        dwServerPwdSupport |= SERVER_DOES_NOT_SUPPORT_KERBEROS
                        );
                }

                if (SUCCEEDED(hr)) {

                    //
                    // Get the domain dns name for the user
                    //
                    hr = GetDomainDNSNameFromHost(
                             pszHostName,
                             AuthI,
                             _Credentials,
                             dwPortSSL,
                             &pszHostDomainName
                             );

                    if (SUCCEEDED(hr)) {

                        dwStatus = KerbSetPasswordUserEx(
                                        pszHostDomainName,
                                        V_BSTR(&varSamAccount),
                                        bstrNewPassword,
                                        &secCredHandle,
                                        pszHostName
                                        );

                        if (dwStatus) {
                            //
                            // We should have got this to come in here.
                            //
                            hr = HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE);
                        }
                        else {
                            fPasswordSet = TRUE;
                        }
                    } // if domain dns name get succeeded.

                    FreeCredentialsHandleWrapper(&secCredHandle);

                } // if GetCredentialsForCaller succeeded.
            } // if we could get authidentity succesfully
        } // if server supports kerberos
    } // if password not set.
#endif
    //
    //  At this point server status cannot be unknown, it
    // will atleast have info about ssl support.
    //
    if (!fPasswordSet) {

        if (!(dwServerPwdSupport & SERVER_DOES_NOT_SUPPORT_NETUSER)) {
            //
            // Password Set using NET APIs
            //
            NET_API_STATUS nasStatus;
            DWORD dwParmErr = 0;
            LPWSTR pszSamAccountArr[] = {L"sAMAccountName"};

            //
            // Get SamAccountName
            //
            VariantClear(&varSamAccount);
            VariantClear(&varGetInfoEx);
            

            if (!fCachePrimed) {
                hr = ADsBuildVarArrayStr( pszSamAccountArr, 1, &varGetInfoEx );
                BAIL_ON_FAILURE(hr);

                hr = _pADs->GetInfoEx(varGetInfoEx, 0);
                BAIL_ON_FAILURE(hr);

                fCachePrimed = TRUE;
            }

            hr = _pADs->Get(L"sAMAccountName", &varSamAccount);
            BAIL_ON_FAILURE(hr);

            //
            // Set the password
            //
            USER_INFO_1003 lpUserInfo1003 ;

            lpUserInfo1003.usri1003_password = bstrNewPassword;

#ifndef Win95
            //
            // At this point if the user credentials are non NULL,
            // we want to impersonate the user and then make this call.
            // This will make sure the NetUserSetInfo call is made in the
            // correct context.
            //
            if (!_Credentials.IsNullCredentials()) {
                //
                // Need to get the userName and password in the format
                // usable by the logonUser call.
                //
                if ((AuthI.User == NULL)
                    && (AuthI.Domain == NULL)
                    && (AuthI.Password == NULL)
                    ) {
                    //
                    // Get teh Auth identity struct populate if necessary.
                    //
                    hr = GetAuthIdentityForCaller(
                             _Credentials,
                             _pADs,
                             &AuthI,
                             FALSE
                             );
                }

                BAIL_ON_FAILURE(hr);

                //
                // Note that if this code is backported, then we might
                // need to change LOGON32_PROVIDER_WINNT50 to 
                // LOGON32_PROVIDER_DEFAULT as NT4 and below will support
                // only that option. Also note that Win2k and below, do not
                // allow all accounts to impersonate.
                //
                if (LogonUser(
                        AuthI.User,
                        AuthI.Domain,
                        AuthI.Password,
                        LOGON32_LOGON_NEW_CREDENTIALS,
                        LOGON32_PROVIDER_WINNT50,
                        &hUserToken
                        )
                    ) {
                    //
                    // Call succeeded so we should use this context.
                    //
                    if (ImpersonateLoggedOnUser(hUserToken)) {
                        fImpersonating = TRUE;
                    } 
                }
                if (!fImpersonating) {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
                
                BAIL_ON_FAILURE(hr);
            } // if credentials are valid.
#endif

            nasStatus = NetUserSetInfo(
                            pszServer,
                            V_BSTR(&varSamAccount),
                            1003,
                            (LPBYTE)&lpUserInfo1003,
                            &dwParmErr
                            );
#ifndef Win95
            if (fImpersonating) {
                if (RevertToSelf()) {
                    fImpersonating = FALSE;
                } 
                else {
                    ADsAssert(!"Revert to self failed.");
                    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
                }
            }
#endif

            if ( nasStatus == NERR_UserNotFound )  { // User not created yet
                hr = E_ADS_OBJECT_UNBOUND;
                BAIL_ON_FAILURE(hr);
            }

            hr = HRESULT_FROM_WIN32(nasStatus);
            if (FAILED(hr) && (nasStatus == ERROR_LOGON_FAILURE)) {

                //
                // Was failure and ERROR_LOGON_FAILURE
                //
                UpdateServerSSLSupportStatus(
                    pszHostName,
                    dwServerPwdSupport |= SERVER_DOES_NOT_SUPPORT_NETUSER
                    );
                //
                // Need to free the variant as we will re-read in kerb
                //
                VariantClear(&varSamAccount);
            }
            else {
                //
                // password set succeed
                //
                fPasswordSet = TRUE;
            }
        }
    } // if Password not set.


    
error:
    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (szServerSSL) {
        FreeADsStr(szServerSSL);
    }

    if (szDn) {
        FreeADsStr(szDn);
    }

    if (pAdsLdpSSL) {
        LdapCloseObject(pAdsLdpSSL);
    }

    if (pADsPrivObjectOptions) {
        pADsPrivObjectOptions->Release();
    }

    if (pMsgResult) {
        LdapMsgFree(pMsgResult);
    }

    if (pszHostDomainName) {
        FreeADsStr(pszHostDomainName);
    }

    if (AuthI.User) {
        FreeADsStr(AuthI.User);
    }

    if (AuthI.Domain) {
        FreeADsStr(AuthI.Domain);
    }

    if (AuthI.Password) {
        FreeADsStr(AuthI.Password);
    }

    if (pszTempPwd) {
        FreeADsMem(pszTempPwd);
    } 

    if (pszHostName) {
    	FreeADsStr(pszHostName);
    }

    if (pszServer) {
    	FreeADsMem(pszServer);
    }

   
#ifndef Win95
    if (fImpersonating) {
        //
        // Try and call revert to self again
        //
        RevertToSelf();
    }
#endif

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }

    VariantClear(&varSamAccount);
    VariantClear(&varGetInfoEx);

    RRETURN(hr);
}


STDMETHODIMP
CLDAPUser::ChangePassword(THIS_ BSTR bstrOldPassword, BSTR bstrNewPassword)
{
    HRESULT hr = S_OK;
    BOOLEAN bUseLDAP = FALSE;

    LPWSTR pszServer = NULL;
    LPWSTR pszHostName = NULL;
    DWORD dwLen = 0;
        
    int err = 0;

    BSTR bstrADsPath = NULL;
    LPWSTR szServerSSL = NULL;
    LPWSTR szDn = NULL;
    DWORD dwPortSSL = 0;
    PADSLDP pAdsLdpSSL = NULL;

    IADsObjOptPrivate * pADsPrivObjectOptions = NULL;
    PADSLDP pAdsLdp = NULL;
    LDAPMessage *pMsgResult = NULL;
    LDAPMessage *pMsgEntry = NULL;
    LDAP *pLdapCurrent = NULL;
    LPWSTR Attributes[] = {L"objectClass", NULL};

    VARIANT varSamAccount;
    DWORD dwServerSSLSupport = 0;
    LPWSTR pszNewPassword = NULL;
    LPWSTR pszOldPassword = NULL;
    VARIANT varGetInfoEx;
    
    SEC_WINNT_AUTH_IDENTITY AuthI;
    BOOL fImpersonating = FALSE;
    HANDLE hUserToken = INVALID_HANDLE_VALUE;

    VariantInit(&varSamAccount);
    VariantInit(&varGetInfoEx);
    memset(&AuthI, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));

    //
    // Get the Ldap path of the user object
    //
    hr = _pADs->get_ADsPath( &bstrADsPath );
    BAIL_ON_FAILURE(hr);

    hr = BuildLDAPPathFromADsPath2(
                bstrADsPath,
                &szServerSSL,
                &szDn,
                &dwPortSSL
                );
    BAIL_ON_FAILURE(hr);

    //
    // Now do an LDAP Search with Referrals and get the handle to success
    // connection. This is where we can find the server the referred object
    // resides on
    //
    hr = _pADs->QueryInterface(
                    IID_IADsObjOptPrivate,
                    (void **)&pADsPrivObjectOptions
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADsPrivObjectOptions->GetOption (
             LDAP_SERVER,
             (void *)&pszHostName
             );

    BAIL_ON_FAILURE(hr);

    //
    // additional length 3 is for '\0' and "\\\\"
    //
    dwLen = STRING_LENGTH(pszHostName) + 3;
    pszServer = (LPWSTR) AllocADsMem( dwLen * sizeof(WCHAR) );
    if (!pszServer) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    wcscpy(pszServer,L"\\\\");
    wcscat(pszServer, pszHostName);        
            
    dwServerSSLSupport = ReadServerSupportsSSL(pszHostName);

    if (dwServerSSLSupport == SERVER_STATUS_UNKNOWN
        || !(dwServerSSLSupport & SERVER_DOES_NOT_SUPPORT_SSL)) {

        //
        // Try to establish SSL connection for this Password Operation
        //

        hr = LdapOpenObject(
                    pszHostName,
                    szDn,
                    &pAdsLdpSSL,
                    _Credentials,
                    636
                    );

        if (SUCCEEDED(hr)) {
            int retval;
            SecPkgContext_ConnectionInfo  sslattr;

            retval = ldap_get_option( pAdsLdpSSL->LdapHandle, LDAP_OPT_SSL_INFO, &sslattr );
            if (retval == LDAP_SUCCESS) {
                //
                // If Channel is secure enough, enable LDAP Password Change
                //
                if (sslattr.dwCipherStrength >= 128) {
                    bUseLDAP = TRUE;
                }
            }
        }

        //
        // Update the SSL support if appropriate
        //
        if (dwServerSSLSupport == SERVER_STATUS_UNKNOWN
            || !bUseLDAP) {

            UpdateServerSSLSupportStatus(
                pszHostName,
                bUseLDAP ?
                dwServerSSLSupport :
                dwServerSSLSupport |= SERVER_DOES_NOT_SUPPORT_SSL
            );
        }

    }

    if (bUseLDAP) {
        //
        // LDAP Password Set
        //
        PLDAPModW prgMod[3];
        LDAPModW ModDelete;
        LDAPModW ModAdd;
        int iOldPwdLen, iNewPwdLen;
        struct berval* rgBerVal[2];
        struct berval* rgBerVal2[2];
        struct berval BerVal;
        struct berval BerVal2;

        prgMod[0] = &ModDelete;
        prgMod[1] = &ModAdd;
        prgMod[2] = NULL;

        ModDelete.mod_op = LDAP_MOD_DELETE | LDAP_MOD_BVALUES;
        ModDelete.mod_type = L"unicodePwd";
        ModDelete.mod_bvalues = rgBerVal;
        rgBerVal[0] = &BerVal;
        rgBerVal[1] = NULL;
        //
        // Put old pwd in quotes.
        //
        if (bstrOldPassword) {
            iOldPwdLen = (wcslen(bstrOldPassword) + 2) * sizeof(WCHAR);
        }
        else {
            iOldPwdLen = 2 * sizeof(WCHAR);
        }

        pszOldPassword = (LPWSTR) AllocADsMem((iOldPwdLen+1) * sizeof(WCHAR));

        if (!pszOldPassword) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcscpy(pszOldPassword, L"\"");
        if (bstrOldPassword) {
            wcscat(pszOldPassword, bstrOldPassword);
        }

        wcscat(pszOldPassword, L"\"");

        BerVal.bv_len = iOldPwdLen;
        BerVal.bv_val = (char*)pszOldPassword;

        ModAdd.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
        ModAdd.mod_type = L"unicodePwd";
        ModAdd.mod_bvalues = rgBerVal2;
        rgBerVal2[0] = &BerVal2;
        rgBerVal2[1] = NULL;
        //
        // Put new password in ""
        //
        if (bstrNewPassword) {
            iNewPwdLen = (wcslen(bstrNewPassword) + 2) * sizeof(WCHAR);
        }
        else {
            iNewPwdLen = 2 * sizeof(WCHAR);
        }

        pszNewPassword = (LPWSTR) AllocADsMem(iNewPwdLen + sizeof(WCHAR));

        if (!pszNewPassword) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        wcscpy(pszNewPassword, L"\"");
        if (bstrNewPassword) {
            wcscat(pszNewPassword, bstrNewPassword);
        }
        wcscat(pszNewPassword, L"\"");


        BerVal2.bv_len = iNewPwdLen;
        BerVal2.bv_val = (char*)pszNewPassword;

        hr = LdapModifyS(
                       pAdsLdpSSL,
                       szDn,
                       prgMod
                       );
        BAIL_ON_FAILURE(hr);
    }
    else {
        //
        // Password Set using NET APIs
        //
        NET_API_STATUS nasStatus;
        DWORD dwParmErr = 0;
        LPWSTR pszSamAccountArr[] = {L"sAMAccountName"};

        //
        // Get SamAccountName
        //

        hr = ADsBuildVarArrayStr( pszSamAccountArr, 1, &varGetInfoEx );
        BAIL_ON_FAILURE(hr);

        hr = _pADs->GetInfoEx(varGetInfoEx, 0);
        BAIL_ON_FAILURE(hr);
        
        hr = _pADs->Get(L"sAMAccountName", &varSamAccount);
        BAIL_ON_FAILURE(hr);

#ifndef Win95
        //
        // At this point if the user credentials are non NULL,
        // we want to impersonate the user and then make this call.
        // This will make sure the NetUserChangePassword call is made in the
        // correct context.
        //
        if (!_Credentials.IsNullCredentials()) {
            //
            // Need to get the userName and password in the format
            // usable by the logonUser call.
            //
            hr = GetAuthIdentityForCaller(
                    _Credentials,
                    _pADs,
                    &AuthI,
                    FALSE
                    );

            if SUCCEEDED(hr) {
            
                //
                // Note that if this code is backported, then we might
                // need to change LOGON32_PROVIDER_WINNT50 to 
                // LOGON32_PROVIDER_DEFAULT as NT4 and below will support
                // only that option. Also note that Win2k and below, do not
                // allow all accounts to impersonate.
                //
                if (LogonUser(
                         AuthI.User,
                         AuthI.Domain,
                         AuthI.Password,
                         LOGON32_LOGON_NEW_CREDENTIALS,
                         LOGON32_PROVIDER_DEFAULT,
                         &hUserToken
                         )
                    ) {
                    //  
                    // Call succeeded so we should use this context.
                    //
                    if (ImpersonateLoggedOnUser(hUserToken)) {
                        fImpersonating = TRUE;
                    } 
                }
            } // if we could successfully get the auth ident structure.

            //
            // We will continue to make the ChangePassword call even if
            // we could not impersonate successfully.
            //

        } // if credentials are valid.
#endif

        //
        // Do the actual change password
        //
        nasStatus = NetUserChangePassword(
                            pszServer,
                            V_BSTR(&varSamAccount),
                            bstrOldPassword,
                            bstrNewPassword
                            );
#ifndef Win95
        if (fImpersonating) {
            if (RevertToSelf()) {
                fImpersonating = FALSE;
            }
            else {
                ADsAssert(!"Revert to self failed.");
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
            }
        }
#endif


        if ( nasStatus == NERR_UserNotFound )  // User not created yet
        {
            hr = E_ADS_OBJECT_UNBOUND;
            BAIL_ON_FAILURE(hr);
        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);
    }

        
error:
    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (szServerSSL) {
        FreeADsStr(szServerSSL);
    }

    if (szDn) {
        FreeADsStr(szDn);
    }

    if (pAdsLdpSSL) {
        LdapCloseObject(pAdsLdpSSL);
    }

    if (pADsPrivObjectOptions) {
        pADsPrivObjectOptions->Release();
    }

    if (pMsgResult) {
        LdapMsgFree(pMsgResult);
    }

    if (pszOldPassword) {
        FreeADsMem(pszOldPassword);
    }
    
    if (pszNewPassword) {
        FreeADsMem(pszNewPassword);
    }

    if (AuthI.User) {
        FreeADsStr(AuthI.User);
    }

    if (AuthI.Domain) {
        FreeADsStr(AuthI.Domain);
    }

    if (AuthI.Password) {
        FreeADsStr(AuthI.Password);
    }
   
    if (pszHostName) {
    	FreeADsStr(pszHostName);
    }

    if (pszServer) {
    	FreeADsMem(pszServer);
    }

   
#ifndef Win95
    if (fImpersonating) {
        //
        // Try and call revert to self again
        //
        RevertToSelf();
    }
#endif

    if (hUserToken != INVALID_HANDLE_VALUE ) {
        CloseHandle(hUserToken);
        hUserToken = NULL;
    }

    VariantClear(&varSamAccount);
    VariantClear(&varGetInfoEx);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// GetDomainDNSNameFromHost
//
// Given the domain dns name for a host, we need to get hold of the
// dns name for the domain.
//
// Arguments:
//   [szHostName]       - name of server.
//   [Credentials]      - Credentials to use for bind.
//   [dwPort]           - Port to connect to server on.
//   [ppszHostName]     - ptr to string for retval.
//
// Returns:
//  S_OK                - If operation succeeds.
//  E_*                 - For other cases.
//
//----------------------------------------------------------------------------
HRESULT
GetDomainDNSNameFromHost(
    LPWSTR szHostName,
    SEC_WINNT_AUTH_IDENTITY& AuthI,
    CCredentials& Credentials,
    DWORD dwPort,
    LPWSTR * ppszHostName
    )
{
    HRESULT hr = S_OK;
    PADSLDP ld = NULL;
    LPTSTR *aValuesNamingContext = NULL;
    IADsNameTranslate *pNameTranslate = NULL;
    BSTR bstrName = NULL;
    int nCount = 0;

    //
    // Bind to the ROOTDSE of the server.
    //
    hr = LdapOpenObject(
             szHostName,
             NULL, // the DN.
             &ld,
             Credentials,
             dwPort
             );

    BAIL_ON_FAILURE(hr);

    //
    // Now get the defaultNamingContext
    //
    hr = LdapReadAttributeFast(
             ld,
             NULL, // the DN.
             LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
             &aValuesNamingContext,
             &nCount
             );
    //
    // Verify we actuall got back at least one value
    //
    if (SUCCEEDED(hr) && (nCount < 1)) {
        hr = HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
    }

    BAIL_ON_FAILURE(hr);

    //
    // Create nametran object
    //
    hr = CoCreateInstance(
             CLSID_NameTranslate,
             NULL,
             CLSCTX_ALL,
             IID_IADsNameTranslate,
             (void **) &pNameTranslate
             );
    BAIL_ON_FAILURE(hr);

    //
    // Init with defaultNamingContext and get transalte
    //

    hr = pNameTranslate->InitEx(
                             ADS_NAME_INITTYPE_SERVER,
                             szHostName,
                             AuthI.User,
                             AuthI.Domain,
                             AuthI.Password
                             );
    BAIL_ON_FAILURE(hr);

    hr = pNameTranslate->Set(
                             ADS_NAME_TYPE_1779,
                             aValuesNamingContext[0]
                             );
    BAIL_ON_FAILURE(hr);


    hr = pNameTranslate->Get(
                             ADS_NAME_TYPE_CANONICAL,
                             &bstrName
                             );
    BAIL_ON_FAILURE(hr);

    if (!bstrName) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    *ppszHostName = AllocADsStr(bstrName);

    if (!*ppszHostName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Null terminate one place ahead so we can get rid of /
    //
    (*ppszHostName)[wcslen(bstrName)-1] = L'\0';


error :
    if (ld) {
        LdapCloseObject(ld);
    }

    if (pNameTranslate) {
        pNameTranslate->Release();
    }

    if (bstrName) {
        SysFreeString(bstrName);
    }

    if (aValuesNamingContext) {
        LdapValueFree(aValuesNamingContext);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


//  Class CLDAPUser

STDMETHODIMP CLDAPUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CLDAPUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, BadLoginCount);
}

STDMETHODIMP CLDAPUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, LastLogin);
}

STDMETHODIMP CLDAPUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, LastLogoff);
}
 
STDMETHODIMP CLDAPUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, LastFailedLogin);
}

STDMETHODIMP CLDAPUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_FILETIME((IADsUser *)this, PasswordLastChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Country, BSTR, 2)                   NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(DepartmentNumber, BSTR, 4)          NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(OfficeLocations, BSTR, 14)          NI
//      PROPERTY_RW(Picture, VARIANT, 15)               NI
//      PROPERTY_RW(TelecomNumber, VARIANT, 17)         NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


STDMETHODIMP
CLDAPUser::get_Description(THIS_ BSTR FAR* pbstrDescription)
{
    HRESULT hr = S_OK;
    VARIANT v;

    VariantInit(&v);
    hr = get_VARIANT_Property((IADs *)this, TEXT("Description"), &v );
    BAIL_IF_ERROR(hr);

    if ( V_ISARRAY(&v))
    {
        long i = 0;
        VARIANT vFirst;

        VariantInit(&vFirst);
        hr = SafeArrayGetElement( V_ARRAY(&v), &i, &vFirst );
        BAIL_IF_ERROR(hr);

        hr = ADsAllocString( V_BSTR(&vFirst), pbstrDescription );
        VariantClear(&vFirst);
    }
    else
    {
        hr = ADsAllocString( V_BSTR(&v), pbstrDescription );
    }

cleanup:

    VariantClear(&v);
    RRETURN(hr);

}

STDMETHODIMP
CLDAPUser::put_Description(THIS_ BSTR bstrDescription)
{
    HRESULT hr = S_OK;
    VARIANT vDescription;

    VariantInit(&vDescription);

    vDescription.vt = VT_BSTR;
    V_BSTR(&vDescription) = bstrDescription;

    hr = put_VARIANT_Property( (IADs *)this,
                               TEXT("Description"),
                               vDescription );

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CLDAPUser::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CLDAPUser::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CLDAPUser::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CLDAPUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CLDAPUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CLDAPUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CLDAPUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CLDAPUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CLDAPUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CLDAPUser::get_LastName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CLDAPUser::put_LastName(THIS_ BSTR bstrLastName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CLDAPUser::get_Manager(THIS_ BSTR FAR* retval)
{
     GET_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CLDAPUser::put_Manager(THIS_ BSTR bstrManager)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CLDAPUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, OfficeLocations);
}

STDMETHODIMP
CLDAPUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocations)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, OfficeLocations);
}

STDMETHODIMP
CLDAPUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Picture);
}

STDMETHODIMP
CLDAPUser::put_Picture(THIS_ VARIANT vPicture)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Picture);
}

STDMETHODIMP
CLDAPUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CLDAPUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CLDAPUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CLDAPUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CLDAPUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CLDAPUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CLDAPUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CLDAPUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CLDAPUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CLDAPUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CLDAPUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CLDAPUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CLDAPUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CLDAPUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CLDAPUser::get_Title(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CLDAPUser::put_Title(THIS_ BSTR bstrTitle)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CLDAPUser::get_HomePage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomePage);
}

STDMETHODIMP
CLDAPUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomePage);
}

STDMETHODIMP
CLDAPUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, SeeAlso );
}

STDMETHODIMP
CLDAPUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, SeeAlso );
}

STDMETHODIMP
CLDAPUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, NamePrefix );
}

STDMETHODIMP
CLDAPUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, NamePrefix );
}

STDMETHODIMP
CLDAPUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, NameSuffix );
}

STDMETHODIMP
CLDAPUser::put_NameSuffix(THIS_ BSTR bstrNameSuffix)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, NameSuffix );
}

STDMETHODIMP
CLDAPUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, OtherName );
}

STDMETHODIMP
CLDAPUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, OtherName );
}

STDMETHODIMP
CLDAPUser::Groups(THIS_ IADsMembers FAR* FAR * ppGroups)
{
    VARIANT varProp;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    VariantInit(&varProp);

    hr = _pADs->Get(L"memberOf", &varProp);
    if ( hr == E_ADS_PROPERTY_NOT_FOUND )
    {
        SAFEARRAY *aList = NULL;
        SAFEARRAYBOUND aBound;

        VariantInit(&varProp);
        hr = S_OK;

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        V_VT(&varProp) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&varProp) = aList;
    }
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = CLDAPUserCollection::CreateUserCollection(
                    bstrADsPath,
                    varProp,
                    _Credentials,
                    IID_IADsMembers,
                    (void **)ppGroups
                    );

    BAIL_ON_FAILURE(hr);

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    VariantClear(&varProp);

    RRETURN(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cprinter.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cprinter.cxx
//
//  Contents:
//
//  History:   9-26-96   yihsins    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

HRESULT
ChangeSeparator(
    LPWSTR pszDN
    );

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aPrintPropMapping[] =
{ { TEXT("Description"), TEXT("description") },
  { TEXT("PrintDevices"), TEXT("PortName") },
  { TEXT("Location"), TEXT("location") },
  { TEXT("HostComputer"), TEXT("serverName") },
  { TEXT("Model"), TEXT("DriverName") },
  { TEXT("StartTime"), TEXT("PrintStartTime") },
  { TEXT("UntilTime"), TEXT("PrintEndTime") },
  { TEXT("Priority"), TEXT("Priority") },
  { TEXT("BannerPage"), TEXT("PrintSeparatorfile") }
//  { TEXT("NetAddresses"), TEXT("PrintNetworkAddress") },
};

#define UNCNAME    TEXT("uNCName")

//
// Class CLDAPPrintQueue
//


// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPPrintQueue)

DEFINE_IPrivateDispatch_Implementation(CLDAPPrintQueue)
DEFINE_DELEGATING_IDispatch_Implementation(CLDAPPrintQueue)
DEFINE_CONTAINED_IADs_Implementation(CLDAPPrintQueue)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPPrintQueue,aPrintPropMapping)

CLDAPPrintQueue::CLDAPPrintQueue():
    _pUnkOuter(NULL),
    _pADs(NULL),
    _fDispInitialized(FALSE),
    _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPPrintQueue);
}

CLDAPPrintQueue::~CLDAPPrintQueue()
{
    delete _pDispMgr;
}

HRESULT
CLDAPPrintQueue:: CreatePrintQueue(
    IUnknown *pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj
    )

{
    CLDAPPrintQueue FAR * pPrintQueue = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pPrintQueue = new CLDAPPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Reference Count = 1 from object tracker
    //


    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pPrintQueue->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsPrintQueue,
                (IADsPrintQueue *)pPrintQueue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsPrintQueueOperations,
                (IADsPrintQueueOperations *)pPrintQueue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pPrintQueue->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pPrintQueue->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pPrintQueue;


    RRETURN(hr);


error:

    if (pPrintQueue)
        delete  pPrintQueue;

    *ppvObj = NULL;

    RRETURN(hr);

}


/* IUnknown methods */

STDMETHODIMP
CLDAPPrintQueue::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}


STDMETHODIMP
CLDAPPrintQueue::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);


    if (IsEqualIID(iid, IID_IADsPrintQueue))
    {
        *ppv = (IADsPrintQueue FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsPrintQueueOperations)) {

        *ppv = (IADsPrintQueueOperations FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) { 

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}




/* IADs methods */


/* IADsPrintQueue methods */

STDMETHODIMP
CLDAPPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, uNCName );
}

STDMETHODIMP
CLDAPPrintQueue::put_PrinterPath(THIS_ BSTR bstruNCName)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue*)this, uNCName);
}

STDMETHODIMP
CLDAPPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CLDAPPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CLDAPPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CLDAPPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP CLDAPPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP CLDAPPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP
CLDAPPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_LONGDATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CLDAPPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_LONGDATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CLDAPPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_LONGDATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CLDAPPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_LONGDATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CLDAPPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CLDAPPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CLDAPPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CLDAPPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CLDAPPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_BSTRARRAY((IADsPrintQueue *)this,PrintDevices);
}

STDMETHODIMP
CLDAPPrintQueue::put_PrintDevices(THIS_ VARIANT vPrintDevices)
{
    PUT_PROPERTY_BSTRARRAY((IADsPrintQueue *)this,PrintDevices);
}

STDMETHODIMP
CLDAPPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CLDAPPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

/* IADsPrintQueueOperations methods */

STDMETHODIMP
CLDAPPrintQueue::get_Status(THIS_ long FAR* retval)
{
    BOOL fSuccess = FALSE;
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hPrinter = NULL;
    BSTR  bstrPath = NULL ;
    LPPRINTER_INFO_2 lpPrinterInfo2 = NULL;
    DWORD dwBufferSize = 1024, dwNeeded ;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                        READ_CONTROL};

    //
    // get the 'Path' property
    //

    hr = get_BSTR_Property(this->_pADs, UNCNAME, &bstrPath) ;

    BAIL_IF_ERROR(hr);

    //
    // Do a GetPrinter call to bstrPath
    //

    fSuccess = OpenPrinter((LPTSTR)bstrPath,
                           &hPrinter,
                           &PrinterDefaults
                           );

    if (!fSuccess) {

        dwStatus = GetLastError();

        if (dwStatus == ERROR_ACCESS_DENIED) {

            PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE ;

            fSuccess = OpenPrinter((LPTSTR)bstrPath,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
        }

    }

    if (!fSuccess) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_IF_ERROR(hr);
    }


    if (!(lpPrinterInfo2 = (LPPRINTER_INFO_2) AllocADsMem(dwBufferSize))) {

        hr = HRESULT_FROM_WIN32(GetLastError()) ;
        BAIL_IF_ERROR(hr);
    }

    fSuccess = GetPrinter(hPrinter,
                         2,
                         (LPBYTE) lpPrinterInfo2,
                         dwBufferSize,
                         &dwNeeded);

    if (!fSuccess) {

        dwStatus = GetLastError() ;

        if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {

            lpPrinterInfo2 = (LPPRINTER_INFO_2) ReallocADsMem(
                                 lpPrinterInfo2,
                                 dwBufferSize,
                                 dwNeeded) ;

            if (!lpPrinterInfo2) {

                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                BAIL_IF_ERROR(hr);
            }

            dwBufferSize = dwNeeded ;

            fSuccess = GetPrinter(hPrinter,
                                 2,
                                 (LPBYTE) lpPrinterInfo2,
                                 dwBufferSize,
                                 &dwNeeded);
        }
    }

    if (!fSuccess) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_IF_ERROR(hr);
    }

    *retval = lpPrinterInfo2->Status;

cleanup:

    if (lpPrinterInfo2) {

        FreeADsMem((LPBYTE)lpPrinterInfo2);
    }

    if (hPrinter) {

        (void) ClosePrinter(hPrinter);
    }

    RRETURN(hr);

}

STDMETHODIMP
CLDAPPrintQueue::PrintJobs(
    THIS_ IADsCollection * FAR* ppCollection
    )
{

    //
    // The job collection object is created and it is passed the printer
    // name. It uses this to create a printer object
    //

    HRESULT hr = S_OK;
    BSTR bstrPath = NULL;
    WCHAR *pszADsPath = NULL;
    IADsPrintQueueOperations *pPrintQueueOps = NULL;

    hr = get_BSTR_Property(_pADs, UNCNAME, &bstrPath) ;
    BAIL_IF_ERROR(hr);

    //
    // UNCName has '\' as separators. Convert them to '/'s.
    //

    hr = ChangeSeparator(bstrPath);
    BAIL_IF_ERROR(hr);

    pszADsPath = (LPWSTR) AllocADsMem( ( wcslen(TEXT("WinNT://"))
                                       + wcslen( bstrPath + 2)
                                       + 1 ) * sizeof(WCHAR));

    if ( pszADsPath == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    wcscpy(pszADsPath, L"WinNT://");
    wcscat(pszADsPath, bstrPath+2);

    hr = ADsGetObject(
             pszADsPath,
             IID_IADsPrintQueueOperations,
             (void **)&pPrintQueueOps
             );

    BAIL_IF_ERROR(hr);

    hr = pPrintQueueOps->PrintJobs(ppCollection);

cleanup:

    if (pPrintQueueOps){
        pPrintQueueOps->Release();
    }

    if (bstrPath){
        ADsFreeString(bstrPath);
    }

    if (pszADsPath){
        FreeADsMem(pszADsPath);
    }

    RRETURN(hr);

}

//+------------------------------------------------------------------------
//
//  Function: CLDAPPrintQueue::Pause
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName
//   and attempts to pause the real printer.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//  Appropriated from Old NetOle Code.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CLDAPPrintQueue::Pause(THIS)
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;
    BSTR bstrPath = NULL ;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};

    //
    // get the 'Path' property
    //

    hr = get_BSTR_Property(this->_pADs, UNCNAME, &bstrPath) ;

    BAIL_ON_FAILURE(hr);


    //
    // use Win32 to open the printer
    //
    fStatus = OpenPrinter(
                    (LPTSTR)bstrPath,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }


    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_PAUSE);
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

error:

    if(hPrinter) {
        (void) ClosePrinter(hPrinter);
    }

    if (bstrPath) {
        ADsFreeString(bstrPath);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPPrintQueue::Resume
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName and
//              attempts to resume the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV  Created
//              Appropriated from old NetOle Project
//----------------------------------------------------------------------------


STDMETHODIMP
CLDAPPrintQueue::Resume(THIS)
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;
    BSTR bstrPath = NULL ;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};

    //
    // get the 'Path' property
    //

    hr = get_BSTR_Property(this->_pADs, UNCNAME, &bstrPath) ;

    BAIL_ON_FAILURE(hr);


    //
    // use Win32 to open the printer
    //
    fStatus = OpenPrinter(
                    (LPTSTR)bstrPath,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }


    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_RESUME);
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

error:

    if(hPrinter) {
        (void) ClosePrinter(hPrinter);
    }

    if (bstrPath) {
        ADsFreeString(bstrPath);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CLDAPPrintQueue::Purge
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to purge the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV   Created
//              Appropriated from old NetOle Code
//----------------------------------------------------------------------------


STDMETHODIMP
CLDAPPrintQueue::Purge(THIS)
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;
    BSTR bstrPath = NULL ;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};

    //
    // get the 'Path' property
    //

    hr = get_BSTR_Property(this->_pADs, UNCNAME, &bstrPath) ;

    BAIL_ON_FAILURE(hr);


    //
    // use Win32 to open the printer
    //
    fStatus = OpenPrinter(
                    (LPTSTR)bstrPath,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }


    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_PURGE);
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

error:

    if(hPrinter) {
        (void) ClosePrinter(hPrinter);
    }

    if (bstrPath) {
        ADsFreeString(bstrPath);
    }

    RRETURN(hr);
}



STDMETHODIMP
CLDAPPrintQueue::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPPrintQueue::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}





STDMETHODIMP
CLDAPPrintQueue::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}

//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPPrintQueue::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPPrintQueue::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


//  Class CLDAPUser


STDMETHODIMP CLDAPUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmailAddress );  
}

STDMETHODIMP CLDAPUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress )
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmailAddress );  
}

STDMETHODIMP CLDAPUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}

STDMETHODIMP CLDAPUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}

STDMETHODIMP CLDAPUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    // Disable this for now since NTDS stores the language ID as an integer.
    // GET_PROPERTY_VARIANT((IADsUser *)this, Languages);
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CLDAPUser::put_Languages(THIS_ VARIANT vLanguages)
{
    // Disable this for now since NTDS stores the language ID as an integer.
    // PUT_PROPERTY_VARIANT((IADsUser *)this, Languages);
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CLDAPUser::get_Profile(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CLDAPUser::put_Profile(THIS_ BSTR bstrProfile)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CLDAPUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}

STDMETHODIMP CLDAPUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\ldap2.h ===
#define LDAP_LIBIID_LDAPOle        228D9A80-C302-11cf-9AA4-00AA004A5691
#define DBGUID_LDAPDialect         83889f20-07d5-11d0-831a-00aa00b505db

#define LDAP_CLSID_LDAPProvider    228D9A81-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPNamespace   228D9A82-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPGenObject   228D9A83-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPUser        228D9A84-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPGroup       228D9A85-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPSchema      228D9A86-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPClass       228D9A87-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPProperty    228D9A88-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPSyntax      228D9A89-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPLocality    228D9A8A-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPO           228D9A8B-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPOU          228D9A8C-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPCountry     228D9A8D-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPDomain      228D9A8E-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPComputer    228D9A8F-C302-11cf-9AA4-00AA004A5691
#define LDAP_CLSID_LDAPPrintQueue  228D9A90-C302-11cf-9AA4-00AA004A5691

#define LDAP_CLSID_DSOObject       549365d0-ec26-11cf-8310-00aa00b505db
#define LDAP_CLSID_MSDATT          2dbed740-0819-11d0-831a-00aa00b505db
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cuser.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszLDAPProp;
} aUserPropMapping[] =
{
  { TEXT("BadLoginCount"), TEXT("badPwdCount") },
  { TEXT("LastLogin"), TEXT("lastLogon") },
  { TEXT("LastLogoff"), TEXT("lastLogoff") },
  { TEXT("LastFailedLogin"), TEXT("badPasswordTime") },
  { TEXT("PasswordLastChanged"), TEXT("pwdLastSet") },
  { TEXT("Description"), TEXT("description") },
  { TEXT("Division"), TEXT("division") },
  { TEXT("Department"), TEXT("department") },
  { TEXT("EmployeeID"), TEXT("employeeID") },
  { TEXT("FullName"), TEXT("displayName") },
  { TEXT("FirstName"), TEXT("givenName") },
  { TEXT("LastName"), TEXT("sn") },
  { TEXT("OtherName"), TEXT("middleName") },
  { TEXT("NamePrefix"), TEXT("personalTitle") },
  { TEXT("NameSuffix"), TEXT("generationQualifier") },
  { TEXT("Title"), TEXT("title") },
  { TEXT("Manager"), TEXT("manager") },
  { TEXT("TelephoneNumber"), TEXT("telephoneNumber") },
  { TEXT("TelephoneHome"), TEXT("homePhone") },
  { TEXT("TelephoneMobile"), TEXT("mobile") },
  { TEXT("TelephonePager"), TEXT("pager") },
  { TEXT("FaxNumber"), TEXT("facsimileTelephoneNumber") },
  { TEXT("OfficeLocations"), TEXT("physicalDeliveryOfficeName") },
  { TEXT("PostalAddresses"), TEXT("postalAddress") },
  { TEXT("PostalCodes"), TEXT("postalCode") },
  { TEXT("SeeAlso"), TEXT("seeAlso") },
  { TEXT("AccountExpirationDate"), TEXT("accountExpires") },
  { TEXT("LoginHours"), TEXT("logonHours") },
  { TEXT("LoginWorkstations"), TEXT("userWorkstations") },
  { TEXT("MaxStorage"), TEXT("maxStorage") },
  { TEXT("EmailAddress"), TEXT("mail") },
  { TEXT("HomeDirectory"), TEXT("homeDirectory") },
  { TEXT("Profile"), TEXT("profilePath") },
  { TEXT("LoginScript"), TEXT("scriptPath") },
  { TEXT("Picture"), TEXT("thumbnailPhoto") },
  { TEXT("HomePage"), TEXT("wWWHomePage") }
};

DWORD dwNumUserPropMapping = sizeof(aUserPropMapping)/sizeof(_propmap);


//  Class CLDAPUser

DEFINE_IPrivateDispatch_Implementation(CLDAPUser)

// IADsExtension::PrivateGetIDsOfNames()/Invoke(), Operate() not included
DEFINE_IADsExtension_Implementation(CLDAPUser)

DEFINE_DELEGATING_IDispatch_Implementation(CLDAPUser)
DEFINE_CONTAINED_IADs_Implementation(CLDAPUser)
DEFINE_CONTAINED_IADsPutGet_Implementation(CLDAPUser,aUserPropMapping)


CLDAPUser::CLDAPUser():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _fDispInitialized(FALSE),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CLDAPUser);
}

HRESULT
CLDAPUser::CreateUser(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{

    HRESULT hr = S_OK;
    CLDAPUser FAR * pUser = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;


    //
    // our extension object only works in a provider (aggregator) environment
    // environment
    //

    ASSERT(pUnkOuter);
    ASSERT(ppvObj);
    ASSERT(IsEqualIID(riid, IID_IUnknown));


    pUser = new CLDAPUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Ref Count = 1 from object tracker
    //

    //
    // CAggregateeDispMgr to handle
    // IADsExtension::PrivateGetIDsOfNames()/PrivatInovke()
    //

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pUser->_pDispMgr = pDispMgr;

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsUser,
                (IADsUser *)pUser,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    //
    // Store the pointer to the pUnkOuter object to delegate all IUnknown
    // calls to the aggregator AND DO NOT add ref this pointer
    //
    pUser->_pUnkOuter = pUnkOuter;


    //
    // Ccache pADs Pointer to delegate all IDispatch calls to
    // the aggregator. But release immediately to avoid the aggregatee
    // having a reference count on the aggregator -> cycle ref counting
    //

    hr = pUnkOuter->QueryInterface(
                IID_IADs,
                (void **)&pADs
                );

    //
    // Our spec stated extesnion writers can expect the aggregator in our
    // provider ot support IDispatch. If not, major bug.
    //

    ASSERT(SUCCEEDED(hr));
    pADs->Release();            // see doc above pUnkOuter->QI
    pUser->_pADs = pADs;


    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pUser;


    RRETURN(hr);


error:

    //
    // do NOT clean up dispMgr here. Iff created, cleaned up Once inside pUser
    //

    if (pUser)
        delete  pUser;

    *ppvObj = NULL;

    RRETURN(hr);

}



STDMETHODIMP
CLDAPUser::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


CLDAPUser::~CLDAPUser( )
{
    //
    // Remember that the aggregatee has no reference counts to
    // decrement.
    //

    delete _pDispMgr;

}


STDMETHODIMP
CLDAPUser::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);

}


STDMETHODIMP
CLDAPUser::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IADsUser)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IADsUser.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}


STDMETHODIMP
CLDAPUser::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }


    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);


    if (SUCCEEDED(hr)) {

        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CLDAPUser::ADSIReleaseObject()
{
    delete this;

    RRETURN(S_OK);
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CLDAPUser::Operate(
    THIS_ DWORD dwCode,
    VARIANT varData1,
    VARIANT varData2,
    VARIANT varData3
    )
{
    HRESULT hr = S_OK;

    switch (dwCode) {

    case ADS_EXT_INITCREDENTIALS:

        hr = InitCredentials(
                &varData1,
                &varData2,
                &varData3
                );
        break;

    default:

        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
CLDAPUser::InitCredentials(
    VARIANT * pvarUserName,
    VARIANT * pvarPassword,
    VARIANT * pvarFlags
    )
{

        BSTR bstrUser = NULL;
        BSTR bstrPwd = NULL;
        DWORD dwFlags = 0;

        ASSERT(V_VT(pvarUserName) == VT_BSTR);
        ASSERT(V_VT(pvarPassword) == VT_BSTR);
        ASSERT(V_VT(pvarFlags) == VT_I4);

        bstrUser = V_BSTR(pvarUserName);
        bstrPwd = V_BSTR(pvarPassword);
        dwFlags = V_I4(pvarFlags);

        CCredentials NewCredentials(bstrUser, bstrPwd, dwFlags);
        _Credentials = NewCredentials;


       RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cUser.cxx
//
//  Contents:  User object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

//  Class CLDAPUserCollection

DEFINE_IDispatch_Implementation(CLDAPUserCollection)


CLDAPUserCollection::CLDAPUserCollection():
    _ADsPath(NULL),
    _pDispMgr(NULL)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CLDAPUserCollection);
}

HRESULT
CLDAPUserCollection::CreateUserCollection(
    BSTR bstrADsPath,
    VARIANT varMembers,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CLDAPUserCollection FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserCollectionObject(Credentials, &pUser);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(bstrADsPath, &(pUser->_ADsPath));
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&(pUser->_vMembers), &varMembers);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:

    *ppvObj = NULL;
    delete pUser;
    RRETURN(hr);

}

CLDAPUserCollection::~CLDAPUserCollection( )
{
    VariantClear(&_vMembers);
    VariantClear(&_vFilter);

    if ( _ADsPath )
        ADsFreeString( _ADsPath );

    delete _pDispMgr;
}

STDMETHODIMP
CLDAPUserCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
	RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CLDAPUserCollection::InterfaceSupportsErrorInfo(THIS_ REFIID riid) 
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CLDAPUserCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CLDAPUserCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPUserCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CLDAPUserCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CLDAPUserCollectionEnum::Create(
                _ADsPath,
                (CLDAPUserCollectionEnum **)&penum,
                _vMembers,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CLDAPUserCollection::AllocateUserCollectionObject(
    CCredentials& Credentials,
    CLDAPUserCollection ** ppUser
    )
{
    CLDAPUserCollection FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pUser = new CLDAPUserCollection();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pUser,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pUser->_Credentials = Credentials;
    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    *ppUser = NULL;
    delete  pDispMgr;
    delete  pUser;

    RRETURN_EXP_IF_ERR(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\ldapres.h ===
#define LDAP_PROVIDER_ID 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\cusercf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  LDAP User Object Class Factory Code
//
//             CLDAPUserCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPUserCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPUserCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    // 
    // our extension object only works with an aggregator in the provider
    //
    if (!pUnkOuter)
        RRETURN(E_FAIL);

    if (IsEqualIID(iid, IID_IUnknown)==FALSE) 
        RRETURN(E_INVALIDARG);

    hr = CLDAPUser::CreateUser(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))

#define PUT_PROPERTY_FILETIME(this, Property) \
                HRESULT tmphr; \
                tmphr = put_FILETIME_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_FILETIME(this, Property) \
                HRESULT tmphr; \
                tmphr = get_FILETIME_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))

#define PUT_PROPERTY_LONGDATE(this, Property) \
                RRETURN(put_DATE_Property_ToLong( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_LONGDATE(this, Property) \
                RRETURN(get_DATE_Property_FromLong(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))

#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))

#define PUT_PROPERTY_BSTRARRAY(this, Property) \
                RRETURN(put_BSTRARRAY_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_BSTRARRAY(this, Property) \
                RRETURN(get_BSTRARRAY_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  ADSI MSExtensions CLSIDs
//
//--------------------------------------------------------------------------

const IID LIBID_ADSMSExtensions = {0x8d6b2714,0x5ef9,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_MSExtUser = {0x4de7016c,0x5ef9,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtOrganization = {0xdccc0bed,0x6066,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtOrganizationUnit = {0xfd8d3a5f,0x6066,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtLocality = {0x2dfb3a35,0x6071,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtPrintQueue = {0x9f37f39c,0x6f49,0x11d1,{0x8c,0x18,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_MSExtGroup = {0x94a909a5,0x6f52,0x11d1,{0x8c,0x18,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for LDAP guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// LDAPOle CLSIDs
//
//-------------------------------------------


//
// LDAPOle objects
//

extern const IID LIBID_ADSMSExtensions;


extern const CLSID CLSID_MSExtUser;

extern const CLSID CLSID_MSExtOrganization;

extern const CLSID CLSID_MSExtOrganizationUnit;

extern const CLSID CLSID_MSExtLocality;

extern const CLSID CLSID_MSExtPrintQueue;

extern const CLSID CLSID_MSExtGroup;


#ifdef __cplusplus
}
#endif


#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HINSTANCE g_hInst = NULL;

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

CLDAPUserCF g_cfUser;
CLDAPOrganizationCF g_cfOrganization;
CLDAPOrganizationUnitCF g_cfOrganizationUnit;
CLDAPLocalityCF     g_cfLocality;
CLDAPPrintQueueCF   g_cfPrintQueue;
CLDAPGroupCF        g_cfGroup;

extern CRITICAL_SECTION g_ExtTypeInfoCritSect;
extern CRITICAL_SECTION g_DispTypeInfoCritSect;
extern CRITICAL_SECTION g_ServerListCritSect;
//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    TCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(TEXT("LDAP"),TEXT("heapInfoLevel"), TEXT("00000003"), awcs,MAXINFOLEN))
        heapInfoLevel = _tcstoul(awcs, NULL, 16);

    if (GetProfileString(TEXT("LDAP"),TEXT("Ot"), TEXT("00000003"), awcs, MAXINFOLEN))
        OtInfoLevel = _tcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(TEXT("LDAP"),TEXT("ADsInfoLevel"), TEXT("00000003"), awcs,MAXINFOLEN))
        ADsInfoLevel = _tcstoul(awcs, NULL, 16);
#endif
}

//  Globals

ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll

//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};

CLSCACHE g_aclscache[] =
{
    &CLSID_MSExtUser,                           &g_cfUser,
    &CLSID_MSExtOrganization,                   &g_cfOrganization,
    &CLSID_MSExtOrganizationUnit,               &g_cfOrganizationUnit,
    &CLSID_MSExtLocality,                       &g_cfLocality,
    &CLSID_MSExtPrintQueue,                     &g_cfPrintQueue,
    &CLSID_MSExtGroup,                          &g_cfGroup
};







//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;


    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (AggregateeDllCanUnload() && DllReadyToUnload()) {
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Catch init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif

            InitializeCriticalSection(&g_ExtTypeInfoCritSect);
            InitializeCriticalSection(&g_DispTypeInfoCritSect);
            InitializeCriticalSection(&g_ServerListCritSect);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical Failure
            //
            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:
        AggregateeFreeTypeInfoTable();
        FreeServerSSLSupportList();

        //
        // Delete the critsects.
#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT);
        DeleteCriticalSection(&g_csMem);
#endif
        DeleteCriticalSection(&g_csDP);
#endif

        DeleteCriticalSection(&g_ExtTypeInfoCritSect);
        DeleteCriticalSection(&g_DispTypeInfoCritSect);
        DeleteCriticalSection(&g_ServerListCritSect);

        if (g_hDllSecur32) {
            FreeLibrary((HMODULE)g_hDllSecur32);
            g_hDllSecur32 = NULL;
        }

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:  
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

TCHAR *szProviderName = TEXT("LDAP");
TCHAR *szLDAPNamespaceName = TEXT("LDAP");
TCHAR *szGCNamespaceName = TEXT("GC");

//
// Support routines for dynamically loading functions.
//
BOOL   g_fDllsLoaded = FALSE;
extern HANDLE g_hDllSecur32 = NULL;
//
// Loads all the dynamic libs we need.
//
void BindToDlls()
{
    DWORD dwErr = 0;

    if (g_fDllsLoaded) {
        return;
    }

    ENTER_SERVERLIST_CRITICAL_SECTION();
    if (g_fDllsLoaded) {
        LEAVE_SERVERLIST_CRITICAL_SECTION();
        return;
    }

    g_hDllSecur32 = LoadLibrary(L"SECUR32.DLL");

    g_fDllsLoaded = TRUE;
    LEAVE_SERVERLIST_CRITICAL_SECTION();

    return;
}

//
// Loads the appropriate secur32 fn.
//
PVOID LoadSecur32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllSecur32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllSecur32, function));
    }

    return NULL;
}

//
// QueryContextAttributesWrapper.
//
SECURITY_STATUS
AcquireCredentialsHandleWrapper(
#if ISSP_MODE == 0                      // For Kernel mode
    PSECURITY_STRING pPrincipal,
    PSECURITY_STRING pPackage,
#else
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
#endif
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    static PF_AcquireCredentialsHandleW pfAcquireCred = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfAcquireCred == NULL) {
        pfAcquireCred = (PF_AcquireCredentialsHandleW)
                            LoadSecur32Function(ACQUIRECREDENTIALSHANDLE_API);
        f_LoadAttempted = TRUE;
    }

    if (pfAcquireCred != NULL) {
        return ((*pfAcquireCred)(
#if ISSP_MODE == 0                      // For Kernel mode
                      pPrincipal,
                      pPackage,
#else
                      pszPrincipal,   // Name of principal
                      pszPackage,     // Name of package
#endif
                      fCredentialUse,      // Flags indicating use
                      pvLogonId,           // Pointer to logon ID
                      pAuthData,           // Package specific data
                      pGetKeyFn,           // Pointer to GetKey() func
                      pvGetKeyArgument,    // Value to pass to GetKey()
                      phCredential,        // (out) Cred Handle
                      ptsExpiry            // (out) Lifetime (optional)

                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }
}


SECURITY_STATUS
FreeCredentialsHandleWrapper(
    PCredHandle phCredential            // Handle to free
    )
{
    static PF_FreeCredentialsHandle pfFreeCredHandle = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfFreeCredHandle == NULL) {
        pfFreeCredHandle = (PF_FreeCredentialsHandle)
                              LoadSecur32Function(FREECREDENTIALSHANDLE_API);
        f_LoadAttempted = TRUE;
    }

    if (pfFreeCredHandle != NULL) {
        return ((*pfFreeCredHandle)(
                       phCredential
                       )
                );
    }
    else {
        return (ERROR_GEN_FAILURE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}


#define DEFINE_IPrivateDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::ADSIGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIInvoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


#define DEFINE_IADsExtension_Implementation(cls)                        \
STDMETHODIMP                                                            \
cls::PrivateGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,            \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)           \
{                                                                       \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                           \
                                         rgszNames,                     \
                                         cNames,                        \
                                         lcid,                          \
                                         rgdispid                       \
                                         ));                            \
}                                                                       \
                                                                        \
STDMETHODIMP                                                            \
cls::PrivateInvoke(DISPID dispidMember, REFIID iid, LCID lcid,          \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,             \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,             \
        unsigned int FAR* puArgErr)                                     \
{                                                                       \
        RRETURN (_pDispMgr->Invoke(dispidMember,                        \
                                   iid,                                 \
                                   lcid,                                \
                                   wFlags,                              \
                                   pdispparams,                         \
                                   pvarResult,                          \
                                   pexcepinfo,                          \
                                   puArgErr                             \
                                   ));                                  \
}


#define DEFINE_DELEGATING_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pADs->GetTypeInfo(itinfo,                            \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pADs->GetIDsOfNames(iid,                             \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pADs->Invoke(dispidMember,                          \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "ldap.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    // if actually the filter is not specified, we don't do anything
    if (V_VT(&vFilter) == VT_EMPTY) {
    	*ppObjectTypeList = pObjectTypeList;
    	RRETURN(hr);
    }

    
    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {
        *ppObjectTypeList = pObjectTypeList;
        RRETURN(S_OK);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    BSTR* pszObject
    )
{
    HRESULT hr = S_OK;

    if ((_dwCurrentIndex > _dwUBound) || (_pObjList == NULL)) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pszObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex = _dwLBound;

    return(hr);

}

BOOL
ObjectTypeList::IsEmpty()
{
    if(_dwMaxElements > 0) {
    	return FALSE;
    }
    else{
    	return TRUE;
    }
    	
}


HRESULT
IsValidFilter(
    LPTSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_tcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    // creates a safe array filter (contains object class name)
    pFilter = SafeArrayCreate(
                    VT_BSTR,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }

  
        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                V_BSTR(&v)
                );

        VariantClear(&v);

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\property.cxx ===
#include "ldap.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);


static HRESULT
PackAccountExpirationDateinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    );

static HRESULT
UnpackAccountExpirationDatefromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    );

// This is the date used in AccountExpirationDate property to specify that the
// account never expires
//
static FILETIME g_Date_1_1_1970 = { 0xd53e8000, 0x019db1de };

// This is the value actually returned by the server
//
static FILETIME g_Date_Never = { 0xffffffff, 0x7fffffff };

HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_FILETIME_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    if (_wcsicmp(bstrPropertyName,  L"accountExpirationDate") == 0 ) {

        hr = PackAccountExpirationDateinVariant(
                daSrcProperty,
                &varInputData
                );
    } 
    else {

        hr = PackFILETIMEinVariant(
                daSrcProperty,
                &varInputData
                );
    }
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_FILETIME_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    // Special case for Account Expiration Date
    //
    if (_wcsicmp (bstrPropertyName, L"accountExpirationDate") == 0) {

        hr = UnpackAccountExpirationDatefromVariant(
                varOutputData,
                pdaDestProperty
                );
    }
    else {

        hr = UnpackFILETIMEfromVariant(
                varOutputData,
                pdaDestProperty
                );
    }

    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_BSTRARRAY_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    LPWSTR* rgszArray = NULL;
    SAFEARRAY * pArray = NULL;
    DWORD dwSize = 0;
    LPWSTR szValue = NULL;

    if(!((V_VT(&vSrcProperty) & VT_VARIANT) && V_ISARRAY(&vSrcProperty)))
        return(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(&vSrcProperty) & VT_BYREF)
        pArray = *(V_ARRAYREF(&vSrcProperty));
    else
        pArray = V_ARRAY(&vSrcProperty);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;

    //
    // Get Size
    //
    if ((V_VT(&vSrcProperty) & VT_VARIANT) == VT_BSTR) {
        BSTR bstrElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &bstrElement
                                    );
            BAIL_ON_FAILURE(hr);

            dwSize += (wcslen(bstrElement)+1);
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        VARIANT varElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            VariantInit(&varElement);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &varElement
                                    );
            BAIL_ON_FAILURE(hr);

            dwSize += (wcslen(V_BSTR(&varElement))+1);
            BAIL_ON_FAILURE(hr);
            VariantClear(&varElement);
        }
    }

    szValue = (LPWSTR)AllocADsMem(sizeof(WCHAR) * (dwSize + 1));
    if (!szValue) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
        szValue[0] = '\0';

    //
    // Put in String
    //
    if ((V_VT(&vSrcProperty) & VT_VARIANT) == VT_BSTR) {
        BSTR bstrElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &bstrElement
                                    );
            BAIL_ON_FAILURE(hr);

            wcscat(szValue,bstrElement);
            if (i!=dwSUBound) {
                wcscat(szValue,L",");
            }
        }
    }
    else {
        VARIANT varElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            VariantInit(&varElement);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &varElement
                                    );
            BAIL_ON_FAILURE(hr);

            wcscat(szValue,V_BSTR(&varElement));
            if (i!=dwSUBound) {
                wcscat(szValue,L",");
            }
            VariantClear(&varElement);
        }
    }

    VariantInit(&varInputData);
    varInputData.vt = VT_BSTR;
    hr = ADsAllocString(
            szValue,
            &varInputData.bstrVal
            );
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    if (szValue) {
        FreeADsMem(szValue);
    }

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTRARRAY_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;
    LPWSTR szString = NULL;
    LPWSTR szValue = NULL;
    DWORD dwCount = 1;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    szString = varOutputData.bstrVal;
    if (!szString) {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }

    while (szString = wcschr(szString,',')) {
        szString++;
        dwCount++;      
    }

    VariantInit(pvDestProperty);

    aBound.lLbound = 0;
    aBound.cElements = dwCount;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    szString = varOutputData.bstrVal;
    szValue = wcstok(szString,L",");
    for (i=0;i<(long)dwCount;i++) {
        VARIANT v;
        VariantInit(&v);
        
        if (!szValue) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        v.vt = VT_BSTR;
        hr = ADsAllocString(
                szValue,
                &v.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v);
        BAIL_ON_FAILURE(hr);
        VariantClear(&v);
        szValue = wcstok(NULL,L",");
    }

    V_VT(pvDestProperty) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvDestProperty) = aList;


    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_DATE_Property_ToLong(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinLONGVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_DATE_Property_FromLong(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    //
    // the Variant returned is expected to be a DWORD
    //

    hr = UnpackDATEfromLONGVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}


// 
// The following functions are very similar to the PackFILETIMEinVariant and 
// UnpackFILETIMEfromVariant in ..\utils\pack.cxx except for a special casing of 
// 1/1/1970. This date is meant to indicate that the account never expires. The date
// is used both for put and get. 
//

HRESULT
PackAccountExpirationDateinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    IADsLargeInteger *pTime = NULL;
    VARIANT var;
    SYSTEMTIME systemtime;
    FILETIME filetime;
    HRESULT hr = S_OK;

    if (VariantTimeToSystemTime(daValue,
                                &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    if (SystemTimeToFileTime(&systemtime,
                             &filetime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (filetime.dwLowDateTime == g_Date_1_1_1970.dwLowDateTime &&
        filetime.dwHighDateTime == g_Date_1_1_1970.dwHighDateTime) {

        filetime = g_Date_Never;
    }
    else {

        if (LocalFileTimeToFileTime(&filetime, &filetime ) == 0) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = CoCreateInstance(
                CLSID_LargeInteger,
                NULL,
                CLSCTX_ALL,
                IID_IADsLargeInteger,
                (void**)&pTime
                );
    BAIL_ON_FAILURE(hr);
    
    hr = pTime->put_HighPart(filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);
    hr = pTime->put_LowPart(filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarInputData);
    pvarInputData->pdispVal = pTime;
    pvarInputData->vt = VT_DISPATCH;

error:
    return hr;
}

HRESULT
UnpackAccountExpirationDatefromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    IADsLargeInteger *pLarge = NULL;
    IDispatch *pDispatch = NULL;
    FILETIME filetime;
    SYSTEMTIME systemtime;
    DATE date;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_DISPATCH){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pDispatch = varSrcData.pdispVal;
    hr = pDispatch->QueryInterface(IID_IADsLargeInteger, (VOID **) &pLarge);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_HighPart((long*)&filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_LowPart((long*)&filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    // Treat this as special case and return 1/1/1970 (don't localize either)
    //
    if (filetime.dwLowDateTime == g_Date_Never.dwLowDateTime &&
        filetime.dwHighDateTime == g_Date_Never.dwHighDateTime) {

        filetime = g_Date_1_1_1970;
    }
    else {

        if (FileTimeToLocalFileTime(&filetime, &filetime) == 0) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (FileTimeToSystemTime(&filetime,
                             &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (SystemTimeToVariantTime(&systemtime,
                                &date) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *pdaValue = date;

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\msext\types\header.h ===
#define MSEXT_LIBIID_ADsMSExt                8d6b2714-5ef9-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtUser                4de7016c-5ef9-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtOrganization        dccc0bed-6066-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtOrganizationUnit    fd8d3a5f-6066-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtLocality            2dfb3a35-6071-11d1-8c13-00c04fd8d503
#define MSEXT_CLSID_MSExtPrintQueue          9f37f39c-6f49-11d1-8c18-00c04fd8d503
#define MSEXT_CLSID_MSExtGroup               94a909a5-6f52-11d1-8c18-00c04fd8d503


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cdssch.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssch.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


static WCHAR gszObjClassAttr[] = L"Object Class";
static WCHAR gszNameAttr[] = L"cn";


HRESULT
CNDSGenObject::EnumAttributes(
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    LPWSTR pszNDSPath = NULL;
    DWORD dwStatus;
    HRESULT hr = S_OK;
    DWORD dwNumberOfEntries;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    HANDLE hConnection = NULL, hOperationData = NULL;
    DWORD i,j,k;

    DWORD dwMemSize = 0;

    LPBYTE pBuffer = NULL;
    LPWSTR pszNameEntry = NULL;
    PADS_ATTR_DEF pAttrDefEntry = NULL;

    if ( !ppAttrDefinition || !pdwNumAttributes ||
        (((LONG)dwNumAttributes) < 0 && ((LONG)dwNumAttributes) != -1) ) {
        RRETURN (E_INVALIDARG);
    }

    *ppAttrDefinition = NULL;
    *pdwNumAttributes = NULL;

    //
    // Allocate memory for pszNDSPath before calling BuildNDSTreeNameFromADsPath
    // Allocating ADsPath is safe as the tree name is always less.
    //

    pszNDSPath = AllocADsStr(_ADsPath);
    if (!pszNDSPath)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = BuildNDSTreeNameFromADsPath(
             _ADsPath,
             pszNDSPath
             );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsOpenObject(
                          pszNDSPath,
                          NULL,
                          NULL,
                          &hConnection,
                          NULL,
                          NULL,
                          NULL,
                          0,
                          0
                          );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (dwNumAttributes != (DWORD)-1) {

        dwStatus = NwNdsCreateBuffer(
                           NDS_SCHEMA_READ_ATTR_DEF,
                           &hOperationData
                           );
        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

        for (i=0; i < dwNumAttributes; i++) {
            dwStatus = NwNdsPutInBuffer(
                               ppszAttrNames[i],
                               0,
                               NULL,
                               0,
                               0,
                               hOperationData
                               );
            CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        }
    }
    else {

        //
        // Tell the server to give us back all the attributes
        //

        hOperationData = NULL;

    }

    dwStatus = NwNdsReadAttrDef(
                        hConnection,
                        NDS_INFO_NAMES_DEFS,
                        &hOperationData
                        );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetAttrDefListFromBuffer(
                   hOperationData,
                   &dwNumberOfEntries,
                   &dwInfoType,
                   (LPVOID *) &lpAttrDefs
                   );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (dwInfoType != NDS_INFO_NAMES_DEFS )
        BAIL_ON_FAILURE( hr = E_FAIL );

    //
    // Now package this data into a single contiguous buffer
    //

    hr =  ComputeADsAttrDefBufferSize(
                lpAttrDefs,
                dwNumberOfEntries,
                &dwMemSize
                );
    BAIL_ON_FAILURE(hr);


    pBuffer = (LPBYTE) AllocADsMem(dwMemSize);

    if (!pBuffer)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    pAttrDefEntry = (PADS_ATTR_DEF) pBuffer;
    pszNameEntry = (LPWSTR) (pBuffer + dwNumberOfEntries * sizeof(ADS_ATTR_DEF));

    for (j = 0; j < dwNumberOfEntries ; j++ ) {

        if (lpAttrDefs[j].dwSyntaxID >= g_cMapNdsTypeToADsType)
            pAttrDefEntry->dwADsType = ADSTYPE_INVALID;
        else
            pAttrDefEntry->dwADsType = g_MapNdsTypeToADsType[lpAttrDefs[j].dwSyntaxID];

        pAttrDefEntry->dwMinRange = lpAttrDefs[j].dwLowerLimit;

        pAttrDefEntry->dwMaxRange = lpAttrDefs[j].dwUpperLimit;

        pAttrDefEntry->fMultiValued = !(lpAttrDefs[j].dwFlags & NDS_SINGLE_VALUED_ATTR);

        wcscpy(pszNameEntry, lpAttrDefs[j].szAttributeName);
        pAttrDefEntry->pszAttrName = pszNameEntry;

        pszNameEntry += wcslen(lpAttrDefs[j].szAttributeName) + 1;
        pAttrDefEntry ++;
    }


    *ppAttrDefinition = (PADS_ATTR_DEF) pBuffer;
    *pdwNumAttributes = dwNumberOfEntries;


error:
    if (pszNDSPath)
        FreeADsStr(pszNDSPath);

    if (hOperationData)
        NwNdsFreeBuffer( hOperationData );

    if (hConnection)
        NwNdsCloseObject( hConnection);
    RRETURN(hr);
}


HRESULT
CNDSGenObject::CreateAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::WriteAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    RRETURN (E_NOTIMPL);
}

HRESULT
CNDSGenObject::DeleteAttributeDefinition(
    LPWSTR pszAttributeName
    )
{
    RRETURN (E_NOTIMPL);
}


HRESULT
ComputeADsAttrDefBufferSize(
    LPNDS_ATTR_DEF pAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize
    )
{
    DWORD i = 0;
    DWORD dwSize = 0;

    dwSize = sizeof(ADS_ATTR_DEF) * dwNumAttributes;

    for (i = 0; i < dwNumAttributes; i++)
        dwSize += (wcslen(pAttributes[i].szAttributeName) + 1)*sizeof(WCHAR);

    *pdwSize = dwSize;

    RRETURN(S_OK);
}


HRESULT
CNDSGenObject::DeleteClassDefinition(
    LPWSTR pszClassName
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CNDSGenObject::CreateClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
   RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::WriteClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
   RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::EnumClasses(
    LPWSTR *ppszClassNames,
    DWORD dwNumClasses,
    PADS_CLASS_DEF *ppClassDefinition,
    DWORD *pdwNumClasses
    )
{
   RRETURN(E_NOTIMPL);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cdsobj.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-10-97     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
CNDSGenObject::SetObjectAttributes(
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    )
{
    HRESULT hr = S_OK;
    BYTE lpBuffer[2048];
    WCHAR *pszNDSPathName = NULL ;

    HANDLE hObject = NULL;
    HANDLE hOperationData = NULL;


    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    DWORD dwStatus = 0;
    PNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumNdsValues = 0;
    DWORD dwSyntaxId = 0;
    DWORD dwNumNDSAttributeReturn = 0;

    *pdwNumAttributesModified = 0;
    
    if (dwNumAttributes <= 0) {

        RRETURN(E_FAIL);
    }


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_MODIFY,
                        &hOperationData
                        );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAttributeEntries + i;

        switch (pThisAttribute->dwControlCode) {        
        
        case ADS_ATTR_UPDATE:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = MarshallNDSSynIdToNDS(                              
                           dwSyntaxId,                                  
                           pNdsDestObjects,                             
                           dwNumNdsValues,                              
                           lpBuffer                                     
                           );                                           
                                                                        
                                                                        
               dwStatus = NwNdsPutInBuffer(                             
                               pThisAttribute->pszAttrName,             
                               dwSyntaxId,                              
                               NULL,                                    
                               0,                                       
                               NDS_ATTR_CLEAR,                          
                               hOperationData                           
                               );                                       
                                                                        
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);              
                                                                        
                                                                        
               dwStatus = NwNdsPutInBuffer(                             
                               pThisAttribute->pszAttrName,             
                               dwSyntaxId,                              
                               lpBuffer,                                
                               dwNumNdsValues,                          
                               NDS_ATTR_ADD,                            
                               hOperationData                           
                               );                                       
                                                                        
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);              
               
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_APPEND:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = MarshallNDSSynIdToNDS(                              
                           dwSyntaxId,                                  
                           pNdsDestObjects,                             
                           dwNumNdsValues,                              
                           lpBuffer                                     
                           );                                           
                                                                        
               dwStatus = NwNdsPutInBuffer(                             
                               pThisAttribute->pszAttrName,             
                               dwSyntaxId,                              
                               lpBuffer,                                
                               dwNumNdsValues,                          
                               NDS_ATTR_ADD_VALUE,                            
                               hOperationData                           
                               );                                       
                                                                        
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);              
               
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_DELETE:                           
               hr = AdsTypeToNdsTypeCopyConstruct(                      
                           pThisAttribute->pADsValues,                  
                           pThisAttribute->dwNumValues,                 
                           &pNdsDestObjects,                            
                           &dwNumNdsValues,                             
                           &dwSyntaxId                                  
                           );                                           
               CONTINUE_ON_FAILURE(hr);                                 
                                                                        
               hr = MarshallNDSSynIdToNDS(                              
                           dwSyntaxId,                                  
                           pNdsDestObjects,                             
                           dwNumNdsValues,                              
                           lpBuffer                                     
                           );                                           
                                                                        
               dwStatus = NwNdsPutInBuffer(                             
                               pThisAttribute->pszAttrName,             
                               dwSyntaxId,                              
                               lpBuffer,                                
                               dwNumNdsValues,                          
                               NDS_ATTR_REMOVE_VALUE,                            
                               hOperationData                           
                               );                                       
                                                                        
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);              
               
               dwNumNDSAttributeReturn++; 
               break;

        case ADS_ATTR_CLEAR:
               dwStatus = NwNdsPutInBuffer(                              
                               pThisAttribute->pszAttrName,              
                               dwSyntaxId,                               
                               NULL,                                     
                               0,                                        
                               NDS_ATTR_CLEAR,                           
                               hOperationData                            
                               );                                        
                                                                         
               CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);               
               dwNumNDSAttributeReturn++; 
               break;


        default:

            //
            // Ignore this attribute and move on.
            //
            break;



        }
        
        if (pNdsDestObjects) {
            FreeMarshallMemory(
              dwSyntaxId,
              dwNumNdsValues,
              lpBuffer
              );
    
            NdsTypeFreeNdsObjects(
               pNdsDestObjects,
               dwNumNdsValues
               );
            pNdsDestObjects = NULL;
        }

    }

    dwStatus = NwNdsModifyObject(
                    hObject,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    *pdwNumAttributesModified = dwNumNDSAttributeReturn;
error:

    if (pNdsDestObjects) {

       FreeMarshallMemory(
              dwSyntaxId,                                  
              dwNumNdsValues,                              
              lpBuffer                                     
              );

       NdsTypeFreeNdsObjects(                     
               pNdsDestObjects, 
               dwNumNdsValues
               );
      }


    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    if (pszNDSPathName) {

        (void) FreeADsStr(pszNDSPathName) ;
    }

    RRETURN(hr);

}


HRESULT
CNDSGenObject::GetObjectAttributes(
    LPWSTR * pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    )
{
    HRESULT hr = S_OK;
    BYTE lpBuffer[2048];
    WCHAR *pszNDSPathName = NULL ;
    DWORD i = 0;
    HANDLE hOperationData = NULL;
    PNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNdsSyntaxId = 0;
    DWORD dwNumValues = 0;

    DWORD dwStatus = 0;
    HANDLE hObject = NULL;
    LPWSTR * pThisAttributeName = NULL;

    PADS_ATTR_INFO pAdsAttributes = NULL;
    PADS_ATTR_INFO pThisAttributeDef = NULL;
    DWORD dwAttrCount = 0;

    DWORD dwNumberOfEntries = 0;
    LPNDS_ATTR_INFO lpEntries = NULL;

    PNDSOBJECT pNdsObject = NULL;
    PADSVALUE pAdsDestValues = NULL;


    DWORD j = 0;

    PADS_ATTR_INFO pThisAdsSrcAttribute = NULL;
    PADS_ATTR_INFO pThisAdsTargAttribute = NULL;

    PADS_ATTR_INFO pAttrEntry = NULL;
    PADSVALUE pAttrValue  = NULL;

    DWORD dwMemSize = 0;

    LPBYTE pAttributeBuffer = NULL;
    LPBYTE pValueBuffer = NULL;
    LPBYTE pDataBuffer = NULL;

    PADSVALUE pThisAdsSrcValue = NULL;

    PADSVALUE pThisAdsTargValue = NULL;
    DWORD dwTotalValues = 0;


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (dwNumberAttributes != (DWORD)-1) {

        //
        // Package attributes into NDS structure
        //

        dwStatus = NwNdsCreateBuffer(
                            NDS_OBJECT_READ,
                            &hOperationData
                            );
        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

        for (i = 0; i < dwNumberAttributes; i++) {

            pThisAttributeName = pAttributeNames + i;

            dwStatus = NwNdsPutInBuffer(
                               *pThisAttributeName,
                               NULL,
                               NULL,
                               0,
                               0,
                               hOperationData
                               );
            CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        }
    }else {

        //
        // Tell the server to give us back whatever it has
        //

        hOperationData = NULL;

    }

    //
    // Read the DS Object
    //

    dwStatus = NwNdsReadObject(
                    hObject,
                    1,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    //
    // Compute the number of attributes in the
    // read buffer.
    //

    dwStatus = NwNdsGetAttrListFromBuffer(
                    hOperationData,
                    &dwNumberOfEntries,
                    &lpEntries
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    //
    // Allocate an attribute buffer which is as large as the
    // number of attributes present
    //
    //

    pAdsAttributes = (PADS_ATTR_INFO)AllocADsMem(
                           sizeof(ADS_ATTR_INFO)*dwNumberOfEntries
                           );
    if (!pAdsAttributes){

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);

    }


    for (i = 0; i < dwNumberOfEntries; i++) {

        pThisAttributeDef = pAdsAttributes + dwAttrCount;

        hr = UnMarshallNDSToNDSSynId(
                    lpEntries[i].dwSyntaxId,
                    lpEntries[i].dwNumberOfValues,
                    lpEntries[i].lpValue,
                    &pNdsObject
                    );
        CONTINUE_ON_FAILURE(hr);

        dwNumValues = lpEntries[i].dwNumberOfValues;

        hr = NdsTypeToAdsTypeCopyConstruct(
                    pNdsObject,
                    dwNumValues,
                    &pAdsDestValues
                    );
        if (FAILED(hr)){
            if (pNdsObject) {
                NdsTypeFreeNdsObjects(pNdsObject, dwNumValues);
            }
            continue;
        }

        pThisAttributeDef->pszAttrName =
                AllocADsStr(lpEntries[i].szAttributeName);

        pThisAttributeDef->pADsValues = pAdsDestValues;

        pThisAttributeDef->dwNumValues = dwNumValues;


        pThisAttributeDef->dwADsType  = g_MapNdsTypeToADsType[lpEntries[i].dwSyntaxId];

        if (pNdsObject) {
            NdsTypeFreeNdsObjects(pNdsObject, dwNumValues);
        }

        dwAttrCount++;


    }

    //
    // Now package this data into a single contiguous buffer
    //

    hr =  ComputeAttributeBufferSize(
                pAdsAttributes,
                dwAttrCount,
                &dwMemSize
                );
    BAIL_ON_FAILURE(hr);

    hr = ComputeNumberofValues(
                pAdsAttributes,
                dwAttrCount,
                &dwTotalValues
                );
    BAIL_ON_FAILURE(hr);


    pAttributeBuffer = (LPBYTE)AllocADsMem(dwMemSize);

    if (!pAttributeBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pValueBuffer = pAttributeBuffer + dwAttrCount * (sizeof(ADS_ATTR_INFO));

    pDataBuffer = pValueBuffer + dwTotalValues * sizeof(ADSVALUE);

    pAttrEntry = (PADS_ATTR_INFO)pAttributeBuffer;

    pAttrValue  = (PADSVALUE)pValueBuffer;

    for (i = 0; i < dwAttrCount; i++) {

        pThisAdsSrcAttribute = pAdsAttributes + i;

        pThisAdsTargAttribute = pAttrEntry + i;

        pThisAdsTargAttribute->pADsValues = pAttrValue;

        pThisAdsTargAttribute->dwNumValues = pThisAdsSrcAttribute->dwNumValues;

        pThisAdsTargAttribute->dwADsType = pThisAdsSrcAttribute->dwADsType;

        dwNumValues = pThisAdsSrcAttribute->dwNumValues;

        pThisAdsSrcValue = pThisAdsSrcAttribute->pADsValues;

        pThisAdsTargValue = pAttrValue;

        for (j = 0; j < dwNumValues; j++) {

            pDataBuffer = AdsTypeCopy(
                                pThisAdsSrcValue,
                                pThisAdsTargValue,
                                pDataBuffer
                                );
            pAttrValue++;
            pThisAdsTargValue = pAttrValue;
            pThisAdsSrcValue++;

        }

        pDataBuffer = AdsCopyAttributeName(
                                pThisAdsSrcAttribute,
                                pThisAdsTargAttribute,
                                pDataBuffer
                                );

    }

    hr = S_OK;

cleanup:

    //
    // Clean up the header based Ods structures
    //

    
    if (pAdsDestValues) {
    }

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    if (pszNDSPathName) {

        (void) FreeADsStr(pszNDSPathName) ;
    }

    if (pAdsAttributes) {
        DWORD dwAttr = 0;
        for (i = 0; i < dwNumberOfEntries; i++) {
            pThisAttributeDef = pAdsAttributes + dwAttr;
            if (pThisAttributeDef->pszAttrName) {
                FreeADsMem(pThisAttributeDef->pszAttrName);
            }
            if (pThisAttributeDef->pADsValues) {
                AdsFreeAdsValues(
                    pThisAttributeDef->pADsValues,
                    pThisAttributeDef->dwNumValues
                    );
                FreeADsMem(pThisAttributeDef->pADsValues);
            }
            dwAttr++;
        }
        FreeADsMem(pAdsAttributes);
    }

    *ppAttributeEntries = (PADS_ATTR_INFO)pAttributeBuffer;
    *pdwNumAttributesReturned = dwAttrCount;

    RRETURN(hr);

error:

    if (pAttributeBuffer) {
        FreeADsMem(pAttributeBuffer);
    }

    if (pAdsAttributes) {
        DWORD dwAttr = 0;
        for (i = 0; i < dwNumberOfEntries; i++) {
            pThisAttributeDef = pAdsAttributes + dwAttr;
            if (pThisAttributeDef->pszAttrName) {
                FreeADsMem(pThisAttributeDef->pszAttrName);
            }
            if (pThisAttributeDef->pADsValues) {
                AdsFreeAdsValues(
                        pThisAttributeDef->pADsValues,
                        pThisAttributeDef->dwNumValues
                        );
                FreeADsMem(pThisAttributeDef->pADsValues);
            }
            dwAttr++;
        }
        FreeADsMem(pAdsAttributes);
    }

    goto cleanup;
}


HRESULT
CNDSGenObject::CreateDSObject(
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    BYTE lpBuffer[2048];
    WCHAR *pszNDSPathName = NULL;

    HANDLE hObject = NULL;
    HANDLE hOperationData = NULL;


    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;

    DWORD dwStatus = 0;
    PNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumNdsValues = 0;
    DWORD dwSyntaxId = 0;
    IADs *pADs = NULL;
    TCHAR szADsClassName[64];


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_ADD,
                        &hOperationData
                        );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAttributeEntries + i;

        hr = AdsTypeToNdsTypeCopyConstruct(
                    pThisAttribute->pADsValues,
                    pThisAttribute->dwNumValues,
                    &pNdsDestObjects,
                    &dwNumNdsValues,
                    &dwSyntaxId
                    );
        CONTINUE_ON_FAILURE(hr);

        hr = MarshallNDSSynIdToNDS(
                    dwSyntaxId,
                    pNdsDestObjects,
                    dwNumNdsValues,
                    lpBuffer
                    );


        dwStatus = NwNdsPutInBuffer(
                        pThisAttribute->pszAttrName,
                        dwSyntaxId,
                        NULL,
                        0,
                        NDS_ATTR_CLEAR,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


        dwStatus = NwNdsPutInBuffer(
                        pThisAttribute->pszAttrName,
                        dwSyntaxId,
                        lpBuffer,
                        dwNumNdsValues,
                        NDS_ATTR_ADD,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        
        FreeMarshallMemory(
               dwSyntaxId,
               dwNumNdsValues,
               lpBuffer
               );

        NdsTypeFreeNdsObjects(
              pNdsDestObjects,
              dwNumNdsValues
              );
        pNdsDestObjects = NULL;
    }

    dwStatus = NwNdsAddObject(
                    hObject,
                    pszRDNName,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumAttributes; i++) {
        pThisAttribute = pAttributeEntries + i;
        if ( _tcsicmp( pThisAttribute->pszAttrName,
                       TEXT("Object Class")) == 0 ) {
            _tcscpy( szADsClassName, 
                     (LPTSTR)pThisAttribute->pADsValues->CaseIgnoreString);
            break;
        }
    }
    
    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    pszRDNName,
                    szADsClassName,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppObject
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs) {
        pADs->Release();
    }
    
    if (pNdsDestObjects) {
        FreeMarshallMemory(
               dwSyntaxId,
               dwNumNdsValues,
               lpBuffer
               );
       
        NdsTypeFreeNdsObjects(                     
               pNdsDestObjects, 
               dwNumNdsValues
               );
    }


    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    if (pszNDSPathName) {

        (void) FreeADsStr(pszNDSPathName) ;
    }


    RRETURN(hr);

}


HRESULT
CNDSGenObject::DeleteDSObject(
    LPWSTR pszRDNName
    )
{
    WCHAR *pszNDSPathName = NULL ;
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hParentObject = NULL;

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hParentObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsRemoveObject(
                    hParentObject,
                    pszRDNName
                    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


error:
    if (hParentObject) {
        NwNdsCloseObject(
                hParentObject
                );
    }

    if (pszNDSPathName) {

        (void) FreeADsStr(pszNDSPathName) ;
    }


    RRETURN(hr);
}

HRESULT
ComputeAttributeBufferSize(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwSize
    )
{
    DWORD i = 0;
    DWORD j = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;
    PADSVALUE pAdsSrcValues = NULL;
    DWORD dwSize = 0;
    DWORD dwVarSz = 0;
    DWORD dwNumValues = 0;
    HRESULT hr = S_OK;


    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAdsAttributes + i;

        dwNumValues = pThisAttribute->dwNumValues;

        pAdsSrcValues = pThisAttribute->pADsValues;

        for (j = 0; j < dwNumValues; j++) {

            dwVarSz = AdsTypeSize(pAdsSrcValues + j);

            dwSize += dwVarSz;

            dwSize += sizeof(ADSVALUE);

        }

        dwSize += sizeof(ADS_ATTR_INFO);

        dwSize += (wcslen(pThisAttribute->pszAttrName) + 1)*sizeof(WCHAR);
    }

    *pdwSize = dwSize;

    RRETURN(S_OK);
}


HRESULT
ComputeNumberofValues(
    PADS_ATTR_INFO pAdsAttributes,
    DWORD dwNumAttributes,
    PDWORD pdwNumValues
    )
{
    DWORD i = 0;
    PADS_ATTR_INFO pThisAttribute = NULL;
    DWORD dwNumValues = 0;
    DWORD dwTotalNumValues = 0;

    for (i = 0; i < dwNumAttributes; i++) {

        pThisAttribute = pAdsAttributes + i;

        dwNumValues = pThisAttribute->dwNumValues;

        dwTotalNumValues += dwNumValues;

    }

    *pdwNumValues = dwTotalNumValues;

    RRETURN(S_OK);
}


DWORD
ComputeObjectInfoSize(
    PADS_OBJECT_INFO pObjectInfo
    )
{
    DWORD dwLen = 0;

    dwLen += (wcslen(pObjectInfo->pszRDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszObjectDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszParentDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszSchemaDN) + 1) * sizeof(WCHAR);
    dwLen += (wcslen(pObjectInfo->pszClassName) + 1) * sizeof(WCHAR);


    dwLen += sizeof(ADS_OBJECT_INFO);

    return(dwLen);
}




LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    );

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((UINT_PTR)addr & ~1))

DWORD ObjectInfoStrings[] =

                             {
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszRDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszObjectDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszParentDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszSchemaDN),
                             FIELD_OFFSET(ADS_OBJECT_INFO, pszClassName),
                             0xFFFFFFFF
                             };


HRESULT
MarshallObjectInfo(
    PADS_OBJECT_INFO pSrcObjectInfo,
    LPBYTE pDestObjectInfo,
    LPBYTE pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(ADS_OBJECT_INFO)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;

    memset(SourceStrings, 0, sizeof(ADS_OBJECT_INFO));
    *pSourceStrings++ = pSrcObjectInfo->pszRDN;
    *pSourceStrings++ = pSrcObjectInfo->pszObjectDN;
    *pSourceStrings++ = pSrcObjectInfo->pszParentDN;
    *pSourceStrings++ = pSrcObjectInfo->pszSchemaDN;
    *pSourceStrings++ = pSrcObjectInfo->pszClassName;

    pEnd = PackStrings(
                SourceStrings,
                pDestObjectInfo,
                ObjectInfoStrings,
                pEnd
                );

    RRETURN(S_OK);
}



HRESULT
CNDSGenObject::GetObjectInformation(
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo
    )
{

    ADS_OBJECT_INFO ObjectInfo;
    PADS_OBJECT_INFO pObjectInfo = &ObjectInfo;
    LPBYTE  pBuffer = NULL;
    DWORD dwSize = 0;

    HRESULT hr = S_OK;

    pObjectInfo->pszRDN = _Name;
    pObjectInfo->pszObjectDN = _ADsPath;
    pObjectInfo->pszParentDN = _Parent;
    pObjectInfo->pszSchemaDN = _Schema;
    pObjectInfo->pszClassName = _ADsClass;

    dwSize = ComputeObjectInfoSize(pObjectInfo);

    pBuffer = (LPBYTE)AllocADsMem(dwSize);
    if (!pBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr  = MarshallObjectInfo(
                pObjectInfo,
                pBuffer,
                pBuffer + dwSize
                );
    BAIL_ON_FAILURE(hr);

    *ppObjInfo = (PADS_OBJECT_INFO)pBuffer;

error:

    RRETURN(hr);
}



LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}


LPBYTE
AdsCopyAttributeName(
    PADS_ATTR_INFO pThisAdsSrcAttribute,
    PADS_ATTR_INFO pThisAdsTargAttribute,
    LPBYTE pDataBuffer
    )
{

    LPWSTR pCurrentPos = (LPWSTR)pDataBuffer;

    wcscpy(pCurrentPos, pThisAdsSrcAttribute->pszAttrName);

    pThisAdsTargAttribute->pszAttrName = pCurrentPos;

    pDataBuffer = pDataBuffer + (wcslen(pThisAdsSrcAttribute->pszAttrName) + 1)*sizeof(WCHAR);

    return(pDataBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cclsobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cclsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSClass

DEFINE_IDispatch_Implementation(CNDSClass)
DEFINE_IADs_Implementation(CNDSClass)


CNDSClass::CNDSClass():
      _pDispMgr( NULL ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 ),

      _dwFlags(0),
      _lpClassName(0),
      _dwNumberOfSuperClasses(0),
      _lpSuperClasses(0),
      _dwNumberOfContainmentClasses(0),
      _lpContainmentClasses(0),
      _dwNumberOfNamingAttributes(0),
      _lpNamingAttributes(0),
      _dwNumberOfMandatoryAttributes(0),
      _lpMandatoryAttributes(0),
      _dwNumberOfOptionalAttributes(0),
      _lpOptionalAttributes(0)

{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNDSClass);
}

HRESULT
CNDSClass::CreateClass(
    BSTR Parent,
    BSTR CommonName,
    LPNDS_CLASS_DEF lpClassDefs,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSClass FAR * pClass = NULL;
    HRESULT hr = S_OK;

    hr = AllocateClassObject(Credentials, &pClass);
    BAIL_ON_FAILURE(hr);

    hr = pClass->InitializeCoreObject(
                Parent,
                CommonName,
                CLASS_CLASS_NAME,
                L"",
                CLSID_NDSClass,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pClass->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pClass->_Credentials = Credentials;

    pClass->_dwFlags = lpClassDefs->dwFlags;

    pClass->_dwNumberOfSuperClasses =
                    lpClassDefs->dwNumberOfSuperClasses;
    pClass->_lpSuperClasses = CreatePropertyList(
                                    lpClassDefs->lpSuperClasses
                                    );

    pClass->_dwNumberOfContainmentClasses =
                    lpClassDefs->dwNumberOfContainmentClasses;
    pClass->_lpContainmentClasses = CreatePropertyList(
                                        lpClassDefs->lpContainmentClasses
                                        );

    pClass->_dwNumberOfNamingAttributes =
                    lpClassDefs->dwNumberOfNamingAttributes;
    pClass->_lpNamingAttributes = CreatePropertyList(
                                        lpClassDefs->lpNamingAttributes
                                        );

    pClass->_dwNumberOfMandatoryAttributes =
                    lpClassDefs->dwNumberOfMandatoryAttributes;
    pClass->_lpMandatoryAttributes = CreatePropertyList(
                                          lpClassDefs->lpMandatoryAttributes
                                          );

    pClass->_dwNumberOfOptionalAttributes =
                    lpClassDefs->dwNumberOfOptionalAttributes;
    pClass->_lpOptionalAttributes = CreatePropertyList(
                                            lpClassDefs->lpOptionalAttributes
                                            );

    pClass->Release();

    RRETURN(hr);

error:

    delete pClass;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSClass::CreateClass(
    BSTR Parent,
    BSTR CommonName,
    HANDLE hTree,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    DWORD dwStatus = 0;
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpClassDefs = NULL;
    DWORD dwObjectsReturned = 0;
    DWORD dwInfoType = 0;
    HANDLE hOperationData = NULL;

    dwStatus = NwNdsCreateBuffer(
                    NDS_SCHEMA_READ_CLASS_DEF,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsPutInBuffer(
                    CommonName,
                    0,
                    NULL,
                    0,
                    0,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsReadClassDef(
                    hTree,
                    NDS_CLASS_INFO_EXPANDED_DEFS,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetClassDefListFromBuffer(
                    hOperationData,
                    &dwObjectsReturned,
                    &dwInfoType,
                    (LPVOID *) &lpClassDefs
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (!lpClassDefs) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CNDSClass::CreateClass(
                    Parent,
                    CommonName,
                    lpClassDefs,
                    Credentials,
                    dwObjectState,
                    riid,
                    ppvObj
                    );

error:
    if (hOperationData) {
        NwNdsFreeBuffer(hOperationData);
    }

    RRETURN_EXP_IF_ERR(hr);
}

CNDSClass::~CNDSClass( )
{
    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }


    if (_lpSuperClasses) {

        FreePropertyList(_lpSuperClasses);
    }

    if (_lpContainmentClasses) {

        FreePropertyList(_lpContainmentClasses);
    }

    if (_lpNamingAttributes) {

        FreePropertyList(_lpNamingAttributes);
    }

    if (_lpMandatoryAttributes) {

        FreePropertyList(_lpMandatoryAttributes);
    }


    if (_lpOptionalAttributes) {

        FreePropertyList(_lpOptionalAttributes);
    }



    VariantClear( &_vFilter );

    delete _pDispMgr;
}

STDMETHODIMP
CNDSClass::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSClass::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(S_OK);
}

STDMETHODIMP
CNDSClass::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSClass::AllocateClassObject(
    CCredentials& Credentials,
    CNDSClass ** ppClass
    )
{
    CNDSClass FAR * pClass = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pClass = new CNDSClass();
    if (pClass == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsClass,
                (IADsClass *)pClass,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}

/* ISupportErrorInfo method*/
STDMETHODIMP
CNDSClass::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
) 
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNDSClass::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN_EXP_IF_ERR(S_OK);
}


STDMETHODIMP
CNDSClass::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSClass::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSClass::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSClass::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



/* IADsClass methods */

STDMETHODIMP
CNDSClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if (_dwFlags & NDS_EFFECTIVE_CLASS) {
        *pfAbstract = VARIANT_FALSE;
    }else {
        *pfAbstract = VARIANT_TRUE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary )
{
    *pfAuxiliary = VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_MandatoryProperties( THIS_ VARIANT FAR *pvMandatoryProperties )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpMandatoryAttributes,
            _dwNumberOfMandatoryAttributes,
            pvMandatoryProperties
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpSuperClasses,
            _dwNumberOfSuperClasses,
            pvDerivedFrom
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpContainmentClasses,
            _dwNumberOfContainmentClasses,
            pvContainment
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_Containment( THIS_ VARIANT vContainment )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if (_dwFlags & NDS_CONTAINER_CLASS) {
        *pfContainer = VARIANT_TRUE;
    }else {
        *pfContainer = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    if ( !pbstrHelpFileName )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    
    HRESULT hr;
    hr = ADsAllocString( _bstrHelpFileName, pbstrHelpFileName );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



PPROPENTRY
CreatePropertyList(
    LPWSTR_LIST  lpStringList
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY pPropEntry = NULL;

    while (lpStringList) {

        pPropEntry = CreatePropertyEntry(
                            lpStringList->szString,
                            0
                            );

        if (!pPropEntry) {
            goto error;
        }

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpStringList = lpStringList->Next;
    }

error:
    return(pStart);
}

HRESULT
MakeVariantFromPropList(
    PPROPENTRY pPropList,
    DWORD dwNumEntries,
    VARIANT * pVarList
    )
{
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pVarList);

    sabNewArray.cElements = dwNumEntries;
    sabNewArray.lLbound = 0;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );

    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i < (dwSLBound + dwNumEntries); i++) {
        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        V_BSTR(&v) = SysAllocString(pPropList->pszPropName);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&i,
                (void *)&v
                );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

        pPropList = pPropList->pNext;

    }

    V_VT(pVarList) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarList) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpOptionalAttributes,
            _dwNumberOfOptionalAttributes,
            retval
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{

    HRESULT hr = E_NOTIMPL;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;

    hr = MakeVariantFromPropList(
            _lpNamingAttributes,
            _dwNumberOfNamingAttributes,
            retval
            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cclscach.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:     Class Cache functionality for the NDS Provider
//
//  Functions:
//                CClassCache::addentry
//                CClassCache::findentry
//                CClassCache::getentry
//                CProperyCache::CClassCache
//                CClassCache::~CClassCache
//                CClassCache::CreateClassCache
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


//+------------------------------------------------------------------------
//
//  Function:   CClassCache::addentry
//
//  Synopsis:
//
//
//
//  Arguments:  [pszTreeName]       --
//              [pszClassName]      --
//              [pClassEntry]       --
//
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
addentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PPROPENTRY pPropList
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwLRUEntry = 0;
    DWORD dwIndex = 0;
    PPROPENTRY pNewPropList = NULL;


    EnterCriticalSection(&_cs);

    hr = findentry(
            pszTreeName,
            pszClassName,
            &dwIndex
            );

    if (SUCCEEDED(hr)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Restore yr error code
    //
    hr = S_OK;

    if (_dwMaxCacheSize == 0 ) {


        LeaveCriticalSection(&_cs);

        RRETURN(E_FAIL);

    }

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (!_ClassEntries[i].bInUse) {

            //
            // Found an available entry; use it
            // fill in the name of the printer and the providor
            // that supports this printer.
            //
            break;

        } else {

            if ((dwLRUEntry == -1) || (i == IsOlderThan(i, dwLRUEntry))){
                dwLRUEntry = i;
            }
        }

    }

    if (i == _dwMaxCacheSize){

        //
        // We have no available entries so we need to use
        // the LRUEntry which is busy
        //


        //
        // Free this entry
        //

        if (_ClassEntries[dwLRUEntry].pPropList) {

            FreePropertyList(_ClassEntries[dwLRUEntry].pPropList);

            _ClassEntries[dwLRUEntry].pPropList = NULL;
        }

        _ClassEntries[dwLRUEntry].bInUse = FALSE;

        i = dwLRUEntry;
    }


    //
    // Insert the new entry into the Cache
    //

    wcscpy(_ClassEntries[i].szTreeName, pszTreeName);
    wcscpy(_ClassEntries[i].szClassName, pszClassName);

    pNewPropList = CopyPropList(pPropList);
    if (pNewPropList) {

        _ClassEntries[i].pPropList = pNewPropList;
    }

    _ClassEntries[i].bInUse = TRUE;

    //
    // update the time stamp so that we know when this entry was made
    //

    GetSystemTime(&_ClassEntries[i].st);

error:

    LeaveCriticalSection(&_cs);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache::findentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
findentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;


    EnterCriticalSection(&_cs);

    if (_dwMaxCacheSize == 0 ) {

        LeaveCriticalSection(&_cs);

        RRETURN(E_FAIL);
    }

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (_ClassEntries[i].bInUse) {
            if ((!_wcsicmp(_ClassEntries[i].szTreeName, pszTreeName)) &&
                (!_wcsicmp(_ClassEntries[i].szClassName, pszClassName))) {

                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&_ClassEntries[i].st);

                *pdwIndex = i;


                LeaveCriticalSection(&_cs);

                RRETURN(S_OK);

            }
        }
    }

    LeaveCriticalSection(&_cs);

    RRETURN(E_FAIL);
}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache::findentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
getentry(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    PPROPENTRY * ppPropList
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PPROPENTRY pPropList = NULL;

    EnterCriticalSection(&_cs);

    hr = findentry(
            pszTreeName,
            pszClassName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pPropList = CopyPropList(
                    _ClassEntries[dwIndex].pPropList
                    );

    *ppPropList =  pPropList;

error:

    LeaveCriticalSection(&_cs);

    RRETURN(hr);

}

//+------------------------------------------------------------------------
//
//  Function:   CClassCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CClassCache::
CClassCache():
        _dwMaxCacheSize(2)
{
    memset(_ClassEntries, 0, sizeof(CLASSENTRY));
}

//+------------------------------------------------------------------------
//
//  Function:   ~CClassCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CClassCache::
~CClassCache()
{
    DWORD i;
    for (i = 0; i < _dwMaxCacheSize; i++ ) {
        if (_ClassEntries[i].bInUse) {
            if (_ClassEntries[i].pPropList) {
                FreePropertyList(_ClassEntries[i].pPropList);
                _ClassEntries[i].pPropList = NULL;
            }
            _ClassEntries[i].bInUse = FALSE;
        }
    }

    DeleteCriticalSection(&_cs);
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CClassCache::
CreateClassCache(
    CClassCache FAR *FAR * ppClassCache
    )
{
    CClassCache FAR * pClassCache = NULL;

    pClassCache = new CClassCache();

    if (!pClassCache) {
        RRETURN(E_FAIL);
    }


    InitializeCriticalSection(&(pClassCache->_cs));

    *ppClassCache = pClassCache;

    RRETURN(S_OK);
}

DWORD
CClassCache::
IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    // DBGMSG(DBG_TRACE, ("IsOlderThan entering with i %d j %d\n", i, j));

    pi = &(_ClassEntries[i].st);
    pj = &(_ClassEntries[j].st);

    if (pi->wYear < pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else  if (pi->wMonth < pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
            return(i);
        } else {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
            return(j);
        }
    }
}

HRESULT
ValidatePropertyinCache(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    LPWSTR pszPropName,
    CCredentials& Credentials,
    PDWORD pdwSyntaxId
    )
{

    HRESULT hr = S_OK;
    PPROPENTRY pPropList = NULL;

    hr = pgClassCache->getentry(
                    pszTreeName,
                    pszClassName,
                    &pPropList
                    );

    if (FAILED(hr)) {
        hr = NdsGetClassInformation(
                 pszTreeName,
                 pszClassName,
                 Credentials,
                 &pPropList
                 );
        BAIL_ON_FAILURE(hr);

        hr = pgClassCache->addentry(
                    pszTreeName,
                    pszClassName,
                    pPropList
                    );
        BAIL_ON_FAILURE(hr);

    }

    hr = FindProperty(
               pPropList,
               pszPropName,
               pdwSyntaxId
               );
    BAIL_ON_FAILURE(hr);

error:

    if (pPropList) {
        FreePropertyList(pPropList);
    }

    RRETURN(hr);

}

HRESULT
NdsGetClassInformation(
    LPWSTR pszTreeName,
    LPWSTR pszClassName,
    CCredentials& Credentials,
    PPROPENTRY * ppPropList
    )
{
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpClassDefs = NULL;
    DWORD dwStatus;
    DWORD dwObjectReturned = 0;
    DWORD dwInfoType = 0;
    HANDLE hTree = NULL;
    HANDLE hOperationData = NULL;
    PPROPENTRY pPropList = NULL;

    dwStatus = ADsNwNdsOpenObject(
                    pszTreeName,
                    Credentials,
                    &hTree,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                    NDS_SCHEMA_READ_CLASS_DEF,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    
    dwStatus = NwNdsPutInBuffer(
                    pszClassName,
                    0,
                    NULL,
                    0,
                    0,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    dwStatus = NwNdsReadClassDef(
                    hTree,
                    NDS_CLASS_INFO_EXPANDED_DEFS,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetClassDefListFromBuffer(
                    hOperationData,
                    &dwObjectReturned,
                    &dwInfoType,
                    (LPVOID *) &lpClassDefs
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    pPropList = GenerateAttrIdList(
                        hTree,
                        lpClassDefs->lpMandatoryAttributes,
                        lpClassDefs->lpOptionalAttributes
                        );

/*
    pPropList = GeneratePropertyAndIdList(
                        pszTreeName,
                        lpClassDefs->lpMandatoryAttributes,
                        lpClassDefs->lpOptionalAttributes
                        );*/
    if (!pPropList) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppPropList = pPropList;


error:

    if (hOperationData) {
        NwNdsFreeBuffer(hOperationData);
    }

    if (hTree) {
        NwNdsCloseObject(hTree);
    }

    RRETURN(hr);
}


PPROPENTRY
CreatePropertyEntry(
    LPWSTR pszPropertyName,
    DWORD dwSyntaxId
    )
{
    LPWSTR pszTemp = NULL;
    PPROPENTRY pPropName = NULL;

    pszTemp = (LPWSTR)AllocADsStr(
                    pszPropertyName
                    );
    if (!pszTemp) {
        return(NULL);
    }

    pPropName = (PPROPENTRY)AllocADsMem(
                        sizeof(PROPENTRY)
                        );
    if (!pPropName) {
        FreeADsStr(pszTemp);
        return(NULL);
    }

    pPropName->pszPropName = pszTemp;
    pPropName->dwSyntaxId = dwSyntaxId;

    return(pPropName);
}

void
FreePropertyEntry(
    PPROPENTRY pPropName
    )
{
    if (pPropName->pszPropName) {
        FreeADsStr(pPropName->pszPropName);
    }

    FreeADsMem(pPropName);

    return;
}


void
FreePropertyList(
    PPROPENTRY pPropList
    )
{
    PPROPENTRY pTemp = NULL;

    while (pPropList) {
        pTemp = pPropList->pNext;

        FreePropertyEntry(pPropList);

        pPropList = pTemp;
    }
    return;
}


PPROPENTRY
GeneratePropertyList(
    LPWSTR_LIST lpMandatoryProps,
    LPWSTR_LIST lpOptionalProps
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY lpProperty = NULL;
    LPWSTR_LIST lpTempStrings = NULL;

    lpTempStrings = lpMandatoryProps;

    while (lpTempStrings) {


        lpProperty = CreatePropertyEntry(
                            lpTempStrings->szString,
                            0
                            );
        if (!lpProperty) {
            goto cleanup;
        }

        lpProperty->pNext = pStart;
        pStart = lpProperty;

        lpTempStrings = lpTempStrings->Next;
    }

    lpTempStrings = lpOptionalProps;

    while (lpTempStrings) {


        lpProperty = CreatePropertyEntry(
                            lpTempStrings->szString,
                            0
                            );
        if (!lpProperty) {
            goto cleanup;
        }

        lpProperty->pNext = pStart;
        pStart = lpProperty;

        lpTempStrings = lpTempStrings->Next;
    }


cleanup:

    return(pStart);

}

HRESULT
FindProperty(
    PPROPENTRY pPropList,
    LPWSTR pszPropName,
    PDWORD pdwSyntaxId
    )
{
    while (pPropList) {
        if (!_wcsicmp(pPropList->pszPropName, pszPropName)) {
            *pdwSyntaxId = pPropList->dwSyntaxId;
            RRETURN(S_OK);
        }

        pPropList = pPropList->pNext;
    }

    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


PPROPENTRY
CopyPropList(
    PPROPENTRY pPropList
    )
{

    PPROPENTRY pPropEntry = NULL;
    PPROPENTRY pStart = NULL;

    while (pPropList) {
      pPropEntry = CreatePropertyEntry(
                        pPropList->pszPropName,
                        pPropList->dwSyntaxId
                        );
      if (!pPropEntry) {
          return(pStart);
      }

      pPropEntry->pNext = pStart;
      pStart = pPropEntry;

      pPropList = pPropList->pNext;

    }

    return(pStart);

}



PPROPENTRY
GeneratePropertyAndIdList(
    LPWSTR pszTreeName,
    CCredentials& Credentials,
    LPWSTR_LIST lpMandatoryProps,
    LPWSTR_LIST lpOptionalProps
    )
{
    HANDLE hTree = NULL;
    PPROPENTRY pStart = NULL;
    PPROPENTRY pPropEntry = NULL;
    LPWSTR_LIST lpTempStrings = NULL;
    HANDLE hOperationData = NULL;
    DWORD i = 0;
    WCHAR szTempBuffer[MAX_PATH];

    LPNDS_ATTR_DEF lpAttrDefs = NULL;

    DWORD dwSyntaxId = 0;
    DWORD dwNumEntries = 0;
    DWORD dwInfoType = 0;
    DWORD dwStatus = 0;


    dwStatus = ADsNwNdsOpenObject(
                    pszTreeName,
                    Credentials,
                    &hTree,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
    if (dwStatus) {

        goto error;
    }



    dwStatus = NwNdsCreateBuffer(
                    NDS_SCHEMA_READ_ATTR_DEF,
                    &hOperationData
                    );
    if (dwStatus) {

        goto error;
    }


    lpTempStrings = lpMandatoryProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);

        dwStatus = NwNdsPutInBuffer(
                        szTempBuffer,
                        0,
                        NULL,
                        0,
                        0,
                        hOperationData
                        );
        if (dwStatus) {

            goto error;
        }

        lpTempStrings = lpTempStrings->Next;
    }

    lpTempStrings = lpOptionalProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);

        dwStatus = NwNdsPutInBuffer(
                        szTempBuffer,
                        0,
                        NULL,
                        0,
                        0,
                        hOperationData
                        );
        if (dwStatus) {

            goto error;
        }

        lpTempStrings = lpTempStrings->Next;
    }


    dwStatus = NwNdsReadAttrDef(
                        hTree,
                        NDS_INFO_NAMES_DEFS,
                        &hOperationData
                        );
    if (dwStatus) {

        goto error;
    }


    dwStatus = NwNdsGetAttrDefListFromBuffer(
                        hOperationData,
                        &dwNumEntries,
                        &dwInfoType,
                        (LPVOID *)&lpAttrDefs
                        );

    if (dwStatus) {

        goto error;
    }


    for (i = 0; i < dwNumEntries; i++){

        pPropEntry = CreatePropertyEntry(
                            lpAttrDefs[i].szAttributeName,
                            lpAttrDefs[i].dwSyntaxID
                            );

        if (!pPropEntry) {
            goto error;
        }

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

    }



error:

    if (hOperationData) {
        NwNdsFreeBuffer(hOperationData);
    }


    if (hTree) {
        NwNdsCloseObject(hTree);
    }


    return(pStart);
}



PPROPENTRY
GenerateAttrIdList(
    HANDLE hTree,
    LPWSTR_LIST lpMandatoryProps,
    LPWSTR_LIST lpOptionalProps
    )
{
    PPROPENTRY pStart = NULL;
    PPROPENTRY pPropEntry = NULL;
    LPWSTR_LIST lpTempStrings = NULL;
    HANDLE hOperationData = NULL;
    DWORD i = 0;
    WCHAR szTempBuffer[MAX_PATH];

    LPNDS_ATTR_DEF lpAttrDefs = NULL;

    DWORD dwSyntaxId = 0;
    DWORD dwNumEntries = 0;
    DWORD dwInfoType = 0;
    DWORD dwStatus = 0;


    lpTempStrings = lpMandatoryProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);


        dwStatus = NwNdsGetSyntaxID(
                        hTree,
                        szTempBuffer,
                        &dwSyntaxId
                        );

        if (dwStatus) {
            lpTempStrings = lpTempStrings->Next;            
            continue;
        }

        pPropEntry = CreatePropertyEntry(
                            szTempBuffer,
                            dwSyntaxId
                            );

        if (!pPropEntry) {
            lpTempStrings = lpTempStrings->Next;
            continue;
        }

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpTempStrings = lpTempStrings->Next;
    }

    lpTempStrings = lpOptionalProps;

    while (lpTempStrings) {

        wcscpy(szTempBuffer, lpTempStrings->szString);

        dwStatus = NwNdsGetSyntaxID(
                        hTree,
                        szTempBuffer,
                        &dwSyntaxId
                        );

        if (dwStatus) {
            lpTempStrings = lpTempStrings->Next;
            continue;
        }

        pPropEntry = CreatePropertyEntry(
                            szTempBuffer,
                            dwSyntaxId
                            );

        if (!pPropEntry) {
            lpTempStrings = lpTempStrings->Next;
            continue;
        }

        pPropEntry->pNext = pStart;
        pStart = pPropEntry;

        lpTempStrings = lpTempStrings->Next;
    }



    return(pStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cdssrch.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssrch.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

const int NO_NDS_RESULT_HANDLES = 32;

static
HRESULT
NdsValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    );

static
HRESULT
NdsValueToADsColumnAppend(
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    );

static
HRESULT
NdsAddAttributes(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT HANDLE *phSearchResult
    );

//
// Sets the appropriate search preferences.
//
HRESULT
CNDSGenObject::SetSearchPreference(
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    )
{
    HRESULT hr = S_OK;
    BOOL fWarning = FALSE;
    DWORD i;

    if (!pSearchPrefs && dwNumPrefs > 0) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    for (i=0; i<dwNumPrefs; i++) {

        pSearchPrefs[i].dwStatus = ADS_STATUS_S_OK;

        switch(pSearchPrefs[i].dwSearchPref) {
        case ADS_SEARCHPREF_ASYNCHRONOUS:
        case ADS_SEARCHPREF_SIZE_LIMIT:
        case ADS_SEARCHPREF_TIME_LIMIT:
        case ADS_SEARCHPREF_TIMEOUT:
        case ADS_SEARCHPREF_PAGESIZE:
        case ADS_SEARCHPREF_PAGED_TIME_LIMIT:
        case ADS_SEARCHPREF_CHASE_REFERRALS:
            //
            // Can't be set
            //
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
            fWarning = TRUE;
            continue;

        case ADS_SEARCHPREF_DEREF_ALIASES:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_INTEGER) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_DEREF_NEVER:
                _SearchPref._fDerefAliases = FALSE;
                break;

            case ADS_DEREF_ALWAYS:
                _SearchPref._fDerefAliases = TRUE;
                break;

            default:
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            break;

        case ADS_SEARCHPREF_ATTRIBTYPES_ONLY:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_BOOLEAN) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            _SearchPref._fAttrsOnly = pSearchPrefs[i].vValue.Boolean;
            break;

        case ADS_SEARCHPREF_SEARCH_SCOPE:
            if (pSearchPrefs[i].vValue.dwType != ADSTYPE_INTEGER) {
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }

            switch (pSearchPrefs[i].vValue.Integer) {
            case ADS_SCOPE_ONELEVEL:
                _SearchPref._iScope = 0;
                break;

            case ADS_SCOPE_SUBTREE:
                _SearchPref._iScope = 1;
                break;

            case ADS_SCOPE_BASE:
                _SearchPref._iScope = 2;
                break;

            default:
                pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREFVALUE;
                fWarning = TRUE;
                continue;
            }
            break;

        default:
            pSearchPrefs[i].dwStatus = ADS_STATUS_INVALID_SEARCHPREF;
            fWarning = TRUE;
            continue;

        }
    }

    RRETURN (fWarning ? S_ADS_ERRORSOCCURRED : S_OK);

}


HRESULT
CNDSGenObject::ExecuteSearch(
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{
    PNDS_SEARCHINFO phSearchInfo = NULL;
    LPWSTR pszNDSContext = NULL, szCurrAttr = NULL;
    DWORD dwAttrNamesLen = 0;
    HRESULT hr = S_OK;
    ULONG i, j;
    LPWSTR pszAttrNameBuffer = NULL, *ppszAttrs = NULL;

    if (!phSearchHandle) {
        RRETURN (E_ADS_BAD_PARAMETER);
    }

    //
    // Allocate search handle
    //
    phSearchInfo = (PNDS_SEARCHINFO) AllocADsMem(sizeof(NDS_SEARCHINFO));
    if(!phSearchInfo)
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);

    if (pszSearchFilter) {
        phSearchInfo->_pszSearchFilter = AllocADsStr(pszSearchFilter);
    }
    else {
        phSearchInfo->_pszSearchFilter = AllocADsStr(L"(object class=*)");
    }
    if(!(phSearchInfo->_pszSearchFilter))
        BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);


    hr = BuildNDSPathFromADsPath(
         _ADsPath,
         &phSearchInfo->_pszBindContext
         );
    BAIL_ON_FAILURE(hr);

    hr = AdsNdsGenerateParseTree(
             phSearchInfo->_pszSearchFilter,
             phSearchInfo->_pszBindContext,
             &phSearchInfo->_pQueryNode
             );
    BAIL_ON_FAILURE(hr);

    phSearchInfo->_fADsPathPresent = FALSE;
    phSearchInfo->_fADsPathReturned = FALSE;

    if (dwNumberAttributes == -1) {
        //
        // Specifies returning all attributes
        //

        phSearchInfo->_ppszAttrs = NULL;
        phSearchInfo->_pszAttrNameBuffer = NULL;
        phSearchInfo->_fADsPathPresent = TRUE;
    }
    else {
        ppszAttrs = (LPWSTR *) AllocADsMem(
                                  sizeof(LPWSTR) *
                                  (dwNumberAttributes + 1)
                                  );
        if (!ppszAttrs)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        for (i = 0; i < dwNumberAttributes; i++)
            dwAttrNamesLen+= (wcslen(pAttributeNames[i]) + 1) * sizeof(WCHAR);

        pszAttrNameBuffer = (LPWSTR) AllocADsMem(
                                         dwAttrNamesLen
                                         );
        if (!pszAttrNameBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        szCurrAttr = pszAttrNameBuffer;
        for (i = 0, j = 0; i < dwNumberAttributes; i++) {
            wcscpy(szCurrAttr, pAttributeNames[i]);
            ppszAttrs[j] = szCurrAttr;
            szCurrAttr += wcslen(ppszAttrs[j]) + 1;

            if(_wcsicmp(ppszAttrs[j], L"ADsPath") == 0) {
                //
                // ADsPath need not be sent
                //

                phSearchInfo->_fADsPathPresent = TRUE;
            }
            else  {

                j++;
            }

        }
        ppszAttrs[j] = NULL;

        phSearchInfo->_ppszAttrs = ppszAttrs;
        phSearchInfo->_pszAttrNameBuffer = pszAttrNameBuffer;
    }

    phSearchInfo->_hConnection = NULL;
    phSearchInfo->_dwIterHandle = NDS_INITIAL_SEARCH;
    phSearchInfo->_pSearchResults = NULL;
    phSearchInfo->_cSearchResults = 0;
    phSearchInfo->_dwCurrResult = 0;
    phSearchInfo->_fResultPrefetched = FALSE;
    phSearchInfo->_fCheckForDuplicates = TRUE;
    phSearchInfo->_dwCurrAttr = 0;
    phSearchInfo->_SearchPref = _SearchPref;

    *phSearchHandle = phSearchInfo;

    RRETURN(S_OK);

error:

    if(phSearchInfo) {
        if(phSearchInfo->_pszBindContext)
            FreeADsStr(phSearchInfo->_pszBindContext);

        if(phSearchInfo->_pszSearchFilter)
            FreeADsStr(phSearchInfo->_pszSearchFilter);

        if(phSearchInfo->_ppszAttrs)
            FreeADsMem(phSearchInfo->_ppszAttrs);

        if(phSearchInfo->_pszAttrNameBuffer)
            FreeADsMem(phSearchInfo->_pszAttrNameBuffer);

        FreeADsMem(phSearchInfo);
    }

    RRETURN (hr);

}


HRESULT
CNDSGenObject::AbandonSearch(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::CloseSearchHandle (
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;
    DWORD dwStatus;

    if (!phSearchInfo)
        RRETURN (E_ADS_BAD_PARAMETER);

    if (phSearchInfo->_pQueryNode) {
        dwStatus = NwNdsDeleteQueryTree(phSearchInfo->_pQueryNode);
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (phSearchInfo->_hConnection) {
        dwStatus = NwNdsCloseObject(phSearchInfo->_hConnection);
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if(phSearchInfo->_pszBindContext)
        FreeADsStr(phSearchInfo->_pszBindContext);

    if(phSearchInfo->_pszSearchFilter)
        FreeADsStr(phSearchInfo->_pszSearchFilter);

    if(phSearchInfo->_ppszAttrs)
        FreeADsMem(phSearchInfo->_ppszAttrs);

    if(phSearchInfo->_pszAttrNameBuffer)
        FreeADsMem(phSearchInfo->_pszAttrNameBuffer);

    if (phSearchInfo->_pSearchResults) {
        for (DWORD i=0; i <= phSearchInfo->_dwCurrResult; i++) {
            NwNdsFreeBuffer(phSearchInfo->_pSearchResults[i]._hSearchResult);
        }
        FreeADsMem(phSearchInfo->_pSearchResults);
    }

    FreeADsMem(phSearchInfo);
    RRETURN (hr);
}


HRESULT
CNDSGenObject::GetFirstRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CNDSGenObject::GetNextRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr;
    DWORD dwStatus = NO_ERROR;
    PNDS_SEARCH_RESULT pResult, pNextResult;
    LPNDS_OBJECT_INFO   pObject, pNextObject;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if (!phSearchInfo) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    if (phSearchInfo->_fCheckForDuplicates) {
        phSearchInfo->_dwCurrAttr = 0;
        phSearchInfo->_fADsPathReturned = FALSE;
    }

    if (!phSearchInfo->_hConnection) {
        dwStatus = ADsNwNdsOpenObject(
                              phSearchInfo->_pszBindContext,
                              _Credentials,
                              &phSearchInfo->_hConnection,
                              NULL,
                              NULL,
                              NULL,
                              NULL
                              );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            RRETURN (hr);
        }
    }

    if (phSearchInfo->_pSearchResults) {
        pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

        if (pResult->_pObjects &&
            ((pResult->_lObjectCurrent+1) < pResult->_lObjects)) {
            pResult->_lObjectCurrent++;
            RRETURN(S_OK);
        }
        if (pResult->_lObjectCurrent+1 == pResult->_lObjects &&
            phSearchInfo->_fResultPrefetched) {
            phSearchInfo->_dwCurrResult++;
            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextResult->_lObjectCurrent = 0;
            phSearchInfo->_fResultPrefetched = FALSE;

            if(phSearchInfo->_fCheckForDuplicates) {
                pObject = pResult->_pObjects + pResult->_lObjectCurrent;
                pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
                if (!_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                    //
                    // Duplicates; Skip one more result
                    //
                    if (pNextResult->_lObjectCurrent+1 < pNextResult->_lObjects)
                        pNextResult->_lObjectCurrent++;
                    else
                    {
                        pNextResult->_lObjectCurrent++;
                        RRETURN(S_ADS_NOMORE_ROWS);
                    }
                }
            }
            if( pNextResult->_lObjectCurrent >= pNextResult->_lObjects &&
                 phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS)
                RRETURN(S_ADS_NOMORE_ROWS);
            else
                RRETURN(S_OK);
        }
        else if( pResult->_lObjectCurrent+1 >= pResult->_lObjects &&
                 phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS)
        {
            // Make sure _lObjectCurrent doesn't exceed _lObjects. If the
            // result set is empty, _lObjectCurrent should stay at -1
            if( ((pResult->_lObjectCurrent+1) == pResult->_lObjects) &&
                 (pResult->_lObjectCurrent != -1) )
                pResult->_lObjectCurrent++;
            RRETURN(S_ADS_NOMORE_ROWS);
        }
    }

    if (!phSearchInfo->_pQueryNode) {
        //
        // querynode not setup yet
        //
        RRETURN (E_FAIL);
    }

    if(!phSearchInfo->_pSearchResults) {
        //
        // Allocate an array of handles to Search Handles
        //
        phSearchInfo->_pSearchResults = (PNDS_SEARCH_RESULT) AllocADsMem(
                                             sizeof(NDS_SEARCH_RESULT) *
                                             NO_NDS_RESULT_HANDLES);
        if(!phSearchInfo->_pSearchResults) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        phSearchInfo->_dwCurrResult = 0;
        phSearchInfo->_cSearchResults = NO_NDS_RESULT_HANDLES;
    }
    else {
        phSearchInfo->_dwCurrResult++;
        if (phSearchInfo->_dwCurrResult >= phSearchInfo->_cSearchResults) {
            //
            // Need to allocate more memory for handles
            //

            phSearchInfo->_pSearchResults = (PNDS_SEARCH_RESULT) ReallocADsMem(
                                                 (void *) phSearchInfo->_pSearchResults,
                                                 sizeof(NDS_SEARCH_RESULT) *
                                                 phSearchInfo->_cSearchResults,
                                                 sizeof(NDS_SEARCH_RESULT) *
                                                 (phSearchInfo->_cSearchResults +
                                                  NO_NDS_RESULT_HANDLES)
                                                 );
            if(!phSearchInfo->_pSearchResults) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            phSearchInfo->_cSearchResults += NO_NDS_RESULT_HANDLES;

        }
    }

    pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    hr = NdsAddAttributes(phSearchInfo,
                             &pNextResult->_hSearchResult
                             );
    BAIL_ON_FAILURE(hr);

    pNextResult->_lObjects = 0;
    pNextResult->_pObjects = NULL;
    // Set _lObjectCurrent to -1 so that empty result set is handled correctly.
    // If it is set  to 0 and the result set is empty, then a subsequent call
    // to GetNextRow will not return S_ADS_NOMORE_ROWS. Instead, it will try to
    // search again (in the process, possibly allocate memory for 
    // _pSearchResults etc.). Also, setting it to -1 ensures that a call to 
    // GetColumn returns error if the result set is empty. 
    // Setting it to -1 also ensures that if an error occurs during the search,
    // subsequent calls to GetNextRow and GetColumn are handled correctly. 
    pNextResult->_lObjectCurrent = -1; 

    dwStatus = NwNdsSearch(
                   phSearchInfo->_hConnection,
                   _SearchPref._fAttrsOnly ?
                       NDS_INFO_NAMES : NDS_INFO_ATTR_NAMES_VALUES,
                   _SearchPref._iScope,
                   _SearchPref._fDerefAliases,
                   phSearchInfo->_pQueryNode,
                   &phSearchInfo->_dwIterHandle,
                   &pNextResult->_hSearchResult
                   );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN (hr);
    }

    DWORD dwType;
    dwStatus = NwNdsGetObjectListFromBuffer(
                   pNextResult->_hSearchResult,
                   (DWORD *) (&pNextResult->_lObjects),
                   &dwType,
                   &pNextResult->_pObjects
                   );
    if (dwStatus) {
        dwStatus = GetLastError();
        if (dwStatus == ERROR_NO_DATA)
            RRETURN(S_ADS_NOMORE_ROWS);
        else
            RRETURN (HRESULT_FROM_WIN32(dwStatus));
    }

    if (pNextResult->_lObjects > 0) {
        pNextResult->_lObjectCurrent = 0;
        if(phSearchInfo->_fCheckForDuplicates && phSearchInfo->_dwCurrResult > 0) {
            pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult-1]);
            pObject = pResult->_pObjects + pResult->_lObjectCurrent;
            pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
            if (!_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // Duplicates; Skip one more result
                //
                pNextResult->_lObjectCurrent++;
            }
        }
        if( pNextResult->_lObjectCurrent >= pNextResult->_lObjects &&
             phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS)
            RRETURN(S_ADS_NOMORE_ROWS);

        RRETURN(S_OK);
    }
    else
        RRETURN(E_FAIL);

error:
    RRETURN(hr);
}

HRESULT
CNDSGenObject::GetPreviousRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    PNDS_SEARCH_RESULT pResult, pPrevResult;
    LPNDS_OBJECT_INFO  pPrevObject, pObject;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if(!phSearchInfo || !phSearchInfo->_pSearchResults)
        RRETURN(E_FAIL);

    if (phSearchInfo->_fCheckForDuplicates) {
        phSearchInfo->_dwCurrAttr = 0;
        phSearchInfo->_fADsPathReturned = FALSE;
    }

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if (pResult->_lObjectCurrent > 0)
    {
        pResult->_lObjectCurrent--;

        if(phSearchInfo->_fCheckForDuplicates && 
          (phSearchInfo->_dwCurrResult > 0) && (0 == pResult->_lObjectCurrent))
        {
            pPrevResult = &(phSearchInfo->_pSearchResults[
                                      phSearchInfo->_dwCurrResult - 1]);
            pPrevObject = pPrevResult->_pObjects + pPrevResult->_lObjects - 1;
            pObject = pResult->_pObjects + pResult->_lObjectCurrent;

            if(!_wcsicmp(pObject->szObjectName, pPrevObject->szObjectName)) {
            // Current row is a duplicate. Go to previous result
                phSearchInfo->_dwCurrResult--;
                pResult = &(phSearchInfo->_pSearchResults[
                                         phSearchInfo->_dwCurrResult]); 
                pResult->_lObjectCurrent = pResult->_lObjects-1;
                phSearchInfo->_fResultPrefetched = TRUE;
            }
        }
    } 
    else if (phSearchInfo->_dwCurrResult > 0) {
        phSearchInfo->_dwCurrResult--;
        pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
        pResult->_lObjectCurrent = pResult->_lObjects-1;
        phSearchInfo->_fResultPrefetched = TRUE;
    }
    else if(0 == pResult->_lObjectCurrent)
    // we are at the very beginning of the result set
        pResult->_lObjectCurrent--;
    else
        RRETURN(S_ADS_NOMORE_ROWS);

    RRETURN(S_OK);

}


HRESULT
CNDSGenObject::GetColumn(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNDS_ATTR_INFO pAttribute;
    PNDS_SEARCH_RESULT pResult, pNextResult;
    LPNDS_OBJECT_INFO   pObject, pNextObject;
    DWORD cAttr;
    BOOL fRowAdvanced = FALSE;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if( !pColumn ||
        !phSearchInfo ||
        !phSearchInfo->_pSearchResults )
        RRETURN (E_ADS_BAD_PARAMETER);

    pColumn->pszAttrName = NULL;
    pColumn->dwADsType = ADSTYPE_INVALID;
    pColumn->pADsValues = NULL;
    pColumn->dwNumValues = 0;
    pColumn->hReserved = NULL;

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if( pResult->_lObjectCurrent < 0 )
        RRETURN (E_ADS_BAD_PARAMETER);

    pObject = pResult->_pObjects + pResult->_lObjectCurrent;

    pColumn->pszAttrName = AllocADsStr(pszColumnName);
    if (pColumn->pszAttrName)
        BAIL_ON_FAILURE(hr);

    if(!_wcsicmp (pszColumnName, L"ADsPath")) {
        LPWSTR szNDSPath = pObject->szObjectFullName;

        //
        // Build the ADsPathName
        //

        WCHAR szTree[MAX_PATH];
        WCHAR szCN[MAX_PATH];
        WCHAR szADsPath[MAX_PATH];

        // Building the CN and the TreeName
        LPWSTR szCurrent = szNDSPath;
        szCurrent+=2;
        while ((WCHAR)(*szCurrent) != (WCHAR)'\\')
            szCurrent++;
        wcsncpy( szTree,
                 szNDSPath,
                 (UINT) (szCurrent-szNDSPath) );

        // Make the first two characters "//" instead of "\\"
        szTree[0] = (WCHAR)'/';
        szTree[1] = (WCHAR)'/';

        szTree[szCurrent-szNDSPath] = (WCHAR)'\0';
        szCurrent++;
        wcscpy( szCN,
                szCurrent );

        // Building the ADsPath
        hr = BuildADsPathFromNDSPath(
                    szTree,
                    szCN,
                    szADsPath
                    );
        BAIL_ON_FAILURE(hr);

        if(*szADsPath) {
            pColumn->pADsValues = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE));
            if (!pColumn->pADsValues)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
            pColumn->dwNumValues = 1;
            pColumn->pADsValues[0].dwType = ADSTYPE_CASE_IGNORE_STRING;

            pColumn->pADsValues[0].CaseIgnoreString = AllocADsStr(szADsPath);
            if (!pColumn->pADsValues[0].CaseIgnoreString)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            pColumn->hReserved = pColumn->pADsValues[0].CaseIgnoreString;
        }
        RRETURN(S_OK);
    }

    if (phSearchInfo->_SearchPref._fAttrsOnly) {
        //
        // Only Names got. So, don't return any values
        //
        RRETURN (S_OK);
    }

    pAttribute = (LPNDS_ATTR_INFO)pObject->lpAttribute;

    for (cAttr=0;cAttr<pObject->dwNumberOfAttributes;cAttr++,pAttribute++) {
        if (_wcsicmp(
                pAttribute->szAttributeName,
                pszColumnName
                ) == 0)
            break;
    }
    if (cAttr == pObject->dwNumberOfAttributes) {
        if(pResult->_lObjectCurrent+1 != pResult->_lObjects ||
           (phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS &&
            !phSearchInfo->_fResultPrefetched)) {
            //
            // No need to look in the next result set;
            //
            BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            phSearchInfo->_fCheckForDuplicates = FALSE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
            }

            fRowAdvanced = TRUE;

            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object;
                //
                BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
            }
            else {
                //
                // Look in the next object
                //
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute;
                for (cAttr=0;cAttr<pNextObject->dwNumberOfAttributes;cAttr++,pAttribute++) {
                    if (_wcsicmp(
                            pAttribute->szAttributeName,
                            pszColumnName
                            ) == 0)
                        break;
                }
                if (cAttr == pNextObject->dwNumberOfAttributes) {
                    //
                    // Didn't find in the next result set containing the row too
                    //
                    BAIL_ON_FAILURE(hr = E_ADS_COLUMN_NOT_SET);
                }
            }
        }
    }

    hr = NdsValueToADsColumn(
             pszColumnName,
             pAttribute->dwSyntaxId,
             pAttribute->dwNumberOfValues,
             pAttribute->lpValue,
             pColumn
             );
    BAIL_ON_FAILURE(hr);

    //
    // Added in to support the case when one multivalue attribute is split into 2 packets. The 
    // following case checks 
    // 1) if we haven't advanced the row, if we have advanced already, the whole
    //    Attribute will already be completely residing in the second packet
    // 2) the attribute was the last attribute from the last packet, thus 
    //    the next attribute, (the first attribute of the next row) might be
    //    the same.
    //
    if ((!fRowAdvanced) &&
            (cAttr == (pObject->dwNumberOfAttributes - 1))) {

        //
        // If there is indeed a need to try out an extra packet
        //
        if(pResult->_lObjectCurrent+1 != pResult->_lObjects ||
           (phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS &&
            !phSearchInfo->_fResultPrefetched)) {
            //
            // No need to look in the next result set;
            //
            hr = S_OK;
            goto done;
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            phSearchInfo->_fCheckForDuplicates = FALSE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                hr = S_OK;
                goto done;
            }

            fRowAdvanced = TRUE;

            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object, since objname is different
                //
                hr = S_OK;
                goto done;
            }
            else {
                //
                // Look in the next object, look for the same attribute
                //
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute;
                for (cAttr=0;cAttr<pNextObject->dwNumberOfAttributes;cAttr++,pAttribute++) {
                    if (_wcsicmp(
                            pAttribute->szAttributeName,
                            pszColumnName
                            ) == 0)
                        break;
                }
                if (cAttr == pNextObject->dwNumberOfAttributes) {
                    //
                    // Didn't find in the next result set containing the row too
                    //
                    hr = S_OK;
                    goto done;
                }
            }
        }

        // 
        // If found, we'll append it to the last column
        //
        hr = NdsValueToADsColumnAppend(
                         pAttribute->dwSyntaxId,
                         pAttribute->dwNumberOfValues,
                         pAttribute->lpValue,
                         pColumn
                         );
        BAIL_ON_FAILURE(hr);
    }
done:
    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    RRETURN(S_OK);

error:

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    FreeColumn(pColumn);

    RRETURN (hr);
}



HRESULT
CNDSGenObject::GetNextColumnName(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{
    HRESULT hr = S_OK;
    LPNDS_ATTR_INFO pAttribute;
    LPNDS_ATTR_INFO pAttributeOld = NULL;
    LPNDS_NAME_ONLY pNameOnlyAttr;
    PNDS_SEARCH_RESULT pResult, pNextResult;
    LPNDS_OBJECT_INFO   pObject, pNextObject;
    BOOL fRowAdvanced = FALSE;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if( !phSearchInfo ||
        !phSearchInfo->_pSearchResults ||
        !ppszColumnName)
        RRETURN (E_ADS_BAD_PARAMETER);

    *ppszColumnName = NULL;

    pResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);

    if( pResult->_lObjectCurrent < 0 )
        RRETURN (E_ADS_BAD_PARAMETER);

    pObject = pResult->_pObjects + pResult->_lObjectCurrent;

    pNameOnlyAttr = (LPNDS_NAME_ONLY)pObject->lpAttribute +
                    phSearchInfo->_dwCurrAttr;
    pAttribute = (LPNDS_ATTR_INFO)pObject->lpAttribute +
                 phSearchInfo->_dwCurrAttr;

    //
    // Get the last attribute's name to test it to avoid getting duplicate 
    // column names. This will happen if a multi-value got divided into two 
    // packets. In that case, both attribute names would be the same.
    // We are only getting the last attribute if this object has greater than
    // 1 object, or else if this attribute is the first attribute, there would
    // not be a one before
    //
    if (phSearchInfo->_dwCurrAttr > 0) {
        pAttributeOld = pAttribute - 1;
    }

    if (phSearchInfo->_dwCurrAttr >= pObject->dwNumberOfAttributes) {
        if(pResult->_lObjectCurrent+1 != pResult->_lObjects ||
           (phSearchInfo->_dwIterHandle == NDS_NO_MORE_ITERATIONS &&
            !phSearchInfo->_fResultPrefetched)) {
            //
            // No need to look in the next result set;
            //
            hr = S_ADS_NOMORE_COLUMNS;
            goto error;
        }
        else {
            //
            // There is a chance that the column may come in the next
            // result set. So, fetch the next set of results.
            //
            phSearchInfo->_fCheckForDuplicates = FALSE;
            hr = GetNextRow(
                     phSearchInfo
                     );
            phSearchInfo->_fCheckForDuplicates = TRUE;
            BAIL_ON_FAILURE(hr);

            if (hr == S_ADS_NOMORE_ROWS) {
                hr = S_ADS_NOMORE_COLUMNS;
                goto error;
            }

            fRowAdvanced = TRUE;

            pNextResult = &(phSearchInfo->_pSearchResults[phSearchInfo->_dwCurrResult]);
            pNextObject = pNextResult->_pObjects + pNextResult->_lObjectCurrent;
            if (_wcsicmp(pObject->szObjectName, pNextObject->szObjectName)) {
                //
                // No need to look in the next object;
                //
                hr = S_ADS_NOMORE_COLUMNS;
                goto error;
            }
            else {
                //
                // Look in the next object
                //
                pNameOnlyAttr = (LPNDS_NAME_ONLY)pNextObject->lpAttribute +
                                phSearchInfo->_dwCurrAttr -
                                pObject->dwNumberOfAttributes;
                pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute +
                                 phSearchInfo->_dwCurrAttr -
                                  pObject->dwNumberOfAttributes;
                //
                // If the new attribute is after the first attribute in the new object,
                // we'll reset AttributeOld to point to the attribute before this.
                // Because the old attribute will be the one before the current one
                // in this case.
                //
                if ((phSearchInfo->_dwCurrAttr - pObject->dwNumberOfAttributes) > 0) {
                    pAttributeOld = pAttribute - 1;
                }

                if (phSearchInfo->_dwCurrAttr >= (pObject->dwNumberOfAttributes +
                                          pNextObject->dwNumberOfAttributes)) {
                    //
                    // Didn't find in the next result set
                    // containing the row too
                    //
                    hr = S_ADS_NOMORE_COLUMNS;
                    goto error;
                }

                //
                // If it is a duplicate column, go on to the next one
                //
                if (pAttributeOld) {
                    if(wcscmp(pAttribute->szAttributeName, 
                              pAttributeOld->szAttributeName) == 0) {
                        phSearchInfo->_dwCurrAttr++;
                        if (phSearchInfo->_dwCurrAttr >= (pObject->dwNumberOfAttributes +
                                                          pNextObject->dwNumberOfAttributes)) {
                            //
                            // Didn't find in the next result set
                            // containing the row too
                            //
                            hr = S_ADS_NOMORE_COLUMNS;
                            goto error;
                        }
                        pNameOnlyAttr = (LPNDS_NAME_ONLY)pNextObject->lpAttribute +
                                 phSearchInfo->_dwCurrAttr -
                                     pObject->dwNumberOfAttributes;
                        pAttribute = (LPNDS_ATTR_INFO)pNextObject->lpAttribute +
                                     phSearchInfo->_dwCurrAttr -
                                     pObject->dwNumberOfAttributes;
                    }
                }
            }
        }
    }

    if (phSearchInfo->_SearchPref._fAttrsOnly)
        *ppszColumnName = AllocADsStr(
                              pNameOnlyAttr->szName
                              );
    else
        *ppszColumnName = AllocADsStr(
                              pAttribute->szAttributeName
                              );

    phSearchInfo->_dwCurrAttr++;

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    RRETURN(S_OK);

error:

    if (fRowAdvanced) {
        phSearchInfo->_fCheckForDuplicates = FALSE;
        GetPreviousRow(phSearchInfo);
        phSearchInfo->_fCheckForDuplicates = TRUE;
    }

    if (*ppszColumnName)
        FreeADsStr(*ppszColumnName);


    if (hr == S_ADS_NOMORE_COLUMNS && phSearchInfo->_fADsPathPresent) {

        //
        // If ADsPath was specified, return it as the last column in the row
        //

        if (!phSearchInfo->_fADsPathReturned) {

            *ppszColumnName = AllocADsStr(L"ADsPath");
            phSearchInfo->_fADsPathReturned = TRUE;
            hr = S_OK;
        }
        else {

            hr = S_ADS_NOMORE_COLUMNS;
        }

    }

    RRETURN (hr);
}


HRESULT
CNDSGenObject::FreeColumn(
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    if(!pColumn)
        RRETURN (E_ADS_BAD_PARAMETER);

    if (pColumn->pszAttrName)
        FreeADsStr(pColumn->pszAttrName);

    switch(pColumn->dwADsType) {
        case ADSTYPE_CASE_IGNORE_STRING:
            if ((PNDSOBJECT)pColumn->hReserved) {
                //ADsPath does not have hReserved, it is a direct string allocation

                if (pColumn->pADsValues) {
                    FreeADsStr(pColumn->pADsValues[0].CaseIgnoreString);
                }
            }
            break;

        default:
            // Nothing to free
            break;
    }

    if (pColumn->pADsValues)
        FreeADsMem(pColumn->pADsValues);

    RRETURN(hr);
}


HRESULT
NdsValueToADsColumn(
    LPWSTR      pszColumnName,
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    )
{
    HRESULT hr = S_OK;
    LPASN1_TYPE_1 lpASN1_1;
    LPASN1_TYPE_7 lpASN1_7;
    LPASN1_TYPE_8 lpASN1_8;
    LPASN1_TYPE_9 lpASN1_9;
    LPASN1_TYPE_14 lpASN1_14;
    LPASN1_TYPE_24 lpASN1_24;
    DWORD i, j;

    if(!pszColumnName || !pColumn)
        RRETURN(E_ADS_BAD_PARAMETER);

    pColumn->hReserved = NULL;
    pColumn->dwNumValues = dwValues;
    pColumn->pADsValues = (PADSVALUE) AllocADsMem(
                                          sizeof(ADSVALUE) * dwValues
                                          );
    if (!pColumn->pADsValues)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    if (dwSyntaxId >= g_cMapNdsTypeToADsType)
        pColumn->dwADsType = ADSTYPE_INVALID;
    else
        pColumn->dwADsType = g_MapNdsTypeToADsType[dwSyntaxId];

    switch (dwSyntaxId) {
        // WIDE STRING
        case NDS_SYNTAX_ID_1:
        case NDS_SYNTAX_ID_2:
        case NDS_SYNTAX_ID_3:
        case NDS_SYNTAX_ID_4:
        case NDS_SYNTAX_ID_5:
        case NDS_SYNTAX_ID_10:
        case NDS_SYNTAX_ID_11:
        case NDS_SYNTAX_ID_20:
            for (i=0; i < dwValues; i++) {
                lpASN1_1 = (LPASN1_TYPE_1) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].CaseIgnoreString = lpASN1_1->DNString;
            }
            break;

    case NDS_SYNTAX_ID_14 :
        for (i=0; i < dwValues; i++) {
            lpASN1_14 = (LPASN1_TYPE_14) lpValue + i;
            pColumn->pADsValues[i].dwType = pColumn->dwADsType;
            pColumn->pADsValues[i].CaseIgnoreString = lpASN1_14->Address;
        }
        break;

        // BYTE STREAM
        case NDS_SYNTAX_ID_9:
            for (i=0; i < dwValues; i++) {
                lpASN1_9 = (LPASN1_TYPE_9) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].OctetString.dwLength =lpASN1_9->Length;
                pColumn->pADsValues[i].OctetString.lpValue = lpASN1_9->OctetString;
            }
            break;

        // BOOLEAN
        case NDS_SYNTAX_ID_7:
            for (i=0; i < dwValues; i++) {
                lpASN1_7 = (LPASN1_TYPE_7) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].Boolean = lpASN1_7->Boolean;
            }
            break;

        // INTEGER
        case NDS_SYNTAX_ID_8:
        case NDS_SYNTAX_ID_22:
        case NDS_SYNTAX_ID_27:
            for (i=0; i < dwValues; i++) {
                lpASN1_8 = (LPASN1_TYPE_8) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].Integer = lpASN1_8->Integer;
            }
            break;

        case NDS_SYNTAX_ID_24 :
            for (i=0; i < dwValues; i++) {
                lpASN1_24 = (LPASN1_TYPE_24) lpValue + i;
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                hr = ConvertDWORDtoSYSTEMTIME(
                            lpASN1_24->Time,
                            &(pColumn->pADsValues[i].UTCTime)
                            );
                BAIL_ON_FAILURE(hr);
            }
            break;

        case NDS_SYNTAX_ID_6 :
        case NDS_SYNTAX_ID_12 :
        case NDS_SYNTAX_ID_13 :
        case NDS_SYNTAX_ID_15 :
        case NDS_SYNTAX_ID_16 :
        case NDS_SYNTAX_ID_17 :
        case NDS_SYNTAX_ID_18 :
        case NDS_SYNTAX_ID_19 :
        case NDS_SYNTAX_ID_21 :
        case NDS_SYNTAX_ID_23 :
        case NDS_SYNTAX_ID_25 :
        case NDS_SYNTAX_ID_26 :
        default:
            for (i=0; i < dwValues; i++) {
                pColumn->pADsValues[i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[i].ProviderSpecific.dwLength =0;
                pColumn->pADsValues[i].ProviderSpecific.lpValue = NULL;
            }
            break;
    }
    RRETURN(hr);

error:

    if (pColumn->pADsValues)
        FreeADsMem(pColumn->pADsValues);

    RRETURN(hr);


}

/*++

Routine Description:

    Given a column, this function will append more values to the end

Return Value:

    S_OK on success, error code otherwise

--*/
HRESULT
NdsValueToADsColumnAppend(
    DWORD       dwSyntaxId,
    DWORD       dwValues,
    LPBYTE      lpValue,
    ADS_SEARCH_COLUMN * pColumn
    )
{
    HRESULT hr = S_OK;
    LPASN1_TYPE_1 lpASN1_1;
    LPASN1_TYPE_7 lpASN1_7;
    LPASN1_TYPE_8 lpASN1_8;
    LPASN1_TYPE_9 lpASN1_9;
    LPASN1_TYPE_14 lpASN1_14;
    LPASN1_TYPE_24 lpASN1_24;
    DWORD i, j;
    PADSVALUE pADsValuesNew = NULL;
    DWORD dwValuesBase;

    if(!pColumn)
        RRETURN(E_ADS_BAD_PARAMETER);

    dwValuesBase = pColumn->dwNumValues;

    //
    // Allocate memory for new values + old values
    //
    pADsValuesNew = (PADSVALUE) AllocADsMem(
                          sizeof(ADSVALUE) * (pColumn->dwNumValues + dwValues)
                          );
    if (!pADsValuesNew) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Copy old values into new array, and free the old one
    //
    memcpy(pADsValuesNew,
           pColumn->pADsValues,
           sizeof(ADSVALUE) * dwValuesBase);
    FreeADsMem(pColumn->pADsValues);
    pColumn->pADsValues = pADsValuesNew;

    switch (dwSyntaxId) {
        // WIDE STRING
        case NDS_SYNTAX_ID_1:
        case NDS_SYNTAX_ID_2:
        case NDS_SYNTAX_ID_3:
        case NDS_SYNTAX_ID_4:
        case NDS_SYNTAX_ID_5:
        case NDS_SYNTAX_ID_10:
        case NDS_SYNTAX_ID_11:
        case NDS_SYNTAX_ID_20:
            for (i=0; i < dwValues; i++) {
                lpASN1_1 = (LPASN1_TYPE_1) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].CaseIgnoreString = lpASN1_1->DNString;
            }
            break;

        case NDS_SYNTAX_ID_14 :
            for (i=0; i < dwValues; i++) {
                lpASN1_14 = (LPASN1_TYPE_14) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].CaseIgnoreString = lpASN1_14->Address;
            }
            break;

        // BYTE STREAM
        case NDS_SYNTAX_ID_9:
            for (i=0; i < dwValues; i++) {
                lpASN1_9 = (LPASN1_TYPE_9) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].OctetString.dwLength =lpASN1_9->Length;
                pColumn->pADsValues[dwValuesBase+i].OctetString.lpValue = lpASN1_9->OctetString;
            }
            break;

        // BOOLEAN
        case NDS_SYNTAX_ID_7:
            for (i=0; i < dwValues; i++) {
                lpASN1_7 = (LPASN1_TYPE_7) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].Boolean = lpASN1_7->Boolean;
            }
            break;

        // INTEGER
        case NDS_SYNTAX_ID_8:
        case NDS_SYNTAX_ID_22:
        case NDS_SYNTAX_ID_27:
            for (i=0; i < dwValues; i++) {
                lpASN1_8 = (LPASN1_TYPE_8) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].Integer = lpASN1_8->Integer;
            }
            break;

        case NDS_SYNTAX_ID_24 :
            for (i=0; i < dwValues; i++) {
                lpASN1_24 = (LPASN1_TYPE_24) lpValue + i;
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                hr = ConvertDWORDtoSYSTEMTIME(
                            lpASN1_24->Time,
                            &(pColumn->pADsValues[dwValuesBase+i].UTCTime)
                            );
                BAIL_ON_FAILURE(hr);
            }
            break;

        case NDS_SYNTAX_ID_6 :
        case NDS_SYNTAX_ID_12 :
        case NDS_SYNTAX_ID_13 :
        case NDS_SYNTAX_ID_15 :
        case NDS_SYNTAX_ID_16 :
        case NDS_SYNTAX_ID_17 :
        case NDS_SYNTAX_ID_18 :
        case NDS_SYNTAX_ID_19 :
        case NDS_SYNTAX_ID_21 :
        case NDS_SYNTAX_ID_23 :
        case NDS_SYNTAX_ID_25 :
        case NDS_SYNTAX_ID_26 :
        default:
            for (i=0; i < dwValues; i++) {
                pColumn->pADsValues[dwValuesBase+i].dwType = pColumn->dwADsType;
                pColumn->pADsValues[dwValuesBase+i].ProviderSpecific.dwLength =0;
                pColumn->pADsValues[dwValuesBase+i].ProviderSpecific.lpValue = NULL;
            }
            break;
    }
    pColumn->dwNumValues = pColumn->dwNumValues + dwValues;
    
error:
    //
    // We don't need to free memory even in error case because it has been
    // put into the column
    //
    RRETURN(hr);
}




HRESULT
NdsAddAttributes(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT HANDLE *phSearchResult
    )
{
    DWORD    dwStatus = NO_ERROR;
    HANDLE   hSearchResult = NULL;
    HRESULT  hr;
    DWORD    i;
    PNDS_SEARCHINFO phSearchInfo = (PNDS_SEARCHINFO) hSearchHandle;

    if (!phSearchResult || !phSearchResult)
        RRETURN( E_FAIL );

    *phSearchResult = NULL;

    if(!phSearchInfo->_ppszAttrs)
        RRETURN(S_OK);

    dwStatus = NwNdsCreateBuffer( NDS_SEARCH,
                                &hSearchResult );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    for (i=0; phSearchInfo->_ppszAttrs[i]; i++) {
        dwStatus = NwNdsPutInBuffer( phSearchInfo->_ppszAttrs[i],
                                   0,
                                   NULL,
                                   0,
                                   0,
                                   hSearchResult );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }

    *phSearchResult = hSearchResult;
    RRETURN( S_OK );

error:
    if(hSearchResult)
        NwNdsFreeBuffer(phSearchInfo);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cenumobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  NDS Object Enumeration Code
//
//              CNDSGenObjectEnum::CNDSGenObjectEnum()
//              CNDSGenObjectEnum::CNDSGenObjectEnum
//              CNDSGenObjectEnum::EnumObjects
//              CNDSGenObjectEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSGenObjectEnum::Create(
    CNDSGenObjectEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CNDSGenObjectEnum FAR* penumvariant = NULL;
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    LPWSTR pszNDSPath = NULL;
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;

    *ppenumvariant = NULL;

    penumvariant = new CNDSGenObjectEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSFilterArray(
                var,
                (LPBYTE *)&penumvariant->_pNdsFilterList
                );
    if (FAILED(hr)) {
        penumvariant->_pNdsFilterList = NULL;
    }

    /*
    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);
    */

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    hr = BuildNDSPathFromADsPath(
                ADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPath,
                    Credentials,
                    &penumvariant->_hObject,
                    szObjectFullName,
                    szObjectClassName,
                    &dwModificationTime,
                    &dwNumberOfEntries
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }


    RRETURN(hr);

error:

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    if (penumvariant) {

        delete penumvariant;
        *ppenumvariant = NULL;
    }
    RRETURN_EXP_IF_ERR(hr);
}

CNDSGenObjectEnum::CNDSGenObjectEnum():
                    _ADsPath(NULL)
{
    _pObjList = NULL;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _hObject = NULL;
    _hOperationData = NULL;
    _lpObjects = NULL;
    _pNdsFilterList = NULL;

    _bNoMore = FALSE;
}


CNDSGenObjectEnum::~CNDSGenObjectEnum()
{
    DWORD dwStatus;

    if (_pNdsFilterList) {
        FreeFilterList((LPBYTE)_pNdsFilterList);
    }
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }
    if (_hOperationData) {
        dwStatus = NwNdsFreeBuffer(_hOperationData);
    }
    if (_hObject) {
        dwStatus = NwNdsCloseObject(_hObject);
    }
}

HRESULT
CNDSGenObjectEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements ) {

        hr = GetGenObject(&pDispatch);
        if (FAILED(hr)) {
            continue;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CNDSGenObjectEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;
    LPNDS_OBJECT_INFO lpCurrentObject = NULL;
    IADs * pADs = NULL;


    *ppDispatch = NULL;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_hOperationData) {
            dwStatus = NwNdsFreeBuffer(_hOperationData);
            _hOperationData = NULL;
            _lpObjects = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        //
        // Insert NDS code in here
        //

        if (_bNoMore) {
            RRETURN(S_FALSE);
        }

        dwStatus = NwNdsListSubObjects(
                            _hObject,
                            MAX_CACHE_SIZE,
                            &_dwObjectReturned,
                            _pNdsFilterList,
                            &_hOperationData
                            );
        if ((dwStatus != ERROR_SUCCESS) && (dwStatus != WN_NO_MORE_ENTRIES)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (dwStatus == WN_NO_MORE_ENTRIES) {
            _bNoMore = TRUE;
        }

        dwStatus = NwNdsGetObjectListFromBuffer(
                            _hOperationData,
                            &_dwObjectReturned,
                            NULL,
                            &_lpObjects
                            );
        if (dwStatus != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }


    }

    //
    // Now send back the current object
    //

    lpCurrentObject = _lpObjects + _dwObjectCurrentEntry;



    //
    // Bump up the object count. The instantiation of this object
    // may fail; if we come into this function again, we do not want
    // to pick up the same object.
    //

    _dwObjectCurrentEntry++;

    hr = CNDSGenObject::CreateGenericObject(
                        _ADsPath,
                        lpCurrentObject->szObjectName,
                        lpCurrentObject->szObjectClass,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
        BAIL_ON_FAILURE(hr);
    }




error:

    //
    // GetGenObject returns only S_FALSE
    //

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSGenObjectEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSGenObjectEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
BuildNDSFilterArray(
    VARIANT var,
    LPBYTE * ppContigFilter
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;

    LPNDS_FILTER_LIST pNdsFilterList = NULL;
    LPBYTE pContigFilter = NULL;

    if(!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_ADS_INVALID_FILTER);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_ADS_INVALID_FILTER;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_ADS_INVALID_FILTER;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    pContigFilter = (LPBYTE)AllocADsMem(
                            sizeof(NDS_FILTER_LIST)
                            - sizeof(NDS_FILTER)
                            );
    if (!pContigFilter) {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }

        //
        //  Create an entry in the filter block
        //  Append it to the existing block
        //

        pContigFilter = CreateAndAppendFilterEntry(
                            pContigFilter,
                            V_BSTR(&v)
                            );

        VariantClear(&v);

        if (!pContigFilter) {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

    }

    pNdsFilterList = (LPNDS_FILTER_LIST)pContigFilter;

    if (!pNdsFilterList->dwNumberOfFilters){

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *ppContigFilter = pContigFilter;

    RRETURN(S_OK);

error:

    if (pContigFilter){

        FreeFilterList(
               pContigFilter
               );

    }

    *ppContigFilter = NULL;

    RRETURN(hr);
}


LPBYTE
CreateAndAppendFilterEntry(
    LPBYTE pContigFilter,
    LPWSTR lpObjectClass
    )
{
    LPWSTR pszFilter = NULL;
    LPNDS_FILTER_LIST pNdsFilterList = NULL;
    DWORD dwFilterCount = 0;
    LPBYTE pNewContigFilter = NULL;
    LPNDS_FILTER pNewEntry = NULL;


    pszFilter = (LPWSTR)AllocADsStr(lpObjectClass);
    if (!pszFilter) {
        return(pContigFilter);
    }

    pNdsFilterList = (LPNDS_FILTER_LIST)pContigFilter;

    dwFilterCount = pNdsFilterList->dwNumberOfFilters;

    pNewContigFilter = (LPBYTE)ReallocADsMem(
                                    pContigFilter,

                                    sizeof(NDS_FILTER_LIST) +
                                    (dwFilterCount - 1)* sizeof(NDS_FILTER),

                                    sizeof(NDS_FILTER_LIST)
                                    + dwFilterCount * sizeof(NDS_FILTER)
                                    );
    if (!pNewContigFilter) {
        return(pContigFilter);
    }

    pNewEntry = (LPNDS_FILTER)(pNewContigFilter + sizeof(NDS_FILTER_LIST)
                        + (dwFilterCount - 1)* sizeof(NDS_FILTER));

    pNewEntry->szObjectClass = pszFilter;

    pNdsFilterList = (LPNDS_FILTER_LIST)pNewContigFilter;

    pNdsFilterList->dwNumberOfFilters = dwFilterCount + 1;

    return(pNewContigFilter);
}

void
FreeFilterList(
    LPBYTE lpContigFilter
    )
{
    LPNDS_FILTER_LIST lpNdsFilterList = (LPNDS_FILTER_LIST)lpContigFilter;
    DWORD dwNumFilters = 0;
    LPNDS_FILTER lpNdsFilter = NULL;
    DWORD i = 0;

    dwNumFilters = lpNdsFilterList->dwNumberOfFilters;

    if (dwNumFilters){

        lpNdsFilter = (LPNDS_FILTER)(lpContigFilter  + sizeof(NDS_FILTER_LIST)
                                      - sizeof(NDS_FILTER));

        for (i = 0; i < dwNumFilters; i++) {

            FreeADsStr((lpNdsFilter + i)->szObjectClass);
        }

    }

    FreeADsMem(lpContigFilter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cenumcls.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  NDS Class Enumeration Code
//
//             CNDSClassEnum::CNDSClassEnum()
//             CNDSClassEnum::CNDSClassEnum
//             CNDSClassEnum::EnumObjects
//             CNDSClassEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSClassEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSClassEnum::Create(
    CNDSClassEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSClassEnum FAR* penumvariant = NULL;
    WCHAR szNDSTreeName[MAX_PATH];
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;


    *ppenumvariant = NULL;

    penumvariant = new CNDSClassEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    hr = BuildNDSTreeNameFromADsPath(
             bstrADsPath,
             szNDSTreeName
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( szNDSTreeName, &penumvariant->_bstrNDSTreeName);
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    penumvariant->_bstrNDSTreeName,
                    Credentials,
                    &penumvariant->_hTree,
                    szObjectFullName,
                    szObjectClassName,
                    &dwModificationTime,
                    &dwNumberOfEntries
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);


    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CNDSClassEnum::CNDSClassEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _bstrNDSTreeName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _pPropNameList( NULL),
      _pCurrentEntry( NULL )
{
    _hOperationData = NULL;
    _hTree = NULL;
    _lpClassDefs = NULL;

    _dwObjectCurrentEntry = 0;
    _dwObjectReturned = 0;

    _dwInfoType = 0;
}

CNDSClassEnum::~CNDSClassEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );
   ADsFreeString( _bstrNDSTreeName );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSClassEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSClassEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumProperties(
                cElements,
                pvar,
                &cElementFetched
                );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSClassEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NDS_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNDSClassEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNDSClassEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSClassEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpCurrentObject = NULL;
    DWORD dwStatus;

    *ppDispatch = NULL;

    if (!_hOperationData) {

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        dwStatus = NwNdsCreateBuffer(
                        NDS_SCHEMA_READ_CLASS_DEF,
                        &_hOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        dwStatus = NwNdsPutInBuffer(
                        _bstrName,
                        0,
                        NULL,
                        0,
                        0,
                        _hOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }


        dwStatus = NwNdsReadClassDef(
                        _hTree,
                        NDS_CLASS_INFO_EXPANDED_DEFS,
                        &_hOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        dwStatus = NwNdsGetClassDefListFromBuffer(
                        _hOperationData,
                        &_dwObjectReturned,
                        &_dwInfoType,
                        (LPVOID *) &_lpClassDefs
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        //
        // Assert to check that we returned only 1 object
        //

        ADsAssert(_dwObjectReturned == 1);


        _pPropNameList = GeneratePropertyList(
                            _lpClassDefs->lpMandatoryAttributes,
                            _lpClassDefs->lpOptionalAttributes
                            );
        if (!_pPropNameList) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        _pCurrentEntry  = _pPropNameList;

    }

    if (_pCurrentEntry){

        //
        // Now send back the current object
        //
        hr = CNDSProperty::CreateProperty(
                            _bstrADsPath,
                            _pCurrentEntry->pszPropName,
                            _hTree,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);

        _pCurrentEntry = _pCurrentEntry->pNext;
        RRETURN(S_OK);
    }
error:
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//              CNDSGroupCollectionEnum::CNDSGroupCollectionEnum()
//              CNDSGroupCollectionEnum::CNDSGroupCollectionEnum
//              CNDSGroupCollectionEnum::EnumObjects
//              CNDSGroupCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSGroupCollectionEnum::Create(
    BSTR bstrGroupName,
    CCredentials& Credentials,
    CNDSGroupCollectionEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    VARIANT varFilter
    )
{
    HRESULT hr = NOERROR;
    CNDSGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CNDSGroupCollectionEnum();


    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString(bstrGroupName, &(penumvariant->_bstrGroupName));
    BAIL_ON_FAILURE(hr);

    hr = penumvariant->ValidateVariant(
                    var
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    hr = ObjectTypeList::CreateObjectTypeList(
            varFilter,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CNDSGroupCollectionEnum::CNDSGroupCollectionEnum():
        _dwSLBound(0),
        _dwSUBound(0),
        _dwIndex(0),
        _dwMultiple(0),
        _bstrGroupName(0),
        _pObjList(NULL)
{
    VariantInit(&_vMembers);
}



CNDSGroupCollectionEnum::~CNDSGroupCollectionEnum()
{
    VariantClear(&_vMembers);
    if (_bstrGroupName) {
        ADsFreeString(_bstrGroupName);
    }
    
    if (_pObjList) {
        delete _pObjList;
    }    
}

HRESULT
CNDSGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    IADs * pIADs = NULL;
    BSTR pszClass = NULL;
    DWORD dwClassID;
    DWORD dwFilterID;
    BOOL fFound = FALSE;


    *pcElementFetched = 0;

    while (i < cElements) {


        if (_dwMultiple == MULTIPLE) {
            hr = GetGroupMultipleMemberObject(&pDispatch);
        }else if (_dwMultiple == SINGLE){
            hr = GetGroupSingleMemberObject(&pDispatch);
        }else {
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }


        //
        // Apply the IADsMembers::put_Filter filter.
        // If the enumerated object is not one of the types to be returned,
        // go on to the next member of the group.
        //
        
        hr = pDispatch->QueryInterface(IID_IADs, (void **)&pIADs);
        BAIL_ON_FAILURE(hr);

        //
        // Determine the object class of the enumerated object and the corresponding
        // object class ID number (as specified in the Filters global array).
        //        
        hr = pIADs->get_Class(&pszClass);
        BAIL_ON_FAILURE(hr);

        hr = IsValidFilter(pszClass, &dwClassID, gpFilters, gdwMaxFilters);
        if (SUCCEEDED(hr)) {

            //
            // Enumerate through the object classes listed in the user-specified filter
            // until we either find a match (fFound = TRUE) or we reach the end of the
            // list.
            //
            hr = _pObjList->Reset();

            while (SUCCEEDED(hr)) {
                hr = _pObjList->GetCurrentObject(&dwFilterID);

                if (SUCCEEDED(hr) 
                    && (dwFilterID == dwClassID)
                    ) {
                    fFound = TRUE;
                    break;
                }

                hr = _pObjList->Next();
            }

            if (!fFound) {
                // 
                // not on the list of objects to return, try again
                // with the next member of the group
                //
                pDispatch->Release();

                pIADs->Release();
                
                if (pszClass) {
                    ADsFreeString(pszClass);
                }
                
                continue;
            }

        }

        pIADs->Release();
        
        if (pszClass) {
            ADsFreeString(pszClass);
        }

        //
        // Return it.
        // 
        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    
    RRETURN_EXP_IF_ERR(hr);

error:
    if (pDispatch) {
        pDispatch->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CNDSGroupCollectionEnum::GetGroupMultipleMemberObject(
    IDispatch ** ppDispatch
    )
{

    VARIANT v;
    HRESULT hr = S_OK;
    WCHAR szADsPathName[MAX_PATH];
    WCHAR szNDSTreeName[MAX_PATH];

    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    *ppDispatch = NULL;

    if (_dwIndex > _dwSUBound) {
        RRETURN(S_FALSE);
    }

    VariantInit(&v);

    hr = SafeArrayGetElement(
                V_ARRAY(&_vMembers),
                (long FAR *)&_dwIndex,
                &v
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSTreeNameFromADsPath(
                _bstrGroupName,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    // Make the first two characters "//" instead of "\\"
    szNDSTreeName[0] = (WCHAR)'/';
    szNDSTreeName[1] = (WCHAR)'/';

    hr = BuildADsPathFromNDSPath(
            szNDSTreeName,
            v.bstrVal,
            szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);


    hr = ADsOpenObject(
                        szADsPathName,
                        pszUserName,
                        pszPassword,
                        _Credentials.GetAuthFlags(),
                        IID_IDispatch,
                        (void **)ppDispatch
                      );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    VariantClear(&v);

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    RRETURN(hr);
}

HRESULT
CNDSGroupCollectionEnum::GetGroupSingleMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsPathName[MAX_PATH];
    WCHAR szNDSTreeName[MAX_PATH];

    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    *ppDispatch = NULL;

    if (_dwIndex == 1) {
        RRETURN(S_FALSE);
    }

    hr = BuildNDSTreeNameFromADsPath(
                _bstrGroupName,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    // Make the first two characters "//" instead of "\\"
    szNDSTreeName[0] = (WCHAR)'/';
    szNDSTreeName[1] = (WCHAR)'/';

    hr = BuildADsPathFromNDSPath(
            szNDSTreeName,
            _vMembers.bstrVal,
            szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = _Credentials.GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);


    hr = ADsOpenObject(
                        szADsPathName,
                        pszUserName,
                        pszPassword,
                        _Credentials.GetAuthFlags(),
                        IID_IDispatch,
                        (void **)ppDispatch
                      );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CNDSGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGroupMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CNDSGroupCollectionEnum::ValidateVariant(
    VARIANT var
    )
{

    if (V_VT(&var) == (VT_VARIANT|VT_ARRAY)) {

        _dwMultiple = MULTIPLE;
        RRETURN(ValidateMultipleVariant(var));

    }else if (V_VT(&var) == VT_BSTR){

        _dwMultiple = SINGLE;
        RRETURN(ValidateSingleVariant(var));
    }else if (V_VT(&var) == VT_EMPTY){

        _dwMultiple = EMPTY;
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
CNDSGroupCollectionEnum::ValidateMultipleVariant(
    VARIANT var
    )
{

    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;


    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSLBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwSUBound = dwSUBound;
    _dwSLBound = dwSLBound;
    _dwIndex =  dwSLBound;


error:

    RRETURN(hr);
}



HRESULT
CNDSGroupCollectionEnum::ValidateSingleVariant(
    VARIANT var
    )
{
    HRESULT hr = S_OK;

    if(!( V_VT(&var) == VT_BSTR)){
        return(E_FAIL);
    }

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwIndex =  0;

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  NDS Schema Enumeration Code
//
//             CNDSSchemaEnum::CNDSSchemaEnum()
//             CNDSSchemaEnum::CNDSSchemaEnum
//             CNDSSchemaEnum::EnumObjects
//             CNDSSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSSchemaEnum::Create(
    CNDSSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrNDSTreeName,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSSchemaEnum FAR* penumvariant = NULL;
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;

    *ppenumvariant = NULL;

    penumvariant = new CNDSSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrNDSTreeName, &penumvariant->_bstrNDSTreeName);
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    penumvariant->_bstrNDSTreeName,
                    Credentials,
                    &penumvariant->_hTree,
                    szObjectFullName,
                    szObjectClassName,
                    &dwModificationTime,
                    &dwNumberOfEntries
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CNDSSchemaEnum::CNDSSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _bstrNDSTreeName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _dwSyntaxCurrentEntry( 0 )
{
    _hOperationData = NULL;
    _hTree = NULL;
    _lpClassDefs = NULL;

    _dwObjectCurrentEntry = 0;
    _dwObjectReturned = 0;

    _dwInfoType = 0;


    _dwPropCurrentEntry = 0;

    _hPropOperationData = NULL;
    _lpAttrDefs = NULL;

    _dwPropObjectCurrentEntry = 0;
    _dwPropObjectReturned = 0;
    _dwPropInfoType = 0;

}

CNDSSchemaEnum::~CNDSSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );
   ADsFreeString( _bstrNDSTreeName );


   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
                cElements,
                pvar,
                &cElementFetched
                );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case NDS_CLASS_ID:
            RRETURN (EnumClasses(cElements, pvar, pcElementFetched));

        case NDS_PROPERTY_ID:
            RRETURN (EnumProperties(cElements, pvar, pcElementFetched));

    case NDS_SYNTAX_ID:
            RRETURN(EnumSyntaxes(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CNDSSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPNDS_CLASS_DEF lpCurrentObject = NULL;
    DWORD dwStatus;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        dwStatus = NwNdsReadClassDef(
                        _hTree,
                        NDS_INFO_NAMES_DEFS,
                        &_hOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        dwStatus = NwNdsGetClassDefListFromBuffer(
                        _hOperationData,
                        &_dwObjectReturned,
                        &_dwInfoType,
                        (LPVOID *) &_lpClassDefs
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

    }

    if (_dwObjectCurrentEntry < _dwObjectReturned) {

        //
        // Now send back the current object
        //

        lpCurrentObject = _lpClassDefs + _dwObjectCurrentEntry;

        hr = CNDSClass::CreateClass(
                            _bstrADsPath,
                            lpCurrentObject->szClassName,
                            lpCurrentObject,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);
        _dwObjectCurrentEntry++;

        RRETURN(S_OK);

    }

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}



HRESULT
CNDSSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPNDS_ATTR_DEF lpCurrentPropObject = NULL;
    DWORD dwStatus;

    if (!_hPropOperationData || (_dwPropObjectCurrentEntry == _dwPropObjectReturned)) {

        _dwPropObjectCurrentEntry = 0;
        _dwPropObjectReturned = 0;

        dwStatus = NwNdsReadAttrDef(
                        _hTree,
                        NDS_INFO_NAMES_DEFS,
                        &_hPropOperationData
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        dwStatus = NwNdsGetAttrDefListFromBuffer(
                        _hPropOperationData,
                        &_dwPropObjectReturned,
                        &_dwInfoType,
                        (LPVOID *) &_lpAttrDefs
                        );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

    }

    if (_dwPropObjectCurrentEntry < _dwPropObjectReturned) {

        //
        // Now send back the current object
        //

        lpCurrentPropObject = _lpAttrDefs + _dwPropObjectCurrentEntry;

        hr = CNDSProperty::CreateProperty(
                            _bstrADsPath,
                            lpCurrentPropObject->szAttributeName,
                            lpCurrentPropObject,
                            _Credentials,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            (void **)ppDispatch
                            );
        BAIL_ON_FAILURE(hr);
        _dwPropObjectCurrentEntry++;

        RRETURN(S_OK);

    }

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}




HRESULT
CNDSSchemaEnum::EnumSyntaxes(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CNDSSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwSyntaxCurrentEntry >= g_cNDSSyntax )
        goto error;

    hr = CNDSSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aNDSSyntax[_dwSyntaxCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwSyntaxCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNDSNamespaceEnum::Create
//             CNDSNamespaceEnum::CNDSNamespaceEnum
//             CNDSNamespaceEnum::~CNDSNamespaceEnum
//             CNDSNamespaceEnum::Next
//             CNDSNamespaceEnum::FetchObjects
//             CNDSNamespaceEnum::FetchNextObject
//             CNDSNamespaceEnum::PrepBuffer
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

#define ENUM_BUFFER_SIZE (1024 * 16)

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::Create(
    CNDSNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CNDSNamespaceEnum FAR* penumvariant = NULL;
    DWORD dwStatus;

    penumvariant = new CNDSNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

#ifndef WIN95    
    dwStatus = NPOpenEnum(RESOURCE_GLOBALNET,
                          RESOURCETYPE_ANY,
                          0,
                          NULL,
                          &penumvariant->_hEnum);
#else
    dwStatus = WNetOpenEnumA(RESOURCE_GLOBALNET,
                          RESOURCETYPE_ANY,
                          0,
                          NULL,
                          &penumvariant->_hEnum);
#endif
    if (dwStatus != NO_ERROR) {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    if (penumvariant) {
        delete penumvariant;
    }
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::CNDSNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSNamespaceEnum::CNDSNamespaceEnum()
{
    _pObjList = NULL;
    _dwEntriesRead = 0;
    _dwCurrentEntry = 0;
    _hEnum = NULL;
    _pBuffer = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::~CNDSNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSNamespaceEnum::~CNDSNamespaceEnum()
{
    if (_pBuffer)
        FreeADsMem(_pBuffer);

    if ( _pObjList )
        delete _pObjList;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSNamespaceEnum::FetchObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = FetchNextObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::FetchNextObject
//
//  Synopsis:   Gets IDispatch pointer of next object in namespace.
//
//  Arguments:  [ppDispatch] -- Pointer to where to return IDispatch pointer.
//
//  Returns:    HRESULT -- S_OK if got the next object
//                      -- S_FALSE if not
//
//  Modifies:   [*ppDispatch]
//
//  History:    31-Jul-96   t-danal   Use Multiple Network Provider for enum
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::FetchNextObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr;
    DWORD dwStatus;
    LPTSTR lpTreeName ;

    *ppDispatch = NULL;

    //
    // Ensure that the buffer is valid
    //

    hr = PrepBuffer();
    BAIL_ON_FAILURE(hr);

    //
    // Grab next (tree) name out of the buffer
    //

    lpTreeName = (LPWSTR)_pBuffer + (_dwCurrentEntry++  * OBJ_NAME_SIZE) ;


    //
    // Now create and send back the current object
    //

    hr = CNDSTree::CreateTreeObject(
                L"NDS:",
                lpTreeName,
                L"Top",
                _Credentials,
                ADS_OBJECT_BOUND,
                IID_IDispatch,
                (void **)ppDispatch
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_ENUM_STATUS(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceEnum::PrepBuffer
//
//  Synopsis:   Ensures that the enumeration buffer has something
//
//  Arguments:  none
//
//  Returns:    HRESULT -- S_OK if the buffer is ready to be used
//                      -- an error if not
//
//  Modifies:   _pBuffer, _dwCurrentEntry, _dwEntriesRead
//
//  History:    31-Jul-96   t-danal   Created
//
//----------------------------------------------------------------------------
HRESULT
CNDSNamespaceEnum::PrepBuffer()
{
    NWCONN_HANDLE hConn;
    NWOBJ_ID      dwResumeObjectID = 0xFFFFFFFF;
    HRESULT       hr = S_OK;
    DWORD         cb = ENUM_BUFFER_SIZE;
    LPWSTR        lpString = NULL, pszObjectName = NULL;
    DWORD         dwIter = 0, i;
    BOOL          fFound ;

    //
    // Fill buffer as need. In theory we can get called to refill.
    // But since we need get everything to remove dups in
    // th case of TREEs, we dont allow this case. Ie. we get all
    // and there should be no more. So if _dwCurrentEntry is not
    // 0 and we need read more - then its time to bail.
    //

    if ( (_dwCurrentEntry < _dwEntriesRead) ) {
        //
        // Buffer still good
        //
        ADsAssert(_pBuffer) ;
        return(S_OK) ;
    }

    if (_dwCurrentEntry != 0) {
        return (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    //
    // Allocate buffer, if needed
    //

    if (!_pBuffer) {
        _pBuffer = AllocADsMem(cb);
        if (!_pBuffer) {
            hr = E_OUTOFMEMORY;
            RRETURN(hr);
        }
        lpString = (LPWSTR) _pBuffer ;
        _pBufferEnd = (LPBYTE)_pBuffer + cb ;
    }

    //
    // Get handle
    //
    hr = NWApiGetAnyBinderyHandle(
             &hConn
             );

    if FAILED(hr) {
        return(hr) ;
    }

    _dwEntriesRead = 0 ;

    do {
        hr = NWApiObjectEnum(
             hConn,
             OT_DIRSERVER,
             &pszObjectName,
             &dwResumeObjectID
             );

        if (FAILED(hr)) {

            if (_dwEntriesRead > 0)
                hr = S_OK ;

            break ;
        }

        //
        // Remove any trailing '_' upto 32 chars. This is standard NDS tree
        // naming stuff.
        //

        dwIter = 31;
        while (pszObjectName[dwIter] == L'_' && dwIter > 0 ) {
            dwIter--;
        }
        pszObjectName[dwIter + 1] =L'\0';

        //
        // Scan for duplicates. We are doing linear everytime, but then again,
        // there shouldnt be many trees.
        //

        fFound = FALSE ;
        for (i = 0; i < _dwEntriesRead; i++) {

            if (_wcsicmp(
                    pszObjectName,
                    (LPWSTR)_pBuffer + (i * OBJ_NAME_SIZE)) == 0) {

                fFound = TRUE ;
                break ;
            }
        }

        //
        // Copy this unique tree name into the buffer
        //

        if (!fFound) {

            //
            // Check that we have enough space.
            //
            if ((lpString + OBJ_NAME_SIZE) >= _pBufferEnd) {

                cb = (DWORD) ((LPBYTE)_pBufferEnd - (LPBYTE)_pBuffer) ;
                _pBuffer = ReallocADsMem(
                               _pBuffer,
                               cb,
                               2 * cb
                               );

                if (!_pBuffer) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }

                lpString = (LPWSTR)_pBuffer + (_dwEntriesRead * OBJ_NAME_SIZE) ;
                _pBufferEnd = (LPBYTE) _pBuffer + (2 * cb) ;
            }

            //
            // Assume fixed size (max NW name). Yes, its more than
            // we really need but keeps things simpler.
            //

            wcscpy(lpString, pszObjectName);
            lpString += OBJ_NAME_SIZE ;
            _dwEntriesRead++ ;
        }
        FreeADsStr(pszObjectName) ;
        pszObjectName = NULL;


    } while (TRUE) ;


error:
    if (pszObjectName) {
                FreeADsStr(pszObjectName);
        }
        (void) NWApiReleaseBinderyHandle(hConn);
    RRETURN(hr);
}

HRESULT
CNDSNamespaceEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType) {

    case NDS_TREE_ID:
        RRETURN (FetchObjects(cElements, pvar, pcElementFetched));

    default:
        RRETURN(S_FALSE);
    }
}

HRESULT
CNDSNamespaceEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = E_FAIL;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumUserCollection.cxx
//
//  Contents:  Windows NT 3.5 UserCollection Enumeration Code
//
//              CNDSUserCollectionEnum::CNDSUserCollectionEnum()
//              CNDSUserCollectionEnum::CNDSUserCollectionEnum
//              CNDSUserCollectionEnum::EnumObjects
//              CNDSUserCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSUserCollectionEnum::Create(
    BSTR bstrUserName,
    CNDSUserCollectionEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CNDSUserCollectionEnum FAR* penumvariant = NULL;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;

    *ppenumvariant = NULL;

    penumvariant = new CNDSUserCollectionEnum();


    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    hr = ADsAllocString(bstrUserName, &(penumvariant->_bstrUserName));
    BAIL_ON_FAILURE(hr);

    hr = penumvariant->ValidateVariant(
                    var
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN(hr);

}

CNDSUserCollectionEnum::CNDSUserCollectionEnum():
        _dwSLBound(0),
        _dwSUBound(0),
        _dwIndex(0),
        _bstrUserName(0),
        _dwMultiple(0)
{
    VariantInit(&_vMembers);
}



CNDSUserCollectionEnum::~CNDSUserCollectionEnum()
{
    VariantClear(&_vMembers);
}

HRESULT
CNDSUserCollectionEnum::EnumUserMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        if (_dwMultiple == MULTIPLE) {
            hr = GetUserMultipleMemberObject(&pDispatch);
        }else if (_dwMultiple == SINGLE){
            hr = GetUserSingleMemberObject(&pDispatch);
        }else {
            hr = S_FALSE;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}


HRESULT
CNDSUserCollectionEnum::GetUserMultipleMemberObject(
    IDispatch ** ppDispatch
    )
{

    VARIANT v;
    HRESULT hr = S_OK;
    WCHAR szADsPathName[MAX_PATH];
    WCHAR szNDSTreeName[MAX_PATH];

    *ppDispatch = NULL;

    if (_dwIndex > _dwSUBound) {
        RRETURN(S_FALSE);
    }

    VariantInit(&v);

    hr = SafeArrayGetElement(
                V_ARRAY(&_vMembers),
                (long FAR *)&_dwIndex,
                &v
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSTreeNameFromADsPath(
                _bstrUserName,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    // Make the first two characters "//" instead of "\\"
    szNDSTreeName[0] = (WCHAR)'/';
    szNDSTreeName[1] = (WCHAR)'/';

    hr = BuildADsPathFromNDSPath(
            szNDSTreeName,
            v.bstrVal,
            szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = CNDSGenObject::CreateGenericObject(
                        szADsPathName,
                        L"group",
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;


error:

    VariantClear(&v);

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    RRETURN(hr);
}

HRESULT
CNDSUserCollectionEnum::GetUserSingleMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsPathName[MAX_PATH];
    WCHAR szNDSTreeName[MAX_PATH];

    *ppDispatch = NULL;

    if (_dwIndex == 1) {
        RRETURN(S_FALSE);
    }

    hr = BuildNDSTreeNameFromADsPath(
                _bstrUserName,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    // Make the first two characters "//" instead of "\\"
    szNDSTreeName[0] = (WCHAR)'/';
    szNDSTreeName[1] = (WCHAR)'/';

    hr = BuildADsPathFromNDSPath(
            szNDSTreeName,
            _vMembers.bstrVal,
            szADsPathName
            );
    BAIL_ON_FAILURE(hr);

    hr = CNDSGenObject::CreateGenericObject(
                        szADsPathName,
                        L"group",
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwIndex++;

error:

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSUserCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSUserCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumUserMembers(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}



HRESULT
CNDSUserCollectionEnum::ValidateVariant(
    VARIANT var
    )
{

    if (V_VT(&var) == (VT_VARIANT|VT_ARRAY)) {

        _dwMultiple = MULTIPLE;
        RRETURN(ValidateMultipleVariant(var));

    }else if (V_VT(&var) == VT_BSTR){

        _dwMultiple = SINGLE;
        RRETURN(ValidateSingleVariant(var));
    }else if (V_VT(&var) == VT_EMPTY){

        _dwMultiple = EMPTY;
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}

HRESULT
CNDSUserCollectionEnum::ValidateMultipleVariant(
    VARIANT var
    )
{

    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;


    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSLBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
                V_ARRAY(&var),
                1,
                (long FAR *)&dwSUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwSUBound = dwSUBound;
    _dwSLBound = dwSLBound;
    _dwIndex =  dwSLBound;


error:

    RRETURN(hr);
}



HRESULT
CNDSUserCollectionEnum::ValidateSingleVariant(
    VARIANT var
    )
{
    HRESULT hr = S_OK;

    if(!( V_VT(&var) == VT_BSTR)){
        return(E_FAIL);
    }

    hr = VariantCopy(&_vMembers, &var);
    BAIL_ON_FAILURE(hr);

    _dwIndex =  0;

error:

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CNDSEnumVariant::Create
//             CNDSEnumVariant::CNDSEnumVariant
//             CNDSEnumVariant::~CNDSEnumVariant
//             CNDSEnumVariant::QueryInterface
//             CNDSEnumVariant::AddRef
//             CNDSEnumVariant::Release
//             CNDSEnumVariant::Next
//             CNDSEnumVariant::Skip
//             CNDSEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::CNDSEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSEnumVariant::CNDSEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::~CNDSEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CNDSEnumVariant::~CNDSEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNDSEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CNDSEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Skip(ULONG cElements)
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Reset()
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cenumt.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  NDS Object Enumeration Code
//
//              CNDSTreeEnum::CNDSTreeEnum()
//              CNDSTreeEnum::CNDSTreeEnum
//              CNDSTreeEnum::EnumObjects
//              CNDSTreeEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CNDSTreeEnum::Create(
    CNDSTreeEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CNDSTreeEnum FAR* penumvariant = NULL;
    WCHAR szObjectFullName[MAX_PATH];
    WCHAR szObjectClassName[MAX_PATH];
    LPWSTR pszNDSPath = NULL;
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    DWORD dwStatus = 0L;

    *ppenumvariant = NULL;

    penumvariant = new CNDSTreeEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSFilterArray(
                var,
                (LPBYTE *)&penumvariant->_pNdsFilterList
                );
    if (FAILED(hr)) {
        penumvariant->_pNdsFilterList = NULL;
    }

    /*
    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);
    */
    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    hr = BuildNDSPathFromADsPath(
                ADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPath,
                    Credentials,
                    &penumvariant->_hObject,
                    szObjectFullName,
                    szObjectClassName,
                    &dwModificationTime,
                    &dwNumberOfEntries
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN(hr);

error:
    delete penumvariant;
    *ppenumvariant = NULL;

    if (pszNDSPath) {

        FreeADsStr(pszNDSPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}

CNDSTreeEnum::CNDSTreeEnum():
                    _ADsPath(NULL)
{
    _pObjList = NULL;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _hObject = NULL;
    _hOperationData = NULL;
    _lpObjects = NULL;
    _pNdsFilterList = NULL;

    _fSchemaReturned = NULL;
    _bNoMore = FALSE;
}


CNDSTreeEnum::~CNDSTreeEnum()
{
    if (_pNdsFilterList) {
        FreeFilterList((LPBYTE)_pNdsFilterList);
    }
}

HRESULT
CNDSTreeEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGenObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CNDSTreeEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;
    LPNDS_OBJECT_INFO lpCurrentObject = NULL;
    IADs * pADs = NULL;

    *ppDispatch = NULL;

    if (!_hOperationData || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_hOperationData) {
            dwStatus = NwNdsFreeBuffer(_hOperationData);
            _hOperationData = NULL;
            _lpObjects = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        //
        // Insert NDS code in here
        //
        if (_bNoMore) {
            RRETURN(S_FALSE);
        }

        dwStatus = NwNdsListSubObjects(
                            _hObject,
                            MAX_CACHE_SIZE,
                            &_dwObjectReturned,
                            _pNdsFilterList,
                            &_hOperationData
                            );
        if ((dwStatus != ERROR_SUCCESS) && (dwStatus != WN_NO_MORE_ENTRIES)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (dwStatus == WN_NO_MORE_ENTRIES) {
            _bNoMore = TRUE;
        }

        dwStatus = NwNdsGetObjectListFromBuffer(
                            _hOperationData,
                            &_dwObjectReturned,
                            NULL,
                            &_lpObjects
                            );
        if (dwStatus != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now send back the current object
    //

    lpCurrentObject = _lpObjects + _dwObjectCurrentEntry;

    hr = CNDSGenObject::CreateGenericObject(
                        _ADsPath,
                        lpCurrentObject->szObjectName,
                        lpCurrentObject->szObjectClass,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
        BAIL_ON_FAILURE(hr);
    }

    _dwObjectCurrentEntry++;


error:

    //
    // GetGenObject returns only S_FALSE
    //

    if (FAILED(hr)) {
        hr = S_FALSE;
    }

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSTreeEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSTreeEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSTreeEnum::EnumSchema(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
)
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;

    if ( _fSchemaReturned )
        RRETURN(S_FALSE);

    if ( cElements > 0 )
    {
        hr = CNDSSchema::CreateSchema(
                  _ADsPath,
                  TEXT("Schema"),
                  _Credentials,
                  ADS_OBJECT_BOUND,
                  IID_IDispatch,
                  (void **)&pDispatch
                  );

        if ( hr == S_OK )
        {
            VariantInit(&pvar[0]);
            pvar[0].vt = VT_DISPATCH;
            pvar[0].pdispVal = pDispatch;
            (*pcElementFetched)++;
            _fSchemaReturned = TRUE;
        }
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "nds.hxx"

//  Class CNDSGroupCollection

DEFINE_IDispatch_Implementation(CNDSGroupCollection)


CNDSGroupCollection::CNDSGroupCollection():
        _ADsPath(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNDSGroupCollection);
}


HRESULT
CNDSGroupCollection::CreateGroupCollection(
    BSTR bstrADsPath,
    VARIANT varMembers,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(Credentials, &pGroup);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(bstrADsPath, &(pGroup->_ADsPath));
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&(pGroup->_vMembers), &varMembers);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSGroupCollection::~CNDSGroupCollection( )
{
    VariantClear(&_vMembers);
    VariantClear(&_vFilter);
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }
    delete _pDispMgr;
}

STDMETHODIMP
CNDSGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSGroupCollection::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{

    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNDSGroupCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSGroupCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    if (!pVar) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGroupCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    if (!retval) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    *retval = NULL;

    hr = CNDSGroupCollectionEnum::Create(
                _ADsPath,
                _Credentials,
                (CNDSGroupCollectionEnum **)&penum,
                _vMembers,
                _vFilter
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSGroupCollection::AllocateGroupCollectionObject(
    CCredentials& Credentials,
    CNDSGroupCollection ** ppGroup
    )
{
    CNDSGroupCollection FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CNDSGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pGroup,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pGroup->_Credentials = Credentials;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cexsyncf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 NDS Security Class Factory Code
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

STDMETHODIMP
CCaseIgnoreListCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CCaseIgnoreList::CreateCaseIgnoreList(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CFaxNumberCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CFaxNumber::CreateFaxNumber(
                iid,
                ppv
                );

    RRETURN(hr);
}


STDMETHODIMP
CNetAddressCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNetAddress::CreateNetAddress(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
COctetListCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = COctetList::CreateOctetList(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CEmailCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CEmail::CreateEmail(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CPathCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPath::CreatePath(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CReplicaPointerCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CReplicaPointer::CreateReplicaPointer(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CTimestampCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CTimestamp::CreateTimestamp(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CPostalAddressCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPostalAddress::CreatePostalAddress(
                iid,
                ppv
                );

    RRETURN(hr);
}
STDMETHODIMP
CBackLinkCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CBackLink::CreateBackLink(
                iid,
                ppv
                );

    RRETURN(hr);
}


STDMETHODIMP
CTypedNameCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CTypedName::CreateTypedName(
                iid,
                ppv
                );

    RRETURN(hr);
}

STDMETHODIMP
CHoldCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CHold::CreateHold(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cexsyn.cxx ===
#include "nds.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////
HRESULT
ConvertStringArrayToSafeBstrArray(
    LPWSTR *prgszArray,
    DWORD dwNumElement,
    VARIANT *pvarSafeArray
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress;

    if ((!prgszArray) || (!pvarSafeArray)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = dwNumElement;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long)dwNumElement; i++ ) {
        VARIANT v;
        VariantInit(&v);

        v.vt = VT_BSTR;
        hr = ADsAllocString(
                prgszArray[i],
                &v.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v);
        BAIL_ON_FAILURE(hr);
        VariantClear(&v);
    }

    V_VT(pvarSafeArray) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarSafeArray) = aList;

    RRETURN(hr);

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

HRESULT
ConvertSafeBstrArrayToStringArray(
    VARIANT varSafeArray,
    LPWSTR **prgszArray,
    PDWORD pdwNumElement
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    LPWSTR* rgszArray = NULL;
    SAFEARRAY * pArray = NULL;

    if ((!prgszArray ) || (!pdwNumElement)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *pdwNumElement = 0;
    *prgszArray = NULL;

    if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
        RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    rgszArray = (LPWSTR*)AllocADsMem(
                                sizeof(LPWSTR)*dwNumVariants
                                );
    if (!rgszArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_VT(&varSafeArray) & VT_VARIANT) == VT_BSTR) {
        BSTR bstrElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &bstrElement
                                    );
            BAIL_ON_FAILURE(hr);

            rgszArray[i-dwSLBound] = AllocADsStr(bstrElement);
            if (!rgszArray[i-dwSLBound]) {
                hr = E_OUTOFMEMORY;
            }
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        VARIANT varElement;
        for (i = dwSLBound; i <= dwSUBound; i++) {
            VariantInit(&varElement);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &varElement
                                    );
            BAIL_ON_FAILURE(hr);

            rgszArray[i-dwSLBound] = AllocADsStr(V_BSTR(&varElement));
            if (!rgszArray[i-dwSLBound]) {
                hr = E_OUTOFMEMORY;
            }
            BAIL_ON_FAILURE(hr);
            VariantClear(&varElement);
        }
    }

    *prgszArray = rgszArray;
    *pdwNumElement = dwNumVariants;
    RRETURN(hr);

error:
    if (rgszArray) {
        FreeADsMem(rgszArray);
    }
    RRETURN(hr);
}

HRESULT
ConvertBinaryArrayToSafeVariantArray(
    POctetString *prgArray,
    DWORD dwNumElement,
    VARIANT *pvarSafeArray
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    VARIANT var;

    if ((!prgArray) || (!pvarSafeArray)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    aBound.lLbound = 0;
    aBound.cElements = dwNumElement;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long)dwNumElement; i++ )
    {
        hr = BinaryToVariant(
                                (prgArray[i])->Length,
                                (prgArray[i])->Value,
                                &var);
        BAIL_ON_FAILURE(hr);
        hr = SafeArrayPutElement( aList, &i, &var);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pvarSafeArray) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarSafeArray) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

HRESULT
ConvertSafeVariantArrayToBinaryArray(
    VARIANT varSafeArray,
    POctetString **prgArray,
    PDWORD pdwNumElement
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    LONG  cIterations = 0; 
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    POctetString *rgArray = NULL;
    SAFEARRAY * pArray = NULL;
    VARIANT var;

    if ((!prgArray ) || (!pdwNumElement)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *pdwNumElement = 0;
    *prgArray = NULL;

    if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
        RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //
    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    rgArray = (POctetString*)AllocADsMem(
                                sizeof(POctetString)*dwNumVariants
                                );
    if (!rgArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        
        rgArray[i-dwSLBound] = (POctetString)AllocADsMem(sizeof(OctetString));
        if (!rgArray[i-dwSLBound]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        rgArray[i-dwSLBound]->Value = NULL;
        cIterations++;
        
        VariantInit(&var);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                &var
                                );
        BAIL_ON_FAILURE(hr);
        
        hr = VariantToBinary(
                &var,
                &(rgArray[i-dwSLBound]->Length),
                &(rgArray[i-dwSLBound]->Value));
        BAIL_ON_FAILURE(hr);

    }

    *prgArray = rgArray;
    *pdwNumElement = dwNumVariants;
    RRETURN(hr);

error:
    if (rgArray) {

        for (i = dwSLBound; i < dwSLBound + cIterations; i++) {
            if (rgArray[i-dwSLBound]) {

                if (rgArray[i-dwSLBound]->Value)
                    FreeADsMem(rgArray[i-dwSLBound]->Value);

                FreeADsMem(rgArray[i-dwSLBound]);
            }
        }

        FreeADsMem(rgArray);
    }
    RRETURN(hr);
}
DEFINE_IDispatch_Implementation(CCaseIgnoreList)

CCaseIgnoreList::CCaseIgnoreList():
        _pDispMgr(NULL),
        _rgszCaseIgnoreList(NULL),
        _dwNumElement(0)
{
    ENLIST_TRACKING(CCaseIgnoreList);
}


HRESULT
CCaseIgnoreList::CreateCaseIgnoreList(
    REFIID riid,
    void **ppvObj
    )
{
    CCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    HRESULT hr = S_OK;

    hr = AllocateCaseIgnoreListObject(&pCaseIgnoreList);
    BAIL_ON_FAILURE(hr);

    hr = pCaseIgnoreList->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pCaseIgnoreList->Release();

    RRETURN(hr);

error:
    delete pCaseIgnoreList;

    RRETURN(hr);

}


CCaseIgnoreList::~CCaseIgnoreList( )
{
    delete _pDispMgr;
    if (_rgszCaseIgnoreList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszCaseIgnoreList[i]) {
                FreeADsStr(_rgszCaseIgnoreList[i]);
            }
        }
        FreeADsMem(_rgszCaseIgnoreList);
    }
}

STDMETHODIMP
CCaseIgnoreList::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsCaseIgnoreList))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsCaseIgnoreList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CCaseIgnoreList::AllocateCaseIgnoreListObject(
    CCaseIgnoreList ** ppCaseIgnoreList
    )
{
    CCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pCaseIgnoreList = new CCaseIgnoreList();
    if (pCaseIgnoreList == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsCaseIgnoreList,
                (IADsCaseIgnoreList *)pCaseIgnoreList,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pCaseIgnoreList->_pDispMgr = pDispMgr;
    *ppCaseIgnoreList = pCaseIgnoreList;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CCaseIgnoreList::get_CaseIgnoreList(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertStringArrayToSafeBstrArray(
                                    _rgszCaseIgnoreList,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
CCaseIgnoreList::put_CaseIgnoreList(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    if (_rgszCaseIgnoreList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszCaseIgnoreList[i]) {
                FreeADsStr(_rgszCaseIgnoreList[i]);
            }
        }
        FreeADsMem(_rgszCaseIgnoreList);
        _rgszCaseIgnoreList = NULL;
        _dwNumElement = 0;
    }
    hr = ConvertSafeBstrArrayToStringArray(
                                    VarSrcObject,
                                    &_rgszCaseIgnoreList,
                                    &_dwNumElement);
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CFaxNumber)

CFaxNumber::CFaxNumber():
        _pDispMgr(NULL),
        _szTelephoneNumber(NULL),
        _NumberOfBits(0),
        _Parameters(NULL)
{
    ENLIST_TRACKING(CFaxNumber);
}


HRESULT
CFaxNumber::CreateFaxNumber(
    REFIID riid,
    void **ppvObj
    )
{
    CFaxNumber FAR * pFaxNumber = NULL;
    HRESULT hr = S_OK;

    hr = AllocateFaxNumberObject(&pFaxNumber);
    BAIL_ON_FAILURE(hr);

    hr = pFaxNumber->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pFaxNumber->Release();

    RRETURN(hr);

error:
    delete pFaxNumber;

    RRETURN(hr);

}


CFaxNumber::~CFaxNumber( )
{
    delete _pDispMgr;
    if (_szTelephoneNumber) {
        FreeADsStr(_szTelephoneNumber);
    }
    if (_Parameters) {
        FreeADsMem(_Parameters);
    }
}

STDMETHODIMP
CFaxNumber::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsFaxNumber))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsFaxNumber FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CFaxNumber::AllocateFaxNumberObject(
    CFaxNumber ** ppFaxNumber
    )
{
    CFaxNumber FAR * pFaxNumber = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pFaxNumber = new CFaxNumber();
    if (pFaxNumber == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsFaxNumber,
                (IADsFaxNumber *)pFaxNumber,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pFaxNumber->_pDispMgr = pDispMgr;
    *ppFaxNumber = pFaxNumber;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CFaxNumber::get_Parameters(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = _NumberOfBits;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList,
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _Parameters,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

STDMETHODIMP
CFaxNumber::put_Parameters(THIS_ VARIANT VarSrcObject)
{

    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    VARIANT *pVarSrcObject = &VarSrcObject;

    if (_Parameters) {
        FreeADsMem(_Parameters);
    }

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _Parameters =
        (BYTE*) AllocADsMem( dwSUBound - dwSLBound + 1);
    if ( _Parameters == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _NumberOfBits = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _Parameters,
            pArray,
            _NumberOfBits);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

error:

    RRETURN(hr);
}

STDMETHODIMP
CFaxNumber::get_TelephoneNumber(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;
    hr = ADsAllocString(_szTelephoneNumber,
                        retval);
    RRETURN(hr);

}

STDMETHODIMP
CFaxNumber::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    if (_szTelephoneNumber) {
        FreeADsStr(_szTelephoneNumber);
    }

    _szTelephoneNumber = AllocADsStr(bstrTelephoneNumber);

    if (!_szTelephoneNumber) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}

DEFINE_IDispatch_Implementation(CNetAddress)

CNetAddress::CNetAddress():
        _pDispMgr(NULL),
        _dwAddressType(0),
        _dwAddressLength(0),
        _pbAddress(NULL)
{
    ENLIST_TRACKING(CNetAddress);
}


HRESULT
CNetAddress::CreateNetAddress(
    REFIID riid,
    void **ppvObj
    )
{
    CNetAddress FAR * pNetAddress = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNetAddressObject(&pNetAddress);
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNetAddress->Release();

    RRETURN(hr);

error:
    delete pNetAddress;

    RRETURN(hr);

}


CNetAddress::~CNetAddress( )
{
    delete _pDispMgr;
    if (_pbAddress) {
        FreeADsMem(_pbAddress);
    }
}

STDMETHODIMP
CNetAddress::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsNetAddress))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsNetAddress FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNetAddress::AllocateNetAddressObject(
    CNetAddress ** ppNetAddress
    )
{
    CNetAddress FAR * pNetAddress = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNetAddress = new CNetAddress();
    if (pNetAddress == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsNetAddress,
                (IADsNetAddress *)pNetAddress,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pNetAddress->_pDispMgr = pDispMgr;
    *ppNetAddress = pNetAddress;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CNetAddress::get_AddressType(THIS_ long FAR * retval)
{
    *retval = _dwAddressType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNetAddress::put_AddressType(THIS_ long lnAddressType)
{
    _dwAddressType = lnAddressType;
    RRETURN(S_OK);
}


STDMETHODIMP
CNetAddress::get_Address(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = _dwAddressLength;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _pbAddress,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

STDMETHODIMP
CNetAddress::put_Address(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    VARIANT *pVarSrcObject = &VarSrcObject;

    if (_pbAddress) {
        FreeADsMem(_pbAddress);
    }

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _pbAddress =
        (BYTE*) AllocADsMem( dwSUBound - dwSLBound + 1);

    if ( _pbAddress == NULL)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _dwAddressLength = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _pbAddress,
            pArray,
            _dwAddressLength );
    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );
error:
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(COctetList)

COctetList::COctetList():
        _pDispMgr(NULL),
        _rgOctetList(NULL)
{
    ENLIST_TRACKING(COctetList);
}


HRESULT
COctetList::CreateOctetList(
    REFIID riid,
    void **ppvObj
    )
{
    COctetList FAR * pOctetList = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOctetListObject(&pOctetList);
    BAIL_ON_FAILURE(hr);

    hr = pOctetList->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOctetList->Release();

    RRETURN(hr);

error:
    delete pOctetList;

    RRETURN(hr);

}


COctetList::~COctetList( )
{
    delete _pDispMgr;
    if (_rgOctetList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgOctetList[i]) {
                FreeADsMem(_rgOctetList[i]);
            }
        }
        FreeADsMem(_rgOctetList);
    }
}

STDMETHODIMP
COctetList::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOctetList))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsOctetList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
COctetList::AllocateOctetListObject(
    COctetList ** ppOctetList
    )
{
    COctetList FAR * pOctetList = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pOctetList = new COctetList();
    if (pOctetList == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsOctetList,
                (IADsOctetList *)pOctetList,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pOctetList->_pDispMgr = pDispMgr;
    *ppOctetList = pOctetList;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
COctetList::get_OctetList(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertBinaryArrayToSafeVariantArray(
                                    _rgOctetList,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
COctetList::put_OctetList(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    if (_rgOctetList) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgOctetList[i]) {
                FreeADsMem(_rgOctetList[i]);
            }
        }
        FreeADsMem(_rgOctetList);
    }
    hr = ConvertSafeVariantArrayToBinaryArray(
                                    VarSrcObject,
                                    &_rgOctetList,
                                    &_dwNumElement);
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CEmail)

CEmail::CEmail():
        _pDispMgr(NULL),
        _szAddress(NULL),
        _dwType(0)
{
    ENLIST_TRACKING(CEmail);
}


HRESULT
CEmail::CreateEmail(
    REFIID riid,
    void **ppvObj
    )
{
    CEmail FAR * pEmail = NULL;
    HRESULT hr = S_OK;

    hr = AllocateEmailObject(&pEmail);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pEmail->Release();

    RRETURN(hr);

error:
    delete pEmail;

    RRETURN(hr);

}


CEmail::~CEmail( )
{
    delete _pDispMgr;
    if (_szAddress) {
        FreeADsStr(_szAddress);
    }
}

STDMETHODIMP
CEmail::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsEmail))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsEmail FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CEmail::AllocateEmailObject(
    CEmail ** ppEmail
    )
{
    CEmail FAR * pEmail = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pEmail = new CEmail();
    if (pEmail == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsEmail,
                (IADsEmail *)pEmail,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pEmail->_pDispMgr = pDispMgr;
    *ppEmail = pEmail;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CEmail::get_Address(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_szAddress, retval);
    RRETURN(hr);

}

STDMETHODIMP
CEmail::put_Address(THIS_ BSTR bstrAddress)
{
    if (!bstrAddress) {
        RRETURN(E_FAIL);
    }

    if (_szAddress) {
        FreeADsStr(_szAddress);
    }

    _szAddress = AllocADsStr(bstrAddress);
    if (!_szAddress) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CEmail::get_Type(THIS_ long FAR * retval)
{
    *retval = _dwType;
    RRETURN(S_OK);
}

STDMETHODIMP
CEmail::put_Type(THIS_ long lnType)
{
    _dwType = lnType;
    RRETURN(S_OK);
}



DEFINE_IDispatch_Implementation(CPath)

CPath::CPath():
        _pDispMgr(NULL),
        _dwType(0),
        _lpVolumeName(NULL),
        _lpPath(NULL)
{
    ENLIST_TRACKING(CPath);
}


HRESULT
CPath::CreatePath(
    REFIID riid,
    void **ppvObj
    )
{
    CPath FAR * pPath = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePathObject(&pPath);
    BAIL_ON_FAILURE(hr);

    hr = pPath->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPath->Release();

    RRETURN(hr);

error:
    delete pPath;

    RRETURN(hr);

}


CPath::~CPath( )
{
    delete _pDispMgr;
    if (_lpVolumeName) {
        FreeADsStr(_lpVolumeName);
    }
    if (_lpPath) {
        FreeADsStr(_lpPath);
    }
}

STDMETHODIMP
CPath::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPath))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPath FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPath::AllocatePathObject(
    CPath ** ppPath
    )
{
    CPath FAR * pPath = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPath = new CPath();
    if (pPath == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPath,
                (IADsPath *)pPath,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPath->_pDispMgr = pDispMgr;
    *ppPath = pPath;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CPath::get_Type(THIS_ long FAR * retval)
{
    *retval = _dwType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPath::put_Type(THIS_ long lnType)
{
    _dwType = lnType;
    RRETURN(S_OK);
}


STDMETHODIMP
CPath::get_VolumeName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpVolumeName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CPath::put_VolumeName(THIS_ BSTR bstrVolumeName)
{

    if (!bstrVolumeName) {
        RRETURN(E_FAIL);
    }

    if (_lpVolumeName) {
        FreeADsStr(_lpVolumeName);
    }

    _lpVolumeName= AllocADsStr(bstrVolumeName);

    if (!_lpVolumeName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CPath::get_Path(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpPath, retval);
    RRETURN(hr);

}

STDMETHODIMP
CPath::put_Path(THIS_ BSTR bstrPath)
{
    if (!bstrPath) {
        RRETURN(E_FAIL);
    }

    if (_lpPath) {
        FreeADsStr(_lpPath);
    }

    _lpPath= AllocADsStr(bstrPath);

    if (!_lpPath) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CReplicaPointer)

CReplicaPointer::CReplicaPointer():
        _pDispMgr(NULL),
        _lpServerName(NULL),
        _dwReplicaType(0),
        _dwReplicaNumber(0),
        _dwCount(0)
{
    ENLIST_TRACKING(CReplicaPointer);
    _ReplicaAddressHints.AddressType = 0;
    _ReplicaAddressHints.AddressLength = 0;
    _ReplicaAddressHints.Address = NULL;
}


HRESULT
CReplicaPointer::CreateReplicaPointer(
    REFIID riid,
    void **ppvObj
    )
{
    CReplicaPointer FAR * pReplicaPointer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateReplicaPointerObject(&pReplicaPointer);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pReplicaPointer->Release();

    RRETURN(hr);

error:
    delete pReplicaPointer;

    RRETURN(hr);
}


CReplicaPointer::~CReplicaPointer( )
{
    delete _pDispMgr;
    if (_lpServerName) {
        FreeADsStr(_lpServerName);
    }
    if (_ReplicaAddressHints.Address) {
        FreeADsMem(_ReplicaAddressHints.Address);
    }
}

STDMETHODIMP
CReplicaPointer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsReplicaPointer))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsReplicaPointer FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CReplicaPointer::AllocateReplicaPointerObject(
    CReplicaPointer ** ppReplicaPointer
    )
{
    CReplicaPointer FAR * pReplicaPointer = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pReplicaPointer = new CReplicaPointer();
    if (pReplicaPointer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsReplicaPointer,
                (IADsReplicaPointer *)pReplicaPointer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pReplicaPointer->_pDispMgr = pDispMgr;
    *ppReplicaPointer = pReplicaPointer;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CReplicaPointer::get_ReplicaType(THIS_ long FAR * retval)
{
    *retval = _dwReplicaType;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaType(THIS_ long lnReplicaType)
{
    _dwReplicaType = lnReplicaType;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::get_ReplicaNumber(THIS_ long FAR * retval)
{
    *retval = _dwReplicaNumber;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaNumber(THIS_ long lnReplicaNumber)
{
    _dwReplicaNumber = lnReplicaNumber;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::get_Count(THIS_ long FAR * retval)
{
    *retval = _dwCount;
    RRETURN(S_OK);
}

STDMETHODIMP
CReplicaPointer::put_Count(THIS_ long lnCount)
{

    _dwCount = lnCount;
    RRETURN(S_OK);
}


STDMETHODIMP
CReplicaPointer::get_ServerName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpServerName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CReplicaPointer::put_ServerName(THIS_ BSTR bstrServerName)
{

    if (!bstrServerName) {
        RRETURN(E_FAIL);
    }

    if (_lpServerName) {
        FreeADsStr(_lpServerName);
    }

    _lpServerName= AllocADsStr(bstrServerName);

    if (!_lpServerName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CReplicaPointer::get_ReplicaAddressHints(THIS_ VARIANT* pValAddress)
{
    HRESULT hr = S_OK;
    NDSOBJECT object;

    memcpy(&object.NdsValue.value_12,
           &_ReplicaAddressHints,
           sizeof(NDS_ASN1_TYPE_12));

    hr = NdsTypeToVarTypeCopyNDSSynId12(
                            &object,
                            pValAddress
                            );
    RRETURN(hr);
}

STDMETHODIMP
CReplicaPointer::put_ReplicaAddressHints(THIS_ VARIANT ValAddress)
{
    HRESULT hr;
    NDSOBJECT object;

    if (_ReplicaAddressHints.Address) {
        FreeADsMem(_ReplicaAddressHints.Address);
    }

    hr = VarTypeToNdsTypeCopyNDSSynId12(
                            &ValAddress,
                            &object
                            );
    BAIL_ON_FAILURE(hr);
    memcpy(&_ReplicaAddressHints,
           &object.NdsValue.value_12,
           sizeof(NDS_ASN1_TYPE_12));
error:
    RRETURN(hr);
}

DEFINE_IDispatch_Implementation(CTimestamp)

CTimestamp::CTimestamp():
        _pDispMgr(NULL),
        _dwWholeSeconds(0),
        _dwEventID(0)
{
    ENLIST_TRACKING(CTimestamp);
}


HRESULT
CTimestamp::CreateTimestamp(
    REFIID riid,
    void **ppvObj
    )
{
    CTimestamp FAR * pTime = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTimestampObject(&pTime);
    BAIL_ON_FAILURE(hr);

    hr = pTime->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTime->Release();

    RRETURN(hr);

error:
    delete pTime;

    RRETURN(hr);

}


CTimestamp::~CTimestamp( )
{
    delete _pDispMgr;
}

STDMETHODIMP
CTimestamp::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsTimestamp))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsTimestamp FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CTimestamp::AllocateTimestampObject(
    CTimestamp ** ppTime
    )
{
    CTimestamp FAR * pTime = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pTime = new CTimestamp();
    if (pTime == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsTimestamp,
                (IADsTimestamp *)pTime,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pTime->_pDispMgr = pDispMgr;
    *ppTime = pTime;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CTimestamp::get_WholeSeconds(THIS_ long FAR * retval)
{
    *retval = _dwWholeSeconds;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::put_WholeSeconds(THIS_ long lnWholeSeconds)
{
    _dwWholeSeconds = lnWholeSeconds;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::get_EventID(THIS_ long FAR * retval)
{
    *retval = _dwEventID;
    RRETURN(S_OK);
}

STDMETHODIMP
CTimestamp::put_EventID(THIS_ long lnEventID)
{
    _dwEventID = lnEventID;
    RRETURN(S_OK);
}


DEFINE_IDispatch_Implementation(CPostalAddress)

CPostalAddress::CPostalAddress():
        _pDispMgr(NULL),
        _rgszPostalAddress(NULL),
        _dwNumElement(0)
{
    ENLIST_TRACKING(CPostalAddress);
}


HRESULT
CPostalAddress::CreatePostalAddress(
    REFIID riid,
    void **ppvObj
    )
{
    CPostalAddress FAR * pPostalAddress = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePostalAddressObject(&pPostalAddress);
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPostalAddress->Release();

    RRETURN(hr);

error:
    delete pPostalAddress;

    RRETURN(hr);

}


CPostalAddress::~CPostalAddress( )
{
    delete _pDispMgr;
    if (_rgszPostalAddress) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszPostalAddress[i]) {
                FreeADsStr(_rgszPostalAddress[i]);
            }
        }
        FreeADsMem(_rgszPostalAddress);
    }
}

STDMETHODIMP
CPostalAddress::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPostalAddress))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPostalAddress FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPostalAddress::AllocatePostalAddressObject(
    CPostalAddress ** ppPostalAddress
    )
{
    CPostalAddress FAR * pPostalAddress = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPostalAddress = new CPostalAddress();
    if (pPostalAddress == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPostalAddress,
                (IADsPostalAddress *)pPostalAddress,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPostalAddress->_pDispMgr = pDispMgr;
    *ppPostalAddress = pPostalAddress;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CPostalAddress::get_PostalAddress(THIS_ VARIANT FAR * pVarDestObject)
{
    HRESULT hr = S_OK;
    hr = ConvertStringArrayToSafeBstrArray(
                                    _rgszPostalAddress,
                                    _dwNumElement,
                                    pVarDestObject);
    RRETURN(hr);
}

STDMETHODIMP
CPostalAddress::put_PostalAddress(THIS_ VARIANT VarSrcObject)
{
    HRESULT hr = S_OK;
    SAFEARRAY * pArray = NULL;

    if (_rgszPostalAddress) {
        long i;
        for (i=0;i<(long)_dwNumElement;i++) {
            if (_rgszPostalAddress[i]) {
                FreeADsStr(_rgszPostalAddress[i]);
            }
        }
        FreeADsMem(_rgszPostalAddress);
    }

    //
    // Make sure it has 6 elements
    //
    if(!((V_VT(&VarSrcObject) & VT_VARIANT) && V_ISARRAY(&VarSrcObject)))
        RRETURN(E_FAIL);

    if (V_VT(&VarSrcObject) & VT_BYREF)
        pArray = *(V_ARRAYREF(&VarSrcObject));
    else
        pArray = V_ARRAY(&VarSrcObject);

    if ((pArray->rgsabound[0].cElements > 6) || (pArray->rgsabound[0].cElements <= 0)){
        RRETURN(E_FAIL);
    }

    hr = ConvertSafeBstrArrayToStringArray(
                                    VarSrcObject,
                                    &_rgszPostalAddress,
                                    &_dwNumElement);
    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CBackLink)

CBackLink::CBackLink():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwRemoteID(0)
{
    ENLIST_TRACKING(CBackLink);
}


HRESULT
CBackLink::CreateBackLink(
    REFIID riid,
    void **ppvObj
    )
{
    CBackLink FAR * pBackLink = NULL;
    HRESULT hr = S_OK;

    hr = AllocateBackLinkObject(&pBackLink);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pBackLink->Release();

    RRETURN(hr);

error:
    delete pBackLink;

    RRETURN(hr);

}


CBackLink::~CBackLink( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CBackLink::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsBackLink))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsBackLink FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CBackLink::AllocateBackLinkObject(
    CBackLink ** ppBackLink
    )
{
    CBackLink FAR * pBackLink = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pBackLink = new CBackLink();
    if (pBackLink == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsBackLink,
                (IADsBackLink *)pBackLink,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pBackLink->_pDispMgr = pDispMgr;
    *ppBackLink = pBackLink;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CBackLink::get_RemoteID(THIS_ long FAR * retval)
{
    *retval = _dwRemoteID;
    RRETURN(S_OK);
}

STDMETHODIMP
CBackLink::put_RemoteID(THIS_ long lnRemoteID)
{
    _dwRemoteID = lnRemoteID;
    RRETURN(S_OK);
}


STDMETHODIMP
CBackLink::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CBackLink::put_ObjectName(THIS_ BSTR bstrObjectName)
{

    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

//////////////////////////////////////////////////////////////////////////
DEFINE_IDispatch_Implementation(CTypedName)

CTypedName::CTypedName():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwLevel(0),
        _dwInterval(0)
{
    ENLIST_TRACKING(CTypedName);
}


HRESULT
CTypedName::CreateTypedName(
    REFIID riid,
    void **ppvObj
    )
{
    CTypedName FAR * pTypedName = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTypedNameObject(&pTypedName);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTypedName->Release();

    RRETURN(hr);

error:
    delete pTypedName;

    RRETURN(hr);

}


CTypedName::~CTypedName( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CTypedName::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsTypedName FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsTypedName))
    {
        *ppv = (IADsTypedName FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsTypedName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CTypedName::AllocateTypedNameObject(
    CTypedName ** ppTypedName
    )
{
    CTypedName FAR * pTypedName = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pTypedName = new CTypedName();
    if (pTypedName == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsTypedName,
                (IADsTypedName *)pTypedName,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pTypedName->_pDispMgr = pDispMgr;
    *ppTypedName = pTypedName;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CTypedName::get_Interval(THIS_ long FAR * retval)
{
    *retval = _dwInterval;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::put_Interval(THIS_ long lnInterval)
{
    _dwInterval = lnInterval;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::get_Level(THIS_ long FAR * retval)
{
    *retval = _dwLevel;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::put_Level(THIS_ long lnLevel)
{
    _dwLevel = lnLevel;
    RRETURN(S_OK);
}

STDMETHODIMP
CTypedName::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CTypedName::put_ObjectName(THIS_ BSTR bstrObjectName)
{

    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}


DEFINE_IDispatch_Implementation(CHold)

CHold::CHold():
        _pDispMgr(NULL),
        _lpObjectName(NULL),
        _dwAmount(0)
{
    ENLIST_TRACKING(CHold);
}


HRESULT
CHold::CreateHold(
    REFIID riid,
    void **ppvObj
    )
{
    CHold FAR * pHold = NULL;
    HRESULT hr = S_OK;

    hr = AllocateHoldObject(&pHold);
    BAIL_ON_FAILURE(hr);

    hr = pHold->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pHold->Release();

    RRETURN(hr);

error:
    delete pHold;

    RRETURN(hr);

}


CHold::~CHold( )
{
    delete _pDispMgr;
    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }
}

STDMETHODIMP
CHold::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsHold))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsHold FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CHold::AllocateHoldObject(
    CHold ** ppHold
    )
{
    CHold FAR * pHold = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pHold = new CHold();
    if (pHold == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsHold,
                (IADsHold *)pHold,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pHold->_pDispMgr = pDispMgr;
    *ppHold = pHold;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CHold::get_Amount(THIS_ long FAR * retval)
{
    *retval = _dwAmount;
    RRETURN(S_OK);
}

STDMETHODIMP
CHold::put_Amount(THIS_ long lnAmount)
{
    _dwAmount = lnAmount;
    RRETURN(S_OK);
}


STDMETHODIMP
CHold::get_ObjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectName, retval);
    RRETURN(hr);

}

STDMETHODIMP
CHold::put_ObjectName(THIS_ BSTR bstrObjectName)
{
    if (!bstrObjectName) {
        RRETURN(E_FAIL);
    }

    if (_lpObjectName) {
        FreeADsStr(_lpObjectName);
    }

    _lpObjectName= AllocADsStr(bstrObjectName);

    if (!_lpObjectName) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aGroupPropMapping[] =
{
  { TEXT("Description"), TEXT("Description") },
};


//  Class CNDSGroup

DEFINE_IDispatch_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADs_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSGroup)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSGroup)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSGroup, aGroupPropMapping)

CNDSGroup::CNDSGroup():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSGroup);
}


HRESULT
CNDSGroup::CreateGroup(
    IADs * pADs,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGroup FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupObject(pADs, Credentials, &pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();

    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSGroup::~CNDSGroup( )
{
    if (_pADs) {
        _pADs->Release();
    }

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSSchemaMgmt) {
        _pDSSchemaMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }

    delete _pDispMgr;
}

STDMETHODIMP
CNDSGroup::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSGroup::AllocateGroupObject(
    IADs *pADs,
    CCredentials& Credentials,
    CNDSGroup ** ppGroup
    )
{
    CNDSGroup FAR * pGroup = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;


    pGroup = new CNDSGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsGroup,
                (IADsGroup *)pGroup,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pGroup,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDSSchemaMgmt = pDSSchemaMgmt;

    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);

    pGroup->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pGroup->_pADs = pADs;
    pADs->AddRef();

    pGroup->_Credentials = Credentials;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:

    delete  pDispMgr;

    delete pGroup;

    *ppGroup = NULL;

    RRETURN(hr);

}

/* ISupportErrorInfo methods */
STDMETHODIMP
CNDSGroup::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsGroup) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}









=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//             IADsGroup and IADsGroupOperation methods
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );




//  Class CNDSGroup


STDMETHODIMP CNDSGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this,Description);
}

STDMETHODIMP CNDSGroup::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this,Description);
}


STDMETHODIMP
CNDSGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    VARIANT varProp;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    if (!ppMembers) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    VariantInit(&varProp);

    hr = _pADs->GetEx(L"Member", &varProp);

    //
    // Do not bail out on failure here if you could not find
    // any data set for the Members property. You need to
    // pass it all the way through and on enumeration
    // return nothing.
    //

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        SAFEARRAY *aList = NULL;

        VariantInit(&varProp);

        SAFEARRAYBOUND aBound;

        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        V_VT(&varProp) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&varProp) = aList;
    }
    else {
        BAIL_ON_FAILURE(hr);
    }

    hr = _pADs->get_ADsPath(&bstrADsPath);

    hr = CNDSGroupCollection::CreateGroupCollection(
                    bstrADsPath,
                    varProp,
                    _Credentials,
                    IID_IADsMembers,
                    (void **)ppMembers
                    );

    BAIL_ON_FAILURE(hr);

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    VariantClear(&varProp);

    RRETURN_EXP_IF_ERR(hr);
}




STDMETHODIMP
CNDSGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;

    if (!bstrMember) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    if (!bMember) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
        //
        // If it has no members, we will return FALSE
        //
        if (hr == E_FAIL) {
                hr = S_OK;
                goto error;
        }

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }


        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );
        if (fMember) {

            fContinue = FALSE;
        }



        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE: VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

        if (!_wcsicmp(bstrName, bstrMember)) {

            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}


STDMETHODIMP
CNDSGroup::Add(THIS_ BSTR bstrNewItem)
{
    HRESULT hr = S_OK;

    WCHAR szNDSUserPathName[MAX_PATH];
    WCHAR szNDSUserTreeName[MAX_PATH];
    IUnknown * pUnknown = NULL;
    IADs * pUser = NULL;

    WCHAR szNDSGroupPathName[MAX_PATH];
    WCHAR szNDSGroupTreeName[MAX_PATH];
    BSTR bstrPathName = NULL;

    BSTR pszClass = NULL;

    hr = ::GetObject(
                bstrNewItem,
                _Credentials,
                (void **)&pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IADs, (void **)&pUser);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrNewItem,
                szNDSUserTreeName,
                szNDSUserPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath(&bstrPathName);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrPathName,
                szNDSGroupTreeName,
                szNDSGroupPathName
                );
    BAIL_ON_FAILURE(hr);


    hr = AddEntry(_pADs, L"Member",szNDSUserPathName);
    BAIL_ON_FAILURE(hr);

    // hr = AddEntry(_pADs, L"Equivalent To Me", szNDSUserPathName);
    // BAIL_ON_FAILURE(hr);

    //
    // Groups do not have a "Group Membership" attribute
    //
    hr = pUser->get_Class(&pszClass);
    BAIL_ON_FAILURE(hr);

    if (_wcsicmp(pszClass, L"group") != 0) {
        hr = AddEntry(pUser, L"Group Membership", szNDSGroupPathName);
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    if (bstrPathName) {
        ADsFreeString(bstrPathName);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pUser) {
        pUser->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGroup::Remove(THIS_ BSTR bstrNewItem)
{
    HRESULT hr = S_OK;

    WCHAR szNDSUserPathName[MAX_PATH];
    WCHAR szNDSUserTreeName[MAX_PATH];
    IUnknown * pUnknown = NULL;
    IADs * pUser = NULL;

    WCHAR szNDSGroupPathName[MAX_PATH];
    WCHAR szNDSGroupTreeName[MAX_PATH];
    BSTR bstrPathName = NULL;

    BSTR pszClass = NULL;

    hr = ::GetObject(
                bstrNewItem,
                _Credentials,
                (void **)&pUnknown
                );

    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IADs, (void **)&pUser);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrNewItem,
                szNDSUserTreeName,
                szNDSUserPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = _pADs->get_ADsPath(&bstrPathName);
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrPathName,
                szNDSGroupTreeName,
                szNDSGroupPathName
                );
    BAIL_ON_FAILURE(hr);


    hr = RemoveEntry(_pADs, L"Member",szNDSUserPathName);
    BAIL_ON_FAILURE(hr);

    // hr = RemoveEntry(_pADs, L"Equivalent To Me", szNDSUserPathName);
    // BAIL_ON_FAILURE(hr);

    //
    // Groups do not have a "Group Membership" attribute
    //
    hr = pUser->get_Class(&pszClass);
    BAIL_ON_FAILURE(hr);

    if (_wcsicmp(pszClass, L"group") != 0) {
        hr = RemoveEntry(pUser, L"Group Membership", szNDSGroupPathName);
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    if (bstrPathName) {
        ADsFreeString(bstrPathName);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pUser) {
        pUser->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
AddEntry(
    IADs * pADs,
    LPWSTR pszAttribute,
    LPWSTR pszValue
    )
{

    HRESULT hr = S_OK;
    VARIANT vOldValue;
    VARIANT vNewValue;
    SAFEARRAY * pArray = NULL;

    VariantInit(&vOldValue);
    VariantInit(&vNewValue);

    #if defined(BUILD_FOR_NT40)

    hr = pADs->Get(pszAttribute, &vOldValue);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {


        VariantInit(&vNewValue);
        V_BSTR(&vNewValue) = SysAllocString(pszValue);
        V_VT(&vNewValue) =  VT_BSTR;

        hr = pADs->Put(pszAttribute, vNewValue);
        BAIL_ON_FAILURE(hr);

    }else{

        hr = VarAddEntry(
                    pszValue,
                    vOldValue,
                    &vNewValue
                    );
        BAIL_ON_FAILURE(hr);

        hr = pADs->Put(pszAttribute, vNewValue);
        BAIL_ON_FAILURE(hr);
    }
    #else

    //
    // NT5 supports appending values. So we don't need to read everything.
    // append ourselves and write everything
    //

    SAFEARRAYBOUND sabNewArray;
    int i;
    VARIANT v;

    sabNewArray.cElements = 1;
    sabNewArray.lLbound = 0;

    pArray = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    VariantInit(&v);

    V_BSTR(&v) = SysAllocString(pszValue);
    V_VT(&v) =  VT_BSTR;

    i = 0;
    hr = SafeArrayPutElement(
                pArray,
                (long *)&i,
                (void *)&v
                );

    VariantClear(&v);

    BAIL_ON_FAILURE(hr);

    V_VT(&vNewValue) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&vNewValue) = pArray;

    hr = pADs->PutEx(ADS_PROPERTY_APPEND, pszAttribute, vNewValue);
    BAIL_ON_FAILURE(hr);

    #endif

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vOldValue);
    VariantClear(&vNewValue);

    RRETURN(hr);
}






HRESULT
RemoveEntry(
    IADs * pADs,
    LPWSTR pszAttribute,
    LPWSTR pszValue
    )
{
    HRESULT hr = S_OK;
    VARIANT vOldValue;
    VARIANT vNewValue;
    SAFEARRAY * pArray = NULL;

    VariantInit(&vOldValue);
    VariantInit(&vNewValue);

    #if defined(BUILD_FOR_NT40)

    hr = pADs->Get(pszAttribute, &vOldValue);
    BAIL_ON_FAILURE(hr);

    hr = VarRemoveEntry(
                pszValue,
                vOldValue,
                &vNewValue
                );
    BAIL_ON_FAILURE(hr);


    if (V_VT(&vNewValue) == VT_EMPTY) {
        hr = pADs->PutEx(ADS_PROPERTY_CLEAR, pszAttribute, vNewValue);
    }else {
        hr = pADs->Put(pszAttribute, vNewValue);

    }
    BAIL_ON_FAILURE(hr);

    #else

    SAFEARRAYBOUND sabNewArray;
    VARIANT  v;
    int i;

    //
    // NT5 supports deleting values. So we don't need to read everything.
    // delete ourselves and write everything - Very inefficient!
    //

    sabNewArray.cElements = 1;
    sabNewArray.lLbound = 0;

    pArray = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    VariantInit(&v);

    V_BSTR(&v) = SysAllocString(pszValue);
    V_VT(&v) =  VT_BSTR;

    i = 0;
    hr = SafeArrayPutElement(
                pArray,
                (long *)&i,
                (void *)&v
                );

    VariantClear(&v);

    BAIL_ON_FAILURE(hr);

    V_VT(&vNewValue) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&vNewValue) = pArray;

    hr = pADs->PutEx(ADS_PROPERTY_DELETE, pszAttribute, vNewValue);
    BAIL_ON_FAILURE(hr);

    #endif

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vOldValue);
    VariantClear(&vNewValue);

    RRETURN(hr);
}


HRESULT
VarFindEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    if (!(V_VT(&varMembers) ==  (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&varMembers),
                                (long FAR *)&i,
                                &v
                                );

        if (!_wcsicmp(V_BSTR(&v), pszNDSPathName)) {
            VariantClear(&v);
            RRETURN(S_OK);
        }

        VariantClear(&v);
    }

error:

    RRETURN(E_FAIL);
}

HRESULT
VarMultipleAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);

    if (!(V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    sabNewArray.cElements = (dwSUBound - dwSLBound + 1) + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(&v);

        hr = SafeArrayGetElement(
                    V_ARRAY(&varMembers),
                    (long FAR *)&i,
                    &v
                    );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&i,
                (void *)&v
                );

        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pszNDSPathName);

    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&v
                );
    VariantClear(&v);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}

HRESULT
VarMultipleRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    DWORD dwNewCount = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);


    if(!(V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY))){
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&varMembers))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&varMembers))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varMembers),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);


    sabNewArray.cElements = (dwSUBound - dwSLBound);
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound, dwNewCount = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(
                    V_ARRAY(&varMembers),
                    (long FAR *)&i,
                    &v
                    );

        if (!_wcsicmp(V_BSTR(&v), pszNDSPathName)) {

            VariantClear(&v);
            //
            // skip this entry
            //
            continue;

        }
        hr = SafeArrayPutElement(
                pFilter,
                (long*)&dwNewCount,
                (void *)&v
                );

        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

        dwNewCount++;

    }

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);


error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}




HRESULT
VarSingleAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{   SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    VARIANT v;

    VariantInit(pvarNewMembers);

    if(!((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR)){
        return(E_FAIL);
    }

    sabNewArray.cElements = (1) + 1;
    sabNewArray.lLbound = 0;

    pFilter = SafeArrayCreate(
                    VT_VARIANT,
                    1,
                    &sabNewArray
                    );
    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    i = 0;
    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&varMembers
                );
    BAIL_ON_FAILURE(hr);

    i++;

    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pszNDSPathName);

    hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&v
                );
    VariantClear(&v);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNewMembers) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNewMembers) = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    RRETURN(hr);
}



HRESULT
VarSingleRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    VariantInit(pvarNewMembers);

    if(!((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR)){
        return(E_FAIL);
    }

    V_VT(pvarNewMembers) = VT_EMPTY;
    V_BSTR(pvarNewMembers) = NULL;

    RRETURN(hr);
}


HRESULT
VarRemoveEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    if (V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY)) {

        hr = VarMultipleRemoveEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );
        RRETURN(hr);

    }else if (V_VT(&varMembers) == VT_BSTR){

        hr = VarSingleRemoveEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );

        RRETURN(hr);

    }else {

        RRETURN(E_FAIL);
    }
}


HRESULT
VarAddEntry(
    LPWSTR pszNDSPathName,
    VARIANT varMembers,
    VARIANT * pvarNewMembers
    )
{
    HRESULT hr = S_OK;

    if (V_VT(&varMembers) == (VT_VARIANT|VT_ARRAY)){

        hr = VarMultipleAddEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );
        RRETURN(hr);

    }else if ((V_VT(&varMembers) & VT_TYPEMASK) == VT_BSTR){

        hr = VarSingleAddEntry(
                pszNDSPathName,
                varMembers,
                pvarNewMembers
                );

        RRETURN(hr);

    }else {

        RRETURN(E_FAIL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\clocalty.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cLocality.cxx
//
//  Contents:  Locality object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aLocalityPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("SeeAlso"), TEXT("See Also") }
};

//  Class CNDSLocality

DEFINE_IDispatch_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADs_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSLocality)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSLocality)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSLocality, aLocalityPropMapping)


CNDSLocality::CNDSLocality():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSLocality);
}


HRESULT
CNDSLocality::CreateLocality(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSLocality FAR * pLocality = NULL;
    HRESULT hr = S_OK;

    hr = AllocateLocalityObject(pADs, &pLocality);
    BAIL_ON_FAILURE(hr);

    hr = pLocality->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pLocality->Release();

    RRETURN(hr);

error:
    delete pLocality;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSLocality::~CNDSLocality( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSSchemaMgmt) {
        _pDSSchemaMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }

    delete _pDispMgr;
}

STDMETHODIMP
CNDSLocality::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsLocality))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsLocality FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {

        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSLocality::AllocateLocalityObject(
    IADs *pADs,
    CNDSLocality ** ppLocality
    )
{
    CNDSLocality FAR * pLocality = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pLocality = new CNDSLocality();
    if (pLocality == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsLocality,
                (IADsLocality *)pLocality,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pLocality,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pADsPropList,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pDSSchemaMgmt = pDSSchemaMgmt;


    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pLocality->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pLocality->_pADs = pADs;
    pADs->AddRef();


    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pLocality->_pADsContainer = pADsContainer;


    pLocality->_pDispMgr = pDispMgr;
    *ppLocality = pLocality;

    RRETURN(hr);

error:

    delete  pDispMgr;

    delete  pLocality;

    *ppLocality = NULL;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSLocality::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsequalIID(riid, IID_IdirecotryAttrMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsLocality)) {
      RRETURN(S_OK);
    } else {
      RRETURN(S_FALSE);
    }
}

STDMETHODIMP CNDSLocality::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,Description);
}

STDMETHODIMP CNDSLocality::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,Description);
}



STDMETHODIMP CNDSLocality::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CNDSLocality::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,LocalityName);
}

STDMETHODIMP CNDSLocality::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CNDSLocality::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsLocality *)this,PostalAddress);
}

STDMETHODIMP CNDSLocality::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}

STDMETHODIMP CNDSLocality::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsLocality *)this,SeeAlso);
}




/* IADsContainer methods */

STDMETHODIMP
CNDSLocality::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSLocality::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSLocality::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSLocality::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cgenobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomain.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSGenObject

DEFINE_IDispatch_Implementation(CNDSGenObject)
DEFINE_IADs_Implementation(CNDSGenObject)


CNDSGenObject::CNDSGenObject():
                _pPropertyCache(NULL)
{

    _pOuterUnknown = NULL;

    _fIsAggregated = NULL;

    VariantInit(&_vFilter);

    InitSearchPrefs();

    ENLIST_TRACKING(CNDSGenObject);
}

HRESULT
CNDSGenObject::CreateGenericObject(
    BSTR bstrADsPath,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];

    memset(szADsParent, 0, sizeof(szADsParent));
    memset(szCommonName, 0, sizeof(szCommonName));

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                szADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CNDSGenObject::CreateGenericObject(
                 szADsParent,
                 szCommonName,
                 ClassName,
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSGenObject FAR * pGenObject = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGenObject(Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_NDSGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGenObject->Release();

    RRETURN(hr);

error:

    delete pGenObject;
    RRETURN(hr);
}

CNDSGenObject::~CNDSGenObject( )
{
    VariantClear(&_vFilter);

    delete _pDispMgr;

    delete _pPropertyCache;
}

STDMETHODIMP
CNDSGenObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
HRESULT
CNDSGenObject::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CNDSGenObject::SetInfo()
{
    DWORD dwStatus = 0L;
    WCHAR szNDSPathName[MAX_PATH];
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = NDSCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = NDSSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSGenObject::NDSSetObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszNDSPathName = NULL;
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_MODIFY,
                        &hOperationData
                        );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSMarshallProperties(
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsModifyObject(
                    hObject,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


error:

    if (pszNDSPathName) {

        FreeADsStr(pszNDSPathName);
    }

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSGenObject::NDSCreateObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszNDSParentName = NULL;
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;


    hr = BuildNDSPathFromADsPath(
                _Parent,
                &pszNDSParentName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSParentName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_ADD,
                        &hOperationData
                        );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSMarshallProperties(
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsAddObject(
                    hObject,
                    _Name,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }


    if (pszNDSParentName) {

        FreeADsStr(pszNDSParentName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSGenObject::GetInfo()
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(TRUE));
}

HRESULT
CNDSGenObject::GetInfo(
    BOOL fExplicit
    )
{
    DWORD dwStatus = 0L;
    HANDLE hObject = NULL;
    HANDLE hOperationData = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPathName = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hOperationData = NULL;

    dwStatus = NwNdsReadObject(
                    hObject,
                    NDS_INFO_ATTR_NAMES_VALUES,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSUnMarshallProperties(
                            hOperationData,
                            fExplicit
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }


    if (pszNDSPathName) {

        FreeADsStr(pszNDSPathName);
    }

    if (_pPropertyCache) {
       Reset();
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;
    HANDLE hObject = NULL;
    VARIANT *vVarArray = NULL;
    DWORD dwNumVariants = 0;
    HANDLE hOperationData = NULL;
    LPWSTR pszNDSPathName = NULL;
    DWORD i;


    UNREFERENCED_PARAMETER(lnReserved);

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildNDSPathFromADsPath(_ADsPath, &pszNDSPathName);
    BAIL_ON_FAILURE(hr);

    hr = ConvertSafeArrayToVariantArray(
    vProperties,
    &vVarArray,
    &dwNumVariants
    );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
    pszNDSPathName, _Credentials, &hObject, NULL, NULL, NULL, NULL);
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hOperationData = NULL;
    dwStatus = NwNdsCreateBuffer(NDS_OBJECT_READ, &hOperationData);
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    //
    // Fill up the buffer with our search parameters.
    //
    for (i = 0; i < dwNumVariants; i++)
    {
    if (!(V_VT(vVarArray + i) == VT_BSTR))
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

    dwStatus = NwNdsPutInBuffer(
        V_BSTR(vVarArray + i), 0, NULL, 0, 0, hOperationData);
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    }

    dwStatus = NwNdsReadObject(
    hObject,
    NDS_INFO_ATTR_NAMES_VALUES,
    &hOperationData
    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    //
    // The TRUE is "fExplicit" -- we want to make sure that any
    // properties we get back from the server get updated in the
    // property cache.
    //
    hr = _pPropertyCache->NDSUnMarshallProperties(hOperationData, TRUE);
    BAIL_ON_FAILURE(hr);

error:
    if (hOperationData)
        dwStatus = NwNdsFreeBuffer(hOperationData);

    if (vVarArray){
        // Need to free each variants content and then the arrays.
        for (i = 0; i < dwNumVariants; i++) {
            VariantClear(vVarArray + i);
        }
        FreeADsMem(vVarArray);
    }

    if (hObject)
        dwStatus = NwNdsCloseObject(hObject);

    if (pszNDSPathName)
        FreeADsStr(pszNDSPathName);

    RRETURN_EXP_IF_ERR(hr);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSGenObject::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSGenObject::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSGenObject::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    VariantClear(&_vFilter);
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNDSGenObject::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSGenObject::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                    _ADsPath,
                    ClassName,
                    RelativeName,
                    _Credentials,
                    ppObject,
                    FALSE
                    );
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSGenObject::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSGenObjectEnum::Create(
                (CNDSGenObjectEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs * pADs  = NULL;
    VARIANT var;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwSyntaxId = 0;
    VARIANT vNewValue;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //


    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    VariantInit(&vNewValue);
    V_BSTR(&vNewValue) = ClassName;
    V_VT(&vNewValue) =  VT_BSTR;

    hr = pADs->Put(L"Object Class", vNewValue);
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should addref this pointer for us.
    //

    hr = InstantiateDerivedObject(
                    pADs,
                    _Credentials,
                    IID_IDispatch,
                    (void **)ppObject
                    );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
        BAIL_ON_FAILURE(hr);
    }



error:

    //
    // Free the intermediate pADs pointer.
    //
    if (pADs) {
        pADs->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    LPWSTR pszNDSPathName = NULL;
    LPWSTR pszNDSChildPath = NULL;
    WCHAR szChildObjectClassName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hChildObject = NULL;
    HANDLE hParentObject = NULL;
    BSTR bstrChildPath = NULL;

    hr = BuildADsPath(
                _ADsPath,
                bstrRelativeName,
                &bstrChildPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrChildPath,
                &pszNDSChildPath
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSChildPath,
                    _Credentials,
                    &hChildObject,
                    NULL,
                    szChildObjectClassName,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (hChildObject) {

        NwNdsCloseObject(hChildObject);
    }


    if (_wcsicmp(szChildObjectClassName, bstrClassName)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We now are sure we're deleting an object of the
    // specified class
    //


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hParentObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsRemoveObject(
                    hParentObject,
                    bstrRelativeName
                    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


error:

    if (bstrChildPath) {
        SysFreeString(bstrChildPath);
    }


    if (pszNDSPathName) {
        FreeADsStr(pszNDSPathName);

    }

    if (pszNDSChildPath) {
        FreeADsStr(pszNDSChildPath);
    }

    if (hParentObject) {
        NwNdsCloseObject(
                hParentObject
                );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;

    hr = CopyObject(
             SourceName,
             _ADsPath,
             NewName,
             _Credentials,
             (void**)&pUnk
             );

    BAIL_ON_FAILURE(hr);

    hr = pUnk->QueryInterface(IID_IDispatch, (void **)ppObject);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    LPWSTR pszNDSDestPathName = NULL;       // Target Parent DN (NDS format)
    LPWSTR pszNDSSrcParent = NULL;          // Source Parent DN (NDS format)
    WCHAR szSrcParent[MAX_PATH];            // Source Parent DN (ADSI format)
    WCHAR szCN[MAX_PATH];                   // Source RDN
    LPWSTR pszRelativeName = NULL;          // Target RDN
    WCHAR szObjectClass[MAX_PATH];          // Object class of object being moved/renamed
    
    LPWSTR pszNDSSrcPathName = NULL;         // Source DN for move (NDS format)
    BSTR pszADsSrcPathName = NULL;           // Source DN for move (ADSI format)
    
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hSrcObject = NULL;
    HANDLE hParentObject = NULL;
    IADs  *pADs = NULL;

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSDestPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPath(
                    SourceName,
                    szSrcParent,
                    szCN
                    );

    hr = BuildNDSPathFromADsPath(
                szSrcParent,
                &pszNDSSrcParent
                );
    BAIL_ON_FAILURE(hr);

    if (NewName)
        pszRelativeName = NewName;
    else
        pszRelativeName = szCN;

    BuildADsPath(szSrcParent, pszRelativeName, &pszADsSrcPathName);

    hr = BuildNDSPathFromADsPath(
                pszADsSrcPathName,
                &pszNDSSrcPathName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Get the value of the new and old name
    //
    if ( NewName != NULL) {
        //
        // Get the value from the NewName if user supplies 'CN=xxx'
        //
        LPWSTR pszCN = NewName;

        while (*pszCN != '\0' && *pszCN != '=') {
            pszCN++;
        }
        if (*pszCN != '\0') {
            NewName = ++pszCN;
        }

        //
        // Getting the value from the CN since it is always in the format 'CN=xxx'
        //
        LPWSTR pszRDN = szCN;
        while (*pszRDN != '\0' && *pszRDN != '=') {
            pszRDN++;
        }
        if (*pszRDN == '\0') {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
        else {
            pszRDN++;
        }

        //
        // Only carry out rename if the names are different
        //
        if (wcscmp(pszRDN,NewName) != 0) {
            dwStatus = ADsNwNdsOpenObject(
                            pszNDSSrcParent,
                            _Credentials,
                            &hParentObject,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            );
            CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

            dwStatus = NwNdsRenameObject(
                                    hParentObject,
                                    pszRDN,
                                    NewName,
                                    FALSE);
            CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        }
    }

    //
    // Only carry out move if the two parents are different
    //
    dwStatus = ADsNwNdsOpenObject(
                    pszNDSSrcPathName,
                    _Credentials,
                    &hSrcObject,
                    NULL,
                    szObjectClass,
                    NULL,
                    NULL
                    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    if (wcscmp(pszNDSDestPathName, pszNDSSrcParent) != 0) {

        dwStatus = NwNdsMoveObject(
                      hSrcObject,
                      pszNDSDestPathName
                      );
        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    }

    if (ppObject) {

        hr = CNDSGenObject::CreateGenericObject(
                        _ADsPath,
                        pszRelativeName,
                        szObjectClass,
                        _Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
        BAIL_ON_FAILURE(hr);


        //
        // InstantiateDerivedObject should add-ref this pointer for us.
        //
        
        hr = InstantiateDerivedObject(
                            pADs,
                            _Credentials,
                            IID_IDispatch,
                            (void**)ppObject
                            );

        if (FAILED(hr)) {
            hr = pADs->QueryInterface(
                                IID_IDispatch,
                                (void**)ppObject
                                );
            BAIL_ON_FAILURE(hr);
        }
    }

error:
    if (hSrcObject) {
        NwNdsCloseObject(hSrcObject);
    }
    if (hParentObject) {
        NwNdsCloseObject(hParentObject);
    }
    if (pszNDSSrcParent) {
        FreeADsMem(pszNDSSrcParent);
    }
    if (pszNDSDestPathName) {
        FreeADsMem(pszNDSDestPathName);
    }
    if (pszNDSSrcPathName) {
        FreeADsMem(pszNDSSrcPathName);
    }
    if (pszADsSrcPathName) {
        ADsFreeString(pszADsSrcPathName);
    }
    if (pADs) {
        pADs->Release();
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSGenObject::AllocateGenObject(
    CCredentials& Credentials,
    CNDSGenObject ** ppGenObject
    )
{
    CNDSGenObject FAR * pGenObject = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CNDSGenObject();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pGenObject,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);



    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pGenObject,
                           DISPID_VALUE
                           );
    BAIL_ON_FAILURE(hr);



    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);



    pGenObject->_Credentials = Credentials;
    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSGenObject::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                FALSE
                );


    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwNumValues = 0, dwNumVariants = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vDefProp;

    VariantInit(&vDefProp);

    //
    // Issue: How do we handle multi-valued support
    //
    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;

    }else {

        //
        // If pvProp is a reference to a fundamental type,
        // we have to dereference it once.
        //
        if (V_ISBYREF(pvProp)) {
            hr = VariantCopyInd(&vDefProp, pvProp);
            BAIL_ON_FAILURE(hr);
            pvProp = &vDefProp;
        }

        dwNumValues = 1;
    }

    //
    // Save it in case dwNumValues changes below (as in the case of ACLs)
    //
    dwNumVariants = dwNumValues;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&vDefProp);

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumVariants; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwNumValues = 0, dwNumVariants = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;


    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);



    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pNdsDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
    case ADS_PROPERTY_APPEND:
    case ADS_PROPERTY_DELETE:

        if (lnControlCode == ADS_PROPERTY_UPDATE) {
            dwFlags = CACHE_PROPERTY_MODIFIED;
        }
        else if (lnControlCode == ADS_PROPERTY_APPEND) {
            dwFlags = CACHE_PROPERTY_APPENDED;
        }
        else {
            dwFlags = CACHE_PROPERTY_DELETED;
        }

        //
        // Now begin the rest of the processing
        //
        //
        // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
        // We should dereference a VT_BYREF|VT_VARIANT once and see
        // what's inside.
        //
        pvProp = &vProp;
        if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
            pvProp = V_VARIANTREF(&vProp);
        }

        if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
            (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

            hr  = ConvertByRefSafeArrayToVariantArray(
                        *pvProp,
                        &pVarArray,
                        &dwNumValues
                        );
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;

        }else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Save it in case dwNumValues changes below (as in the case of ACLs)
        //
        dwNumVariants = dwNumValues;

        //
        // check if the variant maps to the syntax of this property
        //

        hr = VarTypeToNdsTypeCopyConstruct(
                        dwSyntaxId,
                        pvProp,
                        &dwNumValues,
                        &pNdsDestObjects
                        );
        BAIL_ON_FAILURE(hr);

        break;

    default:
       RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //



    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumVariants; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

void
CNDSGenObject::InitSearchPrefs()
{
    _SearchPref._iScope = 1;
    _SearchPref._fDerefAliases = FALSE;
    _SearchPref._fAttrsOnly = FALSE;

}

STDMETHODIMP
CNDSGenObject::get_PropertyCount(
    THIS_ long FAR *plCount
    )
{
    HRESULT hr = E_FAIL;

    if (_pPropertyCache) {
        hr = _pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CNDSGenObject::Next(
    THIS_ VARIANT FAR *pVariant
    )
{

    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    PADSVALUE pAdsValues = NULL;

    if (!_pPropertyCache->index_valid())
    RRETURN_EXP_IF_ERR(E_FAIL);

    VariantInit(&varData);



    hr = _pPropertyCache->unboundgetproperty(
                _pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = ConvertNdsValuesToVariant(
                _pPropertyCache->get_CurrentPropName(),
                pNdsSrcObjects,
                dwSyntaxId,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);


error:

    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the sucess of Skip().
    //

    Skip(1);

    if (pNdsSrcObjects) {
      NdsTypeFreeNdsObjects(pNdsSrcObjects, dwNumValues);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::Skip(
    THIS_ long cElements
    )
{
   HRESULT hr = S_OK;

    hr = _pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSGenObject::Reset(

    )
{
    _pPropertyCache->reset_propindex();

    RRETURN_EXP_IF_ERR(S_OK);
}


STDMETHODIMP
CNDSGenObject::ResetPropertyItem(THIS_ VARIANT varEntry)
{
   HRESULT hr = S_OK;
   DWORD dwIndex = 0;

   switch (V_VT(&varEntry)) {

   case VT_BSTR:

       hr = _pPropertyCache->findproperty(
                           V_BSTR(&varEntry),
                           &dwIndex
                           );
       BAIL_ON_FAILURE(hr);
       break;

   case VT_I4:
       dwIndex = V_I4(&varEntry);
       break;


   case VT_I2:
       dwIndex = V_I2(&varEntry);
       break;


   default:
       hr = E_FAIL;
       BAIL_ON_FAILURE(hr);
   }

   hr = _pPropertyCache->deleteproperty(
                       dwIndex
                       );
error:
   RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSGenObject::GetPropertyItem(
    THIS_ BSTR bstrName,
    LONG lnType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    PADSVALUE pAdsValues = NULL;


    //
    // retrieve data object from cache; if one exists
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = _pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = _pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // translate the Nds objects to variants
    //

    hr = ConvertNdsValuesToVariant(
                bstrName,
                pNdsSrcObjects,
                dwSyntaxId,
                dwNumValues,
                pVariant
                );

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::PutPropertyItem(THIS_ VARIANT varData)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    WCHAR szPropertyName[MAX_PATH];
    DWORD dwControlCode = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvarData = NULL;

    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues = 0;

    DWORD dwSyntaxId2 = 0;
    DWORD dwNumNdsValues = 0;


    hr = ConvertVariantToNdsValues(
                varData,
                szPropertyName,
                &dwControlCode,
                &pNdsDestObjects,
                &dwNumValues,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);


    switch (dwControlCode) {

    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pNdsDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = CACHE_PROPERTY_MODIFIED;
        break;

    case ADS_PROPERTY_APPEND:
        dwFlags = CACHE_PROPERTY_APPENDED;
        break;


    case ADS_PROPERTY_DELETE:
        dwFlags = CACHE_PROPERTY_DELETED;
        break;

    default:
       BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    szPropertyName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    szPropertyName,
                    dwFlags,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    DWORD ADsType,
    DWORD numValues,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(ADsType);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}

STDMETHODIMP
CNDSGenObject::Item(
    THIS_ VARIANT varIndex,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;
    PADSVALUE pAdsValues = NULL;
    LPWSTR szPropName = NULL;
    VARIANT * pvVar = &varIndex;

    //
    // retrieve data object from cache; if one exis
    //

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:

        //
        // retrieve data object from cache; if one exists
        //

        if (GetObjectState() == ADS_OBJECT_UNBOUND) {

            hr = _pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNdsSrcObjects
                        );
            BAIL_ON_FAILURE(hr);

        }else {

            hr = _pPropertyCache->getproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNdsSrcObjects
                        );
            BAIL_ON_FAILURE(hr);
        }

        hr = ConvertNdsValuesToVariant(
                    V_BSTR(pvVar),
                    pNdsSrcObjects,
                    dwSyntaxId,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I4:

        hr = _pPropertyCache->unboundgetproperty(
                    V_I4(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(V_I4(pvVar));

        hr = ConvertNdsValuesToVariant(
                    szPropName,
                    pNdsSrcObjects,
                    dwSyntaxId,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;

    case VT_I2:

        hr = _pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNdsSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = _pPropertyCache->get_PropName(V_I2(pvVar));

        hr = ConvertNdsValuesToVariant(
                    szPropName,
                    pNdsSrcObjects,
                    dwSyntaxId,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);

        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }


error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSGenObject::PurgePropertyList()
{
    _pPropertyCache->flushpropcache();
    RRETURN(S_OK);
}

HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    VARIANT * pVarData = NULL;
    HRESULT hr = S_OK;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pVarData = &varData;
    if (V_VT(pVarData) == (VT_BYREF|VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pVarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(pVarData) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  *pVarData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else {
        pVarArray = NULL;
        dwNumValues = 0;
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}


HRESULT
ConvertVariantToNdsValues(
    VARIANT varData,
    LPWSTR szPropertyName,
    PDWORD pdwControlCode,
    PNDSOBJECT * ppNdsDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;

    PNDSOBJECT pNdsDestObjects = 0;
    DWORD dwNumNdsObjects = 0;
    DWORD dwNdsSyntaxId = 0;

    if (V_VT(&varData) != VT_DISPATCH) {
        RRETURN (hr = DISP_E_TYPEMISMATCH);
    }

    pDispatch = V_DISPATCH(&varData);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);

    VariantInit(&varValues);
    VariantClear(&varValues);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    wcscpy(szPropertyName, bstrPropName);

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);
    *pdwControlCode = dwControlCode;

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        hr = PropVariantToAdsType(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues
                    );
        BAIL_ON_FAILURE(hr);

        hr = AdsTypeToNdsTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    &pNdsDestObjects,
                    &dwNumNdsObjects,
                    &dwNdsSyntaxId
                    );
        BAIL_ON_FAILURE(hr);

    }

    *ppNdsDestObjects = pNdsDestObjects;
    *pdwNumValues = dwNumNdsObjects;
    *pdwSyntaxId = dwNdsSyntaxId;
cleanup:

    if (bstrPropName) {
        ADsFreeString(bstrPropName);
    }

    if (pAdsValues) {
        AdsFreeAdsValues(
                pAdsValues,
                dwNumValues
                );
        FreeADsMem( pAdsValues );
    }

    if (pVarArray) {

        FreeVariantArray(
                pVarArray,
                dwAdsValues
                );
    }

    if (pPropEntry) {

        pPropEntry->Release();
    }

    VariantClear(&varValues);

    RRETURN(hr);

error:

    if (pNdsDestObjects) {

        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumNdsObjects
                );
    }

    *ppNdsDestObjects = NULL;
    *pdwNumValues = 0;

    goto cleanup;

}


HRESULT
ConvertNdsValuesToVariant(
    BSTR bstrPropName,
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    PVARIANT pVarProp
    )
{
    HRESULT hr = S_OK;
    PADSVALUE pAdsValues = NULL;
    DWORD dwNumAdsValues = 0;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    DWORD dwADsType = 0;


    VariantInit(&varData);
    VariantInit(pVarProp);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToAdsTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                &pAdsValues
                );

    if (SUCCEEDED(hr)){
        hr = AdsTypeToPropVariant(
                    pAdsValues,
                    dwNumValues,
                    &varData
                    );
        if (SUCCEEDED(hr)) {
            dwADsType = (dwSyntaxId >= g_cMapNdsTypeToADsType) ?
                            ADSTYPE_INVALID :
                            g_MapNdsTypeToADsType[dwSyntaxId];
        }else {
            VariantClear(&varData);
            hr = S_OK;
        }

    }else {
       VariantClear(&varData);
       VariantInit(&varData);
       hr = S_OK;
    }

    hr = CreatePropEntry(
            bstrPropName,
            dwADsType,
            dwNumValues,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);


    V_DISPATCH(pVarProp) = pDispatch;
    V_VT(pVarProp) = VT_DISPATCH;

error:

    if (pAdsValues) {
       AdsFreeAdsValues(
            pAdsValues,
            dwNumValues
            );
       FreeADsMem( pAdsValues );
    }

    VariantClear(&varData);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cmacro.h ===
#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IADsPutGet_Implementation(cls, ClassPropMapping)    \
STDMETHODIMP                                                                 \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Get( pszPropName, pvProp));                               \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                                 \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                    \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->Put( pszPropName, vProp));                                \
}                                                                            \
                                                                             \
STDMETHODIMP                                                                 \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                         \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp ) == 0 )      \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->GetEx( pszPropName, pvProp));                             \
}                                                                            \
STDMETHODIMP                                                                 \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)           \
{                                                                            \
    LPTSTR pszPropName = bstrName;                                           \
                                                                             \
    for ( DWORD i = 0; i < ARRAY_SIZE(ClassPropMapping); i++ )               \
    {                                                                        \
        if ( _tcsicmp(bstrName, ClassPropMapping[i].pszADsProp) == 0 )       \
        {                                                                    \
            pszPropName = ClassPropMapping[i].pszNDSProp;                   \
            break;                                                           \
        }                                                                    \
    }                                                                        \
                                                                             \
    RRETURN(_pADs->PutEx( lnControlCode, pszPropName, vProp));               \
}

#define DEFINE_CONTAINED_IDirectoryObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_INFO *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_INFO pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    IDispatch * FAR* ppObject                                         \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        ppObject                                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}


#define DEFINE_CONTAINED_IDirectorySearch_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetSearchPreference(                                             \
    PADS_SEARCHPREF_INFO pSearchPrefs,                                \
    DWORD   dwNumPrefs                                                \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->SetSearchPreference(                             \
                         pSearchPrefs,                                \
                         dwNumPrefs                                   \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ExecuteSearch(                                                   \
    LPWSTR pszSearchFilter,                                           \
    LPWSTR * pAttributeNames,                                         \
    DWORD dwNumberAttributes,                                         \
    PADS_SEARCH_HANDLE phSearchResult                                 \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->ExecuteSearch(                                   \
                         pszSearchFilter,                             \
                         pAttributeNames,                             \
                         dwNumberAttributes,                          \
                         phSearchResult                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::AbandonSearch(                                                   \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->AbandonSearch(                                   \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetFirstRow(                                                     \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetFirstRow(                                     \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextRow(                                                      \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextRow(                                      \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPreviousRow(                                                  \
    ADS_SEARCH_HANDLE hSearchResult                                   \
                                                                      \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetPreviousRow(                                  \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetNextColumnName(                                               \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR * ppszColumnName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetNextColumnName(                               \
                         hSearchResult,                               \
                         ppszColumnName                               \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetColumn(                                                       \
    ADS_SEARCH_HANDLE hSearchResult,                                  \
    LPWSTR szColumnName,                                              \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->GetColumn(                                       \
                         hSearchResult,                               \
                         szColumnName,                                \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::FreeColumn(                                                      \
    PADS_SEARCH_COLUMN pSearchColumn                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->FreeColumn(                                      \
                         pSearchColumn                                \
                         );                                           \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CloseSearchHandle(                                               \
    ADS_SEARCH_HANDLE hSearchResult                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSearch->CloseSearchHandle(                               \
                         hSearchResult                                \
                         );                                           \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsPropertyList_Implementation(cls)         \
STDMETHODIMP                                                          \
cls::get_PropertyCount(THIS_ long  FAR * plCount)                     \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->get_PropertyCount(                            \
                    plCount                                           \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Next(THIS_ VARIANT FAR *pVariant)                                \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Next(                                         \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Skip(THIS_ long cElements)                                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Skip(                                         \
                    cElements                                         \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::Reset()                                                          \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Reset(                                        \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ResetPropertyItem(THIS_ VARIANT varEntry)                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->ResetPropertyItem(                           \
                    varEntry                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetPropertyItem(THIS_ BSTR bstrName, LONG lnADsType, VARIANT * pVariant)      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->GetPropertyItem(                              \
                    bstrName,                                         \
                    lnADsType,                                        \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::PutPropertyItem(THIS_ VARIANT varData)                           \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->PutPropertyItem(                                          \
                varData                                                                   \
                );                                                                            \
                                                                      \
    RRETURN(hr);                                                      \
                                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::PurgePropertyList(THIS_)                                                       \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->PurgePropertyList();                          \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pADsPropList->Item(                                         \
                    varIndex,                                         \
                    pVariant                                          \
                    );                                                \
                                                                      \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(cls)              \
STDMETHODIMP                                                          \
cls::EnumAttributes(                                                  \
    LPWSTR * ppszAttrNames,                                           \
    DWORD dwNumAttributes,                                            \
    PADS_ATTR_DEF * ppAttrDefinition,                                 \
    DWORD * pdwNumAttributes                                          \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->EnumAttributes(                                \
              ppszAttrNames,                                          \
              dwNumAttributes,                                        \
              ppAttrDefinition,                                       \
              pdwNumAttributes                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateAttributeDefinition(                                       \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF pAttributeDefinition                                \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->CreateAttributeDefinition(                     \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteAttributeDefinition(                                        \
    LPWSTR pszAttributeName,                                          \
    PADS_ATTR_DEF  pAttributeDefinition                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->WriteAttributeDefinition(                      \
              pszAttributeName,                                       \
              pAttributeDefinition                                    \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteAttributeDefinition(                                       \
    LPWSTR pszAttributeName                                           \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->DeleteAttributeDefinition(                     \
              pszAttributeName                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                       \
STDMETHODIMP                                                           \
cls::EnumClasses(                                                     \
    LPWSTR * ppszClassNames,                                           \
    DWORD dwNumClasses,                                               \
    PADS_CLASS_DEF * ppClassDefinition,                                 \
    DWORD * pdwNumClasses                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->EnumClasses(                                    \
              ppszClassNames,                                          \
              dwNumClasses,                                           \
              ppClassDefinition,                                       \
              pdwNumClasses                                           \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateClassDefinition(                                           \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF pClassDefinition                                    \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->CreateClassDefinition(                          \
              pszClassName,                                           \
              pClassDefinition                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::WriteClassDefinition(                                            \
    LPWSTR pszClassName,                                              \
    PADS_CLASS_DEF  pClassDefinition                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->WriteClassDefinition(                           \
              pszClassName,                                           \
              pClassDefinition                                        \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteClassDefinition(                                           \
    LPWSTR pszClassName                                               \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSSchemaMgmt->DeleteClassDefinition(                          \
              pszClassName                                            \
              );                                                      \
                                                                      \
    RRETURN(hr);                                                      \
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        BSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
            _ADsPath,
            ClassName,
            &_Schema
            );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_Schema) {
        ADsFreeString(_Schema);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsClass, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = ADsAllocString(_Schema, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(
    BOOL fExplicit
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\common.cxx ===
#include "nds.hxx"
#pragma hdrstop

FILTERS Filters[] = {
                    {L"user", NDS_USER_ID},
                    {L"group", NDS_GROUP_ID},
                    {L"queue", NDS_PRINTER_ID},
                    {L"domain", NDS_DOMAIN_ID},
                    {L"computer", NDS_COMPUTER_ID},
                    {L"service", NDS_SERVICE_ID},
                    {L"fileservice", NDS_FILESERVICE_ID},
                    {L"fileshare", NDS_FILESHARE_ID},
                    {L"class", NDS_CLASS_ID},
                    {L"functionalset", NDS_FUNCTIONALSET_ID},
                    {L"syntax", NDS_SYNTAX_ID},
                    {L"property", NDS_PROPERTY_ID},
                    {L"tree", NDS_TREE_ID},
                    {L"Organizational Unit", NDS_OU_ID},
                    {L"Organization", NDS_O_ID},
                    {L"Locality", NDS_LOCALITY_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;



//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------


HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    LPWSTR lpADsPath = NULL;
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwLen = 0;
    LPWSTR pszDisplayName = NULL;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);

    if ((!Name) || (!Parent) || (!pADsPath)) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Get the display name for the name; The display name will have the proper 
    // escaping for characters that have special meaning in an ADsPath like
    // '/' etc. 
    //
    hr = GetDisplayName(
             Name,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        hr = ADsAllocString( pszDisplayName, pADsPath);
        BAIL_ON_FAILURE(hr);
        goto cleanup;
    }

    //
    // Allocate the right side buffer
    // 2 for // + a buffer of MAX_PATH
    //
    dwLen = wcslen(Parent) + wcslen(pszDisplayName) + 2 + MAX_PATH;

    lpADsPath = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));
    if (!lpADsPath) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"WinNT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(lpADsPath, Parent);

    if (_wcsicmp(lpADsPath, ProviderName)) {
        wcscat(lpADsPath, L"/");
    }else {
        wcscat(lpADsPath, L"//");
    }
    wcscat(lpADsPath, pszDisplayName);

    hr = ADsAllocString( lpADsPath, pADsPath);

cleanup:
error:

    if (lpADsPath) {
        FreeADsMem(lpADsPath);
    }

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR bstrADsPath,
    BSTR bstrClass,
    BSTR *pSchemaPath
    )
{
    WCHAR ADsSchema[MAX_PATH];
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(bstrADsPath);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    wcscpy(ADsSchema, L"");
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (bstrClass && *bstrClass) {
        hr = ADsObject(&Lexer, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        if (pObjectInfo->TreeName) {

            wsprintf(ADsSchema,L"%s://",pObjectInfo->ProviderName);
            wcscat(ADsSchema, pObjectInfo->TreeName);
            wcscat(ADsSchema,L"/schema/");
            wcscat(ADsSchema, bstrClass);

        }
    }

    hr = ADsAllocString( ADsSchema, pSchemaPath);

error:

    if (pObjectInfo) {

        FreeObjectInfo( pObjectInfo );
    }
    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }

    RRETURN(ADsAllocString( ADsClass, pADsClass));
}


HRESULT
MakeUncName(
    LPWSTR szSrcBuffer,
    LPWSTR szTargBuffer
    )
{
    ADsAssert(szSrcBuffer && *szSrcBuffer);
    wcscpy(szTargBuffer, L"\\\\");
    wcscat(szTargBuffer, szSrcBuffer);
    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}


PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData,
    WCHAR ch
    )
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;
    WCHAR szTokenList[MAX_PATH];


    if (!psz || !*psz)
        return NULL;

    wsprintf(szTokenList, L"%c", ch);

    cTokens=1;

    // Scan through the string looking for commas,
    // ensuring that each is followed by a non-NULL character:

    while ((psz = wcschr(psz, ch)) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +
         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocADsMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    // Then copy the key data buffer there:

    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;


    // Remember, wcstok has the side effect of replacing the delimiter
    // by NULL, which is precisely what we want:

    psz = wcstok (pDest, szTokenList);

    while (psz) {

        *ppToken++ = psz;
        psz = wcstok (NULL, szTokenList);
    }

    pResult->cTokens = cTokens;

    return( pResult );
}


DWORD
ADsNwNdsOpenObject(
    IN  LPWSTR   ObjectDN,
    IN  CCredentials& Credentials,
    OUT HANDLE * lphObject,
    OUT LPWSTR   lpObjectFullName OPTIONAL,
    OUT LPWSTR   lpObjectClassName OPTIONAL,
    OUT LPDWORD  lpdwModificationTime,
    OUT LPDWORD  lpdwSubordinateCount OPTIONAL
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    hr = Credentials.GetUserName(&pszUserName);
    hr = Credentials.GetPassword(&pszPassword);

    dwStatus = NwNdsOpenObject(
                    ObjectDN,
                    pszUserName,
                    pszPassword,
                    lphObject,
                    NULL, // szObjectName optional parameter
                    lpObjectFullName,
                    lpObjectClassName,
                    lpdwModificationTime,
                    lpdwSubordinateCount
                    );


    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    return(dwStatus);

}

HRESULT
CheckAndSetExtendedError(
    DWORD dwRetval
    )

{
    DWORD dwLastError;
    WCHAR pszErrorString[MAX_PATH];
    WCHAR pszProviderName[MAX_PATH];
    INT   numChars;
    HRESULT hr =S_OK;

    wcscpy(pszErrorString, L"");
    wcscpy(pszProviderName, L"");

    if (dwRetval == NDS_ERR_SUCCESS){
        hr = S_OK;

    } else {
        dwLastError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwLastError);

        if (dwLastError == ERROR_EXTENDED_ERROR){
            numChars = LoadString( g_hInst,
                                   dwRetval,
                                   pszErrorString,
                                   MAX_PATH-1);
            numChars = LoadString( g_hInst,
                                   NDS_PROVIDER_ID,
                                   pszProviderName,
                                   MAX_PATH -1);

            ADsSetLastError( dwRetval,
                             pszErrorString,
                             pszProviderName );

        }

    }


    RRETURN(hr);
}



HRESULT
CopyObject(
    IN LPWSTR pszSrcADsPath,
    IN LPWSTR pszDestContainer,
    IN LPWSTR pszCommonName,           //optional
    IN CCredentials Credentials,
    OUT VOID ** ppObject
    )

{
    //
    // this function is a wrapper for the copy functionality which is used
    // by both IADsContainer::CopyHere and IADsContainer::MoveHere
    //

    HRESULT hr = S_OK;
    DWORD dwStatus = 0L;

    LPWSTR pszNDSSrcName = NULL;
    LPWSTR pszNDSParentName = NULL;

    HANDLE hSrcOperationData = NULL;
    HANDLE hSrcObject = NULL;
    HANDLE hDestOperationData = NULL;
    HANDLE hDestObject = NULL;
    HANDLE hAttrOperationData = NULL;
    DWORD dwNumEntries = 0L;
    LPNDS_ATTR_INFO lpEntries = NULL;
    LPWSTR  pszObjectFullName= NULL;
    LPWSTR  pszObjectClassName= NULL;
    LPWSTR  pszParent= NULL;
    LPWSTR  pszRelativeName = NULL;
    LPWSTR  pszCN = NULL;
    DWORD  i = 0;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDef = NULL;
    IADs  *pADs = NULL;
    
    //
    // allocate all variables that are needed
    //

    pszObjectFullName = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszObjectFullName){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pszObjectClassName = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszObjectClassName){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pszParent = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszParent){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pszCN = (LPWSTR)AllocADsMem(MAX_PATH* sizeof(WCHAR));

    if (!pszCN){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = BuildNDSPathFromADsPath(
                pszSrcADsPath,
                &pszNDSSrcName
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildADsParentPath(
                    pszSrcADsPath,
                    pszParent,
                    pszCN
                    );

    BAIL_ON_FAILURE(hr);


    dwStatus = ADsNwNdsOpenObject(
                    pszNDSSrcName,
                    Credentials,
                    &hSrcObject,
                    pszObjectFullName,
                    pszObjectClassName,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsReadObject(
                    hSrcObject,
                    NDS_INFO_ATTR_NAMES_VALUES,
                    &hSrcOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetAttrListFromBuffer(
                    hSrcOperationData,
                    &dwNumEntries,
                    &lpEntries
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    //
    // we have now extracted all the information we need from the source
    // object, we need to add this information to the destination object
    // as attributes and values
    //

    //
    // create the destination object
    //


    hr = BuildNDSPathFromADsPath(
                pszDestContainer,
                &pszNDSParentName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSParentName,
                    Credentials,
                    &hDestObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);



    //
    // use the name given by the user if given at all
    // otherwise use the name of the source
    //

    if ( pszCommonName != NULL) {
        pszRelativeName = pszCommonName;

    } else {
        pszRelativeName = pszCN;
    }

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_ADD,
                        &hDestOperationData
                        );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    //
    // take each of these entries and get back their schema
    // attribute definitions. the same handle to the DestObject
    // can be used to open the schema
    //



    dwStatus = NwNdsCreateBuffer(
                        NDS_SCHEMA_READ_ATTR_DEF,
                        &hAttrOperationData
                        );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for(i=0; i< dwNumEntries; i++){

        dwStatus = NwNdsPutInBuffer(
                       lpEntries[i].szAttributeName,
                       0,
                       NULL,
                       0,
                       0,
                       hAttrOperationData
                       );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    }


    dwStatus = NwNdsReadAttrDef(
                   hDestObject,
                   NDS_INFO_NAMES_DEFS,
                   & hAttrOperationData
                   );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetAttrDefListFromBuffer(
                   hAttrOperationData,
                   & dwNumEntries,
                   & dwInfoType,
                   (void **)& lpAttrDef
                   );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i=0; i< dwNumEntries; i++){


        if(wcscmp(lpEntries[i].szAttributeName, ACL_name) == 0){
            //
            // skip this attribute. Let it default
            //
            continue;
        }

        if(wcscmp(lpEntries[i].szAttributeName, OBJECT_CLASS_name) == 0){
            dwStatus = NwNdsPutInBuffer(
                           lpEntries[i].szAttributeName,
                           lpEntries[i].dwSyntaxId,
                           lpEntries[i].lpValue,
                           1, // only the first value is relevant
                           NDS_ATTR_ADD,
                           hDestOperationData
                           );

        } else if (   (lpAttrDef[i].dwFlags & NDS_READ_ONLY_ATTR)
                      || (lpAttrDef[i].dwFlags & NDS_HIDDEN_ATTR)  ){

            //
            // skip this value
            //
            continue;

        } else {

            dwStatus = NwNdsPutInBuffer(
                           lpEntries[i].szAttributeName,
                           lpEntries[i].dwSyntaxId,
                           lpEntries[i].lpValue,
                           lpEntries[i].dwNumberOfValues,
                           NDS_ATTR_ADD,
                           hDestOperationData
                           );

        }

    }

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
    dwStatus = NwNdsAddObject(
                   hDestObject,
                   pszRelativeName,
                   hDestOperationData
                   );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = CNDSGenObject::CreateGenericObject(
                    pszDestContainer,
                    pszRelativeName,
                    pszObjectClassName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);


    //
    // InstantiateDerivedObject should add-ref this pointer for us.
    //
    
    hr = InstantiateDerivedObject(
                        pADs,
                        Credentials,
                        IID_IUnknown,
                        ppObject
                        );

    if (FAILED(hr)) {
        hr = pADs->QueryInterface(
                            IID_IUnknown,
                            ppObject
                            );
        BAIL_ON_FAILURE(hr);
    }


error:

    if (pszObjectFullName){
        FreeADsMem(pszObjectFullName);
    }

    if (pszObjectClassName){
        FreeADsMem(pszObjectClassName);
    }

    if (pszParent){
        FreeADsMem(pszParent);
    }

    if (pszCN){
        FreeADsMem(pszCN);
    }

    if (pszNDSSrcName) {

        FreeADsStr(pszNDSSrcName);
    }


    if (pszNDSParentName) {

        FreeADsStr(pszNDSParentName);
    }

    if(hSrcOperationData){
        dwStatus = NwNdsFreeBuffer(hSrcOperationData);
    }

    if(hSrcObject){
        dwStatus = NwNdsCloseObject(hSrcObject);
    }


    if(hDestOperationData){
        dwStatus = NwNdsFreeBuffer(hDestOperationData);
    }

    if(hDestObject){
        dwStatus = NwNdsCloseObject(hDestObject);
    }

    if(hAttrOperationData){
        dwStatus = NwNdsFreeBuffer(hAttrOperationData);
    }

    if (pADs){
        pADs->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertDWORDtoSYSTEMTIME(
    DWORD dwDate,
    LPSYSTEMTIME pSystemTime
    )
{
    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;

    ::RtlSecondsSince1970ToTime(dwDate, &tmpTime );

    fileTime.dwLowDateTime = tmpTime.LowPart;
    fileTime.dwHighDateTime = tmpTime.HighPart;

    if (!FileTimeToSystemTime( &fileTime, pSystemTime)){
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

HRESULT
ConvertSYSTEMTIMEtoDWORD(
    CONST SYSTEMTIME *pSystemTime,
    DWORD *pdwDate
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;

    if (!SystemTimeToFileTime(pSystemTime,&fileTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    tmpTime.LowPart = fileTime.dwLowDateTime;
    tmpTime.HighPart = fileTime.dwHighDateTime;

    ::RtlTimeToSecondsSince1970(&tmpTime, (ULONG *)pdwDate);

error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamcf.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object Class Factory Code
//
//             CNDSNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CNDSNamespace::CreateNamespace(
                L"ADs:",
                L"NDS:",
                Credentials,
                ADS_OBJECT_BOUND,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\corg.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cOrganization.cxx
//
//  Contents:  Organization object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aOrgPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("SeeAlso"), TEXT("See Also") }
};

//  Class CNDSOrganization

DEFINE_IDispatch_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADs_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSOrganization)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSOrganization, aOrgPropMapping)


CNDSOrganization::CNDSOrganization():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSOrganization);
}


HRESULT
CNDSOrganization::CreateOrganization(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSOrganization FAR * pOrganization = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOrganizationObject(pADs, &pOrganization);
    BAIL_ON_FAILURE(hr);

    hr = pOrganization->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOrganization->Release();

    RRETURN(hr);

error:
    delete pOrganization;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSOrganization::~CNDSOrganization( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if (_pDSObject) {
        _pDSObject->Release();
    }

    if (_pDSSearch) {
        _pDSSearch->Release();
    }

    if (_pDSSchemaMgmt) {
        _pDSSchemaMgmt->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }


    delete _pDispMgr;
}

STDMETHODIMP
CNDSOrganization::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsO))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsO FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList) && _pADsPropList)
    {
        *ppv = (IADsPropertyList  FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSOrganization::AllocateOrganizationObject(
    IADs *pADs,
    CNDSOrganization ** ppOrganization
    )
{
    CNDSOrganization FAR * pOrganization = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pOrganization = new CNDSOrganization();
    if (pOrganization == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsO,
                (IADsO *)pOrganization,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pOrganization,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pOrganization,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pDSSchemaMgmt = pDSSchemaMgmt;

    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pADsPropList = pADsPropList;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pOrganization->_pADs = pADs;
    pADs->AddRef();

    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pOrganization->_pADsContainer = pADsContainer;


    pOrganization->_pDispMgr = pDispMgr;
    *ppOrganization = pOrganization;

    RRETURN(hr);

error:

    delete  pOrganization;

    *ppOrganization = NULL;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSOrganization::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
)
{
    if (IsEqualIID(riid, IID_IADs) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsO) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP CNDSOrganization::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,Description);
}

STDMETHODIMP CNDSOrganization::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsO *)this,Description);
}



STDMETHODIMP CNDSOrganization::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,LocalityName);
}

STDMETHODIMP CNDSOrganization::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsO *)this,LocalityName);
}



STDMETHODIMP CNDSOrganization::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}

STDMETHODIMP CNDSOrganization::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsO *)this,PostalAddress);
}


STDMETHODIMP CNDSOrganization::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}

STDMETHODIMP CNDSOrganization::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,TelephoneNumber);
}


STDMETHODIMP CNDSOrganization::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}

STDMETHODIMP CNDSOrganization::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsO *)this,FaxNumber);
}


STDMETHODIMP CNDSOrganization::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

STDMETHODIMP CNDSOrganization::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsO *)this,SeeAlso);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSOrganization::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSOrganization::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSOrganization::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSOrganization::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganization::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamesp.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "NDS.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CNDSNamespace)
DEFINE_IADs_Implementation(CNDSNamespace)

//  Class CNDSNamespace

CNDSNamespace::CNDSNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNDSNamespace);
}

HRESULT
CNDSNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(
                Credentials,
                &pNamespace
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                L"Namespace",
                L"",
                CLSID_NDSNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN_EXP_IF_ERR(hr);
}


CNDSNamespace::~CNDSNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CNDSNamespace::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider)) 
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSNamespace::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsOpenDSObject)) {
        RRETURN(S_OK);
    }  else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNDSNamespace::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSNamespace::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                TRUE
                );
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CNDSNamespaceEnum::Create(
                (CNDSNamespaceEnum **)&penum,
                _vFilter,
                _Credentials
                );
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSNamespace::MoveHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSNamespace::AllocateNamespaceObject(
    CCredentials& Credentials,
    CNDSNamespace ** ppNamespace
    )
{
    CNDSNamespace FAR * pNamespace = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CNDSNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsOpenDSObject,
                           (IADsOpenDSObject *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespace,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;
    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}




STDMETHODIMP
CNDSNamespace::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    //
    // retrieve dataobject from cache; if one exists
    //



    //
    //
    //
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSNamespace::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSNamespace::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch FAR * * ppADsObj
    )
{
    HRESULT hr = S_OK;
    IUnknown * pObject = NULL;
    CCredentials Credentials(lpszUserName, lpszPassword, 0L);

    hr = ::GetObject(
                lpszDNName,
                Credentials,
                (LPVOID *)&pObject
                );
    BAIL_ON_FAILURE(hr);



    hr = pObject->QueryInterface(
                        IID_IDispatch,
                        (void **)ppADsObj
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pObject) {
        pObject->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSNamespace::ParsePath(
    BSTR bstrADsPath, 
    DWORD dwType, 
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - the place where the parsed object is stored
    
Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    PWSTR szPath = NULL;

    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            CLexer Lexer(bstrADsPath);
        
            hr = ADsObject(&Lexer, pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            CLexer Lexer(bstrADsPath);
        
            Lexer.SetAtDisabler(TRUE);
        
            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->ProviderName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->TreeName) {
        pObjectInfo->ServerName = AllocADsStr(pObjInfo->TreeName);
        if (!pObjectInfo->ServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pObjInfo->DisplayTreeName) {
        pObjectInfo->DisplayServerName = AllocADsStr(pObjInfo->DisplayTreeName);
        if (!pObjectInfo->DisplayServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;

error:
    FreeObjectInfo(pObjInfo);
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    return (hr);
}

HRESULT
CNDSNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the 
    components in the target objinfo is empty. Users of this function can call 
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            pObjectInfoTarget->ComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szValue == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);

    RRETURN_EXP_IF_ERR(hr);
}

void
CNDSNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void 
CNDSNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    BOOL fEscaped
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    if (fEscaped) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }
    else {
        pComponent = _pObjectInfo->ComponentArray;
    }

    if (_fNamingAttribute) {
        wcscat(szReturn, pComponent[cComponents].szComponent);
        if (pComponent[cComponents].szValue) {
            wcscat(szReturn,
                   TEXT("="));
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
    }
    else {
        if (pComponent[cComponents].szValue) {
            //
            // If value exist, only show display value
            //
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
        else {
            //
            // else value is only stored in Component
            //
            wcscat(szReturn,
                   pComponent[cComponents].szComponent);
        }
    }
}


HRESULT 
CNDSNamespace::SetComponents(
                            LPWSTR szReturn,
                            BOOLEAN bIsWindowsPath,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            BOOL fEscaped
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    bIsWindowsPath - whether a windows path is to be returned
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    BOOL bReverse;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             fEscaped);
            } 
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
        bReverse = !bIsWindowsPath;
    }
    else {
        bReverse = bIsWindowsPath;
    }


    if (!bReverse) {
        dwLimit = _pObjectInfo->NumComponents;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwOtherLimit >= dwLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
            SetComponent(szReturn,
                         cComponents,
                         fEscaped);
            if (cComponents != dwLimit - 1) {
                wcscat(szReturn,
                       chSeparator);
            }
        }
    }
    else {
        dwLimit = _pObjectInfo->NumComponents-1;
        if (dwType == ADS_COMPONENT_PARENT) {
            if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) 
                dwLimit--;
            else
                dwOtherLimit++;
        }
        if (dwLimit < dwOtherLimit) {
            hr = E_ADS_BAD_PATHNAME;
            goto error;
        }
        for (cComponents = dwLimit ; (long)cComponents >= dwOtherLimit; cComponents--) {
            SetComponent(szReturn,
                         cComponents,
                         fEscaped);
            if (cComponents != dwOtherLimit) {
                wcscat(szReturn, chSeparator);
            }
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2; 
    }
    return dwPath;
}


STDMETHODIMP
CNDSNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    BOOL fEscaped = FALSE;

    switch (dwEscapedMode) {
        case ADS_ESCAPEDMODE_OFF:
        case ADS_ESCAPEDMODE_OFF_EX:
        case ADS_ESCAPEDMODE_DEFAULT:
            fEscaped = FALSE;
            break;
        case ADS_ESCAPEDMODE_ON:
            fEscaped = TRUE;
            break;
        default:
            hr = E_INVALIDARG;
            goto error;
    }

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _fNamingAttribute = (BOOLEAN)(dwFlag & ADS_CONSTRUCT_NAMINGATTRIBUTE);
    _pObjectInfo = pObjectInfo;

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                fEscaped = TRUE;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                    wcscat(szReturn,pObjectInfo->DisplayServerName);
                    if (pObjectInfo->NumComponents>0) {
                        wcscat(szReturn,TEXT("/"));
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TRUE,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
        case ADS_FORMAT_X500_DN:
        case ADS_FORMAT_X500_PARENT:
            hr = E_NOTIMPL;
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\corgu.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  OrganizationUnit object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aOrgUnitPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("LocalityName"), TEXT("L") },
  { TEXT("PostalAddress"), TEXT("Postal Address") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("SeeAlso"), TEXT("See Also") }
  // { TEXT("BusinessCategory"), TEXT("businessCategory") } BUG BUG
};


//  Class CNDSOrganizationUnit

DEFINE_IDispatch_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADs_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSOrganizationUnit)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSOrganizationUnit, aOrgUnitPropMapping)


CNDSOrganizationUnit::CNDSOrganizationUnit():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pADsContainer(NULL),
        _pADsPropList(NULL),
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CNDSOrganizationUnit);
}


HRESULT
CNDSOrganizationUnit::CreateOrganizationUnit(
    IADs * pADs,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSOrganizationUnit FAR * pOrganizationUnit = NULL;
    HRESULT hr = S_OK;

    hr = AllocateOrganizationUnitObject(pADs, &pOrganizationUnit);
    BAIL_ON_FAILURE(hr);

    hr = pOrganizationUnit->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->Release();

    RRETURN(hr);

error:
    delete pOrganizationUnit;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSOrganizationUnit::~CNDSOrganizationUnit( )
{
    if ( _pADs )
        _pADs->Release();

    if ( _pADsContainer )
        _pADsContainer->Release();

    if ( _pDSObject )
        _pDSObject->Release();

    if ( _pDSSearch )
        _pDSSearch->Release();

    if ( _pDSSchemaMgmt )
        _pDSSchemaMgmt->Release();


    if (_pADsPropList) {
        _pADsPropList->Release();
    }


    delete _pDispMgr;
}

STDMETHODIMP
CNDSOrganizationUnit::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOU))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsOU FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer) && _pADsContainer)
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList ) && _pADsPropList)
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSOrganizationUnit::AllocateOrganizationUnitObject(
    IADs *pADs,
    CNDSOrganizationUnit ** ppOrganizationUnit
    )
{
    CNDSOrganizationUnit FAR * pOrganizationUnit = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IADsContainer FAR * pADsContainer = NULL;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;


    pOrganizationUnit = new CNDSOrganizationUnit();
    if (pOrganizationUnit == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsOU,
                (IADsOU *)pOrganizationUnit,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pOrganizationUnit,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pOrganizationUnit,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSObject = pDSObject;

    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);

    pOrganizationUnit->_pDSSchemaMgmt = pDSSchemaMgmt;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pOrganizationUnit->_pADs = pADs;
    pADs->AddRef();

    //
    // Store a pointer to the Container interface
    //

    hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)&pADsContainer
                        );
    BAIL_ON_FAILURE(hr);
    pOrganizationUnit->_pADsContainer = pADsContainer;


    hr = pADs->QueryInterface(
                        IID_IADsPropertyList,
                        (void **)&pADsPropList
                        );
    BAIL_ON_FAILURE(hr);
    pOrganizationUnit->_pADsPropList = pADsPropList;



    pOrganizationUnit->_pDispMgr = pDispMgr;
    *ppOrganizationUnit = pOrganizationUnit;

    RRETURN(hr);

error:

    if (pADsContainer) {
        pADsContainer->Release();
    }


    if (pADsPropList) {

        pADsPropList->Release();
    }


    delete  pDispMgr;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSOrganizationUnit::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
)
{
    if (IsEqualIID(riid, IID_IADs) ||
#if 0
        IsEqualIID(riid, IID_IDirectoryObject) ||
        IsEqualIID(riid, IID_IDirectorySearch) ||
        IsEqualIID(riid, IID_IDirectorySchemaMgmt) ||
#endif
        IsEqualIID(riid, IID_IADsOU) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP CNDSOrganizationUnit::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,Description);
}

STDMETHODIMP CNDSOrganizationUnit::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,Description);
}



STDMETHODIMP CNDSOrganizationUnit::get_LocalityName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}

STDMETHODIMP CNDSOrganizationUnit::put_LocalityName(THIS_ BSTR bstrLocalityName)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,LocalityName);
}



STDMETHODIMP CNDSOrganizationUnit::get_PostalAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}

STDMETHODIMP CNDSOrganizationUnit::put_PostalAddress(THIS_ BSTR bstrPostalAddress)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,PostalAddress);
}


STDMETHODIMP CNDSOrganizationUnit::get_TelephoneNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}

STDMETHODIMP CNDSOrganizationUnit::put_TelephoneNumber(THIS_ BSTR bstrTelephoneNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,TelephoneNumber);
}


STDMETHODIMP CNDSOrganizationUnit::get_FaxNumber(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}

STDMETHODIMP CNDSOrganizationUnit::put_FaxNumber(THIS_ BSTR bstrFaxNumber)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,FaxNumber);
}


STDMETHODIMP CNDSOrganizationUnit::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}

STDMETHODIMP CNDSOrganizationUnit::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    PUT_PROPERTY_VARIANT((IADsOU *)this,SeeAlso);
}


STDMETHODIMP CNDSOrganizationUnit::get_BusinessCategory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}

STDMETHODIMP CNDSOrganizationUnit::put_BusinessCategory(THIS_ BSTR bstrBusinessCategory)
{
    PUT_PROPERTY_BSTR((IADsOU *)this,BusinessCategory);
}


/* IADsContainer methods */

STDMETHODIMP
CNDSOrganizationUnit::get_Count(long FAR* retval)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Count(
                            retval
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Filter(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Filter(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::put_Hints(THIS_ VARIANT Var)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->put_Hints(
                            Var
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CNDSOrganizationUnit::get_Hints(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get_Hints(
                            pVar
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->GetObject(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->get__NewEnum(
                            retval
                            );
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSOrganizationUnit::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Create(
                            ClassName,
                            RelativeName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSOrganizationUnit::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->Delete(
                            bstrClassName,
                            bstrRelativeName
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->CopyHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSOrganizationUnit::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = E_NOTIMPL;
    if (_pADsContainer) {
        hr = _pADsContainer->MoveHere(
                            SourceName,
                            NewName,
                            ppObject
                            );
    }

    RRETURN_EXP_IF_ERR(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cpgi.cxx ===
/*++


  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

--*/

#include "nds.hxx"
#pragma hdrstop

//
//  CNDSPrintQueue
//

STDMETHODIMP
CNDSPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNDSPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CNDSPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CNDSPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CNDSPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CNDSPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}


STDMETHODIMP CNDSPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP CNDSPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}


STDMETHODIMP
CNDSPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNDSPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CNDSPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);

}

STDMETHODIMP
CNDSPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CNDSPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNDSPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CNDSPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNDSPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CNDSPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNDSPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CNDSPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr = E_FAIL;
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSPrintQueue::put_PrinterPath(THIS_ BSTR bstrPrinterPath)
{
    //
    // Cannot change this in Windows NT!
    //
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNDSPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CNDSPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNDSPrintQueue::put_PrintDevices(THIS_ VARIANT vPorts)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, Ports);
}

STDMETHODIMP
CNDSPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

STDMETHODIMP
CNDSPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

//
// Class CNDSPrintQueue
//

/* IADsFSPrintQueueOperation methods */

STDMETHODIMP
CNDSPrintQueue::PrintJobs(
    THIS_ IADsCollection * FAR* ppCollection
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}




//+------------------------------------------------------------------------
//
//  Function: CNDSPrintQueue::Pause
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName
//   and attempts to pause the real printer.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//  Appropriated from Old NetOle Code.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CNDSPrintQueue::Pause(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    LPWSTR pszNDSPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pause printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PAUSE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNDSPrintQueue::Resume
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName and
//              attempts to resume the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV  Created
//              Appropriated from old NetOle Project
//----------------------------------------------------------------------------


STDMETHODIMP
CNDSPrintQueue::Resume(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPath = NULL;
    BSTR bstrADsPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
               );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Resume printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_RESUME
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CNDSPrintQueue::Purge
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to purge the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV   Created
//              Appropriated from old NetOle Code
//----------------------------------------------------------------------------


STDMETHODIMP
CNDSPrintQueue::Purge(THIS)
{
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPath = NULL;
    BSTR bstrADsPath = NULL;

    //
    // Make NDS Path
    //

    hr = _pADs->get_ADsPath(
                &bstrADsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPath
                );
    BAIL_ON_FAILURE(hr);


    //
    // Open a handle to the printer with Administer access.
    //

    hr = NWApiOpenPrinter(
             pszNDSPath,
             &hPrinter,
             PRINTER_ACCESS_ADMINISTER
             );
    BAIL_ON_FAILURE(hr);

    //
    // Purge printer.
    //

    hr = NWApiSetPrinter(
             hPrinter,
             0,
             NULL,
             PRINTER_CONTROL_PURGE
             );
error:

    if (hPrinter) {
        NWApiClosePrinter(hPrinter);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPath) {
        FreeADsStr(pszNDSPath);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSPrintQueue::get_Status(THIS_ long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cprinter.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

  --*/

#include "nds.hxx"
#pragma hdrstop

//
// Class CNDSPrintQueue Methods
//

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aPrintPropMapping[] =
{ { TEXT("Description"), TEXT("Description") },
  { TEXT("Location"), TEXT("L") },
  { TEXT("HostComputer"), TEXT("Host Server") }
};

DEFINE_IDispatch_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADs_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSPrintQueue)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSPrintQueue, aPrintPropMapping)

CNDSPrintQueue::CNDSPrintQueue():
                    _pADs(NULL),
                    _pADsPropList(NULL)
{
    _pDispMgr = NULL;
    ENLIST_TRACKING(CNDSPrintQueue);
    return;
}


CNDSPrintQueue::~CNDSPrintQueue()
{

    if (_pADs) {

        _pADs->Release();
    }

    if (_pADsPropList) {

        _pADsPropList->Release();
    }


    delete _pDispMgr;

    return;
}

HRESULT
CNDSPrintQueue:: CreatePrintQueue(
    IADs * pADs,
    REFIID riid,
    LPVOID * ppvoid
    )

{

    CNDSPrintQueue  *pPrintQueue =  NULL;
    HRESULT hr;

    //
    // Create the printer object
    //

    hr = AllocatePrintQueueObject(
                    pADs,
                    &pPrintQueue
                    );
    BAIL_ON_FAILURE(hr);

    //
    // initialize the core object
    //

    BAIL_ON_FAILURE(hr);


    hr = pPrintQueue->QueryInterface(
                        riid,
                        (void **)ppvoid
                        );
    BAIL_ON_FAILURE(hr);


    pPrintQueue->Release();
    RRETURN(hr);

error:
    delete pPrintQueue;
    RRETURN_EXP_IF_ERR(hr);
}

/* IUnknown methods for printer object  */

STDMETHODIMP
CNDSPrintQueue::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintQueue FAR *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueue))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueueOperations))
    {
      *ppvObj = (IADsPrintQueueOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList) && _pADsPropList)
    {
      *ppvObj = (IADsPropertyList FAR *) this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}


HRESULT
CNDSPrintQueue::AllocatePrintQueueObject(
    IADs * pADs,
    CNDSPrintQueue ** ppPrintQueue
    )
{
    CNDSPrintQueue FAR * pPrintQueue = NULL;
    HRESULT hr = S_OK;

    pPrintQueue = new CNDSPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pPrintQueue->_pDispMgr = new CDispatchMgr;
    if (pPrintQueue->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }

    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintQueue,
                (IADsPrintQueue *)pPrintQueue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintQueueOperations,
                (IADsPrintQueueOperations *)pPrintQueue,
                DISPID_REGULAR
                );

    hr = LoadTypeInfoEntry(
                pPrintQueue->_pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pPrintQueue,
                DISPID_VALUE
                );

    BAIL_ON_FAILURE(hr);

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pPrintQueue->_pADs = pADs;
    pADs->AddRef();

    *ppPrintQueue = pPrintQueue;
    RRETURN(hr);

error:

    delete  pPrintQueue;
    RRETURN(hr);
}

/* ISupportErrorInfo method */
STDMETHODIMP 
CNDSPrintQueue::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintQueue) ||
        IsEqualIID(riid, IID_IADsPrintQueueOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  NDS Provider Object Class Factory Code
//
//             CNDSProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CNDSProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNDSProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cprpobj.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cclsobj.cxx
//
//  Contents:  Microsoft ADs NDS Provider Generic Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


// Class CNDSProperty

DECLARE_INFOLEVEL( Syntax );
DECLARE_DEBUG( Syntax );
#define SyntaxDebugOut(x) SyntaxInlineDebugOut x

DEFINE_IDispatch_Implementation(CNDSProperty)
DEFINE_IADs_Implementation(CNDSProperty)

CNDSProperty::CNDSProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE )
{

    ENLIST_TRACKING(CNDSProperty);
}

CNDSProperty::~CNDSProperty()
{
    delete _pDispMgr;
}

HRESULT
CNDSProperty::CreateProperty(
    BSTR   bstrParent,
    BSTR   bstrName,
    LPNDS_ATTR_DEF lpAttrDef,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;
    WCHAR szADsSyntax[MAX_PATH];
    WCHAR szNDSSyntax[MAX_PATH];

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             bstrName,
             PROPERTY_CLASS_NAME,
             L"",
             CLSID_NDSProperty,
             dwObjectState
             );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

#if DBG
        SyntaxDebugOut((DEB_TRACE,
                           "Property %s : SyntaxId %d\n",
                           lpAttrDef->szAttributeName,
                           lpAttrDef->dwSyntaxID));
#endif

    MapSyntaxIdtoADsSyntax(
            lpAttrDef->dwSyntaxID,
            szADsSyntax
            );

    hr = ADsAllocString(
                szADsSyntax,
                &pProperty->_bstrSyntax
                );
    BAIL_ON_FAILURE(hr);

    MapSyntaxIdtoNDSSyntax(
            lpAttrDef->dwSyntaxID,
            szNDSSyntax
            );

    hr = ADsAllocString(
                szNDSSyntax,
                &pProperty->_bstrOID
                );
    BAIL_ON_FAILURE(hr);

    pProperty->_lMaxRange = lpAttrDef->dwUpperLimit;
    pProperty->_lMinRange = lpAttrDef->dwLowerLimit;
    pProperty->_fMultiValued  = !(lpAttrDef->dwFlags & NDS_SINGLE_VALUED_ATTR);

    pProperty->Release();

    RRETURN(hr);

error:

    delete pProperty;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSProperty::CreateProperty(
    BSTR   bstrParent,
    BSTR   bstrName,
    HANDLE hTree,
    CCredentials& Credentials,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    DWORD dwStatus = 0;
    HRESULT hr = S_OK;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    DWORD dwNumberOfEntries = 0;
    DWORD dwInfoType = 0;
    HANDLE hOperationData = NULL;

    dwStatus = NwNdsCreateBuffer(
                    NDS_SCHEMA_READ_ATTR_DEF,
                    &hOperationData
                    );
    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsPutInBuffer(
                    bstrName,
                    0,
                    NULL,
                    0,
                    0,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsReadAttrDef(
                    hTree,
                    NDS_INFO_NAMES_DEFS,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsGetAttrDefListFromBuffer(
                    hOperationData,
                    &dwNumberOfEntries,
                    &dwInfoType,
                    (LPVOID *) &lpAttrDefs
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    if (!lpAttrDefs) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CNDSProperty::CreateProperty(
                bstrParent,
                bstrName,
                lpAttrDefs,
                Credentials,
                dwObjectState,
                riid,
                ppvObj
                );


error:
    if (hOperationData) {
        NwNdsFreeBuffer(hOperationData);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSProperty::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CNDSProperty::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSProperty::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSProperty::AllocatePropertyObject(
    CNDSProperty FAR * FAR * ppProperty
    )
{
    CNDSProperty FAR *pProperty = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CNDSProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADsProperty,
            (IADsProperty *) pProperty,
            DISPID_REGULAR
            );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSProperty::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }     
}

STDMETHODIMP
CNDSProperty::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSProperty::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSProperty::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSProperty::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


/* IADsProperty methods */

STDMETHODIMP
CNDSProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    if ( !pbstrSyntax )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    HRESULT hr;
    hr = ( ADsAllocString( _bstrSyntax, pbstrSyntax ));
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MaxRange( THIS_ long lMaxRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MinRange( THIS_ long lMinRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNDSProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
MapSyntaxIdtoADsSyntax(
    DWORD dwSyntaxId,
    LPWSTR pszADsSyntax
    )
{

    if (dwSyntaxId >= g_cNDSSyntaxMap) {
        wcscpy(pszADsSyntax, L"Out of Bounds");
    }else {
        wcscpy(pszADsSyntax, g_aNDSSyntaxMap[dwSyntaxId].bstrName);
    }
    RRETURN(S_OK);

}

HRESULT
MapSyntaxIdtoNDSSyntax(
    DWORD dwSyntaxId,
    LPWSTR pszNDSSyntax
    )
{

    if (dwSyntaxId > g_cNDSSyntaxMap) {
        wcscpy(pszNDSSyntax, L"Out of Bounds");
    }else {
        wcscpy(pszNDSSyntax, g_aNDSSyntaxMap[dwSyntaxId].bstrNDSName);
    }
    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cschobj.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cschema.cxx
//
//  Contents:  Microsoft ADs NDS Provider Schema Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSSchema

DEFINE_IDispatch_Implementation(CNDSSchema)
DEFINE_IADs_Implementation(CNDSSchema)


CNDSSchema::CNDSSchema()
{

    VariantInit(&_vFilter);

    _NDSTreeName = NULL;

    ENLIST_TRACKING(CNDSSchema);
}

HRESULT
CNDSSchema::CreateSchema(
    BSTR Parent,
    BSTR CommonName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSSchema FAR * pSchema = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSTreeName = NULL;

    hr = AllocateSchema(&pSchema, Credentials);
    BAIL_ON_FAILURE(hr);

    hr = pSchema->InitializeCoreObject(
                Parent,
                CommonName,
                SCHEMA_CLASS_NAME,
                L"",
                CLSID_NDSSchema,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                Parent,
                &pszNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pszNDSTreeName,  &pSchema->_NDSTreeName);
    BAIL_ON_FAILURE(hr);

    hr = pSchema->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);
    }

    RRETURN(hr);

error:

    if (pszNDSTreeName) {
        FreeADsStr(pszNDSTreeName);
    }

    delete pSchema;
    RRETURN_EXP_IF_ERR(hr);
}

CNDSSchema::~CNDSSchema( )
{
    VariantClear(&_vFilter);

    if (_NDSTreeName) {
        ADsFreeString(_NDSTreeName);
    }
    delete _pDispMgr;
}

STDMETHODIMP
CNDSSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSSchema::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CNDSSchema::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSSchema::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr;
    hr = ::RelativeGetObject(_ADsPath,
                             ClassName,
                             RelativeName,
                             _Credentials,
                             ppObject,
                             FALSE);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSSchema::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSSchemaEnum::Create(
                (CNDSSchemaEnum **)&penum,
                _NDSTreeName,
                _ADsPath,
                _Name,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSchema::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSSchema::AllocateSchema(
    CNDSSchema ** ppSchema,
    CCredentials& Credentials
    )
{
    CNDSSchema FAR * pSchema = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CNDSSchema();
    if (pSchema == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADsDomain *)pSchema,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pSchema,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pSchema->_Credentials = Credentials;
    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSSchema::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSSchema::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CNDSSchema::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSSchema::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CNDSProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSProvider

CNDSProvider::CNDSProvider()
{

}

HRESULT
CNDSProvider::Create(CNDSProvider FAR * FAR * ppProvider)
{
    CNDSProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CNDSProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN(hr);
}

CNDSProvider::~CNDSProvider( )
{
    ENLIST_TRACKING(CNDSProvider);
}

STDMETHODIMP
CNDSProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IParseDisplayName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CNDSProvider::ParseDisplayName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSProvider::ResolvePathName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    CCredentials Credentials;

    if (!pchEaten) {
        BAIL_IF_ERROR(hr = E_INVALIDARG);
    }

    *pchEaten = 0;
    hr = GetObject(
            szDisplayName,
            Credentials,
            (LPVOID *)&pUnknown
            );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NDS
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


#if DBG
DECLARE_INFOLEVEL(NDSMarshall);
DECLARE_DEBUG(NDSMarshall);
#define NDSMarshallDebugOut(x) NDSMarshallInlineDebugOut x
#endif







//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:   Adds a new empty property to the cache
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString = NULL;

    PPROPERTY pNewProperties = NULL;

    //
    // Allocate the string first
    //
    tempString = AllocADsStr(szPropertyName);

    if (!tempString)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);


    //
    //  extend the property cache by adding a new property entry
    //

    pNewProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!pNewProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _pProperties = pNewProperties;

    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);


    //
    // Since the memory has already been allocated in tempString
    // just set the value/pointer now.
    //
    pNewProperty->szPropertyName = tempString;

    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

    RRETURN(hr);

error:

    if (tempString)
       FreeADsStr(tempString);

    RRETURN_EXP_IF_ERR(hr);
}





//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNDSOBJECT pNdsObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PNDSOBJECT pNdsTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (!fExplicit) {
        if ((PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_MODIFIED) ||
            (PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_CLEARED))    {

            hr = S_OK;
            goto error;
        }
    }


    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        NdsTypeFreeNdsObjects(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NDSOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NdsTypeCopyConstruct(
            pNdsObject,
            dwNumValues,
            &pNdsTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

    PROPERTY_FLAGS(pThisProperty)  = CACHE_PROPERTY_INITIALIZED;

error:

    RRETURN_EXP_IF_ERR(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    if (hr == E_ADS_PROPERTY_NOT_FOUND) {

        //
        // Now call the GetInfo function
        //

        hr = _pCoreADsObject->GetInfo(
                    FALSE
                    );
        BAIL_ON_FAILURE(hr);

        hr = findproperty(
                    szPropertyName,
                    &dwIndex
                    );

    }
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
putproperty(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNDSOBJECT pNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PNDSOBJECT pNdsTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        NdsTypeFreeNdsObjects(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NDSOBJECT(pThisProperty) = NULL;
    }


    switch (dwFlags) {

    case CACHE_PROPERTY_MODIFIED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

        hr = NdsTypeCopyConstruct(
                pNdsObject,
                dwNumValues,
                &pNdsTempObject
                );
        BAIL_ON_FAILURE(hr);

        PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_MODIFIED;
        break;

    case CACHE_PROPERTY_CLEARED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = 0;

        PROPERTY_NDSOBJECT(pThisProperty) = NULL;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_CLEARED;

        break;


    case CACHE_PROPERTY_APPENDED:

       PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

       PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

       hr = NdsTypeCopyConstruct(
               pNdsObject,
               dwNumValues,
               &pNdsTempObject
               );
       BAIL_ON_FAILURE(hr);

       PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

       PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_APPENDED;
       break;


    case CACHE_PROPERTY_DELETED:

       PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

       PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

       hr = NdsTypeCopyConstruct(
               pNdsObject,
               dwNumValues,
               &pNdsTempObject
               );
       BAIL_ON_FAILURE(hr);

       PROPERTY_NDSOBJECT(pThisProperty) = pNdsTempObject;

       PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_DELETED;
       break;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
CPropertyCache():
        _dwMaxProperties(0),
        _dwCurrentIndex(0),
        _pProperties(NULL),
        _cb(0),
        _pCoreADsObject(NULL)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

       if (pThisProperty->szPropertyName){
        FreeADsStr(pThisProperty->szPropertyName);
        pThisProperty->szPropertyName = NULL;
          }

            if (PROPERTY_NDSOBJECT(pThisProperty)) {

                NdsTypeFreeNdsObjects(
                        PROPERTY_NDSOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NDSOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{

    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PNDSOBJECT pNdsObject = NULL;

    hr = UnMarshallNDSToNDSSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pNdsObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);




error:

    if (pNdsObject) {
        NdsTypeFreeNdsObjects(
                pNdsObject,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CPropertyCache::
NDSUnMarshallProperties(
    HANDLE hOperationData,
    BOOL fExplicit
    )

{
    DWORD dwNumberOfEntries = 0L;
    LPNDS_ATTR_INFO lpEntries = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwStatus = 0L;

    //
    // Compute the number of attributes in the
    // read buffer.
    //

    dwStatus = NwNdsGetAttrListFromBuffer(
                    hOperationData,
                    &dwNumberOfEntries,
                    &lpEntries
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    for (i = 0; i < dwNumberOfEntries; i++) {

        //
        // unmarshall this property into the
        // property cache
        //

        hr = unmarshallproperty(
                    lpEntries[i].szAttributeName,
                    lpEntries[i].lpValue,
                    lpEntries[i].dwNumberOfValues,
                    lpEntries[i].dwSyntaxId,
                    fExplicit
                    );

        CONTINUE_ON_FAILURE(hr);

    }

error:

    RRETURN_EXP_IF_ERR(hr);

}




HRESULT
CPropertyCache::
marshallproperty(
    HANDLE hOperationData,
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    LPBYTE lpValues,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;


    switch (dwFlags) {

    case CACHE_PROPERTY_MODIFIED:
        dwStatus = NwNdsPutInBuffer(
                       szPropertyName,
                        dwSyntaxId,
                        NULL,
                        0,
                        NDS_ATTR_CLEAR,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

        dwStatus = NwNdsPutInBuffer(
                        szPropertyName,
                        dwSyntaxId,
                        lpValues,
                        dwNumValues,
                        NDS_ATTR_ADD,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;

    case CACHE_PROPERTY_CLEARED:

        dwStatus = NwNdsPutInBuffer(
                       szPropertyName,
                        dwSyntaxId,
                        NULL,
                        0,
                        NDS_ATTR_CLEAR,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;


    case CACHE_PROPERTY_APPENDED:
        dwStatus = NwNdsPutInBuffer(
                        szPropertyName,
                        dwSyntaxId,
                        lpValues,
                        dwNumValues,
                        NDS_ATTR_ADD_VALUE,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;


    case CACHE_PROPERTY_DELETED:
        dwStatus = NwNdsPutInBuffer(
                        szPropertyName,
                        dwSyntaxId,
                        lpValues,
                        dwNumValues,
                        NDS_ATTR_REMOVE_VALUE,
                        hOperationData
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;


    default:
        break;


    }


#if DBG

    NDSMarshallDebugOut((
                DEB_TRACE,
                "dwSyntaxId: %ld \n", dwSyntaxId
                ));
#endif


error:

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CPropertyCache::
NDSMarshallProperties(
    HANDLE hOperationData
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    BYTE lpBuffer[2048];

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == 0) {

            continue;
        }


        hr = MarshallNDSSynIdToNDS(
                PROPERTY_SYNTAX(pThisProperty),
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                lpBuffer
                );
        CONTINUE_ON_FAILURE(hr);


        hr = marshallproperty(
                hOperationData,
                PROPERTY_NAME(pThisProperty),
                PROPERTY_FLAGS(pThisProperty),
                lpBuffer,
                PROPERTY_NUMVALUES(pThisProperty),
                PROPERTY_SYNTAX(pThisProperty)
                );
        CONTINUE_ON_FAILURE(hr);

        if (PROPERTY_NDSOBJECT(pThisProperty)) {
            FreeMarshallMemory(
                    PROPERTY_SYNTAX(pThisProperty),
                    PROPERTY_NUMVALUES(pThisProperty),
                    lpBuffer
                    );

            NdsTypeFreeNdsObjects(
                    PROPERTY_NDSOBJECT(pThisProperty),
                    PROPERTY_NUMVALUES(pThisProperty)
                    );
            PROPERTY_NDSOBJECT(pThisProperty) = NULL;
        }

        wcscpy(pThisProperty->szPropertyName, TEXT(""));
        PROPERTY_SYNTAX(pThisProperty) = 0;
        PROPERTY_NUMVALUES(pThisProperty) = 0;
        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_INITIALIZED;

    }

    RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        //hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

       if (pThisProperty->szPropertyName) {
          FreeADsStr(pThisProperty->szPropertyName);
          pThisProperty->szPropertyName = NULL;
       }

            if (PROPERTY_NDSOBJECT(pThisProperty)) {

                NdsTypeFreeNdsObjects(
                        PROPERTY_NDSOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NDSOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
    _dwCurrentIndex = 0;
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pThisProperty = NULL;

    if (!_pProperties) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }


    if (((LONG)dwIndex < 0) || dwIndex > (_dwMaxProperties - 1) )
       RRETURN_EXP_IF_ERR(E_FAIL);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NDSOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NdsTypeCopyConstruct(
                PROPERTY_NDSOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNdsObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNdsObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        //hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}

BOOL
CPropertyCache::
index_valid(
   )
{
    //
    // NOTE: - _dwCurrentIndex is of type DWORD which is unsigned long.
    //       - _dwMaxProperties -1 is also of type unsigned long (so
    //         if _dwMaxProperites = 0, _dwMaxproperties -1 = 0xffffff)
    //       - comparision checking must taken the above into account
    //         for proper checking
    //

   if ( (_dwMaxProperties==0) || (_dwCurrentIndex >_dwMaxProperties-1) )
      return(FALSE);
   else
      return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
    //
    // NOTE: - _dwIndex is of type DWORD which is unsigned long.
    //       - _dwMaxProperties -1 is also of type unsigned long (so
    //         if _dwMaxProperites = 0, _dwMaxproperties -1 = 0xffffff)
    //       - comparision checking must taken the above into account
    //         for proper checking
    //

   if ( (_dwMaxProperties==0) || (dwIndex >_dwMaxProperties-1) )
      return(FALSE);
   else
      return(TRUE);

}

void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}



HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // - allow current index to go from within range to out of range by 1
    // - by 1 since initial state is out of range by 1
    //

    if ( newIndex > _dwMaxProperties )
        RRETURN_EXP_IF_ERR(E_FAIL);

    _dwCurrentIndex = newIndex;
    RRETURN(S_OK);
}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}


DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid())
        return(NULL);

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}


LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}



HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_NDSOBJECT(pThisProperty)) {
          NdsTypeFreeNdsObjects(
                  PROPERTY_NDSOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_NDSOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      //
      // Reset the current index just in case
      //
      _dwCurrentIndex = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_NDSOBJECT(pThisProperty)) {
       NdsTypeFreeNdsObjects(
               PROPERTY_NDSOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_NDSOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
   //
   // Reset the current index if necesary so we do not skip a property.
   //
   if (_dwCurrentIndex > dwIndex) {
       _dwCurrentIndex--;
   }
error:

   RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\csedcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 NDS Security Class Factory Code
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CNDSAclCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CNDSAclCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CNDSAcl::CreateSecurityDescriptor(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\csynobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  NDS
//
//
//  History:   01-09-96     yihsins    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

/******************************************************************/
/*  Class CNDSSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CNDSSyntax)
DEFINE_IADs_Implementation(CNDSSyntax)

CNDSSyntax::CNDSSyntax()
{
    ENLIST_TRACKING(CNDSSyntax);
}

CNDSSyntax::~CNDSSyntax()
{
    delete _pDispMgr;
}

HRESULT
CNDSSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_NDSSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) 
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSSyntax::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }    
}
/* IADs methods */

STDMETHODIMP
CNDSSyntax::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSSyntax::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::Put(THIS_ BSTR bstrName, VARIANT vProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CNDSSyntax::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)
{
     RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSSyntax::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSSyntax::AllocateSyntaxObject(CNDSSyntax FAR * FAR * ppSyntax)
{
    CNDSSyntax FAR *pSyntax = NULL;
    CDispatchMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CNDSSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CNDSSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CNDSSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( (bstrList != NULL) && (*bstrList != 0) )
    {
        long i = 0;
        long nCount = 1;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\csed.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  CAcl.cxx
//
//  Contents:  SecurityDescriptor object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

//  Class CAcl

DEFINE_IDispatch_Implementation(CAcl)

CAcl::CAcl():
        _pDispMgr(NULL),
        _lpProtectedAttrName(NULL),
        _lpSubjectName(NULL),
        _dwPrivileges(0)
{
    ENLIST_TRACKING(CAcl);
}


HRESULT
CAcl::CreateSecurityDescriptor(
    REFIID riid,
    void **ppvObj
    )
{
    CAcl FAR * pSecurityDescriptor = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSecurityDescriptorObject(&pSecurityDescriptor);
    BAIL_ON_FAILURE(hr);

    hr = pSecurityDescriptor->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSecurityDescriptor->Release();

    RRETURN(hr);

error:
    delete pSecurityDescriptor;

    RRETURN_EXP_IF_ERR(hr);

}


CAcl::~CAcl( )
{
    delete _pDispMgr;

    if (_lpProtectedAttrName)
        FreeADsMem(_lpProtectedAttrName);

    if (_lpSubjectName)
        FreeADsMem(_lpSubjectName);
}

STDMETHODIMP
CAcl::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAcl))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsAcl FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CAcl::AllocateSecurityDescriptorObject(
    CAcl ** ppSecurityDescriptor
    )
{
    CAcl FAR * pSecurityDescriptor = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSecurityDescriptor = new CAcl();
    if (pSecurityDescriptor == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);
    /*
    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBIDOle,
                IID_IADsAcl,
                (IADsAcl *)pSecurityDescriptor,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);
    */
    pSecurityDescriptor->_pDispMgr = pDispMgr;
    *ppSecurityDescriptor = pSecurityDescriptor;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

/* ISupportErrorInfo method */
STDMETHODIMP
CAcl::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsAcl)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

// new stuff!

STDMETHODIMP
CAcl::get_Privileges(THIS_ long FAR * retval)
{

    *retval = _dwPrivileges;
    RRETURN(S_OK);
}

STDMETHODIMP
CAcl::put_Privileges(THIS_ long lnPrivileges)
{

    _dwPrivileges = lnPrivileges;
    RRETURN(S_OK);
}


STDMETHODIMP
CAcl::get_SubjectName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpSubjectName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAcl::put_SubjectName(THIS_ BSTR bstrSubjectName)
{

    if (!bstrSubjectName) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    if (_lpSubjectName) {
        FreeADsStr(_lpSubjectName);
    }
    _lpSubjectName = NULL;

    _lpSubjectName= AllocADsStr(bstrSubjectName);

    if (!_lpSubjectName) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CAcl::get_ProtectedAttrName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpProtectedAttrName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAcl::put_ProtectedAttrName(THIS_ BSTR bstrProtectedAttrName)
{

    if (!bstrProtectedAttrName) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    if (_lpProtectedAttrName) {
        FreeADsStr(_lpProtectedAttrName);
    }
    _lpProtectedAttrName = NULL;

    _lpProtectedAttrName= AllocADsStr(bstrProtectedAttrName);

    if (!_lpProtectedAttrName) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CAcl::CopyAcl(THIS_ IDispatch FAR * FAR * ppAcl)
{

    HRESULT hr = S_OK;
    IADsAcl * pSecDes = NULL;

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(_dwPrivileges);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(_lpSubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(_lpProtectedAttrName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, 
                                 (void**)ppAcl);
    BAIL_ON_FAILURE(hr);

error:

    if (pSecDes) {
        pSecDes->Release();
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser

STDMETHODIMP CNDSUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, BadLoginAddress);
}

STDMETHODIMP CNDSUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, BadLoginCount);
}

STDMETHODIMP CNDSUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogin);
}

STDMETHODIMP CNDSUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogoff);
}

STDMETHODIMP CNDSUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastFailedLogin);
}

STDMETHODIMP CNDSUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordLastChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser


STDMETHODIMP CNDSUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CNDSUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CNDSUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);

}

STDMETHODIMP CNDSUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}


STDMETHODIMP CNDSUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Languages);

}

STDMETHODIMP CNDSUser::put_Languages(THIS_ VARIANT vLanguages)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Languages);
}

STDMETHODIMP CNDSUser::get_Profile(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Profile);

}

STDMETHODIMP CNDSUser::put_Profile(THIS_ BSTR bstrProfile)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CNDSUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LoginScript);

}

STDMETHODIMP CNDSUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cuser.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

struct _propmap
{
    LPTSTR pszADsProp;
    LPTSTR pszNDSProp;
} aUserPropMapping[] =
{
  //{ TEXT("BadLoginCount"), TEXT("badPwdCount") },
  { TEXT("LastLogin"), TEXT("Last Login Time") },
  //{ TEXT("LastLogoff"), TEXT("lastLogoff") },
  //{ TEXT("LastFailedLogin"), TEXT("badPasswordTime") },
  //{ TEXT("PasswordLastChanged"), TEXT("pwdLastSet") },
  { TEXT("Description"), TEXT("Description") },
  //{ TEXT("Division"), TEXT("division") },
  //{ TEXT("Department"), TEXT("department") },
  //{ TEXT("EmployeeID"), TEXT("employeeID") },
  { TEXT("FullName"), TEXT("Full Name") },
  { TEXT("FirstName"), TEXT("Given Name") },
  { TEXT("LastName"), TEXT("Surname") },
  //{ TEXT("OtherName"), TEXT("middleName") },
  //{ TEXT("NamePrefix"), TEXT("personalTitle") },
  { TEXT("NameSuffix"), TEXT("Generational Qualifier") },
  { TEXT("Title"), TEXT("Title") },
  //{ TEXT("Manager"), TEXT("manager") },
  { TEXT("TelephoneNumber"), TEXT("Telephone Number") },
  //{ TEXT("TelephoneHome"), TEXT("homePhone") },
  //{ TEXT("TelephoneMobile"), TEXT("mobile") },
  //{ TEXT("TelephonePager"), TEXT("pager") },
  { TEXT("FaxNumber"), TEXT("Facsimile Telephone Number") },
  { TEXT("OfficeLocations"), TEXT("Physical Delivery Office Name") },
  { TEXT("PostalAddresses"), TEXT("Postal Address") },
  { TEXT("PostalCodes"), TEXT("Postal Code") },
  { TEXT("SeeAlso"), TEXT("See Also") },
  //{ TEXT("AccountExpirationDate"), TEXT("accountExpires") },
  { TEXT("LoginHours"), TEXT("Login Allowed Time Map") },
  //{ TEXT("LoginWorkstations"), TEXT("logonWorkstation") },
  //{ TEXT("MaxStorage"), TEXT("maxStorage") },
  { TEXT("PasswordExpirationDate"), TEXT("Password Expiration Time") },
  { TEXT("PasswordMinimumLength"), TEXT("Password Minimum Length") },
  { TEXT("RequireUniquePassword"), TEXT("Password Unique Required") },
  { TEXT("EmailAddress"), TEXT("Email Address") },
  { TEXT("HomeDirectory"), TEXT("Home Directory") },
  { TEXT("Languages"), TEXT("Language") },
  { TEXT("Profile"), TEXT("Profile") },
  { TEXT("PasswordRequired"), TEXT("Password Required") },
  { TEXT("AccountDisabled"), TEXT("Login Disabled") },
  { TEXT("GraceLoginsAllowed"), TEXT("Login Grace Limit") },
  { TEXT("GraceLoginsRemaining"), TEXT("Login Grace Remaining") },
  { TEXT("LoginScript"), TEXT("Login Script") }
  //{ TEXT("HomePage"), TEXT("url") }
};

DWORD dwNumUserPropMapping = sizeof(aUserPropMapping)/sizeof(_propmap);


//  Class CNDSUser

DEFINE_IDispatch_Implementation(CNDSUser)
DEFINE_CONTAINED_IADs_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectoryObject_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectorySearch_Implementation(CNDSUser)
DEFINE_CONTAINED_IDirectorySchemaMgmt_Implementation(CNDSUser)
DEFINE_CONTAINED_IADsPropertyList_Implementation(CNDSUser)
DEFINE_CONTAINED_IADsPutGet_Implementation(CNDSUser,aUserPropMapping)

CNDSUser::CNDSUser():
        _pADs(NULL),
        _pDSObject(NULL),
        _pDSSearch(NULL),
        _pDSSchemaMgmt(NULL),
        _pDispMgr(NULL),
        _pADsPropList(NULL)
{
    ENLIST_TRACKING(CNDSUser);
}

HRESULT
CNDSUser::CreateUser(
    IADs *pADs,
    CCredentials& Credentials,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSUser FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserObject(pADs, Credentials, &pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();

    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSUser::~CNDSUser( )
{

    if (_pADs) {
        _pADs->Release();
    }

    if (_pDSObject) {
        _pDSObject->Release();
    }
    if (_pDSSearch) {
        _pDSSearch->Release();
    }
    if (_pADsPropList) {
        _pADsPropList->Release();
    }
    if (_pDSSchemaMgmt) {
        _pDSSchemaMgmt->Release();
    }

    delete _pDispMgr;
}


STDMETHODIMP
CNDSUser::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUser))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectoryObject))
    {
        *ppv = (IDirectoryObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySearch))
    {
        *ppv = (IDirectorySearch FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDirectorySchemaMgmt))
    {
        *ppv = (IDirectorySchemaMgmt FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSUser::AllocateUserObject(
    IADs * pADs,
    CCredentials& Credentials,
    CNDSUser ** ppUser
    )
{
    CNDSUser FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;
    IDirectoryObject * pDSObject = NULL;
    IDirectorySearch * pDSSearch = NULL;
    IDirectorySchemaMgmt * pDSSchemaMgmt = NULL;
    IADsPropertyList * pADsPropList = NULL;

    pUser = new CNDSUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsUser,
                (IADsUser *)pUser,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pUser,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = pADs->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)&pDSObject
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSObject = pDSObject;


    hr = pADs->QueryInterface(
                    IID_IADsPropertyList,
                    (void **)&pADsPropList
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pADsPropList = pADsPropList;


    hr = pADs->QueryInterface(
                    IID_IDirectorySearch,
                    (void **)&pDSSearch
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSSearch = pDSSearch;

    hr = pADs->QueryInterface(
                    IID_IDirectorySchemaMgmt,
                    (void **)&pDSSchemaMgmt
                    );
    BAIL_ON_FAILURE(hr);
    pUser->_pDSSchemaMgmt = pDSSchemaMgmt;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pUser->_pADs  = pADs;
    pADs->AddRef();


    pUser->_Credentials = Credentials;
    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pUser;

    *ppUser = NULL;

    RRETURN(hr);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSUser::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsUser) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FaxNumber, BSTR, 7)                 NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(Initials, BSTR, 10)                 NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(NickName, BSTR, 13)                 NI
//      PROPERTY_RW(OfficeLocations, BSTR, 14)          NI
//      PROPERTY_RW(Picture, VARIANT, 15)               NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


STDMETHODIMP
CNDSUser::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CNDSUser::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CNDSUser::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CNDSUser::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CNDSUser::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CNDSUser::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CNDSUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CNDSUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}


STDMETHODIMP
CNDSUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CNDSUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CNDSUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNDSUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNDSUser::get_LastName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CNDSUser::put_LastName(THIS_ BSTR bstrLastName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CNDSUser::get_Manager(THIS_ BSTR FAR* retval)
{
     GET_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CNDSUser::put_Manager(THIS_ BSTR bstrManager)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CNDSUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CNDSUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocation)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CNDSUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, PictureIcon);
}

STDMETHODIMP
CNDSUser::put_Picture(THIS_ VARIANT vPictureIcon)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, PictureIcon);
}

STDMETHODIMP
CNDSUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CNDSUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CNDSUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CNDSUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CNDSUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CNDSUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CNDSUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CNDSUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CNDSUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CNDSUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CNDSUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CNDSUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CNDSUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CNDSUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CNDSUser::get_Title(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CNDSUser::put_Title(THIS_ BSTR bstrTitle)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Title);
}


STDMETHODIMP CNDSUser::Groups(THIS_ IADsMembers FAR*  FAR * ppGroups)
{
    VARIANT varProp;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    VariantInit(&varProp);

    hr = _pADs->GetEx(L"Group Membership", &varProp);
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        SAFEARRAY *aList = NULL;

        VariantInit(&varProp);
    
        SAFEARRAYBOUND aBound;
    
        aBound.lLbound = 0;
        aBound.cElements = 0;
    
        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    
        if ( aList == NULL ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        V_VT(&varProp) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(&varProp) = aList;
    }
    else {
        BAIL_ON_FAILURE(hr);
    }

    hr = _pADs->get_ADsPath(&bstrADsPath);

    hr = CNDSUserCollection::CreateUserCollection(
                    bstrADsPath,
                    varProp,
                    IID_IADsMembers,
                    (void **)ppGroups
                    );

    BAIL_ON_FAILURE(hr);

error:

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    VariantClear(&varProp);

    RRETURN_EXP_IF_ERR(hr);
}
STDMETHODIMP CNDSUser::get_HomePage(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::put_NameSuffix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNDSUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNDSUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              I
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           I
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              I
//        PROPERTY_RW(IsAdmin, boolean, 8)                      I
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   I
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           I
//        PROPERTY_RW(MaxLogins, long, 11)                      I
//        PROPERTY_RW(MaxStorage, long, 12)                     I
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         I
//        PROPERTY_RW(PasswordRequired, boolean, 14)            I
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        I
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


//  Class CNDSUser

STDMETHODIMP
CNDSUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}

STDMETHODIMP
CNDSUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, AccountDisabled);
}


STDMETHODIMP
CNDSUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNDSUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CNDSUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}


STDMETHODIMP
CNDSUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CNDSUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNDSUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CNDSUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{
    HRESULT hr;
    hr = get_VARIANT_BOOL_Property(
                            (IADs *)this,
                            TEXT("Locked By Intruder"),
                            retval
                            );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
    HRESULT hr;
    hr = put_VARIANT_BOOL_Property(
                            (IADs *)this, 
                            TEXT("Locked By Intruder"),
                            fIsAccountLocked
                            ); 
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{ 
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CNDSUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{ 
    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CNDSUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}


STDMETHODIMP
CNDSUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CNDSUser::get_MaxLogins(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNDSUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxLogins);
}

STDMETHODIMP
CNDSUser::get_MaxStorage(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}


STDMETHODIMP
CNDSUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}

STDMETHODIMP
CNDSUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNDSUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CNDSUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNDSUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, PasswordRequired);
}

STDMETHODIMP
CNDSUser::get_PasswordMinimumLength(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNDSUser::put_PasswordMinimumLength(THIS_ LONG lPasswordMinimumLength)
{
    PUT_PROPERTY_LONG((IADsUser *)this, PasswordMinimumLength);
}

STDMETHODIMP
CNDSUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNDSUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CNDSUser::ChangePassword(
    THIS_ BSTR bstrOldPassword,
    BSTR bstrNewPassword
    )
{
    HANDLE hObject = NULL;
    LPWSTR pszNDSPathName = NULL;
    DWORD dwStatus;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;

    hr = _pADs->get_ADsPath(
                    &bstrADsPath
                    );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsChangeUserPassword(
                    hObject,
                    bstrOldPassword,
                    bstrNewPassword
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
error:

    if (hObject) {
        dwStatus = NwNdsCloseObject(hObject);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPathName) {
        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
NWApiSetUserPassword(
    NWCONN_HANDLE hConn,
    DWORD dwUserObjID,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    );

HRESULT
BuildUserNameFromADsPath(
   LPWSTR pszADsPath,
   LPWSTR szUserName
   );


#define NW_MAX_PASSWORD_LEN 256


STDMETHODIMP
CNDSUser::SetPassword(THIS_ BSTR NewPassword)
{
    HANDLE hObject = NULL;
    LPWSTR pszNDSPathName = NULL;
    DWORD dwStatus;
    HRESULT hr = S_OK;
    BSTR bstrADsPath = NULL;
    WCHAR szUserName[NDS_MAX_NAME_CHARS+1];
    WCHAR szPasswordCopy[NW_MAX_PASSWORD_LEN + 1];
    DWORD dwObjID;
    NWCONN_HANDLE hConn = NULL;

    wcscpy(szPasswordCopy, NewPassword);
    hr = ChangePassword(L"", szPasswordCopy);

    if (!FAILED(hr))  {

        return hr;
    }

    hr = _pADs->get_ADsPath(
                    &bstrADsPath
                    );
    BAIL_ON_FAILURE(hr);


    hr = BuildNDSPathFromADsPath(
                bstrADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildUserNameFromADsPath(
             bstrADsPath,
             szUserName
             );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


    dwObjID = NwNdsGetObjectId(hObject);
    hConn = NwNdsObjectHandleToConnHandle(hObject);

    if (hConn == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = NWApiSetUserPassword(
             hConn,
             dwObjID,
             szUserName,
             szPasswordCopy
             );

    NwNdsConnHandleFree(hConn);


error:

    if (hObject) {
        dwStatus = NwNdsCloseObject(hObject);
    }

    if (bstrADsPath) {
        ADsFreeString(bstrADsPath);
    }

    if (pszNDSPathName) {
        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}




HRESULT
NWApiSetUserPassword(
    NWCONN_HANDLE hConn,
    DWORD dwUserObjID,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    )
{
    CHAR           szOemUserName[NDS_MAX_NAME_CHARS + 1];
    CHAR           szOemPassword[NW_MAX_PASSWORD_LEN + 1];
    CHAR           Buffer[128];
    DWORD          rc, err = 0;
    HRESULT        hr = S_OK;
    NTSTATUS       NtStatus;
    UCHAR          ChallengeKey[8];
    UCHAR          ucMoreFlag;
    UCHAR          ucPropFlag;

    if ( !pszUserName ||
         !pszPassword ) {

        hr = E_INVALIDARG ;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Convert UNICODE into OEM representation required by NW APIs.
    //

    rc = WideCharToMultiByte(
             CP_OEMCP,
             0,
             pszUserName,
             -1,
             szOemUserName,
             sizeof(szOemUserName),
             NULL,
             NULL) ;

    if (rc == 0) {

        err = GetLastError() ;
        hr = HRESULT_FROM_WIN32(err);
        BAIL_ON_FAILURE(hr);

    }

    _wcsupr(pszPassword) ;
    rc = WideCharToMultiByte(
             CP_OEMCP,
             0,
             pszPassword,
             -1,
             szOemPassword,
             sizeof(szOemPassword),
             NULL,
             NULL) ;

    if (rc == 0) {

        err = GetLastError() ;
        hr = HRESULT_FROM_WIN32(err);
        BAIL_ON_FAILURE(hr);

    }


    //
    // Get challenge key.
    //

    NtStatus = NWPGetChallengeKey(
                  hConn,
                  ChallengeKey
                  );

    if (!NT_SUCCESS(NtStatus)) {

        err = ERROR_UNEXP_NET_ERR ;
    }


    if (!err) {

        //
        // The old password and object ID make up the 17-byte Vold. This is used
        // later to form the 17-byte Vc for changing password on the server.
        //

        UCHAR ValidationKey[8];
        UCHAR NewKeyedPassword[17];

        EncryptChangePassword(
            (PUCHAR) "",
            (PUCHAR) szOemPassword,
            dwUserObjID,
            ChallengeKey,
            ValidationKey,
            NewKeyedPassword
            );

        NtStatus =  NWPChangeObjectPasswordEncrypted(
                      hConn,
                      szOemUserName,
                      OT_USER,
                      ValidationKey,
                      NewKeyedPassword
                      );

        if (!NT_SUCCESS(NtStatus)) {

            err = ERROR_NOT_SUPPORTED;
        }

    }

    //
    // Return.
    //

    hr = HRESULT_FROM_WIN32(err);


error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Function:  Extract user name from ADs path
//
//  Synopsis:   This call attempts to extract a username from a NDS style
//              ADs path. The last component is assumed to be the username.
//
//  Arguments:  [LPTSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
BuildUserNameFromADsPath(
   LPWSTR pszADsPath,
   LPWSTR szUserName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;

    LPWSTR pszSrcComp = NULL;
    LPWSTR pszSrcValue = NULL;

    DWORD dwNumComponents = 0;

    HRESULT hr = S_OK;

    CLexer Lexer(pszADsPath);

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents ;

    if (dwNumComponents) {

        //
        // take the last value
        //
        pszSrcComp = pObjectInfo->ComponentArray[dwNumComponents-1].szComponent;
        pszSrcValue = pObjectInfo->ComponentArray[dwNumComponents-1].szValue;

        if (pszSrcComp && pszSrcValue) {

            //
            // You have a CN = "MyUserName"
            // Then copy the szValue as your UserName
            //

            wcscpy(szUserName, pszSrcValue);

        }
        else if (pszSrcComp) {

            //
            // Simply MyUserName. For example: path
            // is "NDS://marsdev/mars/dev/MyUserName)"
            //

            wcscpy(szUserName, pszSrcComp);

        }
    }


error:

    //
    // Clean up the parser object
    //

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ctree.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomain.cxx
//
//  Contents:  Microsoft ADs NDS Provider Tree Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

//  Class CNDSTree

DEFINE_IDispatch_Implementation(CNDSTree)
DEFINE_IADs_Implementation(CNDSTree)


CNDSTree::CNDSTree():
                _pPropertyCache(NULL)
{

    VariantInit(&_vFilter);

    ENLIST_TRACKING(CNDSTree);
}

HRESULT
CNDSTree::CreateTreeObject(
    BSTR bstrADsPath,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    WCHAR szADsParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];

    memset(szADsParent, 0, sizeof(szADsParent));
    memset(szCommonName, 0, sizeof(szCommonName));

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                szADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CNDSTree::CreateTreeObject(
                 szADsParent,
                 szCommonName,
                 L"user",
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSTree::CreateTreeObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSTree FAR * pTree = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTree(Credentials, &pTree);
    BAIL_ON_FAILURE(hr);

    hr = pTree->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_NDSTree,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pTree->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTree->Release();

    RRETURN(hr);

error:

    delete pTree;
    RRETURN_EXP_IF_ERR(hr);
}

CNDSTree::~CNDSTree( )
{
    VariantClear(&_vFilter);

    delete _pDispMgr;

    delete _pPropertyCache;
}

STDMETHODIMP
CNDSTree::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CNDSTree::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CNDSTree::SetInfo()
{
    DWORD dwStatus = 0L;
    WCHAR szNDSPathName[MAX_PATH];
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = NDSCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = NDSSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CNDSTree::NDSSetObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszNDSPathName = NULL;
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;


    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_MODIFY,
                        &hOperationData
                        );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = _pPropertyCache->NDSMarshallProperties(
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsModifyObject(
                    hObject,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }

    if (pszNDSPathName) {

        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSTree::NDSCreateObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszNDSParentName = NULL;
    HANDLE hOperationData = NULL;
    HANDLE hObject = NULL;
    HRESULT hr = S_OK;


    hr = BuildNDSPathFromADsPath(
                _Parent,
                &pszNDSParentName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSParentName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsCreateBuffer(
                        NDS_OBJECT_ADD,
                        &hOperationData
                        );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSMarshallProperties(
                            hOperationData
                            );
    BAIL_ON_FAILURE(hr);

    dwStatus = NwNdsAddObject(
                    hObject,
                    _Name,
                    hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }


    if (pszNDSParentName) {

        FreeADsStr(pszNDSParentName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSTree::GetInfo()
{
    RRETURN(GetInfo(TRUE));
}

HRESULT
CNDSTree::GetInfo(
    BOOL fExplicit
    )
{
    DWORD dwStatus = 0L;
    HANDLE hObject = NULL;
    HANDLE hOperationData = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszNDSPathName = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hOperationData = NULL;

    dwStatus = NwNdsReadObject(
                    hObject,
                    NDS_INFO_ATTR_NAMES_VALUES,
                    &hOperationData
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    hr = _pPropertyCache->NDSUnMarshallProperties(
                            hOperationData,
                            fExplicit
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (hOperationData) {

        dwStatus = NwNdsFreeBuffer(hOperationData);
    }

    if (hObject) {

        dwStatus = NwNdsCloseObject(hObject);
    }


    if (pszNDSPathName) {

        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CNDSTree::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CNDSTree::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                FALSE
                );

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CNDSTree::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSTreeEnum::Create(
                (CNDSTreeEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSTree::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs * pADs  = NULL;
    VARIANT var;
    WCHAR szNDSTreeName[MAX_PATH];
    DWORD dwSyntaxId = 0;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //


    hr = CNDSGenObject::CreateGenericObject(
                    _ADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IDispatch,
                    (void **)ppObject
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    LPWSTR pszNDSPathName = NULL;
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    HANDLE hParentObject = NULL;

    hr = BuildNDSPathFromADsPath(
                _ADsPath,
                &pszNDSPathName
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = ADsNwNdsOpenObject(
                    pszNDSPathName,
                    _Credentials,
                    &hParentObject,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

    dwStatus = NwNdsRemoveObject(
                    hParentObject,
                    bstrRelativeName
                    );

    CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);


error:
    if (hParentObject) {
        NwNdsCloseObject(
                hParentObject
                );
    }

    if (pszNDSPathName) {
        FreeADsStr(pszNDSPathName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSTree::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CNDSTree::AllocateTree(
    CCredentials& Credentials,
    CNDSTree ** ppTree
    )
{
    CNDSTree FAR * pTree = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pTree = new CNDSTree();
    if (pTree == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pTree,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pTree,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pTree,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);



    pTree->_Credentials = Credentials;
    pTree->_pPropertyCache = pPropertyCache;
    pTree->_pDispMgr = pDispMgr;
    *ppTree = pTree;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CNDSTree::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                FALSE
                );

    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSTree::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNDSOBJECT pNdsSrcObjects = NULL;

    //
    // retrieve data object from cache; if one exists
    //

    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNdsSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nds objects to variants
    //

    hr = NdsTypeToVarTypeCopyConstruct(
                pNdsSrcObjects,
                dwNumValues,
                pvProp,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNdsSrcObjects) {

        NdsTypeFreeNdsObjects(
            pNdsSrcObjects,
            dwNumValues
            );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CNDSTree::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSTree::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    WCHAR szNDSTreeName[MAX_PATH];

    //
    // Issue: How do we handle multi-valued support
    //
    DWORD dwNumValues = 1;

    //
    // Get the TreeName for this object
    //

    hr = BuildNDSTreeNameFromADsPath(
                _ADsPath,
                szNDSTreeName
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if this is a legal property for this object,
    //

    hr = ValidatePropertyinCache(
                szNDSTreeName,
                _ADsClass,
                bstrName,
                _Credentials,
                &dwSyntaxId
                );
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNdsTypeCopyConstruct(
                    dwSyntaxId,
                    &vProp,
                    &dwNumValues,
                    &pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId,
                    dwNumValues,
                    pNdsDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cUser.cxx
//
//  Contents:  User object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "nds.hxx"

//  Class CNDSUserCollection

DEFINE_IDispatch_Implementation(CNDSUserCollection)


CNDSUserCollection::CNDSUserCollection():
        _ADsPath(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vMembers);
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNDSUserCollection);
}


HRESULT
CNDSUserCollection::CreateUserCollection(
    BSTR bstrADsPath,
    VARIANT varMembers,
    REFIID riid,
    void **ppvObj
    )
{
    CNDSUserCollection FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserCollectionObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(bstrADsPath, &(pUser->_ADsPath));
    BAIL_ON_FAILURE(hr);

    hr = VariantCopy(&(pUser->_vMembers), &varMembers);
    BAIL_ON_FAILURE(hr);

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);

}


CNDSUserCollection::~CNDSUserCollection( )
{
    VariantClear(&_vMembers);
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CNDSUserCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CNDSUserCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
       RRETURN(S_FALSE);
    }   
}

STDMETHODIMP
CNDSUserCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CNDSUserCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSUserCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CNDSUserCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNDSUserCollectionEnum::Create(
                _ADsPath,
                (CNDSUserCollectionEnum **)&penum,
                _vMembers,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CNDSUserCollection::AllocateUserCollectionObject(
    CNDSUserCollection ** ppUser
    )
{
    CNDSUserCollection FAR * pUser = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pUser = new CNDSUserCollection();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pUser,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  NDS CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(LIBID_NDSOle,0x53E7F030L,0x7B9D,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSNamespace,0x51D11C90L,0x7B9D,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSGenObject,0x8B645280L,0x7BA4,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSProvider,0x323991F0L,0x7BAD,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_NDSTree,0x47E94340L,0x994F,0x11CF,0xA5,0xF2,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSSchema,0x65E252B0L,0xB4C8,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSClass,0x946260E0L,0xB505,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSProperty,0x93F8FBF0L,0xB67B,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_NDSSyntax,0x953DBC50L,0xEBDB,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for NDS guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// NDSOle CLSIDs
//
//-------------------------------------------


//
// NDSOle objects
//

extern const CLSID LIBID_NDSOle;

extern const CLSID CLSID_NDSNamespace;

extern const CLSID CLSID_NDSGenObject;

extern const CLSID CLSID_NDSProvider;

extern const CLSID CLSID_NDSTree;

extern const CLSID CLSID_NDSSchema;

extern const CLSID CLSID_NDSClass;

extern const CLSID CLSID_NDSProperty;

extern const CLSID CLSID_NDSSyntax;

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}


#define CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr)                    \
    if (dwStatus) {                                                   \
        hr = CheckAndSetExtendedError(dwStatus);                      \
        BAIL_ON_FAILURE(hr);                                          \
    }

#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))


#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

WCHAR *szProviderName = L"NDS";

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_DOMAIN, L"domain"},
    { TOKEN_USER, L"user"},
    { TOKEN_GROUP, L"group"},
    { TOKEN_COMPUTER, L"computer"},
    { TOKEN_PRINTER, L"printqueue"},
    { TOKEN_SERVICE, L"service"},
    { TOKEN_FILESERVICE, L"fileservice"},
    { TOKEN_SCHEMA, L"schema"},
    { TOKEN_CLASS, L"class"},
    { TOKEN_FUNCTIONALSET, L"functionalset"},
    { TOKEN_FUNCTIONALSETALIAS, L"functionalsetalias"},
    { TOKEN_PROPERTY, L"property"},
    { TOKEN_SYNTAX, L"syntax"},
    { TOKEN_FILESHARE, L"fileshare"}
};

CClassCache *  pgClassCache;

SYNTAXMAP g_aNDSSyntaxMap[] =

{
  /* 0 */
  { TEXT("Unmappable"),  TEXT("Unknown"),  VT_UNKNOWN},

  /* 1 */
  { TEXT("String"),  TEXT("NDS Distinguished Name"),  VT_BSTR},

  /* 2 */
  { TEXT("String"),  TEXT("NDS Case Exact String"),   VT_BSTR},

  /* 3 */
  { TEXT("String"),  TEXT("NDS Case Ignore String"),  VT_BSTR},

  /* 4 */
  { TEXT("String"),  TEXT("NDS Printable String"),    VT_BSTR},

  /* 5 */
  { TEXT("String"),  TEXT("NDS Numeric String"),      VT_BSTR},

  /* 6 */
  { TEXT("Case Ignore List"), TEXT("NDS Case Ignore List"),  VT_VARIANT},

  /* 7 */
  { TEXT("Boolean"),    TEXT("NDS Boolean"),           VT_BOOL},

  /* 8 */
  { TEXT("Integer"),    TEXT("NDS Integer"),           VT_I4},

  /* 9 */
  { TEXT("Octet"),  TEXT("NDS Octet String"),     VT_VARIANT},

  /* 10 */
  { TEXT("String"),      TEXT("NDS Telephone Number"),  VT_BSTR},

  /* 11 */
  { TEXT("FaxNumber"),  TEXT("NDS Facsimile Number"),  VT_DISPATCH},

  /* 12 */
  { TEXT("NetAddress"),  TEXT("NDS Network Address"),   VT_DISPATCH},

  /* 13 */
  { TEXT("Octet List"),  TEXT("NDS Octet List"),        VT_VARIANT},

  /* 14 */
  { TEXT("Email"),  TEXT("NDS Email Address"),     VT_DISPATCH},

  /* 15 */
  { TEXT("Path"),  TEXT("NDS Path"),              VT_DISPATCH},

  /* 16 */
  { TEXT("Replica Pointer"),  TEXT("Replica Pointer"),       VT_DISPATCH},

  /* 17 */
  { TEXT("ACL"),  TEXT("NDS Object ACL"),        VT_DISPATCH},

  /* 18 */
  { TEXT("Postal Address"),  TEXT("NDS Postal Address"),     VT_DISPATCH},

  /* 19 */
  { TEXT("Timestamp"),  TEXT("NDS Timestamp"),          VT_DISPATCH},

  /* 20 */
  { TEXT("Object Class"),      TEXT("NDS Class Name"),         VT_BSTR},

  /* 21 */
  { TEXT("Octet"),   TEXT("NDS Stream"),            VT_VARIANT},

  /* 22 */
  { TEXT("Integer"),      TEXT("NDS Counter"),           VT_I4},

  /* 23 */
  { TEXT("Back Link"),     TEXT("NDS Back Link"),       VT_DISPATCH},

  /* 24 */
  { TEXT("Time"),           TEXT("NDS Time"),             VT_DATE},

  /* 25 */
  { TEXT("Typed Name"),     TEXT("NDS Typed Name"),      VT_DISPATCH},

  /* 26 */
  { TEXT("Hold"),     TEXT("NDS Hold"),            VT_DISPATCH},

  /* 27 */
  { TEXT("Integer"),     TEXT("NDS Interval"),           VT_I4}
};

DWORD g_cNDSSyntaxMap = (sizeof(g_aNDSSyntaxMap)/sizeof(g_aNDSSyntaxMap[0]));

SYNTAXINFO g_aNDSSyntax[] =
{
  { TEXT("String"),  VT_BSTR},
  { TEXT("Case Ignore List"), VT_VARIANT},
  { TEXT("Boolean"),    VT_BOOL},
  { TEXT("Octet"),  VT_VARIANT},
  { TEXT("FaxNumber"),VT_DISPATCH},
  { TEXT("NetAddress"),  VT_DISPATCH},
  { TEXT("Octet List"),  VT_VARIANT},
  { TEXT("Email"),  VT_DISPATCH},
  { TEXT("Path"),  VT_DISPATCH},
  { TEXT("Replica Pointer"),  VT_DISPATCH},
  { TEXT("ACL"),  VT_DISPATCH},
  { TEXT("Postal Address"),  VT_DISPATCH},
  { TEXT("Timestamp"),  VT_DISPATCH},
  { TEXT("Object Class"),      VT_BSTR},
  { TEXT("Back Link"),     VT_DISPATCH},
  { TEXT("Time"),           VT_DATE},
  { TEXT("Typed Name"),     VT_DISPATCH},
  { TEXT("Hold"),     VT_DISPATCH},
  { TEXT("Integer"),  VT_I4}
};

DWORD g_cNDSSyntax = (sizeof(g_aNDSSyntax)/sizeof(g_aNDSSyntax[0]));

ADSTYPE g_MapNdsTypeToADsType[] = {
    ADSTYPE_INVALID,                            /* Unknown */                             
    ADSTYPE_DN_STRING,                          /* Distinguished Name */                  
    ADSTYPE_CASE_EXACT_STRING,                  /* Case Exact String */                   
    ADSTYPE_CASE_IGNORE_STRING,                 /* Case Ignore String */                  
    ADSTYPE_PRINTABLE_STRING,                   /* Printable String */                    
    ADSTYPE_NUMERIC_STRING,                     /* Numeric String */                      
    ADSTYPE_CASEIGNORE_LIST,                /* Case Ignore List */                    
    ADSTYPE_BOOLEAN,                            /* Boolean */                             
    ADSTYPE_INTEGER,                            /* Integer */                             
    ADSTYPE_OCTET_STRING,                       /* Octet String */                        
    ADSTYPE_CASE_IGNORE_STRING,                 /* Telephone Number */                    
    ADSTYPE_FAXNUMBER,                      /* Facsimile Telephone Number */          
    ADSTYPE_NETADDRESS,                     /* Net Address */                         
    ADSTYPE_OCTET_LIST,                     /* Octet List */                          
    ADSTYPE_EMAIL,                          /* EMail Address */                       
    ADSTYPE_PATH,                           /* Path */                                
    ADSTYPE_REPLICAPOINTER,                 /* Replica Pointer */                     
    ADSTYPE_PROV_SPECIFIC,                      /* Object ACL */                          
    ADSTYPE_POSTALADDRESS,                  /* Postal Address */                      
    ADSTYPE_TIMESTAMP,                      /* Timestamp */                           
    ADSTYPE_OBJECT_CLASS,                       /* Class Name */                          
    ADSTYPE_OCTET_STRING,                       /* Stream */                              
    ADSTYPE_INTEGER,                            /* Counter */                             
    ADSTYPE_BACKLINK,                       /* Back Link */                           
    ADSTYPE_UTC_TIME,                           /* Time */                                
    ADSTYPE_TYPEDNAME,                      /* Typed Name */                          
    ADSTYPE_HOLD,                           /* Hold */                                
    ADSTYPE_INTEGER                             /* Interval */                            
};                                                                                        


DWORD g_cMapNdsTypeToADsType = (sizeof(g_MapNdsTypeToADsType)/sizeof(g_MapNdsTypeToADsType[0]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  getobj.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

extern LPWSTR szProviderName;

//+---------------------------------------------------------------------------
//  Function:   RelativeGetObject
//
//  Synopsis:   Gets object relative to given Active Directory path.
//
//  Arguments:  [BSTR ADsPath]
//              [BSTR ClassName]
//              [BSTR RelativeName]
//              [IUnknown** ppObject]
//              [BOOT bNamespaceRelative]
//
//  Returns:    HRESULT
//
//  Modifies:   *ppObject
//
//  History:    08-02-96   t-danal     Created as such.
//
//----------------------------------------------------------------------------
HRESULT
RelativeGetObject(
    BSTR ADsPath,
    BSTR ClassName,
    BSTR RelativeName,
    CCredentials& Credentials,
    IDispatch * FAR* ppObject,
    BOOL bNamespaceRelative
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    *ppObject = NULL;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    memset(szBuffer, 0, sizeof(szBuffer));
    wcscpy(szBuffer, ADsPath);

    if (bNamespaceRelative)
        wcscat(szBuffer, L"//");
    else
        wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR szBuffer,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    DWORD dwStatus = NO_ERROR;
    DWORD dwNumberEntries = 0;
    DWORD dwModificationTime = 0;
    WCHAR szObjectClassName[MAX_PATH];
    WCHAR szObjectFullName[MAX_PATH];

    LPWSTR pszNDSPath = NULL;

    WCHAR szParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    HANDLE hObject = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);

    IADs * pADs = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is @NDS!
    //

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);



    hr = ValidateObjectType(pObjectInfo);

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_SCHEMA:

        hr = GetSchemaObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;


    default:
        hr = BuildNDSPathFromADsPath(
                    szBuffer,
                    &pszNDSPath
                    );
        BAIL_ON_FAILURE(hr);

        dwStatus  = ADsNwNdsOpenObject(
                        pszNDSPath,
                        Credentials,
                        &hObject,
                        szObjectFullName,
                        szObjectClassName,
                        &dwModificationTime,
                        &dwNumberEntries
                        );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);

        hr = BuildADsParentPath(
                    szBuffer,
                    szParent,
                    szCommonName
                    );
        BAIL_ON_FAILURE(hr);

        hr = CNDSGenObject::CreateGenericObject(
                        szParent,
                        szCommonName,
                        szObjectClassName,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IADs,
                        (void **)&pADs
                        );
        BAIL_ON_FAILURE(hr);

        //
        // InstantiateDerivedObject should add-ref this pointer for us.
        //

        hr = InstantiateDerivedObject(
                        pADs,
                        Credentials,
                        IID_IUnknown,
                        (void **)ppObject
                        );

        if (FAILED(hr)) {
            hr = pADs->QueryInterface(
                            IID_IUnknown,
                            ppObject
                            );
            BAIL_ON_FAILURE(hr);

        }
        break;

    }

error:
    if (hObject) {
        NwNdsCloseObject(hObject);
    }
    
    if (pszNDSPath) {

        FreeADsStr(pszNDSPath);
    }


    if (pADs) {
        pADs->Release();
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);
}

HRESULT
BuildADsPathFromNDSPath(
    LPWSTR szNDSTreeName,
    LPWSTR szNDSDNName,
    LPWSTR szADsPathName
    )
{
    PKEYDATA pKeyData = NULL;
    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR pszDisplayTreeName = NULL;
    LPWSTR pszDisplayDNName = NULL;
    HRESULT hr = S_OK;

    if (!szNDSTreeName || !szNDSDNName) {
        RRETURN(E_FAIL);
    }

    hr = GetDisplayName(
             szNDSTreeName,
             &pszDisplayTreeName
             );
    BAIL_ON_FAILURE(hr);

    wsprintf(szADsPathName,L"%s:%s", szProviderName, szNDSTreeName);

    hr = GetDisplayName(
             szNDSDNName,
             &pszDisplayDNName
             );
    BAIL_ON_FAILURE(hr);

    pKeyData = CreateTokenList(
                    pszDisplayDNName,
                    L'.'
                    );

    if (pKeyData) {

        dwCount = pKeyData->cTokens;
        for (i = 0; i < dwCount; i++) {
            wcscat(szADsPathName, L"/");
            wcscat(szADsPathName, pKeyData->pTokens[dwCount - 1 - i]);
        }
    }

    if (pKeyData) {
        FreeADsMem(pKeyData);
    }

error:

    if (pszDisplayTreeName) {
        FreeADsMem(pszDisplayTreeName);
    }

    if (pszDisplayDNName) {
        FreeADsMem(pszDisplayDNName);
    }

    RRETURN(hr);
}


HRESULT
BuildNDSPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR * pszNDSPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;
    LPWSTR szNDSPathName = NULL;


    *pszNDSPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    szNDSPathName = AllocADsStr(szADsPathName);
    if (!szNDSPathName) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(szNDSPathName, L"\\\\");
    wcscat(szNDSPathName, pObjectInfo->TreeName);

    if (dwNumComponents) {

        wcscat(szNDSPathName, L"\\");

        for (i = dwNumComponents; i >  0; i--) {

            AppendComponent(
                    szNDSPathName,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

            if ((i - 1) > 0){
                wcscat(szNDSPathName, L".");
            }
        }

    }

    *pszNDSPathName = szNDSPathName;

error:

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}

HRESULT
AppendComponent(
   LPWSTR szNDSPathName,
   PCOMPONENT pComponent
   )
{
    if (pComponent->szComponent && pComponent->szValue) {
        wcscat(szNDSPathName, pComponent->szComponent);
        wcscat(szNDSPathName,L"=");
        wcscat(szNDSPathName, pComponent->szValue);

    }else if (pComponent->szComponent && !pComponent->szValue) {
        wcscat(szNDSPathName, pComponent->szComponent);
    }else {
        //
        // we should never hit this case
        //
    }

    RRETURN(S_OK);
}



HRESULT
BuildADsParentPath(
    LPWSTR szBuffer,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPath(
             pObjectInfo, 
             szParent, 
             szCommonName
             );

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
// Function:    GetNamespaceObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;

    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    hr = CNDSNamespace::CreateNamespace(
                L"ADs:",
                L"NDS:",
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                ppObject
                );


error:

    RRETURN(hr);
}

HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (!_wcsicmp(pObjectInfo->ProviderName, szProviderName)) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}



//+---------------------------------------------------------------------------
// Function:    GetSchemaObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR szParent[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    WCHAR szNDSPathName[MAX_PATH];
    DWORD dwObjectType = 0;
    DWORD dwStatus;
    HANDLE hTree = NULL;

    hr = ValidateSchemaObject(
                pObjectInfo,
                &dwObjectType
                );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsParentPath(
             pObjectInfo,
             szParent,
             szCommonName
             );
    BAIL_ON_FAILURE(hr);

    switch(dwObjectType) {
    case NDS_CLASS_ID:
    case NDS_PROPERTY_ID:
    case NDS_CLASSPROP_ID:
        wcscpy(szNDSPathName, L"\\\\");
        wcscat(szNDSPathName, pObjectInfo->TreeName);
        dwStatus = ADsNwNdsOpenObject(
                                   szNDSPathName,
                                   Credentials,
                                   &hTree,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL
                                   );

        CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr);
        break;

    default:
        break;
    }

    //
    // Note: The "error:" tag is at the end of the switch statement,
    //       so we can simply break out.
    //

    switch (dwObjectType) {
    case NDS_SCHEMA_ID:
        hr = CNDSSchema::CreateSchema(
                    szParent,
                    szCommonName,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    case NDS_CLASSPROP_ID:
        hr = CNDSClass::CreateClass(
                    szParent,
                    szCommonName,
                    hTree,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        if (FAILED(hr)) {

            hr = CNDSProperty::CreateProperty(
                        szParent,
                        szCommonName,
                        hTree,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IUnknown,
                        ppObject
                        );
            BAIL_ON_FAILURE(hr);

        }
        break;

    case NDS_CLASS_ID:
        hr = CNDSClass::CreateClass(
                    szParent,
                    szCommonName,
                    hTree,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    case NDS_PROPERTY_ID:
        hr = CNDSProperty::CreateProperty(
                    szParent,
                    szCommonName,
                    hTree,
                    Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IUnknown,
                    ppObject
                    );
        break;

    default:
        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

error:
    if (hTree) {
        NwNdsCloseObject(hTree);
    }
    RRETURN(hr);
}

HRESULT
ValidateSchemaObject(
    POBJECTINFO pObjectInfo,
    PDWORD pdwObjectType
    )
{
    DWORD dwNumComponents = 0;

    dwNumComponents = pObjectInfo->NumComponents;




    switch (dwNumComponents) {

    case 1:
        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent, L"schema")) {
            *pdwObjectType = NDS_SCHEMA_ID;
            RRETURN(S_OK);
        }
        break;

    case 2:
        if (pObjectInfo->ClassName) {
            if (!_wcsicmp(pObjectInfo->ClassName, L"Property")) {
                *pdwObjectType = NDS_PROPERTY_ID;
            }
            else {
                *pdwObjectType = NDS_CLASS_ID;
            }
        }
        else {
            *pdwObjectType = NDS_CLASSPROP_ID;
        }
        RRETURN(S_OK);


/*        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent, L"schema")) {
            *pdwObjectType = NDS_CLASS_ID;
            RRETURN(S_OK);
        }
        break;


    case 3:
        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,SCHEMA_NAME)) {
            *pdwObjectType = NDS_PROPERTY_ID;
            RRETURN(S_OK);
        }
        break; */

    default:
        break;


    }

    RRETURN(E_FAIL);
}

HRESULT
BuildADsParentPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;

    dwNumComponents = pObjectInfo->NumComponents;

    if (!dwNumComponents && !pObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(szParent,L"ADs:");

        RRETURN(S_OK);

    } else if (!dwNumComponents && pObjectInfo->DisplayTreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @NDS! object

        wsprintf(szParent, L"%s:", pObjectInfo->ProviderName);

        //
        // And the common name is the TreeName. Remember the
        // "//" will be added on  when we reconstruct the full
        // pathname
        //

        wsprintf(szCommonName,L"%s", pObjectInfo->DisplayTreeName);


        RRETURN(S_OK);


    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(
            szParent, L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->DisplayTreeName
            );

        for (i = 0; i < dwNumComponents - 1; i++) {

            wcscat(szParent, L"/");

            AppendComponent(szParent, &(pObjectInfo->DisplayComponentArray[i]));

        }

        //
        // And the common name is the last component
        //

        szCommonName[0] = '\0';
        AppendComponent(szCommonName, &(pObjectInfo->DisplayComponentArray[dwNumComponents-1]));
    }

    RRETURN(S_OK);
}


HRESULT
ValidateObjectType(
    POBJECTINFO pObjectInfo
    )
{

    pObjectInfo->ObjectType = TOKEN_NDSOBJECT;

    if (pObjectInfo->ProviderName && !pObjectInfo->TreeName
            && !pObjectInfo->NumComponents) {
        pObjectInfo->ObjectType = TOKEN_NAMESPACE;
    }else if (pObjectInfo->ProviderName && pObjectInfo->TreeName
                && pObjectInfo->NumComponents) {

        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"schema")) {
            pObjectInfo->ObjectType = TOKEN_SCHEMA;
        }

    }

    RRETURN(S_OK);
}




HRESULT
BuildNDSTreeNameFromADsPath(
    LPWSTR szBuffer,
    LPWSTR szNDSTreeName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    DWORD dwNumComponents = 0;
    HRESULT hr;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;


    if (!dwNumComponents && !pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        hr = E_FAIL;

    } else if (!dwNumComponents && pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @NDS! object

        wsprintf(szNDSTreeName,L"\\\\%s", pObjectInfo->TreeName);


        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(szNDSTreeName,L"\\\\%s", pObjectInfo->TreeName);

        hr = S_OK;
    }

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);

}



HRESULT
BuildNDSPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR szNDSTreeName,
    LPWSTR szNDSPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;

    wcscpy(szNDSTreeName, L"\\\\");
    wcscat(szNDSTreeName, pObjectInfo->TreeName);

    *szNDSPathName = L'\0';

    if (dwNumComponents) {

        for (i = dwNumComponents; i >  0; i--) {

            AppendComponent(
                    szNDSPathName,
                    &(pObjectInfo->ComponentArray[i-1])
                    );

            if ((i - 1) > 0){
                wcscat(szNDSPathName, L".");
            }
        }

    }

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    FreeADsStr( pObjectInfo->ProviderName );
    FreeADsStr( pObjectInfo->TreeName );
    FreeADsStr( pObjectInfo->DisplayTreeName );
    FreeADsStr( pObjectInfo->ClassName);
    
    for ( DWORD i = 0; i < pObjectInfo->NumComponents; i++ ) {
        FreeADsStr( pObjectInfo->ComponentArray[i].szComponent );
        FreeADsStr( pObjectInfo->ComponentArray[i].szValue );
        FreeADsStr( pObjectInfo->DisplayComponentArray[i].szComponent );
        FreeADsStr( pObjectInfo->DisplayComponentArray[i].szValue );
    }

    // We don't need to free pObjectInfo since the object is always a static
    // variable on the stack.
}


HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;
    BOOL fQuotingOn = FALSE;

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;
    fQuotingOn = FALSE;

    for (len=0; *pch; pch++, len++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            len++;
        }
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName; 
    pszDisplayCh = pszDisplay;
    fQuotingOn = FALSE;

    for (; *pch; pch++, pszDisplayCh++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            *pszDisplayCh++ = L'\\';
        }
        *pszDisplayCh = *pch;
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\nds2.h ===
#define NDS_CLSID_NDSNamespace             51d11c90-7b9d-11cf-b03d-00aa006e0975
#define NDS_LIBIID_NDSOle                  53e7f030-7b9d-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSGenObject             8b645280-7ba4-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSProvider              323991f0-7bad-11cf-b03d-00aa006e0975
#define NDS_CLSID_NDSTree                  47e94340-994f-11cf-a5f2-00aa006e05d3
#define NDS_CLSID_NDSSchema                65e252b0-b4c8-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSClass                 946260e0-b505-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSProperty              93f8fbf0-b67b-11cf-a2b5-00aa006e05d3
#define NDS_CLSID_NDSSyntax                953dbc50-ebdb-11cf-8abc-00c04fd8d503

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);

#define PROPERTY_VARIANT_RW(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT v##name);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HINSTANCE g_hInst = NULL;
extern HMODULE g_hActiveDs;
WCHAR * szNDSPrefix = L"@NDS!";

extern CRITICAL_SECTION g_DispTypeInfoCritSect;
//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"NDS",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"NDS",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"NDS",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CNDSProviderCF g_cfProvider;
CNDSNamespaceCF g_cfNamespace;

CCaseIgnoreListCF g_cfCaseIgnoreList;
CFaxNumberCF g_cfFaxNumber;
CNetAddressCF g_cfNetAddress;
COctetListCF g_cfOctetList;
CEmailCF g_cfEmail;
CPathCF g_cfPath;
CReplicaPointerCF g_cfReplicaPointer;
CTimestampCF g_cfTimestamp;
CPostalAddressCF g_cfPostalAddress;
CBackLinkCF g_cfBackLink;
CTypedNameCF g_cfTypedName;
CHoldCF g_cfHold;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_NDSProvider,                        &g_cfProvider,
    &CLSID_NDSNamespace,                       &g_cfNamespace,
    &CLSID_CaseIgnoreList,                  &g_cfCaseIgnoreList,
    &CLSID_FaxNumber,                       &g_cfFaxNumber,
    &CLSID_NetAddress,                      &g_cfNetAddress,
    &CLSID_OctetList,                       &g_cfOctetList,
    &CLSID_Email,                           &g_cfEmail,
    &CLSID_Path,                            &g_cfPath,
    &CLSID_ReplicaPointer,                  &g_cfReplicaPointer,
    &CLSID_Timestamp,                       &g_cfTimestamp,
    &CLSID_PostalAddress,                   &g_cfPostalAddress,
    &CLSID_BackLink,                        &g_cfBackLink,
    &CLSID_TypedName,                       &g_cfTypedName,
    &CLSID_Hold,                            &g_cfHold,
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (DllReadyToUnload()) {
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Need to trap cases of init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

            g_hActiveDs = GetModuleHandle(TEXT("activeds.dll"));

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif

            InitializeCriticalSection(&g_DispTypeInfoCritSect);

            //
            // Build the global object class cache
            //

            hr = CClassCache::CreateClassCache(
                            &pgClassCache
                            );
            if (FAILED(hr)) {
                return(FALSE);
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical Failure
            //
            return FALSE;
        }
        break;


    case DLL_PROCESS_DETACH:

        delete pgClassCache;

//        FreeTypeInfoTable();

        //
        // Delete the critsects
        //
#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT);
        DeleteCriticalSection(&g_csMem);
#endif
        DeleteCriticalSection(&g_csDP);
#endif

        DeleteCriticalSection(&g_DispTypeInfoCritSect);

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\mapper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

HRESULT
InstantiateDerivedObject(
    IADs FAR * pADs,
    CCredentials& Credentials,
    REFIID riid,
    void  ** ppObject
    )
{
    BSTR bstrClassName = NULL;
    DWORD dwObjectId = 0;
    HRESULT hr = S_OK;

    *ppObject  = NULL;

    hr = pADs->get_Class(&bstrClassName);
    BAIL_ON_FAILURE(hr);

    hr = IsValidFilter(
            bstrClassName,
            &dwObjectId,
            gpFilters,
            gdwMaxFilters
            );
    BAIL_ON_FAILURE(hr)

    switch (dwObjectId) {

    case NDS_USER_ID:
        hr = CNDSUser::CreateUser(
                        pADs,
                        Credentials,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_GROUP_ID:
        hr = CNDSGroup::CreateGroup(
                        pADs,
                        Credentials,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_LOCALITY_ID:
        hr = CNDSLocality::CreateLocality(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;

    case NDS_O_ID:
        hr = CNDSOrganization::CreateOrganization(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;



    case NDS_OU_ID:
        hr = CNDSOrganizationUnit::CreateOrganizationUnit(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;


    case NDS_PRINTER_ID:
        hr = CNDSPrintQueue::CreatePrintQueue(
                        pADs,
                        riid,
                        ppObject
                        );
        BAIL_ON_FAILURE(hr);
        break;



    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

error:
    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\nds2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

HRESULT
NdsTypeToAdsTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    struct _NDS_CI_LIST *pNdsNext = &lpNdsSrcObject->NdsValue.value_6;
    PADS_CASEIGNORE_LIST pAdsOutput = NULL;
    PADS_CASEIGNORE_LIST pAdsCurrent = NULL;

    lpAdsDestValue->dwType = ADSTYPE_CASEIGNORE_LIST;

    lpAdsDestValue->pCaseIgnoreList = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
    if (!lpAdsDestValue->pCaseIgnoreList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pAdsOutput = lpAdsDestValue->pCaseIgnoreList;

    pAdsOutput->String = AllocADsStr(pNdsNext->String);
    if (!pAdsOutput->String) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pNdsNext = pNdsNext->Next;

    while (pNdsNext) {
        pAdsCurrent = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
        if (!pAdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAdsCurrent->String = AllocADsStr(pNdsNext->String);
        if (!pAdsCurrent->String) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAdsOutput->Next = pAdsCurrent;
        pAdsOutput = pAdsCurrent;
        pNdsNext = pNdsNext->Next;
    }

    pAdsOutput->Next = NULL;

error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpNdsSrcObject->NdsValue.value_7.Boolean;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLength = lpNdsSrcObject->NdsValue.value_9.Length;

    if (dwLength) {

        lpByte = (LPBYTE)AllocADsMem(dwLength);
        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (lpNdsSrcObject->NdsValue.value_9.OctetString) {
            memcpy(lpByte, lpNdsSrcObject->NdsValue.value_9.OctetString, dwLength);
        }

        lpAdsDestValue->OctetString.dwLength = dwLength;
        lpAdsDestValue->OctetString.lpValue = lpByte;

    }else {

        lpAdsDestValue->OctetString.dwLength = 0;
        lpAdsDestValue->OctetString.lpValue = NULL;

    }

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if (!lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_FAXNUMBER;

    lpAdsDestValue->pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
    if (!lpAdsDestValue->pFaxNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pFaxNumber->TelephoneNumber =
                            AllocADsStr(lpNdsSrcObject->NdsValue.value_11.TelephoneNumber);
    if ((!lpAdsDestValue->pFaxNumber->TelephoneNumber) &&
        (lpNdsSrcObject->NdsValue.value_11.TelephoneNumber)){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
                            

    hr = CopyOctetString(lpNdsSrcObject->NdsValue.value_11.NumberOfBits,
                         lpNdsSrcObject->NdsValue.value_11.Parameters,
                         &lpAdsDestValue->pFaxNumber->NumberOfBits,
                         &lpAdsDestValue->pFaxNumber->Parameters);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_NETADDRESS;

    lpAdsDestValue->pNetAddress = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!lpAdsDestValue->pNetAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pNetAddress->AddressType =
                            lpNdsSrcObject->NdsValue.value_12.AddressType;

    hr = CopyOctetString(lpNdsSrcObject->NdsValue.value_12.AddressLength,
                         lpNdsSrcObject->NdsValue.value_12.Address,
                         &lpAdsDestValue->pNetAddress->AddressLength,
                         &lpAdsDestValue->pNetAddress->Address);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    struct _NDS_OCTET_LIST *pNdsNext = &lpNdsSrcObject->NdsValue.value_13;
    PADS_OCTET_LIST pAdsOutput = NULL;
    PADS_OCTET_LIST pAdsCurrent = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_LIST;

    lpAdsDestValue->pOctetList = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
    if (!lpAdsDestValue->pOctetList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    pAdsOutput = lpAdsDestValue->pOctetList;

    hr = CopyOctetString(pNdsNext->Length,
                         pNdsNext->Data,
                         &pAdsOutput->Length,
                         &pAdsOutput->Data);
    BAIL_ON_FAILURE(hr);
    pNdsNext = pNdsNext->Next;

    while (pNdsNext) {
        pAdsCurrent = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
        if (!pAdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        hr = CopyOctetString(pNdsNext->Length,
                             pNdsNext->Data,
                             &pAdsOutput->Length,
                             &pAdsOutput->Data);
        BAIL_ON_FAILURE(hr);
        pAdsOutput->Next = pAdsCurrent;
        pAdsOutput = pAdsCurrent;
        pNdsNext = pNdsNext->Next;
    }

    pAdsOutput->Next = NULL;
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_EMAIL;

    lpAdsDestValue->Email.Address=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_14.Address
                        );
    if (!lpAdsDestValue->Email.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->Email.Type =
                            lpNdsSrcObject->NdsValue.value_14.Type;
error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_PATH;

    lpAdsDestValue->pPath = (PADS_PATH)AllocADsMem(sizeof(ADS_PATH));
    if (!lpAdsDestValue->pPath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->VolumeName =
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.VolumeName
                        );
    if (!lpAdsDestValue->pPath->VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Path=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.Path
                        );
    if (!lpAdsDestValue->pPath->Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Type =
                            lpNdsSrcObject->NdsValue.value_15.Type;
error:
    RRETURN(hr);
}



HRESULT
NdsTypeToAdsTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount,dwIter;

    lpAdsDestValue->dwType = ADSTYPE_REPLICAPOINTER;

    lpAdsDestValue->pReplicaPointer = (PADS_REPLICAPOINTER)AllocADsMem(sizeof(ADS_REPLICAPOINTER));
    if (!lpAdsDestValue->pReplicaPointer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ServerName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_16.ServerName
                        );
    if (!lpAdsDestValue->pReplicaPointer->ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ReplicaType =
                            lpNdsSrcObject->NdsValue.value_16.ReplicaType;
    lpAdsDestValue->pReplicaPointer->ReplicaNumber =
                            lpNdsSrcObject->NdsValue.value_16.ReplicaNumber;

    dwCount = lpNdsSrcObject->NdsValue.value_16.Count;

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints =
                        (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS)*dwCount);
    if (!lpAdsDestValue->pReplicaPointer->ReplicaAddressHints) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memset(lpAdsDestValue->pReplicaPointer->ReplicaAddressHints, 0, sizeof(ADS_NETADDRESS)*dwCount);

    for ( dwIter = 0; dwIter < dwCount; dwIter++ ) {
        (lpAdsDestValue->pReplicaPointer->ReplicaAddressHints+dwIter)->AddressType =
                                (lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->AddressType;
    
        hr = CopyOctetString((lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->AddressLength,
                             (lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->Address,
                             &(lpAdsDestValue->pReplicaPointer->ReplicaAddressHints+dwIter)->AddressLength,
                             &(lpAdsDestValue->pReplicaPointer->ReplicaAddressHints+dwIter)->Address);
    }

    lpAdsDestValue->pReplicaPointer->Count = dwCount;

error:
    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr;

    hr = E_ADS_CANT_CONVERT_DATATYPE;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    long i;

    lpAdsDestValue->dwType = ADSTYPE_POSTALADDRESS;

    lpAdsDestValue->pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
    if (!lpAdsDestValue->pPostalAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    for (i=0;i<6;i++) {
        if (lpNdsSrcObject->NdsValue.value_18.PostalAddress[i]) {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] =
                                AllocADsStr(
                                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[i]
                                );
            if (!lpAdsDestValue->pPostalAddress->PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        else {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] =
                                AllocADsStr(
                                    L""
                                );
            if (!lpAdsDestValue->pPostalAddress->PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
                                
        }
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_TIMESTAMP;

    lpAdsDestValue->Timestamp.WholeSeconds =
                            lpNdsSrcObject->NdsValue.value_19.WholeSeconds;

    lpAdsDestValue->Timestamp.EventID =
                            lpNdsSrcObject->NdsValue.value_19.EventID;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_OBJECT_CLASS;

    lpAdsDestValue->ClassName  =
                        AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_20.ClassName
                                );
    if (!lpAdsDestValue->ClassName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    LPBYTE lpByte = NULL;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLength = lpNdsSrcObject->NdsValue.value_21.Length;

    if (dwLength) {

        lpByte = (LPBYTE)AllocADsMem(dwLength);
        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (lpNdsSrcObject->NdsValue.value_21.Data) {
            memcpy(lpByte, lpNdsSrcObject->NdsValue.value_21.Data, dwLength);
        }

        lpAdsDestValue->OctetString.dwLength = dwLength;
        lpAdsDestValue->OctetString.lpValue = lpByte;

    }else {

        lpAdsDestValue->OctetString.dwLength = 0;
        lpAdsDestValue->OctetString.lpValue = NULL;

    }
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BACKLINK;

    lpAdsDestValue->BackLink.ObjectName =
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_23.ObjectName
                        );
    if (!lpAdsDestValue->BackLink.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->BackLink.RemoteID =
                            lpNdsSrcObject->NdsValue.value_23.RemoteID;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    hr = ConvertDWORDtoSYSTEMTIME(
                lpNdsSrcObject->NdsValue.value_24.Time,
                &(lpAdsDestValue->UTCTime)
                );

    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_TYPEDNAME;

    lpAdsDestValue->pTypedName = (PADS_TYPEDNAME)AllocADsMem(sizeof(ADS_TYPEDNAME));
    if (!lpAdsDestValue->pTypedName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pTypedName->ObjectName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_25.ObjectName
                        );
    if (!lpAdsDestValue->pTypedName->ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pTypedName->Level=
                            lpNdsSrcObject->NdsValue.value_25.Level;

    lpAdsDestValue->pTypedName->Interval=
                            lpNdsSrcObject->NdsValue.value_25.Interval;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_HOLD;

    lpAdsDestValue->Hold.ObjectName=
                        AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_26.ObjectName
                        );
    if (!lpAdsDestValue->Hold.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->Hold.Amount=
                            lpNdsSrcObject->NdsValue.value_26.Amount;
error:
    RRETURN(hr);
}

HRESULT
NdsTypeToAdsTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeToAdsTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 2:
        hr = NdsTypeToAdsTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 3:
        hr = NdsTypeToAdsTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 4:
        hr = NdsTypeToAdsTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 5:
        hr = NdsTypeToAdsTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 6:
        hr = NdsTypeToAdsTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 7:
        hr = NdsTypeToAdsTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 8:
        hr = NdsTypeToAdsTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 9:
        hr = NdsTypeToAdsTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 10:
        hr = NdsTypeToAdsTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 11:
        hr = NdsTypeToAdsTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 12:
        hr = NdsTypeToAdsTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 13:
        hr = NdsTypeToAdsTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 14:
        hr = NdsTypeToAdsTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 15:
        hr = NdsTypeToAdsTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 16:
        hr = NdsTypeToAdsTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;


    case 17:
        hr = NdsTypeToAdsTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 18:
        hr = NdsTypeToAdsTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 19:
        hr = NdsTypeToAdsTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 20:
        hr = NdsTypeToAdsTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 21:
        hr = NdsTypeToAdsTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 22:
        hr = NdsTypeToAdsTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 23:
        hr = NdsTypeToAdsTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 24:
        hr = NdsTypeToAdsTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 25:
        hr = NdsTypeToAdsTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 26:
        hr = NdsTypeToAdsTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    case 27:
        hr = NdsTypeToAdsTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpAdsDestValue
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToAdsTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppAdsDestValues
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;

    pAdsDestValues = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pAdsDestValues) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NdsTypeToAdsTypeCopy(
                    pNdsSrcObjects + i,
                    pAdsDestValues + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppAdsDestValues = pAdsDestValues;

     RRETURN(S_OK);

error:

     if (pAdsDestValues) {
        AdsFreeAdsValues(
            pAdsDestValues,
            dwNumObjects
        );

        FreeADsMem(pAdsDestValues);
     }

     *ppAdsDestValues = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ndscopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:  Object Types 6, 13, 16, and 21 are flaky - pay extra attn.
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//


HRESULT
NdsTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );
    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }
    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_1.DNString
                            );
    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }
    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_1.DNString
                            );

    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }
                            
    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                     (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );

    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_1.DNString =
                     (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_1.DNString
                                );

    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpNdsSrcObject->NdsValue.value_1.DNString)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_6 lpNdsSrcTempASN1_6 = NULL;

    LPNDS_ASN1_TYPE_6 lpNdsDestTempASN1_6 = NULL;
    LPNDS_ASN1_TYPE_6 lpNdsDestNextASN1_6 = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsSrcTempASN1_6 = &(lpNdsSrcObject->NdsValue.value_6);
    lpNdsDestTempASN1_6 = &(lpNdsDestObject->NdsValue.value_6);

    lpNdsDestTempASN1_6->Next = NULL;

    lpNdsDestTempASN1_6->String =
                (LPWSTR)AllocADsStr(lpNdsSrcTempASN1_6->String);
    if (!lpNdsDestTempASN1_6->String) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    while ( lpNdsSrcTempASN1_6->Next != NULL )
    {
        lpNdsSrcTempASN1_6 = lpNdsSrcTempASN1_6->Next;

        lpNdsDestNextASN1_6 =
                (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));
        if (!lpNdsDestNextASN1_6) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        lpNdsDestNextASN1_6->Next = NULL;

        lpNdsDestNextASN1_6->String =
            (LPWSTR)AllocADsStr(lpNdsSrcTempASN1_6->String);
        if (!lpNdsDestNextASN1_6->String) {
            FreeADsMem(lpNdsDestNextASN1_6);
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        lpNdsDestTempASN1_6->Next = lpNdsDestNextASN1_6;

        lpNdsDestTempASN1_6 = lpNdsDestNextASN1_6;
    }

    RRETURN(hr);

error:
    if (lpNdsDestObject->NdsValue.value_6.String)
        FreeADsStr(lpNdsDestObject->NdsValue.value_6.String);

    lpNdsDestTempASN1_6 = lpNdsDestObject->NdsValue.value_6.Next;

    while (lpNdsDestTempASN1_6 != NULL) {

        if (lpNdsDestTempASN1_6->String)
            FreeADsStr(lpNdsDestTempASN1_6->String);

        lpNdsDestNextASN1_6 = lpNdsDestTempASN1_6->Next;
        FreeADsMem(lpNdsDestTempASN1_6);
        lpNdsDestTempASN1_6 = lpNdsDestNextASN1_6;
    }

    RRETURN(hr);
}





HRESULT
NdsTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        lpNdsSrcObject->NdsValue.value_7.Boolean;

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;


    lpNdsDestObject->NdsValue.value_8.Integer =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    Length = lpNdsSrcObject->NdsValue.value_9.Length;

    if (Length) {
        pBuffer = (LPBYTE)AllocADsMem(Length);
        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(
            pBuffer,
            lpNdsSrcObject->NdsValue.value_9.OctetString,
            Length
            );

        lpNdsDestObject->NdsValue.value_9.Length = Length;
        lpNdsDestObject->NdsValue.value_9.OctetString = pBuffer;
    }else{
        lpNdsDestObject->NdsValue.value_9.Length = 0;
        lpNdsDestObject->NdsValue.value_9.OctetString = NULL;
    }

error:
    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_10.TelephoneNumber =
                    (LPWSTR)AllocADsStr(
                              lpNdsSrcObject->NdsValue.value_10.TelephoneNumber
                              );

    if ((!lpNdsDestObject->NdsValue.value_10.TelephoneNumber) &&
        (lpNdsSrcObject->NdsValue.value_10.TelephoneNumber)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD AddressLength = 0;
    LPBYTE Address = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_11.NumberOfBits =
                lpNdsSrcObject->NdsValue.value_11.NumberOfBits;

    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                  (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_11.TelephoneNumber
                            );
    if (!lpNdsDestObject->NdsValue.value_11.TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    AddressLength = lpNdsSrcObject->NdsValue.value_11.NumberOfBits;

    if (AddressLength) {
        Address = (LPBYTE)AllocADsMem(AddressLength);
        if (!Address) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy(
            Address,
            lpNdsSrcObject->NdsValue.value_11.Parameters,
            AddressLength
            );
        lpNdsDestObject->NdsValue.value_11.NumberOfBits = AddressLength;
        lpNdsDestObject->NdsValue.value_11.Parameters = Address;
    }else{
        lpNdsDestObject->NdsValue.value_11.NumberOfBits = 0;
        lpNdsDestObject->NdsValue.value_11.Parameters = NULL;
    }

    RRETURN(hr);

error:
    if (lpNdsDestObject->NdsValue.value_11.TelephoneNumber)
        FreeADsMem(lpNdsDestObject->NdsValue.value_11.TelephoneNumber);

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD AddressLength = 0;
    LPBYTE Address = NULL;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_12.AddressType =
                lpNdsSrcObject->NdsValue.value_12.AddressType;

    AddressLength = lpNdsSrcObject->NdsValue.value_12.AddressLength;

    if (AddressLength) {
        Address = (LPBYTE)AllocADsMem(AddressLength);
        if (!Address) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(
            Address,
            lpNdsSrcObject->NdsValue.value_12.Address,
            AddressLength
            );

        lpNdsDestObject->NdsValue.value_12.AddressLength = AddressLength;
        lpNdsDestObject->NdsValue.value_12.Address = Address;
    }else{
        lpNdsDestObject->NdsValue.value_12.AddressLength = 0;
        lpNdsDestObject->NdsValue.value_12.Address = NULL;
    }

error:
    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    LPNDS_ASN1_TYPE_13 pSrc13, *ppDest13, pDest13, pDestNext13;
    LPBYTE lpBuffer;
    DWORD Length;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_13.Next = NULL;
    lpNdsDestObject->NdsValue.value_13.Data = NULL;

    Length =  lpNdsSrcObject->NdsValue.value_13.Length;
    lpBuffer = (LPBYTE)AllocADsMem(
                            Length
                            );
    if (!lpBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpBuffer,
        lpNdsSrcObject->NdsValue.value_13.Data,
        Length
        );

    lpNdsDestObject->NdsValue.value_13.Length = Length;
    lpNdsDestObject->NdsValue.value_13.Data = lpBuffer;

    pSrc13 = lpNdsSrcObject->NdsValue.value_13.Next;
    ppDest13 = &(lpNdsDestObject->NdsValue.value_13.Next);

    while (pSrc13)
    {
        *ppDest13 =
           (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));
        if (!*ppDest13) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        (*ppDest13)->Data =  (LPBYTE)AllocADsMem(pSrc13->Length);
        if (!((*ppDest13)->Data)) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy((*ppDest13)->Data, pSrc13->Data, pSrc13->Length);

        (*ppDest13)->Length = pSrc13->Length;


        ppDest13 = &(*ppDest13)->Next;

        pSrc13 = pSrc13->Next;
    }

    RRETURN(hr);
error:

    if (lpNdsDestObject->NdsValue.value_13.Data)
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);

    pDest13 = lpNdsDestObject->NdsValue.value_13.Next;

    while (pDest13) {
        if (pDest13->Data) 
            FreeADsMem(pDest13->Data);

        pDestNext13 = pDest13->Next;
        FreeADsMem(pDest13);
        pDest13 = pDestNext13;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_14.Address =
            (LPWSTR)AllocADsStr(
                        lpNdsSrcObject->NdsValue.value_14.Address
                        );
    if ((!lpNdsDestObject->NdsValue.value_14.Address) &&
        (lpNdsSrcObject->NdsValue.value_14.Address)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_14.Type =
                        lpNdsSrcObject->NdsValue.value_14.Type;



    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_15.Type =
            lpNdsSrcObject->NdsValue.value_15.Type;

    lpNdsDestObject->NdsValue.value_15.VolumeName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.VolumeName
                            );
    if ((!lpNdsDestObject->NdsValue.value_15.VolumeName) &&
        (lpNdsSrcObject->NdsValue.value_15.VolumeName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_15.Path =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_15.Path
                            );
    if ((!lpNdsDestObject->NdsValue.value_15.Path) &&
        (lpNdsSrcObject->NdsValue.value_15.Path)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}



HRESULT
NdsTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    DWORD Count = 0;
    DWORD iter = 0;
    DWORD dwAddrAlloc = 0;
    LPBYTE Address = NULL;
    DWORD AddressLength = 0;
    LPNDS_ASN1_TYPE_12 lpNdsDestASN1_12 = NULL, lpNdsSrcASN1_12 = NULL;


    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_16.ServerName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_16.ServerName
                            );
    if (!lpNdsDestObject->NdsValue.value_16.ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaType =
                    lpNdsSrcObject->NdsValue.value_16.ReplicaType;

    lpNdsDestObject->NdsValue.value_16.ReplicaNumber =
                    lpNdsSrcObject->NdsValue.value_16.ReplicaNumber;

    Count =  lpNdsSrcObject->NdsValue.value_16.Count;

    lpNdsDestObject->NdsValue.value_16.Count =  Count;

    lpNdsDestASN1_12 = (LPNDS_ASN1_TYPE_12)AllocADsMem(
                             Count * sizeof(NDS_ASN1_TYPE_12)
                             );
    if (!lpNdsDestASN1_12) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints = lpNdsDestASN1_12;


    lpNdsSrcASN1_12 = lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints;

    for ( iter = 0; iter < Count; iter++ )
    {

        (lpNdsDestASN1_12 + iter)->AddressType =
                    (lpNdsSrcASN1_12 + iter)->AddressType;

        AddressLength = (lpNdsSrcASN1_12 + iter)->AddressLength;

        if (AddressLength) {
            Address = (LPBYTE)AllocADsMem(AddressLength);
            if (!Address) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            memcpy(
                Address,
                (lpNdsSrcASN1_12 + iter)->Address,
                AddressLength
                );

            (lpNdsDestASN1_12 + iter)->AddressLength = AddressLength;
            (lpNdsDestASN1_12 + iter)->Address = Address;
            (lpNdsDestASN1_12 + iter)->AddressType = (lpNdsSrcASN1_12 + iter)->AddressType;
        }else{
            (lpNdsDestASN1_12 + iter)->AddressLength = AddressLength;
            (lpNdsDestASN1_12 + iter)->Address = NULL;
            (lpNdsDestASN1_12 + iter)->AddressType = 0;
        }

        dwAddrAlloc++;

    }

    RRETURN(hr);

error:

    if (lpNdsDestASN1_12) {

        for (iter=0; iter < dwAddrAlloc; iter++) {
            if ((lpNdsDestASN1_12 + iter)->Address)
                FreeADsMem((lpNdsDestASN1_12 + iter)->Address);
        }

        FreeADsMem(lpNdsDestASN1_12);
    }

    if (lpNdsDestObject->NdsValue.value_16.ServerName)
        FreeADsStr(lpNdsDestObject->NdsValue.value_16.ServerName);

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;
    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_17.Privileges =
                    lpNdsSrcObject->NdsValue.value_17.Privileges;

    lpNdsDestObject->NdsValue.value_17.ProtectedAttrName =
                    (LPWSTR)AllocADsStr(
                                lpNdsSrcObject->NdsValue.value_17.ProtectedAttrName
                                );
    if ((!lpNdsDestObject->NdsValue.value_17.ProtectedAttrName) &&
        (lpNdsSrcObject->NdsValue.value_17.ProtectedAttrName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_17.SubjectName =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_17.SubjectName
                            );
    if ((!lpNdsDestObject->NdsValue.value_17.SubjectName) &&
        (lpNdsSrcObject->NdsValue.value_17.SubjectName)) {
        hr = E_OUTOFMEMORY;
    }
                            

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_18.PostalAddress[0] =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_18.PostalAddress[0]
                            );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[0]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[0])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[1] =
                 (LPWSTR)AllocADsStr(
                             lpNdsSrcObject->NdsValue.value_18.PostalAddress[1]
                             );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[1]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[1])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[2] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[2]
                    );

    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[2]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[2])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[3] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[3]
                    );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[3]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[3])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[4] =
        (LPWSTR)AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_18.PostalAddress[4]
                    );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[4]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[4])) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_18.PostalAddress[5] =
                (LPWSTR)AllocADsStr(
                            lpNdsSrcObject->NdsValue.value_18.PostalAddress[5]
                            );
    if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[5]) &&
        (lpNdsSrcObject->NdsValue.value_18.PostalAddress[5])) {
        hr = E_OUTOFMEMORY;
    }



    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_19.WholeSeconds =
            lpNdsSrcObject->NdsValue.value_19.WholeSeconds;

    lpNdsDestObject->NdsValue.value_19.EventID =
            lpNdsSrcObject->NdsValue.value_19.EventID;

    RRETURN(hr);
}


HRESULT
NdsTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_20.ClassName =
        AllocADsStr(lpNdsSrcObject->NdsValue.value_20.ClassName);
    if ((!lpNdsDestObject->NdsValue.value_20.ClassName) &&
        (lpNdsSrcObject->NdsValue.value_20.ClassName)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;
   
    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    Length = lpNdsSrcObject->NdsValue.value_21.Length;

    if (Length) {
        pBuffer = (LPBYTE)AllocADsMem(Length);
        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(
            pBuffer,
            lpNdsSrcObject->NdsValue.value_21.Data,
            Length
            );

        lpNdsDestObject->NdsValue.value_21.Length = Length;
        lpNdsDestObject->NdsValue.value_21.Data = pBuffer;
    }else{
        lpNdsDestObject->NdsValue.value_21.Length = 0;
        lpNdsDestObject->NdsValue.value_21.Data = NULL;
    }

error:

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_22.Counter =
        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_23.RemoteID =
        lpNdsSrcObject->NdsValue.value_23.RemoteID;

    lpNdsDestObject->NdsValue.value_23.ObjectName =
        AllocADsStr(
            lpNdsSrcObject->NdsValue.value_23.ObjectName
            );
    if ((!lpNdsDestObject->NdsValue.value_23.ObjectName) &&
        (lpNdsSrcObject->NdsValue.value_23.ObjectName)) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_24.Time =
        lpNdsSrcObject->NdsValue.value_24.Time;

    RRETURN(hr);

}

HRESULT
NdsTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_25.ObjectName =
                AllocADsStr(
                    lpNdsSrcObject->NdsValue.value_25.ObjectName
                    );
    if ((!lpNdsDestObject->NdsValue.value_25.ObjectName) &&
        (lpNdsSrcObject->NdsValue.value_25.ObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_25.Level =
            lpNdsSrcObject->NdsValue.value_25.Level;

    lpNdsDestObject->NdsValue.value_25.Interval =
            lpNdsSrcObject->NdsValue.value_25.Interval;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_26.ObjectName =
            AllocADsStr(lpNdsSrcObject->NdsValue.value_26.ObjectName);
    if ((!lpNdsDestObject->NdsValue.value_26.ObjectName) &&
        (lpNdsSrcObject->NdsValue.value_26.ObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpNdsDestObject->NdsValue.value_26.Amount =
            lpNdsSrcObject->NdsValue.value_26.Amount;

    RRETURN(hr);
}

HRESULT
NdsTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = lpNdsSrcObject->NdsType;

    lpNdsDestObject->NdsValue.value_27.Interval =
            lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 2:
        hr = NdsTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 3:
        hr = NdsTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 4:
        hr = NdsTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 5:
        hr = NdsTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 6:
        hr = NdsTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 7:
        hr = NdsTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 8:
        hr = NdsTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 9:
        hr = NdsTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 10:
        hr = NdsTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 11:
        hr = NdsTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 12:
        hr = NdsTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 13:
        hr = NdsTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 14:
        hr = NdsTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 15:
        hr = NdsTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 16:
        hr = NdsTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;


    case 17:
        hr = NdsTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 18:
        hr = NdsTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 19:
        hr = NdsTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 20:
        hr = NdsTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 21:
        hr = NdsTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 22:
        hr = NdsTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 23:
        hr = NdsTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 24:
        hr = NdsTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 25:
        hr = NdsTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 26:
        hr = NdsTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    case 27:
        hr = NdsTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
NdsTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;

    pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

    if (!pNdsDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NdsTypeCopy(pNdsSrcObjects + i, pNdsDestObjects + i);
     }

     *ppNdsDestObjects = pNdsDestObjects;

     RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ndsres.h ===
#define NDS_PROVIDER_ID    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\nds2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndscopy.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//
//  The following conversions are not supported
//
//  NDS_ASN1_TYPE_1
//
//  NDS_ASN1_TYPE_2
//
//  NDS_ASN1_TYPE_3
//
//  NDS_ASN1_TYPE_4
//
//  NDS_ASN1_TYPE_5
//
//  NDS_ASN1_TYPE_6     
//
//  NDS_ASN1_TYPE_7
//
//  NDS_ASN1_TYPE_8
//
//  NDS_ASN1_TYPE_9     
//
//  NDS_ASN1_TYPE_10
//
//  NDS_ASN1_TYPE_11    
//
//  NDS_ASN1_TYPE_12    
//
//  NDS_ASN1_TYPE_13    
//
//  NDS_ASN1_TYPE_14
//
//  NDS_ASN1_TYPE_15    
//
//  NDS_ASN1_TYPE_16    
//
//  NDS_ASN1_TYPE_17    
//
//  NDS_ASN1_TYPE_18    
//
//  NDS_ASN1_TYPE_19    
//
//  NDS_ASN1_TYPE_20
//
//  NDS_ASN1_TYPE_21    
//
//  NDS_ASN1_TYPE_22
//
//  NDS_ASN1_TYPE_23    
//
//  NDS_ASN1_TYPE_24
//
//  NDS_ASN1_TYPE_25    
//
//  NDS_ASN1_TYPE_26    
//
//  NDS_ASN1_TYPE_27
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId1(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId2(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId3(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    VariantInit(lpVarDestObject);
    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
            lpNdsSrcObject->NdsValue.value_1.DNString,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId4(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
               lpNdsSrcObject->NdsValue.value_1.DNString,
               &(lpVarDestObject->bstrVal)
               );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId5(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
               lpNdsSrcObject->NdsValue.value_1.DNString,
               &(lpVarDestObject->bstrVal)
               );


    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId6(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    long i;
    BSTR bstrAddress;
    DWORD cElements = 0;
    IADsCaseIgnoreList* pCaseIgnoreList = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    struct _NDS_CI_LIST *pCurrent = NULL;
    VARIANT varElement;

    hr = CCaseIgnoreList::CreateCaseIgnoreList(
                IID_IADsCaseIgnoreList,
                (void **)&pCaseIgnoreList
                );
    BAIL_ON_FAILURE(hr);

    pCurrent = &(lpNdsSrcObject->NdsValue.value_6);
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = &(lpNdsSrcObject->NdsValue.value_6);
    for ( i = 0; i < (long)cElements; i++ ) {
        VariantInit(&varElement);
        varElement.vt = VT_BSTR;
        hr = ADsAllocString(
                pCurrent->String,
                &varElement.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &varElement);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
        VariantClear(&varElement);
    }

    VariantInit(&VarDestObject);
    V_VT(&VarDestObject) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&VarDestObject) = aList;

    hr = pCaseIgnoreList->put_CaseIgnoreList(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);
    aList = NULL;

    hr = pCaseIgnoreList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release(); 
    }
    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId7(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BOOL;

    lpVarDestObject->boolVal =
                        (lpNdsSrcObject->NdsValue.value_7.Boolean)?
                        VARIANT_TRUE: VARIANT_FALSE;

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId8(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;


    lpVarDestObject->lVal =
                        lpNdsSrcObject->NdsValue.value_8.Integer;

    RRETURN(hr);

}

HRESULT
NdsTypeToVarTypeCopyNDSSynId9(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    VariantInit(lpVarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_9.Length,
                lpNdsSrcObject->NdsValue.value_9.OctetString,
                lpVarDestObject);
    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId10(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
              lpNdsSrcObject->NdsValue.value_10.TelephoneNumber,
              &(lpVarDestObject->bstrVal)
              );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId11(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    IADsFaxNumber * pFaxNumber= NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VariantInit(lpVarDestObject);

    hr = CFaxNumber::CreateFaxNumber(
                IID_IADsFaxNumber,
                (void **)&pFaxNumber
                );
    BAIL_ON_FAILURE(hr);

    hr = pFaxNumber->put_TelephoneNumber(lpNdsSrcObject->NdsValue.value_11.TelephoneNumber);
    BAIL_ON_FAILURE(hr);

    VariantInit(&VarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_11.NumberOfBits,
                lpNdsSrcObject->NdsValue.value_11.Parameters,
                &VarDestObject);
    BAIL_ON_FAILURE(hr);
    hr = pFaxNumber->put_Parameters(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);

    hr = pFaxNumber->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pFaxNumber) {
        pFaxNumber->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId12(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsNetAddress * pNetAddress = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT VarDestObject;

    VariantInit(lpVarDestObject);

    hr = CNetAddress::CreateNetAddress(
                IID_IADsNetAddress,
                (void **)&pNetAddress
                );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->put_AddressType(lpNdsSrcObject->NdsValue.value_12.AddressType);
    BAIL_ON_FAILURE(hr);

    VariantInit(&VarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_12.AddressLength,
                lpNdsSrcObject->NdsValue.value_12.Address,
                &VarDestObject);
    BAIL_ON_FAILURE(hr);
    hr = pNetAddress->put_Address(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);

    hr = pNetAddress->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pNetAddress) {
        pNetAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId13(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    struct _NDS_OCTET_LIST *pCurrent = NULL;
    DWORD cElements = 0;
    IADsOctetList* pOctetList = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VARIANT VarElement;

    hr = COctetList::CreateOctetList(
                IID_IADsOctetList,
                (void **)&pOctetList
                );
    BAIL_ON_FAILURE(hr);

    pCurrent = &(lpNdsSrcObject->NdsValue.value_13);
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = &(lpNdsSrcObject->NdsValue.value_13);
    for ( i = 0; i < (long)cElements; i++ ) {
        VariantInit(&VarElement);
        hr = BinaryToVariant(
                    pCurrent->Length,
                    pCurrent->Data,
                    &VarElement);
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &VarElement);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
    }

    VariantInit(&VarDestObject);
    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pOctetList->put_OctetList(VarDestObject);
    BAIL_ON_FAILURE(hr);
    VariantClear(&VarDestObject);
    aList = NULL;

    hr = pOctetList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if (pOctetList) {
        pOctetList->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId14(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    IADsEmail * pEmail= NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VariantInit(lpVarDestObject);

    hr = CEmail::CreateEmail(
                IID_IADsEmail,
                (void **)&pEmail
                );
    BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Address(lpNdsSrcObject->NdsValue.value_14.Address);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Type(lpNdsSrcObject->NdsValue.value_14.Type);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pEmail) {
        pEmail->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId15(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsPath * pPath = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    VariantInit(lpVarDestObject);

    hr = CPath::CreatePath(
                IID_IADsPath,
                (void **)&pPath
                );
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_Type(lpNdsSrcObject->NdsValue.value_15.Type);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_VolumeName(lpNdsSrcObject->NdsValue.value_15.VolumeName);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_Path(lpNdsSrcObject->NdsValue.value_15.Path);
    BAIL_ON_FAILURE(hr);

    hr = pPath->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pPath) {
        pPath->Release();
    }

    RRETURN(hr);
}



HRESULT
NdsTypeToVarTypeCopyNDSSynId16(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsReplicaPointer * pReplicaPointer = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    LPWSTR ServerName = NULL;
    DWORD  ReplicaType = 0;
    DWORD  ReplicaNumber = 0;
    DWORD  Count = 0;
    NDSOBJECT object;
    VARIANT varDestObject;

    VariantInit(lpVarDestObject);

    hr = CReplicaPointer::CreateReplicaPointer(
                IID_IADsReplicaPointer,
                (void **)&pReplicaPointer
                );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ServerName(lpNdsSrcObject->NdsValue.value_16.ServerName);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaType(lpNdsSrcObject->NdsValue.value_16.ReplicaType);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaNumber(lpNdsSrcObject->NdsValue.value_16.ReplicaNumber);
    BAIL_ON_FAILURE(hr);

    if (lpNdsSrcObject->NdsValue.value_16.Count > 0) {
        //
        //         We only support the retrieval of 1 ReplicaAddressHints in the 
        //         ReplicaPointer. Supporting more than 1 requires the support
        //         of marshalling an array variant which is more complex. 
        //         Judging that there is no real usage of this interface since
        //         the Replica Pointer is for NDS internal use only. We have
        //         decided that we'll postpone this to post W2K and will fix it
        //         only if there is a need.
        //      
        hr = pReplicaPointer->put_Count(1);
        BAIL_ON_FAILURE(hr);
    
        VariantInit(&varDestObject);
        memcpy(&object.NdsValue.value_12,
               lpNdsSrcObject->NdsValue.value_16.ReplicaAddressHints,
               sizeof(NDS_ASN1_TYPE_12));
        hr = NdsTypeToVarTypeCopyNDSSynId12(
                                &object,
                                &varDestObject
                                );
        BAIL_ON_FAILURE(hr);
        hr = pReplicaPointer->put_ReplicaAddressHints(varDestObject);
        BAIL_ON_FAILURE(hr);
        VariantClear(&varDestObject);
    }

    hr = pReplicaPointer->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pReplicaPointer) {
        pReplicaPointer->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId17(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsAcl * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(lpNdsSrcObject->NdsValue.value_17.SubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(lpNdsSrcObject->NdsValue.value_17.ProtectedAttrName);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(lpNdsSrcObject->NdsValue.value_17.Privileges);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId18(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress;
    IADsPostalAddress* pPostalAddress = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT VarDestObject;
    VARIANT varElement;
    VariantInit(&VarDestObject);

    hr = CPostalAddress::CreatePostalAddress(
                IID_IADsPostalAddress,
                (void **)&pPostalAddress
                );
    BAIL_ON_FAILURE(hr);

    aBound.lLbound = 0;
    aBound.cElements = 6;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) 6; i++ ) {
        VariantInit(&varElement);
        varElement.vt = VT_BSTR;
        
        hr = ADsAllocString(
                lpNdsSrcObject->NdsValue.value_18.PostalAddress[i],
                &varElement.bstrVal
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &varElement);
        BAIL_ON_FAILURE(hr);
        VariantClear(&varElement);
    }

    V_VT(&VarDestObject) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&VarDestObject) = aList;

    hr = pPostalAddress->put_PostalAddress(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);


    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;


error:

    if (aList) 
        SafeArrayDestroy(aList); 

    if (pPostalAddress) {
        pPostalAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId19(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsTimestamp * pTime = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CTimestamp::CreateTimestamp(
                IID_IADsTimestamp,
                (void **)&pTime
                );
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_WholeSeconds(lpNdsSrcObject->NdsValue.value_19.WholeSeconds);
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_EventID(lpNdsSrcObject->NdsValue.value_19.EventID);
    BAIL_ON_FAILURE(hr);

    hr = pTime->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pTime) {
        pTime->Release();
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyNDSSynId20(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpNdsSrcObject->NdsValue.value_20.ClassName,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId21(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    VariantInit(lpVarDestObject);
    hr = BinaryToVariant(
                lpNdsSrcObject->NdsValue.value_21.Length,
                lpNdsSrcObject->NdsValue.value_21.Data,
                lpVarDestObject);

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId22(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )

{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal =
        lpNdsSrcObject->NdsValue.value_22.Counter;

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId23(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsBackLink * pBackLink = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CBackLink::CreateBackLink(
                IID_IADsBackLink,
                (void **)&pBackLink
                );
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_ObjectName(lpNdsSrcObject->NdsValue.value_23.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_RemoteID(lpNdsSrcObject->NdsValue.value_23.RemoteID);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pBackLink) {
        pBackLink->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId24(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertDWORDtoDATE(
                lpNdsSrcObject->NdsValue.value_24.Time,
                &(lpVarDestObject->date),
                TRUE
                );

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId25(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsTypedName * pTypedName = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CTypedName::CreateTypedName(
                IID_IADsTypedName,
                (void **)&pTypedName
                );
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_ObjectName(lpNdsSrcObject->NdsValue.value_25.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Level(lpNdsSrcObject->NdsValue.value_25.Level);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Interval(lpNdsSrcObject->NdsValue.value_25.Interval);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pTypedName) {
        pTypedName->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId26(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    IADsHold * pHold = NULL;
    IDispatch * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = CHold::CreateHold(
                IID_IADsHold,
                (void **)&pHold
                );
    BAIL_ON_FAILURE(hr);

    hr = pHold->put_ObjectName(lpNdsSrcObject->NdsValue.value_26.ObjectName);
    BAIL_ON_FAILURE(hr);

    hr = pHold->put_Amount(lpNdsSrcObject->NdsValue.value_26.Amount);
    BAIL_ON_FAILURE(hr);

    hr = pHold->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    VariantInit(lpVarDestObject);
    V_VT(lpVarDestObject) = VT_DISPATCH;
    V_DISPATCH(lpVarDestObject) =  pDispatch;

error:
    if (pHold) {
        pHold->Release();
    }

    RRETURN(hr);
}

HRESULT
NdsTypeToVarTypeCopyNDSSynId27(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )

{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal =
            lpNdsSrcObject->NdsValue.value_27.Interval;

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopy(
    PNDSOBJECT lpNdsSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsSrcObject->NdsType) {
    case 1:
        hr = NdsTypeToVarTypeCopyNDSSynId1(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 2:
        hr = NdsTypeToVarTypeCopyNDSSynId2(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 3:
        hr = NdsTypeToVarTypeCopyNDSSynId3(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 4:
        hr = NdsTypeToVarTypeCopyNDSSynId4(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 5:
        hr = NdsTypeToVarTypeCopyNDSSynId5(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 6:
        hr = NdsTypeToVarTypeCopyNDSSynId6(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 7:
        hr = NdsTypeToVarTypeCopyNDSSynId7(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 8:
        hr = NdsTypeToVarTypeCopyNDSSynId8(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 9:
        hr = NdsTypeToVarTypeCopyNDSSynId9(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 10:
        hr = NdsTypeToVarTypeCopyNDSSynId10(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 11:
        hr = NdsTypeToVarTypeCopyNDSSynId11(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 12:
        hr = NdsTypeToVarTypeCopyNDSSynId12(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 13:
        hr = NdsTypeToVarTypeCopyNDSSynId13(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 14:
        hr = NdsTypeToVarTypeCopyNDSSynId14(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 15:
        hr = NdsTypeToVarTypeCopyNDSSynId15(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 16:
        hr = NdsTypeToVarTypeCopyNDSSynId16(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;


    case 17:
        hr = NdsTypeToVarTypeCopyNDSSynId17(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 18:
        hr = NdsTypeToVarTypeCopyNDSSynId18(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 19:
        hr = NdsTypeToVarTypeCopyNDSSynId19(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 20:
        hr = NdsTypeToVarTypeCopyNDSSynId20(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 21:
        hr = NdsTypeToVarTypeCopyNDSSynId21(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 22:
        hr = NdsTypeToVarTypeCopyNDSSynId22(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 23:
        hr = NdsTypeToVarTypeCopyNDSSynId23(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 24:
        hr = NdsTypeToVarTypeCopyNDSSynId24(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 25:
        hr = NdsTypeToVarTypeCopyNDSSynId25(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;                                    

    case 26:
        hr = NdsTypeToVarTypeCopyNDSSynId26(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    case 27:
        hr = NdsTypeToVarTypeCopyNDSSynId27(
                lpNdsSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NdsTypeToVarTypeCopyConstruct(
    LPNDSOBJECT pNdsSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects,
    BOOLEAN bReturnArrayAlways
    )
{
    long i = 0;
    HRESULT hr = S_OK;
    VARIANT VarDestObjectsTemp;
    SAFEARRAY *aList = NULL;
    SAFEARRAY *aListTmp = NULL;

    if ((pNdsSrcObjects->NdsType == 17) || (dwNumObjects > 1) || bReturnArrayAlways) {
    
        VariantInit(pVarDestObjects);
    
        //
        // The following are for handling are multi-value properties
        //
    
        SAFEARRAYBOUND aBound;
    
        aBound.lLbound = 0;
        aBound.cElements = dwNumObjects;
    
        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    
        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        for ( i = 0; i < (long) dwNumObjects; i++ )
        {
            VARIANT v;
    
            VariantInit(&v);
            hr = NdsTypeToVarTypeCopy( pNdsSrcObjects + i,
                                       &v );
            BAIL_ON_FAILURE(hr);
    
            hr = SafeArrayPutElement( aList, &i, &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);
        }
    
        V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pVarDestObjects) = aList;
    
    
        // 
        // If it is an NDS ACL, we will convert it into an 
        // NT Security Descriptor
        //
        if (pNdsSrcObjects->NdsType == 17) {
            hr = ConvertNDSAclVArrayToSecDesVar(pVarDestObjects,
                                                &VarDestObjectsTemp);
            SafeArrayDestroy( aList );
            aList = NULL;
            if (!bReturnArrayAlways) {
                V_VT(pVarDestObjects) = V_VT(&VarDestObjectsTemp);
                V_DISPATCH(pVarDestObjects) = V_DISPATCH(&VarDestObjectsTemp);
            }
            else {
                //
                // Pack SecDescriptor into a one-element array
                //
                SAFEARRAYBOUND aBoundTmp;
                long j = 0;
            
                aBoundTmp.lLbound = 0;
                aBoundTmp.cElements = 1;
            
                aListTmp = SafeArrayCreate( VT_VARIANT, 1, &aBoundTmp);
            
                if ( aListTmp == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
        
                hr = SafeArrayPutElement( aListTmp, &j, &VarDestObjectsTemp);
                BAIL_ON_FAILURE(hr);
            
                V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
                V_ARRAY(pVarDestObjects) = aListTmp;
            }
        }
    }
    else {
        hr  = NdsTypeToVarTypeCopy(
                   pNdsSrcObjects,
                   pVarDestObjects
                   );
    }
    BAIL_ON_FAILURE(hr);
    RRETURN(hr);
error:
 
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    if ( aListTmp ) {
        SafeArrayDestroy( aListTmp );
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ndstypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NDS
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      25-Apr-96   KrishnaG   Cloned off GlennC's ndssntx.h
//                                       to resolve inconsistencies with
//                                       datatypes
//
//----------------------------------------------------------------------------

#ifndef __NDSTYPES_HXX
#define __NDSTYPES_HXX

//
// NDS Distinguished Name
//
// Used in attributes: Alias Object Name, Default Queue, Device,
//                     Group Membership, Higher Privileges, Host Device,
//                     Host Server, Member, Message Server, Operator, Owner,
//                     Profile, Reference, Resource, Role Occupant,
//                     Security Equals, See Also, Server, User, Volume
//
typedef struct
{
    LPWSTR DNString;

} NDS_ASN1_TYPE_1, * LPNDS_ASN1_TYPE_1;

//
// NDS Case Exact String syntax
//
// Used in attribute: Home Directory
//
typedef struct
{
    LPWSTR CaseExactString;

} NDS_ASN1_TYPE_2, * LPNDS_ASN1_TYPE_2;

//
// NDS Case Ignore String syntax
//
// Used in attributes: Cartridge, CN (Common Name), C (Country Name),
//                     Description, Host Resource Name, L (Locality Name),
//                     O (Organization Name), OU (Organizational Unit Name),
//                     Physical Delivery Office Name, Postal Code,
//                     Postal Office Box, Queue Directory, SAP Name,
//                     S (State or Province Name), SA (Street Address),
//                     Supported Services, Supported Typefaces, Surname,
//                     Title, Unknown Base Class, Version
//
typedef struct
{
    LPWSTR CaseIgnoreString;

} NDS_ASN1_TYPE_3, * LPNDS_ASN1_TYPE_3;

//
// NDS Printable String syntax
//
// Used in attributes: Page Description Language, Serial Number
//
typedef struct
{
    LPWSTR PrintableString;

} NDS_ASN1_TYPE_4, * LPNDS_ASN1_TYPE_4;

//
// NDS Numeric String syntax
//
// Used in attributes: Bindery Type
//
typedef struct
{
    LPWSTR NumericString;

} NDS_ASN1_TYPE_5, * LPNDS_ASN1_TYPE_5;

//
// NDS Case Ignore List syntax
//
// Used in attribute: Language
//
typedef struct _NDS_CI_LIST
{
    struct _NDS_CI_LIST * Next;
    LPWSTR            String;

}
NDS_ASN1_TYPE_6, * LPNDS_ASN1_TYPE_6;

//
// NDS Boolean syntax
//
// Used in attributes: Allow Unlimited Credit, Detect Intruder,
//                     Lockout After Detection, Locked By Intruder,
//                     Login Diabled, Password Allow Change, Password Required,
//                     Password Unique Required
//
typedef struct
{
    DWORD Boolean;

} NDS_ASN1_TYPE_7, * LPNDS_ASN1_TYPE_7;

//
// Example: NDS Integer syntax
//
// Used in attributes: Bindery Object Restriction, Convergence, GID (Group ID),
//                     Login Grace Limit, Login Intruder Limit,
//                     Login Maximum Simultaneous, Memory,
//                     Minimum Account Balance, Password Minimum Length, Status,
//                     Supported Connections, UID (User ID)
//
typedef struct
{
    DWORD Integer;

} NDS_ASN1_TYPE_8, * LPNDS_ASN1_TYPE_8;

//
// NDS Octet String syntax
//
// Used in attributes: Athority Revocation, Bindery Property, CA Private Key,
//                     CA Public Key, Certificate Revocation,
//                     Cross Certificate Pair, Login Allowed Time Map,
//                     Passwords Used, Printer Configuration, Private Key,
//                     Public Key
//
typedef struct
{
    DWORD  Length;
    LPBYTE OctetString;

} NDS_ASN1_TYPE_9, * LPNDS_ASN1_TYPE_9;

//
// NDS Telephone Number syntax
//
// Used in attribute: Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;

} NDS_ASN1_TYPE_10, * LPNDS_ASN1_TYPE_10;

//
// NDS Facsimile Telephone Number syntax
//
// Used in attribute: Facsimile Telephone Number
//
typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;

} NDS_ASN1_TYPE_11, * LPNDS_ASN1_TYPE_11;

//
// NDS Network Address syntax
//
// Used in attributes: Login Intruder Address, Network Address,
//                     Network Address Restriction
//
typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} NDS_ASN1_TYPE_12, * LPNDS_ASN1_TYPE_12;

//
// NDS Octet List syntax
//
// Used in attribute: (none)
//

typedef struct _NDS_OCTET_LIST
{
    struct _NDS_OCTET_LIST * Next;
    DWORD  Length;
    BYTE * Data;

}NDS_ASN1_TYPE_13, * LPNDS_ASN1_TYPE_13;

//
// NDS EMail Address syntax
//
// Used in attribute: EMail Address
//
typedef struct
{
    DWORD  Type;
    LPWSTR Address;

} NDS_ASN1_TYPE_14, * LPNDS_ASN1_TYPE_14;

//
// NDS Path syntax
//
// Used in attribute: Path
//
typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} NDS_ASN1_TYPE_15, * LPNDS_ASN1_TYPE_15;

//
// NDS Replica Pointer syntax
//
// Used in attribute: Replica
//
typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    LPNDS_ASN1_TYPE_12 ReplicaAddressHints;

    //
    // Note - This is where GlennC's datatypes and the ADs Nds Datatypes
    // part company. He expects a contiguous buffer of Type 12 structures
    // but the number of Type 12 structures cannot be determined until runtime
    //

    // ReplicaAddressHint is variable and
    // can be calculated by Count * the
    // length of a NDS_ASN1_TYPE_12 ( that is
    // Count * 9).


} NDS_ASN1_TYPE_16, * LPNDS_ASN1_TYPE_16;

//
// NDS Object ACL syntax
//
// Used in attributes: ACL, Inherited ACL
//
typedef struct
{
    LPWSTR ProtectedAttrName;
    LPWSTR SubjectName;
    DWORD  Privileges;

} NDS_ASN1_TYPE_17, * LPNDS_ASN1_TYPE_17;

//
// NDS Postal Address syntax
//
// Used in attribute: Postal Address
//
typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} NDS_ASN1_TYPE_18, * LPNDS_ASN1_TYPE_18;

//
// NDS Timestamp syntax
//
// Used in attribute: Obituary, Partition Creation Time, Received Up To,
//                    Syncronized Up To
//
typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} NDS_ASN1_TYPE_19, * LPNDS_ASN1_TYPE_19;

//
// NDS Class Name syntax
//
// Used in attribute: Object Class
//
typedef struct
{
    LPWSTR ClassName;

} NDS_ASN1_TYPE_20, * LPNDS_ASN1_TYPE_20;

//
// NDS Stream syntax
//
// Used in attribute: Login Script, Print Job Configuration, Printer Control,
//                    Type Creator Map
//
typedef struct
{
    DWORD  Length; // Always zero
    BYTE * Data;

} NDS_ASN1_TYPE_21, * LPNDS_ASN1_TYPE_21;

//
// NDS Count syntax
//
// Used in attributes: Account Balance, Login Grace Remaining,
//                     Login Intruder Attempts
//
typedef struct
{
    DWORD Counter;

} NDS_ASN1_TYPE_22, * LPNDS_ASN1_TYPE_22;

//
// NDS Back Link syntax
//
// Used in attribute: Back Link
//
typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} NDS_ASN1_TYPE_23, * LPNDS_ASN1_TYPE_23;

//
// NDS Time syntax
//
// Used in attributes: Last Login Time, Login Expiration Time,
//                     Login Intruder Rest Time, Login Time,
//                     Low Convergence Reset Time, Password Expiration Time
//
typedef struct
{
    DWORD Time; // (in whole seconds) zero equals 12:00 midnight,
                // January 1, 1970, UTC

} NDS_ASN1_TYPE_24, * LPNDS_ASN1_TYPE_24;

//
// NDS Typed Name syntax
//
// Used in attribute: Notify, Print Server, Printer, Queue
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} NDS_ASN1_TYPE_25, * LPNDS_ASN1_TYPE_25;

//
// NDS Hold syntax
//
// Used in attribute: Server Holds
//
typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} NDS_ASN1_TYPE_26, * LPNDS_ASN1_TYPE_26;

//
// NDS Interval syntax
//
// Used in attribute: High Convergence Syncronization Interval,
//                    Intruder Attempt Reset Interval,
//                    Intruder Lockout Reset Interval,
//                    Low Convergence Syncronization Interval,
//                    Password Expiration Interval
//
typedef struct
{
    DWORD  Interval;

} NDS_ASN1_TYPE_27, * LPNDS_ASN1_TYPE_27;


#endif





typedef struct _ndstype{
    DWORD NdsType;
    union {
        NDS_ASN1_TYPE_1 value_1;
        NDS_ASN1_TYPE_2 value_2;
        NDS_ASN1_TYPE_3 value_3;
        NDS_ASN1_TYPE_4 value_4;
        NDS_ASN1_TYPE_5 value_5;

        NDS_ASN1_TYPE_6 value_6;
        NDS_ASN1_TYPE_7 value_7;
        NDS_ASN1_TYPE_8 value_8;
        NDS_ASN1_TYPE_9 value_9;
        NDS_ASN1_TYPE_10 value_10;


        NDS_ASN1_TYPE_11 value_11;
        NDS_ASN1_TYPE_12 value_12;
        NDS_ASN1_TYPE_13 value_13;
        NDS_ASN1_TYPE_14 value_14;
        NDS_ASN1_TYPE_15 value_15;


        NDS_ASN1_TYPE_16 value_16;
        NDS_ASN1_TYPE_17 value_17;
        NDS_ASN1_TYPE_18 value_18;
        NDS_ASN1_TYPE_19 value_19;
        NDS_ASN1_TYPE_20 value_20;


        NDS_ASN1_TYPE_21 value_21;
        NDS_ASN1_TYPE_22 value_22;
        NDS_ASN1_TYPE_23 value_23;
        NDS_ASN1_TYPE_24 value_24;
        NDS_ASN1_TYPE_25 value_25;

        NDS_ASN1_TYPE_26 value_26;
        NDS_ASN1_TYPE_27 value_27;
    }NdsValue;
}NDSOBJECT, *PNDSOBJECT, *LPNDSOBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ndsufree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Freeright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsufree.cxx
//
//  Contents:
//
//  Functions:
//
//                FreeABC1ToNDSSynId1
//                FreeABC2ToNDSSynId2
//                FreeABC3ToNDSSynId3
//                FreeABC4ToNDSSynId4
//                FreeABC5ToNDSSynId5
//                FreeABC6ToNDSSynId6
//                FreeABC7ToNDSSynId7
//                FreeABC8ToNDSSynId8
//                FreeABC9ToNDSSynId9
//                FreeABC10ToNDSSynId10
//                FreeABC11ToNDSSynId11
//                FreeABC12ToNDSSynId12
//                FreeABC13ToNDSSynId13
//                FreeABC14ToNDSSynId14
//                FreeABC15ToNDSSynId15
//                FreeABC16ToNDSSynId16
//                FreeABC17ToNDSSynId17
//                FreeABC18ToNDSSynId18
//                FreeABC19ToNDSSynId19
//                FreeABC20ToNDSSynId20
//                FreeABC21ToNDSSynId21
//                FreeABC22ToNDSSynId22
//                FreeABC23ToNDSSynId23
//                FreeABC24ToNDSSynId24
//                FreeABC25ToNDSSynId25
//                FreeABC26ToNDSSynId26
//                FreeABC27ToNDSSynId27
//
//  History:      15-Jul-97   FelixW   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"


LPBYTE
FreeNDSSynId1ToNDS1(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;

    if (lpASN1_1->DNString) {
        FreeADsStr(lpASN1_1->DNString);
    }

    lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);

    return(lpByte);

}

LPBYTE
FreeNDSSynId2ToNDS2(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_2 lpASN1_2 = (LPASN1_TYPE_2) lpByte;

    if (lpASN1_2->CaseExactString) {
        FreeADsStr(lpASN1_2->CaseExactString);
    }

    lpByte = (LPBYTE ) lpASN1_2 + sizeof(ASN1_TYPE_2);

    return(lpByte);
}



LPBYTE
FreeNDSSynId3ToNDS3(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_3 lpASN1_3 = (LPASN1_TYPE_3) lpByte;

    if (lpASN1_3->CaseIgnoreString) {
        FreeADsStr(lpASN1_3->CaseIgnoreString);
    }

    lpByte = (LPBYTE ) lpASN1_3 + sizeof(ASN1_TYPE_3);

    return(lpByte);
}

LPBYTE
FreeNDSSynId4ToNDS4(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_4 lpASN1_4 = (LPASN1_TYPE_4) lpByte;

    if (lpASN1_4->PrintableString) {
        FreeADsStr(lpASN1_4->PrintableString);
    }

    lpByte = (LPBYTE ) lpASN1_4 + sizeof(ASN1_TYPE_4);

    return(lpByte);

}


LPBYTE
FreeNDSSynId5ToNDS5(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_5 lpASN1_5 = (LPASN1_TYPE_5) lpByte;

    if (lpASN1_5->NumericString) {
        FreeADsStr(lpASN1_5->NumericString);
    }

    lpByte = (LPBYTE ) lpASN1_5 + sizeof(ASN1_TYPE_5);

    return(lpByte);
}

LPBYTE
FreeNDSSynId6ToNDS6(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;
        LPASN1_TYPE_6 lpASN1_6Last = NULL;

    if (lpASN1_6->String) {
            FreeADsStr(lpASN1_6->String);
    }

        lpASN1_6 = lpASN1_6->Next;
        while (lpASN1_6)
    {
        if (lpASN1_6->String) {
            FreeADsStr(lpASN1_6->String);
        }

                lpASN1_6Last = lpASN1_6;
        lpASN1_6 = (LPASN1_TYPE_6)lpASN1_6->Next;
                FreeADsMem(lpASN1_6Last);
    }

    lpByte = lpByte + sizeof(ASN1_TYPE_6);

    return(lpByte);
}


LPBYTE
FreeNDSSynId7ToNDS7(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_7 lpASN1_7 = (LPASN1_TYPE_7) lpByte;
    lpByte = (LPBYTE ) lpASN1_7 + sizeof(ASN1_TYPE_7);

    return(lpByte);
}


LPBYTE
FreeNDSSynId8ToNDS8(
    LPBYTE lpByte
    )

{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;
    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
FreeNDSSynId9ToNDS9(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;

    if (lpASN1_9->OctetString) {
        FreeADsMem((LPBYTE)lpASN1_9->OctetString);
    }

    lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);

    return(lpByte);
}

LPBYTE
FreeNDSSynId10ToNDS10(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_10 lpASN1_10 = (LPASN1_TYPE_10) lpByte;

    if (lpASN1_10->TelephoneNumber) {
        FreeADsStr(lpASN1_10->TelephoneNumber);
    }

    lpByte = (LPBYTE ) lpASN1_10 + sizeof(ASN1_TYPE_10);

    return(lpByte);
}

LPBYTE
FreeNDSSynId11ToNDS11(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;

    if (lpASN1_11->TelephoneNumber) {
        FreeADsStr(lpASN1_11->TelephoneNumber);
    }

    if (lpASN1_11->Parameters) {
        FreeADsMem(lpASN1_11->Parameters);
    }

    lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);

    return(lpByte);
}

LPBYTE
FreeNDSSynId12ToNDS12(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;

    if (lpASN1_12->Address) {
        FreeADsMem((LPBYTE)lpASN1_12->Address);
    }

    lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);

    return(lpByte);
}

LPBYTE
FreeNDSSynId13ToNDS13(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_13 lpASN1_13 = (LPASN1_TYPE_13) lpByte;
        LPASN1_TYPE_13 lpASN1_13Last = NULL;

    if (lpASN1_13->Data) {
            FreeADsMem(lpASN1_13->Data);
    }

        lpASN1_13 = lpASN1_13->Next;
        while (lpASN1_13)
    {
        if (lpASN1_13->Data) {
            FreeADsMem(lpASN1_13->Data);
        }

                lpASN1_13Last = lpASN1_13;
        lpASN1_13 = (LPASN1_TYPE_13)lpASN1_13->Next;
                FreeADsMem(lpASN1_13Last);
    }

    lpByte = lpByte + sizeof(ASN1_TYPE_13);

    return(lpByte);
}


LPBYTE
FreeNDSSynId14ToNDS14(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;

    if (lpASN1_14->Address) {
        FreeADsStr(lpASN1_14->Address);
    }

    lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);

    return(lpByte);
}


LPBYTE
FreeNDSSynId15ToNDS15(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;

    if (lpASN1_15->VolumeName) {
        FreeADsStr(lpASN1_15->VolumeName);
    }

    if (lpASN1_15->Path) {
        FreeADsStr(lpASN1_15->Path);
    }

    lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);

    return(lpByte);
}

LPBYTE
FreeNDSSynId16ToNDS16(
    LPBYTE lpByte
    )
{

    LPASN1_TYPE_16 lpASN1_16 = (LPASN1_TYPE_16) lpByte;

    if (lpASN1_16->ReplicaAddressHint->Address) {
        FreeADsMem(lpASN1_16->ReplicaAddressHint->Address);
    }

    lpByte = (LPBYTE ) lpASN1_16 + sizeof(ASN1_TYPE_16);
    return(lpByte);
}


LPBYTE
FreeNDSSynId17ToNDS17(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;


    if (lpASN1_17->ProtectedAttrName) {
        FreeADsStr(lpASN1_17->ProtectedAttrName);
    }

    if (lpASN1_17->SubjectName) {
        FreeADsStr(lpASN1_17->SubjectName);
    }

    lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);

    return(lpByte);
}


LPBYTE
FreeNDSSynId18ToNDS18(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;


    if (lpASN1_18->PostalAddress[0]) {
        FreeADsStr(lpASN1_18->PostalAddress[0]);
    }
    if (lpASN1_18->PostalAddress[1]) {
        FreeADsStr(lpASN1_18->PostalAddress[1]);
    }
    if (lpASN1_18->PostalAddress[2]) {
        FreeADsStr(lpASN1_18->PostalAddress[2]);
    }
    if (lpASN1_18->PostalAddress[3]) {
        FreeADsStr(lpASN1_18->PostalAddress[3]);
    }
    if (lpASN1_18->PostalAddress[4]) {
        FreeADsStr(lpASN1_18->PostalAddress[4]);
    }
    if (lpASN1_18->PostalAddress[5]) {
        FreeADsStr(lpASN1_18->PostalAddress[5]);
    }


    lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);


    return(lpByte);
}

LPBYTE
FreeNDSSynId19ToNDS19(
    LPBYTE lpByte
    )
{

    LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;

    lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);

    return(lpByte);
}

LPBYTE
FreeNDSSynId20ToNDS20(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_20 lpASN1_20 = (LPASN1_TYPE_20) lpByte;

    if (lpASN1_20->ClassName) {
        FreeADsStr(lpASN1_20->ClassName);
    }

    lpByte = (LPBYTE ) lpASN1_20 + sizeof(ASN1_TYPE_20);

    return(lpByte);
}


LPBYTE
FreeNDSSynId21ToNDS21(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;

    if (lpASN1_21->Data) {
        FreeADsMem((LPBYTE)lpASN1_21->Data);
    }
    
    lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);

    return(lpByte);

}



LPBYTE
FreeNDSSynId22ToNDS22(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_22 lpASN1_22 = (LPASN1_TYPE_22) lpByte;

    lpByte = (LPBYTE ) lpASN1_22 + sizeof(ASN1_TYPE_22);

    return(lpByte);
}

LPBYTE
FreeNDSSynId23ToNDS23(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;

    if (lpASN1_23->ObjectName) {
        FreeADsStr(lpASN1_23->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);

    return(lpByte);
}

LPBYTE
FreeNDSSynId24ToNDS24(
    LPBYTE lpByte

    )
{
    LPASN1_TYPE_24 lpASN1_24 = (LPASN1_TYPE_24) lpByte;

    lpByte = (LPBYTE ) lpASN1_24 + sizeof(ASN1_TYPE_24);

    return(lpByte);
}



LPBYTE
FreeNDSSynId25ToNDS25(
    LPBYTE lpByte
    )

{
    LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;

    if (lpASN1_25->ObjectName) {
        FreeADsStr(lpASN1_25->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);

    return(lpByte);
}


LPBYTE
FreeNDSSynId26ToNDS26(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;


    if (lpASN1_26->ObjectName) {
        FreeADsStr(lpASN1_26->ObjectName);
    }

    lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);

    return(lpByte);
}


LPBYTE
FreeNDSSynId27ToNDS27(
    LPBYTE lpByte
    )
{
    LPASN1_TYPE_27 lpASN1_27 = (LPASN1_TYPE_27) lpByte;

    lpByte = (LPBYTE ) lpASN1_27 + sizeof(ASN1_TYPE_27);

    return(lpByte);
}


LPBYTE
FreeNDSSynIdToNDS(
    DWORD dwSyntaxId,
    LPBYTE lpByte
    )
{
    switch (dwSyntaxId) {
    case 1:
        lpByte = FreeNDSSynId1ToNDS1(
                        lpByte
                         );
        break;

    case 2:
        lpByte = FreeNDSSynId2ToNDS2(
                        lpByte
                         );
        break;

    case 3:
        lpByte = FreeNDSSynId3ToNDS3(
                        lpByte
                         );
        break;

    case 4:
        lpByte = FreeNDSSynId4ToNDS4(
                        lpByte
                         );
        break;

    case 5:
        lpByte = FreeNDSSynId5ToNDS5(
                        lpByte
                         );
        break;

    case 6:
        lpByte = FreeNDSSynId6ToNDS6(
                        lpByte
                         );
        break;

    case 7:
        lpByte = FreeNDSSynId7ToNDS7(
                        lpByte
                         );
        break;

    case 8:
        lpByte = FreeNDSSynId8ToNDS8(
                        lpByte
                         );
        break;


    case 9:
        lpByte = FreeNDSSynId9ToNDS9(
                        lpByte
                         );
        break;

    case 10:
        lpByte = FreeNDSSynId10ToNDS10(
                        lpByte
                         );
        break;

    case 11:
        lpByte = FreeNDSSynId11ToNDS11(
                        lpByte
                         );
        break;

    case 12:
        lpByte = FreeNDSSynId12ToNDS12(
                        lpByte
                         );
        break;

    case 13:
        lpByte = FreeNDSSynId13ToNDS13(
                        lpByte
                         );
        break;

    case 14:
        lpByte = FreeNDSSynId14ToNDS14(
                        lpByte
                         );
        break;

    case 15:
        lpByte = FreeNDSSynId15ToNDS15(
                        lpByte
                         );
        break;

    case 16:
        lpByte = FreeNDSSynId16ToNDS16(
                        lpByte
                         );
        break;


    case 17:
        lpByte = FreeNDSSynId17ToNDS17(
                        lpByte
                         );
        break;

    case 18:
        lpByte = FreeNDSSynId18ToNDS18(
                        lpByte
                         );
        break;

    case 19:
        lpByte = FreeNDSSynId19ToNDS19(
                        lpByte
                         );
        break;

    case 20:
        lpByte = FreeNDSSynId20ToNDS20(
                        lpByte
                         );
        break;


    case 21:
        lpByte = FreeNDSSynId21ToNDS21(
                        lpByte
                         );
        break;

    case 22:
        lpByte = FreeNDSSynId22ToNDS22(
                        lpByte
                         );
        break;

    case 23:
        lpByte = FreeNDSSynId23ToNDS23(
                        lpByte
                         );
        break;

    case 24:
        lpByte = FreeNDSSynId24ToNDS24(
                        lpByte
                         );
        break;

    case 25:
        lpByte = FreeNDSSynId25ToNDS25(
                        lpByte
                         );
        break;

    case 26:
        lpByte = FreeNDSSynId26ToNDS26(
                        lpByte
                         );
        break;

    case 27:
        lpByte = FreeNDSSynId27ToNDS27(
                        lpByte
                         );
        break;


    default:
        break;

    }

    return(lpByte);
}


HRESULT
FreeMarshallMemory(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    DWORD  i = 0;


    for (i = 0; i < dwNumValues; i++) {

        lpValue = FreeNDSSynIdToNDS(
                         dwSyntaxId,
                         lpValue
                         );

    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ndsfree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsfree.cxx
//
//  Contents:   NDS Object Free Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//              Object Types 6, 13, 16, and 21 are flaky - pay extra attn.
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects free code
//


HRESULT
NdsTypeFreeNDSSynId1(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId2(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId3(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);
    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId4(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId5(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_1.DNString);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId6(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_6 pStart = NULL;
    LPNDS_ASN1_TYPE_6 pTemp = NULL;

    FreeADsStr(lpNdsDestObject->NdsValue.value_6.String);

    pStart = lpNdsDestObject->NdsValue.value_6.Next;


    while (pStart){
        pTemp = pStart;

        pStart = pTemp->Next;

        FreeADsStr(pTemp->String);
        FreeADsMem(pTemp);
    }

    RRETURN(hr);
}





HRESULT
NdsTypeFreeNDSSynId7(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do Nothing - Boolean
    //
    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId8(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing - Integer
    //

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId9(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;


    if (lpNdsDestObject->NdsValue.value_9.OctetString) {

        FreeADsMem(
            lpNdsDestObject->NdsValue.value_9.OctetString
            );
    }

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId10(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_10.TelephoneNumber);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId11(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_11.TelephoneNumber);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId12(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if (lpNdsDestObject->NdsValue.value_12.Address) {

        FreeADsMem(lpNdsDestObject->NdsValue.value_12.Address);
    }

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId13(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    LPNDS_ASN1_TYPE_13 pStart = NULL;
    LPNDS_ASN1_TYPE_13 pTemp = NULL;

    if (lpNdsDestObject->NdsValue.value_13.Data) {
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);
    }


    pStart = lpNdsDestObject->NdsValue.value_13.Next;


    while (pStart){
        pTemp = pStart;

        pStart = pTemp->Next;

        if (pTemp->Data) {
            FreeADsMem(pTemp->Data);
        }
        FreeADsMem(pTemp);
    }

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId14(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_14.Address);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId15(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_15.VolumeName);

    FreeADsStr(lpNdsDestObject->NdsValue.value_15.Path);

    RRETURN(hr);
}



HRESULT
NdsTypeFreeNDSSynId16(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPNDS_ASN1_TYPE_12 lpNdsTempASN1_12 = NULL;


    FreeADsStr(lpNdsDestObject->NdsValue.value_16.ServerName);

    dwCount =  lpNdsDestObject->NdsValue.value_16.Count;


    lpNdsTempASN1_12 = lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints;


    for (i = 0; i < dwCount; i++) {

         if ((lpNdsTempASN1_12 + i)->Address) {

             FreeADsMem((lpNdsTempASN1_12 + i)->Address);
         }
    }

    FreeADsMem(lpNdsTempASN1_12);

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId17(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_17.ProtectedAttrName);

    FreeADsStr(lpNdsDestObject->NdsValue.value_17.SubjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId18(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;

    for (i = 0; i < 6; i++) {
        FreeADsStr(lpNdsDestObject->NdsValue.value_18.PostalAddress[i]);
    }

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId19(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing for 19
    //

    RRETURN(hr);
}


HRESULT
NdsTypeFreeNDSSynId20(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_20.ClassName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId21(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if (lpNdsDestObject->NdsValue.value_21.Data) {

        FreeADsMem(
            lpNdsDestObject->NdsValue.value_21.Data
            );
    }

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId22(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    //
    // DoNothing for 22
    //

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId23(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_23.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId24(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    //
    // Do nothing
    //

    RRETURN(hr);

}

HRESULT
NdsTypeFreeNDSSynId25(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_25.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId26(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpNdsDestObject->NdsValue.value_26.ObjectName);

    RRETURN(hr);
}

HRESULT
NdsTypeFreeNDSSynId27(
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    //
    // Nothing to do for this one
    //

    RRETURN(hr);
}


HRESULT
NdsTypeClear(
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNdsDestObject->NdsType) {
    case 1:
        hr = NdsTypeFreeNDSSynId1(
                lpNdsDestObject
                );
        break;

    case 2:
        hr = NdsTypeFreeNDSSynId2(
                lpNdsDestObject
                );
        break;


    case 3:
        hr = NdsTypeFreeNDSSynId3(
                lpNdsDestObject
                );
        break;

    case 4:
        hr = NdsTypeFreeNDSSynId4(
                lpNdsDestObject
                );
        break;

    case 5:
        hr = NdsTypeFreeNDSSynId5(
                lpNdsDestObject
                );
        break;

    case 6:
        hr = NdsTypeFreeNDSSynId6(
                lpNdsDestObject
                );
        break;

    case 7:
        hr = NdsTypeFreeNDSSynId7(
                lpNdsDestObject
                );
        break;

    case 8:
        hr = NdsTypeFreeNDSSynId8(
                lpNdsDestObject
                );
        break;


    case 9:
        hr = NdsTypeFreeNDSSynId9(
                lpNdsDestObject
                );
        break;

    case 10:
        hr = NdsTypeFreeNDSSynId10(
                lpNdsDestObject
                );
        break;

    case 11:
        hr = NdsTypeFreeNDSSynId11(
                lpNdsDestObject
                );
        break;

    case 12:
        hr = NdsTypeFreeNDSSynId12(
                lpNdsDestObject
                );
        break;


    case 13:
        hr = NdsTypeFreeNDSSynId13(
                lpNdsDestObject
                );
        break;

    case 14:
        hr = NdsTypeFreeNDSSynId14(
                lpNdsDestObject
                );
        break;

    case 15:
        hr = NdsTypeFreeNDSSynId15(
                lpNdsDestObject
                );
        break;

    case 16:
        hr = NdsTypeFreeNDSSynId16(
                lpNdsDestObject
                );
        break;


    case 17:
        hr = NdsTypeFreeNDSSynId17(
                lpNdsDestObject
                );
        break;

    case 18:
        hr = NdsTypeFreeNDSSynId18(
                lpNdsDestObject
                );
        break;

    case 19:
        hr = NdsTypeFreeNDSSynId19(
                lpNdsDestObject
                );
        break;

    case 20:
        hr = NdsTypeFreeNDSSynId20(
                lpNdsDestObject
                );
        break;

    case 21:
        hr = NdsTypeFreeNDSSynId21(
                lpNdsDestObject
                );
        break;

    case 22:
        hr = NdsTypeFreeNDSSynId22(
                lpNdsDestObject
                );
        break;

    case 23:
        hr = NdsTypeFreeNDSSynId23(
                lpNdsDestObject
                );
        break;

    case 24:
        hr = NdsTypeFreeNDSSynId24(
                lpNdsDestObject
                );
        break;

    case 25:
        hr = NdsTypeFreeNDSSynId25(
                lpNdsDestObject
                );
        break;

    case 26:
        hr = NdsTypeFreeNDSSynId26(
                lpNdsDestObject
                );
        break;

    case 27:
        hr = NdsTypeFreeNDSSynId27(
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



void
NdsTypeFreeNdsObjects(
    PNDSOBJECT pNdsObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         NdsTypeClear(pNdsObject + i);
    }

    FreeADsMem(pNdsObject);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ndsurshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//                CopyABC1ToNDSSynId1
//                CopyABC2ToNDSSynId2
//                CopyABC3ToNDSSynId3
//                CopyABC4ToNDSSynId4
//                CopyABC5ToNDSSynId5
//                CopyABC6ToNDSSynId6
//                CopyABC7ToNDSSynId7
//                CopyABC8ToNDSSynId8
//                CopyABC9ToNDSSynId9
//                CopyABC10ToNDSSynId10
//                CopyABC11ToNDSSynId11
//                CopyABC12ToNDSSynId12
//                CopyABC13ToNDSSynId13
//                CopyABC14ToNDSSynId14
//                CopyABC15ToNDSSynId15
//                CopyABC16ToNDSSynId16
//                CopyABC17ToNDSSynId17
//                CopyABC18ToNDSSynId18
//                CopyABC19ToNDSSynId19
//                CopyABC20ToNDSSynId20
//                CopyABC21ToNDSSynId21
//                CopyABC22ToNDSSynId22
//                CopyABC23ToNDSSynId23
//                CopyABC24ToNDSSynId24
//                CopyABC25ToNDSSynId25
//                CopyABC26ToNDSSynId26
//                CopyABC27ToNDSSynId27
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//  Warnings:     NDS Data type 6 is not yet supported (no problems just
//                not done!
//
//                NDS Data type 16 need to complete the for loop code
//                NDS Data type 21 is the stream data type some stress.
//----------------------------------------------------------------------------
#include "nds.hxx"




LPBYTE
CopyNDSSynId1ToNDS1(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;

    lpASN1_1->DNString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_1.DNString
                        );

    lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);

    return(lpByte);

}

LPBYTE
CopyNDSSynId2ToNDS2(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_2 lpASN1_2 = (LPASN1_TYPE_2) lpByte;

    lpASN1_2->CaseExactString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_2.CaseExactString
                        );

    lpByte = (LPBYTE ) lpASN1_2 + sizeof(ASN1_TYPE_2);

    return(lpByte);
}



LPBYTE
CopyNDSSynId3ToNDS3(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_3 lpASN1_3 = (LPASN1_TYPE_3) lpByte;

    lpASN1_3->CaseIgnoreString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_3.CaseIgnoreString
                        );

    lpByte = (LPBYTE ) lpASN1_3 + sizeof(ASN1_TYPE_3);

    return(lpByte);
}

LPBYTE
CopyNDSSynId4ToNDS4(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_4 lpASN1_4 = (LPASN1_TYPE_4) lpByte;

    lpASN1_4->PrintableString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_4.PrintableString
                        );

    lpByte = (LPBYTE ) lpASN1_4 + sizeof(ASN1_TYPE_4);

    return(lpByte);

}


LPBYTE
CopyNDSSynId5ToNDS5(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_5 lpASN1_5 = (LPASN1_TYPE_5) lpByte;

    lpASN1_5->NumericString =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_5.NumericString
                        );

    lpByte = (LPBYTE ) lpASN1_5 + sizeof(ASN1_TYPE_5);

    return(lpByte);
}

LPBYTE
CopyNDSSynId6ToNDS6(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;
    LPASN1_TYPE_6 lpASN1_6_Start = (LPASN1_TYPE_6) lpByte;
    LPNDS_ASN1_TYPE_6 lpNdsTempASN1_6 = NULL;

    lpNdsTempASN1_6 = &(lpNdsObject->NdsValue.value_6);
    lpASN1_6->String =
                (LPWSTR)AllocADsStr(
                        lpNdsTempASN1_6->String
                        );

    if (!lpASN1_6->String)
        return NULL;

    while ( lpNdsTempASN1_6->Next)
    {

        //lpASN1_6->Next = (LPASN1_TYPE_6)((LPBYTE)lpASN1_6 +sizeof(ASN1_TYPE_6));
        lpASN1_6->Next = (LPASN1_TYPE_6)AllocADsMem(sizeof(ASN1_TYPE_6));

        if (!lpASN1_6->Next)
            return NULL;

        lpASN1_6 = (LPASN1_TYPE_6)lpASN1_6->Next;

        lpNdsTempASN1_6 = lpNdsTempASN1_6->Next;


        lpASN1_6->String =
                    (LPWSTR)AllocADsStr(
                            lpNdsTempASN1_6->String
                            );

        if (!lpASN1_6->String)
            return NULL;

    }
    lpASN1_6->Next = NULL;

    lpByte = (LPBYTE ) lpASN1_6_Start + sizeof(ASN1_TYPE_6);

    return(lpByte);
}


LPBYTE
CopyNDSSynId7ToNDS7(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;


    lpASN1_8->Integer = lpNdsObject->NdsValue.value_8.Integer;

    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
CopyNDSSynId8ToNDS8(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;


    lpASN1_8->Integer = lpNdsObject->NdsValue.value_8.Integer;

    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
CopyNDSSynId9ToNDS9(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;
    LPBYTE pBuffer = NULL;


    lpASN1_9->Length = lpNdsObject->NdsValue.value_9.Length;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_9->Length);

    if (!pBuffer)
        return NULL;

    memcpy(
        pBuffer,
        lpNdsObject->NdsValue.value_9.OctetString,
        lpASN1_9->Length
        );

    lpASN1_9->OctetString = pBuffer;

    lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);

    return(lpByte);
}

LPBYTE
CopyNDSSynId10ToNDS10(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_10 lpASN1_10 = (LPASN1_TYPE_10) lpByte;

    lpASN1_10->TelephoneNumber =
                        AllocADsStr(
                            lpNdsObject->NdsValue.value_10.TelephoneNumber
                            );

    lpByte = (LPBYTE ) lpASN1_10 + sizeof(ASN1_TYPE_10);

    return(lpByte);
}

LPBYTE
CopyNDSSynId11ToNDS11(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPBYTE pBuffer = NULL;
    LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;

    lpASN1_11->NumberOfBits = lpNdsObject->NdsValue.value_11.NumberOfBits;
    if (lpASN1_11->NumberOfBits) {
                pBuffer = (LPBYTE)AllocADsMem(lpASN1_11->NumberOfBits);

                if (!pBuffer)
                    return NULL;

                memcpy(
                        pBuffer,
                        lpNdsObject->NdsValue.value_11.Parameters,
                        lpASN1_11->NumberOfBits
                        );
                lpASN1_11->Parameters = pBuffer;
        }
        else {
                lpASN1_11->Parameters = NULL;
        }

    lpASN1_11->TelephoneNumber =
                    (LPWSTR)AllocADsStr(
                                lpNdsObject->NdsValue.value_11.TelephoneNumber
                                );

    if (!lpASN1_11->TelephoneNumber)
        return NULL;

    lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);

    return(lpByte);
}

LPBYTE
CopyNDSSynId12ToNDS12(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;
    LPBYTE pBuffer = NULL;

    lpASN1_12->AddressType = lpNdsObject->NdsValue.value_12.AddressType;

    lpASN1_12->AddressLength = lpNdsObject->NdsValue.value_12.AddressLength;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_12->AddressLength);

    if (!pBuffer)
        return NULL;

    memcpy(
        pBuffer,
        lpNdsObject->NdsValue.value_12.Address,
        lpASN1_12->AddressLength
        );

    lpASN1_12->Address = pBuffer;

    lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);

    return(lpByte);
}

LPBYTE
CopyNDSSynId13ToNDS13(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_13 lpASN1_13 = (LPASN1_TYPE_13) lpByte;
    LPASN1_TYPE_13 lpASN1_13_Start = (LPASN1_TYPE_13) lpByte;
    LPNDS_ASN1_TYPE_13 lpNdsTempASN1_13 = NULL;
    HRESULT hr = S_OK;

    lpNdsTempASN1_13 = &(lpNdsObject->NdsValue.value_13);
    hr = CopyOctetString(lpNdsTempASN1_13->Length,
                         lpNdsTempASN1_13->Data,
                         &lpASN1_13->Length,
                         &lpASN1_13->Data);
    BAIL_ON_FAILURE(hr);

    while ( lpNdsTempASN1_13->Next)
    {

        //lpASN1_13->Next = (LPASN1_TYPE_13)((LPBYTE)lpASN1_13 +sizeof(ASN1_TYPE_13));
        lpASN1_13->Next = (LPASN1_TYPE_13)AllocADsMem(sizeof(ASN1_TYPE_13));

        lpASN1_13 = (LPASN1_TYPE_13)lpASN1_13->Next;

        lpNdsTempASN1_13 = lpNdsTempASN1_13->Next;

        hr = CopyOctetString(lpNdsTempASN1_13->Length,
                             lpNdsTempASN1_13->Data,
                             &lpASN1_13->Length,
                             &lpASN1_13->Data);
        BAIL_ON_FAILURE(hr);
    }
    lpASN1_13->Next = NULL;

    lpByte = (LPBYTE ) lpASN1_13_Start + sizeof(ASN1_TYPE_13);

error:
    return(lpByte);
}


LPBYTE
CopyNDSSynId14ToNDS14(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;

    lpASN1_14->Type = lpNdsObject->NdsValue.value_14.Type;

    lpASN1_14->Address  =
            (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_14.Address
                        );

    lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);

    return(lpByte);
}


LPBYTE
CopyNDSSynId15ToNDS15(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;

    lpASN1_15->Type = lpNdsObject->NdsValue.value_15.Type;

    lpASN1_15->VolumeName  =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_15.VolumeName
                            );

    lpASN1_15->Path  =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_15.Path
                            );

    lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);

    return(lpByte);
}

LPBYTE
CopyNDSSynId16ToNDS16(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_16 lpASN1_16 = (LPASN1_TYPE_16) lpByte;

    lpASN1_16->ReplicaType =
                            lpNdsObject->NdsValue.value_16.ReplicaType;
    lpASN1_16->ReplicaNumber =
                            lpNdsObject->NdsValue.value_16.ReplicaNumber;
    lpASN1_16->Count =
                            lpNdsObject->NdsValue.value_16.Count;

    lpASN1_16->ReplicaAddressHint->AddressType =
                            lpNdsObject->NdsValue.value_16.ReplicaAddressHints->AddressType;

    CopyOctetString(lpNdsObject->NdsValue.value_16.ReplicaAddressHints->AddressLength,
                         lpNdsObject->NdsValue.value_16.ReplicaAddressHints->Address,
                         &lpASN1_16->ReplicaAddressHint->AddressLength,
                         &lpASN1_16->ReplicaAddressHint->Address);
    lpByte = (LPBYTE ) lpASN1_16 + sizeof(ASN1_TYPE_16);
    return(lpByte);
}


LPBYTE
CopyNDSSynId17ToNDS17(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;


    lpASN1_17->ProtectedAttrName =
                    (LPWSTR)AllocADsStr(
                               lpNdsObject->NdsValue.value_17.ProtectedAttrName
                                );

    lpASN1_17->SubjectName =
                    (LPWSTR)AllocADsStr(
                                lpNdsObject->NdsValue.value_17.SubjectName
                                );

    lpASN1_17->Privileges = lpNdsObject->NdsValue.value_17.Privileges;

    lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);

    return(lpByte);
}


LPBYTE
CopyNDSSynId18ToNDS18(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;


    lpASN1_18->PostalAddress[0] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[0]
                            );
    lpASN1_18->PostalAddress[1] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[1]
                            );

    lpASN1_18->PostalAddress[2] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[2]
                            );

    lpASN1_18->PostalAddress[3] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[3]
                            );

    lpASN1_18->PostalAddress[4] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[4]
                            );

    lpASN1_18->PostalAddress[5] =
                    (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_18.PostalAddress[5]
                            );

    lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);


    return(lpByte);
}

LPBYTE
CopyNDSSynId19ToNDS19(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{

    LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_19;

    lpASN1_19->WholeSeconds
            = lpNdsObject->NdsValue.value_19.WholeSeconds;


    lpASN1_19->EventID
                = lpNdsObject->NdsValue.value_19.EventID;

    lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);

    return(lpByte);
}

LPBYTE
CopyNDSSynId20ToNDS20(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_20 lpASN1_20 = (LPASN1_TYPE_20) lpByte;

    lpASN1_20->ClassName =
            (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_20.ClassName
                        );

    lpByte = (LPBYTE ) lpASN1_20 + sizeof(ASN1_TYPE_20);

    return(lpByte);
}


LPBYTE
CopyNDSSynId21ToNDS21(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;

    LPBYTE pBuffer = NULL;


    lpASN1_21->Length = lpNdsObject->NdsValue.value_21.Length;

    if (lpASN1_21->Length) {
        pBuffer = (LPBYTE)AllocADsMem(lpASN1_21->Length);

        if (!pBuffer)
            return NULL;

        memcpy(
            pBuffer,
            lpNdsObject->NdsValue.value_21.Data,
            lpASN1_21->Length
            );

        lpASN1_21->Data = pBuffer;
    }
    else {
        lpASN1_21->Data = NULL;
    }

    lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);

    return(lpByte);

}



LPBYTE
CopyNDSSynId22ToNDS22(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_22 lpASN1_22 = (LPASN1_TYPE_22) lpByte;

    lpASN1_22->Counter = lpNdsObject->NdsValue.value_22.Counter;

    lpByte = (LPBYTE ) lpASN1_22 + sizeof(ASN1_TYPE_22);

    return(lpByte);
}

LPBYTE
CopyNDSSynId23ToNDS23(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;

    lpASN1_23->RemoteID = lpNdsObject->NdsValue.value_23.RemoteID;

    lpASN1_23->ObjectName =
            (LPWSTR)AllocADsStr(
                    lpNdsObject->NdsValue.value_23.ObjectName
                    );

    lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);

    return(lpByte);
}

LPBYTE
CopyNDSSynId24ToNDS24(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject

    )
{
    LPASN1_TYPE_24 lpASN1_24 = (LPASN1_TYPE_24) lpByte;

    lpASN1_24->Time = lpNdsObject->NdsValue.value_24.Time;

    lpByte = (LPBYTE ) lpASN1_24 + sizeof(ASN1_TYPE_24);

    return(lpByte);
}



LPBYTE
CopyNDSSynId25ToNDS25(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;

    lpASN1_25->ObjectName =
                (LPWSTR)AllocADsStr(
                            lpNdsObject->NdsValue.value_25.ObjectName
                            );

    lpASN1_25->Level = lpNdsObject->NdsValue.value_25.Level;

    lpASN1_25->Interval = lpNdsObject->NdsValue.value_25.Interval;

    lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);

    return(lpByte);
}


LPBYTE
CopyNDSSynId26ToNDS26(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;


    lpASN1_26->ObjectName =
                (LPWSTR)AllocADsStr(
                        lpNdsObject->NdsValue.value_26.ObjectName
                        );

    lpASN1_26->Amount = lpNdsObject->NdsValue.value_26.Amount;

    lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);

    return(lpByte);
}


LPBYTE
CopyNDSSynId27ToNDS27(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_27 lpASN1_27 = (LPASN1_TYPE_27) lpByte;

    lpASN1_27->Interval = lpNdsObject->NdsValue.value_27.Interval;

    lpByte = (LPBYTE ) lpASN1_27 + sizeof(ASN1_TYPE_27);

    return(lpByte);
}


LPBYTE
CopyNDSSynIdToNDS(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    switch (dwSyntaxId) {
    case 1:
        lpByte = CopyNDSSynId1ToNDS1(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 2:
        lpByte = CopyNDSSynId2ToNDS2(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 3:
        lpByte = CopyNDSSynId3ToNDS3(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 4:
        lpByte = CopyNDSSynId4ToNDS4(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 5:
        lpByte = CopyNDSSynId5ToNDS5(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 6:
        lpByte = CopyNDSSynId6ToNDS6(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 7:
        lpByte = CopyNDSSynId7ToNDS7(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 8:
        lpByte = CopyNDSSynId8ToNDS8(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 9:
        lpByte = CopyNDSSynId9ToNDS9(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 10:
        lpByte = CopyNDSSynId10ToNDS10(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 11:
        lpByte = CopyNDSSynId11ToNDS11(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 12:
        lpByte = CopyNDSSynId12ToNDS12(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 13:
        lpByte = CopyNDSSynId13ToNDS13(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 14:
        lpByte = CopyNDSSynId14ToNDS14(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 15:
        lpByte = CopyNDSSynId15ToNDS15(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 16:
        lpByte = CopyNDSSynId16ToNDS16(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 17:
        lpByte = CopyNDSSynId17ToNDS17(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 18:
        lpByte = CopyNDSSynId18ToNDS18(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 19:
        lpByte = CopyNDSSynId19ToNDS19(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 20:
        lpByte = CopyNDSSynId20ToNDS20(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 21:
        lpByte = CopyNDSSynId21ToNDS21(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 22:
        lpByte = CopyNDSSynId22ToNDS22(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 23:
        lpByte = CopyNDSSynId23ToNDS23(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 24:
        lpByte = CopyNDSSynId24ToNDS24(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 25:
        lpByte = CopyNDSSynId25ToNDS25(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 26:
        lpByte = CopyNDSSynId26ToNDS26(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 27:
        lpByte = CopyNDSSynId27ToNDS27(
                         lpByte,
                         lpNdsObject
                         );
        break;


    default:
        break;

    }

    return(lpByte);
}


HRESULT
MarshallNDSSynIdToNDS(
    DWORD dwSyntaxId,
    PNDSOBJECT pNdsObject,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    DWORD  i = 0;
    HRESULT hr = S_OK;


    for (i = 0; i < dwNumValues; i++) {

        lpValue = CopyNDSSynIdToNDS(
                         dwSyntaxId,
                         lpValue,
                         (pNdsObject + i)
                         );

        if (!lpValue) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }


    }

error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\nwcmacro.h ===
#include "nwapi32.h"

//
// Return Code macro
//
#define NWCCODE_FAILED(Status) ((NWCCODE)(Status) != SUCCESSFUL)

#define NWCCODE_SUCCESS(Status) ((NWCCODE)(Status) == SUCCESSFUL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ndsmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ndsmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//                CopyNDS1ToNDSSynId1
//                CopyNDS2ToNDSSynId2
//                CopyNDS3ToNDSSynId3
//                CopyNDS4ToNDSSynId4
//                CopyNDS5ToNDSSynId5
//                CopyNDS6ToNDSSynId6
//                CopyNDS7ToNDSSynId7
//                CopyNDS8ToNDSSynId8
//                CopyNDS9ToNDSSynId9
//                CopyNDS10ToNDSSynId10
//                CopyNDS11ToNDSSynId11
//                CopyNDS12ToNDSSynId12
//                CopyNDS13ToNDSSynId13
//                CopyNDS14ToNDSSynId14
//                CopyNDS15ToNDSSynId15
//                CopyNDS16ToNDSSynId16
//                CopyNDS17ToNDSSynId17
//                CopyNDS18ToNDSSynId18
//                CopyNDS19ToNDSSynId19
//                CopyNDS20ToNDSSynId20
//                CopyNDS21ToNDSSynId21
//                CopyNDS22ToNDSSynId22
//                CopyNDS23ToNDSSynId23
//                CopyNDS24ToNDSSynId24
//                CopyNDS25ToNDSSynId25
//                CopyNDS26ToNDSSynId26
//                CopyNDS27ToNDSSynId27
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//  Warnings:     NDS Data type 6 is not yet supported (no problems just
//                not done!
//
//                NDS Data type 16 need to complete the for loop code
//                NDS Data type 21 is the stream data type some stress.
//----------------------------------------------------------------------------
#include "nds.hxx"



HRESULT
NdsTypeInit(
    PNDSOBJECT pNdsType
    )
{
    memset(pNdsType, 0, sizeof(NDSOBJECT));

    RRETURN(S_OK);
}


LPBYTE
CopyNDS1ToNDSSynId1(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_1;

    lpNdsObject->NdsValue.value_1.DNString =
                    (LPWSTR)AllocADsStr(lpASN1_1->DNString);

    lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);

    return(lpByte);
}

LPBYTE
CopyNDS2ToNDSSynId2(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_2 lpASN1_2 = (LPASN1_TYPE_2) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_2;

    lpNdsObject->NdsValue.value_2.CaseExactString =
            (LPWSTR)AllocADsStr(lpASN1_2->CaseExactString);

    lpByte = (LPBYTE ) lpASN1_2 + sizeof(ASN1_TYPE_2);

    return(lpByte);
}


LPBYTE
CopyNDS3ToNDSSynId3(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_3 lpASN1_3 = (LPASN1_TYPE_3) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_3;

    lpNdsObject->NdsValue.value_3.CaseIgnoreString =
            (LPWSTR)AllocADsStr(lpASN1_3->CaseIgnoreString);

    lpByte = (LPBYTE ) lpASN1_3 + sizeof(ASN1_TYPE_3);

    return(lpByte);
}

LPBYTE
CopyNDS4ToNDSSynId4(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_4 lpASN1_4 = (LPASN1_TYPE_4) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_4;

    lpNdsObject->NdsValue.value_4.PrintableString =
                (LPWSTR)AllocADsStr(lpASN1_4->PrintableString);

    lpByte = (LPBYTE) lpASN1_4 + sizeof(ASN1_TYPE_4);

    return(lpByte);
}


LPBYTE
CopyNDS5ToNDSSynId5(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_5 lpASN1_5 = (LPASN1_TYPE_5) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_5;

    lpNdsObject->NdsValue.value_5.NumericString =
                 (LPWSTR)AllocADsStr(lpASN1_5->NumericString);

    lpByte = (LPBYTE ) lpASN1_5 + sizeof(ASN1_TYPE_5);

    return(lpByte);
}

LPBYTE
CopyNDS6ToNDSSynId6(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;

    LPNDS_ASN1_TYPE_6 lpNdsTempASN1_6 = NULL;
    LPNDS_ASN1_TYPE_6 lpNdsNextASN1_6 = NULL;

    lpNdsTempASN1_6 = &(lpNdsObject->NdsValue.value_6);


    lpNdsObject->NdsType = NDS_SYNTAX_ID_6;


    lpNdsTempASN1_6->String =
                (LPWSTR)AllocADsStr(lpASN1_6->String);
    if (!lpNdsTempASN1_6->String)
        return (NULL);

    while ( lpASN1_6->Next != NULL )
    {
        lpASN1_6 = lpASN1_6->Next;

        lpNdsNextASN1_6 =
                (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));
        if (!lpNdsNextASN1_6)
            return (NULL);

        lpNdsNextASN1_6->String =
                (LPWSTR)AllocADsStr(lpASN1_6->String);

        if (!lpNdsNextASN1_6->String)
            return (NULL);

        lpNdsTempASN1_6->Next = lpNdsNextASN1_6;

        lpNdsTempASN1_6 = lpNdsNextASN1_6;
    }
    lpByte = (LPBYTE ) lpASN1_6 + sizeof(ASN1_TYPE_6);

    return(lpByte);
}


LPBYTE
CopyNDS7ToNDSSynId7(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{

    LPASN1_TYPE_7 lpASN1_7 = (LPASN1_TYPE_7) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_7;

    lpNdsObject->NdsValue.value_7.Boolean = lpASN1_7->Boolean;

    lpByte = (LPBYTE ) lpASN1_7 + sizeof(ASN1_TYPE_7);

    return(lpByte);
}


LPBYTE
CopyNDS8ToNDSSynId8(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_8;

    lpNdsObject->NdsValue.value_8.Integer = lpASN1_8->Integer;

    lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);

    return(lpByte);
}


LPBYTE
CopyNDS9ToNDSSynId9(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;
    LPBYTE pBuffer = NULL;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_9;

    lpNdsObject->NdsValue.value_9.Length = lpASN1_9->Length;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_9->Length);
    if (!pBuffer)
        return (NULL);

    memcpy(pBuffer, lpASN1_9->OctetString, lpASN1_9->Length);

    lpNdsObject->NdsValue.value_9.OctetString = pBuffer;

    lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);

    return(lpByte);
}

LPBYTE
CopyNDS10ToNDSSynId10(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_10 lpASN1_10 = (LPASN1_TYPE_10) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_10;

    lpNdsObject->NdsValue.value_10.TelephoneNumber =
                    (LPWSTR)AllocADsStr(lpASN1_10->TelephoneNumber);


    lpByte = (LPBYTE ) lpASN1_10 + sizeof(ASN1_TYPE_10);

    return(lpByte);
}

LPBYTE
CopyNDS11ToNDSSynId11(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPBYTE pBuffer = NULL;
    LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_11;

    lpNdsObject->NdsValue.value_11.NumberOfBits = lpASN1_11->NumberOfBits;
    if (lpASN1_11->NumberOfBits) {
        pBuffer = (LPBYTE)AllocADsMem(lpASN1_11->NumberOfBits);
        if (!pBuffer)
            return (NULL);

        memcpy(pBuffer, lpASN1_11->Parameters, lpASN1_11->NumberOfBits);
        lpNdsObject->NdsValue.value_11.Parameters= pBuffer;
    }
    else {
        lpNdsObject->NdsValue.value_11.Parameters= NULL;
    }

    lpNdsObject->NdsValue.value_11.TelephoneNumber =
                    (LPWSTR)AllocADsStr(lpASN1_11->TelephoneNumber);
    if (!lpNdsObject->NdsValue.value_11.TelephoneNumber)
        return (NULL);

    lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);

    return(lpByte);
}

LPBYTE
CopyNDS12ToNDSSynId12(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;
    LPBYTE pBuffer = NULL;

    lpNdsObject->NdsType =  NDS_SYNTAX_ID_12;

    lpNdsObject->NdsValue.value_12.AddressType = lpASN1_12->AddressType;

    lpNdsObject->NdsValue.value_12.AddressLength = lpASN1_12->AddressLength;

    pBuffer = (LPBYTE)AllocADsMem(lpASN1_12->AddressLength);

    if (!pBuffer)
        return (NULL);

    memcpy(pBuffer, lpASN1_12->Address, lpASN1_12->AddressLength);

    lpNdsObject->NdsValue.value_12.Address = pBuffer;

    lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);

    return(lpByte);
}

LPBYTE
CopyNDS13ToNDSSynId13(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_13 lpASN1_13 = (LPASN1_TYPE_13) lpByte;
    LPNDS_ASN1_TYPE_13 * lppNext = NULL;
    LPBYTE lpBuffer = NULL;
    LPNDS_ASN1_TYPE_13  pNextObj = NULL;


    lpNdsObject->NdsType =  NDS_SYNTAX_ID_13;


    lpBuffer = (LPBYTE)AllocADsMem(lpASN1_13->Length);

    if (!lpBuffer)
        return (NULL);

    memcpy(lpBuffer, lpASN1_13->Data, lpASN1_13->Length);

    lpNdsObject->NdsValue.value_13.Length = lpASN1_13->Length;
    lpNdsObject->NdsValue.value_13.Data = lpBuffer;

    lppNext = &(lpNdsObject->NdsValue.value_13.Next);

    while ( lpASN1_13->Next != NULL )
    {
        lpASN1_13 = lpASN1_13->Next;

        pNextObj =
            (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));

        if (!pNextObj)
            return (NULL);

        lpBuffer = (LPBYTE)AllocADsMem(lpASN1_13->Length);

        if (!lpBuffer)
            return (NULL);

        memcpy(lpBuffer, lpASN1_13->Data, lpASN1_13->Length);


        pNextObj->Length = lpASN1_13->Length;
        pNextObj->Data = lpBuffer;

        *lppNext =  pNextObj;

        lppNext = &pNextObj->Next;

    }
    lpByte = (LPBYTE ) lpASN1_13 + sizeof(ASN1_TYPE_13);

    return(lpByte);
}

LPBYTE
CopyNDS14ToNDSSynId14(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;

    lpNdsObject->NdsType =  NDS_SYNTAX_ID_14;

    lpNdsObject->NdsValue.value_14.Type = lpASN1_14->Type;

    lpNdsObject->NdsValue.value_14.Address =
            (LPWSTR)AllocADsStr(lpASN1_14->Address);

    lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);

    return(lpByte);
}


LPBYTE
CopyNDS15ToNDSSynId15(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;

    lpNdsObject->NdsType =  NDS_SYNTAX_ID_15;

    lpNdsObject->NdsValue.value_15.Type = lpASN1_15->Type;

    lpNdsObject->NdsValue.value_15.VolumeName =
                (LPWSTR)AllocADsStr(lpASN1_15->VolumeName);

    lpNdsObject->NdsValue.value_15.Path =
                (LPWSTR)AllocADsStr(lpASN1_15->Path);

    lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);

    return(lpByte);
}

LPBYTE
CopyNDS12ToNDS12(
    LPBYTE lpByte,
    LPNDS_ASN1_TYPE_12 lpDest12
    )
{
    LPASN1_TYPE_12 lpSrc12 = (LPASN1_TYPE_12) lpByte;
    LPBYTE pBuffer = NULL;

    lpDest12->AddressType = lpSrc12->AddressType;

    lpDest12->AddressLength = lpSrc12->AddressLength;

    if (lpSrc12->AddressLength) {
        pBuffer = (LPBYTE)AllocADsMem(lpSrc12->AddressLength);

        if (!pBuffer)
            return (NULL);

        memcpy(pBuffer, lpSrc12->Address, lpSrc12->AddressLength);

        lpDest12->Address = pBuffer;
    }else {
        lpDest12->Address = NULL;
    }

    lpByte = (LPBYTE )lpSrc12 + sizeof(ASN1_TYPE_12);

    return(lpByte);

}


LPBYTE
CopyNDS16ToNDSSynId16(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_16 lpASN1_16 = (LPASN1_TYPE_16) lpByte;
    LPNDS_ASN1_TYPE_12 lpNdsASN1_12;
    DWORD iter = 0;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_16;

    lpNdsObject->NdsValue.value_16.ServerName =
                (LPWSTR)AllocADsStr(lpASN1_16->ServerName);
    if (!lpNdsObject->NdsValue.value_16.ServerName)
        return (NULL);

    lpNdsObject->NdsValue.value_16.ReplicaType = lpASN1_16->ReplicaType;

    lpNdsObject->NdsValue.value_16.ReplicaNumber = lpASN1_16->ReplicaNumber;

    lpNdsObject->NdsValue.value_16.Count = lpASN1_16->Count;

    //
    // NDS is kinda goofy. It stores one substructure as part of the
    // containing data type instead of a pointer to the object.
    //

    lpByte = (LPBYTE ) lpASN1_16 + sizeof(ASN1_TYPE_16) - sizeof(ASN1_TYPE_12);

    lpNdsASN1_12 = (LPNDS_ASN1_TYPE_12)AllocADsMem(
                            lpASN1_16->Count * sizeof(NDS_ASN1_TYPE_12)
                            );

    if (!lpNdsASN1_12)
        return (NULL);

    lpNdsObject->NdsValue.value_16.ReplicaAddressHints = lpNdsASN1_12;

    for ( iter = 0; iter < lpASN1_16->Count; iter++ )
    {

        lpByte = CopyNDS12ToNDS12(
                        lpByte,
                        (lpNdsASN1_12 + iter)
                        );
        if (!lpByte)
            return (NULL);

    }

    return(lpByte);
}


LPBYTE
CopyNDS17ToNDSSynId17(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_17;

    lpNdsObject->NdsValue.value_17.ProtectedAttrName =
                    (LPWSTR)AllocADsStr(lpASN1_17->ProtectedAttrName);

    lpNdsObject->NdsValue.value_17.SubjectName =
                    (LPWSTR)AllocADsStr(lpASN1_17->SubjectName);

    lpNdsObject->NdsValue.value_17.Privileges =
                    lpASN1_17->Privileges;

    lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);

    return(lpByte);
}


LPBYTE
CopyNDS18ToNDSSynId18(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_18;

    lpNdsObject->NdsValue.value_18.PostalAddress[0] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[0]);


    lpNdsObject->NdsValue.value_18.PostalAddress[1] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[1]);


    lpNdsObject->NdsValue.value_18.PostalAddress[2] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[2]);


    lpNdsObject->NdsValue.value_18.PostalAddress[3] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[3]);


    lpNdsObject->NdsValue.value_18.PostalAddress[4] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[4]);


    lpNdsObject->NdsValue.value_18.PostalAddress[5] =
                    (LPWSTR)AllocADsStr(lpASN1_18->PostalAddress[5]);

    lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);

    return(lpByte);
}

LPBYTE
CopyNDS19ToNDSSynId19(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_19;


    lpNdsObject->NdsValue.value_19.WholeSeconds = lpASN1_19->WholeSeconds;

    lpNdsObject->NdsValue.value_19.EventID =  lpASN1_19->EventID;

    lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);

    return(lpByte);
}


LPBYTE
CopyNDS20ToNDSSynId20(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_20 lpASN1_20 = (LPASN1_TYPE_20) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_20;

    lpNdsObject->NdsValue.value_20.ClassName =
            (LPWSTR)AllocADsStr(lpASN1_20->ClassName);

    lpByte = (LPBYTE ) lpASN1_20 + sizeof(ASN1_TYPE_20);

    return(lpByte);
}


LPBYTE
CopyNDS21ToNDSSynId21(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;
    LPBYTE pBuffer = NULL;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_21;

    lpNdsObject->NdsValue.value_21.Length = lpASN1_21->Length;

    if (lpASN1_21->Length) {

        pBuffer = (LPBYTE)AllocADsMem(lpASN1_21->Length);
        if (!pBuffer)
            return (NULL);

        memcpy(pBuffer, lpASN1_21->Data, lpASN1_21->Length);

        lpNdsObject->NdsValue.value_21.Data = pBuffer;
    }
    else {
        lpNdsObject->NdsValue.value_21.Data = NULL;
    }


    lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);

    return(lpByte);

}



LPBYTE
CopyNDS22ToNDSSynId22(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_22 lpASN1_22 = (LPASN1_TYPE_22) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_22;

    lpNdsObject->NdsValue.value_22.Counter = lpASN1_22->Counter;

    lpByte = (LPBYTE ) lpASN1_22 + sizeof(ASN1_TYPE_22);

    return(lpByte);
}

LPBYTE
CopyNDS23ToNDSSynId23(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_23;

    lpNdsObject->NdsValue.value_23.RemoteID = lpASN1_23->RemoteID;

    lpNdsObject->NdsValue.value_23.ObjectName =
            (LPWSTR)AllocADsStr(lpASN1_23->ObjectName);

    lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);

    return(lpByte);
}

LPBYTE
CopyNDS24ToNDSSynId24(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject

    )
{
    LPASN1_TYPE_24 lpASN1_24 = (LPASN1_TYPE_24) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_24;

    lpNdsObject->NdsValue.value_24.Time = lpASN1_24->Time;

    lpByte = (LPBYTE ) lpASN1_24 + sizeof(ASN1_TYPE_24);

    return(lpByte);
}


LPBYTE
CopyNDS25ToNDSSynId25(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )

{
    LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;


    lpNdsObject->NdsType = NDS_SYNTAX_ID_25;

    lpNdsObject->NdsValue.value_25.ObjectName =
                (LPWSTR)AllocADsStr(lpASN1_25->ObjectName);

    lpNdsObject->NdsValue.value_25.Level = lpASN1_25->Level;

    lpNdsObject->NdsValue.value_25.Interval = lpASN1_25->Interval;

    lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);

    return(lpByte);
}


LPBYTE
CopyNDS26ToNDSSynId26(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_26;

    lpNdsObject->NdsValue.value_26.ObjectName =
                (LPWSTR)AllocADsStr(lpASN1_26->ObjectName);

    lpNdsObject->NdsValue.value_26.Amount = lpASN1_26->Amount;

    lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);

    return(lpByte);
}


LPBYTE
CopyNDS27ToNDSSynId27(
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    LPASN1_TYPE_27 lpASN1_27 = (LPASN1_TYPE_27) lpByte;

    lpNdsObject->NdsType = NDS_SYNTAX_ID_27;

    lpNdsObject->NdsValue.value_27.Interval = lpASN1_27->Interval;

    lpByte = (LPBYTE ) lpASN1_27 + sizeof(ASN1_TYPE_27);

    return(lpByte);
}


LPBYTE
CopyNDSToNDSSynId(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNDSOBJECT lpNdsObject
    )
{
    switch (dwSyntaxId) {
    case 1:
        lpByte = CopyNDS1ToNDSSynId1(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 2:
        lpByte = CopyNDS2ToNDSSynId2(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 3:
        lpByte = CopyNDS3ToNDSSynId3(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 4:
        lpByte = CopyNDS4ToNDSSynId4(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 5:
        lpByte = CopyNDS5ToNDSSynId5(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 6:
        lpByte = CopyNDS6ToNDSSynId6(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 7:
        lpByte = CopyNDS7ToNDSSynId7(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 8:
        lpByte = CopyNDS8ToNDSSynId8(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 9:
        lpByte = CopyNDS9ToNDSSynId9(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 10:
        lpByte = CopyNDS10ToNDSSynId10(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 11:
        lpByte = CopyNDS11ToNDSSynId11(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 12:
        lpByte = CopyNDS12ToNDSSynId12(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 13:
        lpByte = CopyNDS13ToNDSSynId13(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 14:
        lpByte = CopyNDS14ToNDSSynId14(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 15:
        lpByte = CopyNDS15ToNDSSynId15(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 16:
        lpByte = CopyNDS16ToNDSSynId16(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 17:
        lpByte = CopyNDS17ToNDSSynId17(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 18:
        lpByte = CopyNDS18ToNDSSynId18(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 19:
        lpByte = CopyNDS19ToNDSSynId19(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 20:
        lpByte = CopyNDS20ToNDSSynId20(
                         lpByte,
                         lpNdsObject
                         );
        break;


    case 21:
        lpByte = CopyNDS21ToNDSSynId21(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 22:
        lpByte = CopyNDS22ToNDSSynId22(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 23:
        lpByte = CopyNDS23ToNDSSynId23(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 24:
        lpByte = CopyNDS24ToNDSSynId24(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 25:
        lpByte = CopyNDS25ToNDSSynId25(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 26:
        lpByte = CopyNDS26ToNDSSynId26(
                         lpByte,
                         lpNdsObject
                         );
        break;

    case 27:
        lpByte = CopyNDS27ToNDSSynId27(
                         lpByte,
                         lpNdsObject
                         );
        break;


    default:
        break;

    }

    return(lpByte);
}


HRESULT
UnMarshallNDSToNDSSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue,
    PNDSOBJECT * ppNdsObject
    )
{
    HRESULT hr = S_OK;
    LPBYTE lpByte = lpValue;
    DWORD  i = 0;
    PNDSOBJECT pNdsObject = NULL;

    pNdsObject = (PNDSOBJECT)AllocADsMem(
                            dwNumValues * sizeof(NDSOBJECT)
                            );

    if (!pNdsObject) {
        RRETURN(E_FAIL);
    }


    for (i = 0; i < dwNumValues; i++) {

        lpByte = CopyNDSToNDSSynId(
                         dwSyntaxId,
                         lpByte,
                         (pNdsObject + i)
                         );

        if (!lpByte) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

    }

    *ppNdsObject = pNdsObject;

error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex = _dwLBound;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\ods2nds.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

HRESULT
AdsTypeToNdsTypeCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_1;

    lpNdsDestObject->NdsValue.value_1.DNString =
                        AllocADsStr(
                            lpAdsSrcValue->DNString
                        );
    if (!lpNdsDestObject->NdsValue.value_1.DNString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_2;

    lpNdsDestObject->NdsValue.value_2.CaseExactString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseExactString
                        );
    if (!lpNdsDestObject->NdsValue.value_2.CaseExactString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyCaseIgnoreList(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    PADS_PROV_SPECIFIC test;
    PADS_CASEIGNORE_LIST pAdsNext = lpAdsSrcValue->pCaseIgnoreList;
    struct _NDS_CI_LIST *pNdsOutput = &lpNdsDestObject->NdsValue.value_6;
    struct _NDS_CI_LIST *pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (pAdsNext == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_6;

    pNdsOutput->String = AllocADsStr(pAdsNext->String);
    if (!pNdsOutput->String ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pAdsNext = pAdsNext->Next;

    while (pAdsNext) {
        pNdsCurrent = (struct _NDS_CI_LIST *)AllocADsMem(sizeof(struct _NDS_CI_LIST));
        if (!pNdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pNdsCurrent->String = AllocADsStr(pAdsNext->String);
        if (!pNdsCurrent->String ) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsOutput->Next;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyOctetList(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    PADS_OCTET_LIST pAdsNext = lpAdsSrcValue->pOctetList;
    struct _NDS_OCTET_LIST *pNdsOutput = &lpNdsDestObject->NdsValue.value_13;
    struct _NDS_OCTET_LIST *pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (pAdsNext == NULL) {
        hr = E_FAIL;
        RRETURN(hr);
    }


    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_13;

    pNdsOutput->Next = NULL;
    pNdsOutput->Data = NULL;

    hr = CopyOctetString(pAdsNext->Length,
                         pAdsNext->Data,
                         &pNdsOutput->Length,
                         &pNdsOutput->Data);
    BAIL_ON_FAILURE(hr);
    pAdsNext = pAdsNext->Next;

    while (pAdsNext) {
        pNdsCurrent = (struct _NDS_OCTET_LIST *)AllocADsMem(sizeof(struct _NDS_OCTET_LIST));
        if (!pNdsCurrent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    
        pNdsCurrent->Next = NULL;
        pNdsCurrent->Data = NULL;

        hr = CopyOctetString(pAdsNext->Length,
                             pAdsNext->Data,
                             &pNdsCurrent->Length,
                             &pNdsCurrent->Data);
        if (FAILED(hr)) {
            FreeADsMem(pNdsCurrent);
            BAIL_ON_FAILURE(hr);
        }
        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsCurrent;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;

    RRETURN(hr);

error:

    if (lpNdsDestObject->NdsValue.value_13.Data) {
        FreeADsMem(lpNdsDestObject->NdsValue.value_13.Data);
    }

    pNdsOutput = lpNdsDestObject->NdsValue.value_13.Next;

    while (pNdsOutput) {
        if (pNdsOutput->Data) {
            FreeADsMem(pNdsOutput->Data);
        }

        pNdsCurrent = pNdsOutput->Next;
        FreeADsMem(pNdsOutput);
        pNdsOutput = pNdsCurrent;
    }

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyPath(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pPath == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_15;

    lpNdsDestObject->NdsValue.value_15.VolumeName =
                        AllocADsStr(
                            lpAdsSrcValue->pPath->VolumeName
                        );
    if (!lpNdsDestObject->NdsValue.value_15.VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_15.Path=
                        AllocADsStr(
                            lpAdsSrcValue->pPath->Path
                        );
    if (!lpNdsDestObject->NdsValue.value_15.Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_15.Type =
                            lpAdsSrcValue->pPath->Type;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyPostalAddress(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pPostalAddress == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_18;

    for (i=0;i<6;i++) {
        if (lpAdsSrcValue->pPostalAddress->PostalAddress[i]) {
            lpNdsDestObject->NdsValue.value_18.PostalAddress[i] =
                                AllocADsStr(
                                    lpAdsSrcValue->pPostalAddress->PostalAddress[i]
                                );
            if (!lpNdsDestObject->NdsValue.value_18.PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        else {
            lpNdsDestObject->NdsValue.value_18.PostalAddress[i] =
                                AllocADsStr(
                                    L""
                                );
            if (!lpNdsDestObject->NdsValue.value_18.PostalAddress[i]) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
                                
        }
    }
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyNdsTime(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_19;

    lpNdsDestObject->NdsValue.value_19.WholeSeconds =
                            lpAdsSrcValue->Timestamp.WholeSeconds;

    lpNdsDestObject->NdsValue.value_19.EventID =
                            lpAdsSrcValue->Timestamp.EventID;

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyBackLink(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_23;

    lpNdsDestObject->NdsValue.value_23.ObjectName =
                        AllocADsStr(
                            lpAdsSrcValue->BackLink.ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_23.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_23.RemoteID =
                            lpAdsSrcValue->BackLink.RemoteID;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyTypedName(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pTypedName == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_25;

    lpNdsDestObject->NdsValue.value_25.ObjectName=
                        AllocADsStr(
                            lpAdsSrcValue->pTypedName->ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_25.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_25.Level=
                            lpAdsSrcValue->pTypedName->Level;

    lpNdsDestObject->NdsValue.value_25.Interval=
                            lpAdsSrcValue->pTypedName->Interval;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyHold(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_26;

    lpNdsDestObject->NdsValue.value_26.ObjectName=
                        AllocADsStr(
                            lpAdsSrcValue->Hold.ObjectName
                        );
    if (!lpNdsDestObject->NdsValue.value_26.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_26.Amount=
                            lpAdsSrcValue->Hold.Amount;
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyEmail(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_14;

    lpNdsDestObject->NdsValue.value_14.Address=
                        AllocADsStr(
                            lpAdsSrcValue->Email.Address
                        );
    if (!lpNdsDestObject->NdsValue.value_14.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    lpNdsDestObject->NdsValue.value_14.Type=
                            lpAdsSrcValue->Email.Type;
error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyNetAddress(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pNetAddress == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_12;

    lpNdsDestObject->NdsValue.value_12.AddressType =
                            lpAdsSrcValue->pNetAddress->AddressType;

    hr = CopyOctetString(lpAdsSrcValue->pNetAddress->AddressLength,
                         lpAdsSrcValue->pNetAddress->Address,
                         &lpNdsDestObject->NdsValue.value_12.AddressLength,
                         &lpNdsDestObject->NdsValue.value_12.Address);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyFaxNumber(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pFaxNumber == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_11;

    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                            AllocADsStr(lpAdsSrcValue->pFaxNumber->TelephoneNumber);
    if (!lpNdsDestObject->NdsValue.value_11.TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = CopyOctetString(lpAdsSrcValue->pFaxNumber->NumberOfBits,
                         lpAdsSrcValue->pFaxNumber->Parameters,
                         &lpNdsDestObject->NdsValue.value_11.NumberOfBits,
                         &lpNdsDestObject->NdsValue.value_11.Parameters);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyReplicaPointer(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwCount,dwIter;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (lpAdsSrcValue->pReplicaPointer == NULL) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_16;

    lpNdsDestObject->NdsValue.value_16.ServerName=
                        AllocADsStr(
                            lpAdsSrcValue->pReplicaPointer->ServerName
                        );
    if (!lpNdsDestObject->NdsValue.value_16.ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpNdsDestObject->NdsValue.value_16.ReplicaType =
                            lpAdsSrcValue->pReplicaPointer->ReplicaType;
    lpNdsDestObject->NdsValue.value_16.ReplicaNumber =
                            lpAdsSrcValue->pReplicaPointer->ReplicaNumber;

    dwCount = lpAdsSrcValue->pReplicaPointer->Count;
    lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints =
                            (LPNDS_ASN1_TYPE_12)AllocADsMem(sizeof(NDS_ASN1_TYPE_12 )*dwCount);
    if (!lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memset(lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints, 0, sizeof(NDS_ASN1_TYPE_12 )*dwCount);
    
    for ( dwIter = 0; dwIter < dwCount; dwIter++ ) {
        (lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->AddressType =
                                (lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints+dwIter)->AddressType;
    
        hr = CopyOctetString((lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints+dwIter)->AddressLength,
                             (lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints+dwIter)->Address,
                             &((lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->AddressLength),
                             &((lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints+dwIter)->Address));
    }

    lpNdsDestObject->NdsValue.value_16.Count = dwCount;

error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = ADSTYPE_CASE_IGNORE_STRING;

    lpNdsDestObject->NdsValue.value_3.CaseIgnoreString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );
    if (!lpNdsDestObject->NdsValue.value_3.CaseIgnoreString) {
        hr = E_OUTOFMEMORY;
    }
    RRETURN(hr);

}


HRESULT
AdsTypeToNdsTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_4;

    lpNdsDestObject->NdsValue.value_4.PrintableString =
                        AllocADsStr(
                            lpAdsSrcValue->PrintableString
                        );
    if (!lpNdsDestObject->NdsValue.value_4.PrintableString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_5;

    lpNdsDestObject->NdsValue.value_5.NumericString =
                        AllocADsStr(
                                lpAdsSrcValue->NumericString
                        );
    if (!lpNdsDestObject->NdsValue.value_5.NumericString) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}



HRESULT
AdsTypeToNdsTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_7;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_8;

    lpNdsDestObject->NdsValue.value_8.Integer =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}

HRESULT
AdsTypeToNdsTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_9;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
    if (!lpByteStream) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpNdsDestObject->NdsValue.value_9.Length = dwNumBytes;
    lpNdsDestObject->NdsValue.value_9.OctetString =  lpByteStream;
error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopyTime(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_24;

    hr = ConvertSYSTEMTIMEtoDWORD(
                &(lpAdsSrcValue->UTCTime),
                &(lpNdsDestObject->NdsValue.value_24.Time)
                );

    RRETURN(hr);

}


HRESULT
AdsTypeToNdsTypeCopyObjectClass(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_20;

    lpNdsDestObject->NdsValue.value_20.ClassName =
                        AllocADsStr(
                            lpAdsSrcValue->ClassName
                        );
    if (!lpNdsDestObject->NdsValue.value_20.ClassName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);
}


HRESULT
AdsTypeToNdsTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        hr = AdsTypeToNdsTypeCopyDNString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        hr = AdsTypeToNdsTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToNdsTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        hr = AdsTypeToNdsTypeCopyPrintableString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        hr = AdsTypeToNdsTypeCopyNumericString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToNdsTypeCopyBoolean(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToNdsTypeCopyInteger(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_OCTET_STRING:
        hr = AdsTypeToNdsTypeCopyOctetString(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_UTC_TIME:
        hr = AdsTypeToNdsTypeCopyTime(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_OBJECT_CLASS:
        hr = AdsTypeToNdsTypeCopyObjectClass(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_CASEIGNORE_LIST:
        hr = AdsTypeToNdsTypeCopyCaseIgnoreList(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_FAXNUMBER:
        hr = AdsTypeToNdsTypeCopyFaxNumber(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_NETADDRESS:
        hr = AdsTypeToNdsTypeCopyNetAddress(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_OCTET_LIST:
        hr = AdsTypeToNdsTypeCopyOctetList(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_EMAIL:
        hr = AdsTypeToNdsTypeCopyEmail(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_PATH:
        hr = AdsTypeToNdsTypeCopyPath(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_REPLICAPOINTER:
        hr = AdsTypeToNdsTypeCopyReplicaPointer(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;


    case ADSTYPE_TIMESTAMP:
        hr = AdsTypeToNdsTypeCopyNdsTime(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_POSTALADDRESS:
        hr = AdsTypeToNdsTypeCopyPostalAddress(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_BACKLINK:
        hr = AdsTypeToNdsTypeCopyBackLink(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_TYPEDNAME:
        hr = AdsTypeToNdsTypeCopyTypedName(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    case ADSTYPE_HOLD:
        hr = AdsTypeToNdsTypeCopyHold(
                lpAdsSrcValue,
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToNdsTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects,
    PDWORD pdwNumNdsObjects,
    PDWORD pdwNdsSyntaxId
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;

    pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

    if (!pNdsDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = AdsTypeToNdsTypeCopy(
                    pAdsSrcValues + i,
                    pNdsDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppNdsDestObjects = pNdsDestObjects;
     *pdwNumNdsObjects = dwNumObjects;
     *pdwNdsSyntaxId = pNdsDestObjects->NdsType;
     RRETURN(S_OK);

error:

     if (pNdsDestObjects) {

        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumObjects
                );
     }

     *ppNdsDestObjects = NULL;
     *pdwNumNdsObjects = 0;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\odsmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"


LPBYTE
AdsTypeCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    lpAdsDestValue->DNString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->DNString);

    dwLength = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    lpAdsDestValue->CaseExactString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseExactString);

    dwLength = (wcslen(lpAdsSrcValue->CaseExactString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )

{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->CaseIgnoreString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->CaseIgnoreString);

    dwLength = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    lpAdsDestValue->PrintableString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->PrintableString);

    dwLength = (wcslen(lpAdsSrcValue->PrintableString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    lpAdsDestValue->NumericString = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->NumericString);

    dwLength = (wcslen(lpAdsSrcValue->NumericString) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}



LPBYTE
AdsTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpAdsSrcValue->Boolean;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                                lpAdsSrcValue->Integer;


    return(lpBuffer);
}

LPBYTE
AdsTypeCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyTime(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    lpAdsDestValue->UTCTime =
                        lpAdsSrcValue->UTCTime;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyObjectClass(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OBJECT_CLASS;

    lpAdsDestValue->ClassName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->ClassName);

    dwLength = (wcslen(lpAdsSrcValue->ClassName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

//
// New Code
//
LPBYTE
AdsTypeCopyCaseIgnoreList(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;
    PADS_CASEIGNORE_LIST pAdsNext = lpAdsSrcValue->pCaseIgnoreList;
    PADS_CASEIGNORE_LIST pNdsOutput = NULL;
    PADS_CASEIGNORE_LIST pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pCaseIgnoreList == NULL) {
        return(lpBuffer);
    }

    lpAdsDestValue->pCaseIgnoreList = (PADS_CASEIGNORE_LIST)lpBuffer;
    lpBuffer+=sizeof(ADS_CASEIGNORE_LIST);
    pNdsOutput = lpAdsDestValue->pCaseIgnoreList;

    lpAdsDestValue->dwType = ADSTYPE_CASEIGNORE_LIST;


    pNdsOutput->String = (LPWSTR)lpBuffer;
    wcscpy((LPWSTR)lpBuffer, pAdsNext->String);
    dwLength = (wcslen(pAdsNext->String) + 1)*sizeof(WCHAR);
    lpBuffer +=  dwLength;

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        pNdsCurrent = (PADS_CASEIGNORE_LIST)lpBuffer;
        lpBuffer += sizeof(ADS_CASEIGNORE_LIST);

        pNdsCurrent->String = (LPWSTR)lpBuffer;
        wcscpy((LPWSTR)lpBuffer, pAdsNext->String);
        dwLength = (wcslen(pAdsNext->String) + 1)*sizeof(WCHAR);
        lpBuffer +=  dwLength;
    
        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsOutput->Next;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyOctetList(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;
    PADS_OCTET_LIST pAdsNext = lpAdsSrcValue->pOctetList;
    PADS_OCTET_LIST pNdsOutput = NULL;
    PADS_OCTET_LIST pNdsCurrent = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        return(lpBuffer);
    }

    if (lpAdsSrcValue->pOctetList == NULL) {
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_LIST;

    lpAdsDestValue->pOctetList = (PADS_OCTET_LIST)lpBuffer;
    lpBuffer+=sizeof(ADS_OCTET_LIST);
    pNdsOutput = lpAdsDestValue->pOctetList;

    dwNumBytes =  pAdsNext->Length;
    memcpy(
        lpBuffer,
        pAdsNext->Data,
        dwNumBytes
        );
    pNdsOutput->Length = dwNumBytes;
    pNdsOutput->Data =  lpBuffer;
    lpBuffer += dwNumBytes;

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        pNdsCurrent = (PADS_OCTET_LIST)lpBuffer;
        lpBuffer += sizeof(ADS_OCTET_LIST);

        dwNumBytes =  pAdsNext->Length;
        memcpy(
            lpBuffer,
            pAdsNext->Data,
            dwNumBytes
            );
        pNdsCurrent->Length = dwNumBytes;
        pNdsCurrent->Data =  lpBuffer;
        lpBuffer += dwNumBytes;

        pNdsOutput->Next = pNdsCurrent;
        pNdsOutput = pNdsOutput->Next;
        pAdsNext = pAdsNext->Next;
    }

    pNdsOutput->Next = NULL;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyPath(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pPath == NULL) {
        return(lpBuffer);
    }


    lpAdsDestValue->dwType = ADSTYPE_PATH;

    lpAdsDestValue->pPath = (PADS_PATH)lpBuffer;
    lpBuffer+=sizeof(ADS_PATH);

    lpAdsDestValue->pPath->Type =
                        lpAdsSrcValue->pPath->Type;

    lpAdsDestValue->pPath->VolumeName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pPath->VolumeName);

    dwLength = (wcslen(lpAdsSrcValue->pPath->VolumeName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    lpAdsDestValue->pPath->Path= (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pPath->Path);

    dwLength = (wcslen(lpAdsSrcValue->pPath->Path) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyPostalAddress(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        return(lpBuffer);
    }

    if (lpAdsSrcValue->pPostalAddress == NULL) {
        return(lpBuffer);
    }


    lpAdsDestValue->pPostalAddress = (PADS_POSTALADDRESS)lpBuffer;
    lpBuffer+=sizeof(ADS_POSTALADDRESS);

    lpAdsDestValue->dwType = ADSTYPE_POSTALADDRESS;


    for (i=0;i<6;i++) {
        if (lpAdsSrcValue->pPostalAddress->PostalAddress[i]) {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] = (LPWSTR)lpBuffer;
            wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pPostalAddress->PostalAddress[i]);
            dwLength = (wcslen(lpAdsSrcValue->pPostalAddress->PostalAddress[i]) + 1)*sizeof(WCHAR);
            lpBuffer +=  dwLength;
        }
        else {
            lpAdsDestValue->pPostalAddress->PostalAddress[i] = (LPWSTR)lpBuffer;
            *((WCHAR*)lpBuffer) = '\0';
            lpBuffer += sizeof(WCHAR);
        }
    }
    return(lpBuffer);
}

LPBYTE
AdsTypeCopyTimestamp(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_TIMESTAMP;

    lpAdsDestValue->Timestamp.WholeSeconds =
                        lpAdsSrcValue->Timestamp.WholeSeconds;

    lpAdsDestValue->Timestamp.EventID =
                        lpAdsSrcValue->Timestamp.EventID;
    return(lpBuffer);
}

LPBYTE
AdsTypeCopyBackLink(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_BACKLINK;

    lpAdsDestValue->BackLink.RemoteID =
                        lpAdsSrcValue->BackLink.RemoteID;

    lpAdsDestValue->BackLink.ObjectName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->BackLink.ObjectName);

    dwLength = (wcslen(lpAdsSrcValue->BackLink.ObjectName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyTypedName(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        return(lpBuffer);
    }

    if (lpAdsSrcValue->pTypedName == NULL) {
        return(lpBuffer);
    }


    lpAdsDestValue->dwType = ADSTYPE_TYPEDNAME;

    lpAdsDestValue->pTypedName = (PADS_TYPEDNAME)lpBuffer;
    lpBuffer+=sizeof(ADS_TYPEDNAME);

    lpAdsDestValue->pTypedName->Interval =
                        lpAdsSrcValue->pTypedName->Interval;

    lpAdsDestValue->pTypedName->Level =
                        lpAdsSrcValue->pTypedName->Level;

    lpAdsDestValue->pTypedName->ObjectName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pTypedName->ObjectName);

    dwLength = (wcslen(lpAdsSrcValue->pTypedName->ObjectName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyHold(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_HOLD;

    lpAdsDestValue->Hold.Amount =
                        lpAdsSrcValue->Hold.Amount;

    lpAdsDestValue->Hold.ObjectName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->Hold.ObjectName);

    dwLength = (wcslen(lpAdsSrcValue->Hold.ObjectName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;


    return(lpBuffer);
}

LPBYTE
AdsTypeCopyEmail(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        return(lpBuffer);
    }

    lpAdsDestValue->dwType = ADSTYPE_EMAIL;

    lpAdsDestValue->Email.Type =
                        lpAdsSrcValue->Email.Type;

    lpAdsDestValue->Email.Address = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->Email.Address);

    dwLength = (wcslen(lpAdsSrcValue->Email.Address) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyNetAddress(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pNetAddress == NULL) {
        return(lpBuffer);
    }


    lpAdsDestValue->pNetAddress = (PADS_NETADDRESS)lpBuffer;
    lpBuffer+=sizeof(ADS_NETADDRESS);

    lpAdsDestValue->dwType = ADSTYPE_NETADDRESS;

    lpAdsDestValue->pNetAddress->AddressType =
                        lpAdsSrcValue->pNetAddress->AddressType;

    dwNumBytes =  lpAdsSrcValue->pNetAddress->AddressLength;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->pNetAddress->Address,
        dwNumBytes
        );

    lpAdsDestValue->pNetAddress->AddressLength = dwNumBytes;

    lpAdsDestValue->pNetAddress->Address =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}

LPBYTE
AdsTypeCopyFaxNumber(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pFaxNumber == NULL) {
        return(lpBuffer);
    }

    lpAdsDestValue->pFaxNumber = (PADS_FAXNUMBER)lpBuffer;
    lpBuffer+=sizeof(ADS_FAXNUMBER);

    lpAdsDestValue->dwType = ADSTYPE_FAXNUMBER;

    lpAdsDestValue->pFaxNumber->TelephoneNumber = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pFaxNumber->TelephoneNumber);

    dwLength = (wcslen(lpAdsSrcValue->pFaxNumber->TelephoneNumber) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    dwNumBytes =  lpAdsSrcValue->pFaxNumber->NumberOfBits;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->pFaxNumber->Parameters,
        dwNumBytes
        );

    lpAdsDestValue->pFaxNumber->NumberOfBits = dwNumBytes;

    lpAdsDestValue->pFaxNumber->Parameters =  lpBuffer;

    lpBuffer += dwNumBytes;

    return(lpBuffer);
}


LPBYTE
AdsTypeCopyReplicaPointer(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        return(lpBuffer);
    }
    if (lpAdsSrcValue->pReplicaPointer == NULL) {
        return(lpBuffer);
    }

    lpAdsDestValue->pReplicaPointer = (PADS_REPLICAPOINTER)lpBuffer;
    lpBuffer+=sizeof(ADS_REPLICAPOINTER);

    lpAdsDestValue->dwType = ADSTYPE_REPLICAPOINTER;

    lpAdsDestValue->pReplicaPointer->ReplicaType =
                        lpAdsSrcValue->pReplicaPointer->ReplicaType;

    lpAdsDestValue->pReplicaPointer->ReplicaNumber =
                        lpAdsSrcValue->pReplicaPointer->ReplicaNumber;

    lpAdsDestValue->pReplicaPointer->Count =
                        lpAdsSrcValue->pReplicaPointer->Count;

    
    lpAdsDestValue->pReplicaPointer->ServerName = (LPWSTR)lpBuffer;

    wcscpy((LPWSTR)lpBuffer, lpAdsSrcValue->pReplicaPointer->ServerName);

    dwLength = (wcslen(lpAdsSrcValue->pReplicaPointer->ServerName) + 1)*sizeof(WCHAR);

    lpBuffer +=  dwLength;

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints = (ADS_NETADDRESS*)lpBuffer;
    lpBuffer += sizeof(ADS_NETADDRESS);



    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressType =
                        lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressType;

    
    dwNumBytes =  lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressLength;

    memcpy(
        lpBuffer,
        lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->Address,
        dwNumBytes
        );

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressLength = dwNumBytes;

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->Address =  lpBuffer;

    lpBuffer += dwNumBytes;
    
    return(lpBuffer);
}
//
// END OF NEW CODE
//


LPBYTE
AdsTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue,
    LPBYTE lpBuffer
    )
{
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        lpBuffer = AdsTypeCopyDNString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        lpBuffer = AdsTypeCopyCaseExactString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        lpBuffer = AdsTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        lpBuffer = AdsTypeCopyPrintableString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        lpBuffer = AdsTypeCopyNumericString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_BOOLEAN:
        lpBuffer = AdsTypeCopyBoolean(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_INTEGER:
        lpBuffer = AdsTypeCopyInteger(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;


    case ADSTYPE_OCTET_STRING:
        lpBuffer = AdsTypeCopyOctetString(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_UTC_TIME:
        lpBuffer = AdsTypeCopyTime(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_OBJECT_CLASS:
        lpBuffer = AdsTypeCopyObjectClass(
                lpAdsSrcValue,
                lpAdsDestValue,
                lpBuffer
                );
        break;

    case ADSTYPE_CASEIGNORE_LIST:
        lpBuffer  = AdsTypeCopyCaseIgnoreList( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_FAXNUMBER:
        lpBuffer  = AdsTypeCopyFaxNumber( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_NETADDRESS:
        lpBuffer  = AdsTypeCopyNetAddress( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_OCTET_LIST:
        lpBuffer  = AdsTypeCopyOctetList( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_EMAIL:
        lpBuffer  = AdsTypeCopyEmail( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_PATH:
        lpBuffer  = AdsTypeCopyPath( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_REPLICAPOINTER:
        lpBuffer  = AdsTypeCopyReplicaPointer( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  


    case ADSTYPE_TIMESTAMP:
        lpBuffer = AdsTypeCopyTimestamp( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;               

    case ADSTYPE_POSTALADDRESS:
        lpBuffer  = AdsTypeCopyPostalAddress( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  
                   
    case ADSTYPE_BACKLINK:
        lpBuffer  = AdsTypeCopyBackLink( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_TYPEDNAME:
        lpBuffer  = AdsTypeCopyTypedName( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    case ADSTYPE_HOLD:
        lpBuffer  = AdsTypeCopyHold( 
                lpAdsSrcValue,                  
                lpAdsDestValue,
                lpBuffer
                );                              
        break;                                  

    default:
        break;
    }

    return(lpBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\property.cxx ===
#include "nds.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    
    VariantClear(&varOutputData);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\qrylexer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lexer.hxx

Abstract:

    This module implements functions to recognize the tokens in the string
    repressentation of the search filter. The format of the search filter
    according to the RFC 1960.

Author:

    Shankara Shastry [ShankSh]    08-Jul-1996

++*/

#include "nds.hxx"
#pragma hdrstop

DFA_STATE  CQryLexer::_pStateTable[MAX_STATES][MAX_CHAR_CLASSES] = gStateTable;

DWORD CQryLexer::_pCharClassTable[] = gCharClassTable;

//+---------------------------------------------------------------------------
// Function: CQryLexer
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments: szBuffer: pattern
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CQryLexer::CQryLexer(
    LPWSTR szBuffer
    ):
    _ptr(NULL),
    _Buffer(NULL),
    _dwEndofString(0),
    _dwState(ATTRTYPE_START_STATE),
    _lexeme()
{
    _bInitialized = FALSE;
    if (!szBuffer || !*szBuffer) {
        return;
    }
        
    _Buffer = (LPWSTR) AllocADsMem(
                            (wcslen(szBuffer)+1) * sizeof(WCHAR)
                            );
    
    if(_Buffer)
    wcscpy(_Buffer,
           szBuffer
           );
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function: GetNextToken
//
// Synopsis: Give the next valid token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CQryLexer::GetNextToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
    WCHAR wcNextChar;
    DWORD dwActionId;
    DFA_STATE dfaState;
    DWORD dwStartState = _dwState;
    // If there is no pattern
    if(!_ptr) {
        *pdwToken = TOKEN_ED;
        RRETURN (S_OK);
    }

    // Start forming the lexeme.

    _lexeme.ResetLexeme();

    *ppszToken = NULL;
    *pdwToken = TOKEN_ERROR;

    while (_dwState != ERROR_STATE && _dwState < FINAL_STATES_BEGIN) {
        // Get the character class from the character and then index the
        // state table
        wcNextChar = NextChar();
        DWORD now = GetCharClass(wcNextChar);
        dwActionId = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwActionId;

        _dwState = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwNextState;

        if(_dwState == ERROR_STATE) {
            BAIL_ON_FAILURE (E_FAIL);
        }

        PerformAction(_dwState,
                      wcNextChar,
                      dwActionId
                      );
    }

    _bInitialized = TRUE;

    if(*pdwToken == TOKEN_ED)
        RRETURN (S_OK);

    *ppszToken = _lexeme.GetLexeme();
    *pdwToken = GetTokenFromState(_dwState);

    _dwStateSave = _dwState;
    // This is to set the start state for the next token to be recognized
    if(*pdwToken == TOKEN_ATTRTYPE) {
        _dwState = ATTRVAL_START_STATE;
    }
    else if (*pdwToken == TOKEN_ATTRVAL) {
        _dwState = ATTRTYPE_START_STATE;
    }
    else if (*pdwToken == TOKEN_PRESENT) {
            _dwState = ATTRTYPE_START_STATE;
    } else {
        _dwState = dwStartState;
    }


    RRETURN (S_OK);

error:
    RRETURN (E_FAIL);
}

//+---------------------------------------------------------------------------
// Function: GetCurrentToken
//
// Synopsis: Give the current valid token, and do not advance unless
//           it is the first token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CQryLexer::GetCurrentToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
    if (!_bInitialized) {
        HRESULT hr;
        hr = GetNextToken(
                    ppszToken,
                    pdwToken
                    );
        return hr;
    } else {
        *ppszToken = _lexeme.GetLexeme();
        *pdwToken = GetTokenFromState(_dwStateSave);
        return (S_OK);
    }
}

//+---------------------------------------------------------------------------
// Function: NextChar
//
// Synopsis: Returns the next chaarcter in the pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
WCHAR
CQryLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function: PushbackChar
//
// Synopsis: Puts back a character to the unrecognised pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
void
CQryLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

HRESULT
CQryLexer::PerformAction(
            DWORD dwCurrState,
            WCHAR wcCurrChar,
            DWORD dwActionId
            )
{
   switch(dwActionId) {
       case ACTION_PUSHBACK_CHAR:
           PushbackChar();
           break;
       case ACTION_PUSHBACK_2CHAR:
           PushbackChar();
           PushbackChar();
           _lexeme.PushBackChar();
           break;
       case ACTION_IGNORE_ESCAPECHAR:
           break;
       case ACTION_DEFAULT:
           _lexeme.PushNextChar(wcCurrChar);
           break;
   }

   if(_dwState >= FINAL_STATES_BEGIN)
       _lexeme.PushNextChar(L'\0');

   RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
// Function: CQryLexer::GetTokenFromState
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
inline DWORD
CQryLexer::GetTokenFromState(
            DWORD dwCurrState
            )
{
    return (dwCurrState - FINAL_STATES_BEGIN);
}


//+---------------------------------------------------------------------------
// Function: ~CQryLexer
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CQryLexer::~CQryLexer()
{
    if( _Buffer )
        FreeADsMem (_Buffer);

}

//+---------------------------------------------------------------------------
// Function: CLexeme
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexeme::CLexeme(
    ):
        _dwMaxLength(0),
        _dwIndex(0)
{
    _pszLexeme = (LPWSTR) AllocADsMem(LEXEME_UNIT_LENGTH * sizeof(WCHAR));
    if(_pszLexeme)
        _dwMaxLength = LEXEME_UNIT_LENGTH;
}

//+---------------------------------------------------------------------------
// Function: ~CLexeme
//
// Synopsis: Destructor
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

inline CLexeme::~CLexeme(
    )
{
    if(_pszLexeme)
        FreeADsMem(_pszLexeme);
}

//+---------------------------------------------------------------------------
// Function: PushNextChar
//
// Synopsis: Add the next character after making sure there is enough memory
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexeme::PushNextChar(
    WCHAR wcNextChar
    )
{
    if(_dwIndex >= _dwMaxLength)
    {
        _pszLexeme = (LPWSTR) ReallocADsMem(
                                    _pszLexeme,
                                    _dwMaxLength * sizeof(WCHAR),
                                    (_dwMaxLength + LEXEME_UNIT_LENGTH) * sizeof(WCHAR)
                                    );
        BAIL_ON_NULL(_pszLexeme);

        _dwMaxLength += LEXEME_UNIT_LENGTH;
    }

    _pszLexeme[_dwIndex++] = wcNextChar;


    RRETURN (S_OK);

error:
    RRETURN (E_FAIL);

}

HRESULT
CLexeme::PushBackChar()
{
    _pszLexeme[--_dwIndex] = '\0';
    RRETURN (S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:  RemoveWhiteSpaces
//
//  Synopsis:  Removes the leading and trailing white spaces
//
//  Arguments: pszText                  Text strings from which the leading
//                                      and trailing white spaces are to be
//                                      removed
//
//  Returns:    LPWSTR                  Pointer to the modified string
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
LPWSTR
RemoveWhiteSpaces(
    LPWSTR pszText)
{
    LPWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!iswspace(*pChar))
            break;
        else
            *pChar = L'\0';
    }

    return pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\printhlp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      printhlp.cxx
//
//  Contents:  Helper functions for printer object.
//
//  History:   08-May-96    t-ptam (PatrickT) migrated
//
//----------------------------------------------------------------------------

#include "nds.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL  fStatus = FALSE;
    DWORD dwNeeded = 0;
    DWORD dwError = 0;

    //
    // Enumerate Jobs using Win32 API.
    //

    fStatus = EnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  *lplpbJobs,
                  *pcbBuf,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Jobs again with a bigger buffer if a bigger one is needed
    // for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

            if (*lplpbJobs) {
                FreeADsMem( *lplpbJobs );
            }

            *lplpbJobs = (LPBYTE)AllocADsMem(dwNeeded);

            if (!*lplpbJobs) {
                *pcbBuf = 0;
                return(FALSE);
            }

            *pcbBuf = dwNeeded;

            fStatus = EnumJobs(
                          hPrinter,
                          dwFirstJob,
                          dwNoJobs,
                          dwLevel,
                          *lplpbJobs,
                          *pcbBuf,
                          &dwNeeded,
                          lpdwReturned
                          );

            if (!fStatus) {
                return(FALSE);
            }
            else {
                return(TRUE);
            }
        }
        else {
            return(FALSE);
        }
    }
    else {
        return(TRUE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumPrinters
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumPrinters(
    DWORD  dwType,
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters,
    LPDWORD lpdwReturned
    )
{
    BOOL   fStatus = FALSE;
    DWORD  dwPassed = 1024;
    DWORD  dwNeeded = 0;
    DWORD  dwError = 0;
    LPBYTE pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Enumerate Printers using Win32 API.
    //

    fStatus = EnumPrinters(
                  dwType,
                  lpszName,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Printers again with a bigger buffer if a bigger one is
    // needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = EnumPrinters(
                      dwType,
                      lpszName,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded,
                      lpdwReturned
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);

error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: WinNTGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{

    BOOL    fStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Get printer's information.
    //

    fStatus = GetPrinter(
                  hPrinter,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded
                  );

    //
    // Get printer's information again with a bigger buffer if a bigger buffer
    // is needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = GetPrinter(
                      hPrinter,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);


error:
    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: GetPrinterInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterInfo(
     THIS_ LPPRINTER_INFO_2 *lplpPrinterInfo2,
     BSTR  bstrPrinterName
     )
{
    //
    // Do a GetPrinter call to bstrPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                              READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(bstrPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)bstrPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    //
    // If access is denied, do it again with a different access right.
    //

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
            {
                PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
                fStatus = OpenPrinter(
                              (LPTSTR)bstrPrinterName,
                              &hPrinter,
                              &PrinterDefaults
                              );
                if (fStatus) {
                    break;
                }
            }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Get printer's info.
    //

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE *)&pMem
                  );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // Return.
    //

    *lplpPrinterInfo2 = (LPPRINTER_INFO_2)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: Set
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
Set(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  pszPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Set printer's data.
    //

    fStatus = SetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE)lpPrinterInfo2,
                  0
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Return.
    //

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}

//----------------------------------------------------------------------------
//
//  Function: WinNTDeletePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
WinNTDeletePrinter(
    POBJECTINFO pObjectInfo
    )
{
    WCHAR szUncServerName[MAX_PATH];
    WCHAR szUncPrinterName[MAX_PATH];
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    //
    // Make Unc Name for OpenPrinter.
    //

    //
    //  Cleanup
    //


    /*
    MakeUncName(pObjectInfo->ComponentArray[1],
                szUncServerName
                );

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, L"\\");
    wcscat(szUncPrinterName, (LPTSTR)pObjectInfo->ComponentArray[2]);*/

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)szUncPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Delete the given printer.
    //

    fStatus = DeletePrinter(hPrinter);

    //
    // Return.
    //

    if (!fStatus) {

        hr = GetLastError();

        fStatus = ClosePrinter(hPrinter);

        goto error;
    }


error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\odssz.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"



DWORD
AdsTypeDNStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->DNString) + 1)*sizeof(WCHAR);

    return(dwSize);
}

DWORD
AdsTypeCaseExactStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->CaseExactString) + 1) *sizeof(WCHAR);


    return(dwSize);
}


DWORD
AdsTypeCaseIgnoreStringSize(
    PADSVALUE lpAdsSrcValue
    )

{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->CaseIgnoreString) + 1) *sizeof(WCHAR);


    return(dwSize);
}


DWORD
AdsTypePrintableStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->PrintableString) + 1) *sizeof(WCHAR);


    return(dwSize);
}

DWORD
AdsTypeNumericStringSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->NumericString) + 1)* sizeof(WCHAR);


    return(dwSize);
}



DWORD
AdsTypeBooleanSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        return(0);
    }

    return(0);
}


DWORD
AdsTypeIntegerSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeOctetStringSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        return(0);
    }

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;


    return(dwNumBytes);
}


DWORD
AdsTypeTimeSize(
    PADSVALUE lpAdsSrcValue
    )
{
    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        return(0);
    }

    return(0);
}

DWORD
AdsTypeObjectClassSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_OBJECT_CLASS){
        return(0);
    }

    dwSize = (wcslen(lpAdsSrcValue->ClassName) + 1)*sizeof(WCHAR);

    return(dwSize);
}

DWORD
AdsTypeCaseIgnoreListSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;
    PADS_CASEIGNORE_LIST pAdsNext = lpAdsSrcValue->pCaseIgnoreList;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        return(0);
    }
    if (lpAdsSrcValue->pCaseIgnoreList == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_CASEIGNORE_LIST);

    dwLength = (wcslen(pAdsNext->String) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        dwSize += sizeof(ADS_CASEIGNORE_LIST);

        dwLength = (wcslen(pAdsNext->String) + 1)*sizeof(WCHAR);
        dwSize +=  dwLength;
    
        pAdsNext = pAdsNext->Next;
    }


    return(dwSize);

}

DWORD
AdsTypeOctetListSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;
    PADS_OCTET_LIST pAdsNext = lpAdsSrcValue->pOctetList;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        return(0);
    }
    if (lpAdsSrcValue->pOctetList == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_OCTET_LIST);

    dwNumBytes =  pAdsNext->Length;
    dwSize += dwNumBytes;

    pAdsNext = pAdsNext->Next;
    
    while (pAdsNext) {
        dwSize += sizeof(ADS_OCTET_LIST);

        dwNumBytes =  pAdsNext->Length;
        dwSize += dwNumBytes;

        pAdsNext = pAdsNext->Next;
    }


    return(dwSize);
}

DWORD
AdsTypePathSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        return(0);
    }
    if (lpAdsSrcValue->pPath == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_PATH);

    dwLength = (wcslen(lpAdsSrcValue->pPath->VolumeName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    dwLength = (wcslen(lpAdsSrcValue->pPath->Path) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}

DWORD
AdsTypePostalAddressSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        return(0);
    }
    if (lpAdsSrcValue->pPostalAddress == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_POSTALADDRESS);

    for (i=0;i<6;i++) {
        if (lpAdsSrcValue->pPostalAddress->PostalAddress[i]) {
            dwLength = (wcslen(lpAdsSrcValue->pPostalAddress->PostalAddress[i]) + 1)*sizeof(WCHAR);
            dwSize +=  dwLength;
        }
        else {
            dwSize += sizeof(WCHAR);
        }
    }
    return(dwSize);
}

DWORD
AdsTypeTimestampSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        return(0);
    }

    return(dwSize);
}

DWORD
AdsTypeBackLinkSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        return(0);
    }


    dwLength = (wcslen(lpAdsSrcValue->BackLink.ObjectName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}

DWORD
AdsTypeTypedNameSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        return(0);
    }
    if (lpAdsSrcValue->pTypedName == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_TYPEDNAME);

    dwLength = (wcslen(lpAdsSrcValue->pTypedName->ObjectName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}

DWORD
AdsTypeHoldSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        return(0);
    }

    dwLength = (wcslen(lpAdsSrcValue->Hold.ObjectName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}

DWORD
AdsTypeEmailSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        return(0);
    }

    dwLength = (wcslen(lpAdsSrcValue->Email.Address) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    return(dwSize);
}


DWORD
AdsTypeNetAddressSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        return(0);
    }
    if (lpAdsSrcValue->pNetAddress == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_NETADDRESS);

    dwNumBytes =  lpAdsSrcValue->pNetAddress->AddressLength;
    dwSize += dwNumBytes;

    return(dwSize);
}

DWORD
AdsTypeFaxNumberSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        return(0);
    }
    if (lpAdsSrcValue->pFaxNumber == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_FAXNUMBER);

    dwLength = (wcslen(lpAdsSrcValue->pFaxNumber->TelephoneNumber) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    dwNumBytes =  lpAdsSrcValue->pFaxNumber->NumberOfBits;
    dwSize += dwNumBytes;

    return(dwSize);
}


DWORD
AdsTypeReplicaPointerSize(
    PADSVALUE lpAdsSrcValue
    )
{
    DWORD dwSize = 0;
    DWORD dwNumBytes = 0;
    DWORD dwLength = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        return(0);
    }
    if (lpAdsSrcValue->pReplicaPointer == NULL) {
        return(0);
    }

    dwSize += sizeof(ADS_REPLICAPOINTER);

    dwLength = (wcslen(lpAdsSrcValue->pReplicaPointer->ServerName) + 1)*sizeof(WCHAR);
    dwSize +=  dwLength;

    dwSize += sizeof(ADS_NETADDRESS);
    
    dwNumBytes =  lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressLength;
    dwSize += dwNumBytes;
    
    return(dwSize);
}


DWORD
AdsTypeSize(
    PADSVALUE lpAdsSrcValue
    )
{

    DWORD dwSize = 0;

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        dwSize = AdsTypeDNStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        dwSize = AdsTypeCaseExactStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        dwSize = AdsTypeCaseIgnoreStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        dwSize = AdsTypePrintableStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        dwSize = AdsTypeNumericStringSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_BOOLEAN:
        dwSize = AdsTypeBooleanSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_INTEGER:
        dwSize = AdsTypeIntegerSize(
                lpAdsSrcValue
                );
        break;


    case ADSTYPE_OCTET_STRING:
        dwSize = AdsTypeOctetStringSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_UTC_TIME:
        dwSize = AdsTypeTimeSize(
                lpAdsSrcValue
                );
        break;

    case ADSTYPE_OBJECT_CLASS:
        dwSize = AdsTypeObjectClassSize(
                lpAdsSrcValue
                );
        break;
    
    case ADSTYPE_CASEIGNORE_LIST:
        dwSize = AdsTypeCaseIgnoreListSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_FAXNUMBER:
        dwSize = AdsTypeFaxNumberSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_NETADDRESS:
        dwSize = AdsTypeNetAddressSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_OCTET_LIST:
        dwSize = AdsTypeOctetListSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_EMAIL:
        dwSize = AdsTypeEmailSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_PATH:
        dwSize = AdsTypePathSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_REPLICAPOINTER:
        dwSize = AdsTypeReplicaPointerSize(
                lpAdsSrcValue
                );
        break;                                  


    case ADSTYPE_TIMESTAMP:
        dwSize = AdsTypeTimestampSize(
                lpAdsSrcValue
                );
        break;               

    case ADSTYPE_POSTALADDRESS:
        dwSize = AdsTypePostalAddressSize(
                lpAdsSrcValue
                );
        break;                                  
                   
    case ADSTYPE_BACKLINK:
        dwSize = AdsTypeBackLinkSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_TYPEDNAME:
        dwSize = AdsTypeTypedNameSize(
                lpAdsSrcValue
                );
        break;                                  

    case ADSTYPE_HOLD:
        dwSize = AdsTypeHoldSize(
                lpAdsSrcValue
                );

    default:
        break;
    }

    return(dwSize);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  parse.cxx
//
//  Contents:  NDS Pathname Parser
//
//    The Pathname Parser is a key component in ADs providers. It checks for
//    syntactic validity of an ADs pathname that has been passed to this
//    provider. If the syntax is valid, then an OBJECTINFO structure is
//    constructed. This OBJECTINFO structure contains a componentized version
//    of the ADs pathname for this object.
//
//    Note all that is being done is a syntax check. Rather than special-case
//    every single new nuance to pathnames, all path checking must conform to
//    the grammar rules laid out by the parser.
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop

// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <NDSObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {

    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = NDSObject(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }
    }

cleanup:
    RRETURN(hr);

}



//+---------------------------------------------------------------------------
//  Function:   NDSObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <NDSObject> -> "\\""identifier""\" <PathName>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
NDSObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    WCHAR szDisplayToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddTreeName(pObjectInfo, szToken, szDisplayToken );
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    //
    // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
    //

    if (dwToken == TOKEN_END || dwToken == TOKEN_COMMA) {
        hr = pTokenizer->PushBackToken();
        RRETURN(S_OK);
    }

    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component
HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) ) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);

    if ((dwToken == TOKEN_FSLASH) ) {
        RRETURN (PathName(pTokenizer, pObjectInfo));
    }else {
        hr = pTokenizer->PushBackToken();
        RRETURN (S_OK);
    }
cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szValue[MAX_TOKEN_LENGTH];
    WCHAR szDisplayValue[MAX_TOKEN_LENGTH];
    WCHAR szEqual[MAX_TOKEN_LENGTH];
    WCHAR szComponent[MAX_TOKEN_LENGTH];
    WCHAR szDisplayComponent[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szComponent, szDisplayComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = pTokenizer->GetNextToken(szEqual, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_EQUAL) {

        hr = pTokenizer->GetNextToken(szValue, szDisplayValue, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddComponent(
                 pObjectInfo,
                 szComponent,
                 szValue,
                 szDisplayComponent,
                 szDisplayValue
                 );
        BAIL_IF_ERROR(hr);

    }else {
        hr = AddComponent(pObjectInfo, szComponent, NULL, szDisplayComponent, NULL);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->PushBackToken();
        BAIL_IF_ERROR(hr);
    }

    RRETURN(S_OK);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPWSTR szDisplayToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;
    LPWSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);

    if (szDisplayToken) {
        memset(szDisplayToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    }

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            if (c == TEXT('"')) {
                //
                // Quoting;
                //

                fQuotingOn = TRUE;

                pch--;
                state = 1;

            }else if (c == TEXT('\\')) {
                //
                // Escaping; Ignore the '\' in the token and check to make
                // sure that the next character exists
                //
                pch--;

                fEscapeOn = TRUE;

                state = 1;

            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'='){
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            /*
            }else if (c == L'.'){
                *pdwToken = TOKEN_PERIOD;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            */
            }else if (c == L':'){
                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
            }else if (c == TEXT('<')) {
                RRETURN(E_FAIL);
            }else if (c == TEXT('>')) {
                RRETURN(E_FAIL);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }
            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_FAIL);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                }
                else {
                    *pch++ = c;
                }
                _dwLastTokenLength++;
                break;
            }
            else if (c == TEXT('\\') ) {
                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                break;

            }
            else if (c == TEXT('"')) {
                fQuotingOn = TRUE;
                _dwLastTokenLength++;
                break;
            }
            else if (c == L'\0' || c == L',' ||
                    c == L'=' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);

            }else if (c == L'@' || c == L'!' || c == L':' ) {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }

            }else {
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }

        default:
            RRETURN(E_FAIL);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}

HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(
    POBJECTINFO pObjectInfo,
    LPWSTR szComponent,
    LPWSTR szValue,
    LPWSTR szDisplayComponent,
    LPWSTR szDisplayValue
    )
{
    if (!szComponent || !*szComponent || !szDisplayComponent || !*szDisplayComponent) {
        RRETURN(E_FAIL);
    }

    if (pObjectInfo->NumComponents < MAXCOMPONENTS) {

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                        AllocADsStr(szComponent);

        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                        AllocADsStr(szValue);

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szComponent =
                    AllocADsStr(szDisplayComponent);

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents].szValue =
                    AllocADsStr(szDisplayValue);

        pObjectInfo->NumComponents++;

        RRETURN(S_OK);

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }
}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPWSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken || !szDisplayToken || !*szDisplayToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = AllocADsStr(szToken);
    pObjectInfo->DisplayTreeName = AllocADsStr(szDisplayToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


// Type -> "user", "group","printer","service", "fileservice"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr = E_FAIL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            pObjectInfo->ClassName = AllocADsStr(szToken);
        }
        RRETURN(hr);
    }

cleanup:
    RRETURN(hr);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\var2nds.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       var2nds.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//
//  NDS_ASN1_TYPE_1
//
//  NDS_ASN1_TYPE_2
//
//  NDS_ASN1_TYPE_3
//
//  NDS_ASN1_TYPE_4
//
//  NDS_ASN1_TYPE_5
//
//  NDS_ASN1_TYPE_6     
//
//  NDS_ASN1_TYPE_7
//
//  NDS_ASN1_TYPE_8
//
//  NDS_ASN1_TYPE_9     
//
//  NDS_ASN1_TYPE_10
//
//  NDS_ASN1_TYPE_11    
//
//  NDS_ASN1_TYPE_12    
//
//  NDS_ASN1_TYPE_13    
//
//  NDS_ASN1_TYPE_14
//
//  NDS_ASN1_TYPE_15    
//
//  NDS_ASN1_TYPE_16    
//
//  NDS_ASN1_TYPE_17    
//
//  NDS_ASN1_TYPE_18    
//
//  NDS_ASN1_TYPE_19    
//
//  NDS_ASN1_TYPE_20
//
//  NDS_ASN1_TYPE_21    
//
//  NDS_ASN1_TYPE_22
//
//  NDS_ASN1_TYPE_23    
//
//  NDS_ASN1_TYPE_24
//
//  NDS_ASN1_TYPE_25    
//
//  NDS_ASN1_TYPE_26    
//
//  NDS_ASN1_TYPE_27
//
//
//----------------------------------------------------------------------------
#include "nds.hxx"

//
// NdsType objects copy code
//
HRESULT
VarTypeToNdsTypeCopyNDSSynId1(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_1;

    lpNdsDestObject->NdsValue.value_1.DNString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    if ((!lpNdsDestObject->NdsValue.value_1.DNString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId2(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_2;

    lpNdsDestObject->NdsValue.value_2.CaseExactString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_2.CaseExactString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId3(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_3;

    lpNdsDestObject->NdsValue.value_3.CaseIgnoreString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_3.CaseIgnoreString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);

}


HRESULT
VarTypeToNdsTypeCopyNDSSynId4(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_4;

    lpNdsDestObject->NdsValue.value_4.PrintableString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_4.PrintableString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId5(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_5;

    lpNdsDestObject->NdsValue.value_5.NumericString =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_5.NumericString) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId6(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    LPNDS_ASN1_TYPE_6 pCurrent = NULL;
    IADsCaseIgnoreList FAR * pCaseIgnoreList = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varCaseIgnoreList;
    VARIANT varElement;

    VariantInit(&varCaseIgnoreList);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsCaseIgnoreList,
                    (void **)&pCaseIgnoreList
                    );
    BAIL_ON_FAILURE(hr);

    hr = pCaseIgnoreList->get_CaseIgnoreList(
                    &varCaseIgnoreList
                    );
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varCaseIgnoreList) &  VT_VARIANT) &&  V_ISARRAY(&varCaseIgnoreList))) {
        return(E_FAIL);
    }
 
    if ((V_ARRAY(&varCaseIgnoreList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varCaseIgnoreList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_6;
    pCurrent = &lpNdsDestObject->NdsValue.value_6;
    
    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varCaseIgnoreList),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        pCurrent->String = AllocADsStr(V_BSTR(&varElement));
        if ((!pCurrent->String) &&
            (V_BSTR(&varElement))) {
            RRETURN(E_OUTOFMEMORY);
        }
        
        if (i != (long)dwSUBound) {
            pCurrent->Next = (LPNDS_ASN1_TYPE_6)AllocADsMem(sizeof(NDS_ASN1_TYPE_6));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
        VariantClear(&varElement);
    }
    pCurrent->Next = NULL;
    RRETURN(S_OK);

error:
    VariantClear(&varCaseIgnoreList);
    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release();
    }
    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId7(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_7;

    lpNdsDestObject->NdsValue.value_7.Boolean =
                        (lpVarSrcObject->boolVal)? TRUE:FALSE;

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId8(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_8;

    if (lpVarSrcObject->vt == VT_I4)
        lpNdsDestObject->NdsValue.value_8.Integer = lpVarSrcObject->lVal;
    else if (lpVarSrcObject->vt == VT_I2)
        lpNdsDestObject->NdsValue.value_8.Integer = lpVarSrcObject->iVal;
    else
        hr = E_ADS_CANT_CONVERT_DATATYPE;

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId9(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr;
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_9;
    hr = VariantToBinary(
                lpVarSrcObject,
                &lpNdsDestObject->NdsValue.value_9.Length,
                &lpNdsDestObject->NdsValue.value_9.OctetString
                );
    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId10(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_10;

    lpNdsDestObject->NdsValue.value_10.TelephoneNumber =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    if ((!lpNdsDestObject->NdsValue.value_10.TelephoneNumber) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId11(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsFaxNumber FAR * pFaxNumber = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varParameters;
    BSTR bstrVal;

    VariantInit(&varParameters);

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsFaxNumber,
                    (void **)&pFaxNumber
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_11;

    hr = pFaxNumber->get_TelephoneNumber(
                                    &bstrVal
                                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_11.TelephoneNumber =
                        AllocADsStr(
                                bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_11.TelephoneNumber) &&
        (bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pFaxNumber->get_Parameters(
                            &varParameters
                            );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varParameters,
                    &lpNdsDestObject->NdsValue.value_11.NumberOfBits,
                    &lpNdsDestObject->NdsValue.value_11.Parameters
                    );
    BAIL_ON_FAILURE(hr);

error:
    VariantClear(&varParameters);
    if (pFaxNumber) {
        pFaxNumber->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId12(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsNetAddress FAR * pNetAddress = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwAddressType = 0;
    BYTE*  pbAddress = NULL;
    VARIANT varAddress;

    VariantInit(&varAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                            IID_IADsNetAddress,
                            (void **)&pNetAddress
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_12;

    hr = pNetAddress->get_AddressType(
                                &dwAddressType
                                );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_12.AddressType = dwAddressType;

    VariantInit(&varAddress);
    hr = pNetAddress->get_Address(
                            &varAddress
                            );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                        &varAddress,
                        &lpNdsDestObject->NdsValue.value_12.AddressLength,
                        &lpNdsDestObject->NdsValue.value_12.Address
                        );
    BAIL_ON_FAILURE(hr);

error:
    VariantClear(&varAddress);
    if (pNetAddress) {
        pNetAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId13(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    LPNDS_ASN1_TYPE_13 pCurrent = NULL;
    IADsOctetList FAR * pOctetList= NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varOctetList;
    VARIANT varElement;

    VariantInit(&varOctetList);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                    IID_IADsOctetList,
                    (void **)&pOctetList
                    );
    BAIL_ON_FAILURE(hr);


    hr = pOctetList->get_OctetList(&varOctetList);
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varOctetList) &  VT_VARIANT) &&  V_ISARRAY(&varOctetList))) {
        return(E_FAIL);
    }
 
    if ((V_ARRAY(&varOctetList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varOctetList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_13;
    pCurrent = &lpNdsDestObject->NdsValue.value_13;
    
    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varOctetList),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        hr = VariantToBinary(
                        &varElement,
                        &pCurrent->Length,
                        &pCurrent->Data
                        );
        BAIL_ON_FAILURE(hr);
        if (i != (long)dwSUBound) {
            pCurrent->Next = (LPNDS_ASN1_TYPE_13)AllocADsMem(sizeof(NDS_ASN1_TYPE_13));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
        VariantClear(&varElement);
    }
    pCurrent->Next = NULL;

error:
    VariantClear(&varOctetList);
    if (pOctetList) {
        pOctetList->Release();
    }
    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId14(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsEmail FAR * pEmail = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwAddressType = 0;
    BSTR bstrAddress;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);
    hr = pDispatch->QueryInterface(
                            IID_IADsEmail,
                            (void **)&pEmail
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_14;

    hr = pEmail->get_Type(
                    &dwAddressType
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_14.Type = dwAddressType;

    hr = pEmail->get_Address(
                        &bstrAddress
                        );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_14.Address=
                        AllocADsStr(
                                bstrAddress
                        );
    if ((!lpNdsDestObject->NdsValue.value_14.Address) &&
        (bstrAddress)) {
        RRETURN(E_OUTOFMEMORY);
    }

error:
    if (pEmail) {
        pEmail->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId15(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsPath FAR * pPath = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwType = 0;
    BSTR bstrVolumeName = NULL;
    BSTR bstrPath = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsPath,
                    (void **)&pPath
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_15;

    hr = pPath->get_VolumeName(
                    &bstrVolumeName
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.VolumeName=
                                AllocADsStr(bstrVolumeName);
    if ((!lpNdsDestObject->NdsValue.value_15.VolumeName) &&
        (bstrVolumeName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pPath->get_Path(
                    &bstrPath
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.Path=
                                AllocADsStr(bstrPath);
    if ((!lpNdsDestObject->NdsValue.value_15.Path) &&
        (bstrPath)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pPath->get_Type((LONG *)&dwType);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_15.Type = dwType;

error:
    if (pPath) {
        pPath->Release();
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNdsTypeCopyNDSSynId16(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsReplicaPointer FAR * pReplicaPointer = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwReplicaType = 0;
    DWORD  dwReplicaNumber = 0;
    DWORD  dwCount = 0;
    BSTR bstrServerName = NULL;
    NDSOBJECT object;
    VARIANT varAddress;

    VariantInit(&varAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsReplicaPointer,
                    (void **)&pReplicaPointer
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_16;

    hr = pReplicaPointer->get_ServerName(
                    &bstrServerName
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ServerName=
                                AllocADsStr(bstrServerName);
    if ((!lpNdsDestObject->NdsValue.value_16.ServerName) &&
        (bstrServerName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pReplicaPointer->get_ReplicaType((LONG *)&dwReplicaType);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ReplicaType= dwReplicaType;

    hr = pReplicaPointer->get_ReplicaNumber((LONG *)&dwReplicaNumber);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_16.ReplicaNumber= dwReplicaNumber;

    hr = pReplicaPointer->get_Count((LONG *)&dwCount);
    BAIL_ON_FAILURE(hr);

    if (dwCount == 0) {
        lpNdsDestObject->NdsValue.value_16.Count = 0;
        lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints = NULL;
    }
    else {
        //
        //         We only support the setting of 1 ReplicaAddressHints in the 
        //         ReplicaPointer. Supporting more than 1 requires the support
        //         of marshalling an array variant which is more complex. 
        //         Judging that there is no real usage of this interface since
        //         the Replica Pointer is for NDS internal use only. We have
        //         decided that we'll postpone this to post W2K and will fix it
        //         only if there is a need.
        //      
        lpNdsDestObject->NdsValue.value_16.Count = 1;
    
        hr = pReplicaPointer->get_ReplicaAddressHints(&varAddress);
        BAIL_ON_FAILURE(hr);
        hr = VarTypeToNdsTypeCopyNDSSynId12(
                                &varAddress,
                                &object
                                );
        BAIL_ON_FAILURE(hr);
        lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints = 
            (LPNDS_ASN1_TYPE_12)AllocADsMem(sizeof(NDS_ASN1_TYPE_12));
        if (lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        memcpy(lpNdsDestObject->NdsValue.value_16.ReplicaAddressHints,
               &object.NdsValue.value_12,
               sizeof(NDS_ASN1_TYPE_12));
    }

error:
    VariantClear(&varAddress);
    if (pReplicaPointer) {
        pReplicaPointer->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId17(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsAcl FAR * pSecDes = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwPrivileges = 0;
    BSTR bstrProtectedAttrName = NULL;
    BSTR bstrSubjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsAcl,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_17;

    hr = pSecDes->get_ProtectedAttrName(
                    &bstrProtectedAttrName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_17.ProtectedAttrName =
                                AllocADsStr(bstrProtectedAttrName);
    if ((!lpNdsDestObject->NdsValue.value_17.ProtectedAttrName) &&
        (bstrProtectedAttrName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pSecDes->get_SubjectName(
                    &bstrSubjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_17.SubjectName=
                                AllocADsStr(bstrSubjectName);
    if ((!lpNdsDestObject->NdsValue.value_17.SubjectName) &&
        (bstrSubjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pSecDes->get_Privileges((LONG *)&dwPrivileges);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_17.Privileges= dwPrivileges;


error:

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId18(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    IADsPostalAddress FAR * pPostalAddress = NULL;
    IDispatch FAR * pDispatch = NULL;
    VARIANT varPostalAddress;
    VARIANT varElement;
    BSTR bstrElement;
    
    VariantInit(&varPostalAddress);
    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsPostalAddress,
                    (void **)&pPostalAddress
                    );
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->get_PostalAddress(
                    &varPostalAddress
                    );
    BAIL_ON_FAILURE(hr);


    if(!((V_VT(&varPostalAddress) &  VT_VARIANT) &&  V_ISARRAY(&varPostalAddress))) {
        return(E_FAIL);
    }
 
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_18;

    if ((V_ARRAY(&varPostalAddress))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ( ((V_ARRAY(&varPostalAddress))->rgsabound[0].cElements <= 0) || 
         ((V_ARRAY(&varPostalAddress))->rgsabound[0].cElements >6) ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varPostalAddress),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varPostalAddress),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varPostalAddress),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        lpNdsDestObject->NdsValue.value_18.PostalAddress[i-dwSLBound] = 
                            AllocADsStr(V_BSTR(&varElement));
        if ((!lpNdsDestObject->NdsValue.value_18.PostalAddress[i-dwSLBound]) &&
            (V_BSTR(&varElement))) {
            RRETURN(E_OUTOFMEMORY);
        }
                            
        VariantClear(&varElement);
    }

error:
    VariantClear(&varPostalAddress);
    if (pPostalAddress) {
        pPostalAddress->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId19(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsTimestamp FAR * pTime = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwEventID = 0;
    long dwWholeSeconds = 0;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsTimestamp,
                    (void **)&pTime
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_19;

    hr = pTime->get_WholeSeconds(
                    &dwWholeSeconds
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_19.WholeSeconds= dwWholeSeconds;
    BAIL_ON_FAILURE(hr);

    hr = pTime->get_EventID(
                    &dwEventID
                    );
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_19.EventID = dwEventID;
    BAIL_ON_FAILURE(hr);

error:
    if (pTime) {
        pTime->Release();
    }

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopyNDSSynId20(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_20;

    lpNdsDestObject->NdsValue.value_20.ClassName =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );
    if ((!lpNdsDestObject->NdsValue.value_20.ClassName) &&
        (lpVarSrcObject->bstrVal)) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId21(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr;
    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_21;
    hr = VariantToBinary(
                            lpVarSrcObject,
                            &lpNdsDestObject->NdsValue.value_21.Length,
                            &lpNdsDestObject->NdsValue.value_21.Data
                            );
    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId22(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_22;

    lpNdsDestObject->NdsValue.value_22.Counter =
                            lpVarSrcObject->lVal;

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId23(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsBackLink FAR * pBackLink = NULL;
    IDispatch FAR * pDispatch = NULL;
    long dwRemoteID = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsBackLink,
                    (void **)&pBackLink
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_23;

    hr = pBackLink->get_ObjectName(
                            &bstrObjectName
                            );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_23.ObjectName=
                                AllocADsStr(bstrObjectName);
    if ((!lpNdsDestObject->NdsValue.value_23.ObjectName) &&
        (bstrObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pBackLink->get_RemoteID((LONG *)&dwRemoteID);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_23.RemoteID = dwRemoteID;

error:
    if (pBackLink) {
        pBackLink->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId24(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_24;

    hr = ConvertDATEtoDWORD(
                lpVarSrcObject->date,
                &(lpNdsDestObject->NdsValue.value_24.Time),
                TRUE
                );

    RRETURN(hr);

}

HRESULT
VarTypeToNdsTypeCopyNDSSynId25(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsTypedName FAR * pTypedName = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwLevel = 0;
    DWORD  dwInterval = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsTypedName,
                    (void **)&pTypedName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_25;

    hr = pTypedName->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_25.ObjectName=
                                AllocADsStr(bstrObjectName);
    if ((!lpNdsDestObject->NdsValue.value_25.ObjectName) &&
        (bstrObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pTypedName->get_Level((LONG *)&dwLevel);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_25.Level = dwLevel;

    hr = pTypedName->get_Interval((LONG *)&dwInterval);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_25.Interval= dwInterval;

error:
    if (pTypedName) {
        pTypedName->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId26(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    IADsHold FAR * pHold = NULL;
    IDispatch FAR * pDispatch = NULL;
    DWORD  dwAmount = 0;
    BSTR bstrObjectName = NULL;

    if (V_VT(lpVarSrcObject) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsHold,
                    (void **)&pHold
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_26;

    hr = pHold->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

    lpNdsDestObject->NdsValue.value_26.ObjectName=
                                AllocADsStr(bstrObjectName);
    if ((!lpNdsDestObject->NdsValue.value_26.ObjectName) &&
        (bstrObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    hr = pHold->get_Amount((LONG *)&dwAmount);
    BAIL_ON_FAILURE(hr);
    lpNdsDestObject->NdsValue.value_26.Amount = dwAmount;

error:
    if (pHold) {
        pHold->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToNdsTypeCopyNDSSynId27(
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNdsDestObject->NdsType = NDS_SYNTAX_ID_27;

    lpNdsDestObject->NdsValue.value_27.Interval =
                            lpVarSrcObject->lVal;

    RRETURN(hr);
}


HRESULT
VarTypeToNdsTypeCopy(
    DWORD dwNdsType,
    PVARIANT lpVarSrcObject,
    PNDSOBJECT lpNdsDestObject
    )
{
    HRESULT hr = S_OK;
    switch (dwNdsType){
    case 1:
        hr = VarTypeToNdsTypeCopyNDSSynId1(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 2:
        hr = VarTypeToNdsTypeCopyNDSSynId2(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 3:
        hr = VarTypeToNdsTypeCopyNDSSynId3(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 4:
        hr = VarTypeToNdsTypeCopyNDSSynId4(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 5:
        hr = VarTypeToNdsTypeCopyNDSSynId5(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 6:
        hr = VarTypeToNdsTypeCopyNDSSynId6(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 7:
        hr = VarTypeToNdsTypeCopyNDSSynId7(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 8:
        hr = VarTypeToNdsTypeCopyNDSSynId8(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 9:
        hr = VarTypeToNdsTypeCopyNDSSynId9(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 10:
        hr = VarTypeToNdsTypeCopyNDSSynId10(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 11:
        hr = VarTypeToNdsTypeCopyNDSSynId11(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 12:
        hr = VarTypeToNdsTypeCopyNDSSynId12(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 13:
        hr = VarTypeToNdsTypeCopyNDSSynId13(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 14:
        hr = VarTypeToNdsTypeCopyNDSSynId14(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 15:
        hr = VarTypeToNdsTypeCopyNDSSynId15(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 16:
        hr = VarTypeToNdsTypeCopyNDSSynId16(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;


    case 17:
        hr = VarTypeToNdsTypeCopyNDSSynId17(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 18:
        hr = VarTypeToNdsTypeCopyNDSSynId18(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 19:
        hr = VarTypeToNdsTypeCopyNDSSynId19(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 20:
        hr = VarTypeToNdsTypeCopyNDSSynId20(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 21:
        hr = VarTypeToNdsTypeCopyNDSSynId21(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 22:
        hr = VarTypeToNdsTypeCopyNDSSynId22(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 23:
        hr = VarTypeToNdsTypeCopyNDSSynId23(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 24:
        hr = VarTypeToNdsTypeCopyNDSSynId24(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 25:
        hr = VarTypeToNdsTypeCopyNDSSynId25(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 26:
        hr = VarTypeToNdsTypeCopyNDSSynId26(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    case 27:
        hr = VarTypeToNdsTypeCopyNDSSynId27(
                lpVarSrcObject,
                lpNdsDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNdsTypeCopyConstruct(
    DWORD dwNdsType,
    LPVARIANT pVarSrcObjects,
    DWORD *pdwNumObjects,
    LPNDSOBJECT * ppNdsDestObjects
    )
{

    DWORD i = 0;
    LPNDSOBJECT pNdsDestObjects = NULL;
    HRESULT hr = S_OK;
    VARIANT varNDSAcl;
    IDispatch * pDispatch = NULL;
    IADsSecurityDescriptor * pSecDes = NULL;
    DWORD dwNumObjects = *pdwNumObjects;

    // 
    // If it is a security descriptor, do special conversion
    // 
    if (dwNdsType == 17) {

        //
        // Bail out if it contains more than 1 object
        //
        if (dwNumObjects != 1) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        if (V_VT(pVarSrcObjects) != VT_DISPATCH){
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    
        pDispatch = V_DISPATCH(pVarSrcObjects);
    
        hr = pDispatch->QueryInterface(
                        IID_IADsSecurityDescriptor,
                        (void **)&pSecDes
                        );
        BAIL_ON_FAILURE(hr);

        hr = ConvertSecDesToNDSAclVarArray(
            pSecDes,
            &varNDSAcl
            );
        BAIL_ON_FAILURE(hr);

        hr  = ConvertSafeArrayToVariantArray(
                    varNDSAcl,
                    &pVarSrcObjects,
                    &dwNumObjects
                    );
        BAIL_ON_FAILURE(hr);
        pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NDSOBJECT)
                                    );

        if (!pNdsDestObjects) {
            RRETURN(E_FAIL);
        }
        *pdwNumObjects = dwNumObjects;
    }
    else {
        pNdsDestObjects = (LPNDSOBJECT)AllocADsMem(
                                        dwNumObjects * sizeof(NDSOBJECT)
                                        );

        if (!pNdsDestObjects) {
            RRETURN(E_FAIL);
        }
    }    
     
    for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToNdsTypeCopy(
                    dwNdsType,
                    pVarSrcObjects + i,
                    pNdsDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);
    
    }

     *ppNdsDestObjects = pNdsDestObjects;

     if (pSecDes) {
        pSecDes->Release();
     }

     RRETURN(S_OK);

error:

     if (pNdsDestObjects) {
        NdsTypeFreeNdsObjects(
                pNdsDestObjects,
                dwNumObjects
                );
     }

     if (pSecDes) {
        pSecDes->Release();
     }

     *ppNdsDestObjects = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\sec2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
ConvertNDSAclVArrayToSecDesVar(
    PVARIANT pVarArrayNDSAcl,
    PVARIANT pVarSecDes
    )
{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    VARIANT varDACL;    

    VariantInit(pVarSecDes);
    memset(&varDACL, 0, sizeof(VARIANT));

    hr = ConvertNDSAclVArrayToAclVariant(
                                    pVarArrayNDSAcl,
                                    &varDACL
                                    );
    BAIL_ON_FAILURE(hr);

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    V_VT(pVarSecDes) = VT_DISPATCH;
    V_DISPATCH(pVarSecDes) =  pDispatch;

error:

    if (pSecDes) {
        pSecDes->Release();
    }

    VariantClear(&varDACL);

    RRETURN(hr);
}




HRESULT
ConvertNDSAclVArrayToAclVariant(
    PVARIANT pVarArrayNDSACL,
    PVARIANT pVarACL
    )
{
    IADsAccessControlList *pAccessControlList = NULL;
    IDispatch *pDispatch = NULL;
    VARIANT *pVarArray = NULL;
    VARIANT varAce;
    DWORD i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumValues = 0;
    DWORD dwNewAceCount = 0;

    VariantInit(pVarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    hr  = ConvertSafeArrayToVariantArray(
                *pVarArrayNDSACL,
                &pVarArray,
                &dwNumValues
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwNumValues; i++) {
        hr = ConvertNDSAclVariantToAceVariant(
                    &(pVarArray[i]),
                    (PVARIANT)&varAce
                    );

        hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));
        if (SUCCEEDED(hr)) {
           dwNewAceCount++;
        }

        VariantClear(&varAce);
    }

    pAccessControlList->put_AceCount(dwNewAceCount);

    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pVarACL) = VT_DISPATCH;
    V_DISPATCH(pVarACL) = pDispatch;

error:

    if (pAccessControlList) {
        pAccessControlList->Release();
    }

    if (pVarArray) {

        for (DWORD i=0; i < dwNumValues; i++) {
            VariantClear(&(pVarArray[i]));
        }
        FreeADsMem(pVarArray);
    }
    RRETURN(hr);
}



HRESULT
ConvertNDSAclVariantToAceVariant(
    PVARIANT pvarNDSAce,
    PVARIANT pvarAce
    )
{
    HRESULT hr = S_OK;
    IADsAccessControlEntry *pAccessControlEntry = NULL;
    IDispatch *pDispatch = NULL;
    IADsAcl *pSecDes = NULL;
    DWORD  dwPrivileges = 0;
    BSTR bstrProtectedAttrName = NULL;
    BSTR bstrSubjectName = NULL;

    if (V_VT(pvarNDSAce) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pDispatch = V_DISPATCH(pvarNDSAce);

    hr = pDispatch->QueryInterface(
                    IID_IADsAcl,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_ProtectedAttrName(
                    &bstrProtectedAttrName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_SubjectName(
                    &bstrSubjectName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_Privileges(
                    (LONG *)&dwPrivileges);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_AccessMask(dwPrivileges);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_Trustee(bstrSubjectName);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->put_ObjectType(bstrProtectedAttrName);
    BAIL_ON_FAILURE(hr);


    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pSecDes) {
        pSecDes->Release();
    }

    if (pAccessControlEntry) {
        pAccessControlEntry->Release();
    }

    if (bstrSubjectName) {
        ADsFreeString(bstrSubjectName);
    }

    if (bstrProtectedAttrName) {
        ADsFreeString(bstrProtectedAttrName);
    }

    RRETURN(hr);


error:

    if (pDispatch) {
        pDispatch->Release();
    }
  
    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\qryparse.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qryparse.cxx

Abstract:

Author:

    Felix Wong [t-FelixW]    05-Nov-1996
    
++*/
#include "nds.hxx"
#pragma hdrstop

//#define DEBUG_DUMPSTACK
//#define DEBUG_DUMPRULE

#if (defined(DEBUG_DUMPSTACK) || defined (DEBUG_DUMPRULE))
#include "stdio.h"
#endif


#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )

// Action Table 
typedef struct _action{
    DWORD type;
    DWORD dwState;
}action;

// Rule Table 
typedef struct _rule{
    DWORD dwNumber;
    DWORD dwA;
}rule;

enum types {
    N,
    S,
    R,
    A
    };

#define X 99

action g_action[28][14] = { 
//       ERROR  ,LPARAN,RPARAN,OR,    AND,   NOT,   APPROX,EQ,    LE,    GE,    PRESNT,ATYPE, VAL,   END,  
/*00*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*01*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{A,X } },
/*02*/  { {N,X },{N,X },{N,X },{S,12},{S,11},{S,13},{N,X },{N,X },{N,X },{N,X },{N,X },{S,14},{N,X },{N,X } },
/*03*/  { {N,X },{N,X },{R,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*04*/  { {N,X },{N,X },{R,3 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*05*/  { {N,X },{N,X },{R,4 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*06*/  { {N,X },{N,X },{R,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*07*/  { {N,X },{N,X },{S,15},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*08*/  { {N,X },{N,X },{R,11},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*09*/  { {N,X },{N,X },{R,12},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*10*/  { {N,X },{N,X },{R,13},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*11*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*12*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*13*/  { {N,X },{S,2 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*14*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,20},{S,26},{S,22},{S,21},{S,23},{N,X },{N,X },{N,X } },
/*15*/  { {N,X },{R,1 },{R,1 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,1 } },
/*16*/  { {N,X },{N,X },{R,6 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*17*/  { {N,X },{S,2 },{R,9 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*18*/  { {N,X },{N,X },{R,7 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*19*/  { {N,X },{N,X },{R,8 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*20*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,15},{N,X } },
/*21*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,16},{N,X } },
/*22*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,17},{N,X } },
/*23*/  { {N,X },{N,X },{R,18},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*24*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,25},{N,X } },
/*25*/  { {N,X },{N,X },{R,14},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*26*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,19},{N,X } },
/*27*/  { {N,X },{N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } }
};

enum non_terminals {
    NONTERM_F,
    NONTERM_FC,
    NONTERM_AND,
    NONTERM_OR,
    NONTERM_NOT,
    NONTERM_FL,
    NONTERM_ITM,
    NONTERM_SMP,
    NONTERM_FT,
    NONTERM_PRS
};


rule g_rule[] = {
//        1)No. of non-terminals and terminals on the right hand side
//        2)The Parent
/*00*/    {0, 0,             },
/*01*/    {3, NONTERM_F,     },
/*02*/    {1, NONTERM_FC,    },
/*03*/    {1, NONTERM_FC,    },
/*04*/    {1, NONTERM_FC,    },
/*05*/    {1, NONTERM_FC,    },
/*06*/    {2, NONTERM_AND,   },
/*07*/    {2, NONTERM_OR,    },
/*08*/    {2, NONTERM_NOT,   },
/*09*/    {1, NONTERM_FL,    },
/*10*/    {2, NONTERM_FL,    },
/*11*/    {1, NONTERM_ITM,   },
/*12*/    {1, NONTERM_ITM,   },
/*13*/    {1, NONTERM_ITM,   },
/*14*/    {3, NONTERM_SMP,   },
/*15*/    {1, NONTERM_FT,    },
/*16*/    {1, NONTERM_FT,    },
/*17*/    {1, NONTERM_FT,    },
/*18*/    {2, NONTERM_PRS,   },
/*19*/    {1, NONTERM_FT,    }
};

#ifdef DEBUG_DUMPRULE
LPWSTR g_rgszRule[] = {
/*00*/    L"",
/*01*/    L"F->(FC)",
/*02*/    L"FC->AND",
/*03*/    L"FC->OR",
/*04*/    L"FC->NOT",
/*05*/    L"FC->ITM",
/*06*/    L"AND->&FL",
/*07*/    L"OR->|FL",
/*08*/    L"NOT->!F",
/*09*/    L"FL->F",
/*10*/    L"FL->F FL",
/*11*/    L"ITM->SMP",
/*12*/    L"ITM->PRS",
/*13*/    L"ITM->STR",
/*14*/    L"SMP->ATR FT VAL",
/*15*/    L"FT->~=",
/*16*/    L"FT->>=",
/*17*/    L"FT-><=",
/*18*/    L"PRS->ATR=*",
/*19*/    L"FT->="
};
#endif

DWORD g_goto[28][10] = {
//         F,   FC,  AND, OR,  NOT, FL,  ITM, SMP, FT,  PRS, 
/*00*/    {1,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*01*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*02*/    {X,   7,   3,   4,   5,   X,   6,   8,   X,   9  },
/*03*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*04*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*05*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*06*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*07*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*08*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*09*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*10*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*11*/    {17,  X,   X,   X,   X,  16,   X,   X,   X,   X  },
/*12*/    {17,  X,   X,   X,   X,  18,   X,   X,   X,   X  },
/*13*/    {19,  X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*14*/    {X,   X,   X,   X,   X,   X,   X,   X,  24,   X  },
/*15*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*16*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*17*/    {17,  X,   X,   X,   X,  27,   X,   X,   X,   X  },
/*18*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*19*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*20*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*21*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*22*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*23*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*24*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*25*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*26*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  },
/*27*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X  }
};

HRESULT MapTokenToType(
                    DWORD dwToken,
                    DWORD *pdwType
                    )
{
    DWORD dwType;    
    switch(dwToken) {            
        case TOKEN_EQ:
            dwType = QUERY_EQUAL;
            break;
        case TOKEN_LE:
            dwType = QUERY_LE;
            break;
        case TOKEN_GE:
            dwType = QUERY_GE;
            break;
        case TOKEN_APPROX_EQ:
            dwType = QUERY_APPROX;
            break;
        default:
            return (E_ADS_INVALID_FILTER);
    }
    *pdwType = dwType;
    return (S_OK);
}

HRESULT Parse(
          LPWSTR szQuery,
          CQueryNode **ppNode,
          CAttrList **ppAttrList
          )
{
    CStack Stack;
    CQryLexer Query(szQuery);
    LPWSTR lexeme;
    DWORD dwToken;
    DWORD dwState;
    HRESULT hr = E_ADS_INVALID_FILTER;

    CAttrList* pAttrList = new CAttrList;
    if (!pAttrList)
        return E_OUTOFMEMORY;

    CSyntaxNode *pSynNode = NULL;
    CQueryNode *pNode1 = NULL;
    CQueryNode *pNode2 = NULL;
    CQueryNode *pNode3 = NULL;
    
    // Push in State 0
    pSynNode = new CSyntaxNode;
    Stack.Push(pSynNode);
    pSynNode = NULL;

#ifdef DEBUG_DUMPSTACK
    Stack.Dump();
#endif

    while (1) {
        // Getting information for this iteration, dwToken and dwState
        hr = Query.GetCurrentToken(
                                &lexeme,
                                &dwToken 
                                );
        BAIL_ON_FAILURE(hr);

        hr = Stack.Current(&pSynNode);
        BAIL_ON_FAILURE(hr);
        
        dwState = pSynNode->_dwState;
        pSynNode = NULL;
        
        // Analysing and processing the data 
        if (g_action[dwState][dwToken].type == S) {
            pSynNode = new CSyntaxNode;
            pSynNode->_dwState = g_action[dwState][dwToken].dwState;
            pSynNode->_dwToken = dwToken;
            switch (dwToken) {
                case TOKEN_ATTRTYPE:
                {
                    hr = pAttrList->Add(lexeme);
                    BAIL_ON_FAILURE(hr);
                }
                case TOKEN_ATTRVAL:
                // both TOKEN_ATTRTYPE and TOKEN_ATTRVAL will get here
                {    
                    LPWSTR szValue = AllocADsStr(lexeme);
                    if (!szValue) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    pSynNode->SetNode(szValue);
                    break;
                }
            }
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;

            hr = Query.GetNextToken(
                               &lexeme,
                               &dwToken
                               );
            BAIL_ON_FAILURE(hr);
#ifdef DEBUG_DUMPSTACK
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == R) {
            DWORD dwRule = g_action[dwState][dwToken].dwState;
            DWORD dwNumber = g_rule[dwRule].dwNumber;
#ifdef DEBUG_DUMPRULE             
            wprintf(L"%s\n",g_rgszRule[dwRule]);
#endif            
            pSynNode = new CSyntaxNode;
            CSyntaxNode *pSynNodeRed;
            switch (dwRule) {
                case 1:  // Reduction of Basic Filter rule
                {
                    // Getting the middle node

                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);

                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    break;
                }
                case 18: // Reduction of PRESENT rule
                {
                    // Getting second node
                    LPWSTR szType;
                    
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szType = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeLeaf(
                               szType,
                               &pNode1
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeNode(
                               QUERY_PRESENT,
                               pNode1,
                               NULL,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    pNode1 = NULL;

                    pSynNode->SetNode(
                              pNode2
                              );
                    pNode2 = NULL;
                    break;
                }
                case 14:    // Reduction of SMP rule 
                {
                    LPWSTR szType;
                    LPWSTR szValue;
                    DWORD dwType;
                    DWORD dwToken;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szValue = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwToken = (DWORD)pSynNodeRed->_dwFilterType;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    szType = pSynNodeRed->_szValue;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeLeaf(
                               szType,
                               &pNode1
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeLeaf(
                               szValue,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MapTokenToType(
                                   dwToken,
                                   &dwType
                                   );
                    BAIL_ON_FAILURE(hr);
                    
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               pNode2,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    pNode3 = NULL;

                    break;
                }
                case 6:     // Reduction of AND, OR rules
                case 7:
                {
                    DWORD dwType;
                    
                    Stack.Pop(&pSynNodeRed);
                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    Stack.Pop();
                    
                    // Adding in the type information
                    if (dwRule == 6)
                        dwType = QUERY_AND;
                    else
                        dwType = QUERY_OR;
                    
                    pSynNode->_pNode->_dwType = dwType;
                    break;
                }
                case 10:    // Reduction of FL rule
                {
                    DWORD dwType;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode2 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    if (pNode2->_dwType == QUERY_UNKNOWN) {
                        // It's not new node, append to node1
                        hr = pNode2->AddChild(pNode1);
                        BAIL_ON_FAILURE(hr);
                        pSynNode->SetNode(
                                  pNode2
                                  );
                        pNode1 = NULL;
                        pNode2 = NULL;
                    }
                    else {
                        // New node
                        hr = MakeNode(
                                   QUERY_UNKNOWN,
                                   pNode1,
                                   pNode2,
                                   &pNode3
                                   );
                        BAIL_ON_FAILURE(hr);
                        pSynNode->SetNode(
                                  pNode3
                                  );
                        pNode1 = NULL;
                        pNode2 = NULL;
                        pNode3 = NULL;
                    }
                    break;
                }
                case 9:    // Reduction of FL rule
                {
                    DWORD dwType;
                    
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeNode(
                               QUERY_UNKNOWN,
                               pNode1,
                               NULL,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode3 = NULL;
                    break;
                }
                case 8:     // Reduction of NOT rule
                {
                    Stack.Pop(&pSynNodeRed);
                    pNode1 = pSynNodeRed->_pNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    
                    hr = MakeNode(
                               QUERY_NOT,
                               pNode1,
                               NULL,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    pNode1 = NULL;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode2
                              );
                    pNode2 = NULL;
                    break;
                }
                case 15:    // Reduction of FT rule
                case 16:
                case 17:
                case 19:
                {
                    // Propagating the last entry
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_dwToken
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                default:
                {
                    // For all the other rules, we propogate the last entry
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_pNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    for (DWORD i = 0;i<dwNumber-1;i++)
                        Stack.Pop();
                }
            }
            hr = Stack.Current(&pSynNodeRed);
            BAIL_ON_FAILURE(hr);
            
            dwState = pSynNodeRed->_dwState;
            DWORD A = g_rule[dwRule].dwA;
            pSynNode->_dwState = g_goto[dwState][A];
            pSynNode->_dwToken = A;
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;
#ifdef DEBUG_DUMPSTACK
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == A){
            hr = Stack.Pop(&pSynNode);
            BAIL_ON_FAILURE(hr);
            *ppNode = pSynNode->_pNode; 
            *ppAttrList = pAttrList;
            pSynNode->_dwType = SNODE_NULL;
            delete pSynNode;
            return S_OK;
        }
        else {
            hr = E_ADS_INVALID_FILTER;
            goto error;
        }
    }
error:
    if (pAttrList) {
        delete pAttrList;
    }
    if (pSynNode) {
        delete pSynNode;
    }
    if (pNode1) {
        delete pNode1;
    }
    if (pNode2) {
        delete pNode2;
    }
    if (pNode3) {
        delete pNode3;
    }
    return hr;
}

                
CStack::CStack()
{
    _dwStackIndex = 0;
}

CStack::~CStack()
{
    DWORD dwIndex = _dwStackIndex;
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        delete pNode;
    }
}

#ifdef DEBUG_DUMPSTACK
void CStack::Dump()
{
    DWORD dwIndex = _dwStackIndex;
    printf("Stack:\n");
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        printf(
           "State=%5.0d, Token=%5.0d\n",
           pNode->_dwState,
           pNode->_dwToken
           );
    }
}
#endif

HRESULT CStack::Push(CSyntaxNode* pNode)
{
    if (_dwStackIndex < MAXVAL) {
        _Stack[_dwStackIndex++] = pNode;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT CStack::Pop(CSyntaxNode** ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[--_dwStackIndex];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Pop()
{
    if (_dwStackIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--_dwStackIndex];
        delete pNode;
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Current(CSyntaxNode **ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[_dwStackIndex-1];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

CAttrList::CAttrList()
{
    _rgAttr = NULL;
    _dwAttrCur = 0;
}

CAttrList::~CAttrList()
{
    if (_rgAttr) {
        for (DWORD i=0;i<_dwAttrCur;i++) 
            FreeADsStr(_rgAttr[i].szName);
        FreeADsMem(_rgAttr);
    }
}

HRESULT CAttrList::Add(LPWSTR szName)
{
    HRESULT hr = S_OK;
    LPWSTR pszTemp = NULL;

    for (DWORD i=0;i<_dwAttrCur;i++) {
        if (_wcsicmp(
                szName,
                _rgAttr[i].szName
                ) == 0)
            break;
    }
    
    if (i != _dwAttrCur)    // does not loop till the end, entry exist already
        return S_OK;
        
    LPWSTR szAttr = AllocADsStr(szName);
    if (!szAttr)
        return E_OUTOFMEMORY;

    if (_dwAttrCur == _dwAttrMax) {
        if (!_rgAttr) {
            _rgAttr = (AttrNode*)AllocADsMem(ATTRNODE_INITIAL*sizeof(AttrNode));
            if (!_rgAttr) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            _dwAttrMax = ATTRNODE_INITIAL;
        }
        else {
            _rgAttr = (AttrNode*)ReallocADsMem(
                                             (void*)_rgAttr,
                                             _dwAttrMax*sizeof(AttrNode),
                                             (_dwAttrMax+ATTRNODE_INC)*sizeof(AttrNode)
                                             );
            if (!_rgAttr) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            _dwAttrMax+= ATTRNODE_INC;
        }
    }
    _rgAttr[_dwAttrCur].szName = szAttr;
    _rgAttr[_dwAttrCur].dwType = 0;     //UNKNOWN at this point
    _dwAttrCur++;
    return S_OK;
error:
    if (szAttr)
        FreeADsStr(szAttr);
    return (hr);
}

HRESULT CAttrList::SetupType(LPWSTR szConnection)
{
    DWORD dwStatus;
    HRESULT hr=S_OK;
    HANDLE hOperationData = NULL;
    DWORD dwNumberOfEntries;
    DWORD dwInfoType;
    LPNDS_ATTR_DEF lpAttrDefs = NULL;
    HANDLE hConnection = NULL;
    DWORD i,j,k;
    
    dwStatus = NwNdsOpenObject( 
                          szConnection,
                          NULL,
                          NULL,
                          &hConnection,
                          NULL,
                          NULL,
                          NULL,
                          0,
                          0
                          );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    dwStatus = NwNdsCreateBuffer( 
                       NDS_SCHEMA_READ_ATTR_DEF,
                       &hOperationData 
                       );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    for (i=0;i<_dwAttrCur;i++) {
        dwStatus = NwNdsPutInBuffer( 
                           _rgAttr[i].szName,
                           0,
                           NULL,
                           0,
                           0,
                           hOperationData 
                           );
        if (dwStatus) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }
    
    dwStatus = NwNdsReadAttrDef( 
                        hConnection,
                        NDS_INFO_NAMES_DEFS,
                        &hOperationData 
                        );
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = NwNdsGetAttrDefListFromBuffer( 
                                    hOperationData,
                                    &dwNumberOfEntries,
                                    &dwInfoType,
                                    (LPVOID *) &lpAttrDefs 
                                    );
    
    if (dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    if (dwNumberOfEntries != _dwAttrCur) {
        hr = E_ADS_INVALID_FILTER;
        goto error;
    }

    for (j = 0; j < dwNumberOfEntries ; j++ ) {
        for (k = 0; k < dwNumberOfEntries; k++) {
            if (_wcsicmp(
                    _rgAttr[k].szName,
                    lpAttrDefs[j].szAttributeName
                    ) == 0) {
                _rgAttr[k].dwType = lpAttrDefs[j].dwSyntaxID;
            break;
            }
        }
        if (k == dwNumberOfEntries)     // cannot find entry
            goto error;
    }

error:
    if (hOperationData)
        NwNdsFreeBuffer( hOperationData );
    if (hConnection)
        NwNdsCloseObject( hConnection);
    RRETURN(hr);
}

HRESULT CAttrList::GetType(LPWSTR szName, DWORD *pdwType)
{
    for (DWORD i=0;i<_dwAttrCur;i++) {
        if (_wcsicmp(
                szName,
                _rgAttr[i].szName
                ) == 0)
            break;
    }
    
    if (i == _dwAttrCur)    // Cannot find attribute
        return E_FAIL;

    *pdwType = _rgAttr[i].dwType;
    return S_OK;
}

CSyntaxNode::CSyntaxNode()
{
    _dwType = SNODE_NULL;
    _dwToken = 0;
    _dwState = 0;
    _pNode = 0;
}

CSyntaxNode::~CSyntaxNode()
{
    switch (_dwType) {
        case SNODE_SZ:
            FreeADsStr(_szValue);
            break;
        case SNODE_NODE:
            delete _pNode;
            break;
        default:
            break;
    }
}

void CSyntaxNode::SetNode(
                    CQueryNode *pNode
                    )       
{
    _pNode = pNode;
    _dwType = SNODE_NODE;
}

void CSyntaxNode::SetNode(
                     LPWSTR szValue
                     )       
{
    _szValue = szValue;
    _dwType = SNODE_SZ;
}

void CSyntaxNode::SetNode(
                    DWORD dwFilterType
                    )       
{
    _dwFilterType = dwFilterType;
    _dwType = SNODE_FILTER;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::CQueryNode
//
//  Synopsis:  Constructor of the CQueryNode
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CQueryNode::CQueryNode()
{
    _dwType = 0;
    _szValue = NULL;
    _dwQueryNode = 0;
    _rgQueryNode = NULL;
    _dwQueryNodeMax = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::SetToString
//
//  Synopsis:  Set the Node to be a String Node
//
//  Arguments: szValue      value of the string
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::SetToString(
    LPWSTR szValue
    )
{
    _szValue = szValue;
    /*
    _szValue = AllocADsStr(szValue);
    if (!_szValue) {
        return E_OUTOFMEMORY;
    }
    */
    _dwType = QUERY_STRING;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::~CQueryNode
//
//  Synopsis:  Destructor of the CQueryNode
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CQueryNode::~CQueryNode()
{
    if (_szValue)
        FreeADsStr(_szValue);
    if (_rgQueryNode) {
        for (DWORD i=0;i<_dwQueryNode;i++) {
            delete _rgQueryNode[i];
        }
        FreeADsMem(_rgQueryNode);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::AddChild
//
//  Synopsis:  Add a child to the node
//
//  Arguments: CQueryNode *pChild   pointer to the child to be added
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::AddChild(CQueryNode *pChild)
{
    if (_dwQueryNode == _dwQueryNodeMax) {
        if (!_rgQueryNode) {
            _rgQueryNode = (CQueryNode**)AllocADsMem(QUERYNODE_INITIAL*sizeof(CQueryNode*));
            if (!_rgQueryNode) {
                return E_OUTOFMEMORY;
            }
            _dwQueryNodeMax = QUERYNODE_INITIAL;
        }
        else {
            _rgQueryNode = (CQueryNode**)ReallocADsMem(
                                             (void*)_rgQueryNode,
                                             _dwQueryNodeMax*sizeof(CQueryNode*),
                                             (_dwQueryNodeMax+QUERYNODE_INC)*sizeof(CQueryNode*)
                                             );
            if (!_rgQueryNode) {
                return E_OUTOFMEMORY;
            }
            _dwQueryNodeMax+= QUERYNODE_INC;
        }
    }
    _rgQueryNode[_dwQueryNode] = pChild;
    _dwQueryNode++;
    return S_OK;
}
//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::GenerateNDSTree
//
//  Synopsis:  Generate an NDS tree with the current CQueryNode
//
//  Arguments:  pAttrList       list of attributes to get syntax info
//              ppNDSSearchTree output of NDS Search Tree generated
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::GenerateNDSTree(
    CAttrList *pAttrList,
    LPQUERY_NODE *ppNDSSearchTree
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwOperation;
    DWORD dwStatus = 0;

    LPWSTR szAttr = NULL;
    LPWSTR szValue = NULL;
    LPQUERY_NODE pQueryNode1 = NULL;
    LPQUERY_NODE pQueryNode2 = NULL;
    LPQUERY_NODE pQueryNode3 = NULL;


    // Looking at type of operation
    switch (_dwType) {
        case QUERY_EQUAL:
        case QUERY_LE:
        case QUERY_GE:
        case QUERY_APPROX:
        case QUERY_PRESENT:
        {
            ASN1_TYPE_1 Asn1_WSTR;
            ASN1_TYPE_7 Asn1_BOOL;
            ASN1_TYPE_8 Asn1_DWORD;
            ASN1_TYPE_9 Asn1_Binary;
            void*   pValue = NULL;
            DWORD dwSyntax;
            DWORD dwAttrType = 0;
            LPWSTR pszTemp = NULL;

            // Getting left node
            if (_rgQueryNode[0] &&
                _rgQueryNode[0]->_dwType == QUERY_STRING) {
                szAttr = AllocADsStr(_rgQueryNode[0]->_szValue);
                if (!szAttr) {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }

            }
            else {
                // No nodes available
                goto error;
            }

            // Getting right node
            if (_rgQueryNode[1] &&
                _rgQueryNode[1]->_dwType == QUERY_STRING) {

                // Get syntax info of right node from attribute list
                hr = pAttrList->GetType(
                                   szAttr,
                                   &dwAttrType
                                   );
                BAIL_ON_FAILURE(hr);

                // Format the node depending on the syntax
                switch (dwAttrType) {
                    // WIDE STRING
                    case NDS_SYNTAX_ID_1:
                    case NDS_SYNTAX_ID_2:
                    case NDS_SYNTAX_ID_3:
                    case NDS_SYNTAX_ID_4:
                    case NDS_SYNTAX_ID_5:
                    case NDS_SYNTAX_ID_10:
                    case NDS_SYNTAX_ID_11:
                    case NDS_SYNTAX_ID_20:
                        szValue = AllocADsStr(_rgQueryNode[1]->_szValue);
                        if (!szValue) {
                            hr = E_OUTOFMEMORY;
                            goto error;
                        }
                        Asn1_WSTR.DNString = szValue;
                        pValue = (void*)&Asn1_WSTR;
                        break;

                    // BOOLEAN
                    case NDS_SYNTAX_ID_7:
                        Asn1_BOOL.Boolean = _wtoi(_rgQueryNode[1]->_szValue);
                        pValue = (void*)&Asn1_BOOL;
                        break;

                    // Binary Strings
                    case NDS_SYNTAX_ID_9:
                        {
                            //
                            // change the unicode form of binary encoded data
                            // to binary 
                            // L"0135ABCDEF0" gets changed to 0x0135ABCDEF0
                            // same as the Ldap client code. 
                            //

                            hr = ADsDecodeBinaryData (
                               _rgQueryNode[1]->_szValue,
                               &Asn1_Binary.OctetString,
                               &Asn1_Binary.Length);
                            BAIL_ON_FAILURE(hr);

                            pValue = (void*)&Asn1_Binary;
                        }
                        break;
                    
                    // TimeStamp
                    case NDS_SYNTAX_ID_24 :
                        {
                        SYSTEMTIME st;
                        TCHAR sz[3];
                        LPWSTR pszSrc = _rgQueryNode[1]->_szValue;
                        //
                        // Year
                        //
                        sz[0] = pszSrc[0];
                        sz[1] = pszSrc[1];
                        sz[2] = TEXT('\0');
                        st.wYear = (WORD) _ttoi(sz);
                        if (st.wYear < 50)
                        {
                            st.wYear += 2000;
                        }
                        else
                        {
                            st.wYear += 1900;
                        }
                        //
                        // Month
                        //
                        sz[0] = pszSrc[2];
                        sz[1] = pszSrc[3];
                        st.wMonth = (WORD) _ttoi(sz);
                        //
                        // Day
                        //
                        sz[0] = pszSrc[4];
                        sz[1] = pszSrc[5];
                        st.wDay = (WORD) _ttoi(sz);
                        //
                        // Hour
                        //
                        sz[0] = pszSrc[6];
                        sz[1] = pszSrc[7];
                        st.wHour = (WORD) _ttoi(sz);
                        //
                        // Minute
                        //
                        sz[0] = pszSrc[8];
                        sz[1] = pszSrc[9];
                        st.wMinute = (WORD) _ttoi(sz);
                        //
                        // Second
                        //
                        sz[0] = pszSrc[10];
                        sz[1] = pszSrc[11];
                        st.wSecond = (WORD) _ttoi(sz);
                        st.wMilliseconds = 0;
                               
                        hr = ConvertSYSTEMTIMEtoDWORD(
                                    &st,
                                    &Asn1_DWORD.Integer
                                    );
                        BAIL_ON_FAILURE (hr);
                        pValue = (void*)&Asn1_DWORD;
                        break;
                        }
                    // DWORD
                    case NDS_SYNTAX_ID_8 :
                    case NDS_SYNTAX_ID_22 :
                    case NDS_SYNTAX_ID_27 :
                        Asn1_DWORD.Integer = _wtol(_rgQueryNode[1]->_szValue);
                        pValue = (void*)&Asn1_DWORD;
                        break;

                    case NDS_SYNTAX_ID_6 :
                    case NDS_SYNTAX_ID_13 :
                    case NDS_SYNTAX_ID_14 :
                    case NDS_SYNTAX_ID_15 :
                    case NDS_SYNTAX_ID_16 :
                    case NDS_SYNTAX_ID_17 :
                    case NDS_SYNTAX_ID_18 :
                    case NDS_SYNTAX_ID_19 :
                    case NDS_SYNTAX_ID_23 :
                    case NDS_SYNTAX_ID_25 :
                    case NDS_SYNTAX_ID_26 :
                    default:
                        hr = E_ADS_CANT_CONVERT_DATATYPE;
                        goto error;
                        break;
                }
            }

            hr = MapQueryToNDSType(
                                _dwType,
                                &dwOperation
                                );
            BAIL_ON_FAILURE (hr);

            dwStatus = NwNdsCreateQueryNode(
                           dwOperation,
                           szAttr,
                           dwAttrType,
                           pValue,
                           ppNDSSearchTree
                           );
            if (dwStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                RRETURN (hr);
            }

            if (szAttr)
                FreeADsStr(szAttr);
            if (szValue)
                FreeADsStr(szValue);
            break;
        }
        case QUERY_AND:
        case QUERY_OR:
            {
            hr = MapQueryToNDSType(
                                _dwType,
                                &dwOperation
                                );
            BAIL_ON_FAILURE (hr);

            // Create first node
            if (!_rgQueryNode[0])
                goto error;

            hr = _rgQueryNode[0]->GenerateNDSTree(
                                            pAttrList,
                                            &pQueryNode1
                                            );
            BAIL_ON_FAILURE (hr);

            // Go through a loop creating the rest
            for (DWORD i=1;i<_dwQueryNode;i++) {
                if (!_rgQueryNode[i])
                    goto error;

                hr = _rgQueryNode[i]->GenerateNDSTree(
                                                pAttrList,
                                                &pQueryNode2
                                                );
                BAIL_ON_FAILURE (hr);

                dwStatus = NwNdsCreateQueryNode(
                               dwOperation,
                               pQueryNode1,
                               NULL,           //not used since this is AND/OR/NOT
                               pQueryNode2,
                               &pQueryNode3
                               );
                if (dwStatus) {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    RRETURN (hr);
                }
                pQueryNode1 = pQueryNode3;
            }
            *ppNDSSearchTree = pQueryNode1;
            break;
            }
        case QUERY_NOT:
            {
            hr = MapQueryToNDSType(
                                _dwType,
                                &dwOperation
                                );
            BAIL_ON_FAILURE (hr);

            // Create first node
            if (!_rgQueryNode[0])
                goto error;

            hr = _rgQueryNode[0]->GenerateNDSTree(
                                            pAttrList,
                                            &pQueryNode1
                                            );
            BAIL_ON_FAILURE (hr);

            hr = NwNdsCreateQueryNode(
                                    dwOperation,
                                    pQueryNode1,
                                    NULL,
                                    NULL,
                                    &pQueryNode3
                                    );
            BAIL_ON_FAILURE (hr);
            *ppNDSSearchTree = pQueryNode3;
            break;
            }
        default:
            goto error;
    }
    RRETURN(hr);

error:
    if (pQueryNode1)
        NwNdsDeleteQueryTree(pQueryNode1);
    if (pQueryNode2)
        NwNdsDeleteQueryTree(pQueryNode2);
    if (szAttr)
        FreeADsStr(szAttr);
    if (szValue)
        FreeADsStr(szValue);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:  CQueryNode::MapQueryToNDSType
//
//  Synopsis:  Maps the node type to the equivalent NDS types
//
//  Arguments:  dwType      input type
//              pdwNDSType  output type
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CQueryNode::MapQueryToNDSType(
                                DWORD dwType,
                                DWORD *pdwNDSType
                                )
{
    DWORD dwNDSType;
    switch(dwType) {
        case QUERY_EQUAL:
            dwNDSType = NDS_QUERY_EQUAL;
            break;
        case QUERY_LE:
            dwNDSType = NDS_QUERY_LE;
            break;
        case QUERY_GE:
            dwNDSType = NDS_QUERY_GE;
            break;
        case QUERY_APPROX:
            dwNDSType = NDS_QUERY_APPROX;
            break;
        case QUERY_PRESENT:
            dwNDSType = NDS_QUERY_PRESENT;
            break;
        case QUERY_NOT:
            dwNDSType = NDS_QUERY_NOT;
            break;
        case QUERY_AND:
            dwNDSType = NDS_QUERY_AND;
            break;
        case QUERY_OR:
            dwNDSType = NDS_QUERY_OR;
            break;

        default:
            return (E_ADS_INVALID_FILTER);
    }
    *pdwNDSType = dwNDSType;
    return (S_OK);
}


// Helper Functions for creating nodes using the CQueryNode Class

//+---------------------------------------------------------------------------
//
//  Function:  MakeNode
//
//  Synopsis:  Make a node with the input values
//
//  Arguments:  dwType              type of node
//              pLQueryNode         pointer to left node
//              pRQueryNode         pointer to right node
//              ppQueryNodeReturn   pointer to Return Node
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeNode(
    DWORD dwType,
    CQueryNode *pLQueryNode,
    CQueryNode *pRQueryNode,
    CQueryNode **ppQueryNodeReturn
    )
{
    HRESULT hr = S_OK;

    CQueryNode *pQueryNode = new CQueryNode();
    if (!pQueryNode)
        return E_OUTOFMEMORY;

    pQueryNode->_dwType = dwType;

    hr = pQueryNode->AddChild(pLQueryNode);
    BAIL_ON_FAILURE(hr);

    if (pRQueryNode) {
                pQueryNode->AddChild(pRQueryNode);
                BAIL_ON_FAILURE(hr);
        }
    *ppQueryNodeReturn = pQueryNode;

    RRETURN(hr);

error:
    delete pQueryNode;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:  MakeLeaf
//
//  Synopsis:  Constructor of the CQueryNode
//
//  Arguments: szValue              value of the string
//             ppQueryNodeReturn    the return node
//
//  Returns:
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeLeaf(
    LPWSTR szValue,
    CQueryNode **ppQueryNodeReturn
    )
{
    HRESULT hr = S_OK;

    CQueryNode *pQueryNode = new CQueryNode();
    if (!pQueryNode)
        return E_OUTOFMEMORY;

    hr = pQueryNode->SetToString(szValue);
    BAIL_ON_FAILURE(hr);

    *ppQueryNodeReturn = pQueryNode;
    RRETURN(hr);

error:
    delete pQueryNode;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:  ADsNdsGenerateParseTree
//
//  Synopsis: Generate an NDS search tree to be used as inputs to NDS search
//            functions
//
//  Arguments:  pszCommandText - Command text for the search
//              szConnection - server to get the schema from
//              ppQueryNode - the generated NDS search tree
//
//  Returns:    HRESULT
//                  S_OK                    NO ERROR
//                  E_OUTOFMEMORY           no memory
//
//  Modifies:
//
//  History:    10-29-96   Felix Wong  Created.
//
//----------------------------------------------------------------------------
HRESULT
AdsNdsGenerateParseTree(
    LPWSTR szCommandText,
    LPWSTR szConnection,
    LPQUERY_NODE *ppQueryNode
)
{
    HRESULT hr;
    LPQUERY_NODE pNDSSearchTree;
    CQueryNode *pNode = NULL;
    CAttrList *pAttrList = NULL;


    // Generate the parse tree and the attribute list
    hr = Parse(
            szCommandText,
            &pNode,
            &pAttrList
            );
    BAIL_ON_FAILURE(hr);


    // Setup syntax information in the attribute list
    hr = pAttrList->SetupType(szConnection);
    BAIL_ON_FAILURE(hr);


    // Generate the NDS tree
    hr = pNode->GenerateNDSTree(
                        pAttrList,
                        &pNDSSearchTree
                        );
    BAIL_ON_FAILURE(hr);

    *ppQueryNode = pNDSSearchTree;

error:
    if (pNode)
        delete pNode;
    if (pAttrList)
        delete pAttrList;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\nds\var2sec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "nds.hxx"
#pragma hdrstop


HRESULT
ConvertSecDesToNDSAclVarArray(
    IADsSecurityDescriptor *pSecDes,
    PVARIANT pvarNDSAcl
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        hr = E_FAIL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);

    hr = ConvertAccessControlListToNDSAclVarArray(
                pDiscAcl,
                pvarNDSAcl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertAccessControlListToNDSAclVarArray(
    IADsAccessControlList FAR * pAccessList,
    PVARIANT pvarNDSAcl
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    VARIANT varAce;
    DWORD dwAceCount = 0;
    DWORD cReturned = 0;
    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;
    VARIANT varNDSAce;

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    
    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);


    VariantInit(pvarNDSAcl);
    aBound.lLbound = 0;
    aBound.cElements = dwAceCount;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);


        hr = ConvertAccessControlEntryToAceVariant(
                    pAccessControlEntry,
                    &varNDSAce
                    );
        CONTINUE_ON_FAILURE(hr);


        //
        // Add the NDSAce into your Safe Array
        //
        hr = SafeArrayPutElement( aList, (long*)&i, &varNDSAce );


        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }
        //dwCount++;
    }

    //
    // Return the Safe Array back to the caller
    //
    V_VT(pvarNDSAcl) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvarNDSAcl) = aList;

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }


    RRETURN(hr);
}

HRESULT
ConvertAccessControlEntryToAceVariant(
    IADsAccessControlEntry * pAccessControlEntry,
    PVARIANT pvarNDSAce
    )
{
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    BSTR bstrObjectTypeClsid = NULL;
    IADsAcl * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    DWORD dwAccessMask;

    VariantInit(pvarNDSAce);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = CAcl::CreateSecurityDescriptor(
                IID_IADsAcl,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SubjectName(bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_ProtectedAttrName(bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Privileges(dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    V_VT(pvarNDSAce) = VT_DISPATCH;
    V_DISPATCH(pvarNDSAce) = pDispatch;

error:
    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\exe\globals.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    globals.cpp

Abstract:

    This file contains global variables

Environment:

    User mode

Revision History:

    08/04/98 -felixw-
        Created it

--*/
#include "main.h"

//
// Global variables
//
const CHAR g_szAttributeNameA[] = "MSFT1991:objectGUID";
const WCHAR g_szAttributeName[] = L"MSFT1991:objectGUID";
const CHAR g_szClassA[]         = "Top";
const WCHAR g_szClass[]         = L"Top";
const WCHAR g_szExtend[]        = L"Extend";
const WCHAR g_szCheck[]         = L"Check";
const WCHAR g_szDot[]           = L".";
const WCHAR g_szServerPrefix[]  = L"\\\\";
const BYTE g_pbASN[] = { 0x06, 0x0a, 0x60, 0x86, 0x48, 0x01, 0x86, 0xf8, 0x37, 0x02, 0x81, 0x02};
const DWORD g_dwASN = sizeof(g_pbASN) / sizeof(BYTE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\exe\globals.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This file contains global variables extern declarations

Environment:

    User mode

Revision History:

    08/04/98 -felixw-
        Created it

--*/

#ifndef _EXTERN_H_
#define _EXTERN_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Global variables
//
extern const CHAR g_szAttributeNameA[];
extern const WCHAR g_szAttributeName[];
extern const WCHAR g_szClass[];
extern const CHAR g_szClassA[];
extern const WCHAR g_szExtend[];
extern const WCHAR g_szCheck[];
extern const WCHAR g_szDot[];
extern const WCHAR g_szServerPrefix[];
extern const BYTE g_pbASN[];
extern const DWORD g_dwASN;

#ifdef __cplusplus
}
#endif

#endif  // ifndef _EXTERN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\adsi\ndsext\exe\main.cpp ===
#include "main.h"

#define     PWLEN           256

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    );

extern "C" int __cdecl wmain(
    IN  int     argc,
    IN  PWSTR  argv[]
)
{
    DWORD WinError = 0;
    PWSTR szTree = NULL;
    PWSTR szUser = NULL;
    PWSTR szContext = NULL;
    PWSTR szPwd = NULL;
    WCHAR szBuffer[PWLEN+1];
    DWORD dwLength;

    InitMem();

    //
    // either with 4 parameters or 2
    //
    if((argc != 5) && (argc != 3)) {
        SelectivePrint(MSG_HELP);
        BAIL();
    }

    if (argc == 5) {
        if (!(argv[1] && argv[2] && argv[3] && argv[4])) {
            SelectivePrint(MSG_HELP);
            BAIL();
        }
    }
    else {
        ASSERT(argc == 3);
        if (!(argv[1] && argv[2])) {
            SelectivePrint(MSG_HELP);
            BAIL();
        }
    }

    szTree = argv[2];

    if (argc == 5) {
        szUser = argv[3];
        szPwd = argv[4];

        if ((wcscmp(szPwd,L"*") == 0)) {
    
            SelectivePrint(MSG_GETPASSWORD,
                           szTree);
        
            if (GetPassword(szBuffer,PWLEN+1,&dwLength)) {
                szPwd = szBuffer;   
            }
            else {
                SelectivePrint(MSG_PASSWORDTOLONG);
                BAIL();
            }
        }
    
        while (*szUser) {
            if (*szUser == '.') {
                *szUser = NULL;
                szContext = szUser+1;
                bre