ATUS_PIPE_DISCONNECTED ) {
            UnlockWinStation( pWinStation );
            Timeout = RtlEnlargedIntegerMultiply( 10000, -10000 );
            WaitStatus = NtWaitForSingleObject( hTargetThread,
                                                FALSE, &Timeout );
            RelockWinStation( pWinStation );
        }
        if ( pWinStation->ShadowTargetStatus ) {
            Status = pWinStation->ShadowTargetStatus;
        }
        goto badconnect;
    }

#ifdef notdef
    /*
     * Now accept the shadow target connection
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_OPEN_ENDPOINT,
                                pEndpoint,
                                EndpointLength,
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS( Status ) )
        goto badaccept;
#endif

    /*
     * Enable I/O for the passthru stack
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_ENABLE_IO,
                                NULL,
                                0,
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badenableio;

    /*
     * Since we don't do the stack query for a shadow stack,
     * simply call an ioctl to mark the stack as connected now.
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_SET_CONNECTED,
                                NULL,
                                0,
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS( Status ) )
        goto badsetconnect;

    /*
     * Wait for shadow broken event to be triggered
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Waiting for BrokenEvent(%ld) = %p\n",
      pWinStation->LogonId, pWinStation->ShadowBrokenEvent));    

    if( !bShadowerHelpSession ) {
        /*
         * Notify WinLogon shadow Started.
         */
        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = FALSE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_DisableScrnSaver;
        Status = SendWinStationCommand( pWinStation, &msg, 0 );

        //
        // Not critical, just performance issue
        //
        ASSERT( NT_SUCCESS( Status ) );
    }    

    UnlockWinStation( pWinStation );



    Status = NtWaitForSingleObject( pWinStation->ShadowBrokenEvent, FALSE, NULL );


    RelockWinStation( pWinStation );

    if( !bShadowerHelpSession ) {

        /*
         * Notify WinLogon shadow Ended.
         */
        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = FALSE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_EnableScrnSaver;
        Status = SendWinStationCommand( pWinStation, &msg, 0 );

        //
        // Not critical, just performance issue
        //
        ASSERT( NT_SUCCESS( Status ) );
    }

    /*
     * Disable I/O for the passthru stack
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_DISABLE_IO,
                                NULL,
                                0,
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Tell win32k about passthru mode being disabled
     */
    msg.ApiNumber = SMWinStationPassthruDisable;
    Status = SendWinStationCommand( pWinStation, &msg, 60 );
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Passthru mode disabled\n"));

    //ASSERT( NT_SUCCESS( Status ) );

    /*
     * Restore WinStation state
     */
    if ( pWinStation->State == State_Shadow ) {
        pWinStation->State = State_Active;
        NotifySystemEvent( WEVENT_STATECHANGE );
    }

    /*
     * Turn off hotkey registration
     */
    RtlZeroMemory( &Hotkey, sizeof(Hotkey) );
    if ( pWinStation->hStack ) {
        //  Check for availability
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxIcaStackIoControl ) {

            Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                    pWinStation->pWsxContext,
                                    pWinStation->hIca,
                                    pWinStation->hStack,
                                    IOCTL_ICA_STACK_REGISTER_HOTKEY,
                                    &Hotkey,
                                    sizeof(Hotkey),
                                    NULL,
                                    0,
                                    NULL );
        }
        else {
            Status = STATUS_CTX_SHADOW_INVALID;
        }

        ASSERT( NT_SUCCESS( Status ) );
    }

    /*
     * Close broken event and passthru stack
     */
    NtClose( pWinStation->ShadowBrokenEvent );
    pWinStation->ShadowBrokenEvent = NULL;

    if ( pWinStation->hPassthruStack ) {
        IcaStackConnectionClose( pWinStation->hPassthruStack,
                                 pShadowConfig,
                                 pEndpoint,
                                 EndpointLength );

        IcaStackClose( pWinStation->hPassthruStack );
        pWinStation->hPassthruStack = NULL;
    }

    MemFree( pEndpoint );

    /*
     * Now give target thread a chance to exit. If it fails to exit within the
     * allotted time period we just allow it to orphan and close its handle so
     * it will be destroyed when it finally does exit. This can occur in
     * highly loaded stress situations and is not part of normal execution.
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Waiting for target thread to exit\n"));
    UnlockWinStation( pWinStation );
    Timeout = RtlEnlargedIntegerMultiply( 5000, -10000 );
    WaitStatus = NtWaitForSingleObject( hTargetThread, FALSE, &Timeout );
    NtClose( hTargetThread );
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Target thread exit status: %lx\n",
           WaitStatus));

    /*
     * Relock WinStation and get target thread exit status
     */
    RelockWinStation( pWinStation );
    TargetStatus = pWinStation->ShadowTargetStatus;

    /*
     * If there is a shadow done event, then signal the waiter now
     */
    if ( pWinStation->ShadowDoneEvent )
        SetEvent( pWinStation->ShadowDoneEvent );

    /*
     * Release winstation
     */
    ReleaseWinStation( pWinStation );

    if (pShadowConfig != NULL) {
        MemFree(pShadowConfig);
        pShadowConfig = NULL;
    }
    return( TargetStatus );

/*=============================================================================
==   Error returns
=============================================================================*/

badsetconnect:
    if ( pWinStation->hPassthruStack ) {
        //  Check for availability
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxIcaStackIoControl ) {

            (void) pWinStation->pWsx->pWsxIcaStackIoControl(
                           pWinStation->pWsxContext,
                           pWinStation->hIca,
                           pWinStation->hPassthruStack,
                           IOCTL_ICA_STACK_DISABLE_IO,
                           NULL,
                           0,
                           NULL,
                           0,
                           NULL );
        }
    }

badenableio:

#ifdef notdef
badaccept:
#endif

    if ( pWinStation->hPassthruStack ) {
        IcaStackConnectionClose( pWinStation->hPassthruStack,
                                 pShadowConfig,
                                 pEndpoint,
                                 EndpointLength );
    }

badconnect:
    if ( pEndpoint )
        MemFree( pEndpoint );

badmalloc:
    UnlockWinStation( pWinStation );
    //Timeout = RtlEnlargedIntegerMultiply( 5000, -10000 );
    //WaitStatus = NtWaitForSingleObject( hTargetThread, FALSE, &Timeout );
    //ASSERT( WaitStatus == STATUS_SUCCESS );
    NtClose( hTargetThread );

    /*
     * Relock WinStation and get target thread exit status
     */
    RelockWinStation( pWinStation );
    if ( pWinStation->ShadowTargetStatus )
        Status = pWinStation->ShadowTargetStatus;

badthread:
badClientName:
    if ( pShadowParms )
        MemFree( pShadowParms );

badshadowparms:
    msg.ApiNumber = SMWinStationPassthruDisable;
    SendWinStationCommand( pWinStation, &msg, 60 );

badpassthru:
    if ( pWinStation->State == State_Shadow ) {
        pWinStation->State = State_Active;
        NotifySystemEvent( WEVENT_STATECHANGE );
    }
    RtlZeroMemory( &Hotkey, sizeof(Hotkey) );
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl && pWinStation->hStack) {

        (void) pWinStation->pWsx->pWsxIcaStackIoControl(
                       pWinStation->pWsxContext,
                       pWinStation->hIca,
                       pWinStation->hStack,
                       IOCTL_ICA_STACK_REGISTER_HOTKEY,
                       &Hotkey,
                       sizeof(Hotkey),
                       NULL,
                       0,
                       NULL );
    }

badhotkey:
badbroken:
    NtClose( pWinStation->ShadowBrokenEvent );
    pWinStation->ShadowBrokenEvent = NULL;

badevent:

#ifdef notdef
badshadowendpoint:
#endif

    if ( pWinStation->hPassthruStack ) {
        IcaStackClose( pWinStation->hPassthruStack );
        pWinStation->hPassthruStack = NULL;
    }

badstackopen:
badthinwiredata:
    if ( pThinwireData )
        MemFree( pThinwireData );
badwddata:
    if ( pModuleData )
        MemFree( pModuleData );
    if ( ImpersonationToken )
        NtClose( ImpersonationToken );
badAddress:
badtoken:
badstate:
    ReleaseWinStation( pWinStation );

badsetup:

    if (pShadowConfig != NULL) {
        MemFree(pShadowConfig);
        pShadowConfig = NULL;
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationShadowWorker, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *
 *  WinStationShadowTargetSetupWorker
 *
 *   Setup the target side of a Winstation shadow operation
 *
 * ENTRY:
 *   LogonId (input)
 *      client of the shadow
 *
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationShadowTargetSetupWorker(
    IN ULONG TargetLogonId )
{
    PWINSTATION pWinStation;
    NTSTATUS Status;

    /*
     * Find and lock target WinStation
     */
    pWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pWinStation == NULL ) {
        return( STATUS_ACCESS_DENIED );
    }

    /*
     * Check the target WinStation state.  We only allow shadow of
     * active (connected, logged on) WinStations.
     */
    if ( pWinStation->State != State_Active ) {
        Status = STATUS_CTX_SHADOW_INVALID;
        goto shadowinvalid;
    }

    /*
     * Stop attempts to shadow an RDP session that is already shadowed.
     * RDP stacks don't support that yet.
     * TODO: Add support for multiple RDP shadows.
     */
    if ((pWinStation->Config).Wd.WdFlag & WDF_TSHARE)
    {
        if ( !IsListEmpty( &pWinStation->ShadowHead ) ) {
            Status = STATUS_CTX_SHADOW_DENIED;
            goto shadowdenied;
        }
    }

    /*
     * Verify that client has WINSTATION_SHADOW access to the target WINSTATION
     */
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_SHADOW, TRUE );
    if ( !NT_SUCCESS( Status ) )
        goto shadowinvalid;


    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

shadowinvalid:
shadowdenied:
    ReleaseWinStation( pWinStation );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationShadowTargetSetupWorker, Status=0x%x\n", Status ));
    return( Status );
}





/*****************************************************************************
 *
 *  WinStationShadowTargetWorker
 *
 *   Start the target side of a Winstation shadow operation
 *
 * ENTRY:
 *   fResetShadowSetting(input)
 *      Reset session shadow class back to original value
 *   ShadowerIsHelpSession
 *      true if the shadowing session is logged in as help assistant.
 *   LogonId (input)
 *      client of the shadow
 *   pConfig (input)
 *      pointer to WinStation config data (for shadow stack)
 *   pAddress (input)
 *      address of shadow client
 *   pModuleData (input)
 *      pointer to client module data
 *   ModuleDataLength (input)
 *      length of client module data
 *   pThinwireData (input)
 *      pointer to thinwire module data
 *   ThinwireDataLength (input)
 *      length of thinwire module data
 *   pClientName (input)
 *      pointer to client name string (domain/username)
 *
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationShadowTargetWorker(
    IN BOOLEAN ShadowerIsHelpSession,
    IN BOOL fResetShadowSetting,
    IN ULONG TargetLogonId,
    IN PWINSTATIONCONFIG2 pConfig,
    IN PICA_STACK_ADDRESS pAddress,
    IN PVOID pModuleData,
    IN ULONG ModuleDataLength,
    IN PVOID pThinwireData,
    IN ULONG ThinwireDataLength,
    IN PVOID pClientName)

{
    PWINSTATION pWinStation;
    WINSTATION_APIMSG msg;
    ULONG ShadowResponse;
    OBJECT_ATTRIBUTES ObjA;
    PSHADOW_INFO pShadow;
    ICA_STACK_BROKEN Broken;
    NTSTATUS Status, Status2, EndStatus = STATUS_SUCCESS;
    BOOLEAN fConcurrentLicense = FALSE;
    DWORD ProtocolMask;
    BOOLEAN fChainedDD = FALSE;
    int cchTitle, cchMessage;

    ULONG shadowIoctlCode;

    HANDLE hIca;
    HANDLE hStack;
    PWSEXTENSION pWsx;
    PVOID pWsxContext;

    BOOL bResetStateFlags = FALSE;

    HANDLE ChannelHandle;

    /*
     * Find and lock target WinStation
     */
    pWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pWinStation == NULL ) {

        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    //
    // save current the console winstation parameters and
    // set them to the global values.
    //

    if (pWinStation->fOwnsConsoleTerminal) {
        hIca = pWinStation->hIca;
        hStack = pWinStation->hStack;
        pWsx = pWinStation->pWsx;
        pWsxContext = pWinStation->pWsxContext;
    }

    /*
     * Check the target WinStation state.  We only allow shadow of
     * active (connected, logged on) WinStations.
     */
    if ( pWinStation->State != State_Active ) {


        // the line below is the fix for bug #230870
        Status = STATUS_CTX_SHADOW_INVALID;
        goto shadowinvalid;
    }

    /*
     * Check if we are shadowing the same protocol winstation or not.
     * But let any shadow happen if it's the console and it isn't being shadowed.
     */
    if (!(pWinStation->fOwnsConsoleTerminal && IsListEmpty( &pWinStation->ShadowHead ))) {

        ProtocolMask=WDF_ICA|WDF_TSHARE;

        if (((pConfig->Wd).WdFlag & ProtocolMask) != ((pWinStation->Config).Wd.WdFlag & ProtocolMask))
        {
            Status=STATUS_CTX_SHADOW_INVALID;
            goto shadowinvalid;
        }
    }

    //
    // Stop attempts to shadow an RDP session that is already shadowed.
    // RDP stacks don't support that yet.
    //
    if( pWinStation->fOwnsConsoleTerminal || ((pWinStation->Config).Wd.WdFlag & WDF_TSHARE ))
    {
        if ( pWinStation->StateFlags & WSF_ST_SHADOW ) {
            //
            // Bug 195616, we release winstation lock when
            // waiting for user to accept/deny shadow request,
            // another thread can come in and weird thing can
            // happen
            Status = STATUS_CTX_SHADOW_DENIED;
            goto shadowdenied;
        }

        pWinStation->StateFlags |= WSF_ST_SHADOW;
        bResetStateFlags = TRUE;
    }

    /*
     *  Check shadowing options
     */
    switch ( pWinStation->Config.Config.User.Shadow ) {
        WCHAR szTitle[32];
        WCHAR szMsg2[256];
        WCHAR ShadowMsg[256];

        /*
         * If shadowing is disabled, then deny this request
         */
        case Shadow_Disable :

            Status = STATUS_CTX_SHADOW_DISABLED;
            goto shadowinvalid;
            break;

        /*
         * If one of the Notify shadow options is set,
         * then ask for permission from session being shadowed.
         * But deny the shadow if this WinStation is currently
         * disconnected (i.e. there is no user to answer the request).
         */
        case Shadow_EnableInputNotify :
        case Shadow_EnableNoInputNotify :

            if ( pWinStation->State == State_Disconnected ) {
                Status = STATUS_CTX_SHADOW_INVALID;
                goto shadowinvalid;
            }

            cchTitle = LoadString( hModuleWin, STR_CITRIX_SHADOW_TITLE, szTitle, sizeof(szTitle)/sizeof(WCHAR));

            cchMessage = LoadString( hModuleWin, STR_CITRIX_SHADOW_MSG_2, szMsg2, sizeof(szMsg2)/sizeof(WCHAR));

            if ((cchMessage == 0) || (cchMessage == sizeof(szMsg2)/sizeof(WCHAR))) {
                Status = STATUS_CTX_SHADOW_INVALID;
                goto shadowinvalid;
            }

            cchMessage = _snwprintf( ShadowMsg, sizeof(ShadowMsg)/sizeof(WCHAR), L" %s %s", pClientName, szMsg2 );

            if ((cchMessage <= 0) || (cchMessage == sizeof(ShadowMsg)/sizeof(WCHAR))) {
                Status = STATUS_CTX_SHADOW_INVALID;
                goto shadowinvalid;
            }

            /*
             * Send message and wait for reply
             */
            msg.u.SendMessage.pTitle = szTitle;
            msg.u.SendMessage.TitleLength = (cchTitle+1) * sizeof(WCHAR);
            msg.u.SendMessage.pMessage = ShadowMsg;
            msg.u.SendMessage.MessageLength = (cchMessage+1) * sizeof(WCHAR);
            msg.u.SendMessage.Style = MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION;
            msg.u.SendMessage.Timeout = 30;
            msg.u.SendMessage.DoNotWait = FALSE;
            msg.u.SendMessage.pResponse = &ShadowResponse;

            msg.ApiNumber = SMWinStationDoMessage;

            /*
             *  Create wait event
             */
            InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
            Status = NtCreateEvent( &msg.u.SendMessage.hEvent, EVENT_ALL_ACCESS, &ObjA,
                                    NotificationEvent, FALSE );
            if ( !NT_SUCCESS(Status) ) {
                goto shadowinvalid;
            }

            /*
             *  Initialize response to IDTIMEOUT
             */
            ShadowResponse = IDTIMEOUT;

            /*
             * Tell the WinStation to display the message box
             */
            Status = SendWinStationCommand( pWinStation, &msg, 0 );

            /*
             *  Wait for response
             */
            if ( Status == STATUS_SUCCESS ) {
                TRACE((hTrace,TC_ICASRV,TT_API1, "WinStationSendMessage: wait for response\n" ));
                UnlockWinStation( pWinStation );
                Status = NtWaitForSingleObject( msg.u.SendMessage.hEvent, FALSE, NULL );
                if ( !RelockWinStation( pWinStation ) ) {
                    Status = STATUS_CTX_CLOSE_PENDING;
                }
                TRACE((hTrace,TC_ICASRV,TT_API1, "WinStationSendMessage: got response %u\n", ShadowResponse ));
                NtClose( msg.u.SendMessage.hEvent );
            }
            else
            {
                /* makarp; close the event in case of SendWinStationCommand failure as well. #182792 */
                NtClose( msg.u.SendMessage.hEvent );
            }

            if ( Status == STATUS_SUCCESS && ShadowResponse != IDYES )
                 Status = STATUS_CTX_SHADOW_DENIED;

            /*
             * Check again the target WinStation state as the user could logoff.
             * We only allow shadow of active (connected, logged on) WinStations.
             */
            if ( Status == STATUS_SUCCESS && pWinStation->State != State_Active ) {
                Status = STATUS_CTX_SHADOW_INVALID;
            }

            if ( Status != STATUS_SUCCESS ) {
                goto shadowinvalid;
            }

            break;
    }

    /*
     * The shadow request is accepted: for the console session, we now need
     * to chain in the DD or there won't be much output to shadow
     */
    TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: Logon ID %ld\n",
                                                      pWinStation->LogonId ));

    /*
     * If the session is connected to the local console, we need to load
     * the chained shadow display driver before starting the shadoe sequence
     */

    if (pWinStation->fOwnsConsoleTerminal)
    {

        Status = ConsoleShadowStart( pWinStation, pConfig, pModuleData, ModuleDataLength );
        if (NT_SUCCESS(Status))
        {
            fChainedDD = TRUE;
            TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: success\n"));
        }
        else
        {
            TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: ConsoleConnect failed 0x%x\n", Status));
            goto shadowinvalid;
        
        }

    }

    /*
     * Allocate shadow data structure
     */
    pShadow = MemAlloc( sizeof(*pShadow) );
    if ( pShadow == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto shadowinvalid;
    }

    /*
     *  Create shadow stack
     */
    Status = IcaStackOpen( pWinStation->hIca, Stack_Shadow,
                           (PROC)WsxStackIoControl, pWinStation,
                           &pShadow->hStack );
    if ( !NT_SUCCESS(Status) )
        goto badopen;

    /*
     * Create stack broken event and register it
     */
    Status = NtCreateEvent( &pShadow->hBrokenEvent, EVENT_ALL_ACCESS,
                            NULL, NotificationEvent, FALSE );
    if ( !NT_SUCCESS( Status ) )
        goto badevent;
    Broken.BrokenEvent = pShadow->hBrokenEvent;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: BrokenEvent(%ld) = %p\n",
          pWinStation->LogonId, pShadow->hBrokenEvent));

    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pShadow->hStack,
                                IOCTL_ICA_STACK_REGISTER_BROKEN,
                                &Broken,
                                sizeof(Broken),
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badbroken;

    /*
     * Add the shadow structure to the shadow list for the WinStation
     */
    InsertTailList( &pWinStation->ShadowHead, &pShadow->Links );

    /*
     * Allocate an endpoint buffer
     */
    pShadow->pEndpoint = MemAlloc( MODULE_SIZE );
    if ( pShadow->pEndpoint == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badendpoint;
    }

    /*
     * Unlock WinStation while we attempt to connect to the client
     * side of the shadow.
     */
    UnlockWinStation( pWinStation );

    /*
     *  Connect to client side of shadow
     */


    Status = IcaStackConnectionWait   ( pShadow->hStack,
                                        pWinStation->ListenName,
                                        pConfig,
                                        pAddress,
                                        pShadow->pEndpoint,
                                        MODULE_SIZE,
                                        &pShadow->EndpointLength );
    if ( Status == STATUS_BUFFER_TOO_SMALL ) {
        MemFree( pShadow->pEndpoint );
        pShadow->pEndpoint = MemAlloc( pShadow->EndpointLength );
        if ( pShadow->pEndpoint == NULL ) {
            Status = STATUS_NO_MEMORY;
            RelockWinStation( pWinStation );
            goto badendpoint;
        }
        Status = IcaStackConnectionWait   ( pShadow->hStack,
                                            pWinStation->ListenName,
                                            pConfig,
                                            pAddress,
                                            pShadow->pEndpoint,
                                            pShadow->EndpointLength,
                                            &pShadow->EndpointLength );
    }
    if ( !NT_SUCCESS(Status) ) {
        RelockWinStation( pWinStation );
        goto badconnect;
    }

    /*
     * Relock the WinStation.
     * If the WinStation is going away, then bail out.
     */
    if ( !RelockWinStation( pWinStation ) ) {
        Status = STATUS_CTX_CLOSE_PENDING;
        goto closing;
    }

    /*
     * Now accept the shadow target connection
     */
    //  Check for availability



    if (pWinStation->pWsx &&
            pWinStation->pWsx->pWsxIcaStackIoControl) {
        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                pWinStation->pWsxContext,
                pWinStation->hIca,
                pShadow->hStack,
                IOCTL_ICA_STACK_OPEN_ENDPOINT,
                pShadow->pEndpoint,
                pShadow->EndpointLength,
                NULL,
                0,
                NULL);
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }
    if (!NT_SUCCESS(Status))
        goto PostCreateConnection;

    /*
     * If user is configured to permit shadow input,
     * then enable shadow input on the keyboard/mouse channels,
     * if not permitting shadow input, disable keyboard/mouse
     * channels.
     */
    switch ( pWinStation->Config.Config.User.Shadow ) {

        case Shadow_EnableInputNotify :
        case Shadow_EnableInputNoNotify :

            shadowIoctlCode = IOCTL_ICA_CHANNEL_ENABLE_SHADOW;
            break;

        case Shadow_EnableNoInputNotify :
        case Shadow_EnableNoInputNoNotify :

            shadowIoctlCode = IOCTL_ICA_CHANNEL_DISABLE_SHADOW;
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
    }        
        
    if( !NT_SUCCESS(Status) )
        goto PostCreateConnection;
                
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Keyboard,
                             NULL,
                             &ChannelHandle );

    if( !NT_SUCCESS( Status ) ) 
        goto PostCreateConnection;

    Status = IcaChannelIoControl( ChannelHandle,
                                  shadowIoctlCode,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );
    IcaChannelClose( ChannelHandle );

    if( !NT_SUCCESS( Status ) )
        goto PostCreateConnection;

    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Mouse,
                             NULL,
                             &ChannelHandle );
    if ( !NT_SUCCESS( Status ) ) 
        goto PostCreateConnection;

    Status = IcaChannelIoControl( ChannelHandle,
                                  shadowIoctlCode,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );
    IcaChannelClose( ChannelHandle );

    if( !NT_SUCCESS( Status ) )
        goto PostCreateConnection;

    /*
     * Tell win32k about the pending shadow operation
     */

    msg.ApiNumber = SMWinStationShadowSetup;
    Status = SendWinStationCommand( pWinStation, &msg, 60 );
    if ( !NT_SUCCESS( Status ) )
        goto badsetup;

    /*
     * Since we don't do the stack query for a shadow stack,
     * simply call an ioctl to mark the stack as connected now.
     */
    //  Check for availability


    if (pWinStation->pWsx &&
            pWinStation->pWsx->pWsxIcaStackIoControl) {
        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                pWinStation->pWsxContext,
                pWinStation->hIca,
                pShadow->hStack,
                IOCTL_ICA_STACK_SET_CONNECTED,
                pModuleData,
                ModuleDataLength,
                NULL,
                0,
                NULL);
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if (!NT_SUCCESS(Status))
        goto badsetconnect;

    /*
     * Enable I/O for the shadow stack
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pShadow->hStack,
                                IOCTL_ICA_STACK_ENABLE_IO,
                                NULL,
                                0,
                                NULL,
                                0,
                                NULL );

    }
    else {

        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badenableio;

    /*
     * If this is a help assistant scenario then notify the target winlogon (via Win32k)
     * that HA shadow is about to commence.
     */
    if (ShadowerIsHelpSession) {
        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = TRUE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_HelpAssistantShadowStart;
        SendWinStationCommand( pWinStation, &msg, 60);
    }

    /*
     * Start shadowing
     */
    msg.ApiNumber = SMWinStationShadowStart;
    msg.u.ShadowStart.pThinwireData = pThinwireData;
    msg.u.ShadowStart.ThinwireDataLength = ThinwireDataLength;
    Status = SendWinStationCommand( pWinStation, &msg, 60 );
    if ( NT_SUCCESS( Status ) ) {

        /*
         * Wait for the shadow to be terminated
         */
        UnlockWinStation( pWinStation );

        if ( fChainedDD ) {
            HANDLE hEvents[2];

            hEvents[0] = pShadow->hBrokenEvent;
            hEvents[1] = pWinStation->ShadowDisplayChangeEvent;

            Status = NtWaitForMultipleObjects( 2, hEvents, WaitAny, FALSE, NULL );
        } else {
            NtWaitForSingleObject( pShadow->hBrokenEvent, FALSE, NULL );
        }
        RelockWinStation( pWinStation );

        if ( fChainedDD && (Status == WAIT_OBJECT_0 + 1) ) {

            // valid only if there's one shadower?
            NtResetEvent(pWinStation->ShadowDisplayChangeEvent, NULL);
            EndStatus = STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE;
        }

        /*
         * Stop shadowing
         */
        msg.ApiNumber = SMWinStationShadowStop;


        Status = SendWinStationCommand( pWinStation, &msg, 60 );

        ASSERT( NT_SUCCESS( Status ) );
    }

    /*
     * If this is a help assistant scenario then notify the target winlogon (via Win32k)
     * that HA shadow is done.
     */
    if (ShadowerIsHelpSession) {
        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = FALSE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_HelpAssistantShadowFinish;
        SendWinStationCommand( pWinStation, &msg, 0);
    }

    /*
     * Disable I/O for the shadow stack
     */
    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        (void) pWinStation->pWsx->pWsxIcaStackIoControl(
                              pWinStation->pWsxContext,
                              pWinStation->hIca,
                              pShadow->hStack,
                              IOCTL_ICA_STACK_DISABLE_IO,
                              NULL,
                              0,
                              NULL,
                              0,
                              NULL );
    }

    /*
     * Do final shadow cleanup
     */
    msg.ApiNumber = SMWinStationShadowCleanup;
    msg.u.ShadowCleanup.pThinwireData = pThinwireData;
    msg.u.ShadowCleanup.ThinwireDataLength = ThinwireDataLength;
    Status2 = SendWinStationCommand( pWinStation, &msg, 60 );
    ASSERT( NT_SUCCESS( Status2 ) );

    RemoveEntryList( &pShadow->Links );

    IcaStackConnectionClose( pShadow->hStack, pConfig,
                             pShadow->pEndpoint, pShadow->EndpointLength );

    MemFree( pShadow->pEndpoint );

    NtClose( pShadow->hBrokenEvent );
    IcaStackClose( pShadow->hStack );

    MemFree( pShadow );

    /*
     * If there is a shadow done event and this was the last shadow,
     * then signal the waiter now.
     */
    if ( pWinStation->ShadowDoneEvent && IsListEmpty( &pWinStation->ShadowHead ) )
        SetEvent( pWinStation->ShadowDoneEvent );

    /*
     * For the console session, we now need to unchain the DD for
     * performance reasons.  Ignore this return code -- we don't need it and 
     * we also don't want to overwrite the value in Status.
     */
    if (fChainedDD == TRUE)
    {
        TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: unchain console DD\n"));
        pWinStation->Flags |= WSF_DISCONNECT;
        ConsoleShadowStop( pWinStation );

        pWinStation->Flags &= ~WSF_DISCONNECT;
        fChainedDD = FALSE;
    }

    //
    // reset the console winstation parameters.
    //

    if (pWinStation->fOwnsConsoleTerminal) {
        pWinStation->hIca = hIca;
        pWinStation->hStack = hStack;
        pWinStation->pWsx = pWsx;
        pWinStation->pWsxContext = pWsxContext;
    } else  if( fResetShadowSetting ) {
        // Console shadow already reset back to original value
        // can't do this in WinStationShadowWorker(), might run into
        // some timing problem.

        pWinStation->Config.Config.User.Shadow = pWinStation->OriginalShadowClass;
    }


    if( bResetStateFlags ) {
        pWinStation->StateFlags &= ~WSF_ST_SHADOW;
    }


    /*
     *  Unlock winstation
     */
    ReleaseWinStation( pWinStation );

    if ( NT_SUCCESS(Status) && (EndStatus != STATUS_SUCCESS) ) {
        Status = EndStatus;
    }



    return( Status );

/*=============================================================================
==   Error returns
=============================================================================*/

badenableio:
badsetconnect:
    msg.ApiNumber = SMWinStationShadowCleanup;
    msg.u.ShadowCleanup.pThinwireData = pThinwireData;
    msg.u.ShadowCleanup.ThinwireDataLength = ThinwireDataLength;
    SendWinStationCommand( pWinStation, &msg, 60 );

badsetup:
PostCreateConnection:
closing:
    IcaStackConnectionClose( pShadow->hStack, pConfig,
                             pShadow->pEndpoint, pShadow->EndpointLength );

badconnect:
    MemFree( pShadow->pEndpoint );

badendpoint:
    RemoveEntryList( &pShadow->Links );

badbroken:
    NtClose( pShadow->hBrokenEvent );

badevent:
    IcaStackClose( pShadow->hStack );

badopen:
    MemFree( pShadow );

shadowinvalid:
shadowdenied:
    /*
     * For the console session, we now need to unchain the DD for
     * performance reasons
     */
    if (fChainedDD == TRUE)
    {
        TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: unchain console DD\n"));
        pWinStation->Flags |= WSF_DISCONNECT;
        /*
         * Ignore this return code -- we don't need it and we also don't want
         * to overwrite the value in Status.
         */
        (void)ConsoleShadowStop( pWinStation );
        pWinStation->Flags &= ~WSF_DISCONNECT;
        fChainedDD = FALSE;
    }

    //
    // reset the console winstation parameters.
    //

    if (pWinStation->fOwnsConsoleTerminal) {
        pWinStation->hIca = hIca;
        pWinStation->hStack = hStack;
        pWinStation->pWsx = pWsx;
        pWinStation->pWsxContext = pWsxContext;
    } else  if( fResetShadowSetting ) {
        // Console shadow already reset back to original value
        // can't do this in WinStationShadowWorker(), might run into
        // some timing problem.

        pWinStation->Config.Config.User.Shadow = pWinStation->OriginalShadowClass;
    }


    if( bResetStateFlags ) {
        pWinStation->StateFlags &= ~WSF_ST_SHADOW;
    }

    ReleaseWinStation( pWinStation );

done:
    TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationShadowTarget, Status=0x%x\n", 
           Status ));
    return Status;
}


/*****************************************************************************
 *
 *  WinStationStopAllShadows
 *
 *   Stop all shadow activity for this Winstation
 *
 * ENTRY:
 *   pWinStation (input)
 *      pointer to WinStation
 *
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationStopAllShadows( PWINSTATION pWinStation )
{
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;

    /*
     * If this WinStation is a shadow client, then set the shadow broken
     * event and create an event to wait on for it the shadow to terminate.
     */
    if ( pWinStation->hPassthruStack ) {

        pWinStation->ShadowDoneEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT( pWinStation->ShadowDoneEvent );

        if ( pWinStation->ShadowBrokenEvent ) {
            SetEvent( pWinStation->ShadowBrokenEvent );
        }
    }

    /*
     * If this WinStation is a shadow target, then loop through the
     * shadow structures and signal the broken event for each one.
     */
    if ( !IsListEmpty( &pWinStation->ShadowHead ) ) {

        pWinStation->ShadowDoneEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT( pWinStation->ShadowDoneEvent );

        Head = &pWinStation->ShadowHead;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            PSHADOW_INFO pShadow;

            pShadow = CONTAINING_RECORD( Next, SHADOW_INFO, Links );
            NtSetEvent( pShadow->hBrokenEvent, NULL );
        }
    }

    /*
     * If a shadow done event was created above, then we'll wait on it
     * now (for either the shadow client or shadow target to complete).
     */
    if ( pWinStation->ShadowDoneEvent ) {

        UnlockWinStation( pWinStation );
        Status = WaitForSingleObject( pWinStation->ShadowDoneEvent, 60*1000 );
        RelockWinStation( pWinStation );

        CloseHandle( pWinStation->ShadowDoneEvent );
        pWinStation->ShadowDoneEvent = NULL;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
_CreateShadowAddress(
    ULONG ShadowId,
    PWINSTATIONCONFIG2 pConfig,
    PWSTR pTargetServerName,
    PICA_STACK_ADDRESS pAddress,
    PICA_STACK_ADDRESS pRemoteAddress
    )
{
    WCHAR ServerName[MAX_COMPUTERNAME_LENGTH+1];
    ULONG Length;
    int   nFormattedLength;
    NTSTATUS Status =  STATUS_INVALID_PARAMETER;

    RtlZeroMemory( pAddress, sizeof(*pAddress) );

    if ( !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdpipe" ) ) {
        Length = MAX_COMPUTERNAME_LENGTH+1;
        ServerName[0] = (WCHAR)0;
        GetComputerName( ServerName, &Length );
        *((PWCHAR)pAddress) = (WCHAR)0;
        nFormattedLength = _snwprintf( (PWSTR)pAddress, sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR), L"\\??\\Pipe\\Shadowpipe\\%d", ShadowId );
        if (nFormattedLength < 0 || nFormattedLength == sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR)) {
            return STATUS_INVALID_PARAMETER;
        }
        if ( pTargetServerName ) {
            *((PWCHAR)pRemoteAddress) = (WCHAR)0;
            nFormattedLength = _snwprintf( (PWSTR)pRemoteAddress,  sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR), L"\\??\\UNC\\%ws\\Pipe\\Shadowpipe\\%d",
                                          pTargetServerName, ShadowId );
            if (nFormattedLength < 0 || nFormattedLength == sizeof(ICA_STACK_ADDRESS)/sizeof(WCHAR)) {
                return STATUS_INVALID_PARAMETER;
            }
        } else {
            *pRemoteAddress = *pAddress;
        }
    } else if ( !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdnetb" ) ) {
        *(PUSHORT)pAddress = AF_NETBIOS;
        GetSystemTimeAsFileTime( (LPFILETIME)((PUSHORT)(pAddress)+1) );
        pConfig->Pd[0].Params.Network.LanAdapter = 1;
        *pRemoteAddress = *pAddress;
    } else if ( !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdtcp" ) ) {
        *(PUSHORT)pAddress = AF_INET;
        *pRemoteAddress = *pAddress;
    } else if ( !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdipx" ) ||
                !_wcsicmp( pConfig->Pd[0].Create.PdDLL, L"tdspx" ) ) {
        *(PUSHORT)pAddress = AF_IPX;
        *pRemoteAddress = *pAddress;
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
_WinStationShadowTargetThread( PVOID p )
{
    PSHADOW_PARMS pShadowParms;
    HANDLE NullToken;
    PWINSTATION pWinStation;
    //DWORD WNetRc;
    NTSTATUS Status;
    NTSTATUS ShadowStatus;

    pShadowParms = (PSHADOW_PARMS)p;

    /*
     * Impersonate the client using the token handle passed to us.
     */
    ShadowStatus = NtSetInformationThread( NtCurrentThread(),
                                           ThreadImpersonationToken,
                                           (PVOID)&pShadowParms->ImpersonationToken,
                                           (ULONG)sizeof(HANDLE) );
    ASSERT( NT_SUCCESS( ShadowStatus ) );
    if ( !NT_SUCCESS( ShadowStatus ) )
        goto impersonatefailed;

    /*
     * If target server name was not specified, then call the
     * target worker function directly and avoid the RPC overhead.
     */
    if ( pShadowParms->pTargetServerName == NULL ) {

        ShadowStatus = WinStationShadowTargetWorker(
                    pShadowParms->ShadowerIsHelpSession,
                    pShadowParms->fResetShadowMode,
                    pShadowParms->TargetLogonId,
                    &pShadowParms->Config,
                    &pShadowParms->Address,
                    pShadowParms->pModuleData,
                    pShadowParms->ModuleDataLength,
                    pShadowParms->pThinwireData,
                    pShadowParms->ThinwireDataLength,
                    pShadowParms->ClientName);
        SetLastError(RtlNtStatusToDosError(ShadowStatus));        

    /*
     * Otherwise, open the remote targer server and call the shadow target API.
     */
    } else {
        HANDLE hServer;

        hServer = WinStationOpenServer( pShadowParms->pTargetServerName );
        if ( hServer == NULL ) {
            ShadowStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        } else {
            ShadowStatus = _WinStationShadowTarget(
                    hServer,
                    pShadowParms->TargetLogonId,
                    &pShadowParms->Config,
                    &pShadowParms->Address,
                    pShadowParms->pModuleData,
                    pShadowParms->ModuleDataLength,
                    pShadowParms->pThinwireData,
                    pShadowParms->ThinwireDataLength,
                    pShadowParms->ClientName,
                    sizeof(pShadowParms->ClientName) );

            if (ShadowStatus != STATUS_SUCCESS) {
                ShadowStatus = WinStationWinerrorToNtStatus(GetLastError());
            }

            WinStationCloseServer( hServer );
        }
    }

    /*
     * Revert back to our threads default token.
     */
    NullToken = NULL;
    Status = NtSetInformationThread( NtCurrentThread(),
                                     ThreadImpersonationToken,
                                     (PVOID)&NullToken,
                                     (ULONG)sizeof(HANDLE) );
    ASSERT( NT_SUCCESS( Status ) );

impersonatefailed:

    /*
     * Now find and lock the client WinStation and return the status
     * from the above call to the client WinStation.
     */
    pWinStation = FindWinStationById( pShadowParms->ClientLogonId, FALSE );
    if ( pWinStation != NULL ) {
        if ( pWinStation->ShadowId == pShadowParms->ClientShadowId ) {
            pWinStation->ShadowTargetStatus = ShadowStatus;
        }
        ReleaseWinStation( pWinStation );
    }

    NtClose( pShadowParms->ImpersonationToken );
    MemFree( pShadowParms->pModuleData );
    MemFree( pShadowParms->pThinwireData );
    MemFree( pShadowParms );

    TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: ShadowTargetThread got: Status=0x%x\n", 
           ShadowStatus ));


    return( ShadowStatus );
}


/*****************************************************************************
 *
 *  WinStationShadowChangeMode
 *
 *   Change the mode of the current shadow: interactive/non interactive
 *
 * ENTRY:
 *   pWinStation (input/output)
 *      pointer to WinStation
 *   pWinStationShadow (input)
 *      pointer to WINSTATIONSHADOW struct
 *   ulLength (input)
 *      length of the input buffer
 *
 *
 * EXIT:
 *   STATUS_xxx error
 *
 ****************************************************************************/

NTSTATUS WinStationShadowChangeMode( 
    PWINSTATION pWinStation,
    PWINSTATIONSHADOW pWinStationShadow,
    ULONG ulLength )
{
    NTSTATUS Status = STATUS_SUCCESS; //assume success

    if (ulLength >= sizeof(WINSTATIONSHADOW)) {

        //
        // If the session is being shadowed then check the new shadow mode
        //
        if ( pWinStation->State == State_Active &&
             !IsListEmpty(&pWinStation->ShadowHead) ) {

            HANDLE ChannelHandle;
            ULONG IoCtlCode = 0;

            switch ( pWinStationShadow->ShadowClass ) {

                case Shadow_EnableInputNotify :
                case Shadow_EnableInputNoNotify :
                    // 
                    // we want input : enable it regardless of current state!
                    //
                    IoCtlCode = IOCTL_ICA_CHANNEL_ENABLE_SHADOW;
                    break;

                case Shadow_EnableNoInputNotify :
                case Shadow_EnableNoInputNoNotify :
                    //
                    // We want no input, disable it.
                    //
                    IoCtlCode = IOCTL_ICA_CHANNEL_DISABLE_SHADOW;
                    break;

                case Shadow_Disable :
                    Status = STATUS_INVALID_PARAMETER;
                    break;

                default:
                    Status = STATUS_INVALID_PARAMETER;
                    break;

            }

            if ( IoCtlCode != 0 ) {
                KEYBOARD_INDICATOR_PARAMETERS KbdLeds;
                NTSTATUS Status2;

                Status = IcaChannelOpen( pWinStation->hIca,
                                         Channel_Keyboard,
                                         NULL,
                                         &ChannelHandle );

                if ( NT_SUCCESS( Status ) ) {

                    // if we're re-enabling input, get the leds state on the primary stack...
                    if ( IoCtlCode == IOCTL_ICA_CHANNEL_ENABLE_SHADOW ) {
                        Status2 = IcaChannelIoControl( ChannelHandle, IOCTL_KEYBOARD_QUERY_INDICATORS,
                                             NULL, 0, &KbdLeds, sizeof(KbdLeds), NULL);
                    }

                    Status = IcaChannelIoControl( ChannelHandle, IoCtlCode,
                                                  NULL, 0, NULL, 0, NULL );

                    // and update all stacks with this state.
                    if ( IoCtlCode == IOCTL_ICA_CHANNEL_ENABLE_SHADOW &&
                         NT_SUCCESS( Status ) &&
                         NT_SUCCESS( Status2 ) ) {

                        Status2 = IcaChannelIoControl( ChannelHandle, IOCTL_KEYBOARD_SET_INDICATORS,
                                             &KbdLeds, sizeof(KbdLeds), NULL, 0, NULL);
                    }

                    IcaChannelClose( ChannelHandle );
                }

                if ( NT_SUCCESS( Status ) ) {

                    Status = IcaChannelOpen( pWinStation->hIca,
                                             Channel_Mouse,
                                             NULL,
                                             &ChannelHandle );

                    if ( NT_SUCCESS( Status ) ) {

                        Status = IcaChannelIoControl( ChannelHandle, IoCtlCode,
                                                      NULL, 0, NULL, 0, NULL );
                        IcaChannelClose( ChannelHandle );
                    }
                }

            }

            // Do not update WinStation shadow config, user should not
            // be able to bypass what's defined in Group Policy. 

        }

    } else {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    return Status;
}


/*****************************************************************************
 *
 *  _DetectLoop
 *
 *   Detects a loop by walking the chain of containers.
 *
 * ENTRY:
 *   RemoteSessionId (input)
 *     id of the session from where we start the search
 *   pRemoteServerDigProductId (input)
 *     product id of the machine from where we start the search
 *   TargetSessionId (input)
 *     id of the session looked up
 *   pTargetServerDigProductId (input)
 *     product id of the machine looked up
 *   pLocalServerProductId (input)
 *     product id of the local machine
 *   pbLoop (output)
 *     pointer to the result of the search
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
_DetectLoop(
    IN ULONG RemoteSessionId,
    IN PWSTR pRemoteServerDigProductId,
    IN ULONG TargetSessionId,
    IN PWSTR pTargetServerDigProductId,
    IN PWSTR pLocalServerProductId,
    OUT BOOL* pbLoop
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWINSTATION pWinStation;
    WCHAR TmpDigProductId[CLIENT_PRODUCT_ID_LENGTH];

    if ( pbLoop == NULL )
        return STATUS_INVALID_PARAMETER;
    else
        *pbLoop = FALSE;



      do {

        if ( _wcsicmp( pLocalServerProductId, pRemoteServerDigProductId ) != 0 ) {

            // For now limit the search to the local cases.
            // Later we can add a RPC call or any other 
            // mechanism (by instance through the client)
            // to get this info from the distant machine.
            
            Status = STATUS_UNSUCCESSFUL;

            // The solution could be to RPC the remote machine to get
            // the client data for the session id. Then from these data
            // we can get the client computer name and the client session id.
            // RPC to use: WinStationQueryInformation with information
            // class set to WinStationClient.
            // No need to add a new RPC call.

          } else {

            // we're sure that the remote session is on the same server
            pWinStation = FindWinStationById( RemoteSessionId, FALSE );

            if ( pWinStation != NULL ) {
                // set the new remote info
                RemoteSessionId = pWinStation->Client.ClientSessionId;

                memcpy(TmpDigProductId, pWinStation->Client.clientDigProductId, sizeof( TmpDigProductId ));
                pRemoteServerDigProductId = TmpDigProductId;
                ReleaseWinStation( pWinStation );
            } else {
                Status = STATUS_ACCESS_DENIED;
            }
          }

          if( !*pRemoteServerDigProductId )
          //older client, can't do anything, allow shadow
            break;

          if ( Status == STATUS_SUCCESS ) {

            if ( (RemoteSessionId == TargetSessionId) &&
                (_wcsicmp( pRemoteServerDigProductId, pTargetServerDigProductId ) == 0) ) {

                *pbLoop = TRUE;

            } else  if ( RemoteSessionId == LOGONID_NONE ) {

                // no loop, return success.
                break;
            }
          }
      } while ( (*pbLoop == FALSE) && (Status == STATUS_SUCCESS) );

    return Status;
}

/*****************************************************************************
 *
 *  _CheckShadowLoop
 *
 *   Detects a loop in the shadow.
 *
 * ENTRY:
     pWinStation
        pointer to the current Winstation
 *   ClientLogonId (input)
 *     client of the shadow
 *   pTargetServerName (input)
 *     target server name
 *   TargetLogonId (input)
 *     target login id (where the app is running)
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/
NTSTATUS
_CheckShadowLoop(
    IN ULONG ClientLogonId,
    IN PWSTR pTargetServerName,
    IN ULONG TargetLogonId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL bLoop;

    WCHAR LocalDigProductId [ CLIENT_PRODUCT_ID_LENGTH ];
    WCHAR* pTargetServerDigProductId = NULL;
    WINSTATIONPRODID WinStationProdId;
    ULONG len;

    memcpy( LocalDigProductId, g_DigProductId, sizeof( LocalDigProductId ));

    //get the target's sessionid and digital product id
    if ( pTargetServerName == NULL ) {
        pTargetServerDigProductId = LocalDigProductId;
    /*
     * Otherwise, open the remote targer server and call the shadow target API.
     */
    } 
    
    else 
    {
        HANDLE hServer;
        ZeroMemory( &WinStationProdId, sizeof( WINSTATIONPRODID ));

        hServer = WinStationOpenServer( pTargetServerName );
        if ( hServer == NULL ) 
        {
            //ignore errors, we allow shadowing
            goto done;
        } 
        else 
        {
          //ignore errors 
          WinStationQueryInformation( hServer, TargetLogonId, WinStationDigProductId, &WinStationProdId, sizeof(WinStationProdId), &len);
          WinStationCloseServer( hServer );
        }
        pTargetServerDigProductId = WinStationProdId.DigProductId;
    }

     //
    // First pass: start from the local session (i.e. the shadow client)
    // and walk the chain of containers up to the outtermost session in case
    // we reach the target session in the chain.
    //
    
    if( *LocalDigProductId && *pTargetServerDigProductId ) {

        Status = _DetectLoop( ClientLogonId,
                          LocalDigProductId,
                          TargetLogonId,
                          pTargetServerDigProductId,
                          LocalDigProductId,
                          &bLoop);

        if ( Status == STATUS_SUCCESS ) {
            if (bLoop) {
                // Status = STATUS_CTX_SHADOW_CIRCULAR;
                Status = STATUS_ACCESS_DENIED;
                goto done;
            }
        } //else ignore errors and do the second pass

    //
    // Second pass: start from the target session (i.e. the shadow target)
    // and walk the chain of containers up to the outtermost session in case
    // we reach the client session in the chain.
    //

        Status = _DetectLoop( TargetLogonId,
                          pTargetServerDigProductId,
                          ClientLogonId,
                          LocalDigProductId,
                          LocalDigProductId,
                          &bLoop);

        if ( Status == STATUS_SUCCESS ) {
            if (bLoop) {
                //Status = STATUS_CTX_SHADOW_CIRCULAR;
                Status = STATUS_ACCESS_DENIED;
            }
        } else {
        //else ignore errors and grant shadow
            Status = STATUS_SUCCESS;
          }
     }

done:
    return Status;
}


/*****************************************************************************
 *
 *  GetSalemOutbufCount
 *
 *   Gets the outbufcount from the registry for the help assistant
 *
 * ENTRY:
 *    pdwValue
 *      output where the value is stored
 * EXIT:
 *   TRUE - no error
 *
 ****************************************************************************/

BOOL GetSalemOutbufCount(PDWORD pdwValue)
{
    BOOL fSuccess = FALSE;
    HKEY hKey = NULL;
    
    if( NULL == pdwValue )
        return FALSE;
    
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_CONTROL_SALEM,
                    0,
                    KEY_READ,
                    &hKey
                   ) == ERROR_SUCCESS ) {

        DWORD dwSize = sizeof(DWORD);
        DWORD dwType;
        if((RegQueryValueEx(hKey,
                            WIN_OUTBUFCOUNT,
                            NULL,
                            &dwType,
                            (PBYTE) pdwValue,
                            &dwSize
                           ) == ERROR_SUCCESS) 
                           && dwType == REG_DWORD 
                           && *pdwValue > 0) {
            fSuccess = TRUE;
        }
    }

    if(NULL != hKey )
        RegCloseKey(hKey);
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\timer.c ===
/*************************************************************************
*
* timer.c
*
* Common timer routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   Local structures
=============================================================================*/

typedef VOID (*PCLIBTIMERFUNC)(PVOID);
typedef NTSTATUS (*PCREATETHREAD)( PUSER_THREAD_START_ROUTINE, PVOID, BOOLEAN, PHANDLE );

/*
 *  Timer thread structure
 */
typedef struct _CLIBTIMERTHREAD {
    HANDLE hTimerThread;
    HANDLE hTimer;
    LIST_ENTRY TimerHead;
} CLIBTIMERTHREAD, * PCLIBTIMERTHREAD;

/*
 *  Timer structures
 */
typedef struct _CLIBTIMER {
    PCLIBTIMERTHREAD pThread;
    LIST_ENTRY Links;
    LARGE_INTEGER ExpireTime;
    PCLIBTIMERFUNC pFunc;
    PVOID pParam;
    ULONG Flags;
} CLIBTIMER, * PCLIBTIMER;

#define TIMER_ENABLED 0x00000001


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS IcaTimerCreate( ULONG, HANDLE * );
NTSTATUS IcaTimerStart( HANDLE, PVOID, PVOID, ULONG );
BOOLEAN IcaTimerCancel( HANDLE );
BOOLEAN IcaTimerClose( HANDLE );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TimersInit( PCLIBTIMERTHREAD );
NTSTATUS _TimerSet( PCLIBTIMERTHREAD );
BOOLEAN _TimerRemove( PCLIBTIMERTHREAD, PCLIBTIMER, BOOLEAN );
DWORD _TimerThread( PCLIBTIMERTHREAD );


/*=============================================================================
==   Global data
=============================================================================*/

CLIBTIMERTHREAD ThreadData[ 3 ];


/*******************************************************************************
 *
 *  _TimersInit
 *
 *  Initialize timers for process
 *
 *  NOTE: timer semaphore must be locked
 *
 *
 *  ENTRY:
 *    pThread (input)
 *        pointer to timer thread structure
 *
 *  EXIT:
 *     NO_ERROR : successful
 *
 ******************************************************************************/

NTSTATUS
_TimersInit( PCLIBTIMERTHREAD pThread )
{
    ULONG Tid;
    NTSTATUS Status;

    /*
     *  Check if someone beat us here
     */
    if ( pThread->hTimerThread )
        return( STATUS_SUCCESS );

    /*
     *  Initialize timer variables
     */
    InitializeListHead( &pThread->TimerHead );
    pThread->hTimerThread = NULL;
    pThread->hTimer = NULL;

    /*
     *  Create timer object
     */
    Status = NtCreateTimer( &pThread->hTimer, TIMER_ALL_ACCESS, NULL, NotificationTimer );
    if ( !NT_SUCCESS(Status) )
        goto badtimer;

    pThread->hTimerThread = CreateThread( NULL,
                                          0,
                                          _TimerThread,
                                          pThread,
                                          THREAD_SET_INFORMATION,
                                          &Tid );

    if ( !pThread->hTimerThread ) {
        Status = NtCurrentTeb()->LastStatusValue;
        goto badthread;
    }

    SetThreadPriority( pThread->hTimerThread, THREAD_PRIORITY_TIME_CRITICAL-2 );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  bad thread create
     */
badthread:
    NtClose( pThread->hTimer );

    /*
     *  bad timer object
     */
badtimer:
    pThread->hTimerThread = NULL;
    ASSERT( Status == STATUS_SUCCESS );
    return( Status );
}


/*******************************************************************************
 *
 *  IcaTimerCreate
 *
 *  Create a timer
 *
 *
 *  ENTRY:
 *     TimerThread (input)
 *         index of time thread (TIMERTHREAD_?)   clib.h
 *     phTimer (output)
 *         address to return timer handle
 *
 *  EXIT:
 *    STATUS_SUCCESS - no error
 *
 *
 ******************************************************************************/

NTSTATUS
IcaTimerCreate( ULONG TimerThread, HANDLE * phTimer )
{
    PCLIBTIMER pTimer;
    NTSTATUS Status;
    PCLIBTIMERTHREAD pThread;

    if ( TimerThread >= 3 )
        return( STATUS_INVALID_PARAMETER );

    /*
     *  Lock timer semaphore
     */
    RtlEnterCriticalSection( &TimerCritSec );

    /*
     *  Get pointer to thread structure
     */
    pThread = &ThreadData[ TimerThread ];

    /*
     *  Make sure timers are initialized
     */
    if ( pThread->hTimerThread == NULL ) {
        Status = _TimersInit( pThread );
        if ( !NT_SUCCESS(Status) )
            goto badinit;
    }

    /*
     *  Unlock timer semaphore
     */
    RtlLeaveCriticalSection( &TimerCritSec );

    /*
     *  Allocate timer event
     */
    pTimer = MemAlloc( sizeof(CLIBTIMER) );
    if ( !pTimer ) {
        Status = STATUS_NO_MEMORY;
        goto badmalloc;
    }

    /*
     *  Initialize timer event
     */
    RtlZeroMemory( pTimer, sizeof(CLIBTIMER) );
    pTimer->pThread = pThread;

    *phTimer = (HANDLE) pTimer;
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  timer create failed
     *  timer initialization failed
     */

// badmalloc:
badinit:
    RtlLeaveCriticalSection( &TimerCritSec );
badmalloc: /* makarp; dont LeaveCritical Section in case of bad malloc as we have done it already. #182846*/
    *phTimer = NULL;
    return( Status );
}


/*******************************************************************************
 *
 *  IcaTimerStart
 *
 *  Start a timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *     pFunc (input)
 *        address of procedure to call when timer expires
 *     pParam (input)
 *        parameter to pass to procedure
 *     TimeLeft (input)
 *        relative time until timer expires (1/1000 seconds)
 *
 *  EXIT:
 *     NO_ERROR : successful
 *
 *
 ******************************************************************************/

NTSTATUS
IcaTimerStart( HANDLE TimerHandle,
            PVOID pFunc,
            PVOID pParam,
            ULONG TimeLeft )
{
    PCLIBTIMER pTimer;
    PCLIBTIMER pNextTimer;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER Time;
    PLIST_ENTRY Head, Next;
    BOOLEAN fSetTimer = FALSE;
    NTSTATUS Status;
    PCLIBTIMERTHREAD pThread;


    /*
     *  Lock timer semaphore
     */
    RtlEnterCriticalSection( &TimerCritSec );

    /*
     *  Get timer pointer
     */
    pTimer = (PCLIBTIMER) TimerHandle;
    pThread = pTimer->pThread;

    /*
     *  Remove timer if it is enabled
     *  (If the timer was the head entry, then fSetTimer
     *   will be TRUE and _TimerSet will be called below.)
     */
    if ( (pTimer->Flags & TIMER_ENABLED) )
        fSetTimer = _TimerRemove( pThread, pTimer, FALSE );

    /*
     *  Initialize timer event
     */
    Time = RtlEnlargedUnsignedMultiply( TimeLeft, 10000 );
    (VOID) NtQuerySystemTime( &CurrentTime );
    pTimer->ExpireTime = RtlLargeIntegerAdd( CurrentTime, Time );
    pTimer->pFunc      = pFunc;
    pTimer->pParam     = pParam;

    /*
     *  Locate correct spot in linked list to insert this entry
     */
    Head = &pThread->TimerHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pNextTimer = CONTAINING_RECORD( Next, CLIBTIMER, Links );
        if ( RtlLargeIntegerLessThan( pTimer->ExpireTime,
                                      pNextTimer->ExpireTime ) )
            break;
    }

    /*
     *  Insert timer event into timer list.
     *  (InsertTailList inserts 'pTimer' entry in front of 'Next' entry.
     *   If 'Next' points to TimerHead, either because the list is empty,
     *   or because we searched thru the entire list and got back to the
     *   head, this will insert the new entry at the tail.)
     */
    InsertTailList( Next, &pTimer->Links );
    pTimer->Flags |= TIMER_ENABLED;

    /*
     *  Update timer if needed.
     *  (If we just added this entry to the head of the list, the timer
     *   needs to be set.  Also, if fSetTimer is TRUE, then this entry was
     *   removed by _TimerRemove and was the head entry, so set the timer.)
     */
    if ( pThread->TimerHead.Flink == &pTimer->Links || fSetTimer ) {
        Status = _TimerSet( pThread );
        if ( !NT_SUCCESS(Status) )
            goto badset;
    }

    /*
     *  Unlock timer semaphore
     */
    RtlLeaveCriticalSection( &TimerCritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  timer set failed
     *  timer create failed
     *  timer initialization failed
     */
badset:
    RtlLeaveCriticalSection( &TimerCritSec );
    ASSERT( Status == STATUS_SUCCESS );
    return( Status );
}


/*******************************************************************************
 *
 *  IcaTimerCancel
 *
 *  cancel the specified timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *
 *  EXIT:
 *     TRUE  : timer was actually canceled
 *     FALSE : timer was not armed
 *
 *
 ******************************************************************************/

BOOLEAN
IcaTimerCancel( HANDLE TimerHandle )
{
    PCLIBTIMERTHREAD pThread;
    PCLIBTIMER pTimer;
    BOOLEAN fCanceled = FALSE;

    /*
     *  Lock timer semaphore
     */
    RtlEnterCriticalSection( &TimerCritSec );

    /*
     *  Get timer pointer
     */
    pTimer = (PCLIBTIMER) TimerHandle;
    pThread = pTimer->pThread;

    /*
     * Remove timer if it is enabled
     */
    if ( (pTimer->Flags & TIMER_ENABLED) ) {
        _TimerRemove( pThread, pTimer, TRUE );
        fCanceled = TRUE;
    }

    /*
     *  Unlock timer semaphore
     */
    RtlLeaveCriticalSection( &TimerCritSec );

    return( fCanceled );
}




/*******************************************************************************
 *
 *  IcaTimerClose
 *
 *  cancel the specified timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *
 *  EXIT:
 *     TRUE  : timer was actually canceled
 *     FALSE : timer was not armed
 *
 *
 ******************************************************************************/

BOOLEAN
IcaTimerClose( HANDLE TimerHandle )
{
    BOOLEAN fCanceled;

    /*
     * Cancel timer if it is enabled
     */
    fCanceled = IcaTimerCancel( TimerHandle );

    /*
     * Free timer memory
     */
    MemFree( TimerHandle );

    return( fCanceled );
}


/*******************************************************************************
 *
 *  _TimerSet
 *
 *  set the timer
 *
 *  NOTE: timer semaphore must be locked
 *
 *
 *  ENTRY:
 *     pThread (input)
 *         pointer to timer thread structure
 *
 *  EXIT:
 *     NO_ERROR : successful
 *
 *
 ******************************************************************************/

NTSTATUS
_TimerSet( PCLIBTIMERTHREAD pThread )
{
    PCLIBTIMER pTimer;
    LARGE_INTEGER Time;
    // the following is roughly 1 year in 100 nanosecond increments
    static LARGE_INTEGER LongWaitTime = { 0, 0x00010000 };

    /*
     *  Get ExpireTime for next timer entry or 'large' value if none
     */
    if ( pThread->TimerHead.Flink != &pThread->TimerHead ) {
        pTimer = CONTAINING_RECORD( pThread->TimerHead.Flink, CLIBTIMER, Links );
        Time = pTimer->ExpireTime;
    } else {
        LARGE_INTEGER CurrentTime;

        NtQuerySystemTime( &CurrentTime );
        Time = RtlLargeIntegerAdd( CurrentTime, LongWaitTime );
    }

    /*
     *  Set the timer
     */
    return( NtSetTimer( pThread->hTimer, &Time, NULL, NULL, FALSE, 0, NULL ) );
}


/*******************************************************************************
 *
 *  _TimerRemove
 *
 *  remove the specified timer from the timer list
 *  and optionally set the time for the next timer to trigger
 *
 *  NOTE: timer semaphore must be locked
 *
 *
 *  ENTRY:
 *     pThread (input)
 *         pointer to timer thread structure
 *     pTimer (input)
 *        timer entry pointer
 *     SetTimer (input)
 *        BOOLEAN which indicates if _TimerSet should be called
 *
 *  EXIT:
 *     TRUE : timer needs to be set (removed entry was head of list)
 *     FALSE : timer does not need to be set
 *
 *
 ******************************************************************************/

BOOLEAN
_TimerRemove( PCLIBTIMERTHREAD pThread, PCLIBTIMER pTimer, BOOLEAN fSetTimer )
{
    BOOLEAN fSetNeeded = FALSE;
    NTSTATUS Status;

    /*
     *  See if timer is currently enabled
     */
    if ( (pTimer->Flags & TIMER_ENABLED) ) {

        /*
         *  Unlink the entry from the timer list and clear enabled flag
         */
        RemoveEntryList( &pTimer->Links );
        pTimer->Flags &= ~TIMER_ENABLED;

        /*
         *  If we removed the head entry, then set the timer
         *  or indicate to caller that it needs to be set.
         */
        if ( pTimer->Links.Blink == &pThread->TimerHead ) {
            if ( fSetTimer ) {
                Status = _TimerSet( pThread );
                ASSERT( Status == STATUS_SUCCESS );
            } else {
                fSetNeeded = TRUE;
            }
        }
    }

    return( fSetNeeded );
}


/*******************************************************************************
 *
 *  _TimerThread
 *
 *
 * ENTRY:
 *     pThread (input)
 *         pointer to timer thread structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

DWORD
_TimerThread( PCLIBTIMERTHREAD pThread )
{
    PCLIBTIMER pTimer;
    PCLIBTIMERFUNC pFunc;
    PVOID pParam;
    LARGE_INTEGER CurrentTime;
    NTSTATUS Status;

    for (;;) {

        /*
         *  Wait on timer
         */
        Status = NtWaitForSingleObject( pThread->hTimer, TRUE, NULL );

        /*
         *  Check for an error
         */
        if ( Status != STATUS_WAIT_0 )
            break;

        /*
         *  Lock semaphore
         */
        RtlEnterCriticalSection( &TimerCritSec );

        /*
         *  Make sure a timer entry exists
         */
        if ( IsListEmpty( &pThread->TimerHead ) ) {
            Status = _TimerSet( pThread );
            ASSERT( Status == STATUS_SUCCESS );
            RtlLeaveCriticalSection( &TimerCritSec );
            continue;
        }

        /*
         *  Make sure the head entry should be removed now.
         *  (The timer may have been triggered while the
         *   head entry was being removed.)
         */
        pTimer = CONTAINING_RECORD( pThread->TimerHead.Flink, CLIBTIMER, Links );
        NtQuerySystemTime( &CurrentTime );
        if ( RtlLargeIntegerGreaterThan( pTimer->ExpireTime, CurrentTime ) ) {
            Status = _TimerSet( pThread );
            ASSERT( Status == STATUS_SUCCESS );
            RtlLeaveCriticalSection( &TimerCritSec );
            continue;
        }

        /*
         * Remove the entry and indicate it is no longer enabled
         */
        RemoveEntryList( &pTimer->Links );
        pTimer->Flags &= ~TIMER_ENABLED;

        /*
         *  Set the timer for next time
         */
        Status = _TimerSet( pThread );
        ASSERT( Status == STATUS_SUCCESS );

        /*
         *  Get all the data we need out of the timer structure
         */
        pFunc  = pTimer->pFunc;
        pParam = pTimer->pParam;

        /*
         *  Unload semaphore
         */
        RtlLeaveCriticalSection( &TimerCritSec );

        /*
         *  Call timer function
         */
        if ( pFunc ) {
            (*pFunc)( pParam );
        }
    }

    pThread->hTimerThread = NULL;
    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\tsrpc-s.c ===
#include <tsrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\setuinfo.c ===
/*************************************************************************
*
* setuinfo.c
*
* Sets user logon information.
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

#include "precomp.h"
#include "tsremdsk.h"
#pragma hdrstop

// global vars
extern POLICY_TS_MACHINE    g_MachinePolicy;

/*****************************************************************************
 *
 *  MergeUserConfigData
 *
 *  This is the final step in updating a Winstation's USERCONFIG data, which is the final merge of
 *  settings from 5 different sources of data, in the following precedence where top most has the highest
 *  precedence overriding all below it:
 *          Machine Policy
 *          User Policy
 *          TSCC
 *          TsUserEx
 *          Client preference settings
 *
 *          By the time this call is made, the Client preference and TsUserEX data is already merged, where
 *              the result of that merge is in pWinstation's USERCONFIGW struct.
 *
 *  The final call happens when user has logged in, and user policy data is present. When this func is called from 
 *      RpcWinStationUpdateUserConfig, any user policy data that is not already overriden by machine policy will be 
 *      set in USERCONFIG.
 *
 *  The User policy has the following items which ARE repeated in Machine policy, and hence, Machine Policy takes precedence
 *      Remote Control Settings ( SHADOW)
 *      Start up program
 *      Session time out:
 *          time out for disconnected session
 *          time limit for active session
 *          time limit for idle session
 *          allow reconnect from oirginal client only
 *          terminate session when time limits are reaced (instead of disconnect).
 *  
 *  None of the session-time-out and start-up-program USER policies are relevant to 
 *      sesion 0, or any session that is physically connected on the console.
 *
 * ENTRY:
 *    pWinStation
 *         Pointer to WINSTATION structure
 *    pPolicy
 *         TS user policy flags, could be NULL
 *    pPolicyData
 *          policy data if pPolicy is not NULL, otherwise, can be NULL
 *    pUserConfig
 *         Pointer to USERCONFIG structure, can be NULL if pWinstation already has user conifig data from SAM
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 * USAGE
 *      fn( pWinstation, NULL, NULL, pUserConfig) will do a legacy merge of user data into pWinstation.
 *          Legacy merge means that data set by TSCC could override user data.
 *
 *      fn( pWinstation, pPolicy, pPolicyData, NULL ) would override pWinstation data of user by per user data
 *          from  group policy 
 *
 ****************************************************************************/


VOID
MergeUserConfigData( PWINSTATION pWinStation, 
    PPOLICY_TS_USER         pPolicy,
    PUSERCONFIGW            pPolicyData,
    PUSERCONFIG             pUserConfig )
{
    PUSERCONFIG         pWSConfig;
    PPOLICY_TS_MACHINE  pMachinePolicy; 
    BOOLEAN             dontApplySomePolicy ;
    BOOL                bValidHelpSessionLogin;

    pWSConfig      = & pWinStation->Config.Config.User;
    pMachinePolicy = & g_MachinePolicy;


    // active console ID is the ID of the session that is physically connected to the real video drivers at this time.
    dontApplySomePolicy = ( pWinStation->LogonId == 0 ) || (pWinStation->LogonId == (USER_SHARED_DATA->ActiveConsoleId) );

    // None of the session-time-out and start-up-program USER policies are relevant to 
    //    sesion 0, or any session that is physically connected on the console.
    if (! dontApplySomePolicy )
    {
        // if sessions0, or if sessions is the phisical console, then we do not want to apply certain policies at all.
    
        if ( ! pMachinePolicy->fPolicyInitialProgram )  // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyInitialProgram  )
            {
                wcscpy( pWSConfig->InitialProgram, pPolicyData->InitialProgram );
                wcscpy( pWSConfig->WorkDirectory,  pPolicyData->WorkDirectory );
        
                pWSConfig->fInheritInitialProgram = FALSE;
            }
            else if (pUserConfig)
            {
                /*
                 * Use initial program/working directory from user config if WinStation
                 * config says inherit and user config does NOT say inherit from client.
                 */
                if ( pWSConfig->fInheritInitialProgram &&
                     !pUserConfig->fInheritInitialProgram ) {
            
                    /*
                     *  Always copy the user config info in this case, plugs security hole.
                     */
                    wcscpy( pWSConfig->InitialProgram, pUserConfig->InitialProgram );
                    wcscpy( pWSConfig->WorkDirectory,  pUserConfig->WorkDirectory );
                }
            }
        }

        if ( ! pMachinePolicy->fPolicyResetBroken ) // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyResetBroken )
            {
                pWSConfig->fResetBroken = pPolicyData->fResetBroken;
                pWSConfig->fInheritResetBroken = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritResetBroken )
                    pWSConfig->fResetBroken = pUserConfig->fResetBroken;
            }
        }


        // ---------------------------------------------- 
        if ( ! pMachinePolicy->fPolicyReconnectSame )  // if we don't have a machine policy for this, then it is ok to use User policy 
        {
            if ( pPolicy && pPolicy->fPolicyReconnectSame )
            {
                pWSConfig->fReconnectSame = pPolicyData->fReconnectSame;
                pWSConfig->fInheritReconnectSame = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritReconnectSame )
                    pWSConfig->fReconnectSame = pUserConfig->fReconnectSame;
            }
        }


        // ---------------------------------------------- 
        if ( ! pMachinePolicy->fPolicyMaxSessionTime )  // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyMaxSessionTime )
            {
                pWSConfig->MaxConnectionTime = pPolicyData->MaxConnectionTime;
                pWSConfig->fInheritMaxSessionTime = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritMaxSessionTime )
                    pWSConfig->MaxConnectionTime = pUserConfig->MaxConnectionTime;
            }
        }


        // ---------------------------------------------- 
        if ( ! pMachinePolicy->fPolicyMaxDisconnectionTime ) // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyMaxDisconnectionTime )
            {
                pWSConfig->MaxDisconnectionTime = pPolicyData->MaxDisconnectionTime;
                pWSConfig->fInheritMaxDisconnectionTime = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritMaxDisconnectionTime )
                    pWSConfig->MaxDisconnectionTime = pUserConfig->MaxDisconnectionTime;
            }
        }

        // ---------------------------------------------- 
        if ( ! pMachinePolicy->fPolicyMaxIdleTime ) // if we don't have a machine policy for this, then it is ok to use User policy
        {
            if ( pPolicy && pPolicy->fPolicyMaxIdleTime )
            {
                pWSConfig->MaxIdleTime = pPolicyData->MaxIdleTime;
                pWSConfig->fInheritMaxIdleTime = FALSE;
            }
            else if (pUserConfig)
            {
                if ( pWSConfig->fInheritMaxIdleTime )
                    pWSConfig->MaxIdleTime = pUserConfig->MaxIdleTime;
            }
        }

    }

    // ---------------------------------------------- 
    if ( ! pMachinePolicy->fPolicyShadow ) // if we don't have a machine policy for this, then it is ok to use User policy
    {
        if ( pPolicy && pPolicy->fPolicyShadow )
        {
            pWSConfig->Shadow = pPolicyData->Shadow;
            pWSConfig->fInheritShadow = FALSE;
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritShadow )
                pWSConfig->Shadow = pUserConfig->Shadow;
        }
    }

    // ---------------------------------------------- 
    // we don't have a machine policy for this item, which does not even have a UI for user policy...
    //      if ( ! pMachinePolicy->fPolicyCallback ) 
    //
    {
        if ( pPolicy && pPolicy->fPolicyCallback )
        {
            pWSConfig->Callback = pPolicyData->Callback;
            pWSConfig->fInheritCallback = FALSE;
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritCallback )
                pWSConfig->Callback = pUserConfig->Callback;
        }
    }

    // ---------------------------------------------- 
    // we don't have a machine policy for this item, which does not even have a UI for user policy...
    //      if ( ! pMachinePolicy->fPolicyCallbackNumber ) 
    //
    {
        if ( pPolicy && pPolicy->fPolicyCallbackNumber )
        {
            wcscpy( pWSConfig->CallbackNumber, pPolicyData->CallbackNumber );
            pWSConfig->fInheritCallbackNumber = FALSE;
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritCallbackNumber )
                wcscpy( pWSConfig->CallbackNumber, pUserConfig->CallbackNumber );
        }
    }

    // ---------------------------------------------- 
    // we don't have a machine policy for this item. Policy forces a state, does not configure a preferance.
    //      if ( ! pMachinePolicy->fPolicyAutoClientDrives ) 
    //
    {
        if ( pPolicy && pPolicy->fPolicyAutoClientDrives)
        {
            pWSConfig->fAutoClientDrives = pPolicyData->fAutoClientDrives;
    
            // In case other items such as 
            // lpt or def-printer are set to be inherited, such an
            // inheritance of bits would continue for those items
            // pWSConfig->fInheritAutoClient = FALSE;
            //
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritAutoClient ) 
            {
                pWSConfig->fAutoClientDrives = pUserConfig->fAutoClientDrives;
            }
        }
    }

    // ---------------------------------------------- 
    // we don't have a machine policy for this item. Policy forces a state, does not configure a preferance.
    //      if ( ! pMachinePolicy->fPolicyAutoClientLpts )                                  
    //
    {
        if ( pPolicy && pPolicy->fPolicyAutoClientLpts )
        {
            pWSConfig->fAutoClientLpts   = pPolicyData->fAutoClientLpts;
        }
        else if (pUserConfig)
        {
            if (pWSConfig->fInheritAutoClient)
            {
                pWSConfig->fAutoClientLpts   = pUserConfig->fAutoClientLpts;
            }
        }
    }

    // ---------------------------------------------- 
    if ( ! pMachinePolicy->fPolicyForceClientLptDef) // if we don't have a machine policy for this, then it is ok to use User policy
    {
        if ( pPolicy && pPolicy->fPolicyForceClientLptDef )
        {
            pWSConfig->fForceClientLptDef = pPolicyData->fForceClientLptDef;
        }
        else if (pUserConfig)
        {
            if ( pWSConfig->fInheritAutoClient ) 
            {
                pWSConfig->fForceClientLptDef = pUserConfig->fForceClientLptDef;
            }
        }
    }

    if( TSIsSessionHelpSession( pWinStation, &bValidHelpSessionLogin ) )
    {
        // We disconnected RA if ticket is invalid.
        ASSERT( TRUE == bValidHelpSessionLogin );

        // Reset initial program.
        pWSConfig->fInheritInitialProgram = FALSE;

        //
        // our string is still less than 256 (INITIALPROGRAM_LENGTH),
        // need to revisit this if ever increase ticket ID and password length
        //
        _snwprintf( 
                pWSConfig->InitialProgram,
                INITIALPROGRAM_LENGTH,
                L"%s %s",
                SALEMRDSADDINNAME,
                pWinStation->Client.WorkDirectory
            );

        pWSConfig->WorkDirectory[0] = 0;

        // reset winstation when connection is broken
        pWSConfig->fInheritResetBroken = FALSE;
        pWSConfig->fResetBroken = TRUE;

        //
        // No re-direction
        //
        pWSConfig->fInheritAutoClient = FALSE;
        pWSConfig->fAutoClientDrives = FALSE;
        pWSConfig->fAutoClientLpts = FALSE;
        pWSConfig->fForceClientLptDef = FALSE;
    }

    // Cache the original shadow setting so we can reset shadow setting
    // at the end of shadow call, we don't to look it up from registry again
    // as winstion shadow setting might change, in addition, a common
    // winstation configuration for more than one NIC might get split
    // into different winstation, in that case, we will spend a lot time
    // figure out which winstation to use.
    // We do this here to pick up new value from RpcWinStationUpdateUserConfig
    //
    pWinStation->OriginalShadowClass = pWSConfig->Shadow;
}


/*****************************************************************************
 *
 *  ResetUserConfigData
 *
 * ENTRY:
 *    pWinStation
 *         Pointer to WINSTATION structure
 *
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
ResetUserConfigData( PWINSTATION pWinStation )
{
    PUSERCONFIG pWSConfig = &pWinStation->Config.Config.User;

    if ( pWSConfig->fInheritInitialProgram ) {
        pWSConfig->InitialProgram[0] = 0;
        pWSConfig->WorkDirectory[0] = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\version.c ===
/****************************************************************************/
// version.c
//
// TermSrv version setting functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   Vars
=============================================================================*/
PWCHAR pProductOemInfo[] = {
    REG_CITRIX_OEMID,
    REG_CITRIX_OEMNAME,
    REG_CITRIX_PRODUCTNAME,
    REG_CITRIX_PRODUCTVERSION,
    (PWCHAR) NULL,
};


/*******************************************************************************
// UpdateOemAndProductInfo
//
// Updates the registry with the OEM and Product info from SHELL32.DLL.
// Called at init time. hKeyTermSrv is an open reg handle to
// HKLM\Sys\CCS\Ctrl\TS TermSrv key. Returns FALSE on error.
 ******************************************************************************/
BOOL UpdateOemAndProductInfo(HKEY hKeyTermSrv)
{
    ULONG   i;
    PWCHAR  pInfo = NULL;
    DWORD   dwSize;
    PCHAR   pBuffer;
    DWORD   dwBytes;
    PUSHORT pTransL;
    PUSHORT pTransH;
    WCHAR   pString[255];
    PWCHAR  pKey;
    BOOL    bRc = TRUE;
    NTSTATUS Status;

    ASSERT(hKeyTermSrv != NULL);

    // Get the VersionInfo data: Determine size, alloc memory, then get it.
    dwSize = GetFileVersionInfoSize(OEM_AND_PRODUCT_INFO_DLL, 0);
    if (dwSize != 0) {
        pInfo = MemAlloc(dwSize);
        if (pInfo != NULL) {
            bRc = GetFileVersionInfo(OEM_AND_PRODUCT_INFO_DLL, 0, dwSize,
                    pInfo);
            if (!bRc)
                goto done;
        }
        else {
            bRc = FALSE;
            goto done;
        }
    }
    else {
        bRc = FALSE;
        goto done;
    }

    /*
     *  Get the translation information
     */
    if (!VerQueryValue(pInfo, L"\\VarFileInfo\\Translation", &pBuffer, &dwBytes)) {
        bRc = FALSE;
        goto done;
    }

    /*
     *  Get the language and character set
     */
    pTransL = (PUSHORT)pBuffer;
    pTransH = (PUSHORT)(pBuffer + 2);

    /*
     *  Pull out the individual fields
     */
    i = 0;
    while ((pKey = pProductOemInfo[i++]) != NULL) {
        /*
         *  Generate StringFileInfo entry
         */
        wsprintf(pString, L"\\StringFileInfo\\%04X%04X\\%s", *pTransL,
                *pTransH, pKey);

        /*
         *  Pull entry
         */
        if (!VerQueryValue( pInfo, pString, &pBuffer, &dwBytes ) ) {
            bRc = FALSE;
            goto done;
        }

        /*
         *  Write key value
         */
        RegSetValueEx(hKeyTermSrv, pKey, 0, REG_SZ, pBuffer, dwBytes * 2);
    }

done:
    /*
     *  Free memory
     */
    if (pInfo != NULL)
        MemFree(pInfo);

    return bRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\wininit.c ===
/*************************************************************************
*
* wininit.c
*
* Window station init and destroy routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

/*
 *  Local data
 */
#define LOGOFF_TIMER 120000L
#define MODULE_SIZE 1024    /* Default size for retrive of module data */
#define VDDATA_LENGTH 1024

/*
 *  Internal Procedures
 */
VOID StartLogonTimers( PWINSTATION );
VOID IdleTimeout( ULONG );
VOID LogonTimeout( ULONG );
VOID IdleLogoffTimeout( ULONG );
VOID LogoffTimeout( ULONG );


/*******************************************************************************
 *
 *  StartLogonTimers
 *
 *  This routine is called when an user is logged on.
 *  Timers are started for idle input and total logon time.
 *
 * ENTRY:
 *   None.
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID
StartLogonTimers( PWINSTATION pWinStation )
{
    int Status;
    ULONG Timer;
    // for Session0 and any console sessions, timeouts don't make sense
    if ( ( pWinStation->LogonId != 0 ) && ( pWinStation->LogonId != USER_SHARED_DATA->ActiveConsoleId  ) ) {
        if ( Timer = pWinStation->Config.Config.User.MaxIdleTime ) {
            if ( !pWinStation->fIdleTimer ) {
                Status = IcaTimerCreate( 0, &pWinStation->hIdleTimer );
                if ( NT_SUCCESS( Status ) )
                    pWinStation->fIdleTimer = TRUE;
                else
                    DBGPRINT(( "StartLogonTimers - failed to create idle timer \n" ));
            }
            if ( pWinStation->fIdleTimer )
                IcaTimerStart( pWinStation->hIdleTimer, IdleTimeout,
                            LongToPtr( pWinStation->LogonId ), Timer );
        }

        if ( Timer = pWinStation->Config.Config.User.MaxConnectionTime ) {
            if ( !pWinStation->fLogonTimer ) {
                Status = IcaTimerCreate( 0, &pWinStation->hLogonTimer );
                if ( NT_SUCCESS( Status ) )
                    pWinStation->fLogonTimer = TRUE;
                else
                    DBGPRINT(( "StartLogonTimers - failed to create logon timer \n" ));
            }
            if ( pWinStation->fLogonTimer )
                IcaTimerStart( pWinStation->hLogonTimer, LogonTimeout,
                            LongToPtr( pWinStation->LogonId ), Timer );
        }
    }
}


/*******************************************************************************
 *
 *  IdleTimeout
 *
 *  This routine is called when the idle timer expires.
 *  Send the user a warning message and start timer to logoff in 2 minutes.
 *
 * ENTRY:
 *   LogonId
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID IdleTimeout( ULONG LogonId )
{
    LARGE_INTEGER liT;
    ULONG ulTimeDelta;
    ICA_STACK_LAST_INPUT_TIME Ica_Stack_Last_Input_Time;
    NTSTATUS Status;
    ULONG cbReturned;
    PWINSTATION pWinStation;
    WINSTATION_APIMSG msg;

    pWinStation = FindWinStationById( LogonId, FALSE );

    if ( !pWinStation ) 
        return;

    if ( !pWinStation->hStack )
        goto done;

    if ( !pWinStation->fIdleTimer )
        goto done;

    //  Check for availability
    if ( pWinStation->pWsx && 
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hStack,
                                IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME,
                                NULL,
                                0,
                                &Ica_Stack_Last_Input_Time,
                                sizeof( Ica_Stack_Last_Input_Time ),
                                &cbReturned );
    }
    else {
        Status = STATUS_INVALID_PARAMETER;
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    /*
     *  Check if there was input during the idle time
     */
    NtQuerySystemTime( &liT );
    // calculate delta in time & convert from 100ns unit to milliseconds
    liT = RtlExtendedLargeIntegerDivide(
            RtlLargeIntegerSubtract( liT, Ica_Stack_Last_Input_Time.LastInputTime ),
            10000, NULL );
    ulTimeDelta = (ULONG)liT.LowTime;

    TRACE((hTrace,TC_ICASRV,TT_API1, "IdleTimeout: delta = %d, max idle = %d\n", ulTimeDelta,
                                 pWinStation->Config.Config.User.MaxIdleTime ));

    if ( ulTimeDelta < pWinStation->Config.Config.User.MaxIdleTime ) {
        IcaTimerStart( pWinStation->hIdleTimer, IdleTimeout, LongToPtr( LogonId ),
                      pWinStation->Config.Config.User.MaxIdleTime - ulTimeDelta );
    } else {
        TCHAR szTitle[128];
        TCHAR szMsg[256];
        int cchTitle, cchMessage;

        IcaTimerStart( pWinStation->hIdleTimer, IdleLogoffTimeout,
                       LongToPtr( LogonId ), LOGOFF_TIMER );


        if ( !(cchTitle = LoadString(hModuleWin, STR_CITRIX_IDLE_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR))) )
           goto done;
        if ( pWinStation->Config.Config.User.fResetBroken )
        {

            if ( !(cchMessage = LoadString(hModuleWin, STR_CITRIX_IDLE_MSG_LOGOFF, szMsg, sizeof(szMsg)/sizeof(TCHAR)) ))
               goto done;
        }
        else
        {
            if ( !(cchMessage = LoadString(hModuleWin, STR_CITRIX_IDLE_MSG_DISCON, szMsg, sizeof(szMsg)/sizeof(TCHAR)) ))
               goto done;

        }

        msg.u.SendMessage.pTitle = szTitle;
        msg.u.SendMessage.TitleLength = (cchTitle+1) * sizeof(TCHAR);
        msg.u.SendMessage.pMessage = szMsg;
        msg.u.SendMessage.MessageLength = (cchMessage+1) * sizeof(TCHAR);
        msg.u.SendMessage.Style = MB_OK | MB_ICONSTOP;
        msg.u.SendMessage.Timeout = (ULONG)LOGOFF_TIMER/1000;
        msg.u.SendMessage.Response = 0;
        msg.u.SendMessage.DoNotWait = TRUE;

        msg.ApiNumber = SMWinStationDoMessage;
        Status = SendWinStationCommand( pWinStation, &msg, 0 );

    }
done:
    ReleaseWinStation( pWinStation );
}

/*******************************************************************************
 *
 *  LogonTimeout
 *
 *  This routine is called when the logon timer expires.
 *  Send the user a warning message and start timer to logoff in 2 minutes.
 *
 * ENTRY:
 *   LogonId
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID LogonTimeout( ULONG LogonId )
{
    TCHAR szTitle[128];
    TCHAR szMsg[256];
    PWINSTATION pWinStation;
    NTSTATUS Status;
    WINSTATION_APIMSG msg;
    int cchTitle, cchMsg;

    pWinStation = FindWinStationById( LogonId, FALSE );

    if ( !pWinStation )
        return;

    if ( !pWinStation->fLogonTimer)
        goto done;

    if ( !(cchTitle = LoadString(hModuleWin, STR_CITRIX_LOGON_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR)) ))
        goto done;
    if ( pWinStation->Config.Config.User.fResetBroken )
    {
        if ( !(cchMsg = LoadString(hModuleWin, STR_CITRIX_LOGON_MSG_LOGOFF, szMsg, sizeof(szMsg)/sizeof(TCHAR)) ))
            goto done;
    }
    else
    {
        if ( !(cchMsg = LoadString(hModuleWin, STR_CITRIX_LOGON_MSG_DISCON, szMsg, sizeof(szMsg)/sizeof(TCHAR)) ))
            goto done;
    }

    msg.u.SendMessage.pTitle = szTitle;
    msg.u.SendMessage.TitleLength = ( cchTitle+1 ) * sizeof(TCHAR);
    msg.u.SendMessage.pMessage = szMsg;
    msg.u.SendMessage.MessageLength = ( cchMsg+1 ) * sizeof(TCHAR);
    msg.u.SendMessage.Style = MB_OK | MB_ICONSTOP;
    msg.u.SendMessage.Timeout = (ULONG)LOGOFF_TIMER/1000;
    msg.u.SendMessage.Response = 0;
    msg.u.SendMessage.DoNotWait = TRUE;

    msg.ApiNumber = SMWinStationDoMessage;
    Status = SendWinStationCommand( pWinStation, &msg, 0 );

    IcaTimerStart( pWinStation->hLogonTimer, LogoffTimeout,
                   LongToPtr( LogonId ), LOGOFF_TIMER );
    if (pWinStation->fIdleTimer) {
        pWinStation->fIdleTimer = FALSE;
        IcaTimerClose( pWinStation->hIdleTimer );
    }
done:
    ReleaseWinStation( pWinStation );
}



/*******************************************************************************
 *
 *  IdleLogoffTimeout
 *
 *  This routine is called when the logoff timer expires.
 *  Check for input before logging user off
 *
 * ENTRY:
 *   LogonId
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID IdleLogoffTimeout( ULONG LogonId )
{
    LARGE_INTEGER liT;
    ULONG ulTimeDelta;
    ICA_STACK_LAST_INPUT_TIME Ica_Stack_Last_Input_Time;
    NTSTATUS Status;
    ULONG cbReturned;
    PWINSTATION pWinStation;

    pWinStation = FindWinStationById( LogonId, FALSE );

    if ( !pWinStation ) 
        return;

    if ( !pWinStation->hStack )
        goto done;

    if ( !pWinStation->fIdleTimer )
        goto done;

    //  Check for availability
    if ( pWinStation->pWsx && 
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hStack,
                                IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME,
                                NULL,
                                0,
                                &Ica_Stack_Last_Input_Time,
                                sizeof( Ica_Stack_Last_Input_Time ),
                                &cbReturned );
    }
    else {
        Status = STATUS_INVALID_PARAMETER;
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    NtQuerySystemTime( &liT );
    liT = RtlExtendedLargeIntegerDivide(
            RtlLargeIntegerSubtract( liT, Ica_Stack_Last_Input_Time.LastInputTime ),
            10000, NULL );
    ulTimeDelta = (ULONG)liT.LowTime;

    TRACE((hTrace,TC_ICASRV,TT_API1, "IdleTimeout: delta = %d, max idle = %d\n", ulTimeDelta,
                                                          LOGOFF_TIMER ));

    if ( ulTimeDelta < LOGOFF_TIMER ) {
        IcaTimerStart( pWinStation->hIdleTimer, IdleTimeout, LongToPtr( LogonId ),
                    pWinStation->Config.Config.User.MaxIdleTime - ulTimeDelta );
    } else
        LogoffTimeout( LogonId );

done:
    ReleaseWinStation( pWinStation );
}



/*******************************************************************************
 *
 *  LogoffTimeout
 *
 *  This routine is called when the logoff timer expires.
 *  Log user off and disconnect the winstation.
 *
 * ENTRY:
 *   LogonId - LogonId to logout
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID LogoffTimeout(ULONG LogonId)
{
    PWINSTATION pWinStation;

    pWinStation = FindWinStationById( LogonId, FALSE );

    if ( !pWinStation ) 
        return;

    //
    // Report disconnect reason back to client
    //
    if(pWinStation->WinStationName[0] &&
       pWinStation->pWsx &&
       pWinStation->pWsx->pWsxSetErrorInfo &&
       pWinStation->pWsxContext)
    {
        ULONG discReason = 0;
        if(pWinStation->fIdleTimer)
        {
            discReason = TS_ERRINFO_IDLE_TIMEOUT;
        }
        else if(pWinStation->fLogonTimer)
        {
            discReason = TS_ERRINFO_LOGON_TIMEOUT;
        }

        if(discReason)
        {
            pWinStation->pWsx->pWsxSetErrorInfo(
                               pWinStation->pWsxContext,
                               discReason,
                               FALSE); //stack lock not held
        }
    }

    if ( pWinStation->Config.Config.User.fResetBroken ) {
        ReleaseWinStation( pWinStation );
        QueueWinStationReset( LogonId );
    }
    else {
        ReleaseWinStation( pWinStation );
        QueueWinStationDisconnect( LogonId );
    }
}


/*******************************************************************************
 *
 *  DisconnectTimeout
 *
 *  This routine is called when the disconnect timer expires.
 *  Reset the winstation.
 *
 * ENTRY:
 *   LogonId
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID DisconnectTimeout( ULONG LogonId )
{
    //This timer pops for a disconnected session
    //so there is no need to report an error back to
    //the client
    QueueWinStationReset( LogonId );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\wait.c ===
/*************************************************************************
*
* wait.c
*
* WinStation wait for connection routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include "conntfy.h"

// These are the maximum lengths of UserName, Password and Domain allowed by Winlogon
#define MAX_ALLOWED_USERNAME_LEN 255
#define MAX_ALLOWED_PASSWORD_LEN 126
#define MAX_ALLOWED_DOMAIN_LEN   255   



/*=============================================================================
==   Data
=============================================================================*/

NTSTATUS
WinStationInheritSecurityDescriptor(
    PVOID pSecurityDescriptor,
    PWINSTATION pTargetWinStation
    );
NTSTATUS
WaitForConsoleConnectWorker( PWINSTATION pWinStation );
BOOL
IsKernelDebuggerAttached();


extern PSECURITY_DESCRIPTOR DefaultConsoleSecurityDescriptor;

extern WINSTATIONCONFIG2 gConsoleConfig;
extern HANDLE   WinStationIdleControlEvent;
extern RTL_CRITICAL_SECTION ConsoleLock;
extern RTL_RESOURCE WinStationSecurityLock;


/*****************************************************************************
 *
 *  WaitForConnectWorker
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pWinStation (input)
 *      Pointer to our WinStation (locked)
 *
 *    Note, comes in locked and returned released.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WaitForConnectWorker( PWINSTATION pWinStation, HANDLE ClientProcessId )
{
    OBJECT_ATTRIBUTES ObjA;
    ULONG ReturnLength;
    BYTE version;
    ULONG Offset;
    ICA_STACK_LAST_ERROR tdlasterror;
    WINSTATION_APIMSG WMsg;
    BOOLEAN rc;
    NTSTATUS Status;
    BOOLEAN fOwnsConsoleTerminal = FALSE;
    ULONG BytesGot ; 

#define MODULE_SIZE 1024

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WaitForConnectWorker, LogonId=%d\n",
           pWinStation->LogonId ));


       KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WaitForConnectWorker, LogonId=%d\n",pWinStation->LogonId ));

    /*
     * You only go through this API once
     */
    if ( !pWinStation->NeverConnected ) {
        ReleaseWinStation( pWinStation );
#ifdef DBG
        DbgBreakPoint();
#endif
        return( STATUS_ACCESS_DENIED );
    }

    // Should really be winlogon only here, however if ntsd is started
    // then the first time we know it's winlogon is here.

    /*
     * Ensure this is WinLogon calling
     */
    if ( ClientProcessId != pWinStation->InitialCommandProcessId ) {

        /*
         * If NTSD is started instead of winlogon, the InitialCommandProcessId is wrong.
         */
        if ( !pWinStation->InitialProcessSet ) {

            //  need to close handle if already opened
            if ( pWinStation->InitialCommandProcess ) {
                NtClose( pWinStation->InitialCommandProcess );
                pWinStation->InitialCommandProcess = NULL;
                InvalidateTerminateWaitList();
            }

            pWinStation->InitialCommandProcess = OpenProcess(
                PROCESS_ALL_ACCESS,
                FALSE,
                (DWORD)(UINT_PTR)ClientProcessId );

            if ( pWinStation->InitialCommandProcess == NULL ) {
                ReleaseWinStation( pWinStation );
                Status = STATUS_ACCESS_DENIED;
                goto done;
            }
            pWinStation->InitialCommandProcessId = ClientProcessId;
            pWinStation->InitialProcessSet = TRUE;

        }
        else {
            ReleaseWinStation( pWinStation );
            Status = STATUS_SUCCESS;
            goto done;
        }
    }
    else {
        /*
         * Only do this once
         */
        pWinStation->InitialProcessSet = TRUE;
    }

    /*
     * Console's work is done
     */


    /*
     * At this point the create is done.
     */
    if (pWinStation->CreateEvent != NULL) {
        NtSetEvent( pWinStation->CreateEvent, NULL );
    }


    /*
     * At this point The session may be terminating. If this is
     * the case, fail the call now.
     */

    if ( pWinStation->Terminating ) {
        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_CLOSE_PENDING;
        goto done;
    }


    /*
     * We are going to wait for a connect (Idle)
     */
    memset( &WMsg, 0, sizeof(WMsg) );
    pWinStation->State = State_Idle;
    NotifySystemEvent( WEVENT_STATECHANGE );

    /*
     * Initialize connect event to wait on
     */
    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
    Status = NtCreateEvent( &pWinStation->ConnectEvent, EVENT_ALL_ACCESS, &ObjA,
                            NotificationEvent, FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * OK, now wait for a connection
     */
    UnlockWinStation( pWinStation );
    Status = NtWaitForSingleObject( pWinStation->ConnectEvent, FALSE, NULL );
    rc = RelockWinStation( pWinStation );

    if ( !NT_SUCCESS(Status) ) {
        ReleaseWinStation( pWinStation );
        goto done;

    }

    fOwnsConsoleTerminal = pWinStation->fOwnsConsoleTerminal;

    if (pWinStation->ConnectEvent) {
        NtClose( pWinStation->ConnectEvent );
        pWinStation->ConnectEvent = NULL;
    }
    if ( !rc || pWinStation->Terminating ) {
        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_CLOSE_PENDING;
        goto done;
    }

    // if this is a connect to the console session, Do all the console specific.
    if (fOwnsConsoleTerminal) {
        Status = WaitForConsoleConnectWorker( pWinStation );
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Reset the broken connection Flag.
     *
     */

    pWinStation->StateFlags &= ~WSF_ST_BROKEN_CONNECTION;



    /*
     * Duplicate the beep channel.
     * This is one channel that both CSR and ICASRV have open.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Beep,
                             NULL,
                             &pWinStation->hIcaBeepChannel );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationWaitForConnect, LogonId=%d, IcaChannelOpen 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaBeepChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaBeepChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationWaitForConnect, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Duplicate the thinwire channel.
     * This is one channel that both CSR and ICASRV have open.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Virtual,
                             VIRTUAL_THINWIRE,
                             &pWinStation->hIcaThinwireChannel );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationWaitForConnect, LogonId=%d, IcaChannelOpen 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaThinwireChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaThinwireChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationWaitForConnect, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                  IOCTL_ICA_CHANNEL_ENABLE_SHADOW,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Video channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Video,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaVideoChannel );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationOpenChannel, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Keyboard channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Keyboard,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaKeyboardChannel );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationOpenChannel, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Mouse channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Mouse,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaMouseChannel );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationOpenChannel, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Command channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Command,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaCommandChannel );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationOpenChannel, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }


    /*
     * Secure any virtual channels
     */
    VirtualChannelSecurity( pWinStation );

    /*
     *  Client specific connection extension completion
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxInitializeClientData ) {
         
        Status = pWinStation->pWsx->pWsxInitializeClientData( pWinStation->pWsxContext,
                                                              pWinStation->hStack,
                                                              pWinStation->hIca,
                                                              pWinStation->hIcaThinwireChannel,
                                                              pWinStation->VideoModuleName,
                                                              sizeof(pWinStation->VideoModuleName),
                                                              &pWinStation->Config.Config.User,
                                                              &pWinStation->Client.HRes,
                                                              &pWinStation->Client.VRes,
                                                              &pWinStation->Client.ColorDepth,
                                                              &WMsg.u.DoConnect );
        if ( !NT_SUCCESS( Status ) ) {
            ReleaseWinStation( pWinStation );
            goto done;
        }

        if (pWinStation->LogonId == 0 || g_bPersonalTS) {
            if (pWinStation->hWinmmConsoleAudioEvent) {
                if (pWinStation->Client.fRemoteConsoleAudio) {
                    // Set the console audio event - means console audio can be remoted
                    SetEvent(pWinStation->hWinmmConsoleAudioEvent);
                }
                else {
                    // Set the console audio event - means console audio can't be remoted
                    ResetEvent(pWinStation->hWinmmConsoleAudioEvent);
                }
            }            
        }
    }

    /* Get long UserNames and Password now */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxEscape ) {

        pWinStation->pNewClientCredentials = MemAlloc( sizeof(ExtendedClientCredentials) ); 
        if (pWinStation->pNewClientCredentials == NULL) {
            ReleaseWinStation( pWinStation );
            goto done; 
        }
         
        Status = pWinStation->pWsx->pWsxEscape( pWinStation->pWsxContext,
                                                GET_LONG_USERNAME,
                                                NULL,
                                                0,
                                                pWinStation->pNewClientCredentials,
                                                sizeof(ExtendedClientCredentials),
                                                &BytesGot) ; 

        if (NT_SUCCESS(Status)) {

            // WsxEscape for GET_LONG_USERNAME succeeded

            // Check if u need the ExtendedClientCredentials - the common case is short UserName and
            // short password - so optimize the common case

            if ( (wcslen(pWinStation->pNewClientCredentials->UserName) <= USERNAME_LENGTH) &&
                 (wcslen(pWinStation->pNewClientCredentials->Password) <= PASSWORD_LENGTH) &&
                 (wcslen(pWinStation->pNewClientCredentials->Domain) <= DOMAIN_LENGTH) ) {

                // We can use the old credentials itself
                MemFree(pWinStation->pNewClientCredentials);
                pWinStation->pNewClientCredentials = NULL ; 
            }
    
            // Winlogon does not allow > 126 chars for Password and > 255 chars for UserName and Domain in some code paths
            // So we have to use the old truncated credentials in case the extended credentials exceed these limits

            if (pWinStation->pNewClientCredentials != NULL) {
    
                if (wcslen(pWinStation->pNewClientCredentials->UserName) > MAX_ALLOWED_USERNAME_LEN) {
                    wcscpy(pWinStation->pNewClientCredentials->UserName, pWinStation->Config.Config.User.UserName);
                }
                if (wcslen(pWinStation->pNewClientCredentials->Password) > MAX_ALLOWED_PASSWORD_LEN) {
                    wcscpy(pWinStation->pNewClientCredentials->Password, pWinStation->Config.Config.User.Password); 
                }
                if (wcslen(pWinStation->pNewClientCredentials->Domain) > MAX_ALLOWED_DOMAIN_LEN) {
                    wcscpy(pWinStation->pNewClientCredentials->Domain, pWinStation->Config.Config.User.Domain);
                }
            }
        } else {
            // WsxEscape for GET_LONG_USERNAME failed
            MemFree(pWinStation->pNewClientCredentials);
            pWinStation->pNewClientCredentials = NULL ;
        }

    }

    /*
     * Store WinStation name in connect msg
     */
    RtlCopyMemory( WMsg.u.DoConnect.WinStationName,
                   pWinStation->WinStationName,
                   sizeof(WINSTATIONNAME) );

    /*
     * KLUDGE ALERT!!
     * The Wsx initializes AudioDriverName in the DoConnect struct.
     * However, we need to save it for later use during reconnect,
     * so we now copy it into the WinStation->Client struct.
     * (This field was NOT not initialized during the earlier
     * IOCTL_ICA_STACK_QUERY_CLIENT call.)
     */
    RtlCopyMemory( pWinStation->Client.AudioDriverName,
                   WMsg.u.DoConnect.AudioDriverName,
                   sizeof( pWinStation->Client.AudioDriverName ) );





    /*
     * Store protocol and Display driver name in WINSTATION since we may need them later for reconnect.
     */

    memset(pWinStation->ProtocolName, 0, sizeof(pWinStation->ProtocolName));
    memcpy(pWinStation->ProtocolName, WMsg.u.DoConnect.ProtocolName, sizeof(pWinStation->ProtocolName) - sizeof(WCHAR));

    memset(pWinStation->DisplayDriverName, 0, sizeof(pWinStation->DisplayDriverName));
    memcpy(pWinStation->DisplayDriverName, WMsg.u.DoConnect.DisplayDriverName, sizeof(pWinStation->DisplayDriverName) - sizeof(WCHAR));

    /*
     * Save protocol type, screen resolution, and color depth
     */
    WMsg.u.DoConnect.HRes = pWinStation->Client.HRes;
    WMsg.u.DoConnect.VRes = pWinStation->Client.VRes;
    WMsg.u.DoConnect.ProtocolType = pWinStation->Client.ProtocolType;

    /*
     * Translate the color to the format excpected in winsrv
     */

    switch(pWinStation->Client.ColorDepth){
    case 1:
       WMsg.u.DoConnect.ColorDepth=4 ; // 16 colors
      break;
    case 2:
       WMsg.u.DoConnect.ColorDepth=8 ; // 256
       break;
    case 4:
       WMsg.u.DoConnect.ColorDepth= 16;// 64K
       break;
    case 8:
       WMsg.u.DoConnect.ColorDepth= 24;// 16M
       break;
#define DC_HICOLOR
#ifdef DC_HICOLOR
    case 16:
       WMsg.u.DoConnect.ColorDepth= 15;// 32K
       break;
#endif
    default:
       WMsg.u.DoConnect.ColorDepth=8 ;
       break;
    }


    WMsg.u.DoConnect.KeyboardType        = pWinStation->Client.KeyboardType;
    WMsg.u.DoConnect.KeyboardSubType     = pWinStation->Client.KeyboardSubType;
    WMsg.u.DoConnect.KeyboardFunctionKey = pWinStation->Client.KeyboardFunctionKey;


    /*
     * Tell Win32 about the connection
     */

    WMsg.ApiNumber = SMWinStationDoConnect;

    Status = SendWinStationCommand( pWinStation, &WMsg, 600 );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: SMWinStationDoConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        goto done;
    } else {
        pWinStation->StateFlags |= WSF_ST_CONNECTED_TO_CSRSS;

    }

    //
    //Set session time zone information.
    //
#ifdef TERMSRV_USE_CLIENT_TIME_ZONE
    {
        WINSTATION_APIMSG TimezoneMsg;
        memset( &TimezoneMsg, 0, sizeof(TimezoneMsg) );

        TimezoneMsg.ApiNumber = SMWinStationSetTimeZone;
        memcpy(&(TimezoneMsg.u.SetTimeZone.TimeZone),&(pWinStation->Client.ClientTimeZone),
                    sizeof(TS_TIME_ZONE_INFORMATION));

       SendWinStationCommand( pWinStation, &TimezoneMsg, 600 );

    }
#endif
    /*
     * Indicate we're now connected. Only after succesful connection to Win32/CSR.
     */
    pWinStation->NeverConnected = FALSE;


    /*
     * Check if we received a broken connection indication while connecting to  to Win32/CSR.
     */

    if (pWinStation->StateFlags & WSF_ST_BROKEN_CONNECTION) {
        QueueWinStationReset(pWinStation->LogonId);
        Status = STATUS_CTX_CLOSE_PENDING;
        ReleaseWinStation( pWinStation );
        goto done;
    }


    /*
     * Set connect time and start disconnect timer
     */
    NtQuerySystemTime( &pWinStation->ConnectTime );

    /*
     * Attempt to connect to the CdmRedirector
     * for Client Drive Mapping
     *
     * NOTE: We still init the WinStation even if Client Drive
     *       mapping does not connect.
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxCdmConnect ) {
        Status = pWinStation->pWsx->pWsxCdmConnect( pWinStation->pWsxContext,
                                                    pWinStation->LogonId,
                                                    pWinStation->hIca );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: CdmConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    Status = STATUS_SUCCESS;


    pWinStation->State = State_Connected;
    NotifySystemEvent( WEVENT_CONNECT | WEVENT_STATECHANGE );


    Status = NotifyConnect(pWinStation, fOwnsConsoleTerminal);
    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(( "TERMSRV: NotifyConsoleConnect failed  Status= 0x%x\n", Status));
    }

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );



done:

    /*
     * Failure here will cause Winlogon to terminate the session. If we are failing
     * the console session, let wake up the IdleControlThread, he may have to create
     * a new console session.
     */
    if (!NT_SUCCESS( Status ) && fOwnsConsoleTerminal) {
        NtSetEvent(WinStationIdleControlEvent, NULL);
    }


    return( Status );
}

// Since the physical console does not have a real client, init data to some defaults
void    InitializeConsoleClientData( PWINSTATIONCLIENTW  pWC )
{
    pWC->fTextOnly          = FALSE;
    pWC->fDisableCtrlAltDel = FALSE; 
    pWC->fMouse             = TRUE; 
    pWC->fDoubleClickDetect = FALSE; 
    pWC->fINetClient        = FALSE; 
    pWC->fPromptForPassword = FALSE;  
    pWC->fMaximizeShell     = TRUE; 
    pWC->fEnableWindowsKey  = TRUE; 
    pWC->fRemoteConsoleAudio= FALSE; 
    
    wcscpy( pWC->ClientName      , L"");
    wcscpy( pWC->Domain          , L"");                                     
    wcscpy( pWC->UserName        , L"");                                 
    wcscpy( pWC->Password        , L"");
    wcscpy( pWC->WorkDirectory   , L"");
    wcscpy( pWC->InitialProgram  , L"");                    
    
    pWC->SerialNumber            = 0;        // client computer unique serial number    
    pWC->EncryptionLevel         = 3;        // security level of encryption pd         
    pWC->ClientAddressFamily     = 0;                                             
    
    wcscpy( pWC->ClientAddress      , L"");
    
    pWC->HRes                    = 640;                                    
    pWC->VRes                    = 480;                                                           
    pWC->ColorDepth              = 0x2;                                                     
    pWC->ProtocolType            = PROTOCOL_CONSOLE ;
    pWC->KeyboardLayout          = 0;                                                  
    pWC->KeyboardType            = 0;                                                    
    pWC->KeyboardSubType         = 0;                                                 
    pWC->KeyboardFunctionKey     = 0;                                             
    
    wcscpy( pWC->imeFileName    , L"");
    wcscpy( pWC->ClientDirectory, L"");
    wcscpy( pWC->ClientLicense  , L"");
    wcscpy( pWC->ClientModem    , L"");
    
    pWC->ClientBuildNumber       = 0;                                               
    pWC->ClientHardwareId        = 0;    // client software serial number            
    pWC->ClientProductId         = 0;    // client software product id              
    pWC->OutBufCountHost         = 0;    // number of outbufs on host               
    pWC->OutBufCountClient       = 0;    // number of outbufs on client             
    pWC->OutBufLength            = 0;    // length of outbufs in bytes              
    
    wcscpy( pWC->AudioDriverName, L"" );

    pWC->ClientSessionId = LOGONID_NONE;
    
    {
        //This time zone information is invalid
        //using it we set BaseSrvpStaticServerData->TermsrvClientTimeZoneId to
        //TIME_ZONE_ID_INVALID!
        TS_TIME_ZONE_INFORMATION InvalidTZ={0,L"",
                {0,10,0,6/*this number makes it invalid; day numbers >5 not allowed*/,0,0,0,0},0,L"",
                {0,4,0,6/*this number makes it invalid*/,0,0,0,0},0};

        memcpy(&(pWC->ClientTimeZone), &InvalidTZ, 
            sizeof(TS_TIME_ZONE_INFORMATION));
    }

    pWC->clientDigProductId[0] = 0;
}

BOOLEAN gConsoleNeverConnected = TRUE;

NTSTATUS
WaitForConsoleConnectWorker( PWINSTATION pWinStation )
{
    OBJECT_ATTRIBUTES ObjA;
    ULONG ReturnLength;
    BYTE version;
    ULONG Offset;
    ICA_STACK_LAST_ERROR tdlasterror;
    WINSTATION_APIMSG WMsg;
    BOOLEAN rc;
    NTSTATUS Status;

#define MODULE_SIZE 1024

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WaitForConnectWorker, LogonId=%d\n",
           pWinStation->LogonId ));


       KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d\n", pWinStation->LogonId ));

    if (pWinStation->LogonId == 0) {
        /*
         * We need to acquire console lock. UnLock winstation first to avoid deadlock.
         */

        UnlockWinStation( pWinStation );
        ENTERCRIT( &ConsoleLock );
        if (!RelockWinStation( pWinStation )) {
            LEAVECRIT( &ConsoleLock );
            return STATUS_CTX_WINSTATION_NOT_FOUND;
        }

        /*
         * You only go through this API once for console session.
         */
        if (!gConsoleNeverConnected) {
            LEAVECRIT( &ConsoleLock );
            return STATUS_SUCCESS;
        }
    }


    if (!pWinStation->pSecurityDescriptor && pWinStation->LogonId) {
        RtlAcquireResourceShared(&WinStationSecurityLock, TRUE);
        Status = RtlCopySecurityDescriptor(DefaultConsoleSecurityDescriptor,
                                              &(pWinStation->pSecurityDescriptor));
        RtlReleaseResource(&WinStationSecurityLock);
    }



    // Read console config, 
    // For the session 0, this was already initalized in WinStationCreateWorker()

    if (pWinStation->LogonId != 0) {

         pWinStation->Config = gConsoleConfig;

         // initalize client data, since there isn't any real rdp client sending anythhing to us
         InitializeConsoleClientData( & pWinStation->Client );
    }


    /*
     * We are going to wait for a connect (Idle)
     */
    memset( &WMsg, 0, sizeof(WMsg) );
    pWinStation->State = State_ConnectQuery;
    NotifySystemEvent( WEVENT_STATECHANGE );

    /*
     * Initialize connect event to wait on
     */
    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
    if (pWinStation->ConnectEvent == NULL) {
        Status = NtCreateEvent( &pWinStation->ConnectEvent, EVENT_ALL_ACCESS, &ObjA,
                                NotificationEvent, FALSE );
        if ( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtCreateEvent 0x%x\n",
                      pWinStation->LogonId, Status  ));
            goto done;
        }

    }


    /*
     * Duplicate the beep channel.
     * This is one channel that both CSR and ICASRV have open.
     */
    if (pWinStation->hIcaBeepChannel == NULL) {
        Status = IcaChannelOpen( pWinStation->hIca,
                                 Channel_Beep,
                                 NULL,
                                 &pWinStation->hIcaBeepChannel );

        if ( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, IcaChannelOpen 0x%x\n",
                      pWinStation->LogonId, Status  ));
            goto done;
        }
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaBeepChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaBeepChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Duplicate the thinwire channel.
     * This is one channel that both CSR and ICASRV have open.
     */
    if (pWinStation->hIcaThinwireChannel == NULL) {
        Status = IcaChannelOpen( pWinStation->hIca,
                                 Channel_Virtual,
                                 VIRTUAL_THINWIRE,
                                 &pWinStation->hIcaThinwireChannel );

        if ( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, IcaChannelOpen 0x%x\n",
                      pWinStation->LogonId, Status  ));
            goto done;
        }
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaThinwireChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaThinwireChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                  IOCTL_ICA_CHANNEL_ENABLE_SHADOW,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Video channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Video,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaVideoChannel );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Keyboard channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Keyboard,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaKeyboardChannel );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Mouse channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Mouse,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaMouseChannel );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Command channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Command,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaCommandChannel );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }


    if (!pWinStation->LogonId) {
        goto SkipClientData;
    }
    /*
     * Secure any virtual channels
     */
    VirtualChannelSecurity( pWinStation );

   /*
     * Tell Win32 about the connection
     */

    WMsg.u.DoConnect.fEnableWindowsKey = (BOOLEAN) pWinStation->Client.fEnableWindowsKey;
SkipClientData:
    WMsg.ApiNumber = SMWinStationDoConnect;

    Status = SendWinStationCommand( pWinStation, &WMsg, 600 );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: SMWinStationDoConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker SMWinStationDoConnect failed  Status= 0x%x\n", Status));
        goto done;
    } else {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WaitForConsoleConnectWorker SMWinStationDoConnect OK\n"));
        pWinStation->StateFlags |= WSF_ST_CONNECTED_TO_CSRSS;
        if (pWinStation->LogonId == 0) {
            gConsoleNeverConnected=FALSE;
        }

    }


    /*
     * Indicate we're now connected. Only after succesful connection to Win32/CSR.
     */
    pWinStation->NeverConnected = FALSE;


    /*
     * Check if we received a broken connection indication while connecting to  to Win32/CSR.
     */

    if (pWinStation->StateFlags & WSF_ST_BROKEN_CONNECTION) {
        QueueWinStationReset(pWinStation->LogonId);
        Status = STATUS_CTX_CLOSE_PENDING;
        goto done;
    }


    /*
     * Set connect time and start disconnect timer
     */
    NtQuerySystemTime( &pWinStation->ConnectTime );

    /*
     * Attempt to connect to the CdmRedirector
     * for Client Drive Mapping
     *
     * NOTE: We still init the WinStation even if Client Drive
     *       mapping does not connect.
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxCdmConnect ) {
        Status = pWinStation->pWsx->pWsxCdmConnect( pWinStation->pWsxContext,
                                                    pWinStation->LogonId,
                                                    pWinStation->hIca );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: CdmConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    Status = STATUS_SUCCESS;

    /*
     *  Start logon timers
     */
    StartLogonTimers( pWinStation );

    pWinStation->State = State_Connected;
    NotifySystemEvent( WEVENT_CONNECT | WEVENT_STATECHANGE );

    Status = NotifyConnect(pWinStation, pWinStation->fOwnsConsoleTerminal);
    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(( "TERMSRV: NotifyConsoleConnect failed  Status= 0x%x\n", Status));
    }


done:
    //
    //  Set the licensing policy for the console session. This must be done
    //  to prevent a weird state when a console session goes remote. This must
    //  Done weither wi faill or succeed. Licensing code assumes the policy is
    //  set.
    //
    if (pWinStation->LogonId == 0) {
        LEAVECRIT( &ConsoleLock );
    }
    LCAssignPolicy(pWinStation);

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\winget.c ===
/****************************************************************************/
// winget.c
//
// TermSrv RPC query handler.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "rpcwire.h"
#include "conntfy.h" // for GetLockedState

#include <winsock2.h>
#include <ws2tcpip.h>

#define MODULE_SIZE 1024
extern WCHAR g_DigProductId[CLIENT_PRODUCT_ID_LENGTH];

// Extern function
extern NTSTATUS _CheckCallerLocalAndSystem(VOID);

/*=============================================================================
==   Private functions
=============================================================================*/
NTSTATUS xxxGetUserToken(PWINSTATION, WINSTATIONUSERTOKEN UNALIGNED *, ULONG);


/*=============================================================================
==   Functions Used
=============================================================================*/
NTSTATUS xxxWinStationQueryInformation(ULONG, WINSTATIONINFOCLASS,
        PVOID, ULONG, PULONG);

NTSTATUS
RpcCheckClientAccess(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

NTSTATUS
RpcCheckSystemClientEx(
    PWINSTATION pWinStation
    );

NTSTATUS
RpcCheckSystemClientNoLogonId(
    PWINSTATION pWinStation
    );

BOOLEAN
ValidWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen);

BOOLEAN
IsCallerAllowedPasswordAccess(VOID);

//
// Query client's IP Address.
//
extern NTSTATUS
xxxQueryRemoteAddress(
    PWINSTATION pWinStation,
    PWINSTATIONREMOTEADDRESS pRemoteAddress
    )
{
    struct sockaddr_in6 addr6;
    ULONG   AddrBytesReturned;
    NTSTATUS Status;

    if( pWinStation->State != State_Active && pWinStation->State != State_Connected )
    {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
    }
    else
    {
        Status = IcaStackIoControl( pWinStation->hStack,
                                    IOCTL_TS_STACK_QUERY_REMOTEADDRESS,
                                    pWinStation->pEndpoint,
                                    pWinStation->EndpointLength,
                                    &addr6,
                                    sizeof( addr6 ),
                                    &AddrBytesReturned
                                );

        if( NT_SUCCESS(Status) )
        {
            pRemoteAddress->sin_family = addr6.sin6_family;
            if( AF_INET == addr6.sin6_family )
            {
                struct sockaddr_in* pAddr = (struct sockaddr_in *)&addr6;

                pRemoteAddress->ipv4.sin_port = pAddr->sin_port;
                pRemoteAddress->ipv4.in_addr = pAddr->sin_addr.s_addr;
            }
            else
            {
                // Support of IPV6 is for next release.
                Status = STATUS_NOT_SUPPORTED;
            }
        }
    }

    return Status;
}


ULONG GetLoadMetrics(PWINSTATIONLOADINDICATORDATA pLIData)
{
    SYSTEM_PERFORMANCE_INFORMATION SysPerfInfo;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorInfo[MAX_PROCESSORS];
    SYSTEM_BASIC_INFORMATION BasicInfo;

    LARGE_INTEGER TotalCPU = {0, 0};
    LARGE_INTEGER IdleCPU = {0, 0};
    LARGE_INTEGER TotalCPUDelta = {0, 0};
    LARGE_INTEGER IdleCPUDelta = {0, 0};
    ULONG         AvgIdleCPU, AvgBusyCPU, CPUConstrainedSessions;

    ULONG RemainingSessions = 0;
    LOADFACTORTYPE LoadFactor = ErrorConstraint;
    ULONG MinSessions;
    ULONG NumWinStations;
    NTSTATUS StatusPerf, StatusProc, StatusBasic;
    ULONG i;

    // Initialize additional data area
    memset(pLIData->reserved, 0, sizeof(pLIData->reserved));

    // Determine the number of active winstations in the system.  If there
    // aren't any, just assume 1 so we don't have to special case the logic
    // too much.  Note that this code counts the console.
    if (WinStationTotalCount > IdleWinStationPoolCount)
        NumWinStations = WinStationTotalCount - IdleWinStationPoolCount;
    else
        NumWinStations = 1;

    TRACE((hTrace, TC_LOAD, TT_API1,
           "Session Statistics: Total [%ld], Idle [%ld], Disc [%ld]\n",
           WinStationTotalCount, IdleWinStationPoolCount, WinStationDiscCount));

    //
    // Get basic info like total memory, etc.
    //
    StatusBasic = NtQuerySystemInformation(SystemBasicInformation,
                                           &BasicInfo, sizeof(BasicInfo),
                                           NULL);

    //
    // Get resource (memory) utilization metrics
    //
    StatusPerf = NtQuerySystemInformation(SystemPerformanceInformation,
                                          &SysPerfInfo, sizeof(SysPerfInfo), 
                                          NULL);

    //
    // Get CPU utilization metrics
    //
    StatusProc = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                          ProcessorInfo, 
                                          sizeof(ProcessorInfo),
                                          NULL);

    if (gLB.fInitialized && 
        NT_SUCCESS(StatusPerf) && 
        NT_SUCCESS(StatusProc) &&
        NT_SUCCESS(StatusBasic)) {

        ULONG DefaultPagedPool, DefaultPtes, DefaultCommit;
        ULONG CommitAvailable;

        //
        // Determine resource usage for all sessions, subtracting out the 
        // resources required by the base system.  Readjust the base 
        // calculations if they become nonsensical.
        //
    
        // total committment and average consumption
        CommitAvailable = SysPerfInfo.CommitLimit - SysPerfInfo.CommittedPages;
        if (gLB.BaselineCommit < SysPerfInfo.CommittedPages) {
            gLB.CommitUsed = SysPerfInfo.CommittedPages - gLB.BaselineCommit;
            gLB.AvgCommitPerUser = max(gLB.CommitUsed / NumWinStations, 
                                       gLB.MinCommitPerUser);
            DefaultCommit = FALSE;
        }
        else {
            gLB.CommitUsed = 0;
            gLB.AvgCommitPerUser = gLB.MinCommitPerUser;
            gLB.BaselineCommit = SysPerfInfo.CommittedPages;
            DefaultCommit = TRUE;
        }
                    
        TRACE((hTrace, TC_LOAD, TT_API1,
               "   Commit:       Base [%6ld], Used [%6ld], Avail: [%6ld], AvgPerUser: [%6ld]%s\n", 
               gLB.BaselineCommit,
               gLB.CommitUsed, 
               CommitAvailable, 
               gLB.AvgCommitPerUser,
               DefaultCommit ? "*" : ""));
    
        // total system PTEs used and average consumption
        if (gLB.BaselineFreePtes > SysPerfInfo.FreeSystemPtes) {
            gLB.PtesUsed = gLB.BaselineFreePtes - SysPerfInfo.FreeSystemPtes;
            gLB.AvgPtesPerUser = max(gLB.PtesUsed / NumWinStations, 
                                     gLB.MinPtesPerUser);
            DefaultPtes = FALSE;
        }
        else {
            gLB.PtesUsed = 0;
            gLB.AvgPtesPerUser = gLB.MinPtesPerUser;
            gLB.BaselineFreePtes = SysPerfInfo.FreeSystemPtes;
            DefaultPtes = TRUE;
        }

        TRACE((hTrace, TC_LOAD, TT_API1,
               "   Ptes:         Base [%6ld], Used [%6ld], Avail: [%6ld], AvgPerUser: [%6ld]%s\n", 
               gLB.BaselineFreePtes, 
               gLB.PtesUsed, 
               SysPerfInfo.FreeSystemPtes, 
               gLB.AvgPtesPerUser,
               DefaultPtes ? "*" : ""));                
                    
        // paged pool used and average consumption
        if (gLB.BaselinePagedPool < SysPerfInfo.PagedPoolPages) {
            gLB.PagedPoolUsed = SysPerfInfo.PagedPoolPages - gLB.BaselinePagedPool;
            gLB.AvgPagedPoolPerUser = max(gLB.PagedPoolUsed / NumWinStations, 
                                          gLB.MinPagedPoolPerUser);
            DefaultPagedPool = FALSE;
        }
        else {
            gLB.PagedPoolUsed = 0;
            gLB.AvgPagedPoolPerUser = gLB.MinPagedPoolPerUser;
            gLB.BaselinePagedPool = SysPerfInfo.PagedPoolPages;
            DefaultPagedPool = TRUE;            
        }

        TRACE((hTrace, TC_LOAD, TT_API1,
               "   PagedPool:    Base [%6ld], Used [%6ld], Avail: [%6ld], AvgPerUser: [%6ld]%s\n", 
               gLB.BaselinePagedPool,
               gLB.PagedPoolUsed, 
               SysPerfInfo.AvailablePagedPoolPages, 
               gLB.AvgPagedPoolPerUser,
               DefaultPagedPool ? "*" : ""));
            
        TRACE((hTrace, TC_LOAD, TT_API1,
               "   Session Raw: Commit  [%4ld], Pte    [%4ld], Paged    [%4ld]\n",
               CommitAvailable / gLB.AvgCommitPerUser,
               SysPerfInfo.FreeSystemPtes / gLB.AvgPtesPerUser,
               SysPerfInfo.AvailablePagedPoolPages / gLB.AvgPagedPoolPerUser));

        // Sum up individual CPU usage
        for (i = 0; i < gLB.NumProcessors; i++) {
            IdleCPU.QuadPart += ProcessorInfo[i].IdleTime.QuadPart;
            TotalCPU.QuadPart += ProcessorInfo[i].KernelTime.QuadPart +
                                 ProcessorInfo[i].UserTime.QuadPart;
        }
    
        // Determine CPU deltas for this period
        IdleCPUDelta.QuadPart = IdleCPU.QuadPart - gLB.IdleCPU.QuadPart;
        TotalCPUDelta.QuadPart = TotalCPU.QuadPart - gLB.TotalCPU.QuadPart;
        gLB.IdleCPU.QuadPart = IdleCPU.QuadPart;
        gLB.TotalCPU.QuadPart = TotalCPU.QuadPart;

        // Determine what portion of 255 units we are idle
        AvgIdleCPU = (ULONG) (TotalCPUDelta.QuadPart ? 
                              ((IdleCPUDelta.QuadPart << 8) / TotalCPUDelta.QuadPart) 
                              : 0);

        //
        // Exponential smoothing: 
        //     gLB.AvgIdleCPU = (ULONG) (alpha * gLB.AvgIdleCPU + (1 - alpha) * AvgIdleCPU)
        //
        // When Alpha = 0.75, the equation simplifies to the following:
        //
        gLB.AvgIdleCPU = (3 * gLB.AvgIdleCPU + AvgIdleCPU) >> 2 ;

        // Based on current smoothed CPU usage, calculate how much a session uses
        // on average and extrapolate to max CPU constrained sessions.
        AvgBusyCPU = 255 - gLB.AvgIdleCPU;
        if ((AvgBusyCPU > 0) && (AvgBusyCPU <= 255))
            CPUConstrainedSessions = (NumWinStations << 8) / AvgBusyCPU;
        else
            CPUConstrainedSessions = 0xFFFFFFFF;

        // Now flip it to remaining CPU constrained sessions.  We never let this
        // number hit zero since it doesn't mean session creation will fail.
        if (CPUConstrainedSessions > NumWinStations)
            CPUConstrainedSessions -= NumWinStations;
        else
            CPUConstrainedSessions = 1;

        // Bias the averages a bit to account for growth in the existing sessions
        gLB.AvgCommitPerUser += (ULONG) (gLB.AvgCommitPerUser >> SimGrowthBias);
        gLB.AvgPtesPerUser += (ULONG) (gLB.AvgPtesPerUser >> SimGrowthBias);
        gLB.AvgPagedPoolPerUser += (ULONG) (gLB.AvgPagedPoolPerUser >> SimGrowthBias);
        
        TRACE((hTrace, TC_LOAD, TT_API1,
               "   Session Avg: Commit  [%4ld], Pte    [%4ld], Paged    [%4ld]\n",
               CommitAvailable / gLB.AvgCommitPerUser,
               SysPerfInfo.FreeSystemPtes / gLB.AvgPtesPerUser,
               SysPerfInfo.AvailablePagedPoolPages / gLB.AvgPagedPoolPerUser));
    
        
        TRACE((hTrace, TC_LOAD, TT_API1,
               "   CPU Idle:    Current [%4ld], Avg    [%4ld], Est      [%4ld]\n",
               (AvgIdleCPU * 100) / 255, 
               (gLB.AvgIdleCPU * 100) / 255, 
               CPUConstrainedSessions));
    
        //
        // Find the most constrained resource!  Failure on any one of these 
        // items means we will not be likely to start a session.
        //
    
        // Commit Constraint (TODO: needs refinement, doesn't consider paging
        RemainingSessions = CommitAvailable / gLB.AvgCommitPerUser ;
        LoadFactor = AvailablePagesConstraint;
        pLIData->reserved[AvailablePagesConstraint] = RemainingSessions;
            
        // Free System PTEs Constraint
        MinSessions = SysPerfInfo.FreeSystemPtes / gLB.AvgPtesPerUser;
        if (MinSessions < RemainingSessions) {
            RemainingSessions = MinSessions;
            LoadFactor = SystemPtesConstraint;
        }
        pLIData->reserved[SystemPtesConstraint] = MinSessions;
    
        // Paged Pool Constraint
        MinSessions = SysPerfInfo.AvailablePagedPoolPages / gLB.AvgPagedPoolPerUser;
        if (MinSessions < RemainingSessions) {
            RemainingSessions = MinSessions;
            LoadFactor = PagedPoolConstraint;
        }
        pLIData->reserved[PagedPoolConstraint] = MinSessions;
        
        gLB.RemainingSessions = RemainingSessions;

        //
        // Add in constraints that are good indicators of application performance.
        // We will likely create a session if these resources are low, but the
        // user experience will suffer.

        // CPU Contraint
        if (CPUConstrainedSessions < RemainingSessions) {
            LoadFactor = CPUConstraint;
            RemainingSessions = CPUConstrainedSessions;
        }
        pLIData->reserved[CPUConstraint] = MinSessions;

                
        gLB.EstimatedSessions = RemainingSessions;
    
    
        TRACE((hTrace, TC_LOAD, TT_API1,
               "Remaining Sessions:   Raw: [%4ld], Est: [%4ld], Factor = %s, Commit = %ld\n\n",
               gLB.RemainingSessions, gLB.EstimatedSessions,
               LoadFactor == AvailablePagesConstraint ? "Available Memory" :
              (LoadFactor == SystemPtesConstraint     ? "SystemPtes"       :
              (LoadFactor == PagedPoolConstraint      ? "PagedPool"        :
              (LoadFactor == CPUConstraint            ? "CPU"              :
               "Unknown!"))), SysPerfInfo.CommittedPages
              ));
        
        //
        // Return data to caller
        //
        pLIData->RemainingSessionCapacity = gLB.EstimatedSessions;
        pLIData->RawSessionCapacity = gLB.RemainingSessions;
        pLIData->LoadFactor = LoadFactor;
        pLIData->TotalSessions = NumWinStations;
        pLIData->DisconnectedSessions = WinStationDiscCount;

        // Had to split this up for IA64 alignment issues
        pLIData->IdleCPU.HighPart = IdleCPUDelta.HighPart;
        pLIData->IdleCPU.LowPart = IdleCPUDelta.LowPart;
        pLIData->TotalCPU.HighPart = TotalCPUDelta.HighPart;
        pLIData->TotalCPU.LowPart = TotalCPUDelta.LowPart;
    }

    // The load metrics failed to intialize! Set the capacity sky high to still
    // allow access to the server.
    else {
        RemainingSessions = 0xFFFFFFFF;
        pLIData->RemainingSessionCapacity = RemainingSessions;
        pLIData->RawSessionCapacity = RemainingSessions;
        pLIData->LoadFactor = ErrorConstraint;
        pLIData->TotalSessions = NumWinStations;
        pLIData->DisconnectedSessions = WinStationDiscCount;
        
        // Had to split this up for IA64 alignment issues
        pLIData->IdleCPU.HighPart = 0;
        pLIData->IdleCPU.LowPart = 99;
        pLIData->TotalCPU.HighPart = 0;
        pLIData->TotalCPU.LowPart = 100;
        
        TRACE((hTrace, TC_LOAD, TT_ERROR,
               "GetLoadMetrics failed: init [%ld], Proc [%lx], Perf [%lx], Basic [%lx]!\n",
               gLB.fInitialized, StatusProc, StatusPerf, StatusBasic));
    }

    return RemainingSessions;
}


/*******************************************************************************
 *  xxxWinStationQueryInformation
 *
 *    Query window station information  (worker routine)
 *
 * ENTRY:
 *    LogonId (input)
 *       Session ID corresponding to the session.
 *    WinStationInformationClass (input)
 *       Specifies the type of information to get from the specified window
 *       station object.
 *    pWinStationInformation (output)
 *       A pointer to a buffer that contains information to get for the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being set.
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *    pReturnLength (output)
 *         Specifies the amount returned in the buffer
 ******************************************************************************/
NTSTATUS xxxWinStationQueryInformation(
        ULONG LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG pReturnLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HINSTANCE hInstance;
    PWINSTATION pWinStation = NULL;
    ULONG cbReturned;
    ICA_STACK_LAST_INPUT_TIME       Ica_Stack_Last_Input_Time;
    WINSTATION_APIMSG WMsg;
    PWINSTATIONVIDEODATA pVideoData;
    HANDLE hVirtual;
    ULONG i;

    *pReturnLength = 0;

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationQueryInformation LogonId=%d, Class=%d\n",
            LogonId, (ULONG)WinStationInformationClass));

    /*
     * Find the WinStation
     * Return error if not found or currently terminating.
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if (pWinStation == NULL)
        return STATUS_CTX_WINSTATION_NOT_FOUND;
    if (pWinStation->Terminating) {
        ReleaseWinStation(pWinStation);
        return STATUS_CTX_CLOSE_PENDING;
    }

    /*
     * Verify that client has QUERY access
     */
    Status = RpcCheckClientAccess(pWinStation, WINSTATION_QUERY, FALSE);
    if (!NT_SUCCESS(Status)) {
        ReleaseWinStation(pWinStation);
        return Status;
    }

    switch ( WinStationInformationClass ) {
    
        case WinStationLoadIndicator:
        {
            PWINSTATIONLOADINDICATORDATA pLIData = 
                (PWINSTATIONLOADINDICATORDATA) pWinStationInformation;
    
            if (WinStationInformationLength >= sizeof(WINSTATIONLOADINDICATORDATA)) {
                GetLoadMetrics(pLIData);

                *pReturnLength = sizeof(WINSTATIONLOADINDICATORDATA);
            }
            else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        break;

        case WinStationInformation:
        {
            if (!ValidWireBuffer(WinStationInformationClass,
                     pWinStationInformation,
                     WinStationInformationLength))
            {
                Status = STATUS_INVALID_USER_BUFFER;
            }
            else
            {
                WINSTATIONINFORMATION           *pInfo;
                PROTOCOLSTATUS                  *pIca_Stack_Query_Status;

                pInfo = MemAlloc( sizeof( WINSTATIONINFORMATION ) ) ;

                if ( pInfo )
                {
                        pIca_Stack_Query_Status = MemAlloc( sizeof( PROTOCOLSTATUS ) );
                        if ( pIca_Stack_Query_Status  )
                        {
                            TCHAR         *szUserName = NULL, *szDomainName = NULL;
                            DWORD         dwUserSize = MAX_PATH, dwDomainSize = MAX_PATH;
                            SID_NAME_USE  TypeOfAccount;
                            BOOL          LookupResult;

                            memset( pInfo, 0, sizeof( PWINSTATIONINFORMATION ) );
                            wcscpy( pInfo->WinStationName, pWinStation->WinStationName );
                            memcpy( pInfo->Domain, pWinStation->Domain, sizeof( pInfo->Domain ) );
                            memcpy( pInfo->UserName, pWinStation->UserName, sizeof( pInfo->UserName ) );

                            // Since the Username stored maybe stale, query the Username again
                            // Intentionally we do not fail if we are not able to allocate szUserName and szDomainName
                            // This is because we can send the cached credentials in that case

                            szUserName = MemAlloc(MAX_PATH);
                            if ( szUserName ) {

                                szDomainName = MemAlloc(MAX_PATH);
                                if ( szDomainName ) {

                                    LookupResult = LookupAccountSid(NULL, 
                                                                    pWinStation->pUserSid, 
                                                                    szUserName, 
                                                                    &dwUserSize, 
                                                                    szDomainName, 
                                                                    &dwDomainSize, 
                                                                    &TypeOfAccount);

                                    if (LookupResult) {
    
                                        // Re-copy and update WINSTATION struct if the Username or Domain has changed  
                                        if ( (szUserName) && (lstrcmpi(pWinStation->UserName, szUserName)) ) {
                                            memcpy( pInfo->UserName, szUserName, sizeof(pInfo->UserName) );
                                            memcpy( pWinStation->UserName, szUserName, sizeof(pWinStation->UserName) );
                                        } 
                                        if ( (szDomainName) && (lstrcmpi(pWinStation->Domain, szDomainName)) ) {
                                            memcpy( pInfo->Domain, szDomainName, sizeof(pInfo->Domain) );
                                            memcpy( pWinStation->Domain, szDomainName, sizeof(pWinStation->Domain) );
                                        } 
                                    }
                                }
                            }

                            if (szUserName != NULL) {
                                MemFree(szUserName);
                            }

                            if (szDomainName != NULL) {
                                MemFree(szDomainName);
                            }
  
                            pInfo->ConnectState = pWinStation->State;
                            pInfo->LogonId = pWinStation->LogonId;
                            pInfo->ConnectTime = pWinStation->ConnectTime;
                            pInfo->DisconnectTime = pWinStation->DisconnectTime;
                            pInfo->LogonTime = pWinStation->LogonTime;
    
                            if ( pWinStation->hStack && !pWinStation->fOwnsConsoleTerminal ) {
    
                                //  Check for availability
                                if ( pWinStation->pWsx &&
                                        pWinStation->pWsx->pWsxIcaStackIoControl ) {

                                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                                            pWinStation->pWsxContext,
                                                            pWinStation->hIca,
                                                            pWinStation->hStack,
                                                            IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME,
                                                            NULL,
                                                            0,
                                                            &Ica_Stack_Last_Input_Time,
                                                            sizeof( Ica_Stack_Last_Input_Time ),
                                                            &cbReturned );


                                    if ( !NT_SUCCESS( Status ) )
                                    {
                                        MemFree( pInfo );                  
                                        MemFree( pIca_Stack_Query_Status );
                                        break;
                                    }
    
                                    pInfo->LastInputTime = Ica_Stack_Last_Input_Time.LastInputTime;                    
                                }
    
                                //  Check for availability
                                if ( pWinStation->pWsx &&
                                        pWinStation->pWsx->pWsxIcaStackIoControl ) {



                                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(

                                                            pWinStation->pWsxContext,
                                                            pWinStation->hIca,
                                                            pWinStation->hStack,
                                                            IOCTL_ICA_STACK_QUERY_STATUS,
                                                            NULL,
                                                            0,
                                                            pIca_Stack_Query_Status,
                                                            sizeof( PROTOCOLSTATUS ),
                                                            &cbReturned );

                                    if ( !NT_SUCCESS( Status ) )
                                    {
                                        MemFree( pInfo );                  
                                        MemFree( pIca_Stack_Query_Status );
                                        break;
                                    }
    
                                    pInfo->Status = *pIca_Stack_Query_Status;
                                }
    
                                /*
                                 * The thinwire cache data is down in WIN32
                                 */
                                if ( pWinStation->pWin32Context ) {
                                    WMsg.ApiNumber = SMWinStationThinwireStats;

    
                                    Status = SendWinStationCommand( pWinStation, &WMsg, gbServer?5:1 );

                                    if ( Status == STATUS_SUCCESS ) {
                                        pInfo->Status.Cache = WMsg.u.ThinwireStats.Stats;
                                        pWinStation->Cache =  WMsg.u.ThinwireStats.Stats;
                                    } else {
                                        pInfo->Status.Cache = pWinStation->Cache;

                                    }
                                    Status = STATUS_SUCCESS; // ignore errors getting TW stats
                                }
                            } else {
                                /*
                                 * This makes winadmin Idle time happy.
                                 */
                                (VOID) NtQuerySystemTime( &(pInfo->LastInputTime) );                
                            }
    
                            (VOID) NtQuerySystemTime( &pInfo->CurrentTime );
    
                            CopyInWireBuf(WinStationInformationClass,
                                          (PVOID)pInfo,
                                          pWinStationInformation);
                            *pReturnLength = WinStationInformationLength;
    
                            MemFree( pIca_Stack_Query_Status );
                        }
                        else
                        {
                            Status = STATUS_NO_MEMORY;
                        }
                    MemFree(pInfo);
                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }
        break;


        case WinStationConfiguration:
            if (!ValidWireBuffer(WinStationInformationClass,
                                 pWinStationInformation,
                                 WinStationInformationLength)) {
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            CopyInWireBuf(WinStationInformationClass,
                          (PVOID)&pWinStation->Config.Config,
                          pWinStationInformation);

            if (RpcCheckSystemClientEx( pWinStation ) != STATUS_SUCCESS) {
                PWINSTACONFIGWIREW p = pWinStationInformation;
                PUSERCONFIGW u = (PUSERCONFIGW)((PCHAR)p + p->UserConfig.Offset);
                RtlZeroMemory( &u->Password, sizeof(u->Password) );
            }

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationWd:
            if (!ValidWireBuffer(WinStationInformationClass,
                                 pWinStationInformation,
                                 WinStationInformationLength)){
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            CopyInWireBuf(WinStationInformationClass,
                          (PVOID)&pWinStation->Config.Wd,
                          pWinStationInformation);

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationPd:
            if (!ValidWireBuffer(WinStationInformationClass,
                                 pWinStationInformation,
                                 WinStationInformationLength)){
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            CopyInWireBuf(WinStationInformationClass,
                          (PVOID)&pWinStation->Config.Pd[0],
                          pWinStationInformation);

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationCd:
            if ( WinStationInformationLength > sizeof(CDCONFIG) )
                WinStationInformationLength = sizeof(CDCONFIG);

            memcpy( pWinStationInformation,
                    &pWinStation->Config.Cd,
                    WinStationInformationLength );

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationPdParams:
        {
            if (!ValidWireBuffer(WinStationInformationClass,
                 pWinStationInformation,
                 WinStationInformationLength)){
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }
            else
            {
                PDPARAMS *pPdParams;
    
                pPdParams = MemAlloc( sizeof( PDPARAMS ) );
    
                if (pPdParams)
                {

                    CopyOutWireBuf(WinStationInformationClass,
                               (PVOID) pPdParams,
                               pWinStationInformation);
    
                    /*
                     * Based on PDClass, this can query any PD
                     */
                    if ( pWinStation->hStack &&
                         pWinStation->pWsx &&
                         pWinStation->pWsx->pWsxIcaStackIoControl ) {
        
                        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                                pWinStation->pWsxContext,
                                                pWinStation->hIca,
                                                pWinStation->hStack,
                                                IOCTL_ICA_STACK_QUERY_PARAMS,
                                                pPdParams,
                                                sizeof(PDPARAMS ),
                                                pPdParams,
                                                sizeof( PDPARAMS ),
                                                pReturnLength );
        
                        /*
                         * If we get an error in the idle/disconnected state,
                         * or if this is a session on the local console.
                         * then just clear the return buffer and return success.
                         */
                        if ( !NT_SUCCESS( Status ) ) {
                            if ((pWinStation->fOwnsConsoleTerminal) || 
                                    (pWinStation->State != State_Active &&
                                    pWinStation->State != State_Connected )) {
                                memset(pPdParams, 0, sizeof(PDPARAMS));
                                *pReturnLength = WinStationInformationLength;
                                Status = STATUS_SUCCESS;
                            }
                        }
                    } else {
                        memset( (PVOID)pPdParams, 0, sizeof(PDPARAMS) );
                        *pReturnLength = WinStationInformationLength;
                        Status = STATUS_SUCCESS;
                    }
        
                    if (NT_SUCCESS(Status)) {
                        CopyInWireBuf(WinStationInformationClass,
                                      (PVOID)pPdParams,
                                      pWinStationInformation);
                    }
        
                    *pReturnLength = WinStationInformationLength;
        
                    MemFree( pPdParams );

                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }
        break;


        case WinStationClient:
            if (!ValidWireBuffer(WinStationInformationClass,
                                 pWinStationInformation,
                                 WinStationInformationLength)){
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            CopyInWireBuf(WinStationInformationClass,
                          (PVOID)&pWinStation->Client,
                          pWinStationInformation);

            // if caller is not allow to see it, then scrub the password
            if ( !IsCallerAllowedPasswordAccess() ) {
                PWINSTATIONCLIENT pWSClient = (PWINSTATIONCLIENT)pWinStationInformation;
                PBYTE pStart;
                PBYTE pEnd;
                ULONG ulMaxToScrub;

                pEnd = (PBYTE) ( pWinStationInformation ) + WinStationInformationLength;
                if ((ULONG_PTR) pEnd > (ULONG_PTR)pWSClient->Password) {
                    ulMaxToScrub =  (ULONG)((ULONG_PTR) pEnd - (ULONG_PTR)pWSClient->Password);
                    if (ulMaxToScrub > sizeof(pWSClient->Password))
                        ulMaxToScrub = sizeof(pWSClient->Password);
                    memset(pWSClient->Password, 0,ulMaxToScrub);
                }
            }

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationModules:
            //  Check for availability
            if (pWinStation->hStack &&
                    pWinStation->pWsx &&
                    pWinStation->pWsx->pWsxIcaStackIoControl) {
                ULONG b = (ULONG) IsCallerAllowedPasswordAccess();

                Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                        pWinStation->pWsxContext,
                                        pWinStation->hIca,
                                        pWinStation->hStack,
                                        IOCTL_ICA_STACK_QUERY_MODULE_DATA,
                                        (PVOID) &b,
                                        sizeof(b),
                                        pWinStationInformation,
                                        WinStationInformationLength,
                                        pReturnLength );
            } else {
                memset( pWinStationInformation, 0, WinStationInformationLength );
                Status = STATUS_SUCCESS;
            }
            break;


        case WinStationCreateData:
            if ( WinStationInformationLength > sizeof(WINSTATIONCREATE) )
                WinStationInformationLength = sizeof(WINSTATIONCREATE);

            memcpy( pWinStationInformation,
                    &pWinStation->Config.Create,
                    WinStationInformationLength );

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationPrinter:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;


        case WinStationUserToken:
            if ( WinStationInformationLength < sizeof(WINSTATIONUSERTOKEN) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            /*
             * Check it for WINSTATION_ALL_ACCESS. This will generate an
             * access audit if on.
             */
            Status = RpcCheckClientAccess( pWinStation, WINSTATION_ALL_ACCESS, FALSE );
            if ( !NT_SUCCESS( Status ) ) {
                break;
            }

            //
            // Make sure only system mode callers can get this token.
            //
            // A Token is a very dangerous thing to allow someone to
            // get a hold of, since they can create processes that
            // have the tokens subject context.
            //
            Status = RpcCheckSystemClientNoLogonId( pWinStation );
            if (!NT_SUCCESS(Status)) {
                break;
            }

            Status = xxxGetUserToken(
                              pWinStation,
                              (WINSTATIONUSERTOKEN UNALIGNED *)pWinStationInformation,
                              WinStationInformationLength
                              );

            *pReturnLength = sizeof(WINSTATIONUSERTOKEN);
            break;


        case WinStationVideoData:
            if ( !pWinStation->LogonId || !pWinStation->hStack ) {
                Status = STATUS_PROCEDURE_NOT_FOUND;
                break;
            }

            if ( WinStationInformationLength < sizeof(WINSTATIONVIDEODATA) ) {
                 Status = STATUS_BUFFER_TOO_SMALL;
                 break;
            }

            pVideoData = (PWINSTATIONVIDEODATA) pWinStationInformation;

            pVideoData->HResolution = pWinStation->Client.HRes;
            pVideoData->VResolution = pWinStation->Client.VRes;
            pVideoData->fColorDepth = pWinStation->Client.ColorDepth;

            *pReturnLength = sizeof(WINSTATIONVIDEODATA);
            break;


        case WinStationVirtualData:
            if ( !pWinStation->hStack ) {
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            if ( WinStationInformationLength < sizeof(VIRTUALCHANNELNAME) ) {
                 Status = STATUS_BUFFER_TOO_SMALL;
                 break;
            }

            /*
             *  Open virtual channel handle
             */
            Status = IcaChannelOpen( pWinStation->hIca,
                                     Channel_Virtual,
                                     pWinStationInformation,
                                &hVirtual );
            if ( !NT_SUCCESS( Status ) )
                break;

            /*
             *  Query client virtual channel data
             */
            Status = IcaChannelIoControl( hVirtual,
                                          IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA,
                                          NULL,
                                          0,
                                          pWinStationInformation,
                                          WinStationInformationLength,
                                          pReturnLength );

            /*
             *  Close virtual channel
             */
            IcaChannelClose(hVirtual);
            break;


        case WinStationLoadBalanceSessionTarget:
            // This query requests the target session ID for a
            // client redirected from another server in a load balancing
            // cluster. Returns -1 for no redirection. This call is
            // normally made only by WinLogon.
            if (WinStationInformationLength > sizeof(ULONG))
                WinStationInformationLength = sizeof(ULONG);

            if (!pWinStation->bRequestedSessionIDFieldValid)
                *((ULONG *)pWinStationInformation) = (ULONG)-1;
            else
                *((ULONG *)pWinStationInformation) =
                        pWinStation->RequestedSessionID;

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationShadowInfo:
        {
            PWINSTATIONSHADOW pWinstationShadow;
    
            if (WinStationInformationLength >= sizeof(WINSTATIONSHADOW)) {

                pWinstationShadow = (PWINSTATIONSHADOW) pWinStationInformation;

                if ( pWinStation->State == State_Shadow ) {

                    // The current state is Shadow so it's a viewer
                    pWinstationShadow->ShadowState = State_Shadowing;

                } else if ( pWinStation->State == State_Active &&
                            !IsListEmpty(&pWinStation->ShadowHead) ) {

                    // Active and being shadowed
                    pWinstationShadow->ShadowState = State_Shadowed;

                } else {

                    pWinstationShadow->ShadowState = State_NoShadow;
                }

                pWinstationShadow->ShadowClass  = pWinStation->Config.Config.User.Shadow;
                pWinstationShadow->SessionId    = LogonId;
                pWinstationShadow->ProtocolType = pWinStation->Client.ProtocolType;


                *pReturnLength = sizeof(WINSTATIONSHADOW);
            }
            else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        break;

        case WinStationDigProductId:
        {
            PWINSTATIONPRODID pWinStationProdId;
   
            if ( WinStationInformationLength >= sizeof(WINSTATIONPRODID) )
            {
              pWinStationProdId  = (PWINSTATIONPRODID)pWinStationInformation;
              memcpy( pWinStationProdId->DigProductId, g_DigProductId, sizeof( g_DigProductId ));
              memcpy( pWinStationProdId->ClientDigProductId, pWinStation->Client.clientDigProductId, sizeof( pWinStation->Client.clientDigProductId ));
              pWinStationProdId->curentSessionId = pWinStation->LogonId;
              pWinStationProdId->ClientSessionId = pWinStation->Client.ClientSessionId;

              *pReturnLength = WinStationInformationLength;
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }

        case WinStationLockedState:
        {
            BOOL bLockedState;
            if ( pWinStationInformation &&  (WinStationInformationLength >= sizeof(bLockedState)))
            {
                Status = GetLockedState(pWinStation, &bLockedState);
                *(LPBOOL)pWinStationInformation = bLockedState;
                *pReturnLength = sizeof(bLockedState);
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case WinStationRemoteAddress:
        {
            PWINSTATIONREMOTEADDRESS pRemoteAddress = (PWINSTATIONREMOTEADDRESS) pWinStationInformation;

            if( WinStationInformationLength >= sizeof(WINSTATIONREMOTEADDRESS) )
            {
                Status = xxxQueryRemoteAddress( pWinStation, pRemoteAddress );
            }
            else
            {
                *pReturnLength = sizeof(WINSTATIONREMOTEADDRESS);
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        
            break;
        }

        case WinStationLastReconnectType:
        {

            if ( pWinStationInformation &&  (WinStationInformationLength >= sizeof(ULONG)))
            {
                *((ULONG *)pWinStationInformation) = pWinStation->LastReconnectType;
                *pReturnLength = sizeof(ULONG);
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case WinStationMprNotifyInfo:
        {
            pExtendedClientCredentials pMprNotifyInfo;

            // Only System can query this information

            Status = _CheckCallerLocalAndSystem();
            if (Status != STATUS_SUCCESS) {
                break;
            }

            if (WinStationInformationLength >= sizeof(ExtendedClientCredentials)) {

                pMprNotifyInfo = (pExtendedClientCredentials) pWinStationInformation;

                *pMprNotifyInfo = g_MprNotifyInfo;
                *pReturnLength = sizeof(ExtendedClientCredentials);

                // Erase the sensitive information now since its no longer needed in TermSrv
                RtlSecureZeroMemory( g_MprNotifyInfo.Domain, wcslen(g_MprNotifyInfo.Domain) * sizeof(WCHAR) );
                RtlSecureZeroMemory( g_MprNotifyInfo.UserName, wcslen(g_MprNotifyInfo.UserName) * sizeof(WCHAR) );
                RtlSecureZeroMemory( g_MprNotifyInfo.Password, wcslen(g_MprNotifyInfo.Password) * sizeof(WCHAR) );

            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        break;

        default:
            /*
             * Fail the call
             */
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

    ReleaseWinStation(pWinStation);

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationQueryInformation "
            "LogonId=%d, Class=%d, Status=0x%x\n",
            LogonId, (ULONG)WinStationInformationClass, Status));

    return Status;
}


/*****************************************************************************
 *  xxxGetUserToken
 *
 *   Duplicate the users token into the process space of the caller
 *   if they are an admin.
 *
 * ENTRY:
 *   p (input/output)
 *     Argument buffer
 *
 *   Length (input)
 *     Size of argument buffer
 ****************************************************************************/
NTSTATUS xxxGetUserToken(
        PWINSTATION pWinStation,
        WINSTATIONUSERTOKEN UNALIGNED *p,
        ULONG Size)
{
    NTSTATUS Status;
    HANDLE RemoteToken;
    HANDLE RemoteProcess;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjA;

    // Determine if the caller is an admin

    //
    // If the token is not NULL, duplicate it into the callers
    // process space.
    //
    if (pWinStation->UserToken == NULL) {
        return STATUS_NO_TOKEN;
    }

    InitializeObjectAttributes(&ObjA, NULL, 0, NULL, NULL);
    ClientId.UniqueProcess = p->ProcessId;
    ClientId.UniqueThread = p->ThreadId;

    Status = NtOpenProcess(
            &RemoteProcess,
            PROCESS_ALL_ACCESS,
            &ObjA,
            &ClientId);

    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TermSrv GETTOKEN: Error 0x%x "
                "opening remote process %d\n", Status,p->ProcessId));
        return Status;
    }

    Status = NtDuplicateObject(
            NtCurrentProcess(),
            pWinStation->UserToken,
            RemoteProcess,
            &RemoteToken,
            0,
            0,
            DUPLICATE_SAME_ACCESS);

    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TermSrv GETTOKEN: Error 0x%x "
                "duplicating UserToken\n", Status));
        NtClose( RemoteProcess );
        return Status;
    }

    p->UserToken = RemoteToken;
    NtClose(RemoteProcess);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\winsta.c ===
//****************************************************************************/
// winsta.c
//
// TermSrv session and session stack related code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "icaevent.h"
#include "tsappcmp.h" // for TermsrvAppInstallMode
#include <msaudite.h>

#include "sessdir.h"

#include <allproc.h>
#include <userenv.h>

#include <winsock2.h>

#include "conntfy.h"
#include "tsremdsk.h"
#include <ws2tcpip.h>

#include <Accctrl.h>
#include <Aclapi.h>

#include "tssec.h"

//
// Autoreconnect security headers
//
#include <md5.h>
#include <hmac.h>

// performance flags
#include "tsperf.h"

#ifndef MAX_WORD
#define MAX_WORD            0xffff
#endif


//
// SIGN_BYPASS_OPTION #define should be removed before WIN64 SHIPS!!!!!
//
#ifdef _WIN64
#define SIGN_BYPASS_OPTION
#endif

/*
 * Local defines
 */
#define SETUP_REG_PATH L"\\Registry\\Machine\\System\\Setup"

#define REG_WINDOWS_KEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define MAXIMUM_WAIT_WINSTATIONS ((MAXIMUM_WAIT_OBJECTS >> 1) - 1)
#define MAX_STRING_BYTES 512

BOOL gbFirtsConnectionThread = TRUE;
WINSTATIONCONFIG2 gConsoleConfig;
WCHAR g_DigProductId[CLIENT_PRODUCT_ID_LENGTH];

RECONNECT_INFO ConsoleReconnectInfo;


ULONG gLogoffTimeout = 90; /*90 seconds default value for logoff timeout*/

/*
 * Globals to support load balancing.  Since this is queried frequently we can't
 * afford to lock the winstation list and count them up.  Note that they are
 * modified only when we have the WinStationListLock to avoid mutual exclusion
 * issues.
 */
ULONG WinStationTotalCount = 0;
ULONG WinStationDiscCount = 0;
LOAD_BALANCING_METRICS gLB;

/*
 * External procedures defined
 */


VOID     StartAllWinStations(HKEY);
NTSTATUS QueueWinStationCreate( PWINSTATIONNAME );
NTSTATUS WinStationCreateWorker(PWINSTATIONNAME pWinStationName, PULONG pLogonId );
VOID     WinStationTerminate( PWINSTATION );
VOID     WinStationDeleteWorker( PWINSTATION );
NTSTATUS WinStationDoDisconnect( PWINSTATION, PRECONNECT_INFO, BOOLEAN );
NTSTATUS WinStationDoReconnect( PWINSTATION, PRECONNECT_INFO );
BOOL     CopyReconnectInfo(PWINSTATION, PRECONNECT_INFO);
VOID     CleanupReconnect( PRECONNECT_INFO );
NTSTATUS WinStationExceptionFilter( PWSTR, PEXCEPTION_POINTERS );
NTSTATUS IcaWinStationNameFromLogonId( ULONG, PWINSTATIONNAME );
VOID     WriteErrorLogEntry(
            IN  NTSTATUS NtStatusCode,
            IN  PVOID    pRawData,
            IN  ULONG    RawDataLength
            );

NTSTATUS CheckIdleWinstation(VOID);
BOOL IsKernelDebuggerAttached();


/*
 * Internal procedures defined
 */
NTSTATUS WinStationTerminateThread( PVOID );
NTSTATUS WinStationIdleControlThread( PVOID );
NTSTATUS WinStationConnectThread( ULONG );
NTSTATUS WinStationTransferThread( PVOID );
NTSTATUS ConnectSmWinStationApiPort( VOID );
NTSTATUS IcaRegWinStationEnumerate( PULONG, PWINSTATIONNAME, PULONG );
NTSTATUS WinStationStart( PWINSTATION );
BOOL     WinStationTerminateProcesses( PWINSTATION, ULONG *pNumTerminated );
VOID     WinStationDeleteProc( PREFLOCK );
VOID     WinStationZombieProc( PREFLOCK );
NTSTATUS SetRefLockDeleteProc( PREFLOCK, PREFLOCKDELETEPROCEDURE );

VOID     WsxBrokenConnection( PWINSTATION );
NTSTATUS TerminateProcessAndWait( HANDLE, HANDLE, ULONG );
VOID     ResetAutoReconnectInfo( PWINSTATION );
ULONG    WinStationShutdownReset( PVOID );
ULONG WinStationLogoff( PVOID );
NTSTATUS DoForWinStationGroup( PULONG, ULONG, LPTHREAD_START_ROUTINE );
NTSTATUS LogoffWinStation( PWINSTATION, ULONG );
PWINSTATION FindIdleWinStation( VOID );

ULONG CountWinStationType(
    PWINSTATIONNAME pListenName,
    BOOLEAN bActiveOnly,
    BOOLEAN bLockHeld);


NTSTATUS
_CloseEndpoint(
    IN PWINSTATIONCONFIG2 pWinStationConfig,
    IN PVOID pEndpoint,
    IN ULONG EndpointLength,
    IN PWINSTATION pWinStation,
    IN BOOLEAN bNeedStack
    );

NTSTATUS _VerifyStackModules(PWINSTATION);

NTSTATUS _ImpersonateClient(HANDLE, HANDLE *);

WinstationRegUnLoadKey(HKEY hKey, LPWSTR lpSubKey);

ULONG WinstationCountUserSessions(PSID, ULONG);

BOOLEAN WinStationCheckConsoleSession(VOID);

NTSTATUS
WinStationWinerrorToNtStatus(ULONG ulWinError);


VOID
WinStationSetMaxOustandingConnections();

BOOL IsClientOnSameMachine(PWINSTATION pWinStation);

NTSTATUS GetProductIdFromRegistry( WCHAR* DigProductId, DWORD dwSize );


/*
 * External procedures used
 */
NTSTATUS WinStationInitRPC( VOID );
NTSTATUS WinStationInitLPC( VOID );
NTSTATUS WinStationStopAllShadows( PWINSTATION );
VOID NotifySystemEvent( ULONG );
NTSTATUS SendWinStationCommand( PWINSTATION, PWINSTATION_APIMSG, ULONG );
NTSTATUS RpcCheckClientAccess( PWINSTATION, ACCESS_MASK, BOOLEAN );
NTSTATUS WinStationSecurityInit( VOID );
VOID DisconnectTimeout( ULONG LogonId );
PWSEXTENSION FindWinStationExtensionDll( PWSTR, ULONG );

PSECURITY_DESCRIPTOR
WinStationGetSecurityDescriptor(
    PWINSTATION pWinStation
    );

VOID
WinStationFreeSecurityDescriptor(
    PWINSTATION pWinStation
    );

NTSTATUS
WinStationInheritSecurityDescriptor(
    PVOID pSecurityDescriptor,
    PWINSTATION pTargetWinStation
    );

NTSTATUS
ReadWinStationSecurityDescriptor(
    PWINSTATION pWinStation
    );

NTSTATUS
WinStationReadRegistryWorker();

void
PostErrorValueEvent(
    unsigned EventCode, DWORD ErrVal);

BOOL
Filter_AddOutstandingConnection(
        IN HANDLE   pContext,
        IN PVOID    pEndpoint,
        IN ULONG    EndpointLength,
        OUT PBYTE   pin_addr,
        OUT PUINT   puAddrSize,
        OUT BOOLEAN *pbBlocked
    );

BOOL
Filter_RemoveOutstandingConnection(
        IN PBYTE    pin_addr,
        IN UINT     uAddrSize
        );

RTL_GENERIC_COMPARE_RESULTS
NTAPI
Filter_CompareConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
    );

PVOID
Filter_AllocateConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
    );

PVOID
Filter_AllocateConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
    );

VOID
Filter_FreeConnectionEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       Buffer
    );

BOOL
FindFirstListeningWinStationName( 
    PWINSTATIONNAMEW pListenName, 
    PWINSTATIONCONFIG2 pConfig );

typedef struct _TRANSFER_INFO {
    ULONG LogonId;
    PVOID pEndpoint;
    ULONG EndpointLength;
} TRANSFER_INFO, *PTRANSFER_INFO;


VOID     AuditEvent( PWINSTATION pWinstation, ULONG EventId );
VOID AuditShutdownEvent(VOID);


/*
 * Local variables
 */
RTL_CRITICAL_SECTION WinStationListLock;
RTL_CRITICAL_SECTION WinStationListenersLock;
RTL_CRITICAL_SECTION WinStationStartCsrLock;
RTL_CRITICAL_SECTION TimerCritSec;
RTL_CRITICAL_SECTION WinStationZombieLock;
RTL_CRITICAL_SECTION UserProfileLock;
RTL_CRITICAL_SECTION ConsoleLock;
RTL_RESOURCE WinStationSecurityLock;

// This synchronization counter prevents WinStationIdleControlThread from
// Trying to create a console session when  there is not one. There are two 
// Situations where we do no want it to create such session:
// - At initialization time before we create session Zero which is the initial
// console session.
// - During reconnect in the window were we just disconnected the console session
// (so there is no console session) but we know we are we going to reconnect
// an other session to the console.

ULONG gConsoleCreationDisable = 1;


LIST_ENTRY WinStationListHead;    // protected by WinStationListLock
LIST_ENTRY SystemEventHead;       // protected by WinStationListLock
LIST_ENTRY ZombieListHead;
ULONG LogonId;
LARGE_INTEGER TimeoutZero;
HANDLE WinStationEvent = NULL;
HANDLE WinStationIdleControlEvent = NULL;
HANDLE ConsoleLogoffEvent = NULL;
HANDLE g_hMachineGPEvent=NULL;
static HANDLE WinStationApiPort = NULL;
BOOLEAN StopOnDown = FALSE;
HANDLE hTrace = NULL;
//BOOLEAN ShutdownTerminateNoWait = FALSE;
ULONG ShutDownFromSessionID = 0;

ULONG IdleWinStationPoolCount = 2;

ULONG_PTR gMinPerSessionPageCommitMB = 20;
#define REG_MIN_PERSESSION_PAGECOMMIT L"MinPerSessionPageCommit"

PVOID glpAddress;

ULONG_PTR gMinPerSessionPageCommit;

typedef struct _TS_OUTSTANDINGCONNECTION {
    ULONGLONG  blockUntilTime;
    ULONG      NumOutStandingConnect;
    UINT       uAddrSize;
    BYTE       addr[16];
    struct _TS_OUTSTANDINGCONNECTION *pNext;
} TS_OUTSTANDINGCONNECTION, *PTS_OUTSTANDINGCONNECTION;

PTS_OUTSTANDINGCONNECTION   g_pBlockedConnections = NULL;
RTL_GENERIC_TABLE           gOutStandingConnections;

RTL_CRITICAL_SECTION        FilterLock;
ULONG MaxOutStandingConnect;
ULONG NumOutStandingConnect;
ULONG MaxSingleOutStandingConnect;      // maximum number of outstanding connections from a single IP
ULONG DelayConnectionTime = 30*1000;
SYSTEMTIME LastLoggedDelayConnection;
ULONGLONG LastLoggedBlockedConnection = 0;
BOOLEAN gbNeverLoggedDelayConnection = TRUE;

HANDLE hConnectEvent;

BOOLEAN gbWinSockInitialized = FALSE;

/*
 * Global data
 */
extern BOOL g_fAppCompat;
extern BOOL g_SafeBootWithNetwork;

RTL_CRITICAL_SECTION g_AuthzCritSection;


extern HANDLE gReadyEventHandle;


extern BOOLEAN RegDenyTSConnectionsPolicy();
extern DWORD WaitForTSConnectionsPolicyChanges( BOOLEAN bWaitForAccept, HANDLE hEvent );
extern void  InitializeConsoleClientData( PWINSTATIONCLIENTW  pWC );

// defines in REGAPI
extern BOOLEAN    RegGetMachinePolicyEx( 
            BOOLEAN             forcePolicyRead,
            FILETIME            *pTime ,    
            PPOLICY_TS_MACHINE  pPolicy );

// Global TermSrv counter values
DWORD g_TermSrvTotalSessions;
DWORD g_TermSrvDiscSessions;
DWORD g_TermSrvReconSessions;

// Global system SID

PSID gSystemSid = NULL;
PSID gAdminSid = NULL;

BOOLEAN g_fDenyTSConnectionsPolicy = 0;

POLICY_TS_MACHINE   g_MachinePolicy;

/****************************************************************************/
// IsEmbedded
//
// Service-load-time initialization.
/****************************************************************************/
BOOL IsEmbedded()
{
    static int fResult = -1; 
    
    if(fResult == -1)
    {
        OSVERSIONINFOEX ovix;
        BOOL b;
        
        fResult = 0;

        ovix.dwOSVersionInfoSize = sizeof(ovix);
        b = GetVersionEx((LPOSVERSIONINFO) &ovix);
        ASSERT(b);
        if(b && (ovix.wSuiteMask & VER_SUITE_EMBEDDEDNT))
        {
            fResult = 1;
        }
    }
    
    return (fResult == 1);
}

/****************************************************************************/
// InitTermSrv
//
// Service-load-time initialization.
/****************************************************************************/
NTSTATUS InitTermSrv(HKEY hKeyTermSrv)
{
    NTSTATUS Status;
    DWORD dwLen;
    DWORD dwType;
    ULONG  szBuffer[MAX_PATH/sizeof(ULONG)];
    FILETIME    policyTime;
    WSADATA wsaData;

#define MAX_DEFAULT_CONNECTIONS 50
#define MAX_CONNECT_LOW_THRESHOLD 5
#define MAX_SINGLE_CONNECT_THRESHOLD_DIFF 5
#define MAX_DEFAULT_CONNECTIONS_PRO 3
#define MAX_DEFAULT_SINGLE_CONNECTIONS_PRO 2


    ASSERT(hKeyTermSrv != NULL);

    g_TermSrvTotalSessions = 0;
    g_TermSrvDiscSessions = 0;
    g_TermSrvReconSessions = 0;

    // Set default value for maximum simultaneous connection attempts
    WinStationSetMaxOustandingConnections();

    NumOutStandingConnect = 0;
    hConnectEvent = NULL;

    ShutdownInProgress = FALSE;
    //ShutdownTerminateNoWait = FALSE;
    ShutDownFromSessionID = 0;

    // don't bother saving the policy time, the thread that waits for policy update will save it's own copy at the
    // cost of running the 1st time around. Alternatively, I need to use another global var for the policy update value.
    RegGetMachinePolicyEx( TRUE, &policyTime, &g_MachinePolicy );

    Status = RtlInitializeCriticalSection( &FilterLock );
    ASSERT( NT_SUCCESS( Status ));
    if (!NT_SUCCESS(Status)) {
        goto badFilterLock;
    }

    RtlInitializeGenericTable( &gOutStandingConnections,
                               Filter_CompareConnectionEntry,
                               Filter_AllocateConnectionEntry,
                               Filter_FreeConnectionEntry,
                               NULL );


    Status = RtlInitializeCriticalSection( &ConsoleLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
       goto badConsoleLock;
    }

    Status = RtlInitializeCriticalSection( &UserProfileLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badUserProfileLock;
    }

    Status = RtlInitializeCriticalSection( &WinStationListLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badWinstationListLock;
    }

    if (!gbServer) {
        Status = RtlInitializeCriticalSection( &WinStationListenersLock );
        ASSERT( NT_SUCCESS( Status ) );
        if (!NT_SUCCESS(Status)) {
            goto badWinStationListenersLock;
        }
    }

    Status = RtlInitializeCriticalSection( &WinStationZombieLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badWinStationZombieLock;
    }

    Status = RtlInitializeCriticalSection( &TimerCritSec );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badTimerCritsec;
    }

    Status = RtlInitializeCriticalSection( &g_AuthzCritSection );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badAuthzCritSection;
    }

    InitializeListHead( &WinStationListHead );
    InitializeListHead( &SystemEventHead );
    InitializeListHead( &ZombieListHead );

    Status = InitializeConsoleNotification ();
    if (!NT_SUCCESS(Status)) {
        goto badinitStartCsrLock;
    }

    Status = RtlInitializeCriticalSection( &WinStationStartCsrLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badinitStartCsrLock;
    }

    Status = LCInitialize(
        g_bPersonalTS ? LC_INIT_LIMITED : LC_INIT_ALL,
        g_fAppCompat
        );

    if (!NT_SUCCESS(Status)) {
        goto badLcInit;
    }

    //
    // Listener winstations always get LogonId above 65536 and are
    // assigned by Terminal Server. LogonId's for sessions are
    // generated by mm in the range 0-65535
    //
    LogonId = MAX_WORD + 1;

    TimeoutZero = RtlConvertLongToLargeInteger( 0 );
    Status = NtCreateEvent( &WinStationEvent, EVENT_ALL_ACCESS, NULL,
                   NotificationEvent, FALSE );
    Status = NtCreateEvent( &WinStationIdleControlEvent, EVENT_ALL_ACCESS, NULL,
                   SynchronizationEvent, FALSE );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badEvent;
    }

    Status = NtCreateEvent( &ConsoleLogoffEvent, EVENT_ALL_ACCESS, NULL,
                   NotificationEvent, TRUE );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badEvent;
    }

    /*
     * Initialize WinStation security
     */

    RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
    Status = WinStationSecurityInit();
    RtlReleaseResource(&WinStationSecurityLock);
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badInitSecurity;
    }

    Status = WinStationInitLPC();
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badInitLPC;
    }

    //
    // Read the registry to determine if maximum outstanding connections
    // policy is turned on and the value for it
    //

    //
    // Get MaxOutstandingCon string value
    //
    dwLen = sizeof(MaxOutStandingConnect);
    if (RegQueryValueEx(hKeyTermSrv, MAX_OUTSTD_CONNECT, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        if (*(PULONG)szBuffer > 0) {
            MaxOutStandingConnect = *(PULONG)szBuffer;
        }
    }

    dwLen = sizeof(MaxSingleOutStandingConnect);
    if (RegQueryValueEx(hKeyTermSrv, MAX_SINGLE_OUTSTD_CONNECT, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        if (*(PULONG)szBuffer > 0) {
            MaxSingleOutStandingConnect = *(PULONG)szBuffer;
        }
    }

    


    dwLen = sizeof(gLogoffTimeout);
    if (RegQueryValueEx(hKeyTermSrv, LOGOFF_TIMEOUT, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        gLogoffTimeout = *(PULONG)szBuffer;
    }

    //
    // Read the logoff timeout value. This timeout is used by termsrv to force terminate
    // winlogon, if winlogon does not complete logoff after ExitWindows message was sent to him
    //




    //
    //  set max number of outstanding connection from single IP
    //
    if ( MaxOutStandingConnect < MAX_SINGLE_CONNECT_THRESHOLD_DIFF*5)
    {
        MaxSingleOutStandingConnect = MaxOutStandingConnect - 1;
    } else {
        MaxSingleOutStandingConnect = MaxOutStandingConnect - MAX_SINGLE_CONNECT_THRESHOLD_DIFF;
    }

    //
    // Create the connect Event
    //
    if (MaxOutStandingConnect != 0) {
        hConnectEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (hConnectEvent == NULL) {
            MaxOutStandingConnect = 0;
        }
    }

    //
    // Initialize winsock
    //


    // Ask for Winsock version 2.2.
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) == 0) {
        gbWinSockInitialized = TRUE;
    }

    return(Status);

    /*
     * Clean up on failure. Clean up is not implemented for
     * all cases of failure. However most of it will be done implicitly
     * by the exit from termsrv process. Failure at this point means anyway
     * there will be no multi-user feature.
     */

badInitLPC: // Cleanup code not implemented
badInitSecurity:
badEvent:
    if (WinStationEvent != NULL)
        NtClose(WinStationEvent);
    if (WinStationIdleControlEvent != NULL)
        NtClose(WinStationIdleControlEvent);
    if (ConsoleLogoffEvent != NULL)
        NtClose(ConsoleLogoffEvent);
badLcInit:
    RtlDeleteCriticalSection( &WinStationStartCsrLock );
badinitStartCsrLock:
    RtlDeleteCriticalSection( &TimerCritSec );
badTimerCritsec:
badWinStationZombieLock:
    if (!gbServer) {
        RtlDeleteCriticalSection( &WinStationListenersLock );
    }
badWinStationListenersLock:
    RtlDeleteCriticalSection( &WinStationListLock );
badWinstationListLock:
    RtlDeleteCriticalSection( &UserProfileLock );
badUserProfileLock:
    RtlDeleteCriticalSection( &ConsoleLock );
badAuthzCritSection:
    RtlDeleteCriticalSection( &g_AuthzCritSection );
badConsoleLock:
    RtlDeleteCriticalSection( &FilterLock );
badFilterLock:
    return Status;
}


/*******************************************************************************
 *
 * GroupPolicyNotifyThread
 * Entry: 
 *      nothing
 *
 *
*******************************************************************************/
DWORD GroupPolicyNotifyThread(DWORD notUsed )
{
    DWORD       dwError;
    BOOL        rc;
    HANDLE      hEvent;
    BOOLEAN     bWaitForAccept;
    BOOLEAN     bSystemStartup;

    static      FILETIME    timeOfLastPolicyRead = { 0 , 0 } ;

    rc = RegisterGPNotification( g_hMachineGPEvent, TRUE);

    if (rc) {
        hEvent = g_hMachineGPEvent;
    } else {
        // TS can still run with the default set of config data, besides
        // if there were any machine group policy data, TS got them on the
        // last reboot cycle.
        //
        hEvent = NULL;
    }

    //
    // At the beginning the listeners are not started.
    // So wait (or test) for the connections to be accepted.
    //
    bWaitForAccept = TRUE;
    bSystemStartup = TRUE;


    //
    // Query and set the global flag before entering any wait.
    //
    g_fDenyTSConnectionsPolicy = RegDenyTSConnectionsPolicy();


    while (TRUE) {

        dwError = WaitForTSConnectionsPolicyChanges( bWaitForAccept, hEvent );

        //
        // Both GP changes and reg changes can affect this one.
        //
        g_fDenyTSConnectionsPolicy = RegDenyTSConnectionsPolicy();

        if (dwError == WAIT_OBJECT_0) {

            //
            // A change in the TS connections policy has occurred.
            //
            if (bWaitForAccept) {

                // are the connections really accepted?
                if (!(g_fDenyTSConnectionsPolicy &&
                      !(TSIsMachinePolicyAllowHelp() && TSIsMachineInHelpMode()))) {

                    // Start the listeners.
                    if ( bSystemStartup ) {
                        // the first time, start all listeners
                        StartStopListeners(NULL, TRUE);
                    } else {
                        // after the first time, use this function to start
                        // listeners only as needed.
                        WinStationReadRegistryWorker();
                    }

                    // Switch to a wait for denied connections.
                    bWaitForAccept = FALSE;

                    bSystemStartup = FALSE;
                }

            } else {

                // are the connections really denied?
                if (g_fDenyTSConnectionsPolicy &&
                    !(TSIsMachinePolicyAllowHelp() && TSIsMachineInHelpMode())) {
                    // Stop the listeners.
                    StartStopListeners(NULL, FALSE);

                    // Switch to a wait for accepted connections.
                    bWaitForAccept = TRUE;
                }

            }

        } else if (dwError == WAIT_OBJECT_0 + 1) {

            //
            // We got notified that the GP has changed.
            //
            if ( RegGetMachinePolicyEx( FALSE, & timeOfLastPolicyRead,  &g_MachinePolicy ) )
            {
                // there has been a change, go ahead with the actual updates
                WinStationReadRegistryWorker();

                // Also update the session directory settings if on an app 
                // server.
                if (!g_bPersonalTS && g_fAppCompat) {
                    UpdateSessionDirectory();
                }
            }

        } else {

            // should we not do something else?
            Sleep( 5000 );
            continue;
        }

    }

    if (rc) {
        UnregisterGPNotification(g_hMachineGPEvent);
    }

    return 0;
}

/*******************************************************************************
 *
 *  StartAllWinStations
 *
 *   Get list of configured WinStations from the registry,
 *   start the Console, and then start all remaining WinStations.
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

void StartAllWinStations(HKEY hKeyTermSrv)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath;
    HANDLE KeyHandle;
    UNICODE_STRING ValueName;
#define VALUE_BUFFER_SIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256 * sizeof(WCHAR))
    CHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    DWORD ThreadId;
    NTSTATUS Status;
    DWORD ValueType;
    DWORD ValueSize;
#define AUTOSTARTTIME 600000

    ASSERT(hKeyTermSrv != NULL);

    /*
     * Initialize the number of idle winstations and gMinPerSessionPageCommitMB,
     * if this value is in the registry.
     */
    ValueSize = sizeof(IdleWinStationPoolCount);
    Status = RegQueryValueEx(hKeyTermSrv,
                              REG_CITRIX_IDLEWINSTATIONPOOLCOUNT,
                              NULL,
                              &ValueType,
                              (LPBYTE) &ValueBuffer,
                              &ValueSize );
    if ( Status == ERROR_SUCCESS ) {
        IdleWinStationPoolCount = *(PULONG)ValueBuffer;
    }
    
    //get the product id from registry for use in detecting shadow loop
     GetProductIdFromRegistry( g_DigProductId, sizeof( g_DigProductId ) );



    //Terminal Service needs to skip Memory check in Embedded images 
    //when the TS service starts
    //bug #246972
    if(!IsEmbedded()) {
        
        ValueSize = sizeof(gMinPerSessionPageCommitMB);
        Status = RegQueryValueEx(hKeyTermSrv,
                                  REG_MIN_PERSESSION_PAGECOMMIT,
                                  NULL,
                                  &ValueType,
                                  (LPBYTE) &ValueBuffer,
                                  &ValueSize );
        if ( Status == ERROR_SUCCESS ) {
            gMinPerSessionPageCommitMB = *(PULONG)ValueBuffer;
        }

        gMinPerSessionPageCommit = gMinPerSessionPageCommitMB * 1024 * 1024;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &glpAddress,
                                          0,
                                          &gMinPerSessionPageCommit,
                                          MEM_RESERVE,
                                          PAGE_READWRITE
                                        );
        ASSERT( NT_SUCCESS( Status ) );

    }

    /*
     * Open connection to our WinStationApiPort.  This will be used to
     * queue requests to our API thread instead of doing them inline.
     */
    Status = ConnectSmWinStationApiPort();
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Create Console WinStation first
     */
    Status = WinStationCreateWorker( L"Console", NULL );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("INIT: Failed to create Console WinStation, status=0x%08x\n", Status));
    } else {
        /*
         * From now on,WinStationIdleControlThread can create console sessions if needed
         */
        InterlockedDecrement(&gConsoleCreationDisable);

    }


    /*
     * Open the Setup key and look for the valuename "SystemSetupInProgress".
     * If found and it has a value of TRUE (non-zero), then setup is in
     * progress and we skip starting WinStations other than the Console.
     */
    RtlInitUnicodeString( &KeyPath, SETUP_REG_PATH );
    InitializeObjectAttributes( &ObjectAttributes, &KeyPath,
                                OBJ_CASE_INSENSITIVE, NULL, NULL );
    Status = NtOpenKey( &KeyHandle, GENERIC_READ, &ObjectAttributes );
    if ( NT_SUCCESS( Status ) ) {
        RtlInitUnicodeString( &ValueName, L"SystemSetupInProgress" );
        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        Status = NtQueryValueKey( KeyHandle,
                                  &ValueName,
                                  KeyValuePartialInformation,
                                  (PVOID)KeyValueInfo,
                                  VALUE_BUFFER_SIZE,
                                  &ValueLength );
        NtClose( KeyHandle );
        if ( NT_SUCCESS( Status ) ) {
            ASSERT( ValueLength < VALUE_BUFFER_SIZE );
            if ( KeyValueInfo->Type == REG_DWORD &&
                 KeyValueInfo->DataLength == sizeof(ULONG) &&
                 *(PULONG)(KeyValueInfo->Data) != 0 ) {
                return;
            }
        }
    }

    /*
     * Start a policy notfiy thread.
     *
     */
    {
        HANDLE  hGroupPolicyNotifyThread;
        DWORD   dwID;
        
        g_hMachineGPEvent = CreateEvent (NULL, FALSE, FALSE, 
            TEXT("TermSrv:  machine GP event"));

        if (g_hMachineGPEvent) 
        {
            hGroupPolicyNotifyThread = CreateThread (
                NULL, 0, (LPTHREAD_START_ROUTINE) GroupPolicyNotifyThread,
                0, 0, &dwID);
            if ( hGroupPolicyNotifyThread )
            {
                NtClose( hGroupPolicyNotifyThread );
            }
        }
    }
    

    /*
     * If necessary, create the thread in charge of the regulation of the idle sessions
     */
    {
        HANDLE hIdleControlThread = CreateThread( NULL,
                                            0,              // use Default stack size of the svchost process
                    (LPTHREAD_START_ROUTINE)WinStationIdleControlThread,
                                            NULL,
                                            THREAD_SET_INFORMATION,
                                            &ThreadId );
        if (hIdleControlThread)  {
            NtClose(hIdleControlThread);
        }
    }

    /*
     * Finally, create the terminate thread
     */
    {
    HANDLE hTerminateThread = CreateThread( NULL,
                                            0,      // use Default stack size of the svchost process
                    (LPTHREAD_START_ROUTINE)WinStationTerminateThread,
                                            NULL,
                                            THREAD_SET_INFORMATION,
                                            &ThreadId );
    if ( hTerminateThread )
        NtClose( hTerminateThread );
    }
}


/*******************************************************************************
 *
 *  StartStopListeners
 *
 *   Get list of configured WinStations from the registry,
 *   and start the WinStations.
 *
 * ENTRY:
 *    bStart
 *      if TRUE start the listeners.
 *      if FALSE stop the listeners if no connections related to them exist
 *      anymore. However we do this only on PRO and PER as on a server we
 *      don't mind keeping the listeners.
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/
BOOL StartStopListeners(LPWSTR WinStationName, BOOLEAN bStart)
{
    ULONG i;
    ULONG WinStationCount, ByteCount;
    PWINSTATIONNAME pBuffer;
    PWINSTATIONNAME pWinStationName;
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    NTSTATUS Status;
    BOOL     bReturn = FALSE;

    if (bStart) {

        /*
         * Get list of WinStations from registry
         */
        pBuffer = NULL;
        WinStationCount = 0;
        Status = IcaRegWinStationEnumerate( &WinStationCount, NULL, &ByteCount );
        if ( NT_SUCCESS(Status) ) {
            pBuffer = pWinStationName = MemAlloc( ByteCount );
            WinStationCount = (ULONG) -1;
            if (pBuffer) {
                IcaRegWinStationEnumerate( &WinStationCount,
                                           pWinStationName,
                                           &ByteCount );
            }
        }

        /*
         * Now create all remaining WinStations defined in registry
         * Note that every 4th WinStation we do the WinStationCreate inline
         * instead of queueing it.  This is so we don't create an excess
         * number of API threads right off the bat.
         */
        if ( pBuffer ) {
            for ( i = 0; i < WinStationCount; i++ ) {

                if ( _wcsicmp( pWinStationName, L"Console" ) ) {

                    if ( i % 4 )
                        QueueWinStationCreate( pWinStationName );
                    else // Don't queue more than 4 at a time
                        (void) WinStationCreateWorker( pWinStationName, NULL );
                }
                (char *)pWinStationName += sizeof(WINSTATIONNAME);
            }

            MemFree( pBuffer );
        }

        bReturn = TRUE;

    } else {

        //
        // Do this only on PRO and PER (i.e. WORKSTATION)
        //
        
        if ( gbServer ) {
            return FALSE;
        }

        ENTERCRIT( &WinStationListenersLock );

        // Test if TS connections are denied or not in case we are called from a
        // terminate or a disconnect.

        if ( g_fDenyTSConnectionsPolicy  &&
             // Performance, we only want to check if policy enable help when connection is denied
             (!TSIsMachineInHelpMode() || !TSIsMachinePolicyAllowHelp()) ) {

            ULONG ulLogonId;

            if( WinStationName ) {

                // note that this function doesn't handle renamed listeners
                WinStationCount = CountWinStationType( WinStationName, TRUE, FALSE );

                if ( WinStationCount == 0 ) {

                    pWinStation = FindWinStationByName( WinStationName, FALSE );

                    if ( pWinStation ) {

                        ulLogonId = pWinStation->LogonId;

                        ReleaseWinStation( pWinStation );

                         // reset it and don't recreate it
                        WinStationResetWorker( ulLogonId, TRUE, FALSE, FALSE );
                    }
                }

            } else {

                // terminate all listeners

searchagain:
                Head = &WinStationListHead;
                ENTERCRIT( &WinStationListLock );

                for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

                    pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

                    //
                    // Only check listening winstations
                    //
                    if ( (pWinStation->Flags & WSF_LISTEN) &&
                         !(pWinStation->Flags & (WSF_RESET | WSF_DELETE)) ) {

                        ulLogonId = pWinStation->LogonId;

                        // note that this function doesn't handle renamed listeners
                        WinStationCount = CountWinStationType( pWinStation->WinStationName, TRUE, TRUE );

                        if ( WinStationCount == 0 ) {

                            LEAVECRIT( &WinStationListLock );

                            // reset it and don't recreate it
                            WinStationResetWorker( ulLogonId, TRUE, FALSE, FALSE );
                            goto searchagain;
                        }

                    }
                }
                LEAVECRIT( &WinStationListLock );
            }

            bReturn = TRUE;

        }
        LEAVECRIT( &WinStationListenersLock );

    }

    return bReturn;
}


/*******************************************************************************
 *  WinStationIdleControlThread
 *
 *   This routine will control the number of idle sessions.
 ******************************************************************************/
NTSTATUS WinStationIdleControlThread(PVOID Parameter)
{
    ULONG i;
    NTSTATUS    Status = STATUS_SUCCESS;
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    ULONG       IdleCount = 0;
    ULONG       j;
    LARGE_INTEGER Timeout;
    PLARGE_INTEGER pTimeout;
    ULONG ulSleepDuration;
    ULONG ulRetries = 0;

    ulSleepDuration = 60*1000; // 1 minute
    pTimeout = NULL;


    /*
     * Now create the pool of idle WinStations waiting for a connection.
     * we need to wait for termsrv to be fully up, otherwise Winlogon will
     * fail its RPC call to termsrv (WaitForConnectWorker).
     */

    if (gReadyEventHandle != NULL) {
        WaitForSingleObject(gReadyEventHandle, (DWORD)-1);
    }
    for ( i = 0; i < IdleWinStationPoolCount; i++ ) {
        (void) WinStationCreateWorker( NULL, NULL );
    }

    Timeout = RtlEnlargedIntegerMultiply( ulSleepDuration, -10000);

    if (WinStationIdleControlEvent != NULL)
    {
        while (TRUE)
        {

            Status = NtWaitForSingleObject(WinStationIdleControlEvent,FALSE, pTimeout);

            if ( !NT_SUCCESS(Status) && (Status != STATUS_TIMEOUT)) {
                Sleep(1000);     // don't eat too much CPU
                continue;
            }
            pTimeout = &Timeout;
            /*
             * See if we need to create a console session
             * If if we fail creating a console session, we'll set a timeout so that we will
             * retry .
             */
            ENTERCRIT( &ConsoleLock );

            if (gConsoleCreationDisable == 0) {
                if (WinStationCheckConsoleSession()) {
                    pTimeout = NULL;
                }
            } 

            LEAVECRIT( &ConsoleLock );

            /*
             * Now count the number of IDLE WinStations and ensure there
             * are enough available.
             */
            if (IdleWinStationPoolCount != 0) {
                ENTERCRIT( &WinStationListLock );
                IdleCount = 0;
                Head = &WinStationListHead;
                for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
                    pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
                    if ( pWinStation->Flags & WSF_IDLE )
                        IdleCount++;
                }
                LEAVECRIT( &WinStationListLock );

                for ( j = IdleCount; j < IdleWinStationPoolCount; j++ ) {
                    WinStationCreateWorker( NULL, NULL );
                }
            }
        }
    }
    return STATUS_SUCCESS;
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715) // Not all control paths return (due to infinite loop)
#endif
/*******************************************************************************
 *  WinStationTerminateThread
 *
 *   This routine will wait for WinStation processes to terminate,
 *   and will then reset the corresponding WinStation.
 ******************************************************************************/
NTSTATUS WinStationTerminateThread(PVOID Parameter)
{
    LONG ThreadIndex = (LONG)(INT_PTR)Parameter;
    LONG WinStationIndex;
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    LONG EventCount;
    LONG EventIndex;
    int WaitCount;
    int HandleCount;
    int HandleArraySize = 0;
    PHANDLE pHandleArray = NULL;
    PULONG pIdArray = NULL;
    ULONG ThreadsNeeded;
    ULONG ThreadsRunning = 1;
    ULONG j;
    NTSTATUS Status;
    LARGE_INTEGER Timeout;
    PLARGE_INTEGER pTimeout;
    ULONG ulSleepDuration;

    /*
     * We need some timer values for the diferent cases of failure in
     * the thread's loop:
     * - If we fail creating a new WinstationterminateThread,
     * then we will do a WaitFormulpipleObjects with a timer instead of a wait without
     * time out. This will give a new chance to create the thread when timout is over.
     * if we fail allocating a new buffer to extend handle array, we will wait a timeout
     * duration before we retry.
     */

    ulSleepDuration = 3*60*1000;
    Timeout = RtlEnlargedIntegerMultiply( ulSleepDuration, -10000);

    /*
     * Loop forever waiting for WinStation processes to terminate
     */
    for ( ; ; ) {

        /*
         * Determine number of WinStations
         */
        pTimeout = NULL;
        WaitCount = 0;
        Head = &WinStationListHead;
        ENTERCRIT( &WinStationListLock );
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
            WaitCount++;

        /*
         * If there are more than the maximum number of objects that
         * can be specified to NtWaitForMultipleObjects, then determine
         * if we must start up additional thread(s).
         */
        if ( WaitCount > MAXIMUM_WAIT_WINSTATIONS ) {
            ThreadsNeeded = (WaitCount + MAXIMUM_WAIT_WINSTATIONS - 1) /
                                MAXIMUM_WAIT_WINSTATIONS;
            WaitCount = MAXIMUM_WAIT_WINSTATIONS;
            if ( ThreadIndex == 0 && ThreadsNeeded > ThreadsRunning ) {
                LEAVECRIT( &WinStationListLock );
                for ( j = ThreadsRunning; j < ThreadsNeeded; j++ ) {
                    DWORD ThreadId;
                    HANDLE Handle;

                    Handle = CreateThread( NULL,
                                           0,       // use Default stack size of the svchost process
                                           (LPTHREAD_START_ROUTINE)
                                               WinStationTerminateThread,
                                           ULongToPtr( j * MAXIMUM_WAIT_WINSTATIONS ),
                                           THREAD_SET_INFORMATION,
                                           &ThreadId );
                    if ( !Handle ) {
                       pTimeout = &Timeout;
                       break;
                    }

                    // makarp: 182597 - close handle to the thread.
                    CloseHandle(Handle);

                    ThreadsRunning++;
                }
                ENTERCRIT( &WinStationListLock );
            }
        }

        /*
         * If we need a larger handle array, then release the
         * WinStationList lock, allocate the new handle array,
         * and go start the loop again.
         */
        HandleCount = (WaitCount << 1) + 1;
        ASSERT( HandleCount < MAXIMUM_WAIT_OBJECTS );
        if ( HandleCount > HandleArraySize ||
             HandleCount < HandleArraySize - 10 ) {
            LEAVECRIT( &WinStationListLock );
            if ( pHandleArray ){
               MemFree( pHandleArray );
            }

            pHandleArray = MemAlloc( HandleCount * sizeof(HANDLE) );
            if ( pIdArray ) {
               MemFree( pIdArray );
            }

            pIdArray = MemAlloc( HandleCount * sizeof(ULONG) );


            /* makarp: check for allocation failures #182597 */
            if (!pIdArray || !pHandleArray) {

                if (pIdArray) {
                   MemFree(pIdArray);
                   pIdArray = NULL;
                }
                if (pHandleArray){
                   MemFree(pHandleArray);
                   pHandleArray = NULL;
                }

                HandleArraySize = 0;

                Sleep(ulSleepDuration);
                continue;
            }

            HandleArraySize = HandleCount;
            continue;
        }

        /*
         * Build list of handles to wait on
         */
        EventCount = 0;
        pIdArray[EventCount] = 0;
        pHandleArray[EventCount++] = WinStationEvent;
        WinStationIndex = 0;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            if ( WinStationIndex++ < ThreadIndex )
                continue;
            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
            if ( !pWinStation->LogonId ) // no waiting on console
                continue;
            if ( pWinStation->Starting )
                continue;
            if  (pWinStation->Terminating) {
                continue;
            }
            if ( pWinStation->WindowsSubSysProcess ) {
                pIdArray[EventCount] = pWinStation->LogonId;
                pHandleArray[EventCount++] = pWinStation->WindowsSubSysProcess;
            }
            if ( pWinStation->InitialCommandProcess ) {
                pIdArray[EventCount] = pWinStation->LogonId;
                pHandleArray[EventCount++] = pWinStation->InitialCommandProcess;
            }
            if ( WinStationIndex - ThreadIndex >= WaitCount )
                break;
        }

        /*
         * Reset WinStationEvent and release the WinStationList lock
         */
        NtResetEvent( WinStationEvent, NULL );
        LEAVECRIT( &WinStationListLock );

        /*
         * Wait for WinStationEvent to trigger (meaning that the
         * WinStationList has changed), or for one of the existing
         * Win32 subsystems or initial commands to terminate.
         */
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: TerminateThread, Waiting for initial command exit (ArraySize=%d)\n", EventCount ));

        Status = NtWaitForMultipleObjects( EventCount, pHandleArray, WaitAny,
                                           FALSE, pTimeout );

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: TerminateThread, WaitForMultipleObjects, rc=%x\n", Status ));

        if ( !NT_SUCCESS(Status) || Status >= EventCount ) { //WinStationVerifyHandles();
            continue;
        }

        /*
         * If WinStationEvent triggered, then just go recompute handle list
         */
        if ( (EventIndex = Status) == STATUS_WAIT_0 )
            continue;

        /*
         * Find the WinStation for the process that terminated and
         * mark it as terminating.  This prevents us from waiting
         * on that WinStation's processes next time through the loop.
         * (NOTE: The 'Terminating' field is protected by the global
         * WinStationListLock instead of the WinStation mutex.)
         */
        Head = &WinStationListHead;
        ENTERCRIT( &WinStationListLock );
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
            if ( pWinStation->LogonId == pIdArray[EventIndex] ) {
                pWinStation->Terminating = TRUE;
                break;
            }
        }

        LEAVECRIT( &WinStationListLock );

        /*
         * Wake up the WinStationIdleControlThread
         */
        NtSetEvent(WinStationIdleControlEvent, NULL);

        /*
         * If there are multiple terminate threads, cause the other
         * threads to wakeup in order to recompute their wait lists.
         */
        NtSetEvent( WinStationEvent, NULL );

        /*
         * One of the initial command processes has terminated,
         * queue a request to reset the WinStation.
         */
        QueueWinStationReset( pIdArray[EventIndex]);
    }

    // make the compiler happy
    return STATUS_SUCCESS;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


/*******************************************************************************
 *  InvalidateTerminateWaitList
 *
 *   Wakes up WinStationTerminateThread to force it to reinitialize its
 *   wait list. Used when we detect that the initial process was ntsd,
 *   and we change the initial process to WinLogon.
 *
 * ENTRY:
 *    The WinStationListLock must not be held.
 ******************************************************************************/
VOID InvalidateTerminateWaitList(void)
{
    ENTERCRIT( &WinStationListLock );
    NtSetEvent( WinStationEvent, NULL );
    LEAVECRIT( &WinStationListLock );
}


/*******************************************************************************
 *  WinStationConnectThread
 *
 *   This routine will wait for and process incoming connections
 *   for a specified WinStation.
 ******************************************************************************/
NTSTATUS WinStationConnectThread(ULONG Parameter)
{
    typedef struct _TRANSFERTHREAD {
        LIST_ENTRY Entry;
        HANDLE hThread;
    } TRANSFERTHREAD, *PTRANSFERTHREAD;

    LIST_ENTRY TransferThreadList;
    PTRANSFERTHREAD pTransferThread;
    PLIST_ENTRY Next;

    PWINSTATION pListenWinStation;
    PVOID pEndpoint = NULL;
    ULONG EndpointLength;
    ULONG WinStationCount;
    ULONG TransferThreadCount;
    BOOLEAN rc;
    BOOLEAN bConnectSuccess = FALSE;
    BOOLEAN bTerminate = FALSE;
    NTSTATUS Status;
    SYSTEMTIME currentSystemTime;

#define MODULE_SIZE 1024
#define _WAIT_ERROR_LIMIT 10
    ULONG WaitErrorLimit = _WAIT_ERROR_LIMIT; // # of consecutive errors allowed

    /*
     * Initialize list of transfer threads
     */
    InitializeListHead( &TransferThreadList );

    /*
     * Find and lock the WinStation
     */
    pListenWinStation = FindWinStationById( Parameter, FALSE );
    if ( pListenWinStation == NULL ) {
        return( STATUS_ACCESS_DENIED );
    }

    /*
     * Ensure only authorized Session Driver and Video Driver stack
     * modules will be loaded as a result of this connection thread.
     *
     * If any module fails verification, mark the WinStation in the
     * DOWN state and exit WITHOUT error.
     *
     * NOTE:
     * The silent exit is very much intentional so as not to aid in
     * a third party's attempt to circumvent this security measure.
     */

    Status = _VerifyStackModules( pListenWinStation );
    if ( Status != STATUS_SUCCESS ) {
        pListenWinStation->State = State_Down;
        ReleaseWinStation( pListenWinStation );
        return( STATUS_SUCCESS );
    }


    /*
     * Indicate we got this far successfully.
     */
    pListenWinStation->CreateStatus = STATUS_SUCCESS;

    /*
     * Load the WinStation extension dll for this WinStation.
     * Note that we don't save the result in pListenWinStation->pWsx
     * since we don't want to make callouts to it for the
     * listen WinStation.
     */
    (VOID) FindWinStationExtensionDll( pListenWinStation->Config.Wd.WsxDLL,
                                       pListenWinStation->Config.Wd.WdFlag );


    /*
     * Do not start accepting client connections before termsrv is totaly UP
     */
    if (gReadyEventHandle != NULL) {
        WaitForSingleObject(gReadyEventHandle, (DWORD)-1);
    }

    /*
     * for perf reason termsrv startup is delayed. We the need to also delay
     * accepting connections so that if a console logon hapened before termsrv
     * was up, we get the delayed logon notification before we accept a 
     * client connection.
     */

    if (gbFirtsConnectionThread) {
        Sleep(5*1000);
        gbFirtsConnectionThread = FALSE;
    }

    
    /*
     * Loop waiting for connection requests and passing them off
     * to an idle WinStation.
     */
    for ( ; ; ) {

        /*
         *  Abort retries if this listener has been terminated
         */
        if ( pListenWinStation->Terminating ) {
            break;
        }

        /*
         * Allocate an endpoint buffer
         */
        pEndpoint = MemAlloc( MODULE_SIZE );
        if ( !pEndpoint ) {
            Status = STATUS_NO_MEMORY;

            // Sleep for 30 seconds and try again.  Listener thread should not exit
            // simply just in low memory condition
            UnlockWinStation(pListenWinStation);

            Sleep(30000);

            if (!RelockWinStation(pListenWinStation))
                break;

            continue;
        }

        /*
         * Unlock listen WinStation while we wait for a connection
         */
        UnlockWinStation( pListenWinStation );

        /*
         * Check if # outstanding connections reaches max value
         * If so, wait for the event when the connection # drops
         * below the max.  There is a timeout value of 30 seconds
         * for the wait
         */
        if (hConnectEvent != NULL) {
            if (NumOutStandingConnect > MaxOutStandingConnect) {
                DWORD rc;

                // Event log we have exceeded max outstanding connections. but not more than
                // once in a day.

                GetSystemTime(&currentSystemTime);
                if ( currentSystemTime.wYear != LastLoggedDelayConnection.wYear  ||
                     currentSystemTime.wMonth != LastLoggedDelayConnection.wMonth  ||
                     currentSystemTime.wDay != LastLoggedDelayConnection.wDay    ||
                     gbNeverLoggedDelayConnection
                    ) {
                    gbNeverLoggedDelayConnection = FALSE;
                    LastLoggedDelayConnection = currentSystemTime;
                    WriteErrorLogEntry(EVENT_TOO_MANY_CONNECTIONS,
                            pListenWinStation->WinStationName,
                            sizeof(pListenWinStation->WinStationName));
                }


                // manual reset the ConnectEvent before wait
                ResetEvent(hConnectEvent);
                rc = WAIT_TIMEOUT;

                // wait for Connect Event for 30 secs
                while (rc == WAIT_TIMEOUT) {
                    rc = WaitForSingleObject(hConnectEvent, DelayConnectionTime);
                    if (NumOutStandingConnect <= MaxOutStandingConnect) {
                        break;
                    }
                    if (rc == WAIT_TIMEOUT) {
                        KdPrint(("TermSrv: Reached 30 secs timeout\n"));
                    }
                    else {
                        KdPrint(("TermSrv: WaitForSingleObject return status=%x\n", rc));
                    }
                }

            }
        }

        /*
         *  Wait for connection
         */
        Status = IcaStackConnectionWait( pListenWinStation->hStack,
                                         pListenWinStation->WinStationName,
                                         &pListenWinStation->Config,
                                         NULL,
                                         pEndpoint,
                                         MODULE_SIZE,
                                         &EndpointLength );

        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            MemFree( pEndpoint );
            pEndpoint = MemAlloc( EndpointLength );
            if ( !pEndpoint ) {
                Status = STATUS_NO_MEMORY;

                // Sleep for 30 seconds and try again.  Listener thread should not exit
                // simply just in low memory condition
                Sleep(30000);

                if (!RelockWinStation( pListenWinStation ))
                    break;

                continue;


            }

            Status = IcaStackConnectionWait( pListenWinStation->hStack,
                                             pListenWinStation->WinStationName,
                                             &pListenWinStation->Config,
                                             NULL,
                                             pEndpoint,
                                             EndpointLength,
                                             &EndpointLength );
        }

        /*
         * If ConnectionWait was not successful,
         * check to see if the consecutive error limit has been reached.
         */
        if ( !NT_SUCCESS( Status ) ) {
            MemFree( pEndpoint );
            pEndpoint = NULL;
            /*
             * If status is DEVICE_DOES_NOT_EXIST, then we want to wait before retrying
             * otherwise, this prioritary thread will take all the CPU trying 10 times
             * lo load the listener stack. Such an error takes time to be fixed (either
             * changing the NIC or going into tscc to have the NIC GUID table updated.
             */
            if ((Status == STATUS_DEVICE_DOES_NOT_EXIST) || (!bConnectSuccess) || (Status == STATUS_INVALID_ADDRESS_COMPONENT) ) {
                Sleep(30000);
            }

            if ( WaitErrorLimit--) {
                if (!RelockWinStation( pListenWinStation ))
                    break;

                /*
                 * If we have had a successful connection,
                 * then skip the stack close/reopen since this would
                 * terminate any existing connections.
                 */
                if ( !bConnectSuccess ) {
                    /*
                     * What we really need is a function to unload the
                     * stack drivers but leave the stack handle open.
                     */
                    Status = IcaStackClose( pListenWinStation->hStack );
                    ASSERT( NT_SUCCESS( Status ) );
                    Status = IcaStackOpen( pListenWinStation->hIca,
                                           Stack_Primary,
                                           (PROC)WsxStackIoControl,
                                           pListenWinStation,
                                           &pListenWinStation->hStack );
                    if ( !NT_SUCCESS( Status ) ) {
                        pListenWinStation->State = State_Down;
                        break;
                    }
                }

                continue;
            }
            else {

                // Sleep for 30 seconds and try again.  Listener thread should not exit
                Sleep(30000);

                if (!RelockWinStation( pListenWinStation ))
                    break;

                // Reset the error count
                WaitErrorLimit = _WAIT_ERROR_LIMIT;

                continue;
            }

        } else {
            bConnectSuccess = TRUE;
            WaitErrorLimit = _WAIT_ERROR_LIMIT;
        }

        /*
         * Check for Shutdown and MaxInstance
         */
        rc = RelockWinStation( pListenWinStation );
        if ( !rc )
            break;

        /*
         * Reject all connections if a shutdown is in progress
         */
        if ( ShutdownInProgress ) {
            Status = _CloseEndpoint( &pListenWinStation->Config,
                                     pEndpoint,
                                     EndpointLength,
                                     pListenWinStation,
                                     TRUE ); // Use a temporary stack
            MemFree( pEndpoint );
            pEndpoint = NULL;

            continue;
        }

         /*
          * Reject all connections if user or the Group-Policy has disabled accepting connections
          */
         if ( g_fDenyTSConnectionsPolicy ) 
         {

            //
            // Performance, we only want to check if policy enable help when connection is denied
            //
            if( !TSIsMachineInHelpMode() || !TSIsMachinePolicyAllowHelp() )
            {
                 Status = _CloseEndpoint( &pListenWinStation->Config,
                                          pEndpoint,
                                          EndpointLength,
                                          pListenWinStation,
                                          TRUE ); // Use a temporary stack
                 MemFree( pEndpoint );
                 pEndpoint = NULL;

                 if ( !gbServer ) {
                     //
                     // On Personal and Pro if there are no more connections associated
                     // to this listener, then terminate it.
                     //
                     // note that this function doesn't handle renamed listeners
                     WinStationCount = CountWinStationType( pListenWinStation->WinStationName, TRUE, FALSE );

                     if ( WinStationCount == 0 ) {
                         bTerminate = TRUE;
                         break;
                     }
                 }

                 Sleep( 5000 ); // sleep for 5 seconds, defense against
                                // denial of service attacks.
                 continue;
            }
         }


        /*
         * Check to see how many transfer threads we have active.
         * If more than the MaxInstance count, we won't start any more.
         */
        TransferThreadCount = 0;
        Next = TransferThreadList.Flink;
        while ( Next != &TransferThreadList ) {
            pTransferThread = CONTAINING_RECORD( Next, TRANSFERTHREAD, Entry );
            Next = Next->Flink;

            /*
             * If thread is still active, bump the thread count
             */
            if ( WaitForSingleObject( pTransferThread->hThread, 0 ) != 0 ) {
                TransferThreadCount++;

            /*
             * Thread has exited, so close the thread handle and free memory
             */
            } else {
                RemoveEntryList( &pTransferThread->Entry );
                CloseHandle( pTransferThread->hThread );
                MemFree( pTransferThread );
            }
        }

        /*
         * If this is not a single-instance connection
         * and there is a MaxInstance count specified,
         * then check whether the MaxInstance limit will be exceeded.
         */
        if ( !(pListenWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) &&
             pListenWinStation->Config.Create.MaxInstanceCount != (ULONG)-1 ) {
            ULONG Count;

            /*
             * Count number of currently active WinStations
             */
            WinStationCount = CountWinStationType( pListenWinStation->WinStationName, FALSE, FALSE );

            /*
             * Get larger of WinStation and TransferThread count
             */
            Count = max( WinStationCount, TransferThreadCount );

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Count %d\n", Count ));
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: MaxInstanceCount %d\n", pListenWinStation->Config.Create.MaxInstanceCount ));

            if ( pListenWinStation->Config.Create.MaxInstanceCount <= Count ) {
                Status = _CloseEndpoint( &pListenWinStation->Config,
                                         pEndpoint,
                                         EndpointLength,
                                         pListenWinStation,
                                         TRUE ); // Use a temporary stack
                MemFree( pEndpoint );
                pEndpoint = NULL;

                continue;
            }
        }
        UnlockWinStation( pListenWinStation );

        /*
         * Increment the counter of pending connections.
         */

        InterlockedIncrement( &NumOutStandingConnect );

        /*
         * If this is a single instance connection,
         * then handle the transfer of the connection endpoint to
         * an idle WinStation directly.
         */
        if ( pListenWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
            Status = TransferConnectionToIdleWinStation( pListenWinStation,
                                                          pEndpoint,
                                                          EndpointLength,
                                                          NULL );
            pEndpoint = NULL;

            /*
             * If the transfer was successful, then for a single instance
             * connection, we must now exit the wait for connect loop.
             */
            if ( NT_SUCCESS( Status ) ) {
                RelockWinStation( pListenWinStation );
                break;
            }

        /*
         * For non-single instance WinStations, let the worker thread
         * handle the connection handoff so this thread can go back
         * and listen for another connection immediately.
         */
        } else {
            PTRANSFER_INFO pInfo;
            DWORD ThreadId;
            HANDLE hTransferThread;
            BOOLEAN bTransferThreadCreated = FALSE;

            pInfo = MemAlloc( sizeof(*pInfo) );
            pTransferThread = MemAlloc( sizeof(*pTransferThread) );

            if (pInfo && pTransferThread) {

                pInfo->LogonId = pListenWinStation->LogonId;
                pInfo->pEndpoint = pEndpoint;
                pInfo->EndpointLength = EndpointLength;

                pTransferThread->hThread = CreateThread(
                              NULL,
                              0,        // use Default stack size of the svchost process
                              (LPTHREAD_START_ROUTINE)WinStationTransferThread,
                              (PVOID)pInfo,
                              0,
                              &ThreadId
                              );

                if ( pTransferThread->hThread ) {
                    bTransferThreadCreated = TRUE;
                    InsertTailList( &TransferThreadList, &pTransferThread->Entry );
                }

            }

            if (!bTransferThreadCreated) {
                if (pInfo) {
                    MemFree( pInfo );
                }

                if (pTransferThread) {
                    MemFree( pTransferThread );
                }

                TransferConnectionToIdleWinStation( pListenWinStation,
                                                     pEndpoint,
                                                     EndpointLength,
                                                     NULL );
            }

            pEndpoint = NULL;
        }

        /*
         * Relock the listen WinStation
         */
        if (!RelockWinStation( pListenWinStation ) )
            break;

    } // for - wait for connection

    /*
     * Clean up the transfer thread list.
     * (There's no need to wait for them to exit.)
     */
    Next = TransferThreadList.Flink;
    while ( Next != &TransferThreadList ) {
        pTransferThread = CONTAINING_RECORD( Next, TRANSFERTHREAD, Entry );
        Next = Next->Flink;
        RemoveEntryList( &pTransferThread->Entry );
        CloseHandle( pTransferThread->hThread );
        MemFree( pTransferThread );
    }

    /*
     * If after exiting the connect loop above, the WinStation is marked down,
     * then write the error status to the event log.
     */
    if ( pListenWinStation->State == State_Down ) {
        ReleaseWinStation( pListenWinStation );

        if ( Status != STATUS_CTX_CLOSE_PENDING ) {
            PostErrorValueEvent(EVENT_TS_LISTNER_WINSTATION_ISDOWN, Status);
        }
    } else {
        /*
         * If not a single-instance transport release the WinStation;
         * otherwise, delete the listener WinStation.
         */
        if (!(pListenWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) &&
            !bTerminate) {
            ReleaseWinStation( pListenWinStation );

        } else {
            /*
             * Mark the listen winstation as being deleted.
             * If a reset/delete operation is already in progress
             * on this winstation, then don't proceed with the delete.
             */
            if ( pListenWinStation->Flags & (WSF_RESET | WSF_DELETE) ) {
                ReleaseWinStation( pListenWinStation );
                Status = STATUS_CTX_WINSTATION_BUSY;
                goto done;
            }
            pListenWinStation->Flags |= WSF_DELETE;

            /*
             * Make sure this WinStation is ready to delete
             */
            WinStationTerminate( pListenWinStation );

            /*
             * Call the WinStationDelete worker
             */
            WinStationDeleteWorker( pListenWinStation );
        }
    }

done:

    if ( pEndpoint ){
        Status = _CloseEndpoint( &pListenWinStation->Config,
                                 pEndpoint,
                                 EndpointLength,
                                 pListenWinStation,
                                 TRUE ); // Use a temporary stack
        MemFree( pEndpoint );
    }

    return Status;
}


/*******************************************************************************
 *  WinStationTransferThread
 ******************************************************************************/
NTSTATUS WinStationTransferThread(PVOID Parameter)
{
    PTRANSFER_INFO pInfo;
    PWINSTATION pListenWinStation;
    NTSTATUS Status;

    /*
     * Find and lock the listen WinStation
     * (We MUST do this so that it doesn't get deleted while
     *  we are attempting to transfer the new connection.)
     */
    pInfo = (PTRANSFER_INFO)Parameter;
    pListenWinStation = FindWinStationById( pInfo->LogonId, FALSE );
    if ( pListenWinStation == NULL ) {
        MemFree( pInfo );

        if( InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
            if (hConnectEvent != NULL)
            {
                SetEvent(hConnectEvent);
            }
        }

        return( STATUS_ACCESS_DENIED );

    }

    /*
     * Unlock the listen WinStation but hold a reference to it.
     */
    UnlockWinStation( pListenWinStation );

    /*
     * Transfer the connection to an idle WinStation
     */
    Status = TransferConnectionToIdleWinStation( pListenWinStation,
                                                  pInfo->pEndpoint,
                                                  pInfo->EndpointLength,
                                                  NULL );

    /*
     * Relock and release the listen WinStation
     */
    RelockWinStation( pListenWinStation );
    ReleaseWinStation( pListenWinStation );

    MemFree(pInfo);

    return Status;
}


NTSTATUS TransferConnectionToIdleWinStation(
        PWINSTATION pListenWinStation,
        PVOID pEndpoint,
        ULONG EndpointLength,
        PICA_STACK_ADDRESS pStackAddress)
{
    PWINSTATION pTargetWinStation = NULL;
    ULONG ReturnLength;
    BOOLEAN rc;
    BOOLEAN CreatedIdle = FALSE;
    BOOLEAN ConnectionAccepted = FALSE;
    NTSTATUS Status;
    ICA_TRACE Trace;
    LS_STATUS_CODE LlsStatus;
    NT_LS_DATA LsData;

    BOOLEAN bBlockThis;

    PWCHAR pListenName;
    PWINSTATIONCONFIG2 pConfig;
    BOOL bPolicyAllowHelp;

    BYTE in_addr[16];
    UINT uAddrSize;
    BOOL bSuccessAdded = FALSE;
    WINSTATIONNAME szDefaultConfigWinstationName;
    BOOL bCanCallout;

    // error code we need to pass back to client
    NTSTATUS StatusCallback = STATUS_SUCCESS;   


    // Flag to detemine if session is a RA login
    BOOL bSessionIsHelpSession;
    BOOL bValidRAConnect;

    //
    // Check AllowGetHelp policy is enabled and salem has pending help session
    //
    bPolicyAllowHelp = TSIsMachinePolicyAllowHelp() & TSIsMachineInHelpMode();

    if( g_fDenyTSConnectionsPolicy && !bPolicyAllowHelp )
    {
        //
        // Close the connection if TS policy deny connection and 
        // help is disabled.
        //
        TRACE((hTrace, TC_ICASRV, TT_ERROR, 
               "TERMSRV: Denying TS connection due to GP\n"));
        if ( pListenWinStation && pEndpoint ) {
            Status = _CloseEndpoint( &pListenWinStation->Config,
                                 pEndpoint,
                                 EndpointLength,
                                 pListenWinStation,
                                 TRUE ); // Use a temporary stack
            MemFree(pEndpoint);
            pEndpoint = NULL;
        }

        if( InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
            if (hConnectEvent != NULL)
            {
                SetEvent(hConnectEvent);
            }
        }
        return STATUS_CTX_WINSTATION_ACCESS_DENIED;
    }



    //
    //  check for rejected connections
    //
    if( pListenWinStation )
    {
        uAddrSize = sizeof( in_addr );

        bSuccessAdded = Filter_AddOutstandingConnection(
                 pListenWinStation->hStack,
                 pEndpoint,
                 EndpointLength,
                 in_addr,
                 &uAddrSize,
                 &bBlockThis
                 );
        //
        //  connection blocked, close and exit
        //
        if ( bBlockThis )
        {
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                   "TERMSRV: Excessive number of pending connections\n"));

            if ( bSuccessAdded )
            {
                Filter_RemoveOutstandingConnection( in_addr, uAddrSize );
            }
            Status = _CloseEndpoint( &pListenWinStation->Config,
                                     pEndpoint,
                                     EndpointLength,
                                     pListenWinStation,
                                     TRUE ); // Use a temporary stack
            MemFree( pEndpoint );
            pEndpoint = NULL;

            if( InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
            {
                if (hConnectEvent != NULL)
                {
                    SetEvent(hConnectEvent);
                }
            }
    
            return STATUS_CTX_WINSTATION_ACCESS_DENIED;
        }
    }
    else
    {
        // Make sure variable 
        bBlockThis = FALSE;
        bSuccessAdded = FALSE;
    }

    //
    // 

    /*
     * Now find an idle WinStation to transfer this connection to.
     * If there is not one available, then we attempt to create one.
     * if this also fails, then we have no choice but to close
     * the connection endpoint and wait again.
     */
    pTargetWinStation = FindIdleWinStation();
    if ( pTargetWinStation == NULL ) {

        /*
         * Create another idle WinStation
         */
        Status = WinStationCreateWorker( NULL, NULL );
        if ( NT_SUCCESS( Status ) )
            CreatedIdle = TRUE;

        pTargetWinStation = FindIdleWinStation();
        if ( pTargetWinStation == NULL ) {
            TRACE((hTrace, TC_ICASRV, TT_ERROR, 
                   "TERMSRV: Could not get an idle WinStation!\n"));
            goto releaseresources;
        }
    }

    ASSERT( pTargetWinStation->Flags & WSF_IDLE );
    ASSERT( pTargetWinStation->WinStationName[0] == UNICODE_NULL );
    ASSERT( pTargetWinStation->ConnectEvent );

    if ( pListenWinStation ) {
        pConfig = &(pListenWinStation->Config);
        pListenName = pListenWinStation->WinStationName;
    } else {
        //
        // For Whistler, callback is only for Salem, we can pick 
        // configuration from any listening winstation as
        // 1) All we need is HelpAssistant logon/shadow right, which
        //    is already in default.
        // 2) No listening winstation, system is either no pending help
        //    or not allow to get help, so we need to bail out.
        // 3) Additional check at the bottom to make sure login
        //    from callback is HelpAssistant only.
        //
        // If we going support this for the general case, we need
        // to take a default configuration, make connection and issue
        // a new IOCTL call into tdtcp.sys to determine NIC card/IP address 
        // that establish connection and from there, map to right winstation
        // configuration.

        //
        // Setup initial callback configuration, this is only
        // heruristic, we will reset the configuration after
        // determine which NIC is used to connect to TS client
        //
        bCanCallout = FindFirstListeningWinStationName(
                                            szDefaultConfigWinstationName,
                                            &pTargetWinStation->Config
                                        );

        if( FALSE == bCanCallout ) {
            // If no listening thread, connection is not active, don't allow
            // callback
            Status = STATUS_ACCESS_DENIED;
            // It's ok to go to releaseresources even if pConfig is not set
            // because in this case pListenWinStation and pEndpoint are NULL.
            goto releaseresources;
        }
        
        pListenName = szDefaultConfigWinstationName;
        pConfig = &(pTargetWinStation->Config);
    }

    /*
     * Check for MaxInstance
     */
    if ( !(pConfig->Pd[0].Create.PdFlag & PD_SINGLE_INST) ) {
        ULONG Count;

        Count = CountWinStationType( pListenName, FALSE, FALSE );

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Count %d\n", Count ));
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: MaxInstanceCount %d\n",
                pConfig->Create.MaxInstanceCount));

        if ( pConfig->Create.MaxInstanceCount <= Count ) {
            TRACE((hTrace, TC_ICASRV, TT_ERROR, 
                   "TERMSRV: Exceeded maximum instance count [%ld >= %ld]\n",
                   Count, pConfig->Create.MaxInstanceCount));
            goto releaseresources;
        }
    }

    /*
     * Copy the listen name to the target WinStation.
     * This is done to enable tracing on the new stack.
     *
     * Also, this is done BEFORE the connection accept so that if the
     * listen WinStation is reset before the accept completes, the
     * target WinStation will also be reset.
     */
    RtlCopyMemory( pTargetWinStation->ListenName,
                   pListenName,
                   sizeof(pTargetWinStation->ListenName) );

    /*
     *  Enable trace
     */
    
    RtlZeroMemory( &Trace , sizeof( ICA_TRACE ) );
    InitializeTrace( pTargetWinStation, FALSE, &Trace );

    /*
     *  Hook extensions for this target
     */
    pTargetWinStation->pWsx = FindWinStationExtensionDll(
            pConfig->Wd.WsxDLL,
            pConfig->Wd.WdFlag );

    /*
     *  Initialize winstation extension context structure
     */
    if (pTargetWinStation->pWsx &&
            pTargetWinStation->pWsx->pWsxWinStationInitialize) {
        Status = pTargetWinStation->pWsx->pWsxWinStationInitialize(
                &pTargetWinStation->pWsxContext);
        if (Status != STATUS_SUCCESS) {
            TRACE((hTrace, TC_ICASRV, TT_ERROR, 
                   "TERMSRV: WsxWinStationInitialize failed [%lx]\n",
                   Status));
            goto badconnect;
        }
    }

    /*
     * Terminate Listen stack of single-instance transports now, so that
     * the underlying CancelIo doesn't disturb the Accept stack.
     */
    // this one can prevent from generalizing efficiently the transfer function
    if (pListenWinStation && (pListenWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST)) {
        IcaStackTerminate(pListenWinStation->hStack);
    }

    /*
     * Change state to ConnectQuery while we try to accept the connection
     */
    pTargetWinStation->State = State_ConnectQuery;
    NotifySystemEvent(WEVENT_STATECHANGE);

    /*
     * Since the ConnectionAccept may take a while, we have to unlock
     * the target WinStation before the call.  However, we set the
     * WSF_IDLEBUSY flag so that the WinStation does not appear idle.
     */
    pTargetWinStation->Flags |= WSF_IDLEBUSY;
    UnlockWinStation( pTargetWinStation );


    if ( !pListenWinStation && pStackAddress) {

        // must have extension DLL loaded
        if( !pTargetWinStation->pWsx || !pTargetWinStation->pWsx->pWsxIcaStackIoControl ) {
            Status = STATUS_UNSUCCESSFUL;
            goto badconnect;
        }

        //
        // Allocate an endpoint buffer
        //
        EndpointLength = MODULE_SIZE;
        pEndpoint = MemAlloc( MODULE_SIZE );
        if ( !pEndpoint ) {
            Status = STATUS_NO_MEMORY;
            goto badconnect;
        }

        Status = IcaStackConnectionRequest( pTargetWinStation->hStack,
                                         pTargetWinStation->ListenName,
                                         pConfig,
                                         pStackAddress,
                                         pEndpoint,
                                         EndpointLength,
                                         &ReturnLength );

        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            MemFree( pEndpoint );
            pEndpoint = MemAlloc( ReturnLength );
            if ( !pEndpoint ) {
                Status = STATUS_NO_MEMORY;
                goto badconnect;
            }
            EndpointLength = ReturnLength;

            Status = IcaStackConnectionRequest( pTargetWinStation->hStack,
                                                pTargetWinStation->ListenName,
                                                pConfig,
                                                pStackAddress,
                                                pEndpoint,
                                                EndpointLength,
                                                &ReturnLength );
        }

        if ( !NT_SUCCESS(Status) ) {
            // special error code to pass back to client
            StatusCallback = Status;
            goto badconnect;
        }

    }

    /*
     * Now accept the connection for the target WinStation
     * using the new endpoint.
     */
    Status = IcaStackConnectionAccept(pTargetWinStation->hIca,
                                      pTargetWinStation->hStack,
                                      pListenName,
                                      pConfig,
                                      pEndpoint,
                                      EndpointLength,
                                      NULL,
                                      0,
                                      &Trace);

    ConnectionAccepted = (Status == STATUS_SUCCESS);

    TRACE((hTrace,TC_ICASRV,TT_API1,
            "TERMSRV: IcaStackConnectionAccept, LogonId=%d, Status=0x%x\n",
            pTargetWinStation->LogonId, Status));

    if (NT_SUCCESS(Status)) {
        // In post-logon SD work, quering load balancing info has been moved
        // to WinStationNotifyLogonWorker
        // while this part of getting load balancing info is still here
        // because we rely on it to connect to the console
        TS_LOAD_BALANCE_INFO LBInfo;
        ULONG ReturnLength;
        
        // Get the client load balance capability info. 
        // Note we use _IcaStackIoControl() instead of IcaStackIoControl() or
        // WsxIcaStackIoControl() since we still have the stack lock.
        memset(&LBInfo, 0, sizeof(LBInfo));
        Status = _IcaStackIoControl(pTargetWinStation->hStack,
                IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO,
                NULL, 0,
                &LBInfo, sizeof(LBInfo),
                &ReturnLength);

        // On non-success, we'll have FALSE for all of our entries, on
        // success valid values. So, save off the cluster info into the
        // WinStation struct now.
        pTargetWinStation->bClientSupportsRedirection =
                LBInfo.bClientSupportsRedirection;
        pTargetWinStation->bRequestedSessionIDFieldValid =
                LBInfo.bRequestedSessionIDFieldValid;
        pTargetWinStation->bClientRequireServerAddr =
                LBInfo.bClientRequireServerAddr;
        pTargetWinStation->RequestedSessionID = LBInfo.RequestedSessionID;


        /*
         * Attempt to license the client. Failure is fatal, do not let the
         * connection continue.
         */

        LCAssignPolicy(pTargetWinStation);

        Status = LCProcessConnectionProtocol(pTargetWinStation);

        TRACE((hTrace,TC_ICASRV,TT_API1,
                "TERMSRV: LCProcessConnectionProtocol, LogonId=%d, Status=0x%x\n",
                pTargetWinStation->LogonId, Status));

         // The stack was locked from successful IcaStackConnectionAccept(),
         // unlock it now.
        IcaStackUnlock(pTargetWinStation->hStack);
    }

    /*
     * Now relock the target WinStation and clear the IDLEBUSY flag.
     */
    rc = RelockWinStation(pTargetWinStation);
    pTargetWinStation->Flags &= ~WSF_IDLEBUSY;

    /*
     * If the connection accept was not successful,
     * then we have no choice but to close the connection endpoint
     * and go back and wait for another connection.
     */
    if (!NT_SUCCESS(Status) || !rc) {
        TRACE((hTrace, TC_ICASRV, TT_ERROR,
                "TERMSRV: Connection attempt failed, Status [%lx], rc [%lx]\n",
                Status, rc));
        goto badconnect;
    }

    /*
     * The connection accept was successful, save the
     * new endpoint in the target WinStation, copy the config
     * parameters to the target WinStation, and reset the WSF_IDLE flag.
     */
    pTargetWinStation->pEndpoint      = pEndpoint;
    pTargetWinStation->EndpointLength = EndpointLength;
    if ( pListenWinStation ) 
        pTargetWinStation->Config = pListenWinStation->Config;
    pTargetWinStation->Flags &= ~WSF_IDLE;

    /*
     * Copy real name of Single-Instance transports
     */
    if ( pConfig->Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
         RtlCopyMemory( pTargetWinStation->WinStationName,
                       pTargetWinStation->ListenName,
                       sizeof(pTargetWinStation->WinStationName) );
    /*
     * Otherwise, build dynamic name from Listen name and target LogonId.
     */
    } else {
        int CopyCount;
        WINSTATIONNAME TempName;

//        swprintf( TempName, L"#%d", pTargetWinStation->LogonId );
        ASSERT(pTargetWinStation->LogonId > 0 && pTargetWinStation->LogonId < 65536);
        swprintf( TempName, L"#%d", pTargetWinStation->SessionSerialNumber );


        CopyCount = min( wcslen( pTargetWinStation->ListenName ),
                         sizeof( pTargetWinStation->WinStationName ) /
                            sizeof( pTargetWinStation->WinStationName[0] ) -
                                wcslen( TempName ) - 1 );
        wcsncpy( pTargetWinStation->WinStationName,
                 pTargetWinStation->ListenName,
                 CopyCount );
        wcscpy( &pTargetWinStation->WinStationName[CopyCount], TempName );
    }

    /*
     * Inherit the security descriptor from the listen WINSTATION to the
     * connected WINSTATION.
     */
    if ( pListenWinStation ) {
        RtlAcquireResourceShared(&WinStationSecurityLock, TRUE);
        Status = WinStationInheritSecurityDescriptor( pListenWinStation->pSecurityDescriptor,
                                             pTargetWinStation );
        if (Status != STATUS_SUCCESS) {
            // badconnect free pEndpoint, WinStationTerminate() will try to free this
            // end point again causing double free.
            pTargetWinStation->pEndpoint = NULL;
            goto badconnect;
        }
        RtlReleaseResource(&WinStationSecurityLock);
    } else {
        ReadWinStationSecurityDescriptor( pTargetWinStation );
    }


    /*
     *  Initialize client data
     */
    pTargetWinStation->Client.ClientSessionId = LOGONID_NONE;
    ZeroMemory( pTargetWinStation->Client.clientDigProductId, sizeof( pTargetWinStation->Client.clientDigProductId ));
    pTargetWinStation->Client.PerformanceFlags = TS_PERF_DISABLE_NOTHING;

    if ( pTargetWinStation->pWsx && pTargetWinStation->pWsx->pWsxIcaStackIoControl ) {
        (void) pTargetWinStation->pWsx->pWsxIcaStackIoControl(
                              pTargetWinStation->pWsxContext,
                              pTargetWinStation->hIca,
                              pTargetWinStation->hStack,
                              IOCTL_ICA_STACK_QUERY_CLIENT,
                              NULL,
                              0,
                              &pTargetWinStation->Client,
                              sizeof(pTargetWinStation->Client),
                              &ReturnLength );
    }

    if ( pTargetWinStation->Config.Config.User.fWallPaperDisabled )
    {
        pTargetWinStation->Client.PerformanceFlags |= TS_PERF_DISABLE_WALLPAPER;
    }



    //
    // Clear helpassistant specific bits to indicate we still not sure
    // login user is a help assistant
    //
    pTargetWinStation->StateFlags &= ~WSF_ST_HELPSESSION_FLAGS;
    bSessionIsHelpSession = TSIsSessionHelpSession( pTargetWinStation, &bValidRAConnect );

    //
    // If TS policy denies connection, only way to comes to 
    // here is policy allow help, reject connection if logon
    // user is not salem help assistant.
    //

    //
    // Disconnect client on following 
    //
    // 1) Safeboot with networking if not RA connect.
    // 2) Reverse connection if not RA connect.
    // 3) TS not accepting connection via policy setting if not RA connect.
    // 4) Not allowing help if RA connect.
    // 5) Invalid RA connection if RA connect.
    //

    if( TRUE == bSessionIsHelpSession )
    {
        //
        // If invalid ticket or policy deny help, we immediately disconnect
        //
        if( FALSE == bValidRAConnect || FALSE == bPolicyAllowHelp ) 
        {
            // Invalid ticket, disconnect immediately
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: Invalid RA login\n"));
            goto invalid_ra_connection;
        }
    }
    else if( !pListenWinStation && pStackAddress ) 
    {
        // 
        // Reverse Connect, parameter passed in pListenWinStation = NULL
        // and pStackAddress is not NULL, for normal connection, 
        // pListenWinStation is not NULL but pStackAddress is NULL
        //

        //
        // Handle non-RA Reverse connection, Whistler revert connection
        // only allow RA login.
        //
        TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: Not/invalid Help Assistant logon\n"));
        goto invalid_ra_connection;
    }

    //
    // Connecting client must be either non-RA or valid RA connection.
    //

    //
    // Handle Safeboot with networking and TS deny non-RA connection,
    // safeboot with networking only allow RA connection.
    //
    if( g_SafeBootWithNetwork || g_fDenyTSConnectionsPolicy || g_bPersonalWks)
    {
        if( FALSE == bSessionIsHelpSession )
        {
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: Policy or safeboot denied connection\n"));

            goto invalid_ra_connection;
        }
    }

    //
    // Only log Salem event for reverse connection
    //
    if( !pListenWinStation && pStackAddress )
    {
        ASSERT( TRUE == bSessionIsHelpSession );
        TSLogSalemReverseConnection(pTargetWinStation, pStackAddress);
    }

    /*
     * Set the connect event to wake up the target WinStation.
     */
    if (pTargetWinStation->ConnectEvent != NULL) {
        NtSetEvent( pTargetWinStation->ConnectEvent, NULL );
    }

    /*
     * Release target WinStation
     */

    if( pListenWinStation  )
    {

        if (bSuccessAdded) {  // If we could add this IP address to the per IP list then remember it.
            PREMEMBERED_CLIENT_ADDRESS pAddress;
            if ((uAddrSize != 0) && (pAddress = (PREMEMBERED_CLIENT_ADDRESS) MemAlloc( sizeof(REMEMBERED_CLIENT_ADDRESS) + uAddrSize -1 ))!= NULL  ) {
                pAddress->length = uAddrSize;
                RtlCopyMemory( &pAddress->addr[0] , in_addr,uAddrSize );
                pTargetWinStation->pRememberedAddress = pAddress;

            } else {
                Filter_RemoveOutstandingConnection( in_addr, uAddrSize );
                if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
                {
                   if (hConnectEvent != NULL)
                   {
                       SetEvent(hConnectEvent);
                   }
                }

            }
        } else{ // We could not add this IP address to the pr IP list
            if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
            {
               if (hConnectEvent != NULL)
               {
                   SetEvent(hConnectEvent);
               }
            }
        }


    }


    ReleaseWinStation( pTargetWinStation );

    /*
     * If necessary, create another idle WinStation to replace the one being connected
     */
    NtSetEvent(WinStationIdleControlEvent, NULL);


    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

invalid_ra_connection:

    // badconnect free pEndpoint, WinStationTerminate() will try to free this
    // end point again causing double free.
    pTargetWinStation->pEndpoint = NULL;
    StatusCallback = STATUS_CTX_WINSTATION_ACCESS_DENIED;

    /*
     * Error during ConnectionAccept
     */
badconnect:
    /*
     * Clear the Listen name
     */
    RtlZeroMemory( pTargetWinStation->ListenName,
                   sizeof(pTargetWinStation->ListenName) );

    /*
     * Call WinStation rundown function before killing the stack
     */
    if (pTargetWinStation->pWsxContext) {
        if ( pTargetWinStation->pWsx &&
             pTargetWinStation->pWsx->pWsxWinStationRundown ) {
            pTargetWinStation->pWsx->pWsxWinStationRundown( pTargetWinStation->pWsxContext );
        }
        pTargetWinStation->pWsxContext = NULL;
    }
    pTargetWinStation->pWsx = NULL;


    /*
     * Release system resources.  This happens in two phases:
     *
     *  a.) The connection endpoint - since endpoints are not reference counted
     *      care must be taken to destroy the endpoint with the stack in which it
     *      was loaded.  In the event it was not loaded, we create a temporary
     *      stack to do the dirty work.
     *
     *  b.) The Winstation inself - if we had to create an idle winstation to
     *      handle this connection, it is destroyed.  Otherwise we just return
     *      it back to the idle pool.
     *
     */
releaseresources:
    
    /*
     * If we created a target WinStation, then use its stack to close the
     * endpoint since the stack may have a reference to it.
     */
    TRACE((hTrace, TC_ICASRV, TT_ERROR, 
           "TERMSRV: Closing Endpoint [0x%p], winsta = 0x%p, Accepted = %ld\n",
           pEndpoint, pTargetWinStation, ConnectionAccepted));

    if ((pTargetWinStation != NULL) && (ConnectionAccepted)) {
        Status = _CloseEndpoint( pConfig,
                                 pEndpoint,
                                 EndpointLength,
                                 pTargetWinStation,
                                 FALSE ); // Use the stack which already has
                                          // the endpoint loaded
    }

    /*
     * Otherwise, we failed before we got the endpoint loaded so close the
     * endpoint using a temporary stack.
     */
    else if ( pListenWinStation ) {
        // note that:
        // 1. if pListenWinStation is NULL then pEndpoint is NULL, so nothing to close;
        // 2. use the config of pListenWinStation in case pConfig is not set yet.
        Status = _CloseEndpoint( &pListenWinStation->Config,
                                 pEndpoint,
                                 EndpointLength,
                                 pListenWinStation,
                                 TRUE ); // Use a temporary stack
    }    

    if ( pEndpoint )
        MemFree( pEndpoint );

    pEndpoint = NULL;


    /*
     * Return the winstation if we got that far in the protocol sequence
     */
    if (pTargetWinStation != NULL) {
        
        /*
         * If we created a WinStation above because there were no IDLE
         * WinStations available, then we will now have an extra IDLE
         * WinStation.  In this case, reset the current IDLE WinStation.
         */
        if ( CreatedIdle ) {
            QueueWinStationReset( pTargetWinStation->LogonId);
            // clear this so it doesn't get selected as idle when unlocked
            pTargetWinStation->Flags &= ~WSF_IDLE;
            ReleaseWinStation( pTargetWinStation );
        }
    
        /*
         * Else return this WinStation to the idle pool after cleaning up the
         * stack.
         */
        else {

            //
            //  The licensing context needs to be freed and recreated to
            //  ensure it is cleaned up properly.
            //

            LCDestroyContext(pTargetWinStation);

            Status = LCCreateContext(pTargetWinStation);

            if (NT_SUCCESS(Status))
            {
                Status = IcaStackClose( pTargetWinStation->hStack );
                ASSERT( NT_SUCCESS( Status ) );
                Status = IcaStackOpen( pTargetWinStation->hIca,
                                   Stack_Primary,
                                   (PROC)WsxStackIoControl,
                                   pTargetWinStation,
                                   &pTargetWinStation->hStack );
            }

            if (NT_SUCCESS(Status)) {
                pTargetWinStation->State = State_Idle;
                NotifySystemEvent( WEVENT_STATECHANGE );
                ReleaseWinStation( pTargetWinStation );
            } else {
                pTargetWinStation->Flags &= ~WSF_IDLE;
                QueueWinStationReset( pTargetWinStation->LogonId);
                ReleaseWinStation( pTargetWinStation );
            }
        }
    }


    if ( pListenWinStation  )
    {

        if (bSuccessAdded) {
            Filter_RemoveOutstandingConnection( in_addr, uAddrSize );
        }
        if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
            if (hConnectEvent != NULL)
            {
                SetEvent(hConnectEvent);
            }
        }

    }

    // If error is due to call back, return meaningful error 
    // code.
    if( STATUS_SUCCESS != StatusCallback )
    {
        return StatusCallback;
    }

    return -1 /*STATUS_CTX_UNACCEPTED_CONNECTION*/;
}


/*******************************************************************************
 *  ConnectSmWinStationApiPort
 *
 *   Open a connection to the WinStationApiPort.  This will be used
 *   to queue requests to the Api Request thread instead of processing
 *   them in line.
 ******************************************************************************/
NTSTATUS ConnectSmWinStationApiPort()
{
    UNICODE_STRING PortName;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    WINSTATIONAPI_CONNECT_INFO info;
    ULONG ConnectInfoLength;
    NTSTATUS Status;

    /*
     * Set up the security quality of service parameters to use over the
     * port.  Use the most efficient (least overhead) - which is dynamic
     * rather than static tracking.
     */
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    RtlInitUnicodeString( &PortName, L"\\SmSsWinStationApiPort" );

    // Fill in the ConnectInfo structure with our access request mask
    info.Version = CITRIX_WINSTATIONAPI_VERSION;
    info.RequestedAccess = 0;
    ConnectInfoLength = sizeof(WINSTATIONAPI_CONNECT_INFO);

    Status = NtConnectPort( &WinStationApiPort,
                            &PortName,
                            &DynamicQos,
                            NULL,
                            NULL,
                            NULL, // Max message length [select default]
                            (PVOID)&info,
                            &ConnectInfoLength );

    if ( !NT_SUCCESS( Status ) ) {
        // Look at the returned INFO to see why if desired
        if ( ConnectInfoLength == sizeof(WINSTATIONAPI_CONNECT_INFO) ) {
            DBGPRINT(( "TERMSRV: Sm connect failed, Reason 0x%x\n",
                      info.AcceptStatus));
        }
        DBGPRINT(( "TERMSRV: Connect to SM failed %lx\n", Status ));
    }

    return Status;
}


/*******************************************************************************
 *  QueueWinStationCreate
 *
 *   Send a create message to the WinStationApiPort.
 *
 * ENTRY:
 *    pWinStationName (input)
 *       Pointer to WinStationName to be created
 ******************************************************************************/
NTSTATUS QueueWinStationCreate(PWINSTATIONNAME pWinStationName)
{
    WINSTATION_APIMSG msg;
    NTSTATUS Status;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: QueueWinStationCreate: %S\n", pWinStationName ));

    /*
     * Initialize msg
     */
    msg.h.u1.s1.DataLength = sizeof(msg) - sizeof(PORT_MESSAGE);
    msg.h.u1.s1.TotalLength = sizeof(msg);
    msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    msg.h.u2.s2.DataInfoOffset = 0;
    msg.ApiNumber = SMWinStationCreate;
    msg.WaitForReply = FALSE;
    if ( pWinStationName ) {
        RtlCopyMemory( msg.u.Create.WinStationName, pWinStationName,
                       sizeof(msg.u.Create.WinStationName) );
    } else {
        RtlZeroMemory( msg.u.Create.WinStationName,
                       sizeof(msg.u.Create.WinStationName) );
    }

    /*
     * Send create message to our API request thread
     * but don't wait for a reply.
     */
    Status = NtRequestPort( WinStationApiPort, (PPORT_MESSAGE) &msg );
    ASSERT( NT_SUCCESS( Status ) );

    return Status;
}


/*******************************************************************************
 *  QueueWinStationReset
 *
 *   Send a reset message to the WinStationApiPort.
 *
 * ENTRY:
 *    LogonId (input)
 *       LogonId of WinStationName to reset
 ******************************************************************************/
NTSTATUS QueueWinStationReset(ULONG LogonId)
{

    WINSTATION_APIMSG msg;
    NTSTATUS Status;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: QueueWinStationReset: %u\n", LogonId ));

    /*
     * Initialize msg
     */
    msg.h.u1.s1.DataLength = sizeof(msg) - sizeof(PORT_MESSAGE);
    msg.h.u1.s1.TotalLength = sizeof(msg);
    msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    msg.h.u2.s2.DataInfoOffset = 0;
    msg.ApiNumber = SMWinStationReset;
    msg.WaitForReply = FALSE;
    msg.u.Reset.LogonId = LogonId;

    /*
     * Send reset message to our API request thread
     * but don't wait for a reply.
     */
    Status = NtRequestPort( WinStationApiPort, (PPORT_MESSAGE) &msg );
    ASSERT( NT_SUCCESS( Status ) );

    return( Status );
}


/*******************************************************************************
 *  QueueWinStationDisconnect
 *
 *   Send a disconnect message to the WinStationApiPort.
 *
 * ENTRY:
 *    LogonId (input)
 *       LogonId of WinStationName to disconnect
 ******************************************************************************/
NTSTATUS QueueWinStationDisconnect(ULONG LogonId)
{
    WINSTATION_APIMSG msg;
    NTSTATUS Status;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: QueueWinStationDisconnect: %u\n", LogonId ));

    /*
     * Initialize msg
     */
    msg.h.u1.s1.DataLength = sizeof(msg) - sizeof(PORT_MESSAGE);
    msg.h.u1.s1.TotalLength = sizeof(msg);
    msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    msg.h.u2.s2.DataInfoOffset = 0;
    msg.ApiNumber = SMWinStationDisconnect;
    msg.WaitForReply = FALSE;
    msg.u.Reset.LogonId = LogonId;

    /*
     * Send disconnect message to our API request thread
     * but don't wait for a reply.
     */
    Status = NtRequestPort( WinStationApiPort, (PPORT_MESSAGE) &msg );
    ASSERT( NT_SUCCESS( Status ) );

    return( Status );
}


/*******************************************************************************
 *  IcaRegWinStationEnumerate
 *
 *   Enumerate all WinStations configured in the registry.
 *
 * ENTRY:
 *    pWinStationCount (input/output)
 *       count of WinStation names to return, on return the number of
 *       WinStation names actually returned in name buffer
 *    pWinStationName (output)
 *       pointer to buffer to return WinStation names
 *    pByteCount (input/output)
 *       size of WinStation name buffer, on return the number of
 *       bytes actually returned in the name buffer
 ******************************************************************************/
NTSTATUS IcaRegWinStationEnumerate(
        PULONG pWinStationCount,
        PWINSTATIONNAME pWinStationName,
        PULONG pByteCount)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR PathBuffer[ 260 ];
    UNICODE_STRING KeyPath;
    HANDLE Handle;
    ULONG i;
    ULONG Count;

    wcscpy( PathBuffer, REG_NTAPI_CONTROL_TSERVER L"\\" REG_WINSTATIONS );
    RtlInitUnicodeString( &KeyPath, PathBuffer );

    InitializeObjectAttributes( &ObjectAttributes, &KeyPath,
                                OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = NtOpenKey( &Handle, GENERIC_READ, &ObjectAttributes );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: NtOpenKey failed, rc=%x\n", Status ));
        return( Status );
    }

    Count = pWinStationName ?
            min( *pByteCount / sizeof(WINSTATIONNAME), *pWinStationCount ) :
            (ULONG) -1;
    *pWinStationCount = *pByteCount = 0;
    for ( i = 0; i < Count; i++ ) {
        WINSTATIONNAME WinStationName;
        UNICODE_STRING WinStationString;

        WinStationString.Length = 0;
        WinStationString.MaximumLength = sizeof(WinStationName);
        WinStationString.Buffer = WinStationName;
        Status = RtlpNtEnumerateSubKey( Handle, &WinStationString, i, NULL );
        if ( !NT_SUCCESS( Status ) ) {
            if ( Status != STATUS_NO_MORE_ENTRIES ) {
                DBGPRINT(( "TERMSRV: RtlpNtEnumerateSubKey failed, rc=%x\n", Status ));
            }
            break;
        }
        if ( pWinStationName ) {
            RtlCopyMemory( pWinStationName, WinStationName,
                           WinStationString.Length );
            pWinStationName[WinStationString.Length>>1] = UNICODE_NULL;
            (char*)pWinStationName += sizeof(WINSTATIONNAME);
        }
        (*pWinStationCount)++;
        *pByteCount += sizeof(WINSTATIONNAME);
    }

    NtClose( Handle );

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  WinStationCreateWorker
 *
 *   Worker routine to create/start a WinStation.
 *
 * ENTRY:
 *    pWinStationName (input) (optional)
 *       Pointer to WinStationName to be created
 *    pLogonId (output)
 *       location to return LogonId of new WinStation
 *
 *    NOTE: If a WinStation name is specified, then this will become the
 *          "listening" WinStation for the specified name.
 *          If a WinStation name is not specified, then this will become
 *          part of the free pool of idle/disconnected WinStations.
 ******************************************************************************/
NTSTATUS WinStationCreateWorker(
        PWINSTATIONNAME pWinStationName,
        PULONG pLogonId )
{
    BOOL fConsole;
    PWINSTATION pWinStation;
    PWINSTATION pCurWinStation;
    NTSTATUS Status;
    UNICODE_STRING WinStationString;
    ULONG ReturnLength;
    
    /*
     * If system shutdown is in progress, then don't allow create
     */
    if ( ShutdownInProgress ) {
        Status = STATUS_ACCESS_DENIED;
        goto shutdown;
    }

    if (pWinStationName == NULL)
    {
        fConsole = FALSE;
    }
    else
    {
        fConsole = (_wcsicmp(pWinStationName, L"Console") == 0);
    }

    /*
     * If not the Console, then verify the WinStation name is defined
     * in the registry and that it is enabled.
     */
    if ( pWinStationName && !fConsole ) {
        Status = CheckWinStationEnable( pWinStationName );
        if ( Status != STATUS_SUCCESS ) {
            DBGPRINT(( "TERMSRV: WinStation '%ws' is disabled\n", pWinStationName ));
            goto disabled;
        }
    }

    /*
     * Allocate and initialize WinStation struct
     */
    if ( (pWinStation = MemAlloc( sizeof(WINSTATION) )) == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto nomem;
    }
    RtlZeroMemory( pWinStation, sizeof(WINSTATION) );
    pWinStation->Starting = TRUE;
    pWinStation->NeverConnected = TRUE;
    pWinStation->State = State_Init;
    pWinStation->pNewNotificationCredentials = NULL;
    pWinStation->LastReconnectType = NeverReconnected;
    pWinStation->fDisallowAutoReconnect = FALSE;


    InitializeListHead( &pWinStation->ShadowHead );
    InitializeListHead( &pWinStation->Win32CommandHead );

    // Create the licensing context
    Status = LCCreateContext(pWinStation);
    if ( !NT_SUCCESS( Status ) )
        goto nolicensecontext;


    // Create and lock winstation mutex
    Status = InitRefLock( &pWinStation->Lock, WinStationDeleteProc );
    if ( !NT_SUCCESS( Status ) )
        goto nolock;

    /*
     * If a WinStation name was specified, see if it already exists
     * (on return, WinStationListLock will be locked).
     */
    if ( pWinStationName ) {
        if ( pCurWinStation = FindWinStationByName( pWinStationName, TRUE ) ) {
            ReleaseWinStation( pCurWinStation );
            LEAVECRIT( &WinStationListLock );
            Status = STATUS_CTX_WINSTATION_NAME_COLLISION;
            goto alreadyexists;
        }
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Creating WinStation %ws\n", pWinStationName ));
        wcscpy( pWinStation->WinStationName, pWinStationName );

        /*
         * If not the console, then this will become a "listen" WinStation
         */
        if ( !fConsole ) {

            pWinStation->Flags |= WSF_LISTEN;

            //
            // Listener winstations always get LogonId above 65536 and are
            // assigned by Terminal Server. LogonId's for sessions are
            // generated by mm in the range 0-65535
            //
            pWinStation->LogonId = LogonId++;
            ASSERT(pWinStation->LogonId >= 65536);

        } else {

            //
            // Console always get 0
            //
            pWinStation->LogonId = 0;
            pWinStation->fOwnsConsoleTerminal = TRUE;

        }

    /*
     * No WinStation name was specified.
     * This will be an idle WinStation waiting for a connection.
     */
    } else {
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Creating IDLE WinStation\n" ));
        pWinStation->Flags |= WSF_IDLE;
        pWinStation->LogonId = -1; // MM will asssign session IDs
        ENTERCRIT( &WinStationListLock );
    }

    /*
     * Allocate LogonId and insert in WinStation list
     */
    InsertTailList( &WinStationListHead, &pWinStation->Links );
    LEAVECRIT( &WinStationListLock );

    /*
     *  Initialize WinStation configuration data
     */
#ifdef NO_CONSOLE_REGISTRY
    if ( pWinStation->LogonId ) {
#endif
        /*
         *  Read winstation configuration data from registry
         */
        if ( pWinStationName ) {
            Status = RegWinStationQueryEx( SERVERNAME_CURRENT,
                                         &g_MachinePolicy, 
                                         pWinStationName,
                                         &pWinStation->Config,
                                         sizeof(WINSTATIONCONFIG2),
                                         &ReturnLength, TRUE );
            if ( !NT_SUCCESS(Status) ) {
                goto badregdata;
            }

            if (pWinStation->Config.Wd.WdFlag & WDF_TSHARE)
            {
                pWinStation->Client.ProtocolType = PROTOCOL_RDP;
            }
            else if (pWinStation->Config.Wd.WdFlag & WDF_ICA)
            {
                pWinStation->Client.ProtocolType = PROTOCOL_ICA;
            }
            else
            {
                pWinStation->Client.ProtocolType = PROTOCOL_CONSOLE;
            }

            /*
             * Save console config for console sessions.
             */

            if (pWinStation->LogonId == 0) {
                gConsoleConfig = pWinStation->Config;

                // initalize client data, since there isn't any real rdp client sending anythhing to us
                InitializeConsoleClientData( & pWinStation->Client );

            }
        }
#ifdef NO_CONSOLE_REGISTRY
    } else {


        /*
         *  Hand craft the console configuration data
         */
        PWDCONFIG pWdConfig = &pWinStation->Config.Wd;
        PPDCONFIGW pPdConfig = &pWinStation->Config.Pd[0];

        wcscpy( pWdConfig->WdName, L"Console" );
        pWdConfig->WdFlag = WDF_NOT_IN_LIST;
        wcscpy( pPdConfig->Create.PdName, L"Console" );
        pPdConfig->Create.PdClass = PdConsole;
        pPdConfig->Create.PdFlag  = PD_USE_WD | PD_RELIABLE | PD_FRAME |
                                    PD_CONNECTION | PD_CONSOLE;

        RegQueryOEMId( (PBYTE) &pWinStation->Config.Config.OEMId,
                       sizeof(pWinStation->Config.Config.OEMId) );               

    }
#endif

    if (pWinStation->LogonId == 0 || g_bPersonalTS) {
        
        // Create a named event for console session so that winmm can check if we
        // are remoting audio on the console itself.  Use a global event is for
        // fast check
        {
            BYTE bSA[SECURITY_DESCRIPTOR_MIN_LENGTH];
            PSECURITY_DESCRIPTOR pSD = &bSA;
            SECURITY_ATTRIBUTES SA;
            EXPLICIT_ACCESS ea;
            SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;
            PSID pSidWorld;
            PACL pNewDAcl;
            DWORD dwres;

            if ( AllocateAndInitializeSid( &siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidWorld))
            {
                ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
                ea.grfAccessPermissions = SYNCHRONIZE;
                ea.grfAccessMode = GRANT_ACCESS;
                ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
                ea.Trustee.ptstrName = (LPTSTR)pSidWorld;

                dwres = SetEntriesInAcl(1, &ea, NULL, &pNewDAcl );
                if ( ERROR_SUCCESS == dwres )
                {
                  if (InitializeSecurityDescriptor(pSD,
                                                   SECURITY_DESCRIPTOR_REVISION))
                  {
                    if (SetSecurityDescriptorDacl(pSD, TRUE, pNewDAcl, FALSE ))
                    {
                        SA.nLength = sizeof( SA );
                        SA.lpSecurityDescriptor = pSD;
                        SA.bInheritHandle = FALSE;
                        pWinStation->hWinmmConsoleAudioEvent = 
                               CreateEvent( &SA, TRUE, FALSE, L"Global\\WinMMConsoleAudioEvent");
                    }
                  }
                  LocalFree( pNewDAcl );
                }
                LocalFree( pSidWorld );
            }
        }
    }
    else {
        pWinStation->hWinmmConsoleAudioEvent = NULL;
    }


    /*
     * Start the WinStation
     */
    Status = WinStationStart( pWinStation );
    
    /*
     * Ignore errors from console, otherwise keep going
     */
    if ( ( pWinStation->LogonId ) && ( Status != STATUS_SUCCESS ) )
        goto starterror;


    /*
     * Return LogonId to caller
     */
    if ( pLogonId )
        *pLogonId = pWinStation->LogonId;

    // Increment the total number of sessions created since TermSrv started.
    // we don't count the console and listener sessions
    if (pWinStation->LogonId > 0 && pWinStation->LogonId < 65536) {
        pWinStation->SessionSerialNumber = (ULONG) InterlockedIncrement(&g_TermSrvTotalSessions);
    }

    if (!(pWinStation->Flags & WSF_LISTEN))
    {
        Status = InitializeSessionNotification(pWinStation);
        if ( !NT_SUCCESS( Status ) )
            goto starterror; 
    }


    /*
     * Set WinStationEvent to indicate another WinStation has been created
     */
    ENTERCRIT( &WinStationListLock );
    pWinStation->Starting = FALSE;
    NtSetEvent( WinStationEvent, NULL );
    
    // Keep track of total session count for Load Balancing Indicator but
    // don't count listen winstations
    if (!(pWinStation->Flags & WSF_LISTEN))
        WinStationTotalCount++;

    LEAVECRIT( &WinStationListLock );

    /*
     * Release WinStation now
     */
    ReleaseWinStation( pWinStation );

    /*
     * Notify clients of WinStation create
     */


    NotifySystemEvent( WEVENT_CREATE );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * WinStationStart returned error
     * WinStation kernel object could not be created
     */
starterror:
    if ( !(pWinStation->Flags & (WSF_RESET | WSF_DELETE)) ) {
        if ( StopOnDown )
            DbgBreakPoint();
        pWinStation->Flags |= WSF_DELETE;
        WinStationTerminate( pWinStation );
        pWinStation->State = State_Down;
        PostErrorValueEvent(EVENT_TS_WINSTATION_START_FAILED, Status);
        WinStationDeleteWorker(pWinStation);
    } else {
        ReleaseWinStation( pWinStation );
    }



    return Status;

    /*
     * Error reading registry data
     */
badregdata:

    /*
     * WinStation name already exists
     */
alreadyexists:
    ReleaseWinStation( pWinStation );
    NtClose( pWinStation->Lock.Mutex );

    /*
     * Could not create WinStation lock
     */
nolock:
    LCDestroyContext(pWinStation);

    /*
     * Could not allocate licensing context
     */
nolicensecontext:
    MemFree( pWinStation );


    /*
     * Could not allocate WinStation
     */
nomem:
    PostErrorValueEvent(EVENT_TS_WINSTATION_START_FAILED, Status);

    /*
     * WinStation is disabled
     * System shutdown is in progress
     */
disabled:
shutdown:

    return Status;
}


/*******************************************************************************
 *  WinStationStart
 *
 *   Start a WinStation.  This involves reading the
 *   execute list from the registry, loading the WinStation
 *   subsystems, and starting the initial program.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to start
 ******************************************************************************/
NTSTATUS WinStationStart(PWINSTATION pWinStation)
{
    OBJECT_ATTRIBUTES ObjA;
    LARGE_INTEGER Timeout;
    NTSTATUS Status;
    UNICODE_STRING InitialCommand;
    PUNICODE_STRING pInitialCommand;
    PWCHAR pExecuteBuffer = NULL;
    ULONG CommandSize;
    ICA_TRACE Trace;
    PWCHAR pszCsrStartEvent = NULL;
    PWCHAR pszReconEvent = NULL;
    UNICODE_STRING EventName;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationStart, %S (LogonId=%d)\n",
               pWinStation->WinStationName, pWinStation->LogonId ));

    // allocate memory

    pExecuteBuffer = MemAlloc( MAX_STRING_BYTES * sizeof(WCHAR) );
    if (pExecuteBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    pszCsrStartEvent = MemAlloc( MAX_PATH * sizeof(WCHAR) );
    if (pszCsrStartEvent == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    pszReconEvent = MemAlloc( MAX_PATH * sizeof(WCHAR) );
    if (pszReconEvent == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    /*
     * If its a WSF_LISTEN WinStation, see if a specific ACL has
     * been set for it.
     *
     * This ACL will be inherited by WinStations that are
     * connected to from this thread.
     *
     * If not specific ACL has been set, the system default
     * will be used.
     */

    if (( pWinStation->Flags & WSF_LISTEN ) || (pWinStation->LogonId == 0)){

        ReadWinStationSecurityDescriptor( pWinStation );
    }

   /*
   * Open an instance of the TermDD device driver
   */
    Status = IcaOpen( &pWinStation->hIca );
    if ( !NT_SUCCESS( Status ) ) {
         DBGPRINT(( "TERMSRV IcaOpen: Error 0x%x from IcaOpen, last error %d\n",
                   Status, GetLastError() ));
         goto done;
     }

    /*
     * Open a stack instance
     */
    Status = IcaStackOpen( pWinStation->hIca, Stack_Primary,
            (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack);

    if ( !NT_SUCCESS( Status ) ) {
        IcaClose( pWinStation->hIca );
        pWinStation->hIca = NULL;
        DBGPRINT(( "TERMSRV IcaStackOpen: Error 0x%x from IcaStackOpen, last error %d\n",
                   Status, GetLastError() ));
        goto done;
    }

    if ( !NT_SUCCESS( Status ) ) {
        IcaClose( pWinStation->hIca );
        pWinStation->hIca = NULL;
        DBGPRINT(( "TERMSRV IcaStackOpen for console stack: Error 0x%x from IcaStackOpen, last error %d\n",
                  Status, GetLastError() ));
    }

    /*
     *  Enable trace
     */
    RtlZeroMemory( &Trace , sizeof( ICA_TRACE ) );
    InitializeTrace( pWinStation, FALSE, &Trace );



    /*
     * If this is a "listening" WinStation, then we don't load the
     * subsystems and initial command.  Instead we create a service
     * thread to wait for new connections and service them.
     */
    if ( pWinStation->Flags & WSF_LISTEN ) {
        DWORD ThreadId;

        pWinStation->hConnectThread = CreateThread(
                          NULL,
                          0,        // use Default stack size of the svchost process
                          (LPTHREAD_START_ROUTINE)WinStationConnectThread,
                          LongToPtr( pWinStation->LogonId ),
                          0,
                          &ThreadId
                          );

        pWinStation->CreateStatus = STATUS_SUCCESS;
        Status = pWinStation->CreateStatus;
        pWinStation->NeverConnected = FALSE;
        pWinStation->State = State_Listen;
        NotifySystemEvent( WEVENT_STATECHANGE );

    /*
     * Load subsystems and initial command
     *
     * Session Manager starts the console itself, but returns the
     * process ID's.  For all others, this actually starts CSR
     * and winlogon.
     */
    } else {
        /*
         * Create event we will wait on below
         */
        if ( pWinStation->LogonId ) {

            InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
            Status = NtCreateEvent( &pWinStation->CreateEvent, EVENT_ALL_ACCESS, &ObjA,
                                    NotificationEvent, FALSE );
            if ( !NT_SUCCESS( Status ) )
                goto done; 
        }

        UnlockWinStation( pWinStation );

        /*
         * Check debugging options
         */
        Status = RegWinStationQueryValueW(
                     SERVERNAME_CURRENT,
                     pWinStation->WinStationName,
                     L"Execute",
                     pExecuteBuffer,
                     MAX_STRING_BYTES * sizeof(WCHAR),
                     &CommandSize );

        if ( !Status && CommandSize ) {
            RtlInitUnicodeString( &InitialCommand, pExecuteBuffer );
            pInitialCommand = &InitialCommand;
        } else {
            pInitialCommand = NULL;
        }

        /*
         * For now only do one winstation start at a time.  This is because of
         * WinStation space problems.  The Session manager maps it's self into
         * the WinStation space of the CSR it wants to start so the CSR inherits
         * the space.  That means only one CSR can be started at a time.
         */
        ENTERCRIT( &WinStationStartCsrLock );
        
        
        //Terminal Service needs to skip Memory check in Embedded images 
        //when the TS service starts
        //bug #246972
        if(!IsEmbedded()) {
            /*
             * Make sure we have enough resources to start a new session
             */

            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &glpAddress,
                                              0,
                                              &gMinPerSessionPageCommit,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );

            if (!NT_SUCCESS(Status)) {
                DBGPRINT(( "TERMSRV: NtAllocateVirtualMemory failed with Status %lx for Size %lx(MB)\n",Status,gMinPerSessionPageCommitMB));
                LEAVECRIT( &WinStationStartCsrLock );
                goto done;
            } else {

                Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                              &glpAddress,
                                              &gMinPerSessionPageCommit,
                                              MEM_DECOMMIT
                                            );
                if (!NT_SUCCESS(Status)) {
                    DBGPRINT(( "TERMSRV: NtFreeVirtualMemory failed with Status %lx \n",Status));
                    ASSERT(NT_SUCCESS(Status));
                }
            }
        }


        Status = SmStartCsr( IcaSmApiPort,
                             &pWinStation->LogonId,
                             pInitialCommand,
                             (PULONG_PTR)&pWinStation->InitialCommandProcessId,
                             (PULONG_PTR)&pWinStation->WindowsSubSysProcessId );



        LEAVECRIT( &WinStationStartCsrLock );

        if ( !RelockWinStation( pWinStation ) )
            Status = STATUS_CTX_CLOSE_PENDING;

        if (  Status != STATUS_SUCCESS) {
            DBGPRINT(("TERMSRV: SmStartCsr failed\n"));
            goto done;
        }


        /*
         * Close handle to initial command process, if already opened
         */
        if ( pWinStation->InitialCommandProcess ) {
            NtClose( pWinStation->InitialCommandProcess );
            pWinStation->InitialCommandProcess = NULL;
        }

        /*
         * Open handle to initial command process
         */
        pWinStation->InitialCommandProcess = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE,
            (DWORD)(ULONG_PTR)(pWinStation->InitialCommandProcessId) );

        if ( pWinStation->InitialCommandProcess == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Logon %d cannot open Initial command process\n",
                      pWinStation->LogonId));
            Status = STATUS_ACCESS_DENIED;
            goto done;
        }

        /*
         * Open handle to WIN32 subsystem process
         */
        pWinStation->WindowsSubSysProcess = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE,
            (DWORD)(ULONG_PTR)(pWinStation->WindowsSubSysProcessId) );

        if ( pWinStation->WindowsSubSysProcess == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Logon %d cannot open windows subsystem process\n",
                      pWinStation->LogonId));
            Status = STATUS_ACCESS_DENIED;
            goto done;
        }

        //
        // Terminal Server calls into Session Manager to create a new Hydra session.
        // The session manager creates and resume a new session and returns to Terminal
        // server the session id of the new session. There is a race condition where
        // CSR can resume and call into terminal server before terminal server can
        // store the session id in its internal structure. To prevent this CSR will
        // wait here on a named event which will be set by Terminal server once it
        // gets the sessionid for the newly created session
        // Create CsrStartEvent
        //
        if ( NT_SUCCESS( Status ) && pWinStation->LogonId ) {

            wsprintf(pszCsrStartEvent,
                L"\\Sessions\\%d\\BaseNamedObjects\\CsrStartEvent",pWinStation->LogonId);
            RtlInitUnicodeString( &EventName,pszCsrStartEvent);
            InitializeObjectAttributes( &ObjA, &EventName, OBJ_OPENIF, NULL, NULL );

            Status = NtCreateEvent( &(pWinStation->CsrStartEventHandle),
                                    EVENT_ALL_ACCESS,
                                    &ObjA,
                                    NotificationEvent,
                                    FALSE );

            if ( !NT_SUCCESS( Status ) ) {
                DBGPRINT(("TERMSRV: NtCreateEvent (%ws) failed (%lx)\n",pszCsrStartEvent, Status));
                ASSERT(FALSE);
                pWinStation->CsrStartEventHandle = NULL;
                goto done;
            }

            //
            //  Now that we have the sessionId(LogonId), set the CsrStartEvent so
            //  CSR can connect to TerminalServer
            //

            NtSetEvent(pWinStation->CsrStartEventHandle, NULL);
        }

        {
           //
           // Create ReconnectReadyEvent
           //
           if ( pWinStation->LogonId == 0 ) {
              wsprintf(pszReconEvent,
                   L"\\BaseNamedObjects\\ReconEvent");
           } else {
             wsprintf(pszReconEvent,
                  L"\\Sessions\\%d\\BaseNamedObjects\\ReconEvent",pWinStation->LogonId);
           }
           RtlInitUnicodeString( &EventName,pszReconEvent);
           InitializeObjectAttributes( &ObjA, &EventName, OBJ_OPENIF, NULL, NULL );

           Status = NtCreateEvent( &(pWinStation->hReconnectReadyEvent),
                                   EVENT_ALL_ACCESS,
                                   &ObjA,
                                   NotificationEvent,
                                   TRUE );

           if ( !NT_SUCCESS( Status ) ) {
               DBGPRINT(("TERMSRV: NtCreateEvent (%ws) failed (%lx)\n",pszReconEvent, Status));
               ASSERT(FALSE);
               pWinStation->hReconnectReadyEvent = NULL;
               goto done;
           }

        }

        /*
         * For console, create is always successful - but do we need to
         * crank up the stack for the console session?
         */
        if ( pWinStation->LogonId == 0 )
        {
            pWinStation->CreateStatus = STATUS_SUCCESS;
            Status = pWinStation->CreateStatus;
            pWinStation->NeverConnected = FALSE;
            pWinStation->State = State_Connected;

        /*
         * Wait for create event to be triggered and get create status
         */
        } else {
            Timeout = RtlEnlargedIntegerMultiply( 30000, -10000 );
            UnlockWinStation( pWinStation );
            Status = NtWaitForSingleObject( pWinStation->CreateEvent, FALSE, &Timeout );
            if ( !RelockWinStation( pWinStation ) )
                Status = STATUS_CTX_CLOSE_PENDING;
            if ( Status == STATUS_SUCCESS )
                Status = pWinStation->CreateStatus;

            NtClose( pWinStation->CreateEvent );
            pWinStation->CreateEvent = NULL;
        }
    }

done:
    
    if (pExecuteBuffer != NULL) {
        MemFree(pExecuteBuffer);
        pExecuteBuffer = NULL;
    }

    if (pszCsrStartEvent != NULL) {
        MemFree(pszCsrStartEvent);
        pszCsrStartEvent = NULL;
    }

    if (pszReconEvent != NULL) {
        MemFree(pszReconEvent);
        pszReconEvent = NULL;
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationStart Subsys PID=%d InitialProg PID=%d, Status=0x%x\n",
               pWinStation->WindowsSubSysProcessId,
               pWinStation->InitialCommandProcessId,
               Status ));

    return Status;
}


/*******************************************************************************
 *  WinStationRenameWorker
 *
 *   Worker routine to rename a WinStation.
 *
 * ENTRY:
 *    pWinStationNameOld (input)
 *       Pointer to old WinStationName
 *    pWinStationNameNew (input)
 *       Pointer to new WinStationName
 ******************************************************************************/
NTSTATUS WinStationRenameWorker(
        PWINSTATIONNAME pWinStationNameOld,
        ULONG           NameOldSize,
        PWINSTATIONNAME pWinStationNameNew,
        ULONG           NameNewSize)
{
    PWINSTATION pWinStation;
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;
    ULONG ulNewNameLength;

    /*
     * Ensure new WinStation name is non-zero length
     */

    //
    // The new WinStationName is allocated by the RPC server stub and the
    // size is sent over by the client (this is part of the existing interface.
    // Therefore, it is sufficient to assert for the pWinStationNameNew to be
    // non-null AND the New size to be non-zero. If it asserts, this is a serious
    // problem with the rpc stub that should never happen in a released build.
    //
    // The old WinStationName also poses a problem. It is assumed in the code
    // that follows that the old WinStationName is NULL terminated. The RPC
    // interface does not say that. Which means the call to FindWinStation by
    // name can potentially AV.

    if (!( (pWinStationNameNew != 0 ) && (NameNewSize != 0 ) &&
           !IsBadWritePtr( pWinStationNameNew, NameNewSize ) ) ) {

       return( STATUS_CTX_WINSTATION_NAME_INVALID );
    }

    if (!( (pWinStationNameOld != 0 ) && (NameOldSize != 0 )
       && !IsBadReadPtr( pWinStationNameOld, NameOldSize ) &&
       !IsBadWritePtr( pWinStationNameOld, NameOldSize))) {

       return( STATUS_CTX_WINSTATION_NAME_INVALID );
    }

    /*
     * Find and lock the WinStation
     * (Note that we hold the WinStationList lock while changing the name.)
     */
    // We will add a NULL Terminator to the end of the old winstation name

    pWinStationNameOld[ NameOldSize - 1 ] = 0;
    pWinStationNameNew[ NameNewSize - 1 ] = 0;

    /*
     * Ensure new WinStation name is non-zero length and not too long
     */
    ulNewNameLength = wcslen( pWinStationNameNew );
    if ( ( ulNewNameLength == 0 ) || ( ulNewNameLength > WINSTATIONNAME_LENGTH ) )
        return( STATUS_CTX_WINSTATION_NAME_INVALID );


    pWinStation = FindWinStationByName( pWinStationNameOld, TRUE );

    if ( pWinStation == NULL ) {
        LEAVECRIT( &WinStationListLock );
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    }

    /*
     * Verify that client has DELETE access
     */
    Status = RpcCheckClientAccess( pWinStation, DELETE, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        LEAVECRIT( &WinStationListLock );
        ReleaseWinStation( pWinStation );
        return( Status );
    }

    /*
     * Now search the WinStation list to see if the new WinStation name
     * is already used.  If so then this is an error.
     */
    Head = &WinStationListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        PWINSTATION pWinStationTemp;

        pWinStationTemp = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( !_wcsicmp( pWinStationTemp->WinStationName, pWinStationNameNew ) ) {
            LEAVECRIT( &WinStationListLock );
            ReleaseWinStation( pWinStation );
            return( STATUS_CTX_WINSTATION_NAME_COLLISION );
        }
    }

    /*
     * Free the old name and set the new one, then release
     * the WinStationList lock and the WinStation mutex.
     */
    wcsncpy( pWinStation->WinStationName, pWinStationNameNew, WINSTATIONNAME_LENGTH );
    pWinStation->WinStationName[ WINSTATIONNAME_LENGTH ] = 0;

    LEAVECRIT( &WinStationListLock );
    ReleaseWinStation( pWinStation );

    /*
     * Notify clients of WinStation rename
     */
    NotifySystemEvent( WEVENT_RENAME );

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  WinStationTerminate
 *
 *   Terminate a WinStation.  This involves causing the WinStation initial
 *   program to logoff, terminating the initial program, and terminating
 *   all subsystems.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to terminate
 ******************************************************************************/
VOID WinStationTerminate(PWINSTATION pWinStation)
{
    WINSTATION_APIMSG msg;
    LARGE_INTEGER Timeout;
    NTSTATUS Status = 0;
    BOOL AllExited = FALSE;
    BOOL bDoDisconnectFailed = FALSE;
    int i, iLoop;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationTerminate, %S (LogonId=%d)\n",
               pWinStation->WinStationName, pWinStation->LogonId ));


    //
    // Release filtered address
    //
    /*
    if (pWinStation->pRememberedAddress != NULL) {
        Filter_RemoveOutstandingConnection( &pWinStation->pRememberedAddress->addr[0], pWinStation->pRememberedAddress->length );
        MemFree(pWinStation->pRememberedAddress);
        pWinStation->pRememberedAddress = NULL;
        if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
           if (hConnectEvent != NULL)
           {
               SetEvent(hConnectEvent);
           }
        }


    }
    */

    if (pWinStation->fOwnsConsoleTerminal) {
       CopyReconnectInfo(pWinStation, &ConsoleReconnectInfo);

    }


    /*
     * If not already set, mark the WinStation as terminating.
     * This prevents our WinStation Terminate thread from waiting on
     * the initial program or Win32 subsystem processes.
     */
    ENTERCRIT( &WinStationListLock );
    if ( !pWinStation->Terminating ) {
        pWinStation->Terminating = TRUE;
        NtSetEvent( WinStationEvent, NULL );
    }

    if (!(pWinStation->StateFlags & WSF_ST_WINSTATIONTERMINATE)) {
        pWinStation->StateFlags |= WSF_ST_WINSTATIONTERMINATE;
    } else {
        DBGPRINT(("Termsrv: WinstationTerminate: Session %ld has already been terminated \n",pWinStation->LogonId));
        LEAVECRIT( &WinStationListLock );


        return;
    }
    LEAVECRIT( &WinStationListLock );

    /*
     *  If WinStation is idle waiting for a connection, signal connect event
     *  - this will return an error back to winlogon
     */
    if ( pWinStation->ConnectEvent ) {
        NtSetEvent( pWinStation->ConnectEvent, NULL );
    }

    /*
     * Stop any shadowing for this WinStation
     */
    WinStationStopAllShadows( pWinStation );

     /*
     * Tell Win32 to disconnect.
     * This puts up the disconnected desktop among other things.
     */
    if ( ( pWinStation->WinStationName[0] ) &&
         ( !pWinStation->NeverConnected ) &&
         ( !(pWinStation->Flags & WSF_LISTEN) ) &&
         ( !(pWinStation->Flags & WSF_DISCONNECT) ) &&
         ( !(pWinStation->StateFlags & WSF_ST_IN_DISCONNECT )) &&
         ( (pWinStation->StateFlags & WSF_ST_CONNECTED_TO_CSRSS) )  ) {

        msg.ApiNumber = SMWinStationDoDisconnect;
        msg.u.DoDisconnect.ConsoleShadowFlag = FALSE;

        /*
         * Insignia really wants the video driver to be notified before
         * the transport is closed.
         */
        pWinStation->StateFlags |= WSF_ST_IN_DISCONNECT;

        Status = SendWinStationCommand( pWinStation, &msg, 600 );
        

        if (!NT_SUCCESS(Status)) {
           bDoDisconnectFailed = TRUE;
        }else {
                              
            /*
             * Tell csrss to notify winlogon for the disconnect.
             */

            msg.ApiNumber = SMWinStationNotify;
            msg.WaitForReply = FALSE;
            msg.u.DoNotify.NotifyEvent = WinStation_Notify_Disconnect;
            Status = SendWinStationCommand( pWinStation, &msg, 0 );

            pWinStation->StateFlags &= ~WSF_ST_CONNECTED_TO_CSRSS;

        }
    }


    /*
     *  Free Timers
     */
    if ( pWinStation->fIdleTimer ) {
        IcaTimerClose( pWinStation->hIdleTimer );
        pWinStation->fIdleTimer = FALSE;
    }
    if ( pWinStation->fLogonTimer ) {
        IcaTimerClose( pWinStation->hLogonTimer );
        pWinStation->fLogonTimer = FALSE;
    }
    if ( pWinStation->fDisconnectTimer ) {
        IcaTimerClose( pWinStation->hDisconnectTimer );
        pWinStation->fDisconnectTimer = FALSE;
    }

    /*
     *  Free events
     */
    if ((pWinStation->LogonId == 0 || g_bPersonalTS) && pWinStation->hWinmmConsoleAudioEvent) {
        CloseHandle(pWinStation->hWinmmConsoleAudioEvent);
    }

    /*
     * Notify clients of WinStation delete
     *
     * This mimics what happened in 1.6, but the state of the winstation hasn't changed
     * yet and it's still in the list, so it's not "deleted".  Maybe we should add
     * a State_Exiting.  Right now, it's marked down when it loses the LPC connection
     * with the CSR.  Later, it's removed from the list and another WEVENT_DELETE is sent.
     */
    NotifySystemEvent( WEVENT_DELETE );
    
    if (!(pWinStation->Flags & WSF_LISTEN))
    {
        UnlockWinStation(pWinStation);
        RemoveSessionNotification( pWinStation->LogonId, pWinStation->SessionSerialNumber );


        /*
         * WinStationDeleteWorker, deletes the lock, which is always called after WinStationTerminate.
         * therefore we should always succeed in Relock here.
         */
        RTL_VERIFY(RelockWinStation(pWinStation));
    }


    /*
     * Terminate ICA stack
     */

    if ( pWinStation->hStack && (!bDoDisconnectFailed)  ) {
        /*
         * Close the connection endpoint, if any
         */
        if ( pWinStation->pEndpoint ) {

            /*
             * First notify Wsx that connection is going away
             */
            WsxBrokenConnection( pWinStation );



            IcaStackConnectionClose( pWinStation->hStack,
                                     &pWinStation->Config,
                                     pWinStation->pEndpoint,
                                     pWinStation->EndpointLength
                                     );
            MemFree( pWinStation->pEndpoint );
            pWinStation->pEndpoint = NULL;
            pWinStation->EndpointLength = 0;
        }

        IcaStackTerminate( pWinStation->hStack );

    } else{
       pWinStation->StateFlags |= WSF_ST_DELAYED_STACK_TERMINATE;
    }

    /*
     * Flush the Win32 command queue.
     * If the Win32 command list is not empty, then loop through each
     * entry on the list and unlink it and trigger the wait event.
     */
    while ( !IsListEmpty( &pWinStation->Win32CommandHead ) ) {
        PLIST_ENTRY Head;
        PCOMMAND_ENTRY pCommand;

        Head = pWinStation->Win32CommandHead.Flink;
        pCommand = CONTAINING_RECORD( Head, COMMAND_ENTRY, Links );
        RemoveEntryList( &pCommand->Links );
        if ( !pCommand->pMsg->WaitForReply ) {
            ASSERT( pCommand->Event == NULL );
            MemFree( pCommand );
        } else {
            pCommand->Links.Flink = NULL;
            pCommand->pMsg->ReturnedStatus = STATUS_CTX_WINSTATION_BUSY;
            NtSetEvent( pCommand->Event, NULL );
        }
    }

    //
    // close CsrStartEvent
    //
    if (pWinStation->CsrStartEventHandle != NULL)   {
        NtClose(pWinStation->CsrStartEventHandle);
    }

    //
    // close hReconnectReadyEvent
    //
    if (pWinStation->hReconnectReadyEvent != NULL)   {
        NtClose(pWinStation->hReconnectReadyEvent);
    }


    /*
     * Force initial program to exit if it hasn't already
     */
    if ( pWinStation->InitialCommandProcess ) {
        DWORD WaitStatus;

        /*
         * If initial program has already exited, then we can skip this
         */
        WaitStatus = WaitForSingleObject( pWinStation->InitialCommandProcess, 0 );
        if ( WaitStatus != 0 ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Terminating initial command, LogonId=%d\n",
                      pWinStation->LogonId ));

            //
            // if we are asked to terminate winstation that initiated the shutdown
            // there is no point in sending SMWinStationExitWindows to this window, as its
            // winlogons main thread is already busy waiting for this (RpcWinStationShutdownSystem) lpc
            //.
            if (!ShutDownFromSessionID || ShutDownFromSessionID != pWinStation->LogonId)
            {
                 /*
                 * Tell the WinStation to logoff
                 */
                msg.ApiNumber = SMWinStationExitWindows;
                msg.u.ExitWindows.Flags = EWX_LOGOFF | EWX_FORCE;
                Status = SendWinStationCommand( pWinStation, &msg, 10 );
                if ( NT_SUCCESS( Status ) && ( pWinStation->InitialCommandProcess != NULL ) ) {
                    ULONG i;

                
                    if ( ShutDownFromSessionID )
                        Timeout = RtlEnlargedIntegerMultiply( 1, -10000 );
                    else
                        Timeout = RtlEnlargedIntegerMultiply( 2000, -10000 );

                    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Waiting for InitialCommand (ID=0x%x) to exit\n", pWinStation->InitialCommandProcessId ));


                    for ( i = 0; i < gLogoffTimeout; i++ ) {
                    
                        HANDLE CommandHandle = pWinStation->InitialCommandProcess;


                        UnlockWinStation( pWinStation );
                        Status = NtWaitForSingleObject( CommandHandle, FALSE, &Timeout );
                        RelockWinStation( pWinStation );
                        if ( Status == STATUS_SUCCESS )
                            break;

                        TRACE((hTrace,TC_ICASRV,TT_API1,  "." ));

                    }

                    TRACE((hTrace,TC_ICASRV,TT_API1, "\nTERMSRV: Wait for InitialCommand to exit, Status=0x%x\n", Status ));

                    if (Status == STATUS_SUCCESS) {
                        NtClose( pWinStation->InitialCommandProcess );
                        pWinStation->InitialCommandProcess = NULL;
                    }

                }
            }
            else
            {
                // we are not going to have to terminate winlogon for the session that initiated shutdown.
                Status = STATUS_UNSUCCESSFUL;
            }

            /*
             * If unable to connect to the WinStation, then we must use
             * the brute force method - just terminate the initial command.
             */
            if ( ( Status != STATUS_SUCCESS ) && ( pWinStation->InitialCommandProcess != NULL ) ) {

                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Waiting for InitialCommand to terminate\n" ));

                Status = TerminateProcessAndWait( pWinStation->InitialCommandProcessId,
                                                     pWinStation->InitialCommandProcess,
                                                     120 );
                if ( Status != STATUS_SUCCESS ) {
                    DBGPRINT(( "TERMSRV: InitialCommand failed to terminate, Status=%x\n", Status ));

               /*
                * We can fail terminating initial process if it is waiting
                * for a user validation in the Hard Error popup. In this case it is
                * Ok to proceceed as  sending SMWinStationTerminate message bellow
                * will trigger Win32k cleanup code that will dismiss the popup.
                */
                    ASSERT(pWinStation->WindowsSubSysProcess);
                }
            }
        }

        NtClose( pWinStation->InitialCommandProcess );
        pWinStation->InitialCommandProcess = NULL;

    }

    /*
     * Now check to see if there are any remaining processes in
     * the system other than CSRSS with this SessionId.  If so, terminate them now.
     */

    if (ShutDownFromSessionID && ShutDownFromSessionID == pWinStation->LogonId)
        iLoop = 90;
    else
        iLoop = 3;

    for (i = 0 ; i < iLoop; i++) {

        ULONG NumTerminated = 0;
        AllExited = WinStationTerminateProcesses( pWinStation, &NumTerminated );

        /*
         * If we found any processes other than CSRSS that had to be terminated, we
         * have to re-enumerate all the process and make sure that no new processes
         * in this session were created in the windows between the call to NtQuerySystemInformation
         * and terminating all the found processes. If we only find CSRSS we don't have to
         * re-enumerate since CSRSS does not create any processes.
         */
        if (AllExited && (NumTerminated == 0)) {
            break;
        }

        if ((i == (iLoop - 1)) && (AllExited == FALSE)) {
            /*
             * Last iteration and not all processes terminated
             */

//            DbgBreakPoint();
        }

        /*
         * This is a hack to give enough time to processess to terminate
         */

        if (ShutDownFromSessionID && ShutDownFromSessionID == pWinStation->LogonId)
        {
            Sleep(1*1000);
        }
        else
        {
            Sleep(30*1000);
            
        }
    }


    if (pWinStation->WindowsSubSysProcess) {
        /*
         * Send terminate message to this subsystem
         */
        msg.ApiNumber = SMWinStationTerminate;
        /*
         * We used to not wait for this.  However, if the reverse LPC is
         * hung, the CSR is not going to exit anyway and we don't want
         * to silently forget about the WinStation.  (It takes up memory.)
         *
         * Also, if we kill the thread prematurely W32 is never going to exit.
         */
        Status = SendWinStationCommand( pWinStation, &msg, -1 );

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Call to SMWinStationTerminate returned Status=0x%x\n", Status));


        if ((Status != STATUS_SUCCESS) && (Status != STATUS_CTX_CLOSE_PENDING)  ) {
            SetRefLockDeleteProc(&pWinStation->Lock, WinStationZombieProc);
        }

        /*
         * Now check to see if there are any remaining processes in
         * the system other than CSRSS with this SessionId.  If so, terminate them now.
         */

        
        for (i = 0 ; i < 3; i++) {

            ULONG NumTerminated = 0;
            AllExited = WinStationTerminateProcesses( pWinStation, &NumTerminated );

            /*
             * If we found any processes other than CSRSS that had to be terminated, we
             * have to re-enumerate all the process and make sure that no new processes
             * in this session were created in the windows between the call to NtQuerySystemInformation
             * and terminating all the found processes. If we only find CSRSS we don't have to
             * re-enumerate since CSRSS does not create any processes.
             */
            if (AllExited && (NumTerminated == 0)) {
                break;
            }

            if ((i == 2) && (AllExited == FALSE)) {
                /*
                 * Last iteration and not all processes terminated
                 */
    //            DbgBreakPoint();
            }

            /*
             * This is a hack to give enough time to processess to terminate
             */
            Sleep(30*1000);
        }


        /*
         * Force the windows subsystem to exit. Only terminate CSRSS it all other processes
         * have terminated
         */
        if ( AllExited ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: All process exited in Session %d\n",pWinStation->LogonId ));

            /*
             * Wait for the subsystem to exit
             */
            if ( NT_SUCCESS(Status) || ( Status == STATUS_CTX_WINSTATION_BUSY ) || (Status == STATUS_CTX_CLOSE_PENDING ) ) {

                ASSERT(!(pWinStation->Flags & WSF_LISTEN));
//                ENTERCRIT( &WinStationStartCsrLock );
//                Status = SmStopCsr( IcaSmApiPort,
//                                    pWinStation->LogonId );
//                LEAVECRIT( &WinStationStartCsrLock );


//                DBGPRINT(( "TERMSRV:   SmStopCsr on CSRSS for Session=%d returned Status=%x\n",
//                              pWinStation->LogonId, Status ));
//
//                ASSERT(NT_SUCCESS(Status));

//                if (!NT_SUCCESS(Status)) {
//                    DBGPRINT(( "TERMSRV:   SmStopCsr Failed for Session=%d returned Status=%x\n",
//                                                pWinStation->LogonId, Status ));
 //                   DbgBreakPoint();
                //}
                NtClose( pWinStation->WindowsSubSysProcess );
                pWinStation->WindowsSubSysProcess = NULL;
            }
        } else {

            DBGPRINT(("TERMSRV: Did not terminate all the session processes\n"));
            SetRefLockDeleteProc(&pWinStation->Lock, WinStationZombieProc);

        //    DbgBreakPoint();
        }
    }

}

/*******************************************************************************
 *  WinStationTerminateProcesses
 *
 *   Terminate all processes executing on the specified WinStation
 ******************************************************************************/
BOOL WinStationTerminateProcesses(
        PWINSTATION pWinStation,
        ULONG *pNumTerminated)
{
    PCHAR pBuffer;
    ULONG ByteCount;
    NTSTATUS Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    UNICODE_STRING CsrssName;
    UNICODE_STRING NtsdName;
    BOOL retval = TRUE;
    WCHAR ProcessName[MAX_PATH];
    SYSTEM_SESSION_PROCESS_INFORMATION SessionProcessInfo;
    ULONG retlen = 0;

    ByteCount = 32 * 1024;

    *pNumTerminated = 0;

    SessionProcessInfo.SessionId = pWinStation->LogonId;
    
    for ( ; ; ) {
        if ( (pBuffer = MemAlloc( ByteCount )) == NULL )
            return (FALSE);

        SessionProcessInfo.Buffer = pBuffer;
        SessionProcessInfo.SizeOfBuf = ByteCount;

        /*
         *  get process info
         */

        Status = NtQuerySystemInformation(
                        SystemSessionProcessInformation,
                        &SessionProcessInfo,
                        sizeof(SessionProcessInfo),
                        &retlen );

        if ( NT_SUCCESS( Status ) )
            break;

        /*
         *  Make sure buffer is big enough
         */
        MemFree( pBuffer );
        if ( Status != STATUS_INFO_LENGTH_MISMATCH ) 
            return (FALSE);
        ByteCount *= 2;
    }

    if (retlen == 0) {
       MemFree(pBuffer);
       return TRUE;
    }

    RtlInitUnicodeString(&CsrssName,L"CSRSS");


    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;
    for ( ; ; ) {
        HANDLE ProcessHandle;
        CLIENT_ID ClientId;
        OBJECT_ATTRIBUTES ObjA;

        if (RtlPrefixUnicodeString(&CsrssName,&(ProcessInfo->ImageName),TRUE)) {
            if (ProcessInfo->NextEntryOffset == 0)
                break;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                    ((ULONG_PTR)ProcessInfo + ProcessInfo->NextEntryOffset);
            continue;
        }

        RtlInitUnicodeString(&NtsdName,L"ntsd");
        if (! RtlPrefixUnicodeString(&NtsdName,&(ProcessInfo->ImageName),TRUE) ) {
            // If we found any process other than CSRSS and ntsd.exe, bump the
            // the count
            (*pNumTerminated) += 1;
        }

        /*
         * Found a process with a matching LogonId.
         * Attempt to open the process and terminate it.
         */
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: TerminateProcesses, found processid 0x%x for LogonId %d\n",
                   ProcessInfo->UniqueProcessId, ProcessInfo->SessionId ));
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Process Name  %ws for LogonId %d\n",
                   ProcessInfo->ImageName.Buffer, ProcessInfo->SessionId ));

        ClientId.UniqueThread = 0;
        ClientId.UniqueProcess = (HANDLE)ProcessInfo->UniqueProcessId;

        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        Status = NtOpenProcess( &ProcessHandle, PROCESS_ALL_ACCESS,
                                 &ObjA, &ClientId );
        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("TERMSRV: Unable to open processid 0x%x, status=0x%x\n",
                       ProcessInfo->UniqueProcessId, Status ));
            retval = FALSE;
        } else {
            Status = TerminateProcessAndWait( ProcessInfo->UniqueProcessId,
                                             ProcessHandle, 60 );
            NtClose( ProcessHandle );
            if ( Status != STATUS_SUCCESS ) {
                DBGPRINT(("TERMSRV: Unable to terminate processid 0x%x, status=0x%x\n",
                           ProcessInfo->UniqueProcessId, Status ));

                retval = FALSE;
            }
        }

        if ( ProcessInfo->NextEntryOffset == 0 )
            break;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((ULONG_PTR)ProcessInfo + ProcessInfo->NextEntryOffset);
    }

    /*
     *  free buffer
     */
    MemFree( pBuffer );

    return retval;
}


/*******************************************************************************
 *  WinStationDeleteWorker
 *
 *   Delete a WinStation.
 ******************************************************************************/
VOID WinStationDeleteWorker(PWINSTATION pWinStation)
{
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationDeleteWorker, %S (LogonId=%d)\n",
               pWinStation->WinStationName, pWinStation->LogonId ));

    /*
     * If this is the last reference, then
     * Initial program and all subsystems should be terminated by now.
     */
    ENTERCRIT( &WinStationListLock );
    ASSERT( (pWinStation->Links.Flink != NULL) &&  (pWinStation->Links.Blink != NULL));
    RemoveEntryList( &pWinStation->Links );
#if DBG
    pWinStation->Links.Flink = pWinStation->Links.Blink = NULL;
#endif

    if (pWinStation->Lock.RefCount == 1) {
        ASSERT( pWinStation->InitialCommandProcess == NULL );
    }

    // Keep track of total session count for Load Balancing Indicator but don't
    // track listen winstations
    if (!(pWinStation->Flags & WSF_LISTEN))
        WinStationTotalCount--;

    // If we're resetting a disconnected session then adjust LB counter
    if (pWinStation->State == State_Disconnected) {
        WinStationDiscCount--;
    }

    LEAVECRIT( &WinStationListLock );

    /*
     * Unlock WinStation and delete it
     */
    DeleteRefLock( &pWinStation->Lock );

    /*
     * Notify clients of deletion
     */
    NotifySystemEvent( WEVENT_DELETE );
}


/*******************************************************************************
 *  WinStationDeleteProc
 *
 *   Delete the WinStation containing the specified RefLock.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock of WinStation to delete
 ******************************************************************************/
VOID WinStationDeleteProc(PREFLOCK pLock)
{
    PWINSTATION pWinStation;
    ICA_TRACE IcaTrace;
    NTSTATUS Status = STATUS_SUCCESS;

    /* 
     * See if we need to wakeup IdleControlThread to maintain Console session
     */

    if ((USER_SHARED_DATA->ActiveConsoleId == -1) && (gConsoleCreationDisable == 0) ) {
        NtSetEvent(WinStationIdleControlEvent, NULL);
    }


    /*
     * Get a pointer to the containing WinStation
     */
    pWinStation = CONTAINING_RECORD( pLock, WINSTATION, Lock );



    /*
     * Release filtered address
     */

    if (pWinStation->pRememberedAddress != NULL) {
        Filter_RemoveOutstandingConnection( &pWinStation->pRememberedAddress->addr[0], pWinStation->pRememberedAddress->length );
        MemFree(pWinStation->pRememberedAddress);
        pWinStation->pRememberedAddress = NULL;
        if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
           if (hConnectEvent != NULL)
           {
               SetEvent(hConnectEvent);
           }
        }

    }

    /*
     * If this hasn't yet been cleaned up do it now.
     */
    if (pWinStation->ConnectEvent) {
        NtClose( pWinStation->ConnectEvent );
        pWinStation->ConnectEvent = NULL;
    }
    if (pWinStation->CreateEvent) {
        NtClose( pWinStation->CreateEvent );
        pWinStation->CreateEvent = NULL;
    }

    /*
     *  In the case where we timed out disconnecting the session we had
     *  to delay the stack unload till here to avoid situation where Win32k
     *  Display driver believe the session is still connected while the WD
     *  is already unloaded.
     */
    if ( pWinStation->hStack && (pWinStation->StateFlags & WSF_ST_DELAYED_STACK_TERMINATE) ) {
        pWinStation->StateFlags &= ~WSF_ST_DELAYED_STACK_TERMINATE;

        /*
         * Close the connection endpoint, if any
         */
        if ( pWinStation->pEndpoint ) {
            /*
             * First notify Wsx that connection is going away
             */
            WsxBrokenConnection( pWinStation );



            IcaStackConnectionClose( pWinStation->hStack,
                                   &pWinStation->Config,
                                   pWinStation->pEndpoint,
                                   pWinStation->EndpointLength
                                   );
            MemFree( pWinStation->pEndpoint );
            pWinStation->pEndpoint = NULL;
            pWinStation->EndpointLength = 0;
        }

        IcaStackTerminate( pWinStation->hStack );
    }
    
    /* close cdm */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxCdmDisconnect ) {
        pWinStation->pWsx->pWsxCdmDisconnect( pWinStation->pWsxContext,
                                              pWinStation->LogonId,
                                              pWinStation->hIca );
    }

    /*
     * Call WinStation rundown function before killing the stack
     */
    if ( pWinStation->pWsxContext ) {
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxWinStationRundown ) {
            pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
        }
        pWinStation->pWsxContext = NULL;
    }

    /*
     * Close ICA stack and device handles
     */
    if ( pWinStation->hStack ) {
        IcaStackClose( pWinStation->hStack );
        pWinStation->hStack = NULL;
    }

    if ( pWinStation->hIca ) {
        /* close trace */
        memset( &IcaTrace, 0, sizeof(IcaTrace) );
        (void) IcaIoControl( pWinStation->hIca, IOCTL_ICA_SET_TRACE,
                             &IcaTrace, sizeof(IcaTrace), NULL, 0, NULL );

        /* close handle */
        IcaClose( pWinStation->hIca );
        pWinStation->hIca = NULL;
    }

    /*
     * Close various ICA channel handles
     */
    if ( pWinStation->hIcaBeepChannel ) {
        (void) IcaChannelClose( pWinStation->hIcaBeepChannel );
        pWinStation->hIcaBeepChannel = NULL;
    }

    if ( pWinStation->hIcaThinwireChannel ) {
        (void) IcaChannelClose( pWinStation->hIcaThinwireChannel );
        pWinStation->hIcaThinwireChannel = NULL;
    }

    if ( pWinStation->hConnectThread ) {
        NtClose( pWinStation->hConnectThread );
        pWinStation->hConnectThread = NULL;
    }

    /*
     * Free security structures
     */
    WinStationFreeSecurityDescriptor( pWinStation );

    if ( pWinStation->pUserSid ) {
        pWinStation->pProfileSid = pWinStation->pUserSid;
        pWinStation->pUserSid = NULL;
    }

    if (pWinStation->pProfileSid) {
       WinstationUnloadProfile(pWinStation);
       MemFree( pWinStation->pProfileSid );
       pWinStation->pProfileSid = NULL;
    }

    /*
     * Cleanup UserToken
     */
    if ( pWinStation->UserToken ) {
        NtClose( pWinStation->UserToken );
        pWinStation->UserToken = NULL;
    }

    if (pWinStation->LogonId > 0) {
        ENTERCRIT( &WinStationStartCsrLock );
        Status = SmStopCsr( IcaSmApiPort, pWinStation->LogonId );
        LEAVECRIT( &WinStationStartCsrLock );
    }
    
    // Clean up the New Client Credentials struct for Long UserName
    if (pWinStation->pNewClientCredentials != NULL) {
        MemFree(pWinStation->pNewClientCredentials); 
    }

    // Clean up the updated Notification Credentials
    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    /*
     * Cleanup licensing context
     */
    LCDestroyContext(pWinStation);

    TRACE((hTrace,TC_ICASRV,TT_API1,  "TERMSRV:   SmStopCsr on CSRSS for Session=%d returned Status=%x\n", pWinStation->LogonId, Status ));
    ASSERT(NT_SUCCESS(Status));

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(( "TERMSRV:   SmStopCsr Failed for Session=%d returned Status=%x\n", pWinStation->LogonId, Status ));
 //     DbgBreakPoint();

        ENTERCRIT( &WinStationZombieLock );
        InsertTailList( &ZombieListHead, &pWinStation->Links );
        LEAVECRIT( &WinStationZombieLock );
        return;
    }

    /*
     * Zero WinStation name buffer
     */
    RtlZeroMemory( pWinStation->WinStationName, sizeof(pWinStation->WinStationName) );

    MemFree( pWinStation );
}


/*******************************************************************************
 *  WinStationZombieProc
 *
 *   Puts WinStation containing the specified RefLock in the zombie list.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock of WinStation to delete
 ******************************************************************************/
VOID WinStationZombieProc(PREFLOCK pLock)
{
    PWINSTATION pWinStation;

    pWinStation = CONTAINING_RECORD( pLock, WINSTATION, Lock );
    ENTERCRIT( &WinStationZombieLock );
    InsertTailList( &ZombieListHead, &pWinStation->Links );
    LEAVECRIT( &WinStationZombieLock );
}

/*******************************************************************************
 *  CopyReconnectInfo
 *
 *
 * ENTRY:
 ******************************************************************************/
BOOL CopyReconnectInfo(PWINSTATION pWinStation, PRECONNECT_INFO pReconnectInfo)
{
   NTSTATUS Status;

   RtlZeroMemory( pReconnectInfo, sizeof(*pReconnectInfo) );

   /*
    * Save WinStation name and configuration data.
    */
   RtlCopyMemory( pReconnectInfo->WinStationName,
                  pWinStation->WinStationName,
                  sizeof(WINSTATIONNAME) );
   RtlCopyMemory( pReconnectInfo->ListenName,
                  pWinStation->ListenName,
                  sizeof(WINSTATIONNAME) );
   RtlCopyMemory( pReconnectInfo->ProtocolName,
                  pWinStation->ProtocolName,
                  sizeof(pWinStation->ProtocolName) );
   RtlCopyMemory( pReconnectInfo->DisplayDriverName,
                  pWinStation->DisplayDriverName,
                  sizeof(pWinStation->DisplayDriverName) );
   pReconnectInfo->Config = pWinStation->Config;
   pReconnectInfo->Client = pWinStation->Client;

   /*
    * Open a new TS connection to temporarily attach the stack to.
    */
   Status = IcaOpen( &pReconnectInfo->hIca );
   if (Status != STATUS_SUCCESS ) {
      return FALSE;
   }

   Status = IcaStackDisconnect( pWinStation->hStack,
                                pReconnectInfo->hIca,
                                NULL );
   if ( !NT_SUCCESS( Status ) ){
      IcaClose( pReconnectInfo->hIca );
      pReconnectInfo->hIca = NULL;
      return FALSE;
   }

   /*
    * Save stack and endpoint data
    */
   pReconnectInfo->hStack = pWinStation->hStack;
   pReconnectInfo->pEndpoint = pWinStation->pEndpoint;
   pReconnectInfo->EndpointLength = pWinStation->EndpointLength;

   /*
    * Indicate no stack or connection endpoint for this WinStation
    */
   pWinStation->hStack = NULL;
   pWinStation->pEndpoint = NULL;
   pWinStation->EndpointLength = 0;

   /*
    * Reopen a stack for this WinStation
    */
   Status = IcaStackOpen( pWinStation->hIca, Stack_Primary,
           (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack );

   /*
    * Save the licensing stuff to move to other winstation
    */
   if ( pWinStation->pWsx &&
        pWinStation->pWsx->pWsxDuplicateContext ) {
       pReconnectInfo->pWsx = pWinStation->pWsx;
       pWinStation->pWsx->pWsxDuplicateContext( pWinStation->pWsxContext,
               &pReconnectInfo->pWsxContext );
   }

   /*
    * Copy console owner info
    */
   pReconnectInfo->fOwnsConsoleTerminal = pWinStation->fOwnsConsoleTerminal;

   /*
    * Copy the notification Credentials to move to other winstation
    */
   if (pWinStation->pNewNotificationCredentials) {
       pReconnectInfo->pNotificationCredentials = pWinStation->pNewNotificationCredentials;
   } else {
       pReconnectInfo->pNotificationCredentials = NULL;
   }

   return TRUE;

}

VOID
_IncrementPnpEvent( VOID )
{
        HANDLE hPnpMutex = NULL;
        HANDLE hPnpEvent = NULL;
        HANDLE hPnpInfo = NULL;
        typedef struct
        {
            DWORD                       cbSize;
            LONG                        cPnpEvents;
        } *PMMPNPINFO;
        PMMPNPINFO pPnpInfo;

        //
        //  bump the cPnpEvents
        //
        hPnpMutex = OpenMutex( SYNCHRONIZE, FALSE, L"Global\\GuardMutexmmGlobalPnpInfoGuard" );
        if ( hPnpMutex )
        {
            hPnpEvent = OpenEvent(SYNCHRONIZE, FALSE, L"Global\\GuardEventmmGlobalPnpInfoGuard" );
            if ( hPnpEvent )
            {
                //
                //  acquire exclusive ownership on the PnP section
                //
                HANDLE ah[2];
                DWORD dw;

                ah[0] = hPnpEvent; 
                ah[1] = hPnpMutex;
                dw = WaitForMultipleObjects( 2, ah, TRUE, 5000 );
                if ( WAIT_TIMEOUT != dw )
                {
                    hPnpInfo = OpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, L"Global\\mmGlobalPnpInfo" );
                    if (hPnpInfo) {
                        pPnpInfo = (PMMPNPINFO)MapViewOfFile(hPnpInfo, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
                        if (pPnpInfo) {
                            pPnpInfo->cPnpEvents ++;
                            UnmapViewOfFile( pPnpInfo );
                        } else {
                            DBGPRINT(( "Can't map PnP section: %d\n", GetLastError()));
                        }
                        CloseHandle(hPnpInfo);
                    } else {
                        DBGPRINT(( "Can't open PnP section: %d\n", GetLastError()));
                    }

                    ReleaseMutex( hPnpMutex );
                } else {
                    DBGPRINT(( "Timed out to open mmGlobalPnpInfo" ));
                }
                CloseHandle( hPnpEvent );
            } else {
                DBGPRINT(( "Can't open PnP event: %d\n", GetLastError()));
            }

            CloseHandle( hPnpMutex );
        } else {
            DBGPRINT(( "Can't open PnP mutex: %d\n", GetLastError()));
        }

}

/*******************************************************************************
 *  WinStationDoDisconnect
 *
 *   Send disconnect message to a WinStation and optionally close connection
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to disconnect
 *    pReconnectInfo (input) OPTIONAL
 *       Pointer to RECONNECT_INFO buffer
 *       If NULL, this is a terminate disconnect.
 *
 * EXIT:
 *    STATUS_SUCCESS                - if successful
 *    STATUS_CTX_WINSTATION_BUSY    - if session is already disconnected, or busy
 ******************************************************************************/
NTSTATUS WinStationDoDisconnect(
        PWINSTATION pWinStation,
        PRECONNECT_INFO pReconnectInfo,
        BOOLEAN bSyncNotify)
{
    WINSTATION_APIMSG DisconnectMsg;
    NTSTATUS Status;
    ULONG ulTimeout;
    BOOLEAN fOwnsConsoleTerminal = pWinStation->fOwnsConsoleTerminal;
    FILETIME DiscTime;
    DWORD SessionID;
    BOOLEAN bInformSessionDirectory = FALSE;
    TS_AUTORECONNECTINFO SCAutoReconnectInfo;
    ULONG BytesGot;


    // We need to prevent from WinStationDoDisconnect being called twice
    if ( pWinStation->State == State_Disconnected || pWinStation->StateFlags & WSF_ST_IN_DISCONNECT)
    {
        // The session is already disconnected.
        // BUBUG a specific error code STATUS_CTX_SESSION_DICONNECTED would be better.
        return (STATUS_CTX_WINSTATION_BUSY);
    }
    pWinStation->StateFlags |=  WSF_ST_IN_DISCONNECT;

    /*
     *  Start disconnect timer if enabled
     */
    if ( ulTimeout = pWinStation->Config.Config.User.MaxDisconnectionTime ) {
        if ( !pWinStation->fDisconnectTimer ) {
            Status = IcaTimerCreate( 0, &pWinStation->hDisconnectTimer );
            if ( NT_SUCCESS( Status ) )
                pWinStation->fDisconnectTimer = TRUE;
            else
                DBGPRINT(("xxxWinStationDisconnect - failed to create timer \n"));
        }
        if ( pWinStation->fDisconnectTimer )
            IcaTimerStart( pWinStation->hDisconnectTimer, DisconnectTimeout,
                           LongToPtr( pWinStation->LogonId ), ulTimeout );
    }

    /*
     * Stop any shadowing for this WinStation
     */
    WinStationStopAllShadows( pWinStation );

    /*
     * Tell Win32k about the disconnect
     */
    if (pWinStation->StateFlags & WSF_ST_CONNECTED_TO_CSRSS) {
        DisconnectMsg.ApiNumber = SMWinStationDoDisconnect;
        DisconnectMsg.u.DoDisconnect.ConsoleShadowFlag = FALSE;

        Status = SendWinStationCommand( pWinStation, &DisconnectMsg, 600 );
        if ( !NT_SUCCESS(Status) ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: CSR DoDisconnect failed LogonId=%d Status=0x%x\n",
                       pWinStation->LogonId, Status ));
            goto badwin32disconnect;
        } else {

            ULONG WaitTime = 0;

            /*
             * Tell csrss to notify winlogon for the disconnect.
             */
            if (pWinStation->UserName[0] != L'\0') {
               DisconnectMsg.WaitForReply = TRUE;
               WaitTime = 10;
            } else {
               DisconnectMsg.WaitForReply = FALSE;
            }
            DisconnectMsg.ApiNumber = SMWinStationNotify;
            if (bSyncNotify) {
               DisconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_SyncDisconnect;
            } else {
                DisconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_Disconnect;
            }
            Status = SendWinStationCommand( pWinStation, &DisconnectMsg, WaitTime );

            pWinStation->StateFlags &= ~WSF_ST_CONNECTED_TO_CSRSS;
            pWinStation->fOwnsConsoleTerminal = FALSE;
        }
    }

    /*
     * close cdm
     */
    if ( pWinStation->pWsx && pWinStation->pWsx->pWsxCdmDisconnect ) {
        pWinStation->pWsx->pWsxCdmDisconnect( pWinStation->pWsxContext,
                                              pWinStation->LogonId,
                                              pWinStation->hIca );
    }

    /*
     * If a reconnect info struct has been specified, then this is NOT
     * a terminate disconnect.  Save the current WinStation name,
     * WinStation and client configuration info, and license data.
     * Also disconnect the current stack and save the stack handle
     * and connection endpoint data.
     */
    if ( pReconnectInfo || fOwnsConsoleTerminal) {


        if ((pReconnectInfo == NULL) && fOwnsConsoleTerminal) {
            pReconnectInfo = &ConsoleReconnectInfo;
            if (ConsoleReconnectInfo.hIca) {
               CleanupReconnect(&ConsoleReconnectInfo);
               RtlZeroMemory(&ConsoleReconnectInfo,sizeof(RECONNECT_INFO));
            }
        }

        if (!CopyReconnectInfo(pWinStation, pReconnectInfo))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto badstackopen;

        }
        
        /*
         * Copy console owner info
         */
        pReconnectInfo->fOwnsConsoleTerminal = fOwnsConsoleTerminal;


   /*
    * This is a terminate disconnect.
    * If there is a connection endpoint, then close it now.
    */
    } else if (pWinStation->pEndpoint ) {

        /*
         *  First grab any autoreconnect info state and save it
         *  in the winstation
         */

        TRACE((hTrace,TC_ICASRV,TT_API1,
               "TERMSRV: Disconnecting - grabbing SC autoreconnect from stack\n"));

        if (pWinStation->pWsx &&
            pWinStation->pWsx->pWsxEscape) {

            Status = pWinStation->pWsx->pWsxEscape(
                        pWinStation->pWsxContext,
                        GET_SC_AUTORECONNECT_INFO,
                        NULL,
                        0,
                        &SCAutoReconnectInfo,
                        sizeof(SCAutoReconnectInfo),
                        &BytesGot);

            if (NT_SUCCESS(Status)) {

                // 
                // Valid the length of the SC info and save it into the winstation
                // this will be used later on. We need to grab the info now
                // before the stack handle is closed as we won't be able to IOCTL
                // down to the stack at autoreconnect time.
                //

                if (SCAutoReconnectInfo.cbAutoReconnectInfo ==
                    sizeof(pWinStation->AutoReconnectInfo.ArcRandomBits)) {

                    TRACE((hTrace,TC_ICASRV,TT_API1,
                           "TERMSRV: Disconnecting - got SC ARC from stack\n"));

                    pWinStation->AutoReconnectInfo.Valid = TRUE;
                    memcpy(&pWinStation->AutoReconnectInfo.ArcRandomBits,
                           &SCAutoReconnectInfo.AutoReconnectInfo,
                           sizeof(pWinStation->AutoReconnectInfo.ArcRandomBits));
                }
                else {
                    TRACE((hTrace,TC_ICASRV,TT_ERROR,
                           "TERMSRV: Disconnecting - got invalid len SC ARC from stack\n"));
                    ResetAutoReconnectInfo(pWinStation);
                }
            }
            else {

                TRACE((hTrace,TC_ICASRV,TT_API1,
                       "TERMSRV: Disconnecting - did not get SC ARC from stack\n"));
                ResetAutoReconnectInfo(pWinStation);
            }
        }

        /*
         * First notify Wsx that connection is going away
         */
        WsxBrokenConnection( pWinStation );




        if (pWinStation->hStack != NULL) {
            Status = IcaStackConnectionClose( pWinStation->hStack,
                                              &pWinStation->Config,
                                              pWinStation->pEndpoint,
                                              pWinStation->EndpointLength );
            ASSERT( NT_SUCCESS(Status) );
            if ( !NT_SUCCESS(Status) ) {
                TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: StackConnectionClose failed LogonId=%d Status=0x%x\n",
                       pWinStation->LogonId, Status ));
            }
        }

        MemFree( pWinStation->pEndpoint );
        pWinStation->pEndpoint = NULL;
        pWinStation->EndpointLength = 0;

        /*
         * Close the stack and reopen it.
         * What we really need is a function to unload the stack drivers
         * but leave the stack handle open.
         */

        if (pWinStation->hStack != NULL) {
            Status = IcaStackClose( pWinStation->hStack );
            ASSERT( NT_SUCCESS( Status ) );
        }

        Status = IcaStackOpen( pWinStation->hIca, Stack_Primary,
                               (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack );

        /*
         * Since this is a terminate disconnect, clear all client
         * license data and indicate it no longer holds a license.
         */
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxClearContext ) {
            pWinStation->pWsx->pWsxClearContext( pWinStation->pWsxContext );
        }
        /*
         * Session 0, we want to get rid of any protocol extension so that next remote
         * connection could happen with a different protocol.
         */
        if (pWinStation->LogonId == 0 ) {
            if ( pWinStation->pWsxContext ) {
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxWinStationRundown ) {
                    pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
                }
                pWinStation->pWsxContext = NULL;
            }
            pWinStation->pWsx = NULL;
        }
    }

    /*
     *  Cancel timers
     */
    if ( pWinStation->fIdleTimer ) {
        pWinStation->fIdleTimer = FALSE;
        IcaTimerClose( pWinStation->hIdleTimer );
    }
    if ( pWinStation->fLogonTimer ) {
        pWinStation->fLogonTimer = FALSE;
        IcaTimerClose( pWinStation->hLogonTimer );
    }

    // Send Audit Information only for actual disconnects 
    if (pWinStation->UserName && (wcslen(pWinStation->UserName) > 0)) {
        AuditEvent( pWinStation, SE_AUDITID_SESSION_DISCONNECTED );
    }


    {
        ENTERCRIT( &WinStationListLock );
        (VOID) NtQuerySystemTime( &pWinStation->DisconnectTime );

        if ((pWinStation->State == State_Active) || (pWinStation->State == 
                State_Shadow)) {
            // If the session was active or in a shadow state and is being
            // disconnected...
            //
            // Copy off the session ID and disconnection FileTime for the
            // session directory call below. We do not want to hold locks when
            // calling the directory interface.
            memcpy(&DiscTime, &pWinStation->DisconnectTime, sizeof(DiscTime));
            SessionID = pWinStation->LogonId;

            // Set flag that we need to notify the session directory.
            bInformSessionDirectory = TRUE;
        }
        
        pWinStation->State = State_Disconnected;
        RtlZeroMemory( pWinStation->WinStationName,
                       sizeof(pWinStation->WinStationName) );
        RtlZeroMemory( pWinStation->ListenName,
                       sizeof(pWinStation->ListenName) );

        // Keep track of disconnected session count for Load Balancing 
        // Indicator.
        WinStationDiscCount++;

        LEAVECRIT( &WinStationListLock );

        NotifySystemEvent( WEVENT_DISCONNECT | WEVENT_STATECHANGE );
    }

    // Call the session directory to inform of the disconnection.
    if (!g_bPersonalTS && g_fAppCompat && bInformSessionDirectory)
        SessDirNotifyDisconnection(SessionID, DiscTime);

    TRACE((hTrace, TC_ICASRV, TT_API1, 
            "TERMSRV: WinStationDoDisconnect, rc=0x0\n" ));

    Status = NotifyDisconnect(pWinStation, fOwnsConsoleTerminal);
    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(("NotifyConsoleDisconnect failed, SessionId = %d, Status = "
                "%d", pWinStation->LogonId, Status));
    }
    pWinStation->StateFlags &=  ~WSF_ST_IN_DISCONNECT;

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

badstackopen:
badwin32disconnect:
    TRACE((hTrace, TC_ICASRV, TT_API1, "TERMSRV: WinStationDoDisconnect, rc=0x%x\n", Status ));
    pWinStation->StateFlags &=  ~WSF_ST_IN_DISCONNECT;
    
    return Status;
}


/*******************************************************************************
 * ImperonateClient
 *
 *   Giving a client primary, make the calling thread impersonate the client
 *
 * ENTRY:
 *    ClientToken (input)
 *       A client primary token
 *    pImpersonationToken (output)
 *       Pointer to an impersonation token
 ******************************************************************************/
NTSTATUS _ImpersonateClient(HANDLE ClientToken, HANDLE *pImpersonationToken)
{
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;

    //
    // ClientToken is a primary token - create an impersonation token
    // version of it so we can set it on our thread
    //
    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;

    Status = NtDuplicateToken( ClientToken,
                               TOKEN_IMPERSONATE,
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               pImpersonationToken );
    if ( !NT_SUCCESS( Status ) )
    {
        TRACE( ( hTrace, TC_ICASRV, TT_ERROR, "ImpersonateClient: cannot get impersonation token: 0x%x\n", Status ) );
        return( Status );
    }

    //
    // Impersonate the client
    //
    Status = NtSetInformationThread( NtCurrentThread(),
                                     ThreadImpersonationToken,
                                     ( PVOID )pImpersonationToken,
                                     ( ULONG )sizeof( HANDLE ) );
    if ( !NT_SUCCESS( Status ) )
    {
        TRACE( ( hTrace, TC_ICASRV, TT_ERROR, "ImpersonateClient: cannot impersonate client: 0x%x\n", Status ) );
    }

    return Status;
}

/*******************************************************************************
 *  WinStationDoReconnect
 *
 *   Send connect Api message to a WinStation.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to connect
 *    pReconnectInfo (input)
 *       Pointer to RECONNECT_INFO buffer
 ******************************************************************************/
NTSTATUS WinStationDoReconnect(
        PWINSTATION pWinStation,
        PRECONNECT_INFO pReconnectInfo)
{
    WINSTATION_APIMSG ReconnectMsg;
    NTSTATUS Status;
    BOOLEAN fDisableCdm;
    BOOLEAN fDisableCpm;
    BOOLEAN fDisableLPT;
    BOOLEAN fDisableCcm;
    BOOLEAN fDisableClip;
    NTSTATUS TempStatus;
    PWINSTATIONCONFIG2 pCurConfig = NULL;
    PWINSTATIONCLIENT pCurClient = NULL;

    // WinStation should not currently be connected
    ASSERT( pWinStation->pEndpoint == NULL );

    //
    // Allocate and initialize CurConfig struct
    //

    if ( (pCurConfig = MemAlloc( sizeof(WINSTATIONCONFIG2) )) == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto nomem;
    }
    RtlZeroMemory( pCurConfig, sizeof(WINSTATIONCONFIG2) ); 

    //
    // Allocate and initialize CurClient struct
    //
    if ( (pCurClient = MemAlloc( sizeof(WINSTATIONCLIENT) )) == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto nomem;
    }
    RtlZeroMemory( pCurClient, sizeof(WINSTATIONCLIENT) ); 

    //
    // Config info has to be set prior to calling CSRSS. CSRSS notifies winlogon
    // which in turn sends reconnect messages to notification dlls. We query 
    // protocol info from termsrv notification dll which is stored in config
    // data
    //
    *pCurConfig = pWinStation->Config; 
    pWinStation->Config = pReconnectInfo->Config;

    *pCurClient = pWinStation->Client;
    pWinStation->Client = pReconnectInfo->Client;

    if ((pWinStation->LogonId == 0) && (pWinStation->UserName[0] == L'\0')) {
       ReconnectMsg.ApiNumber = SMWinStationNotify;
       ReconnectMsg.WaitForReply = TRUE;
       ReconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_PreReconnect;
       Status = SendWinStationCommand( pWinStation, &ReconnectMsg, 60 );
    }

    /*
     * Unconditionally, we will send the PreReconnectDesktopSwitch event.
     */
    ReconnectMsg.ApiNumber = SMWinStationNotify;
    ReconnectMsg.WaitForReply = TRUE;
    ReconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_PreReconnectDesktopSwitch;
    Status = SendWinStationCommand( pWinStation, &ReconnectMsg, 60 );

    /*
     * Close the current stack and reconnect the saved stack to this WinStation
     */
    if (pWinStation->hStack != NULL) {
        IcaStackClose( pWinStation->hStack );
        pWinStation->hStack = NULL;
    }

    Status = IcaStackReconnect( pReconnectInfo->hStack,
                                pWinStation->hIca,
                                pWinStation,
                                pWinStation->LogonId );
    if ( !NT_SUCCESS( Status ) ){
        pWinStation->Config = *pCurConfig;
        pWinStation->Client = *pCurClient;
        goto badstackreconnect;
    }

    /*
     * Save stack and endpoint data
     */
    pWinStation->hStack = pReconnectInfo->hStack;
    pWinStation->pEndpoint = pReconnectInfo->pEndpoint;
    pWinStation->EndpointLength = pReconnectInfo->EndpointLength;

    /* 
     * Save the notification Credentials in the new winstation
     */
    if (pReconnectInfo->pNotificationCredentials) {

        if (pWinStation->pNewNotificationCredentials == NULL) {
            pWinStation->pNewNotificationCredentials = MemAlloc(sizeof(CLIENTNOTIFICATIONCREDENTIALS)); 
            if (pWinStation->pNewNotificationCredentials == NULL) {
                Status = STATUS_NO_MEMORY ; 
                goto nomem ; 
            }
        }

        RtlCopyMemory( pWinStation->pNewNotificationCredentials->Domain,
                       pReconnectInfo->pNotificationCredentials->Domain,
                       sizeof(pReconnectInfo->pNotificationCredentials->Domain) );

        RtlCopyMemory( pWinStation->pNewNotificationCredentials->UserName,
                       pReconnectInfo->pNotificationCredentials->UserName,
                       sizeof(pReconnectInfo->pNotificationCredentials->UserName) );

    } else {
        pWinStation->pNewNotificationCredentials = NULL; 
    }

    pReconnectInfo->hStack = NULL;
    pReconnectInfo->pEndpoint = NULL;
    pReconnectInfo->EndpointLength = 0;
    pReconnectInfo->pNotificationCredentials = NULL;

    /*
     * Tell Win32k about the reconnect
     */
    ReconnectMsg.ApiNumber = SMWinStationDoReconnect;
    ReconnectMsg.u.DoReconnect.fMouse = (BOOLEAN)pReconnectInfo->Client.fMouse;
    ReconnectMsg.u.DoReconnect.fClientDoubleClickSupport =
                (BOOLEAN)pReconnectInfo->Client.fDoubleClickDetect;
    ReconnectMsg.u.DoReconnect.fEnableWindowsKey =
                (BOOLEAN)pReconnectInfo->Client.fEnableWindowsKey;
    RtlCopyMemory( ReconnectMsg.u.DoReconnect.WinStationName,
                   pReconnectInfo->WinStationName,
                   sizeof(WINSTATIONNAME) );
    RtlCopyMemory( ReconnectMsg.u.DoReconnect.AudioDriverName,
                   pReconnectInfo->Client.AudioDriverName,
                   sizeof( ReconnectMsg.u.DoReconnect.AudioDriverName ) );
    RtlCopyMemory( ReconnectMsg.u.DoReconnect.DisplayDriverName,
                   pReconnectInfo->DisplayDriverName,
                   sizeof( ReconnectMsg.u.DoReconnect.DisplayDriverName ) );
    RtlCopyMemory( ReconnectMsg.u.DoReconnect.ProtocolName,
                   pReconnectInfo->ProtocolName,
                   sizeof( ReconnectMsg.u.DoReconnect.ProtocolName ) );

    /*
     * Set the display resolution information in the message for reconnection
     */
    ReconnectMsg.u.DoReconnect.HRes = pReconnectInfo->Client.HRes;
    ReconnectMsg.u.DoReconnect.VRes = pReconnectInfo->Client.VRes;
    ReconnectMsg.u.DoReconnect.ProtocolType = pReconnectInfo->Client.ProtocolType;
    ReconnectMsg.u.DoReconnect.fDynamicReconnect  = (BOOLEAN)(pWinStation->Config.Wd.WdFlag & WDF_DYNAMIC_RECONNECT );

    /*
     * Translate the color to the format excpected in winsrv
     */
    switch (pReconnectInfo->Client.ColorDepth) {
        case 1:
            ReconnectMsg.u.DoReconnect.ColorDepth=4 ; // 16 colors
            break;
        case 2:
            ReconnectMsg.u.DoReconnect.ColorDepth=8 ; // 256
            break;
        case 4:
            ReconnectMsg.u.DoReconnect.ColorDepth= 16;// 64K
            break;
        case 8:
            ReconnectMsg.u.DoReconnect.ColorDepth= 24;// 16M
            break;
#define DC_HICOLOR
#ifdef DC_HICOLOR
        case 16:
            ReconnectMsg.u.DoReconnect.ColorDepth= 15;// 32K
            break;
#endif
        default:
            ReconnectMsg.u.DoReconnect.ColorDepth=8 ;
            break;
    }

    ReconnectMsg.u.DoReconnect.KeyboardType        = pWinStation->Client.KeyboardType;
    ReconnectMsg.u.DoReconnect.KeyboardSubType     = pWinStation->Client.KeyboardSubType;
    ReconnectMsg.u.DoReconnect.KeyboardFunctionKey = pWinStation->Client.KeyboardFunctionKey;

    if (pWinStation->LogonId == 0 || g_bPersonalTS) {
        if (pWinStation->hWinmmConsoleAudioEvent) {
            if (pWinStation->Client.fRemoteConsoleAudio) {
                // set the remoting audio on console flag
                SetEvent(pWinStation->hWinmmConsoleAudioEvent);

            }
            else {
                // don't set the remoting audio on console flag
                ResetEvent(pWinStation->hWinmmConsoleAudioEvent);
            }
            _IncrementPnpEvent();
        }        
    }


    if (WaitForSingleObject(pWinStation->hReconnectReadyEvent, 45*1000) != WAIT_OBJECT_0) {
    
       DbgPrint("Wait Failed for hReconnectReadyEvent for Session %d\n", pWinStation->LogonId);
       SetEvent(pWinStation->hReconnectReadyEvent);
    }

    Status = SendWinStationCommand( pWinStation, &ReconnectMsg, 600 );
    if ( !NT_SUCCESS(Status) ) {

        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: CSR DoReconnect failed LogonId=%d Status=0x%x\n",
               pWinStation->LogonId, Status ));
        pWinStation->Config = *pCurConfig;
        pWinStation->Client = *pCurClient;
        goto badreconnect;
    } else {
        pWinStation->StateFlags |= WSF_ST_CONNECTED_TO_CSRSS;
    }

    //
    // Update protocol and display driver names.
    //
    RtlCopyMemory( pWinStation->ProtocolName,
                   pReconnectInfo->ProtocolName,
                   sizeof(pWinStation->ProtocolName) );
    RtlCopyMemory( pWinStation->DisplayDriverName,
                   pReconnectInfo->DisplayDriverName,
                   sizeof(pWinStation->DisplayDriverName) );
    
    //
    // Set session time zone information.
    //
#ifdef TERMSRV_USE_CLIENT_TIME_ZONE
    {
        WINSTATION_APIMSG TimezoneMsg;

        memset( &TimezoneMsg, 0, sizeof(TimezoneMsg) );
        TimezoneMsg.ApiNumber = SMWinStationSetTimeZone;
        memcpy(&(TimezoneMsg.u.SetTimeZone.TimeZone),&(pReconnectInfo->Client.ClientTimeZone),
                    sizeof(TS_TIME_ZONE_INFORMATION));
        SendWinStationCommand( pWinStation, &TimezoneMsg, 600 );
    }
#endif

    /*
     * Copy console owner info
     */
    pWinStation->fOwnsConsoleTerminal = pReconnectInfo->fOwnsConsoleTerminal;
    
    /*
     * Close temporary ICA connection that was opened for the reconnect
     */
    IcaClose( pReconnectInfo->hIca );
    pReconnectInfo->hIca = NULL;

    /*
     * Move all of the licensing stuff to the new WinStation
     */

    /*
     * we may not have pWsx if the ReconnectInfo is from a session
     * that was connected to the local console
     */
    if ( pReconnectInfo->pWsxContext ) {
        if ( pWinStation->pWsx == NULL ) {
            //
            // This means that we are reconnecting remotely to a session
            // that comes from the console. So create a new extension.
            //
            pWinStation->pWsx = FindWinStationExtensionDll(
                            pWinStation->Config.Wd.WsxDLL,
                            pWinStation->Config.Wd.WdFlag );

            //
            //  Initialize winstation extension context structure
            //
            if ( pWinStation->pWsx &&
                 pWinStation->pWsx->pWsxWinStationInitialize ) {
                Status = pWinStation->pWsx->pWsxWinStationInitialize( 
                        &pWinStation->pWsxContext);

                if (!NT_SUCCESS(Status)) {
                    pWinStation->pWsx = NULL;
                }
            }

            if ( pWinStation->pWsx &&
                 pWinStation->pWsx->pWsxWinStationReInitialize ) {
                WSX_INFO WsxInfo;

                WsxInfo.Version = WSX_INFO_VERSION_1;
                WsxInfo.hIca = pWinStation->hIca;
                WsxInfo.hStack = pWinStation->hStack;
                WsxInfo.SessionId = pWinStation->LogonId;
                WsxInfo.pDomain = pWinStation->Domain;
                WsxInfo.pUserName = pWinStation->UserName;

                Status = pWinStation->pWsx->pWsxWinStationReInitialize( 
                        pWinStation->pWsxContext, &WsxInfo );

                if (!NT_SUCCESS(Status)) {
                    pWinStation->pWsx = NULL;
                }
            }                    
        }

        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxCopyContext ) {
            pWinStation->pWsx->pWsxCopyContext( pWinStation->pWsxContext,
                                                pReconnectInfo->pWsxContext );
        }
        if ( pReconnectInfo->pWsx &&
             pReconnectInfo->pWsx->pWsxWinStationRundown ) {
            pReconnectInfo->pWsx->pWsxWinStationRundown( pReconnectInfo->pWsxContext );
        }
        pReconnectInfo->pWsxContext = NULL;

    } else { // pReconnectInfo->pWsxContext == NULL
        //
        // This means that we are reconnecting to the console.
        //
        if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxWinStationRundown ) {
            //
            // Reconnecting a remote session to the console.
            // Delete the extension.
            //
            pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
        }
        pWinStation->pWsxContext = NULL;
        pWinStation->pWsx = NULL;

        //
        // In the case where both are NULL, we are reconnecting 
        // to the console a session that comes from the console.
        //
    }

    RtlEnterCriticalSection( &WinStationListLock );
    if (pWinStation->UserName[0] != (WCHAR) 0) {
        pWinStation->State = State_Active;
    } else {
        pWinStation->State = State_Connected;
    }
    RtlCopyMemory( pWinStation->WinStationName,
                   pReconnectInfo->WinStationName,
                   sizeof(WINSTATIONNAME) );

    /*
     * Copy the original listen name for instance checking.
     */
    RtlCopyMemory( pWinStation->ListenName,
                   pReconnectInfo->ListenName,
                   sizeof(WINSTATIONNAME) );

    // Keep track of disconnected session count for Load Balancing Indicator
    WinStationDiscCount--;

    RtlLeaveCriticalSection( &WinStationListLock );

    /*
     * Disable virtual channel flags are from the transport setup.
     * Do not overwrite them.
     */
    fDisableCdm = (BOOLEAN) pWinStation->Config.Config.User.fDisableCdm;
    fDisableCpm = (BOOLEAN) pWinStation->Config.Config.User.fDisableCpm;
    fDisableLPT = (BOOLEAN) pWinStation->Config.Config.User.fDisableLPT;
    fDisableCcm = (BOOLEAN) pWinStation->Config.Config.User.fDisableCcm;
    fDisableClip = (BOOLEAN) pWinStation->Config.Config.User.fDisableClip;

    pWinStation->Config = pReconnectInfo->Config;

    pWinStation->Config.Config.User.fDisableCdm = fDisableCdm;
    pWinStation->Config.Config.User.fDisableCpm = fDisableCpm;
    pWinStation->Config.Config.User.fDisableLPT = fDisableLPT;
    pWinStation->Config.Config.User.fDisableCcm = fDisableCcm;
    pWinStation->Config.Config.User.fDisableClip = fDisableClip;

    /*
     * Disable virtual channels if needed.
     */
    VirtualChannelSecurity( pWinStation );
    
    /*
     * Notify the CDM channel of reconnection.
     */
    
    if ( pWinStation->pWsx &&
            pWinStation->pWsx->pWsxCdmConnect ) {
        (VOID) pWinStation->pWsx->pWsxCdmConnect( pWinStation->pWsxContext,
                                                      pWinStation->LogonId,
                                                      pWinStation->hIca );
    }

    /*
     * Reset any autoreconnect information prior to reconnection
     * as it is stale. New information will be generated by the stack
     * when login completes.
     */
    ResetAutoReconnectInfo(pWinStation);

    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxLogonNotify ) {

        PWCHAR pUserNameToSend, pDomainToSend ;
        
        // Use the New notification credentials sent from Gina for the call below if they are available
        if (pWinStation->pNewNotificationCredentials) {
            pUserNameToSend = pWinStation->pNewNotificationCredentials->UserName;
            pDomainToSend = pWinStation->pNewNotificationCredentials->Domain;
        } else {
            pUserNameToSend = pWinStation->UserName;
            pDomainToSend = pWinStation->Domain ;
        }
        
        Status = pWinStation->pWsx->pWsxLogonNotify( pWinStation->pWsxContext,
                                                   pWinStation->LogonId,
                                                   NULL,
                                                   pDomainToSend,
                                                   pUserNameToSend);

        if (pWinStation->pNewNotificationCredentials != NULL) {
            MemFree(pWinStation->pNewNotificationCredentials);
            pWinStation->pNewNotificationCredentials = NULL;
        }

        if(!NT_SUCCESS(Status)) {
            TRACE((hTrace, TC_ICASRV, TT_API1,
                   "TERMSRV: WinStationDoReconnect: LogonNotify rc=0x%x\n",
                   Status ));
        }
    }

    NotifySystemEvent( WEVENT_CONNECT | WEVENT_STATECHANGE );

    /*
     * Cleanup any allocated buffers.
     * The endpoint buffer was transfered to the WinStation above.
     */
    pReconnectInfo->pEndpoint = NULL;
    pReconnectInfo->EndpointLength = 0;

    /*
     * Set connect time and stop disconnect timer
     */
    NtQuerySystemTime(&pWinStation->ConnectTime);
    if (pWinStation->fDisconnectTimer) {
        pWinStation->fDisconnectTimer = FALSE;
        IcaTimerClose( pWinStation->hDisconnectTimer );
    }

    /*
     *  Start logon timers
     */
    StartLogonTimers(pWinStation);

    // Notify the session directory of the reconnection.
    if (!g_bPersonalTS && g_fAppCompat) {
        TSSD_ReconnectSessionInfo ReconnInfo;

        ReconnInfo.SessionID = pWinStation->LogonId;
        ReconnInfo.TSProtocol = pWinStation->Client.ProtocolType;
        ReconnInfo.ResolutionWidth = pWinStation->Client.HRes;
        ReconnInfo.ResolutionHeight = pWinStation->Client.VRes;
        ReconnInfo.ColorDepth = pWinStation->Client.ColorDepth;
        SessDirNotifyReconnection(&ReconnInfo);
    }

    TRACE((hTrace, TC_ICASRV, TT_API1, "TERMSRV: WinStationDoReconnect, rc=0x0\n" ));
    
    AuditEvent( pWinStation, SE_AUDITID_SESSION_RECONNECTED );

    /*
     * Tell csrss to notify winlogon for the reconnect then notify any process
     * that registred for notification.
     */

    ReconnectMsg.ApiNumber = SMWinStationNotify;
    ReconnectMsg.WaitForReply = FALSE;
    ReconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_Reconnect;
    Status = SendWinStationCommand( pWinStation, &ReconnectMsg, 0 );

    Status = NotifyConnect(pWinStation, pWinStation->fOwnsConsoleTerminal);
    if ( !NT_SUCCESS(Status) ) {
            DBGPRINT(("NotifyConsoleConnect failed, SessionId = %d, Status = %d", pWinStation->LogonId, Status));
    }

    // Free up allocated Memory
    if (pCurConfig != NULL) {
        MemFree( pCurConfig );
        pCurConfig = NULL; 
    }
    if (pCurClient != NULL) {
        MemFree( pCurClient ); 
        pCurClient = NULL;
    }

    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    // Since the winstation has reconnected, we can allow further autoreconnects
    pWinStation->fDisallowAutoReconnect = FALSE;

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * Failure from Win32 reconnect call.
     * Disconnect the stack again, and indicate the WinStation
     * does not have a stack or endpoint connection.
     */
badreconnect:
    TempStatus = IcaStackDisconnect( pWinStation->hStack,
                                     pReconnectInfo->hIca,
                                     NULL );
    //ASSERT( NT_SUCCESS( TempStatus ) );

    pReconnectInfo->hStack = pWinStation->hStack;
    pReconnectInfo->pEndpoint = pWinStation->pEndpoint;
    pReconnectInfo->EndpointLength = pWinStation->EndpointLength;
    pWinStation->hStack = NULL;
    pWinStation->pEndpoint = NULL;
    pWinStation->EndpointLength = 0;

badstackreconnect:
    TempStatus = IcaStackOpen( pWinStation->hIca, Stack_Primary,
                               (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack );
    //ASSERT( NT_SUCCESS( TempStatus ) ); // don't know how to handle any error here

nomem:
    // Free up allocated Memory
    if (pCurConfig != NULL) {
        MemFree( pCurConfig );
        pCurConfig = NULL; 
    }
    if (pCurClient != NULL) {
        MemFree( pCurClient ); 
        pCurClient = NULL;
    }

    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    TRACE((hTrace, TC_ICASRV, TT_API1, "TERMSRV: WinStationDoReconnect, rc=0x%x\n", Status ));
    return( Status );
}


/*******************************************************************************
 *  WsxBrokenConnection
 *
 *   Send broken connection notification to the WinStation extension DLL
 ******************************************************************************/
VOID WsxBrokenConnection(PWINSTATION pWinStation)
{
    /*
     * Only send notification if there is a reason
     */
    if ( pWinStation->BrokenReason ) {
        if ( pWinStation->pWsx && pWinStation->pWsx->pWsxBrokenConnection ) {
            ICA_BROKEN_CONNECTION Broken;

            Broken.Reason = pWinStation->BrokenReason;
            Broken.Source = pWinStation->BrokenSource;
            pWinStation->pWsx->pWsxBrokenConnection( pWinStation->pWsxContext,
                                                     pWinStation->hStack,
                                                     &Broken );
        }

        /*
         * Clear these once we have tried to send them
         */
        pWinStation->BrokenReason = 0;
        pWinStation->BrokenSource = 0;
    }
}


/*******************************************************************************
 *  CleanupReconnect
 *
 *   Cleanup the specified RECONNECT_INFO structure
 *
 * ENTRY:
 *    pReconnectInfo (input)
 *       Pointer to RECONNECT_INFO buffer
 ******************************************************************************/
VOID CleanupReconnect(PRECONNECT_INFO pReconnectInfo)
{
    NTSTATUS Status;

    /*
     * If there is a connection endpoint, then close it now.
     * When done, we also free the endpoint structure.
     */
    if ( (pReconnectInfo->pEndpoint != NULL) && (pReconnectInfo->hStack != NULL)) {
        Status = IcaStackConnectionClose( pReconnectInfo->hStack,
                                          &pReconnectInfo->Config,
                                          pReconnectInfo->pEndpoint,
                                          pReconnectInfo->EndpointLength );

        ASSERT( Status == STATUS_SUCCESS );
        MemFree( pReconnectInfo->pEndpoint );
        pReconnectInfo->pEndpoint = NULL;
    }

    if ( pReconnectInfo->pWsxContext ) {
        if ( pReconnectInfo->pWsx &&
             pReconnectInfo->pWsx->pWsxWinStationRundown ) {
            pReconnectInfo->pWsx->pWsxWinStationRundown( pReconnectInfo->pWsxContext );
        }
        pReconnectInfo->pWsxContext = NULL;
    }

    if ( pReconnectInfo->hStack ) {
        IcaStackClose( pReconnectInfo->hStack );
        pReconnectInfo->hStack = NULL;
    }

    if ( pReconnectInfo->hIca ) {
        IcaClose( pReconnectInfo->hIca );
        pReconnectInfo->hIca = NULL;
    }
}


NTSTATUS _CloseEndpoint(
        IN PWINSTATIONCONFIG2 pWinStationConfig,
        IN PVOID pEndpoint,
        IN ULONG EndpointLength,
        IN PWINSTATION pWinStation,
        IN BOOLEAN bNeedStack)
{
    HANDLE hIca;
    HANDLE hStack;
    NTSTATUS Status;

    /*
     * Open a stack handle that we can use to close the specified endpoint.
     */

    TRACE((hTrace, TC_ICASRV, TT_ERROR, 
          "TERMSRV: _CloseEndpoint [%p] on %s stack\n", 
           pEndpoint, bNeedStack ? "Temporary" : "Primary"));

    if (bNeedStack) {
        Status = IcaOpen( &hIca );
        if ( NT_SUCCESS( Status ) ) {
            Status = IcaStackOpen( hIca, Stack_Primary, NULL, NULL, &hStack );
            if ( NT_SUCCESS( Status ) ) {
                Status = IcaStackConnectionClose( hStack,
                                                  pWinStationConfig,
                                                  pEndpoint,
                                                  EndpointLength );
                IcaStackClose( hStack );
            }
            IcaClose( hIca );
        }
    }

    else {
        Status = IcaStackConnectionClose( pWinStation->hStack,
                                          pWinStationConfig,
                                          pEndpoint,
                                          EndpointLength );
    }
    
    if ( !NT_SUCCESS( Status ) ) {
        TRACE((hTrace, TC_ICASRV, TT_ERROR, 
               "TERMSRV: _CloseEndpoint failed [%s], Status=%x\n", 
               bNeedStack ? "Temporary" : "Primary", Status ));
    }

    return Status;
}


/*******************************************************************************
 *  WinStationExceptionFilter
 *
 *   Handle exception from a WinStation thread
 *
 * ENTRY:
 *    pExceptionInfo (input)
 *       pointer to EXCEPTION_POINTERS struct
 *
 * EXIT:
 *    EXCEPTION_EXECUTE_HANDLER -- always
 ******************************************************************************/
NTSTATUS WinStationExceptionFilter(
        PWSTR OutputString,
        PEXCEPTION_POINTERS pexi)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    MUTANT_BASIC_INFORMATION MutexInfo;
    NTSTATUS Status;

    DbgPrint( "TERMSRV: %S\n", OutputString );
    DbgPrint( "TERMSRV: ExceptionRecord=%p ContextRecord=%p\n",
              pexi->ExceptionRecord, pexi->ContextRecord );
    DbgPrint( "TERMSRV: Exception code=%08x, flags=%08x, addr=%p, IP=%p\n",
              pexi->ExceptionRecord->ExceptionCode,
              pexi->ExceptionRecord->ExceptionFlags,
              pexi->ExceptionRecord->ExceptionAddress,
              CONTEXT_TO_PROGRAM_COUNTER(pexi->ContextRecord) );
#ifdef i386
    DbgPrint( "TERMSRV: esp=%p ebp=%p\n",
              pexi->ContextRecord->Esp, pexi->ContextRecord->Ebp );
#endif
    DbgBreakPoint();

    /*
     * Lock the global WinStation critsec if we don't already own it
     */
    if ( NtCurrentTeb()->ClientId.UniqueThread != WinStationListLock.OwningThread )
        ENTERCRIT( &WinStationListLock );

    /*
     * Search the WinStation list to see if we had any locked
     */
    Head = &WinStationListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        Status = NtQueryMutant( pWinStation->Lock.Mutex, MutantBasicInformation,
                                &MutexInfo, sizeof(MutexInfo), NULL );
        if ( NT_SUCCESS( Status ) && MutexInfo.OwnedByCaller ) {
            ReleaseWinStation( pWinStation );
            break;  // OK to quit now, we should never lock more than one
        }
    }

    LEAVECRIT( &WinStationListLock );

    return EXCEPTION_EXECUTE_HANDLER;
}


/*******************************************************************************
 *  GetProcessLogonId
 *
 *   Get LogonId for a process
 *
 * ENTRY:
 *    ProcessHandle (input)
 *       handle of process to get LogonId for
 *    pLogonId (output)
 *       location to return LogonId of process
 ******************************************************************************/
NTSTATUS GetProcessLogonId(HANDLE Process, PULONG pLogonId)
{
    NTSTATUS Status;
    PROCESS_SESSION_INFORMATION ProcessInfo;

    /*
     * Get the LogonId for the process
     */
    *pLogonId = 0;
    Status = NtQueryInformationProcess( Process, ProcessSessionInformation,
                                        &ProcessInfo, sizeof( ProcessInfo ),
                                        NULL );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: GetProcessLogonId, Process=%x, Status=%x\n",
                  Process, Status ));
        return( Status );
    }

    *pLogonId = ProcessInfo.SessionId;
    return Status;
}


/*******************************************************************************
 *  SetProcessLogonId
 *
 *   Set LogonId for a process
 *
 * ENTRY:
 *    ProcessHandle (input)
 *       handle of process to set LogonId for
 *    LogonId (output)
 *       LogonId to set for process
 ******************************************************************************/
NTSTATUS SetProcessLogonId(HANDLE Process, ULONG LogonId)
{
    NTSTATUS Status;
    PROCESS_SESSION_INFORMATION ProcessInfo;

    /*
     * Set the LogonId for the process
     */
    ProcessInfo.SessionId = LogonId;
    Status = NtSetInformationProcess( Process, ProcessSessionInformation,
                                      &ProcessInfo, sizeof( ProcessInfo ) );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: SetProcessLogonId, Process=%x, Status=%x\n",
                  Process, Status ));
        return Status;
    }

    return Status;
}


/*******************************************************************************
 *  FindWinStationById
 *
 *   Find and lock a WinStation given its LogonId
 *
 * ENTRY:
 *    LogonId (input)
 *       LogonId of WinStation to find
 *    LockList (input)
 *       BOOLEAN indicating whether WinStationListLock should be
 *       left locked on return
 *
 * EXIT:
 *    On success - Pointer to WinStation
 *    On failure - NULL
 ******************************************************************************/
PWINSTATION FindWinStationById(ULONG LogonId, BOOLEAN LockList)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    PWINSTATION pFoundWinStation = NULL;
    ULONG   uCount;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for a WinStation with the given logonid.
     */
searchagain:
    uCount = 0;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( pWinStation->LogonId == LogonId ) {
           uCount++;

            /*
             * Now try to lock the WinStation.
             */
            if (pFoundWinStation == NULL){
               if ( !LockRefLock( &pWinStation->Lock ) )
                  goto searchagain;
                  pFoundWinStation = pWinStation;
            }
#if DBG
#else
    break;
#endif
        }
    }

    ASSERT((uCount <= 1) || (LogonId== -1)  );

    /*
     * If the WinStationList lock should not be held, then release it now.
     */
    if ( !LockList )
        LEAVECRIT( &WinStationListLock );

    if (pFoundWinStation == NULL) {
        TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: FindWinStationById: %d (not found)\n", LogonId ));
    }


    return pFoundWinStation;
}

BOOL
FindFirstListeningWinStationName( PWINSTATIONNAMEW pListenName, PWINSTATIONCONFIG2 pConfig )
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    BOOL bFound = FALSE;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

searchagain:
    /*
     * Search the list for a WinStation with the given name.
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( pWinStation->Flags & WSF_LISTEN && pWinStation->Client.ProtocolType == PROTOCOL_RDP) {

            // try to lock winstation.
            if ( !LockRefLock( &pWinStation->Lock ) )
                goto searchagain;

            CopyMemory( pConfig, &(pWinStation->Config), sizeof(WINSTATIONCONFIG2) );
            lstrcpy( pListenName, pWinStation->WinStationName );
            ReleaseWinStation( pWinStation );
            bFound = TRUE;
        }
    }

    LEAVECRIT( &WinStationListLock );

    TRACE((hTrace,TC_ICASRV,TT_API3,"TERMSRV: FindFirstListeningWinStationName: %ws\n",
            (bFound) ? pListenName : L"Not Found" ));

    return bFound;
}

/*******************************************************************************
 *  FindWinStationByName
 *
 *   Find and lock a WinStation given its Name
 *
 * ENTRY:
 *    WinStationName (input)
 *       Name of WinStation to find
 *    LockList (input)
 *       BOOLEAN indicating whether WinStationListLock should be
 *       left locked on return
 *
 * EXIT:
 *    On success - Pointer to WinStation
 *    On failure - NULL
 ******************************************************************************/
PWINSTATION FindWinStationByName(LPWSTR WinStationName, BOOLEAN LockList)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for a WinStation with the given name.
     */
searchagain:
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( !_wcsicmp( pWinStation->WinStationName, WinStationName ) ) {

            /*
             * Now try to lock the WinStation.  If this succeeds,
             * then ensure it still has the name we're searching for.
             */
            if ( !LockRefLock( &pWinStation->Lock ) )
                goto searchagain;
            if ( _wcsicmp( pWinStation->WinStationName, WinStationName ) ) {
                ReleaseWinStation( pWinStation );
                goto searchagain;
            }

            /*
             * If the WinStationList lock should not be held, then release it now.
             */
            if ( !LockList )
                LEAVECRIT( &WinStationListLock );

            TRACE((hTrace,TC_ICASRV,TT_API3,"TERMSRV: FindWinStationByName: %S, LogonId %u\n",
                    WinStationName, pWinStation->LogonId ));
            return( pWinStation );
        }
    }

    /*
     * If the WinStationList lock should not be held, then release it now.
     */
    if ( !LockList )
        LEAVECRIT( &WinStationListLock );

    TRACE((hTrace,TC_ICASRV,TT_API3,"TERMSRV: FindWinStationByName: %S, (not found)\n",
            WinStationName ));
    return NULL;
}


/*******************************************************************************
 *  FindIdleWinStation
 *
 *   Find and lock an idle WinStation
 *
 * EXIT:
 *    On success - Pointer to WinStation
 *    On failure - NULL
 ******************************************************************************/
PWINSTATION FindIdleWinStation()
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    BOOLEAN bFirstTime = TRUE;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for an idle WinStation
     */
searchagain:
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( (pWinStation->Flags & WSF_IDLE) &&
             !(pWinStation->Flags & WSF_IDLEBUSY) &&
             !pWinStation->Starting &&
             pWinStation->ConnectEvent ) {

            /*
             * Now try to lock the WinStation.  If this succeeds,
             * then ensure it is still marked as idle.
             */
            if ( !LockRefLock( &pWinStation->Lock ) )
                goto searchagain;
            if ( !(pWinStation->Flags & WSF_IDLE) ||
                 (pWinStation->Flags & WSF_IDLEBUSY) ||
                 pWinStation->Starting ||
                 !pWinStation->ConnectEvent ) {
                ReleaseWinStation( pWinStation );
                goto searchagain;
            }

            LEAVECRIT( &WinStationListLock );
            return( pWinStation );
        }
    }

    LEAVECRIT( &WinStationListLock );

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: FindIdleWinStation: (none found)\n" ));
    return NULL;
}


/*******************************************************************************
 *  CountWinStationType
 *
 *   Count the number of matching Winstation Listen Names
 *
 * ENTRY:
 *    Listen Name
 *
 *    bActiveOnly if TRUE, count only active WinStations
 *
 * EXIT:
 *    Number
 ******************************************************************************/
ULONG CountWinStationType(
    PWINSTATIONNAME pListenName,
    BOOLEAN bActiveOnly,
    BOOLEAN bLockHeld)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    ULONG Count = 0;

    Head = &WinStationListHead;

    if ( !bLockHeld ) {
        ENTERCRIT( &WinStationListLock );
    }

    /*
     * Search the list for an idle WinStation
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( !wcscmp( pWinStation->ListenName, pListenName ) ) {
            if ( !bActiveOnly )
                Count++;
            else if ( pWinStation->State == State_Active )
                Count++;
        }
    }

    if ( !bLockHeld ) {
        LEAVECRIT( &WinStationListLock );
    }

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: CountWinstationType %d\n", Count ));
    return Count;
}


/*******************************************************************************
 *  LockWinStationByPointer
 *
 *   Lock a WinStation given a pointer
 *
 * NOTE:
 *    WinStationListLock must be locked on entry and will be locked on return.
 *    If return value is FALSE, then the WinStation may have beed deleted
 *    and the pWinStation pointer should NOT be referenced.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to lock
 *
 * EXIT:
 *    On success - TRUE if WinStation was locked successfully
 *    On failure - FALSE otherwise
 ******************************************************************************/
BOOLEAN LockWinStationByPointer(PWINSTATION pWinStation)
{
    /*
     * Try to lock the WinStation.
     */
    return LockRefLock(&pWinStation->Lock);
}


/*******************************************************************************
 *  InitRefLock
 *
 *   Initialize a RefLock and lock it.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to init
 *    pDeleteProcedure (input)
 *       Pointer to delete procedure for object
 ******************************************************************************/
NTSTATUS InitRefLock(PREFLOCK pLock, PREFLOCKDELETEPROCEDURE pDeleteProcedure)
{
    NTSTATUS Status;

    // Create and lock winstation mutex
    Status = NtCreateMutant( &pLock->Mutex, MUTANT_ALL_ACCESS, NULL, TRUE );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    pLock->RefCount = 1;
    pLock->Invalid = FALSE;
    pLock->pDeleteProcedure = pDeleteProcedure;

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  SetRefLockDeleteProc
 *
 *   Cahnge a RefLock DeleteProc.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to init
 *    pDeleteProcedure (input)
 *       Pointer to delete procedure for object
 ******************************************************************************/
NTSTATUS SetRefLockDeleteProc(
        PREFLOCK pLock,
        PREFLOCKDELETEPROCEDURE pDeleteProcedure)
{
    pLock->pDeleteProcedure = pDeleteProcedure;
    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  LockRefLock
 *
 *   Increment the reference count for a RefLock and lock it.
 *
 * NOTE:
 *    WinStationListLock must be locked on entry and will be locked on return.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to lock
 *
 * EXIT:
 *    TRUE - if object was locked successfully
 *    FALSE - otherwise
 ******************************************************************************/
BOOLEAN LockRefLock(PREFLOCK pLock)
{
    /*
     * Increment reference count for this RefLock.
     */
    InterlockedIncrement( &pLock->RefCount );

    /*
     * If mutex cannot be locked without blocking,
     * then unlock the WinStation list lock, wait for the mutex,
     * and relock the WinStation list lock.
     */
    if ( NtWaitForSingleObject( pLock->Mutex, FALSE, &TimeoutZero ) != STATUS_SUCCESS ) {
        LEAVECRIT( &WinStationListLock );
        NtWaitForSingleObject( pLock->Mutex, FALSE, NULL );
        ENTERCRIT( &WinStationListLock );

        /*
         * If the object is marked as invalid, it was removed while
         * we waited for the lock.  Release our lock and return FALSE,
         * indicating we were unable to lock it.
         */
        if ( pLock->Invalid ) {
            /*
             * Release the winstationlist lock because the Winstation
             * migth go away as a result of releasing its lock,
             */
            LEAVECRIT( &WinStationListLock );
            ReleaseRefLock( pLock );
            ENTERCRIT( &WinStationListLock );
            return FALSE;
        }
    }

    return TRUE;
}


/*******************************************************************************
 *  RelockRefLock
 *
 *   Relock a RefLock which has been unlocked but still has a reference.
 *
 * NOTE:
 *    Object must have been previously unlocked by calling UnlockRefLock.
 *
 * EXIT:
 *    TRUE - if object is still valid
 *    FALSE - if object was marked invalid while unlocked
 ******************************************************************************/
BOOLEAN RelockRefLock(PREFLOCK pLock)
{
    /*
     * Lock the mutex
     */
    NtWaitForSingleObject( pLock->Mutex, FALSE, NULL );

    /*
     * If the object is marked as invalid,
     * it was removed while it was unlocked so we return FALSE.
     */
    return !pLock->Invalid;
}


/*******************************************************************************
 *  UnlockRefLock
 *
 *   Unlock a RefLock but keep a reference to it (don't decrement
 *   the reference count).  Caller must use RelockWinRefLock
 *   to relock the object.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to unlock
 ******************************************************************************/
VOID UnlockRefLock(PREFLOCK pLock)
{
    NtReleaseMutant(pLock->Mutex, NULL);
}


/*******************************************************************************
 *  ReleaseRefLock
 *
 *   Unlock and dereference a RefLock.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to release
 ******************************************************************************/
VOID ReleaseRefLock(PREFLOCK pLock)
{
    ASSERT( pLock->RefCount > 0 );

    /*
     * If object has been marked invalid and we are the
     * last reference, then finish deleting it now.
     */
    if ( pLock->Invalid ) {
        ULONG RefCount;

        RefCount = InterlockedDecrement( &pLock->RefCount );
        NtReleaseMutant( pLock->Mutex, NULL );
        if ( RefCount == 0 ) {
            NtClose( pLock->Mutex );
            (*pLock->pDeleteProcedure)( pLock );
        }

    } else {
        InterlockedDecrement( &pLock->RefCount );
        NtReleaseMutant( pLock->Mutex, NULL );
    }
}


/*******************************************************************************
 *  DeleteRefLock
 *
 *   Unlock, dereference, and delete a RefLock.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to delete
 ******************************************************************************/
VOID DeleteRefLock(PREFLOCK pLock)
{
    ASSERT( pLock->RefCount > 0 );

    /*
     * If we are the last reference, then delete the object now
     */
    if ( InterlockedDecrement( &pLock->RefCount ) == 0 ) {
        NtReleaseMutant( pLock->Mutex, NULL );
        NtClose( pLock->Mutex );
        (*pLock->pDeleteProcedure)( pLock );

    /*
     * Otherwise, just mark the object invalid
     */
    } else {
        pLock->Invalid = TRUE;
        NtReleaseMutant( pLock->Mutex, NULL );
    }
}


BOOLEAN IsWinStationLockedByCaller(PWINSTATION pWinStation)
{
    MUTANT_BASIC_INFORMATION MutantInfo;
    NTSTATUS Status;

    Status = NtQueryMutant( pWinStation->Lock.Mutex,
                            MutantBasicInformation,
                            &MutantInfo,
                            sizeof(MutantInfo),
                            NULL );
    if ( NT_SUCCESS( Status ) )
        return MutantInfo.OwnedByCaller;

    return FALSE;
}


/*******************************************************************************
 *  WinStationEnumerateWorker
 *
 *   Enumerate the WinStation list and return LogonIds and WinStation
 *   names to the caller.
 *
 * NOTE:
 *   This version only returns one entry at a time.  There is no guarantee
 *   across calls that the list will not change, causing the users Index
 *   to miss an entry or get the same entry twice.
 *
 * ENTRY:
 *    pEntries (input/output)
 *       Pointer to number of entries to return/number actually returned
 *    pWin (output)
 *       Pointer to buffer to return entries
 *    pByteCount (input/output)
 *       Pointer to size of buffer/length of data returned in buffer
 *    pIndex (input/output)
 *       Pointer to WinStation index to return/next index
 ******************************************************************************/
NTSTATUS WinStationEnumerateWorker(
        PULONG pEntries,
        PLOGONID pWin,
        PULONG pByteCount,
        PULONG pIndex)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    ULONG WinStationIndex;
    ULONG MaxEntries, MaxByteCount;
    NTSTATUS Status;
    NTSTATUS Error = STATUS_NO_MORE_ENTRIES;

    WinStationIndex = 0;
    MaxEntries = *pEntries;
    MaxByteCount = *pByteCount;
    *pEntries = 0;
    *pByteCount = 0;
    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

        if ( *pEntries >= MaxEntries ||
             *pByteCount + sizeof(LOGONID) > MaxByteCount ) {
            break;
        }

        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        if ( *pIndex == WinStationIndex ) {
            (*pIndex)++;    // set Index to next entry

            /*
             * Verify that client has QUERY access before
             * returning it in the enumerate list.
             * (Note that RpcCheckClientAccess only references the WinStation
             *  to get the LogonId, so it is safe to call this routine without
             *  locking the WinStation since we hold the WinStationListLock
             *  which prevents the WinStation from being deleted.)
             */
            Status = RpcCheckClientAccess( pWinStation, WINSTATION_QUERY, FALSE );
            if ( NT_SUCCESS( Status ) ) {
                Error = STATUS_SUCCESS;


                /*
                 * It's possible that the LPC client can go away while we
                 * are processing this call.  Its also possible that another
                 * server thread handles the LPC_PORT_CLOSED message and closes
                 * the port, which deletes the view memory, which is what
                 * pWin points to.  In this case the pWin references below
                 * will trap.  We catch this and just break out of the loop.
                 */
                try {
                    pWin->LogonId = pWinStation->LogonId;
                    if ( pWinStation->Terminating )
                        pWin->State = State_Down;
                    else
                        pWin->State = pWinStation->State;
                    wcscpy( pWin->WinStationName, pWinStation->WinStationName );
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    break;
                }
                pWin++;
                (*pEntries)++;
                *pByteCount += sizeof(LOGONID);
            }
        }
        WinStationIndex++;
    }

    LEAVECRIT( &WinStationListLock );
    return Error;
}


/*******************************************************************************
 *  LogonIdFromWinStationNameWorker
 *
 *   Return the LogonId for a given WinStation name.
 *
 * ENTRY:
 *    WinStationName (input)
 *       name of WinStation to query
 *    pLogonId (output)
 *       Pointer to location to return LogonId
 ******************************************************************************/
NTSTATUS LogonIdFromWinStationNameWorker(
        PWINSTATIONNAME WinStationName,
        ULONG  NameSize,
        PULONG pLogonId)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    NTSTATUS Status;
    UINT     uiLength;

    // make sure we don't go beyond the end of one of the two strings
    // (and work around bug #229753 : NameSize is in bytes, not a characters count)
    if (NameSize > sizeof(WINSTATIONNAME)) {
        uiLength = sizeof(WINSTATIONNAME)/sizeof(WCHAR);
    } else {
        uiLength = NameSize/sizeof(WCHAR);
    }

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        if ( !_wcsnicmp( pWinStation->WinStationName, WinStationName, uiLength ) ) {

            /*
             * If client doesn't have QUERY access, return NOT_FOUND error
             */
            Status = RpcCheckClientAccess( pWinStation, WINSTATION_QUERY, FALSE );
            if ( !NT_SUCCESS( Status ) )
                break;
            *pLogonId = pWinStation->LogonId;
            LEAVECRIT( &WinStationListLock );
            return( STATUS_SUCCESS );
        }
    }

    LEAVECRIT( &WinStationListLock );
    return STATUS_CTX_WINSTATION_NOT_FOUND;
}


/*******************************************************************************
 *  IcaWinStationNameFromLogonId
 *
 *   Return the WinStation name for a given LogonId.
 *
 * ENTRY:
 *    LogonId (output)
 *       LogonId to query
 *    pWinStationName (input)
 *       pointer to location to return WinStation name
 ******************************************************************************/
NTSTATUS IcaWinStationNameFromLogonId(
        ULONG LogonId,
        PWINSTATIONNAME pWinStationName)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    NTSTATUS Status;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        if ( pWinStation->LogonId == LogonId ) {
            /*
             * If client doesn't have QUERY access, return NOT_FOUND error
             */
            Status = RpcCheckClientAccess( pWinStation, WINSTATION_QUERY, FALSE );
            if ( !NT_SUCCESS( Status ) )
                break;
            wcscpy( pWinStationName, pWinStation->WinStationName );
            LEAVECRIT( &WinStationListLock );
            return( STATUS_SUCCESS );
        }
    }

    LEAVECRIT( &WinStationListLock );
    return STATUS_CTX_WINSTATION_NOT_FOUND;
}


NTSTATUS TerminateProcessAndWait(
        HANDLE ProcessId,
        HANDLE Process,
        ULONG Seconds)
{
    NTSTATUS Status;
    ULONG mSecs;
    LARGE_INTEGER Timeout;

    /*
     * Try to terminate the process
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: TerminateProcessAndWait, process=0x%x, ", ProcessId ));

    Status = NtTerminateProcess( Process, STATUS_SUCCESS );
    if ( !NT_SUCCESS( Status ) && Status != STATUS_PROCESS_IS_TERMINATING ) {
        DBGPRINT(("Terminate=0x%x\n", Status ));
        return( Status );
    }
    TRACE((hTrace,TC_ICASRV,TT_API1, "Terminate=0x%x, ", Status ));

    /*
     * Wait for the process to die
     */
    mSecs = Seconds * 1000;
    Timeout = RtlEnlargedIntegerMultiply( mSecs, -10000 );
    Status = NtWaitForSingleObject( Process, FALSE, &Timeout );

    TRACE((hTrace,TC_ICASRV,TT_API1, "Wait=0x%x\n", Status ));

    return Status;
}


/*****************************************************************************
 *  ShutdownLogoff
 *
 *   Worker function to handle logoff notify of WinStations when
 *   the system is being shutdown.
 *
 *   It is built from the code in WinStationReset
 *
 * ENTRY:
 *   Client LogonId (input)
 *     LogonId of the client Winstation doing the shutdown. This is so
 *     that he does not get reset.
 *   Flags (input)
 *     The shutdown flags.
 ****************************************************************************/
NTSTATUS ShutdownLogoff(ULONG ClientLogonId, ULONG Flags)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation, pConsole = NULL;
    PULONG Tmp;
    PULONG Ids = NULL;
    ULONG  IdCount = 0;
    ULONG  IdAllocCount = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE((hTrace,TC_ICASRV,TT_API1, "ShutdownLogoff: Called from WinStation %d Flags %x\n", ClientLogonId, Flags ));

    /*
     * Loop through all the WinStations getting the LogonId's
     * of active Winstations
     */
    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        //
        // take a reference on the console
        //
        if ( pWinStation->fOwnsConsoleTerminal ) {
            if ( LockWinStationByPointer( pWinStation ) ) {
                  pConsole = pWinStation;
                  UnlockWinStation( pConsole );
            }
        }
        //
        // just skip :
        // - the caller's session
        // - the console (because winsrv!W32WinStationExitWindows would fail for the console)
        // - the listener
        //
        if ( ( pWinStation->LogonId == ClientLogonId ) ||
             ( pWinStation->LogonId == 0) ||
             ( pWinStation->Flags & WSF_LISTEN ) ) {
            // Skip this one, or it's a listen
            continue;
        }

        if ( IdCount >= IdAllocCount ) {
            // Reallocate the array
            IdAllocCount += 16;
            Tmp = RtlAllocateHeap( RtlProcessHeap(), 0, IdAllocCount * sizeof(ULONG) );
            if ( Tmp == NULL ) {
                Status = STATUS_NO_MEMORY;
                if ( Ids )
                    RtlFreeHeap( RtlProcessHeap(), 0, Ids );
                IdCount = 0;
                break;
            }
            if ( Ids ) {
               RtlCopyMemory( Tmp, Ids, IdCount*sizeof(ULONG) );
               RtlFreeHeap( RtlProcessHeap(), 0, Ids );
            }
            Ids = Tmp;
        }
        // Copy the LogonId into our array
        Ids[IdCount++] = pWinStation->LogonId;
    }

    //
    // We are protected by new winstations starting up by the shutdown
    // global flags.
    //
    // The actual WinStation reset routine will validate that the LogonId
    // is still valid
    //
    LEAVECRIT( &WinStationListLock );

    //
    // see if the console is being shadowed
    //
    if ( pConsole ) {
        RelockWinStation( pConsole );
        WinStationStopAllShadows( pConsole );
        ReleaseWinStation( pConsole );
    }

    if (IdCount !=0)
    {
        //
        // Ids[] holds the LogonId's of valid Winstations, IdCount is the number
        //

        /*
         * Now do the actual logout and/or reset of the WinStations.
         */
        if (Flags & WSD_LOGOFF) {
            Status = DoForWinStationGroup( Ids, IdCount,
                                           (LPTHREAD_START_ROUTINE) WinStationLogoff);
        }

        if (Flags & WSD_SHUTDOWN) {
            Status = DoForWinStationGroup( Ids, IdCount,
                                           (LPTHREAD_START_ROUTINE) WinStationShutdownReset);
        }
    }

    return Status;
}


/*****************************************************************************
 *  DoForWinStationGroup
 *
 *   Executes a function for each WinStation in the group.
 *   The group is passed as an array of LogonId's.
 *
 * ENTRY:
 *   Ids (input)
 *     Array of LogonId's of WinStations to reset
 *
 *   IdCount (input)
 *     Count of LogonId's in array
 *
 *   ThreadProc (input)
 *     The thread routine executed for each WinStation.
 ****************************************************************************/
NTSTATUS DoForWinStationGroup(
        PULONG Ids,
        ULONG  IdCount,
        LPTHREAD_START_ROUTINE ThreadProc)
{
    ULONG Index;
    NTSTATUS Status;
    LARGE_INTEGER Timeout;
    PHANDLE ThreadHandles = NULL;

    ThreadHandles = RtlAllocateHeap( RtlProcessHeap(), 0, IdCount * sizeof(HANDLE) );
    if( ThreadHandles == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    /*
     * Wait a max of 60 seconds for thread to exit
     */
    Timeout = RtlEnlargedIntegerMultiply( 60000, -10000 );

    for( Index=0; Index < IdCount; Index++ ) {

        //
        // Here we create a thread to run the actual reset function.
        // Since we are holding the lists crit sect, the threads will
        // wait until we are done, then wake up when we release it
        //
        DWORD ThreadId;

        ThreadHandles[Index] = CreateThread( NULL,
                                             0,         // use Default stack size of the svchost process
                                             ThreadProc,
                                             LongToPtr( Ids[Index] ),  // LogonId
                                             THREAD_SET_INFORMATION,
                                             &ThreadId );
        if ( !ThreadHandles[Index] ) {
            ThreadHandles[Index] = (HANDLE)(-1);
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Shutdown: Could not create thread for WinStation %d Shutdown\n", Ids[Index]));
        }
    }

    //
    // Now wait for the threads to exit. Each will reset their
    // WinStation and be signal by the kernel when the thread is
    // exited.
    //
    for (Index=0; Index < IdCount; Index++) {
        if ( ThreadHandles[Index] != (HANDLE)(-1) ) {
            Status = NtWaitForSingleObject(
                         ThreadHandles[Index],
                         FALSE,   // Not alertable
                         &Timeout
                         );

            if( Status == STATUS_TIMEOUT ) {
                TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: DoForWinStationGroup: Timeout Waiting for Thread\n"));
            }
            else if (!NT_SUCCESS( Status ) ) {
                TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: DoForWinStationGroup: Error waiting for Thread Status 0x%x\n", Status));
            }
            NtClose( ThreadHandles[Index] );
        }
    }

    /* makarp:free the ThreadHandles. // #182609 */
    RtlFreeHeap( RtlProcessHeap(), 0, ThreadHandles );

    return STATUS_SUCCESS;
}


/*****************************************************************************
 *  WinStationShutdownReset
 *
 *   Reset a WinStation due to a system shutdown. Does not re-create
 *   it.
 *
 * ENTRY:
 *   ThreadArg (input)
 *     WinStation logonId
 ****************************************************************************/
ULONG WinStationShutdownReset(PVOID ThreadArg)
{
    ULONG LogonId = (ULONG)(INT_PTR)ThreadArg;
    PWINSTATION pWinStation;
    NTSTATUS Status;
    ULONG ulIndex;
    BOOL bConnectDisconnectPending = TRUE;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: ShutdownReset, LogonId=%d\n", LogonId ));

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Console is a special case since it only logs off
     */
    if ( LogonId == 0 ) {
        Status = LogoffWinStation( pWinStation, (EWX_FORCE | EWX_LOGOFF) );
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Mark the winstation as being deleted.
     * If a reset/delete operation is already in progress
     * on this winstation, then don't proceed with the delete.
     * Also if there is a Connect/disconnect pending, give it
     * a chance to complete.
     */
    for (ulIndex=0; ulIndex < WINSTATION_WAIT_COMPLETE_RETRIES; ulIndex++) {

       if ( pWinStation->Flags & (WSF_RESET | WSF_DELETE) ) {
           ReleaseWinStation( pWinStation );
           Status = STATUS_CTX_WINSTATION_BUSY;
           goto done;
       }

       if ( pWinStation->Flags & (WSF_CONNECT | WSF_DISCONNECT) ) {
           LARGE_INTEGER Timeout;
           Timeout = RtlEnlargedIntegerMultiply( WINSTATION_WAIT_COMPLETE_DURATION, -10000 );
           UnlockWinStation( pWinStation );
           NtDelayExecution( FALSE, &Timeout );
           if ( !RelockWinStation( pWinStation ) ) {
               ReleaseWinStation( pWinStation );
               Status = STATUS_SUCCESS;
               goto done;
           }
       } else {
          bConnectDisconnectPending = FALSE;
          break;
       }
    }

    if ( bConnectDisconnectPending ) {
        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto done;
    }

    pWinStation->Flags |= WSF_DELETE;

    /*
     * If no broken reason/source have been set, then set them here.
     */
    if ( pWinStation->BrokenReason == 0 ) {
        pWinStation->BrokenReason = Broken_Terminate;
        pWinStation->BrokenSource = BrokenSource_Server;
    }

    /*
     * Make sure this WinStation is ready to delete
     */
    WinStationTerminate( pWinStation );

    /*
     * Call the WinStationDelete worker
     */
    WinStationDeleteWorker( pWinStation );
    Status = STATUS_SUCCESS;

done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: ShutdownReset, Status=0x%x\n", Status ));
    ExitThread( 0 );
    return Status;
}


/*****************************************************************************
 *  WinStationLogoff
 *
 *   Logoff the WinStation via ExitWindows.
 *
 * ENTRY:
 *   ThreadArg (input)
 *     WinStation logonId
 ****************************************************************************/
ULONG WinStationLogoff(PVOID ThreadArg)
{
    ULONG LogonId = (ULONG)(INT_PTR)ThreadArg;
    PWINSTATION pWinStation;
    NTSTATUS Status;
    LARGE_INTEGER Timeout;

    /*
     * Wait a maximum of 1 min for the session to logoff
     */
    Timeout = RtlEnlargedIntegerMultiply( 60000, -10000 );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationLogoff, LogonId=%d\n", LogonId ));

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
    } else {
        Status = LogoffWinStation( pWinStation, EWX_LOGOFF);

        if (ShutdownInProgress &&
                NT_SUCCESS(Status) &&
                ((pWinStation->State == State_Active) ||
                (pWinStation->State == State_Disconnected))) {

            UnlockWinStation( pWinStation );
            Status = NtWaitForSingleObject( pWinStation->InitialCommandProcess,
                                            FALSE,
                                            &Timeout );
            RelockWinStation( pWinStation );
        }

        ReleaseWinStation( pWinStation );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationLogoff, Status=0x%x\n", Status ));
    ExitThread( 0 );
    return Status;
}


/*******************************************************************************
 *  ResetGroupByListener
 *
 *    Resets all active winstations on the supplied listen name.
 *
 * ENTRY:
 *    pListenName (input)
 *       Type of Winstation (e.g. tcp, ipx)
 ******************************************************************************/
VOID ResetGroupByListener(PWINSTATIONNAME pListenName)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for all active WinStation with the given ListenName.
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if (!wcscmp(pWinStation->ListenName, pListenName) &&
            (!(pWinStation->Flags & (WSF_RESET | WSF_LISTEN)))) {
            QueueWinStationReset(pWinStation->LogonId);
        }
    }

    LEAVECRIT( &WinStationListLock );
}


NTSTATUS LogoffWinStation(PWINSTATION pWinStation, ULONG ExitWindowsFlags)
{
    WINSTATION_APIMSG msg;
    NTSTATUS Status = 0;

    /*
     * Tell the WinStation to logoff
     */
    msg.ApiNumber = SMWinStationExitWindows;
    msg.u.ExitWindows.Flags = ExitWindowsFlags;
    Status = SendWinStationCommand( pWinStation, &msg, 0 );
    return Status;
}


/*****************************************************************************
 *
 *  This section of the file contains the impementation of the digital
 *  certification mechanism for the Stack and WinStation Extension DLLs.  This
 *  code is not in a separate file so that external symbols are not visible.
 *  All routines are declared static.
 *
 ****************************************************************************/

//
// For security reasons, the TRACE statements in the following routine are
// normally not included.  If you want to include them, uncomment the
// SIGN_DEBUG_WINSTA #define below.
//
// #define SIGN_DEBUG_WINSTA

#include <wincrypt.h>
#include <imagehlp.h>
#include <stddef.h>

#include "../../tscert/inc/pubblob.h"    // needed by certvfy.inc
#include "../../tscert/inc/certvfy.inc"  // VerifyFile()

//
//  The following are initialized by VfyInit.
//
static RTL_CRITICAL_SECTION VfyLock;
static WCHAR szSystemDir[ MAX_PATH + 1 ];
static WCHAR szDriverDir[ MAX_PATH + 1 ];

/*******************************************************************************
 *  ReportStackLoadFailure
 *
 *   Send a StackFailed message to the WinStationApiPort.
 *
 * ENTRY:
 *    Module (input)
 *       Name of Module to Log Error Against
 ******************************************************************************/
static NTSTATUS ReportStackLoadFailure(PWCHAR Module)
{
    HANDLE h;
    extern WCHAR gpszServiceName[];

    h = RegisterEventSource(NULL, gpszServiceName);
    if (h != NULL) {
        if (!ReportEventW(h,       // event log handle
                          EVENTLOG_ERROR_TYPE,   // event type
                          0,                     // category zero
                          EVENT_BAD_STACK_MODULE,// event identifier
                          NULL,                  // no user security identifier
                          1,                     // one substitution string
                          0,                     // no data
                          &Module,               // pointer to string array
                          NULL)                 // pointer to data
           ) {
            DBGPRINT(("ReportEvent Failed %ld. Event ID=%lx module=%ws\n",GetLastError(), EVENT_BAD_STACK_MODULE, Module));
        }

        DeregisterEventSource(h);
    } else {
        DBGPRINT(("Cannot RegisterEvent Source %ld Event ID=%lx module=%ws\n",GetLastError(), EVENT_BAD_STACK_MODULE, Module));
    }

    return STATUS_SUCCESS;
}


/******************************************************************************
 *  _VerifyStackModules
 *   Verifies the integrity of the stack modules and the authenticity
 *   of the digital signature.
 *
 * ENTRY:
 *   pWinStation (input)
 *     Pointer to a Listen Winstation.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *   STATUS_UNSUCCESSFUL - DLL integrity check, authenticity check failed
 *                         or registry stucture invalid
 *****************************************************************************/
static NTSTATUS _VerifyStackModules(IN PWINSTATION pWinStation)
{
    PWCHAR pszModulePath = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD KeyIndex;
    DWORD Error;
#ifdef SIGN_BYPASS_OPTION
    HKEY hKey;
#endif SIGN_BYPASS_OPTION
    HKEY hVidKey;
    HKEY hVidDriverKey;
    UNICODE_STRING KeyPath;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hServiceKey;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
#define VALUE_BUFFER_SZ (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + \
                           256 * sizeof( WCHAR))
    PCHAR pValueBuffer = NULL;
    INT Entries;
    DWORD dwByteCount;
    PPDNAME pPdNames, p;
    INT i;
    DLLNAME WdDLL;


#ifdef SIGN_BYPASS_OPTION

    //
    // Check if Verification is to be bypassed
    //
    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REG_CONTROL_TSERVER L"\\BypassVerification",
            0,
            KEY_READ,
            &hKey ) == ERROR_SUCCESS ) {
        RegCloseKey( hKey );
        Status = STATUS_SUCCESS;
        goto exit;
    }

#endif //SIGN_BYPASS_OPTION



#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1, "System Dir: %ws\n", szSystemDir ));
#endif // SIGN_DEBUG_WINSTA

    // allocate memory
    pszModulePath = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) ) ; 
    if (pszModulePath == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    pValueBuffer = MemAlloc( VALUE_BUFFER_SZ );
    if (pValueBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    //
    //  Verify the WSX DLL if defined
    //
    if ( pWinStation->Config.Wd.WsxDLL[0] != L'\0' ) {
        wcscpy( pszModulePath, szSystemDir );
        wcscat( pszModulePath, pWinStation->Config.Wd.WsxDLL );
        wcscat( pszModulePath, L".DLL" );
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "==> WSX Path: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

        if ( !VerifyFile( pszModulePath, &VfyLock ) ) {
            ReportStackLoadFailure(pszModulePath);
            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
    }
    //
    //  Verify the WD
    //
    wcscpy( WdDLL, pWinStation->Config.Wd.WdDLL );
    wcscpy( pszModulePath, szDriverDir );
    wcscat( pszModulePath, WdDLL );
    wcscat( pszModulePath, L".SYS" );
#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1, "==> WD Path: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

    if ( !VerifyFile( pszModulePath, &VfyLock ) ) {
        ReportStackLoadFailure(pszModulePath);
        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    //
    //  Verify the TD which is in Pd[0].  Always defined for Listen Stack.
    //
    wcscpy( pszModulePath, szDriverDir );
    wcscat( pszModulePath, pWinStation->Config.Pd[0].Create.PdDLL );
    wcscat( pszModulePath, L".SYS" );
#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1, "==> WD Path: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

    if ( !VerifyFile( pszModulePath, &VfyLock ) ) {
        ReportStackLoadFailure(pszModulePath);
        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    //
    //  Enumerate the PDs for this WD and verify all the PDs.
    //  Can't depend on Pd[i] for this since optional PDs won't
    //  be present during Listen.
    //
    Entries = -1;
    dwByteCount = 0;
    i = 0;
    Error = RegPdEnumerate(
        NULL,
        WdDLL,
        FALSE,
        &i,
        &Entries,
        NULL,
        &dwByteCount );
#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1,
          "RegPdEnumerate 1 complete., Entries %d, Error %d\n", Entries, Error ));
#endif // SIGN_DEBUG_WINSTA
    
    if ( Error != ERROR_NO_MORE_ITEMS && Error != ERROR_CANTOPEN ) {
        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    //
    //  T.Share doesn't have PDs, so check if none
    //
    if ( Entries ) {
        dwByteCount = sizeof(PDNAME) * Entries;
        pPdNames = MemAlloc( dwByteCount );
        if ( !pPdNames ) {
            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
        i = 0;
        Error = RegPdEnumerate(
            NULL,
            WdDLL,
            FALSE,
            &i,
            &Entries,
            pPdNames,
            &dwByteCount );
        if ( Error != ERROR_SUCCESS ) {

            /* makarp #182610 */
            MemFree( pPdNames );

            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
        //
        // Open up the Registry entry for each named PD and pull out the value
        // of the PdDLL.  This is the name of the DLL to verify.
        //
        for ( i = 0, p = pPdNames; i < Entries;
                i++, (char*)p += sizeof(PDNAME) ) {
            HKEY hPdKey;
            PWCHAR pszPdDLL = NULL;
            PWCHAR pszRegPath = NULL;
            DWORD dwLen;
            DWORD dwType;

            // allocate memory
            pszPdDLL = MemAlloc( (MAX_PATH+1) * sizeof(WCHAR) );
            if (pszPdDLL == NULL) {
                MemFree( pPdNames );
                Status = STATUS_NO_MEMORY;
                goto exit;
            }

            pszRegPath = MemAlloc( (MAX_PATH+1) * sizeof(WCHAR) );
            if (pszRegPath == NULL) {
                MemFree( pszPdDLL );
                MemFree( pPdNames );
                Status = STATUS_NO_MEMORY;
                goto exit;
            }
            
            //
            // Build up the Registry Path to open the PD's key
            //
            wcscpy( pszRegPath, WD_REG_NAME );
            wcscat( pszRegPath, L"\\" );
            wcscat( pszRegPath, WdDLL );
            wcscat( pszRegPath, PD_REG_NAME L"\\" );
            wcscat( pszRegPath, p );
#ifdef SIGN_DEBUG_WINSTA
            TRACE((hTrace,TC_ICASRV,TT_API1, "PdKeyPath: %ws\n", pszRegPath ));
#endif // SIGN_DEBUG_WINSTA

            if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegPath, 0, KEY_READ,
                   &hPdKey ) != ERROR_SUCCESS ) {
                MemFree( pPdNames );
                MemFree( pszPdDLL );
                MemFree( pszRegPath );
                Status = STATUS_UNSUCCESSFUL;
                goto exit;
            }
            //
            // Get the name of the Pd DLL.
            //
            dwLen = (MAX_PATH + 1) * sizeof(WCHAR) ;
            if ( RegQueryValueEx( hPdKey,
                                  WIN_PDDLL,
                                  NULL,
                                  &dwType,
                                  (PCHAR) pszPdDLL,
                                  &dwLen ) != ERROR_SUCCESS ) {
                MemFree( pPdNames );
                MemFree( pszPdDLL );
                MemFree( pszRegPath );

                // makarp:182610
                RegCloseKey(hPdKey);

                Status = STATUS_UNSUCCESSFUL;
                goto exit;
            }

            // makarp:182610
            RegCloseKey(hPdKey);

            //
            // Build path to DLL and attempt verification
            //
            wcscpy( pszModulePath, szDriverDir );
            wcscat( pszModulePath, pszPdDLL );
            wcscat( pszModulePath, L".SYS" );
#ifdef SIGN_DEBUG_WINSTA
            TRACE((hTrace,TC_ICASRV,TT_API1, "==> PD Path: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

            if ( !VerifyFile( pszModulePath, &VfyLock ) &&
                    GetLastError() != ERROR_CANTOPEN ) {
                MemFree( pPdNames );
                MemFree( pszPdDLL );
                MemFree( pszRegPath );
                ReportStackLoadFailure(pszModulePath);
                Status = STATUS_UNSUCCESSFUL;
                goto exit;
            }
            MemFree( pszPdDLL );
            MemFree( pszRegPath );
        }
        MemFree( pPdNames );
    }

    //
    // for all keys under HKLM\System\CCS\Control\Terminal Server\VIDEO
    //  open the subkey \Device\Video0 and use that value as
    //  a string to open
    //  \REGISTRY\Machine\System\CCS\Services\vdtw30\Device0
    //   DLL name is in Value "Installed Display Drivers"
    //
    //  Open registry (LOCAL_MACHINE\System\CCS\Control\Terminal Server\VIDEO)
    //
    //  NOTE: All video driver DLLs are verified since there isn't any simple
    //  method to determine which one is used for this stack.
    //
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, VIDEO_REG_NAME, 0,
         KEY_ENUMERATE_SUB_KEYS, &hVidKey ) != ERROR_SUCCESS ) {
        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    for ( KeyIndex = 0 ;; KeyIndex++ ) {   // For all VIDEO subkeys
        PWCHAR pszVidDriverName = NULL;
        PWCHAR pszRegPath = NULL;
        PWCHAR pszDeviceKey = NULL;
        PWCHAR pszServiceKey = NULL;
        DWORD dwLen;
        DWORD dwType;

        // allocate memory
        pszVidDriverName = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
        if (pszVidDriverName == NULL) {
            Status = STATUS_NO_MEMORY;
            goto exit;
        }

        pszRegPath = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
        if (pszRegPath == NULL) {
            MemFree(pszVidDriverName);
            Status = STATUS_NO_MEMORY;
            goto exit;
        }

        pszDeviceKey = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
        if (pszDeviceKey == NULL) {
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            Status = STATUS_NO_MEMORY;
            goto exit;
        }

        pszServiceKey = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
        if (pszServiceKey == NULL) {
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            Status = STATUS_NO_MEMORY;
            goto exit;
        }

        //
        //  Get name of VIDEO driver subkey.  If end of subkeys, exit loop.
        //
        if ((Error = RegEnumKey( hVidKey, KeyIndex, pszVidDriverName,
                                 MAX_PATH+1))!= ERROR_SUCCESS ){
             
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);

            break;  // exit for loop
        }

        //
        // Build up the Registry Path to open the VgaCompatible Value
        //
        wcscpy( pszRegPath, VIDEO_REG_NAME L"\\" );
        wcscat( pszRegPath, pszVidDriverName );
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "VidDriverKeyPath: %ws\n", pszRegPath ));
#endif // SIGN_DEBUG_WINSTA

        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegPath, 0, KEY_READ,
               &hVidDriverKey ) != ERROR_SUCCESS ) {
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }

        //
        // Don't like to use constant strings, but this is the way
        // WINSRV does it...
        //
        dwLen = (MAX_PATH + 1) * sizeof(WCHAR) ;               

        if ( RegQueryValueEx( hVidDriverKey,
                              L"VgaCompatible",
                              NULL,
                              &dwType,
                              (PCHAR) pszDeviceKey,
                              &dwLen ) != ERROR_SUCCESS ) {
            RegCloseKey( hVidDriverKey );
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "DeviceKey: %ws\n", pszDeviceKey ));
#endif // SIGN_DEBUG_WINSTA


        dwLen = (MAX_PATH + 1) * sizeof(WCHAR); 
        if ( RegQueryValueEx( hVidDriverKey,
                              pszDeviceKey,
                              NULL,
                              &dwType,
                              (PCHAR) pszServiceKey,
                              &dwLen ) != ERROR_SUCCESS ) {
            RegCloseKey( hVidDriverKey );
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }
        RegCloseKey( hVidDriverKey );
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "ServiceKey: %ws\n", pszServiceKey ));
#endif // SIGN_DEBUG_WINSTA


        RtlInitUnicodeString( &KeyPath, pszServiceKey );
        InitializeObjectAttributes( &ObjectAttributes, &KeyPath,
                                    OBJ_CASE_INSENSITIVE, NULL, NULL );
        //
        // Must use NT Registry APIs since the ServiceKey key name from
        // the registry is in the form used by these APIs.
        //
        Status = NtOpenKey( &hServiceKey, GENERIC_READ, &ObjectAttributes );
        if ( !NT_SUCCESS( Status ) ) {
            DBGPRINT(( "TERMSRV: NtOpenKey failed, rc=%x\n", Status ));
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }

        //
        // Don't like to use constant strings, but this is the way
        // WINSRV does it...
        //
        RtlInitUnicodeString( &ValueName, L"InstalledDisplayDrivers" );
        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)pValueBuffer;
        Status = NtQueryValueKey( hServiceKey,
                                  &ValueName,
                                  KeyValuePartialInformation,
                                  (PVOID)KeyValueInfo,
                                  VALUE_BUFFER_SZ,
                                  &ValueLength );
        NtClose( hServiceKey );
        if ( !NT_SUCCESS( Status ) ) {
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }

        wcscpy( pszModulePath, szSystemDir );
        wcscat( pszModulePath, (PWCHAR)&KeyValueInfo->Data );
        wcscat( pszModulePath, L".DLL" );
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "==> VidDriverDLLPath: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

        if ( !VerifyFile( pszModulePath, &VfyLock ) ) {
             ReportStackLoadFailure(pszModulePath);
             Status = STATUS_UNSUCCESSFUL;
             MemFree(pszVidDriverName);
             MemFree(pszRegPath);
             MemFree(pszDeviceKey);
             MemFree(pszServiceKey);
             goto closevidkey;
        }

        MemFree(pszVidDriverName);
        MemFree(pszRegPath);
        MemFree(pszDeviceKey);
        MemFree(pszServiceKey);

    } // for all VIDEO subkeys

closevidkey:
    RegCloseKey( hVidKey );

exit:
    if (pszModulePath != NULL) {
        MemFree(pszModulePath);
        pszModulePath = NULL;
    }
    if (pValueBuffer != NULL) {
        MemFree(pValueBuffer);
        pValueBuffer = NULL;
    }
    return Status;
}


/*******************************************************************************
 *  VfyInit
 *   Sets up environment for Stack DLL verification.
 ******************************************************************************/
NTSTATUS VfyInit()
{
    GetSystemDirectory( szSystemDir, sizeof( szSystemDir )/ sizeof(WCHAR));
    wcscat( szSystemDir, L"\\" );
    wcscpy( szDriverDir, szSystemDir );
    wcscat( szDriverDir, L"Drivers\\" );

    return RtlInitializeCriticalSection(&VfyLock);
}



VOID WinstationUnloadProfile(PWINSTATION pWinStation)
{
#if 0
    NTSTATUS NtStatus;
    UNICODE_STRING  UnicodeString;
    BOOL bResult;

    // if this is not the last session for this user, then we do nothing.
    if (WinstationCountUserSessions(pWinStation->pProfileSid, pWinStation->LogonId) != 0) {
        return;
    }

    // Get the user hive name from user Sid.
    NtStatus = RtlConvertSidToUnicodeString( &UnicodeString, pWinStation->pProfileSid, (BOOLEAN)TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        DBGPRINT(("TERMSRV: WinstationUnloadProfile couldn't convert Sid to string. \n"));
        return;
    }

    // Unload the user's hive.
    bResult = WinstationRegUnLoadKey(HKEY_USERS, UnicodeString.Buffer);
    if (!bResult) {
        DBGPRINT(("TERMSRV: WinstationUnloadProfile failed. \n"));
    }

    // free allocated string.
    RtlFreeUnicodeString(&UnicodeString);
#endif
}


BOOL WinstationRegUnLoadKey(HKEY hKey, LPWSTR lpSubKey)
{
    BOOL bResult = TRUE;
    LONG error;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    ENTERCRIT(&UserProfileLock);
    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (NT_SUCCESS(Status)) {

        error = RegUnLoadKey(hKey, lpSubKey);

        if ( error != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: WinstationRegUnLoadKey RegUnLoadKey failed. \n"));
            bResult = FALSE;
        }

        //
        // Restore the privilege to its previous state
        //
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    } else {
        DBGPRINT(("TERMSRV: WinstationRegUnLoadKey adjust privilege failed. \n"));
        bResult = FALSE;
    }

    LEAVECRIT(&UserProfileLock);
    return bResult;
}


ULONG WinstationCountUserSessions(PSID pUserSid, ULONG CurrentLogonId)
{
   PLIST_ENTRY Head, Next;
   PWINSTATION pWinStation;
   ULONG Count = 0;
   PSID pSid;

   Head = &WinStationListHead;
   ENTERCRIT( &WinStationListLock );

   // Search the list for WinStations with a matching ListenName
   for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
       pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
       if (pWinStation->LogonId == CurrentLogonId) {
          continue;
       }
       if (pWinStation->pUserSid != NULL) {
          pSid =  pWinStation->pUserSid;
       } else {
          pSid = pWinStation->pProfileSid;
       }
       if ( (pSid != NULL) && RtlEqualSid( pSid, pUserSid ) ) {
           Count++;
       }
   }

   LEAVECRIT( &WinStationListLock );
   return Count;
}


PWINSTATION FindConsoleSession()
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    PWINSTATION pFoundWinStation = NULL;
    ULONG   uCount;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for a WinStation with the Console Session.
     */
searchagain:
    uCount = 0;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( pWinStation->fOwnsConsoleTerminal) {
           uCount++;

            /*
             * Now try to lock the WinStation.
             */
            if (pFoundWinStation == NULL){
               if ( !LockRefLock( &pWinStation->Lock ) )
                  goto searchagain;
                  pFoundWinStation = pWinStation;
            }
#if DBG
#else
    break;
#endif
        }
    }

    ASSERT((uCount <= 1));

    /*
     * If the WinStationList lock should not be held, then release it now.
     */
    LEAVECRIT( &WinStationListLock );

    return pFoundWinStation;
}


PWINSTATION FindIdleSessionZero()
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    PWINSTATION pFoundWinStation = NULL;
    ULONG   uCount;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for a WinStation with the Console Session.
     */
searchagain:
    uCount = 0;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {


        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if (pWinStation->LogonId == 0) { 
           uCount++;

            /*
             * Now try to lock the WinStation.
             */
            if (pFoundWinStation == NULL){
               if ( !LockRefLock( &pWinStation->Lock ) )
                  goto searchagain;
                  pFoundWinStation = pWinStation;
            }
#if DBG
#else
    break;
#endif
        }
    }

    ASSERT((uCount <= 1));

    /*
     * If the WinStationList lock should not be held, then release it now.
     */
    LEAVECRIT( &WinStationListLock );

    if (pFoundWinStation != NULL) {
        if ((pFoundWinStation->State == State_Disconnected) && 
            (!pFoundWinStation->Flags) &&
            (pFoundWinStation->UserName[0] == L'\0') ) {
            return pFoundWinStation;
        } else {
            ReleaseWinStation(pFoundWinStation);
        }
    }
    return NULL;
}


BOOLEAN WinStationCheckConsoleSession(VOID)
{
    PWINSTATION pWinStation;

    // Check if there already is a console session
    pWinStation = FindConsoleSession();
    if (pWinStation != NULL) {
        ReleaseWinStation(pWinStation);
        return TRUE;
    } else {
        if (gConsoleCreationDisable > 0) {
            return FALSE;   
        }
    }


    //
    // See if we can use a disconnected session zero that is not in use
    //

    if (ConsoleReconnectInfo.hStack != NULL) {
        pWinStation = FindIdleSessionZero();

        if (gConsoleCreationDisable > 0) {
            if (pWinStation != NULL) {
                ReleaseWinStation(pWinStation);
            }
            return FALSE;
        }

        if (pWinStation != NULL) {

            NTSTATUS Status;


            pWinStation->Flags |= WSF_CONNECT;
            Status = WinStationDoReconnect(pWinStation, &ConsoleReconnectInfo); 
            pWinStation->Flags &= ~WSF_CONNECT;

            ReleaseWinStation(pWinStation);

            if (NT_SUCCESS(Status)) {
               RtlZeroMemory(&ConsoleReconnectInfo,sizeof(RECONNECT_INFO));
               return TRUE;
            }else{
                CleanupReconnect(&ConsoleReconnectInfo);
                RtlZeroMemory(&ConsoleReconnectInfo,sizeof(RECONNECT_INFO));
            }
        }

    }


    // We nead to create a new session to connect to the Console
    pWinStation = FindIdleWinStation();
    if (pWinStation == NULL) {
        WinStationCreateWorker( NULL, NULL );
        pWinStation = FindIdleWinStation();
        if (pWinStation == NULL) {
            DBGPRINT(("TERMSRV: WinStationCheckConsoleSession - Fail to get an idle session\n"));
            return FALSE;
        }
    }

    if (gConsoleCreationDisable > 0) {
        ReleaseWinStation(pWinStation);
        return FALSE;
    }

    // Set the session as owning the Console and wakeup the WaitForConnectWorker
    // Actually there is more to do than that and I will need to process LLS licensing here.
    pWinStation->fOwnsConsoleTerminal = TRUE;
    pWinStation->State = State_ConnectQuery;
    pWinStation->Flags &= ~WSF_IDLE;
    wcscpy(pWinStation->WinStationName, L"Console");

    CleanupReconnect(&ConsoleReconnectInfo);
    RtlZeroMemory(&ConsoleReconnectInfo,sizeof(RECONNECT_INFO));
    NtSetEvent( pWinStation->ConnectEvent, NULL );
    ReleaseWinStation(pWinStation);

    // If necessary, create another idle WinStation to replace the one being connected

    NtSetEvent(WinStationIdleControlEvent, NULL);

    return TRUE;
}


/******************************************************************************
 * Tells win32k to load the console shadow mirroring driver
 *
 * ENTRY:
 *   pWinStation (input)
 *     Pointer to the console Winstation.
 *   pClientConfig (input)
 *     Pointer to the configuration of the shadow client.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *   STATUS_xxx     - error
 *****************************************************************************/
NTSTATUS ConsoleShadowStart( IN PWINSTATION pWinStation,
                             IN PWINSTATIONCONFIG2 pClientConfig,
                             IN PVOID pModuleData,
                             IN ULONG ModuleDataLength)
{
    NTSTATUS Status;
    WINSTATION_APIMSG WMsg;
    ULONG ReturnLength;

    TRACE((hTrace, TC_ICASRV, TT_API1, "CONSOLE REMOTING: LOAD DD\n"));

    Status = NtCreateEvent( &pWinStation->ShadowDisplayChangeEvent, EVENT_ALL_ACCESS,
                            NULL, NotificationEvent, FALSE );
    if ( !NT_SUCCESS( Status) ) {
        goto badevent;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->ShadowDisplayChangeEvent,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hDisplayChangeEvent,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto badevent;
    }

    /*
     *  Read Wd, Cd and Pd configuration data from registry
     */
    Status = RegConsoleShadowQuery( SERVERNAME_CURRENT,
                                 pWinStation->WinStationName,
                                 pClientConfig->Wd.WdPrefix,
                                 &pWinStation->Config,
                                 sizeof(WINSTATIONCONFIG2),
                                 &ReturnLength );
    if ( !NT_SUCCESS(Status) ) {
        goto badconfig;
    }


    /*
     * Build the Console Stack.
     * We need this special stack for the Console Shadow.
     */ 
    Status = IcaOpen( &pWinStation->hIca );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV IcaOpen for console stack : Error 0x%x from IcaOpen, last error %d\n",
                  Status, GetLastError() ));
        goto badopen;
    }

    Status = IcaStackOpen( pWinStation->hIca, Stack_Console,
                           (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV IcaOpen for console stack : Error 0x%x from IcaOpen, last error %d\n",
                  Status, GetLastError() ));
        goto badstackopen;
    }


    DBGPRINT(("WinStationStart: pushing stack for console...\n"));

    /*
     * Load and initialize the WinStation extensions
     */
    pWinStation->pWsx = FindWinStationExtensionDll(
                                  pWinStation->Config.Wd.WsxDLL,
                                  pWinStation->Config.Wd.WdFlag );
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxWinStationInitialize )
    {
        Status = pWinStation->pWsx->pWsxWinStationInitialize(
                                      &pWinStation->pWsxContext );
    }

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV IcaOpen for console stack : Error 0x%x from IcaOpen, last error %d\n",
                  Status, GetLastError() ));
        goto badextension;
    }

    /*
     * Load the stack
     */
    Status = IcaPushConsoleStack( (HANDLE)(pWinStation->hStack),
                                  pWinStation->WinStationName,
                                  &pWinStation->Config,
                                  pModuleData,
                                  ModuleDataLength);

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV IcaOpen for console stack : Error 0x%x from IcaOpen, last error %d\n",
                  Status, GetLastError() ));
        goto badpushstack;
    }

    DBGPRINT(("WinStationStart: pushed stack for console\n"));



    /*
     * This code is based on that in WaitForConnectWorker (see wait.c)
     */
    if ( !(pWinStation->pWsx) ||
         !(pWinStation->pWsx->pWsxInitializeClientData) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, No pWsxInitializeClientData\n" ));
        Status = STATUS_CTX_SHADOW_INVALID;
        goto done;
    }

    pWinStation->State = State_Idle;

    /*
     * Open the beep channel (if not already) and duplicate it.
     * This is one channel that both CSR and ICASRV have open.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Beep,
                             NULL,
                             &pWinStation->hIcaBeepChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, IcaChannelOpen 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaBeepChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaBeepChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Open the thinwire channel (if not already) and duplicate it.
     * This is one channel that both CSR and ICASRV have open.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Virtual,
                             VIRTUAL_THINWIRE,
                             &pWinStation->hIcaThinwireChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, IcaChannelOpen 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaThinwireChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaThinwireChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                  IOCTL_ICA_CHANNEL_ENABLE_SHADOW,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Video channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Video,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaVideoChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Keyboard channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Keyboard,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaKeyboardChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Mouse channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Mouse,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaMouseChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Command channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Command,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaCommandChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Secure any virtual channels
     */
    VirtualChannelSecurity( pWinStation );

    /*
     * Get the client data
     */
    Status = pWinStation->pWsx->pWsxInitializeClientData(
                         pWinStation->pWsxContext,
                         pWinStation->hStack,
                         pWinStation->hIca,
                         pWinStation->hIcaThinwireChannel,
                         pWinStation->VideoModuleName,
                         sizeof(pWinStation->VideoModuleName),
                         &pWinStation->Config.Config.User,
                         &pWinStation->Client.HRes,
                         &pWinStation->Client.VRes,
                         &pWinStation->Client.ColorDepth,
                         &WMsg.u.DoConnect );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, InitializeClientData failed 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Store WinStation name in connect msg
     */
    RtlCopyMemory( WMsg.u.DoConnect.WinStationName,
                   pWinStation->WinStationName,
                   sizeof(WINSTATIONNAME) );

    /*
     * Save screen resolution, and color depth
     */
    WMsg.u.DoConnect.HRes = pWinStation->Client.HRes;
    WMsg.u.DoConnect.VRes = pWinStation->Client.VRes;

    /*
     * Translate the color to the format excpected in winsrv
     */

    switch(pWinStation->Client.ColorDepth){
    case 1:
       WMsg.u.DoConnect.ColorDepth=4 ; // 16 colors
      break;
    case 2:
       WMsg.u.DoConnect.ColorDepth=8 ; // 256
       break;
    case 4:
       WMsg.u.DoConnect.ColorDepth= 16;// 64K
       break;
    case 8:
       WMsg.u.DoConnect.ColorDepth= 24;// 16M
       break;
#define DC_HICOLOR
#ifdef DC_HICOLOR
    case 16:
       WMsg.u.DoConnect.ColorDepth= 15;// 32K
       break;
#endif
    default:
       WMsg.u.DoConnect.ColorDepth=8 ;
       break;
    }

    /*
     * Tell Win32 about the connection
     */
    WMsg.ApiNumber = SMWinStationDoConnect;
    WMsg.u.DoConnect.ConsoleShadowFlag = TRUE;

    Status = SendWinStationCommand( pWinStation, &WMsg, 60 );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: SMWinStationDoConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, SendWinStationCommand failed 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * This flag is important: without it, WinStationDoDisconnect won't let
     * Win32k know about the disconnection, so it can't unload the chained DD.
     */
    pWinStation->StateFlags |= WSF_ST_CONNECTED_TO_CSRSS;

    /*
     * Set connect time
     */
    NtQuerySystemTime( &pWinStation->ConnectTime );

    /*
     * no need for logon timers here - we don't want to
     * stop the console session!
     */

    TRACE((hTrace, TC_ICASRV, TT_API1, "CONSOLE REMOTING: LOADED DD\n"));
    pWinStation->State = State_Active;

    return Status;

    /*
     * Error paths:
     */
done:
    // to undo the push stack, does the IcaStackClose below suffice?

    pWinStation->State = State_Active;

badpushstack:
    if (pWinStation->pWsxContext) {
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxWinStationRundown ) {
            pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
        }
        pWinStation->pWsxContext = NULL;
    }

badextension:
    pWinStation->pWsx = NULL;

    IcaStackClose( pWinStation->hStack );

badstackopen:
    IcaClose( pWinStation->hIca );

badopen:
    pWinStation->Config = gConsoleConfig;

badconfig:
    NtClose(pWinStation->ShadowDisplayChangeEvent);
    pWinStation->ShadowDisplayChangeEvent = NULL;

badevent:
    return Status;
}


/******************************************************************************
 * Tells win32k to unload the console shadow mirroring driver
 *
 * ENTRY:
 *   pWinStation (input)
 *     Pointer to the console Winstation.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *   STATUS_xxx     - error
 *****************************************************************************/
NTSTATUS ConsoleShadowStop(PWINSTATION pWinStation)
{
    WINSTATION_APIMSG ConsoleShadowStopMsg;
    NTSTATUS Status;

    /*
     * Tell Win32k to unload the chained DD
     */
    ConsoleShadowStopMsg.ApiNumber = SMWinStationDoDisconnect;
    ConsoleShadowStopMsg.u.DoDisconnect.ConsoleShadowFlag = TRUE;
    Status = SendWinStationCommand( pWinStation, &ConsoleShadowStopMsg, 600 );
    if ( !NT_SUCCESS(Status) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: CSR ConsoleShadowStop failed LogonId=%d Status=0x%x\n",
                   pWinStation->LogonId, Status ));
    }

    /*
     * No matter what happened, everything must be undone.
     */
    if (pWinStation->pWsxContext) {
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxWinStationRundown ) {
            pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
        }
        pWinStation->pWsxContext = NULL;
    }

    pWinStation->pWsx = NULL;

    IcaStackClose( pWinStation->hStack );

    IcaClose( pWinStation->hIca );

    /*
     * Restore console config.
     */
    pWinStation->Config = gConsoleConfig;

    NtClose(pWinStation->ShadowDisplayChangeEvent);
    pWinStation->ShadowDisplayChangeEvent = NULL;

    return Status;
}



ULONG CodePairs[] = {

// Very general NT Status

    STATUS_SUCCESS,                 NO_ERROR,
    STATUS_NO_MEMORY,               ERROR_NOT_ENOUGH_MEMORY,
    STATUS_ACCESS_DENIED,           ERROR_ACCESS_DENIED,
    STATUS_INSUFFICIENT_RESOURCES,  ERROR_NO_SYSTEM_RESOURCES,
    STATUS_BUFFER_TOO_SMALL,        ERROR_INSUFFICIENT_BUFFER,
    STATUS_OBJECT_NAME_NOT_FOUND,   ERROR_FILE_NOT_FOUND,
    STATUS_NOT_SUPPORTED,           ERROR_NOT_SUPPORTED,
  
// RPC specific Status  
  
    RPC_NT_SERVER_UNAVAILABLE, RPC_S_SERVER_UNAVAILABLE,
    RPC_NT_INVALID_STRING_BINDING, RPC_S_INVALID_STRING_BINDING,
    RPC_NT_WRONG_KIND_OF_BINDING, RPC_S_WRONG_KIND_OF_BINDING,
    RPC_NT_PROTSEQ_NOT_SUPPORTED, RPC_S_PROTSEQ_NOT_SUPPORTED,
    RPC_NT_INVALID_RPC_PROTSEQ, RPC_S_INVALID_RPC_PROTSEQ,
    RPC_NT_INVALID_STRING_UUID, RPC_S_INVALID_STRING_UUID,
    RPC_NT_INVALID_ENDPOINT_FORMAT, RPC_S_INVALID_ENDPOINT_FORMAT,
    RPC_NT_INVALID_NET_ADDR, RPC_S_INVALID_NET_ADDR,
    RPC_NT_NO_ENDPOINT_FOUND, RPC_S_NO_ENDPOINT_FOUND,
    RPC_NT_INVALID_TIMEOUT, RPC_S_INVALID_TIMEOUT,
    RPC_NT_OBJECT_NOT_FOUND, RPC_S_OBJECT_NOT_FOUND,
    RPC_NT_ALREADY_REGISTERED, RPC_S_ALREADY_REGISTERED,
    RPC_NT_TYPE_ALREADY_REGISTERED, RPC_S_TYPE_ALREADY_REGISTERED,
    RPC_NT_ALREADY_LISTENING, RPC_S_ALREADY_LISTENING,
    RPC_NT_NO_PROTSEQS_REGISTERED, RPC_S_NO_PROTSEQS_REGISTERED,
    RPC_NT_NOT_LISTENING, RPC_S_NOT_LISTENING,
    RPC_NT_UNKNOWN_MGR_TYPE, RPC_S_UNKNOWN_MGR_TYPE,
    RPC_NT_UNKNOWN_IF, RPC_S_UNKNOWN_IF,
    RPC_NT_NO_BINDINGS, RPC_S_NO_BINDINGS,
    RPC_NT_NO_MORE_BINDINGS, RPC_S_NO_MORE_BINDINGS,
    RPC_NT_NO_PROTSEQS, RPC_S_NO_PROTSEQS,
    RPC_NT_CANT_CREATE_ENDPOINT, RPC_S_CANT_CREATE_ENDPOINT,
    RPC_NT_OUT_OF_RESOURCES, RPC_S_OUT_OF_RESOURCES,
    RPC_NT_SERVER_TOO_BUSY, RPC_S_SERVER_TOO_BUSY,
    RPC_NT_INVALID_NETWORK_OPTIONS, RPC_S_INVALID_NETWORK_OPTIONS,
    RPC_NT_NO_CALL_ACTIVE, RPC_S_NO_CALL_ACTIVE,
    RPC_NT_CALL_FAILED, RPC_S_CALL_FAILED,
    RPC_NT_CALL_FAILED_DNE, RPC_S_CALL_FAILED_DNE,
    RPC_NT_PROTOCOL_ERROR, RPC_S_PROTOCOL_ERROR,
    RPC_NT_UNSUPPORTED_TRANS_SYN, RPC_S_UNSUPPORTED_TRANS_SYN,
    RPC_NT_UNSUPPORTED_TYPE, RPC_S_UNSUPPORTED_TYPE,
    RPC_NT_INVALID_TAG, RPC_S_INVALID_TAG,
    RPC_NT_INVALID_BOUND, RPC_S_INVALID_BOUND,
    RPC_NT_NO_ENTRY_NAME, RPC_S_NO_ENTRY_NAME,
    RPC_NT_INVALID_NAME_SYNTAX, RPC_S_INVALID_NAME_SYNTAX,
    RPC_NT_UNSUPPORTED_NAME_SYNTAX, RPC_S_UNSUPPORTED_NAME_SYNTAX,
    RPC_NT_UUID_NO_ADDRESS, RPC_S_UUID_NO_ADDRESS,
    RPC_NT_DUPLICATE_ENDPOINT, RPC_S_DUPLICATE_ENDPOINT,
    RPC_NT_UNKNOWN_AUTHN_TYPE, RPC_S_UNKNOWN_AUTHN_TYPE,
    RPC_NT_MAX_CALLS_TOO_SMALL, RPC_S_MAX_CALLS_TOO_SMALL,
    RPC_NT_STRING_TOO_LONG, RPC_S_STRING_TOO_LONG,
    RPC_NT_PROTSEQ_NOT_FOUND, RPC_S_PROTSEQ_NOT_FOUND,
    RPC_NT_PROCNUM_OUT_OF_RANGE, RPC_S_PROCNUM_OUT_OF_RANGE,
    RPC_NT_BINDING_HAS_NO_AUTH, RPC_S_BINDING_HAS_NO_AUTH,
    RPC_NT_UNKNOWN_AUTHN_SERVICE, RPC_S_UNKNOWN_AUTHN_SERVICE,
    RPC_NT_UNKNOWN_AUTHN_LEVEL, RPC_S_UNKNOWN_AUTHN_LEVEL,
    RPC_NT_INVALID_AUTH_IDENTITY, RPC_S_INVALID_AUTH_IDENTITY,
    RPC_NT_UNKNOWN_AUTHZ_SERVICE, RPC_S_UNKNOWN_AUTHZ_SERVICE,
    RPC_NT_NOTHING_TO_EXPORT, RPC_S_NOTHING_TO_EXPORT,
    RPC_NT_INCOMPLETE_NAME, RPC_S_INCOMPLETE_NAME,
    RPC_NT_INVALID_VERS_OPTION, RPC_S_INVALID_VERS_OPTION,
    RPC_NT_NO_MORE_MEMBERS, RPC_S_NO_MORE_MEMBERS,
    RPC_NT_NOT_ALL_OBJS_UNEXPORTED, RPC_S_NOT_ALL_OBJS_UNEXPORTED,
    RPC_NT_INTERFACE_NOT_FOUND, RPC_S_INTERFACE_NOT_FOUND,
    RPC_NT_ENTRY_ALREADY_EXISTS, RPC_S_ENTRY_ALREADY_EXISTS,
    RPC_NT_ENTRY_NOT_FOUND, RPC_S_ENTRY_NOT_FOUND,
    RPC_NT_NAME_SERVICE_UNAVAILABLE, RPC_S_NAME_SERVICE_UNAVAILABLE,
    RPC_NT_INVALID_NAF_ID, RPC_S_INVALID_NAF_ID,
    RPC_NT_CANNOT_SUPPORT, RPC_S_CANNOT_SUPPORT,
    RPC_NT_NO_CONTEXT_AVAILABLE, RPC_S_NO_CONTEXT_AVAILABLE,
    RPC_NT_INTERNAL_ERROR, RPC_S_INTERNAL_ERROR,
    RPC_NT_ZERO_DIVIDE, RPC_S_ZERO_DIVIDE,
    RPC_NT_ADDRESS_ERROR, RPC_S_ADDRESS_ERROR,
    RPC_NT_FP_DIV_ZERO, RPC_S_FP_DIV_ZERO,
    RPC_NT_FP_UNDERFLOW, RPC_S_FP_UNDERFLOW,
    RPC_NT_FP_OVERFLOW, RPC_S_FP_OVERFLOW,
    RPC_NT_NO_MORE_ENTRIES, RPC_X_NO_MORE_ENTRIES,
    RPC_NT_SS_CHAR_TRANS_OPEN_FAIL, RPC_X_SS_CHAR_TRANS_OPEN_FAIL,
    RPC_NT_SS_CHAR_TRANS_SHORT_FILE, RPC_X_SS_CHAR_TRANS_SHORT_FILE,
    RPC_NT_SS_CONTEXT_MISMATCH, ERROR_INVALID_HANDLE,
    RPC_NT_SS_CONTEXT_DAMAGED, RPC_X_SS_CONTEXT_DAMAGED,
    RPC_NT_SS_HANDLES_MISMATCH, RPC_X_SS_HANDLES_MISMATCH,
    RPC_NT_SS_CANNOT_GET_CALL_HANDLE, RPC_X_SS_CANNOT_GET_CALL_HANDLE,
    RPC_NT_NULL_REF_POINTER, RPC_X_NULL_REF_POINTER,
    RPC_NT_ENUM_VALUE_OUT_OF_RANGE, RPC_X_ENUM_VALUE_OUT_OF_RANGE,
    RPC_NT_BYTE_COUNT_TOO_SMALL, RPC_X_BYTE_COUNT_TOO_SMALL,
    RPC_NT_BAD_STUB_DATA, RPC_X_BAD_STUB_DATA,
    RPC_NT_INVALID_OBJECT, RPC_S_INVALID_OBJECT,
    RPC_NT_GROUP_MEMBER_NOT_FOUND, RPC_S_GROUP_MEMBER_NOT_FOUND,
    RPC_NT_NO_INTERFACES, RPC_S_NO_INTERFACES,
    RPC_NT_CALL_CANCELLED, RPC_S_CALL_CANCELLED,
    RPC_NT_BINDING_INCOMPLETE, RPC_S_BINDING_INCOMPLETE,
    RPC_NT_COMM_FAILURE, RPC_S_COMM_FAILURE,
    RPC_NT_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,
    RPC_NT_NO_PRINC_NAME, RPC_S_NO_PRINC_NAME,
    RPC_NT_NOT_RPC_ERROR, RPC_S_NOT_RPC_ERROR,
    RPC_NT_UUID_LOCAL_ONLY, RPC_S_UUID_LOCAL_ONLY,
    RPC_NT_SEC_PKG_ERROR, RPC_S_SEC_PKG_ERROR,
    RPC_NT_NOT_CANCELLED, RPC_S_NOT_CANCELLED,
    RPC_NT_INVALID_ES_ACTION, RPC_X_INVALID_ES_ACTION,
    RPC_NT_WRONG_ES_VERSION, RPC_X_WRONG_ES_VERSION,
    RPC_NT_WRONG_STUB_VERSION, RPC_X_WRONG_STUB_VERSION,
    RPC_NT_INVALID_PIPE_OBJECT,    RPC_X_INVALID_PIPE_OBJECT,
    RPC_NT_WRONG_PIPE_VERSION,     RPC_X_WRONG_PIPE_VERSION,
    RPC_NT_SEND_INCOMPLETE,        RPC_S_SEND_INCOMPLETE,
    RPC_NT_INVALID_ASYNC_HANDLE,   RPC_S_INVALID_ASYNC_HANDLE,
    RPC_NT_INVALID_ASYNC_CALL,     RPC_S_INVALID_ASYNC_CALL,
    RPC_NT_PIPE_CLOSED,            RPC_X_PIPE_CLOSED,
    RPC_NT_PIPE_EMPTY,             RPC_X_PIPE_EMPTY,
    RPC_NT_PIPE_DISCIPLINE_ERROR,  RPC_X_PIPE_DISCIPLINE_ERROR,

 
    // Terminal Server Specific Status.

    STATUS_CTX_CLOSE_PENDING,               ERROR_CTX_CLOSE_PENDING,
    STATUS_CTX_NO_OUTBUF,                   ERROR_CTX_NO_OUTBUF,
    STATUS_CTX_MODEM_INF_NOT_FOUND,         ERROR_CTX_MODEM_INF_NOT_FOUND,
    STATUS_CTX_INVALID_MODEMNAME,           ERROR_CTX_INVALID_MODEMNAME,
    STATUS_CTX_RESPONSE_ERROR,              ERROR_CTX_MODEM_RESPONSE_ERROR,
    STATUS_CTX_MODEM_RESPONSE_TIMEOUT,      ERROR_CTX_MODEM_RESPONSE_TIMEOUT,
    STATUS_CTX_MODEM_RESPONSE_NO_CARRIER,   ERROR_CTX_MODEM_RESPONSE_NO_CARRIER,
    STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE,  ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE,
    STATUS_CTX_MODEM_RESPONSE_BUSY,         ERROR_CTX_MODEM_RESPONSE_BUSY,
    STATUS_CTX_MODEM_RESPONSE_VOICE,        ERROR_CTX_MODEM_RESPONSE_VOICE,
    STATUS_CTX_TD_ERROR,                    ERROR_CTX_TD_ERROR,
    STATUS_LPC_REPLY_LOST,                  ERROR_CONNECTION_ABORTED,
    STATUS_CTX_WINSTATION_NAME_INVALID,     ERROR_CTX_WINSTATION_NAME_INVALID,
    STATUS_CTX_WINSTATION_NOT_FOUND,        ERROR_CTX_WINSTATION_NOT_FOUND,
    STATUS_CTX_WINSTATION_NAME_COLLISION,   ERROR_CTX_WINSTATION_ALREADY_EXISTS,
    STATUS_CTX_WINSTATION_BUSY,             ERROR_CTX_WINSTATION_BUSY,
    STATUS_CTX_GRAPHICS_INVALID,            ERROR_CTX_GRAPHICS_INVALID,
    STATUS_CTX_BAD_VIDEO_MODE,              ERROR_CTX_BAD_VIDEO_MODE,
    STATUS_CTX_NOT_CONSOLE,                 ERROR_CTX_NOT_CONSOLE,
    STATUS_CTX_CLIENT_QUERY_TIMEOUT,        ERROR_CTX_CLIENT_QUERY_TIMEOUT,
    STATUS_CTX_CONSOLE_DISCONNECT,          ERROR_CTX_CONSOLE_DISCONNECT,
    STATUS_CTX_CONSOLE_CONNECT,             ERROR_CTX_CONSOLE_CONNECT,
    STATUS_CTX_SHADOW_DENIED,               ERROR_CTX_SHADOW_DENIED,
    STATUS_CTX_SHADOW_INVALID,              ERROR_CTX_SHADOW_INVALID,
    STATUS_CTX_SHADOW_DISABLED,             ERROR_CTX_SHADOW_DISABLED,
    STATUS_CTX_WINSTATION_ACCESS_DENIED,    ERROR_CTX_WINSTATION_ACCESS_DENIED,
    STATUS_CTX_INVALID_PD,                  ERROR_CTX_INVALID_PD,
    STATUS_CTX_PD_NOT_FOUND,                ERROR_CTX_PD_NOT_FOUND,
    STATUS_CTX_INVALID_WD,                  ERROR_CTX_INVALID_WD,
    STATUS_CTX_WD_NOT_FOUND,                ERROR_CTX_WD_NOT_FOUND,
    STATUS_CTX_CLIENT_LICENSE_IN_USE,       ERROR_CTX_CLIENT_LICENSE_IN_USE, 
    STATUS_CTX_CLIENT_LICENSE_NOT_SET,      ERROR_CTX_CLIENT_LICENSE_NOT_SET,
    STATUS_CTX_LICENSE_NOT_AVAILABLE,       ERROR_CTX_LICENSE_NOT_AVAILABLE, 
    STATUS_CTX_LICENSE_CLIENT_INVALID,      ERROR_CTX_LICENSE_CLIENT_INVALID,
    STATUS_CTX_LICENSE_EXPIRED,             ERROR_CTX_LICENSE_EXPIRED,       

};


/*
 * WinStationWinerrorToNtStatus
 * Translate a Windows error code into an NTSTATUS code.
 */

NTSTATUS
WinStationWinerrorToNtStatus(ULONG ulWinError)
{
    ULONG ulIndex;

    for (ulIndex = 0 ; ulIndex < sizeof(CodePairs)/sizeof(CodePairs[0]) ; ulIndex+=2) {
        if (CodePairs[ ulIndex+1 ] == ulWinError ) {
            return (NTSTATUS) CodePairs[ ulIndex];
        }
    }
    return STATUS_UNSUCCESSFUL;
}



/*
 * WinStationSetMaxOustandingConnections() set the default values
 * for the maximum number of outstanding connection connections.
 * Reads the registry configuration for it if it exists.
 */

VOID
WinStationSetMaxOustandingConnections()
{
    SYSTEM_BASIC_INFORMATION BasicInfo;
    HKEY hKey;
    NTSTATUS Status;
    BOOL bLargeMachine = FALSE;


    // Initialize date of last delayed connection that was logged into
    // event log. In order not to flood event log with what may not be a DOS
    // attack but just a normal regulation action, delayed connection are not
    // logged more than once in 24h.

    GetSystemTime(&LastLoggedDelayConnection);

    // Init the default values for maximum outstanding connection and
    // Maximumn outstanding connections from single IP address. For
    // Non server platforms these are fixed values.

    if (!gbServer) {
        MaxOutStandingConnect = MAX_DEFAULT_CONNECTIONS_PRO;
        MaxSingleOutStandingConnect = MAX_DEFAULT_SINGLE_CONNECTIONS_PRO;
    }  else {
        // Determine if this Machine has over 512Mb of memory
        // In order to set defaults Values (registry settings overide this anyway).
        // Default value are not changed for machines over 512 Mb : Session regulation
        // is trigered if we have 50 outstanding connection and we will wait 30 seconds
        // before acception new connections. For machines with less than 512 Mb, regulation
        // needs to be stronger : it is trigered at lower number of  outstanding connections and we will
        // wait 70 seconds before accepting new connections.

        MaxOutStandingConnect = MAX_DEFAULT_CONNECTIONS;

        Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    NULL
                    );

        if (NT_SUCCESS(Status)) {
            if (BasicInfo.PageSize > 1024*1024) {
                MaxOutStandingConnect = MAX_DEFAULT_CONNECTIONS;
                DelayConnectionTime = 30*1000;

            }else{
                ULONG ulPagesPerMeg = 1024*1024/BasicInfo.PageSize;
                ULONG ulMemSizeInMegabytes = BasicInfo.NumberOfPhysicalPages/ulPagesPerMeg ;

                if (ulMemSizeInMegabytes >= 512) {
                    MaxOutStandingConnect = MAX_DEFAULT_CONNECTIONS;
                    DelayConnectionTime = 70*1000;
                } else if (ulMemSizeInMegabytes >= 256) {
                    MaxOutStandingConnect = 15;
                    DelayConnectionTime = 70*1000;

                } else if (ulMemSizeInMegabytes >= 128) {
                    MaxOutStandingConnect = 10;
                    DelayConnectionTime = 70*1000;
                } else {
                    MaxOutStandingConnect = 5;
                    DelayConnectionTime = 70*1000;
                }
            }
        }


        //
        //  set max number of outstanding connection from single IP
        //
        if ( MaxOutStandingConnect < MAX_SINGLE_CONNECT_THRESHOLD_DIFF*5)
        {
            MaxSingleOutStandingConnect = MaxOutStandingConnect - 1;
        } else {
            MaxSingleOutStandingConnect = MaxOutStandingConnect - MAX_SINGLE_CONNECT_THRESHOLD_DIFF;
        }
    }
    

}



/*
 * IsClientOnSameMachine() Determines if the client is running on the same 
 * machine when this posible (currently implemted only for clients connected
 * through TCP/IP). When we can detect the client is on the same machine, we can 
 * earlier fail operations like trying to reconecting the console to that client.
 * This way we can fail the operation quicly without going through annoying 
 * protocol timeouts.
 */

BOOL 
IsClientOnSameMachine(PWINSTATION pWinStation)

{
    ADDRINFO *AddrInfo, *AI;
    int RetVal;
    struct sockaddr_in *pIPV4addr;
    struct sockaddr_in6 *pIPV6addr;
    PBYTE pServerAddrByte;
    PBYTE pClientAddrByte;
    DWORD dwIP4[4];
    BYTE  achIP4[4];
    char  achCompterName[256];
    DWORD dwComputerNameSize;


    //Return if WinSock couldn't be initialized
    if (!gbWinSockInitialized) {
        return FALSE;
    }

    // setup the client addrees for comparing with server adresses

    switch (pWinStation->Client.ClientAddressFamily ) {
    
    // For IPV4 the address in client data is represented as a WCHAR string
    case AF_INET:
        swscanf(pWinStation->Client.ClientAddress, L"%u.%u.%u.%u", &dwIP4[0], &dwIP4[1], &dwIP4[2], &dwIP4[3] );
        achIP4[0] = (BYTE) dwIP4[0];
        achIP4[1] = (BYTE) dwIP4[1];
        achIP4[2] = (BYTE) dwIP4[2];
        achIP4[3] = (BYTE) dwIP4[3];
        pClientAddrByte = &achIP4[0];
        break;

    // For IPv6 the adress in client data is assumed to be in binary form
    case AF_INET6:
        pClientAddrByte = (PBYTE) pWinStation->Client.ClientAddress;
        break;

    default:
        return FALSE;
    }

    // Get the server adresses.


    dwComputerNameSize = sizeof(achCompterName);
    if (!GetComputerNameA(achCompterName,&dwComputerNameSize)) {
        return FALSE;
    }


    RetVal = getaddrinfo(achCompterName, NULL, NULL, &AddrInfo);
    if (RetVal != 0) {
        DBGPRINT (("Cannot resolve address, error: %d\n", RetVal));
        return FALSE;

    } else{
        // Compare all server adresses with client till a match is found.


        for (AI = AddrInfo; AI != NULL; AI = AI->ai_next) {

            if (pWinStation->Client.ClientAddressFamily == (ULONG)AI->ai_family &&
                AI->ai_addrlen <= sizeof(pWinStation->Client.ClientAddress) ) {

                switch (pWinStation->Client.ClientAddressFamily) {
                
                case AF_INET:
                    if (AI->ai_addrlen >= sizeof(struct sockaddr_in)) {
                        pIPV4addr = (struct sockaddr_in *) AI->ai_addr;
                        pServerAddrByte = (PBYTE)&pIPV4addr->sin_addr;
                        if (RtlEqualMemory(pClientAddrByte,pServerAddrByte, 4)) {
                            return TRUE;
                        }
                    }
                    break;

                case AF_INET6:
                    if (AI->ai_addrlen >= sizeof(struct sockaddr_in6)) {
                        pIPV6addr = (struct sockaddr_in6 *) AI->ai_addr;
                        pServerAddrByte = (PBYTE)&pIPV6addr->sin6_addr;
                        if (RtlEqualMemory(pClientAddrByte,pServerAddrByte, 16)) {
                            return TRUE;
                        }
                    }
                    break;

                default:
                    break;
                }
            }

        }
    }
    

    return FALSE;

#if 0            
            
    char hostname[(512+1)*sizeof(TCHAR)];
    int err;
    int i,j;
    struct hostent* phostent;
    
    err=gethostname(hostname, sizeof(hostname));
    if (err == 0) {
        ;
        if ( (phostent = gethostbyname(hostname))  !=NULL) {
            switch(phostent->h_addrtype){
            case AF_INET:
                if (pWinStation->Client.ClientAddressFamily == AF_INET) {
                    BYTE ipaddress[4];
                    swscanf(pWinStation->Client.ClientAddress, L"%u.%u.%u.%u", &ipaddress[0], &ipaddress[1], &ipaddress[2], &ipaddress[3] );

                    j=0;
                    while (phostent->h_addr_list[j] != NULL) {
                        for (i=0; i < 4 ; i++) {
                            if (ipaddress[i] != (BYTE) phostent->h_addr_list[j][i]) {
                                break;
                            }
                            if (i == 3 ) {
                                return TRUE;
                            }
                        }
                        j++;
                    }
                }

            default:
                break;
            }

        }

    }
    return FALSE;
#endif
}
/*
 * Make sure we can Preallocate an Idle session before allowing console disconnect.
 *
 */

NTSTATUS
CheckIdleWinstation()
{
    PWINSTATION pWinStation;
    NTSTATUS Status;
    pWinStation = FindIdleWinStation();
    if ( pWinStation == NULL ) {

        /*
         * Create another idle WinStation
         */
        Status = WinStationCreateWorker( NULL, NULL );
        if ( NT_SUCCESS( Status ) ) {
            pWinStation = FindIdleWinStation();
            if ( pWinStation == NULL ) {
                return STATUS_INSUFFICIENT_RESOURCES;

            }
        } else{
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    ReleaseWinStation(pWinStation);
    return STATUS_SUCCESS;

}

NTSTATUS
InitializeWinStationSecurityLock(
    VOID
    )
{
    NTSTATUS Status ;

    try 
    {
        RtlInitializeResource( &WinStationSecurityLock );
        Status = STATUS_SUCCESS ;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }


    return Status;
}

//gets the product id from the registry
NTSTATUS 
GetProductIdFromRegistry( WCHAR* DigProductId, DWORD dwSize )
{
    HKEY hKey = NULL;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ZeroMemory( DigProductId, dwSize );
    
    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_WINDOWS_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        DWORD dwType = REG_SZ;
        if( RegQueryValueEx( hKey, 
                             L"ProductId", NULL, &dwType,
                             (LPBYTE)DigProductId, 
                             &dwSize
                             ) == ERROR_SUCCESS )
            status = STATUS_SUCCESS;
    }

    if (hKey)
      RegCloseKey( hKey );

    return status;
}

//
//  Gets the remote IP address of the connections
//  and supports statistics of how many outstanding connections
//  are there for this client, if the number of outstanding connections
//  reaches MaxSingleOutStandingConnections, *pbBlocked is returned FALSE
//  the functions returns TRUE on success
//
//  Paramters:
//      pContext
//      pEndpoint   - handle of this connection
//      EndpointLength - td layer needs the length
//      pin_addr    - returns remote IP address
//      pbBlocked   - returns TRUE if the connection has to be blocked, because of excessive number of
//                    outstanding connections
//
BOOL
Filter_AddOutstandingConnection(
        IN HANDLE   pContext,
        IN PVOID    pEndpoint,
        IN ULONG    EndpointLength,
        OUT PBYTE   pin_addr,
        OUT PUINT   puAddrSize,
        OUT BOOLEAN *pbBlocked
    )
{
    BOOL rv = FALSE;
    PTS_OUTSTANDINGCONNECTION pIter, pPrev;
    TS_OUTSTANDINGCONNECTION key;
    struct  sockaddr_in6 addr6;
    ULONG   AddrBytesReturned;
    NTSTATUS Status;
    PVOID   paddr;
    BOOL    bLocked = FALSE;
    PVOID   bSucc;
    BOOLEAN bNewElement;
    ULONGLONG currentTime;


    *pbBlocked = FALSE;

    Status = IcaStackIoControl(  pContext,
                                 IOCTL_TS_STACK_QUERY_REMOTEADDRESS,
                                 pEndpoint,
                                 EndpointLength,
                                 &addr6,
                                 sizeof( addr6 ),
                                 &AddrBytesReturned );
    if ( !NT_SUCCESS( Status ))
    {
        goto exitpt;
    }

    if ( AF_INET == addr6.sin6_family )
    {
        key.uAddrSize = 4;
        paddr = &(((struct sockaddr_in *)&addr6)->sin_addr.s_addr);
    } else if ( AF_INET6 == addr6.sin6_family )
    {
        key.uAddrSize = 16;
        paddr = &(addr6.sin6_addr);
    } else {
        ASSERT( 0 );
    }
    ASSERT ( *puAddrSize >= key.uAddrSize );

    RtlCopyMemory( pin_addr, paddr, key.uAddrSize );
    *puAddrSize = key.uAddrSize;

    ENTERCRIT( &FilterLock );
    bLocked = TRUE;

    //
    //  Check first in the outstanding connections
    //
    RtlCopyMemory( key.addr, paddr, key.uAddrSize );
    pIter = RtlLookupElementGenericTable( &gOutStandingConnections, &key );

    if ( NULL == pIter )
    {

        //
        //  check in the blocked connections list
        //
        pPrev = NULL;
        pIter = g_pBlockedConnections;
        while ( NULL != pIter )
        {
            if ( key.uAddrSize == pIter->uAddrSize &&
                 key.uAddrSize == RtlCompareMemory( pIter->addr, paddr, key.uAddrSize ))
            {
                break;
            }
            pPrev = pIter;
            pIter = pIter->pNext;
        }

        if ( NULL != pIter )
        {
            pIter->NumOutStandingConnect ++;
            //
            //  already blocked, check for exparation time
            //
            GetSystemTimeAsFileTime( (LPFILETIME)&currentTime );
            if ( currentTime > pIter->blockUntilTime )
            {
                //
                // unblock, remove from list
                //
                pIter->blockUntilTime = 0;
                if ( NULL != pPrev )
                {
                    pPrev->pNext = pIter->pNext;
                } else {
                    g_pBlockedConnections = pIter->pNext;
                }

                bSucc = RtlInsertElementGenericTable( &gOutStandingConnections, pIter, sizeof( *pIter ), &bNewElement );
                if ( !bSucc )
                {
                    MemFree( pIter );
                    goto exitpt;
                }
                ASSERT( bNewElement );
                MemFree( pIter );

            } else {
                *pbBlocked = TRUE;
            }

        } else {
            //
            //  this will be a new connection
            //
            key.NumOutStandingConnect = 1;

            bSucc = RtlInsertElementGenericTable( &gOutStandingConnections, &key, sizeof( key ), &bNewElement );
            if ( !bSucc )
            {
                goto exitpt;
            }
            ASSERT( bNewElement );
        }
    } else {

        pIter->NumOutStandingConnect ++;
        //
        //  Check if we need to block this connection
        //
        if ( pIter->NumOutStandingConnect > MaxSingleOutStandingConnect )
        {
            *pbBlocked = TRUE;
            key.NumOutStandingConnect = pIter->NumOutStandingConnect;

            GetSystemTimeAsFileTime( (LPFILETIME)&currentTime );
            // DelayConnectionTime is in ms
            // currentTime is in 100s ns
            key.blockUntilTime = currentTime + ((ULONGLONG)10000) * ((ULONGLONG)DelayConnectionTime);

            RtlDeleteElementGenericTable( &gOutStandingConnections, &key );

            //
            //  add to the blocked connections
            //
            pIter = MemAlloc( sizeof( *pIter ));
            if ( NULL == pIter )
            {
                goto exitpt;
            }

            RtlCopyMemory( pIter, &key, sizeof( *pIter ));
            pIter->pNext = g_pBlockedConnections;
            g_pBlockedConnections = pIter;

            //
            //  log at most one event on every 15 minutes
            //
            if ( LastLoggedBlockedConnection + ((ULONGLONG)10000) * (15 * 60 * 1000) < currentTime )
            {
                LastLoggedBlockedConnection = currentTime;
                WriteErrorLogEntry( EVENT_TOO_MANY_CONNECTIONS, &key.addr, key.uAddrSize );
            }
        }

    }

    rv = TRUE;

exitpt:

    if ( bLocked )
    {
        LEAVECRIT( &FilterLock );
    }

    return rv;
}

//
//  Removes outstanding connections added in AddOutStandingConnection
//
BOOL
Filter_RemoveOutstandingConnection(
        IN PBYTE    paddr,
        IN UINT     uAddrSize
        )
{
    PTS_OUTSTANDINGCONNECTION pIter, pPrev, pNext;
    TS_OUTSTANDINGCONNECTION key;
    ULONGLONG   currentTime;
    NTSTATUS    Status;
    ULONG       AddrBytesReturned;
#if DBG
    BOOL        bFound = FALSE;
#endif

    pPrev = NULL;
    GetSystemTimeAsFileTime( (LPFILETIME)&currentTime );

    key.uAddrSize = uAddrSize;
    RtlCopyMemory( key.addr, paddr, uAddrSize );

    ENTERCRIT( &FilterLock );

    pIter = RtlLookupElementGenericTable( &gOutStandingConnections, &key );
    if ( NULL != pIter )
    {
#if DBG
        bFound = TRUE;
#endif
        pIter->NumOutStandingConnect--;

        //
        //  cleanup connections w/o reference
        //
        if ( 0 == pIter->NumOutStandingConnect )
        {
            RtlDeleteElementGenericTable( &gOutStandingConnections, &key );
        }

    }

    //
    //  work through the blocked list
    //
    pIter = g_pBlockedConnections;

    while( pIter )
    {
        if ( uAddrSize == pIter->uAddrSize &&
             uAddrSize == RtlCompareMemory( pIter->addr, paddr, uAddrSize ))
        {
            ASSERT( 0 != pIter->NumOutStandingConnect );
            pIter->NumOutStandingConnect--;
#if DBG
            ASSERT( !bFound );
            bFound = TRUE;
#endif
        }

        //
        //  cleanup all connections w/o references
        //
        if ( 0 == pIter->NumOutStandingConnect &&
             currentTime > pIter->blockUntilTime )
        {
            if ( NULL == pPrev )
            {
                g_pBlockedConnections = pIter->pNext;
            } else {
                pPrev->pNext = pIter->pNext;
            }
            //
            //  remove item and advance to the next
            //
            pNext = pIter->pNext;
            MemFree( pIter );
            pIter = pNext;
        } else {
            //
            //  advance to the next item
            //
            pPrev = pIter;
            pIter = pIter->pNext;
        }

    }

    ASSERT( bFound );

    /*
     *  Decrement the number of outstanding connections.
     *  If connections drop back to max value, set the connect event.
     */
#if DBG
    //
    //  ensure proper cleanup
    //
    bFound = ( 0 == gOutStandingConnections.NumberGenericTableElements );
    for( pIter = g_pBlockedConnections; pIter; pIter = pIter->pNext )
    {
        bFound = bFound & ( 0 == pIter->NumOutStandingConnect );
    }

#endif

    LEAVECRIT( &FilterLock );

    return TRUE;
}

/*****************************************************************************
 *
 *  Filter_CompareConnectionEntry
 *
 *   Generic table support.Compare two connection entries
 *
 *
 ****************************************************************************/

RTL_GENERIC_COMPARE_RESULTS
NTAPI
Filter_CompareConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
)
{
    PTS_OUTSTANDINGCONNECTION pFirst, pSecond;
    INT rc;

    pFirst = (PTS_OUTSTANDINGCONNECTION)FirstInstance;
    pSecond = (PTS_OUTSTANDINGCONNECTION)SecondInstance;

    if ( pFirst->uAddrSize < pSecond->uAddrSize )
    {
        return GenericLessThan;
    } else if ( pFirst->uAddrSize > pSecond->uAddrSize ) 
    {
        return GenericGreaterThan;
    }

    rc = memcmp( pFirst->addr, pSecond->addr, pFirst->uAddrSize );
    return ( rc < 0 )?GenericLessThan:
           ( rc > 0 )?GenericGreaterThan:
                      GenericEqual;
}

/*****************************************************************************
 *
 *  Filter_AllocateConnectionEntry
 *
 *   Generic table support. Allocates a new table entry
 *
 *
 ****************************************************************************/

PVOID
Filter_AllocateConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
    )
{
    return MemAlloc( ByteSize );
}

/*****************************************************************************
 *
 *  Filter_FreeConnectionEntry
 *
 *   Generic table support. frees a new table entry
 *
 *
 ****************************************************************************/

VOID
Filter_FreeConnectionEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       Buffer
    )
{
    MemFree( Buffer );
}

VOID
Filter_DestroyList(
    VOID
    )
{
    PTS_OUTSTANDINGCONNECTION p;
    TS_OUTSTANDINGCONNECTION con;

    while ( NULL != g_pBlockedConnections )
    {
        p = g_pBlockedConnections->pNext;
        MemFree( g_pBlockedConnections );
        g_pBlockedConnections = p;
    }

    while (p = RtlEnumerateGenericTable( &gOutStandingConnections, TRUE)) 
    {
        RtlCopyMemory( &con, p, sizeof( con ));
        RtlDeleteElementGenericTable( &gOutStandingConnections, &con);
    }
}

//
// ComputeHMACVerifier
// Compute the HMAC verifier from the random
// and the cookie
//
BOOL
ComputeHMACVerifier(
    PBYTE pCookie,     //IN - the shared secret
    LONG cbCookieLen,  //IN - the shared secret len
    PBYTE pRandom,     //IN - the session random
    LONG cbRandomLen,  //IN - the session random len
    PBYTE pVerifier,   //OUT- the verifier
    LONG cbVerifierLen //IN - the verifier buffer length
    )
{
    HMACMD5_CTX hmacctx;
    BOOL fRet = FALSE;

    ASSERT(cbVerifierLen >= MD5DIGESTLEN);

    if (!(pCookie &&
          cbCookieLen &&
          pRandom &&
          cbRandomLen &&
          pVerifier &&
          cbVerifierLen)) {
        goto bail_out;
    }

    HMACMD5Init(&hmacctx, pCookie, cbCookieLen);

    HMACMD5Update(&hmacctx, pRandom, cbRandomLen);
    HMACMD5Final(&hmacctx, pVerifier);

    fRet = TRUE;

bail_out:
    return fRet;
}


//
// Extract the session to reconnect to from the ARC info
// also do the necessary security checks
//
// Params:
//  pClientArcInfo - autoreconnect information from the client
//
// Returns:
//  If all security checks pass and pArc is valid then winstation
//  to reconnect to is returned. Else NULL
//
// NOTE: WinStation returned is left LOCKED.
//
PWINSTATION
GetWinStationFromArcInfo(
    PBYTE pClientRandom,
    LONG  cbClientRandomLen,
    PTS_AUTORECONNECTINFO pClientArcInfo
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PWINSTATION pWinStation = NULL;
    PWINSTATION pFoundWinStation = NULL;
    ARC_CS_PRIVATE_PACKET UNALIGNED* pCSArcInfo = NULL;
    BYTE arcSCclientBlob[ARC_SC_SECURITY_TOKEN_LEN];
    BYTE hmacVerifier[ARC_CS_SECURITY_TOKEN_LEN];
    PBYTE pServerArcBits = NULL;
    ULONG BytesGot = 0;
    TS_AUTORECONNECTINFO SCAutoReconnectInfo;

    TRACE((hTrace,TC_ICASRV,TT_API1,
           "TERMSRV: WinStation GetWinStationFromArcInfo pRandom:%p len:%d\n",
           pClientRandom, cbClientRandomLen));


    if (!pClientArcInfo) {
        goto error;
    }

    pCSArcInfo = (ARC_CS_PRIVATE_PACKET UNALIGNED*)pClientArcInfo->AutoReconnectInfo;

    if (!pCSArcInfo->cbLen ||
        pCSArcInfo->cbLen < sizeof(ARC_CS_PRIVATE_PACKET)) {

        TRACE((hTrace,TC_ICASRV,TT_ERROR,
               "TERMSRV: GetWinStationFromArcInfo ARC length invalid bailing out\n"));
        goto error;
    }

    memset(arcSCclientBlob, 0, sizeof(arcSCclientBlob));
    pWinStation = FindWinStationById(pCSArcInfo->LogonId, FALSE);
    if (pWinStation) {

        TRACE((hTrace,TC_ICASRV,TT_API1,
               "TERMSRV: GetWinStationFromArcInfo found arc winstation: %d\n",
               pCSArcInfo->LogonId));
        //
        // Do security checks to ensure this is the same winstation
        // that was connected to the client
        //

        //
        // First obtain the last autoreconnect blob sent to the client
        // since we do an inline cookie update in rdpwd
        //

        if (pWinStation->AutoReconnectInfo.Valid) {
            pServerArcBits = pWinStation->AutoReconnectInfo.ArcRandomBits;

            Status = STATUS_SUCCESS;
        }
        else {
            if (pWinStation->pWsx &&
                pWinStation->pWsx->pWsxEscape) {

                if (pWinStation->Terminating ||
                    pWinStation->StateFlags & WSF_ST_WINSTATIONTERMINATE ||
                    !pWinStation->WinStationName[0]) {

                    TRACE((hTrace,TC_ICASRV,TT_ERROR,
                           "GetWinStationFromArcInfo skipping escape"
                           "to closed stack disconnected %d\n",
                           LogonId));

                    Status = STATUS_ACCESS_DENIED;
                    goto error;
                }

                Status = pWinStation->pWsx->pWsxEscape(
                                            pWinStation->pWsxContext,
                                            GET_SC_AUTORECONNECT_INFO,
                                            NULL,
                                            0,
                                            &SCAutoReconnectInfo,
                                            sizeof(SCAutoReconnectInfo),
                                            &BytesGot);

                if (NT_SUCCESS(Status)) {
                    ASSERT(SCAutoReconnectInfo.cbAutoReconnectInfo ==
                           ARC_SC_SECURITY_TOKEN_LEN);
                }

                pServerArcBits = SCAutoReconnectInfo.AutoReconnectInfo;
            }
        }
    }
    else {
        Status = STATUS_ACCESS_DENIED;
    }

    if (NT_SUCCESS(Status)) {

        //
        // Ensure we got the correct length for the server->client
        // data
        // 
        ASSERT(pServerArcBits);

        //
        // Get random
        //
        if (ComputeHMACVerifier(pServerArcBits,
                            ARC_SC_SECURITY_TOKEN_LEN,
                            pClientRandom,
                            cbClientRandomLen,
                            (PBYTE)hmacVerifier,
                            sizeof(hmacVerifier))) {

            //
            // Check that the verifier matches that sent by the client
            //

            if (!memcmp(hmacVerifier,
                        pCSArcInfo->SecurityVerifier,
                        sizeof(pCSArcInfo->SecurityVerifier))) {

                TRACE((hTrace,TC_ICASRV,TT_API1,
                       "TERMSRV: WinStation ARC info matches - will autoreconnect\n"));

            }
            else {

                TRACE((hTrace,TC_ICASRV,TT_ERROR,
                       "TERMSRV: autoreconnect verifier does not match targid:%d!!!\n",
                       pWinStation->LogonId));

                //
                // Reset the autoreconnect info
                //
                pWinStation->AutoReconnectInfo.Valid = FALSE;
                memset(pWinStation->AutoReconnectInfo.ArcRandomBits, 0,
                       sizeof(pWinStation->AutoReconnectInfo.ArcRandomBits));

                //
                // Mark that no winstation target was found
                //
                goto error;
            }
        }
        pFoundWinStation = pWinStation;
    }

error:
    if ((NULL == pFoundWinStation) && pWinStation) {
        ReleaseWinStation(pWinStation);
        pWinStation = NULL;
    }

    return pFoundWinStation;
}

//
// Extract the session to reconnect to from the ARC info
// also do the necessary security checks
//
// Params:
//  pWinStation - winstation to reset autoreconnect info for
//
VOID
ResetAutoReconnectInfo( PWINSTATION pWinStation)
{
    pWinStation->AutoReconnectInfo.Valid = FALSE;
    memset(pWinStation->AutoReconnectInfo.ArcRandomBits, 0,
           sizeof(pWinStation->AutoReconnectInfo.ArcRandomBits));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\wstrpc.c ===
/****************************************************************************/
// wstrpc.c
//
// TermSrv API RPC server code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <winuserp.h>

#define SECURITY_WIN32

#include <stdlib.h>
#include <time.h>
#include <tchar.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <allproc.h>
#include <winsta.h>
#include <rpc.h>
#include <vdmdbg.h>
#include <dsrole.h>
#include <security.h>
#include <ntsecapi.h>
#include <lmapibuf.h>
#include "..\rpcwire.h"
#define INITGUID
#include "objbase.h"
#include "initguid.h"
#include <netcfgx.h>
#include "devguid.h"

#include <malloc.h>
#include <dsgetdc.h>
#include <winsock2.h>
#include <tdi.h>
#include "tsremdsk.h"

/*
 * Include the RPC generated common header
 */
#include "tsrpc.h"

#include "icaevent.h"
#include "sessdir.h"

#include "conntfy.h"

#define  MIN_GAP_DATABASE_SIZE 100

#define MAX_IDS_LEN   256     // maximum length that the input parm can be

#define MAX_BUF  256
#define MAX_STRING_BYTES 512

//
// Winlogon defines
//
#define APPLICATION_NAME                    TEXT("Winlogon")
#define WINSTATIONS_DISABLED                TEXT("WinStationsDisabled")


#ifdef NTSDDEBUG
#define NTSDDBGPRINT(x) DbgPrint x
#else
#define NTSDDBGPRINT(x)
#endif

//
// Value passed to RPC runtime libraries for the maximum number of
// cached threads it will keep around. We can actually service more RPC
// calls than this, but it will delete threads when they are done.
//
#define MAX_WINSTATION_RPC_THREADS 1000

#ifdef notdef
// This validates the user pointer to be within the View memory region
#define ISPOINTERVALID_SERVER(pContext, p, length)              \
    (((ULONG)(p) >= (ULONG)(pContext)->ViewBase) &&       \
    ((char *)(p) + (length)) < (char *)((ULONG)(pContext)->ViewBase+pContext->ViewSize))
#endif


 //
 // Extern funcs, these three are from acl.c
extern VOID CleanUpSD(PSECURITY_DESCRIPTOR);
extern BOOL IsCallerSystem( VOID );
extern BOOL IsCallerAdmin( VOID );
extern BOOLEAN WinStationCheckConsoleSession(VOID);
extern NTSTATUS CheckIdleWinstation(VOID);

extern NTSTATUS WaitForConsoleConnectWorker( PWINSTATION pWinStation );

extern BOOL IsClientOnSameMachine(PWINSTATION pWinStation);

extern WCHAR gpszServiceName[];

extern BOOL g_fAppCompat;

extern ULONG MaxOutStandingConnect;
extern ULONG NumOutStandingConnect;
extern HANDLE hConnectEvent;


// TermSrv counter values
extern DWORD g_TermSrvTotalSessions;
extern DWORD g_TermSrvReconSessions;
extern DWORD g_TermSrvDiscSessions;
extern PSID gSystemSid;
extern PSID gAdminSid;

extern HANDLE WinStationIdleControlEvent;

extern HANDLE ConsoleLogoffEvent;
extern RTL_CRITICAL_SECTION ConsoleLock;
extern ULONG gConsoleCreationDisable;

extern NTSTATUS
WinStationEnableSessionIo( 
    PWINSTATION pWinStation, 
    BOOL bEnable
);

extern NTSTATUS
_CheckShadowLoop(
    IN ULONG ClientLogonId,
    IN PWSTR pTargetServerName,
    IN ULONG TargetLogonId
    );

extern BOOL
Filter_RemoveOutstandingConnection(
        IN PBYTE    pin_addr,
        IN UINT     uAddrSize
        );


typedef struct _SID_CACHE_LIST_ENTRY {
    LIST_ENTRY      ListEntry;
    HANDLE          ProcId;
    LARGE_INTEGER   CreateTime;
    PSID            pSid;
} SID_CACHE_LIST_ENTRY, *PSID_CACHE_LIST_ENTRY;

#define MAX_SID_CACHE_ENTRIES 4000
ULONG gMaxSidCacheEntries = 0;

#define REG_GUID_TABLE      REG_CONTROL_TSERVER L"\\lanatable\\"
#define LANA_ID             L"LanaId"


/*=============================================================================
==   Functions Defined
=============================================================================*/
VOID     NotifySystemEvent( ULONG );
VOID     CheckSidCacheSize();
BOOL     IsValidLoopBack(PWINSTATION, ULONG, ULONG);


/*=============================================================================
==   External Functions used
=============================================================================*/

NTSTATUS WinStationEnumerateWorker( PULONG, PLOGONID, PULONG, PULONG );
NTSTATUS WinStationRenameWorker( PWINSTATIONNAME, ULONG, PWINSTATIONNAME, ULONG );
NTSTATUS xxxWinStationQueryInformation( ULONG, ULONG, PVOID, ULONG, PULONG );
NTSTATUS xxxWinStationSetInformation( ULONG, WINSTATIONINFOCLASS, PVOID, ULONG );
NTSTATUS LogonIdFromWinStationNameWorker( PWINSTATIONNAME, ULONG, PULONG );
NTSTATUS IcaWinStationNameFromLogonId( ULONG, PWINSTATIONNAME );
NTSTATUS WaitForConnectWorker( PWINSTATION pWinStation, HANDLE ClientProcessId );
DWORD xxxWinStationGenerateLicense( PWCHAR, ULONG, PCHAR, ULONG );
DWORD xxxWinStationInstallLicense( PCHAR, ULONG );
DWORD xxxWinStationEnumerateLicenses( PULONG, PULONG, PCHAR, PULONG );
DWORD xxxWinStationActivateLicense( PCHAR, ULONG, PWCHAR, ULONG );
DWORD xxxWinStationRemoveLicense( PCHAR, ULONG );
DWORD xxxWinStationSetPoolCount( PCHAR, ULONG );
DWORD xxxWinStationQueryUpdateRequired( PULONG );
NTSTATUS WinStationShadowWorker( ULONG, PWSTR, ULONG, BYTE, USHORT );
NTSTATUS WinStationShadowTargetSetupWorker( ULONG );
NTSTATUS WinStationShadowTargetWorker( BOOLEAN, BOOL, ULONG, PWINSTATIONCONFIG2, PICA_STACK_ADDRESS,
                                       PVOID, ULONG, PVOID, ULONG, PVOID );
NTSTATUS WinStationStopAllShadows( PWINSTATION );

VOID     WinStationTerminate( PWINSTATION );
VOID     WinStationDeleteWorker( PWINSTATION );
NTSTATUS WinStationDoDisconnect( PWINSTATION, PRECONNECT_INFO, BOOLEAN );
NTSTATUS WinStationDoReconnect( PWINSTATION, PRECONNECT_INFO );
VOID     CleanupReconnect( PRECONNECT_INFO );
NTSTATUS ShutdownLogoff( ULONG, ULONG );

NTSTATUS SelfRelativeToAbsoluteSD( PSECURITY_DESCRIPTOR,
                                   PSECURITY_DESCRIPTOR *, PULONG );
NTSTATUS QueueWinStationCreate( PWINSTATIONNAME );
ULONG    WinStationShutdownReset( PVOID );
NTSTATUS DoForWinStationGroup( PULONG, ULONG, LPTHREAD_START_ROUTINE );
NTSTATUS InitializeGAPPointersDatabase();
NTSTATUS IncreaseGAPPointersDatabaseSize();
NTSTATUS InsertPointerInGAPDatabase(PVOID Pointer);
VOID     ReleaseGAPPointersDatabase();
BOOLEAN  PointerIsInGAPDatabase(PVOID Pointer);
VOID     ValidateGAPPointersDatabase(ULONG n);
VOID     ResetAutoReconnectInfo( PWINSTATION );

NTSTATUS
GetSidFromProcessId(
    HANDLE          UniqueProcessId,
    LARGE_INTEGER   CreateTime,
    PSID            *ppProcessSid
    );

PSECURITY_DESCRIPTOR
WinStationGetSecurityDescriptor(
    PWINSTATION pWinStation
    );

NTSTATUS
WinStationConnectWorker(
    ULONG  ClientLogonId,
    ULONG  ConnectLogonId,
    ULONG  TargetLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize,
    BOOLEAN bWait,
    BOOLEAN bAutoReconnecting
    );

NTSTATUS
WinStationDisconnectWorker(
    ULONG LogonId,
    BOOLEAN bWait,
    BOOLEAN CallerIsRpc
    );

NTSTATUS
WinStationWaitSystemEventWorker(
    HANDLE hServer,
    ULONG EventMask,
    PULONG pEventFlags
    );

NTSTATUS
WinStationCallbackWorker(
    ULONG   LogonId,
    PWCHAR pPhoneNumber
    );

NTSTATUS
WinStationBreakPointWorker(
    ULONG   LogonId,
    BOOLEAN KernelFlag
    );

NTSTATUS
WinStationReadRegistryWorker(
    VOID
    );

NTSTATUS
ReInitializeSecurityWorker(
    VOID
    );

NTSTATUS
WinStationNotifyLogonWorker(
    DWORD   ClientLogonId,
    DWORD   ClientProcessId,
    BOOLEAN fUserIsAdmin,
    DWORD   UserToken,
    PWCHAR  pDomain,
    DWORD   DomainSize,
    PWCHAR  pUserName,
    DWORD   UserNameSize,
    PWCHAR  pPassword,
    DWORD   PasswordSize,
    UCHAR   Seed,
    PCHAR   pUserConfig,
    DWORD   ConfigSize
    );

NTSTATUS
WinStationNotifyLogoffWorker(
    DWORD   ClientLogonId,
    DWORD   ClientProcessId
    );

NTSTATUS
WinStationNotifyNewSession(
    DWORD   ClientLogonId
    );

NTSTATUS
WinStationShutdownSystemWorker(
    ULONG ClientLogonId,
    ULONG ShutdownFlags
    );

NTSTATUS
WinStationTerminateProcessWorker(
    ULONG ProcessId,
    ULONG ExitCode
    );

PSECURITY_DESCRIPTOR
BuildEveryOneAllowSD();

NTSTATUS AddUserAce( PWINSTATION );
NTSTATUS RemoveUserAce( PWINSTATION );
NTSTATUS ApplyWinStaMapping( PWINSTATION pWinStation );

NTSTATUS
RpcCheckClientAccess(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

NTSTATUS
RpcCheckClientAccessLocal(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

_CheckConnectAccess(
    PWINSTATION pSourceWinStation,
    PSID   pClientSid,
    ULONG  ClientLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize
    );

NTSTATUS
RpcCheckSystemClient(
    ULONG LogonId
    );

NTSTATUS
RpcCheckSystemClientNoLogonId(
    PWINSTATION pWinStation
    );

NTSTATUS
RpcGetClientLogonId(
    PULONG pLogonId
    );

BOOL
ConfigurePerSessionSecurity(
    PWINSTATION pWinStation
    );

BOOL
IsCallerAdmin( VOID );

BOOL
IsCallerSystem( VOID );

BOOLEAN
ValidWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen);

NTSTATUS
IsZeroterminateStringA(
    PBYTE pString,
    DWORD  dwLength
    );

NTSTATUS
IsZeroterminateStringW(
    PWCHAR pwString,
    DWORD  dwLength
    ) ;

NTSTATUS
WinStationUpdateClientCachedCredentialsWorker(
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId,
    PWCHAR      pDomain,
    DWORD       DomainSize,
    PWCHAR      pUserName,
    DWORD       UserNameSize
    );

NTSTATUS 
WinStationFUSCanRemoteUserDisconnectWorker(
    DWORD       TargetLogonId,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId,
    PWCHAR      pDomain,
    DWORD       DomainSize,
    PWCHAR      pUserName,
    DWORD       UserNameSize
    );

NTSTATUS 
WinStationCheckLoopBackWorker(
    DWORD       TargetLogonId,
    DWORD       ClientLogonId,
    PWCHAR      pTargetServerName,
    DWORD       NameSize
    );

NTSTATUS WinStationNotifyDisconnectPipeWorker(
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    );



/*=============================================================================
==   Internal Functions used
=============================================================================*/
VOID AuditShutdownEvent(VOID);
BOOL AuditingEnabled(VOID);

NTSTATUS LogoffWinStation( PWINSTATION, ULONG );

//
//Used by IsGinaVersionCurrent()
//
#define WLX_NEGOTIATE_NAME               "WlxNegotiate"
typedef BOOL (WINAPI * PWLX_NEGOTIATE)(DWORD, DWORD *);
BOOL IsGinaVersionCurrent();


#if DBG
void DumpOutLastErrorString()
{
    LPVOID lpMsgBuf;
    DWORD  error = GetLastError();

    DBGPRINT(("GetLastError() = 0x%lx \n", error ));

    FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            error,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL
        );

    //
    // Process any inserts in lpMsgBuf.
    // ...
    // Display the string.
    //
    DBGPRINT(("%s\n", (LPCTSTR)lpMsgBuf ));

    //
    // Free the buffer.
    //
    LocalFree( lpMsgBuf );
}
#endif

#if DBG
#define DumpOutLastError    DumpOutLastErrorString()
#else
#define DumpOutLastError
#endif


/*=============================================================================
==   Data
=============================================================================*/
BOOLEAN gbPointersDatabaseIsValid = FALSE;
ULONG   gPointersDatabaseSize;
ULONG   gNbProcesses;
PVOID   *gPointersDatabase = NULL;

RTL_CRITICAL_SECTION    gRpcGetAllProcessesLock;
RTL_CRITICAL_SECTION    gRpcPointersDatabaseLock;
RTL_CRITICAL_SECTION    gRpcSidCacheLock;
BOOLEAN                 gbRpcGetAllProcessesOK;
BOOLEAN                 gbRpcSidCacheOK;

extern RTL_CRITICAL_SECTION WsxListLock;
extern LIST_ENTRY WsxListHead;
extern LIST_ENTRY WinStationListHead;    // protected by WinStationListLock

LIST_ENTRY gSidCacheHead;

BOOLEAN bConsoleConnected=FALSE;

extern POLICY_TS_MACHINE        g_MachinePolicy;    // declared in winsta.c


/*****************************************************************************
 *  WinStationInitRPC
 *
 *   Setup the RPC bindings, and listen for incoming requests.
 ****************************************************************************/
RPC_STATUS
WinStationInitRPC( VOID
    )
{
    RPC_STATUS Status;
    DWORD Result;
    RPC_BINDING_VECTOR *pBindingVector;
    PSECURITY_DESCRIPTOR pSd;

    TRACE((hTrace,TC_ICASRV,TT_API2,"RPC WinStationInitRPC\n"));

    //
    //  Initialize the Critical Sections that are
    //  necessary for RpcWinStationGetAllProcesses
    //
    gbRpcGetAllProcessesOK =
        ((NT_SUCCESS(RtlInitializeCriticalSection(&gRpcGetAllProcessesLock))
         && (NT_SUCCESS(RtlInitializeCriticalSection(&gRpcPointersDatabaseLock)))
        )? TRUE : FALSE);

    gbRpcSidCacheOK =
        NT_SUCCESS(RtlInitializeCriticalSection(&gRpcSidCacheLock)) ? TRUE :
        FALSE;
    InitializeListHead(&gSidCacheHead);

    pSd = BuildEveryOneAllowSD();
    if( pSd == NULL ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: WinStationInitRPC: Defaulting SD!\n"));
    }

    // register the LPC (local only) interface
    Status = RpcServerUseProtseqEp(
                 L"ncalrpc",      // Protocol Sequence (LPC)
                 MAX_WINSTATION_RPC_THREADS,  // Maximum calls at one time
                 L"IcaApi",    // Endpoint
                 pSd           // Security
                 );

    if( Status != RPC_S_OK ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"IcaServ: Error %d RpcUseProtseqEp on ncalrpc\n",Status));
        CleanUpSD(pSd);
        return( Status );
    }

    //
    // register the Named pipes interface
    // (remote with NT domain authentication)
    //
    Status = RpcServerUseProtseqEp(
                 L"ncacn_np",     // Protocol Sequence
                 MAX_WINSTATION_RPC_THREADS,  // Maximum calls at one time
                 L"\\pipe\\Ctx_WinStation_API_service", // Endpoint
                 NULL             // Security
                 );

    if( Status != RPC_S_OK ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d RpcUseProtseqEp on ncacn_np\n",Status));
        return( Status );
    }

    // Register our interface handle
    Status = RpcServerRegisterIf(
                 IcaApi_ServerIfHandle, // icaapi.h from MIDL
                 NULL,    // MgrTypeUUID
                 NULL     // default EPV
                 );

    if( Status != RPC_S_OK ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d RpcServerRegisterIf\n",Status));
        return( Status );
    }

    // By default, rpc will serialize access to context handles.  Since
    // the ICASRV needs to be able to have two threads access a context
    // handle at once, and it knows what it is doing, we will tell rpc
    // not to serialize access to context handles.


    // We cannot call this function as its effects are process wide, and since we are
    // part of SvcHost, other services also get affected with this call.
    // instead we will use context_handle_noserialize attribute in our acf files.
    //
    // I_RpcSsDontSerializeContext();

    // Now do the RPC listen to service calls
    Status = RpcServerListen(
                 1,     // Min calls
                 MAX_WINSTATION_RPC_THREADS,
                 TRUE   // fDontWait
                 );

    if( Status != RPC_S_OK ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d RpcServerListen\n",Status));
        return( Status );
    }

    return( 0 );
}


/*****************************************************************************
 *  RpcWinStationOpenServer
 *
 *   Function to open the server for WinStation API's.
 *
 *   The purpose of this function is the allocation of the
 *   RPC context handle for server side state information.
 ****************************************************************************/
BOOLEAN
RpcWinStationOpenServer(
    handle_t hBinding,
    DWORD    *pResult,
    HANDLE *phContext
    )
{
    PRPC_CLIENT_CONTEXT p;

    //
    // Allocate our open context structure
    //
    p = midl_user_allocate( sizeof(RPC_CLIENT_CONTEXT) );

    if( p == NULL ) {
        *pResult = (DWORD) STATUS_NO_MEMORY;
        return( FALSE );
    }

    //
    // zero it out
    //
    memset( p, 0, sizeof(RPC_CLIENT_CONTEXT) );

    //
    // Initialize it
    //
    p->pWaitEvent = NULL;

    //
    // Return the RPC context handle
    //
    *phContext = (PRPC_CLIENT_CONTEXT)p;

    // Return success
    *pResult = STATUS_SUCCESS;

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationCloseServer
 *
 *   Function to close the server for WinStation API's.
 *   This function is obsolete. use RpcWinstationCloseServerEx instead.
 *   Its kept here for compatibility with older (w2k) clients.
 ****************************************************************************/
BOOLEAN
RpcWinStationCloseServer(
    HANDLE hContext,
    DWORD  *pResult
    )
{
    PRPC_CLIENT_CONTEXT pContext = (PRPC_CLIENT_CONTEXT)hContext;
    ULONG EventFlags;
    NTSTATUS Status;

    // Free the wait event block if one was allocated
    if ( pContext->pWaitEvent ) {
        WinStationWaitSystemEventWorker( hContext, WEVENT_NONE, &EventFlags );
    }

    *pResult = STATUS_SUCCESS;

    return( TRUE );
}

/*****************************************************************************
 *  RpcWinStationCloseServerEx
 *
 *   Function to close the server for WinStation API's.
 *   This function supersades the RpcWinStationCloseServer
 ****************************************************************************/
BOOLEAN
RpcWinStationCloseServerEx(
    HANDLE *phContext,
    DWORD  *pResult
    )
{
    PRPC_CLIENT_CONTEXT pContext = (PRPC_CLIENT_CONTEXT)*phContext;

    ULONG EventFlags;
    NTSTATUS Status;

    // Free the wait event block if one was allocated
    if ( pContext->pWaitEvent ) {
        WinStationWaitSystemEventWorker( *phContext, WEVENT_NONE, &EventFlags );
    }

    Status = RpcSsContextLockExclusive(NULL, pContext);
    if (RPC_S_OK == Status)
    {
        midl_user_free(pContext);

        // This is required to signal the RPC that we are done with this context handle
        *phContext = NULL;

        *pResult = STATUS_SUCCESS;
        return( TRUE );
    }
    else
    {
        DbgPrint("-------------RpcWinStationCloseServerEx: failed to lock the Context exclusively, Status = 0x%X\n", Status);
        return (FALSE);
    }
}


/*****************************************************************************
 * RpcIcaServerPing
 *
 * Called on an external ping to this Terminal Server.
 ****************************************************************************/
BOOLEAN
RpcIcaServerPing(
    HANDLE hServer,
    DWORD  *pResult
    )
{
    TRACE((hTrace,TC_ICASRV,TT_API1,"PING Received!\n"));

    *pResult = STATUS_SUCCESS;

    return( TRUE );
}


/*****************************************************************************
 *  RpcWinStationEnumerate
 *
 *   WinStationEnumerate API
 ****************************************************************************/
BOOLEAN
RpcWinStationEnumerate(
    HANDLE  hServer,
    DWORD   *pResult,
    PULONG  pEntries,
    PCHAR   pLogonId,
    PULONG  pByteCount,
    PULONG  pIndex
    )
{

    if (!pEntries || !pLogonId || !pByteCount || !pIndex) {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }

    *pResult = WinStationEnumerateWorker(
                   pEntries,
                   (PLOGONID)pLogonId,
                   pByteCount,
                   pIndex
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationEnumerateProcesses
 *
 *   WinStationEnumerateProcesses API
 ****************************************************************************/
BOOLEAN
RpcWinStationEnumerateProcesses(
    HANDLE  hServer,
    DWORD   *pResult,
    PBYTE   pProcessBuffer,
    DWORD   ByteCount
    )
{
    PBYTE pSrcProcessBuffer = NULL;


#ifdef  _X86_ 

    RtlEnterCriticalSection(&gRpcGetAllProcessesLock);

    // Check if SID cache hasn't grown too much
    CheckSidCacheSize();

    //
    // Allocate a temporary buffer
    //
    pSrcProcessBuffer = MemAlloc (ByteCount);
    if (pSrcProcessBuffer == NULL)
    {
        RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
        *pResult = STATUS_NO_MEMORY;
        return FALSE;
    }

    /*
     * Perform process enumeration.
     */
    *pResult = NtQuerySystemInformation( SystemProcessInformation,
                                         (PVOID)pSrcProcessBuffer,
                                         ByteCount,
                                         NULL);
    if ( *pResult == STATUS_SUCCESS ) {
        PSYSTEM_PROCESS_INFORMATION pSrcProcessInfo;
        PSYSTEM_PROCESS_INFORMATION pDestProcessInfo;
        PCITRIX_PROCESS_INFORMATION pDestCitrixInfo;
        ULONG   TotalOffset;
        PSID    pSid;
        ULONG   SizeOfSid;
        PBYTE   pSrc, pDest;
        ULONG   i;
        ULONG   Size = 0;

        /*
         * Walk the returned buffer to calculate the required size.
         */
        pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pSrcProcessBuffer;
        TotalOffset = 0;
        do
        {
            Size += (SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION
                     + (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * pSrcProcessInfo->NumberOfThreads)
                     + pSrcProcessInfo->ImageName.Length
                    );
            //
            //  Get the Sid (will be remembered in the Sid cache)
            //  Maybe it would be better to add here a "Sidmaximumlength" ??
            //
            if (NT_SUCCESS(GetSidFromProcessId(
                            pSrcProcessInfo->UniqueProcessId,
                            pSrcProcessInfo->CreateTime,
                            &pSid
                            )    )    )
            {
                Size += RtlLengthSid(pSid);
            }

            TotalOffset += pSrcProcessInfo->NextEntryOffset;
            pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pSrcProcessBuffer[TotalOffset];
        }
        while (pSrcProcessInfo->NextEntryOffset != 0);

        if (ByteCount < Size)
        {
            RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
            MemFree(pSrcProcessBuffer);
            *pResult = STATUS_INFO_LENGTH_MISMATCH;
            return FALSE;
        }

        /*
         * Walk the returned buffer (it's in new Win2000 SYSTEM_PROCESS_INFORMATION format),
         * copy it to the old TS4 SYSTEM_PROCESS_INFORMATION format, and fixup the addresses
         * (now containing pointers in our address space within pProcessBuffer) to offsets.
         */

        // back to the beginning
        pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pSrcProcessBuffer;
        pDestProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;

        // initialize current pointers
        pSrc = pSrcProcessBuffer;
        pDest = pProcessBuffer;
        TotalOffset = 0;
        for(;;) {
            //
            // Copy process information
            //
            memcpy(pDest,pSrc,SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION);
            pSrc += sizeof(SYSTEM_PROCESS_INFORMATION);
            pDest += SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION;

            //
            // Copy all the threads info
            //
            for (i=0; i < pSrcProcessInfo->NumberOfThreads ; i++)
            {
                memcpy(pDest,pSrc,SIZEOF_TS4_SYSTEM_THREAD_INFORMATION);
                pSrc += sizeof(SYSTEM_THREAD_INFORMATION);
                pDest += SIZEOF_TS4_SYSTEM_THREAD_INFORMATION;
            }

            //
            // Set the old TS4 info
            //
            pDestCitrixInfo = (PCITRIX_PROCESS_INFORMATION) pDest;
            pDest += sizeof(CITRIX_PROCESS_INFORMATION);

            pDestCitrixInfo->MagicNumber = CITRIX_PROCESS_INFO_MAGIC;
            pDestCitrixInfo->LogonId = pSrcProcessInfo->SessionId;
            pDestCitrixInfo->ProcessSid = NULL;

            //
            //  Get the Sid again (from the cache)
            //
            if (NT_SUCCESS(GetSidFromProcessId(
                            pDestProcessInfo->UniqueProcessId,
                            pDestProcessInfo->CreateTime,
                            &pSid
                            )    )    )
            {
                //
                // Copy the Sid
                //
                SizeOfSid = RtlLengthSid(pSid);

                pDestCitrixInfo->ProcessSid = NULL;
                if ( NT_SUCCESS(RtlCopySid(SizeOfSid, pDest, pSid) ) )
                {
                    pDestCitrixInfo->ProcessSid = (PSID)((ULONG_PTR)pDest - (ULONG_PTR)pProcessBuffer);
                    pDest += SizeOfSid;
                }
            }

            pDestCitrixInfo->Pad = 0;

            //
            // Copy the image file name
            //
            if ((pSrcProcessInfo->ImageName.Buffer != NULL) && (pSrcProcessInfo->ImageName.Length != 0) )
            {
                memcpy(pDest, pSrcProcessInfo->ImageName.Buffer, pSrcProcessInfo->ImageName.Length);
                pDestProcessInfo->ImageName.Buffer = (PWSTR) ((ULONG_PTR)pDest - (ULONG_PTR)pProcessBuffer);
                pDestProcessInfo->ImageName.Length = pSrcProcessInfo->ImageName.Length;
                pDest += (pSrcProcessInfo->ImageName.Length);
                memcpy(pDest,L"\0",sizeof(WCHAR));
                pDest += sizeof(WCHAR);
            }
            else
            {
                pDestProcessInfo->ImageName.Buffer = NULL;
                pDestProcessInfo->ImageName.Length = 0;
            }

            //
            // loop...
            //
            if( pSrcProcessInfo->NextEntryOffset == 0 )
            {
                pDestProcessInfo->NextEntryOffset = 0;
                break;
            }

            pDestProcessInfo->NextEntryOffset =
                (ULONG)((ULONG_PTR)pDest - (ULONG_PTR)pDestProcessInfo);

            pDestProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pDest;

            TotalOffset += pSrcProcessInfo->NextEntryOffset;
            pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pSrcProcessBuffer[TotalOffset];
            pSrc = (PBYTE)pSrcProcessInfo;
        }
    }

    RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
    MemFree(pSrcProcessBuffer);
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
#else

    *pResult = STATUS_NOT_SUPPORTED;
    return FALSE;
#endif
}


/*******************************************************************************
 * AllocateGAPPointer
 ******************************************************************************/
void __RPC_FAR * __RPC_USER
AllocateGAPPointer( size_t Size )
{
    void __RPC_FAR * pMyPointer;

    pMyPointer = MIDL_user_allocate(Size);
    if (pMyPointer != NULL)
    {
        if (gbRpcGetAllProcessesOK == TRUE)
        {
            //
            // store the pointer in our database
            // so that the RPC server stub do not try to free them.
            //
            if (!NT_SUCCESS(InsertPointerInGAPDatabase(pMyPointer)))
            {
                LocalFree(pMyPointer);
                pMyPointer = NULL;
            }
        }
        else    // nothing can be done
        {
            LocalFree(pMyPointer);
            pMyPointer = NULL;
        }
    }
    return pMyPointer;
}


//********************************************************************************
//
//      Functions used to handle the memory allocations and de-allocations
//      in RpcWinStationGetAllProcesses (GAP = Get All Processes)
//
//********************************************************************************
NTSTATUS
InitializeGAPPointersDatabase()
{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlEnterCriticalSection(&gRpcPointersDatabaseLock);
    {
        gPointersDatabaseSize = MIN_GAP_DATABASE_SIZE;
        gPointersDatabase = MemAlloc(MIN_GAP_DATABASE_SIZE * sizeof(PVOID));

        if (gPointersDatabase == NULL)
        {
            Status = STATUS_NO_MEMORY;
        }
        else
        {
            RtlZeroMemory(gPointersDatabase,MIN_GAP_DATABASE_SIZE * sizeof(PVOID));
        }

        gNbProcesses = 0;
        gbPointersDatabaseIsValid = FALSE;
    }
    RtlLeaveCriticalSection(&gRpcPointersDatabaseLock);

    return Status;
}


NTSTATUS
IncreaseGAPPointersDatabaseSize()
{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID   *NewPointersDatabase;

    NewPointersDatabase = MemAlloc(gPointersDatabaseSize * 2 * sizeof(PVOID));

    if (NewPointersDatabase == NULL)
    {
        Status = STATUS_NO_MEMORY;
    }
    else
    {
        RtlCopyMemory(NewPointersDatabase,
                      gPointersDatabase,
                      gPointersDatabaseSize * sizeof(PVOID));
        RtlZeroMemory(&NewPointersDatabase[gPointersDatabaseSize],
                      gPointersDatabaseSize * sizeof(PVOID));

        MemFree(gPointersDatabase);
        gPointersDatabase = NewPointersDatabase;
        gPointersDatabaseSize = gPointersDatabaseSize * 2;
    }

    return Status;
}


NTSTATUS
InsertPointerInGAPDatabase(PVOID Pointer)
{
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;

//    DBGPRINT(("TERMSRV: InsertPointerInGAPDatabase 0x%x\n",Pointer));

    RtlEnterCriticalSection(&gRpcPointersDatabaseLock);
    {
        for (i=0; i < gPointersDatabaseSize; i++)
        {
            if (gPointersDatabase[i] == NULL)
            {
                gPointersDatabase[i] = Pointer;
                break;
            }
        }
        if (i == gPointersDatabaseSize)
        {
            Status = IncreaseGAPPointersDatabaseSize();
            if (NT_SUCCESS(Status))
            {
                gPointersDatabase[i] = Pointer;
            }
        }
    }
    RtlLeaveCriticalSection(&gRpcPointersDatabaseLock);
    return Status;
}


VOID
ReleaseGAPPointersDatabase()
{
    PTS_ALL_PROCESSES_INFO_NT6  pProcessArray;
    ULONG   i;

    if (gPointersDatabase != NULL)
    {
        RtlEnterCriticalSection(&gRpcPointersDatabaseLock);
        {
            //
            // free all the "autonomic" pointers
            //

            // the first one is ProcessArray
            if ((gPointersDatabase[0] != NULL) && (gNbProcesses != 0))
            {
                pProcessArray = (PTS_ALL_PROCESSES_INFO_NT6) gPointersDatabase[0];

                //
                //  free the Process Info buffer
                //
                if (pProcessArray[0].pTsProcessInfo != NULL)
                {
                    LocalFree(pProcessArray[0].pTsProcessInfo);
                }

                //
                //  free all the SIDs
                //
                for (i=0; i < gNbProcesses ; i++)
                {
                    if (pProcessArray[i].pSid != NULL)
                    {
                        LocalFree(pProcessArray[i].pSid);
                    }
                }
                //
                //  free the returned array
                //
                LocalFree(pProcessArray);
            }

            //
            //  free the database
            //
            MemFree(gPointersDatabase);
            gPointersDatabase = NULL;
            gNbProcesses = 0;
            //
            //  disable the checking
            //
            gbPointersDatabaseIsValid = FALSE;
        }
        RtlLeaveCriticalSection(&gRpcPointersDatabaseLock);
    }
}


BOOLEAN
PointerIsInGAPDatabase(PVOID Pointer)
{
    ULONG   i;
    BOOLEAN bRet = FALSE;

    // spend time only if necessary
    if ((Pointer != NULL)
            && (gbRpcGetAllProcessesOK == TRUE)
            && (gbPointersDatabaseIsValid == TRUE)
            )
    {
        RtlEnterCriticalSection(&gRpcPointersDatabaseLock);
        {
            // we need to check because the database may have been released
            // while we were waiting for the lock
            if (gPointersDatabase != NULL)
            {
                for (i=0; i < gPointersDatabaseSize; i++)
                {
                    if (gPointersDatabase[i] == Pointer)
                    {
                        bRet = TRUE;
                        break;
                    }
                }
            }
        }
        RtlLeaveCriticalSection(&gRpcPointersDatabaseLock);
    }

    return bRet;
}


VOID
ValidateGAPPointersDatabase(ULONG n)
{
    gbPointersDatabaseIsValid = TRUE;
    gNbProcesses = n;
}


/*******************************************************************************
 *  SidCacheAdd
 *
 *  NOTE: Do not call with GAP allocated, or otherwise controlled pointers.
 ******************************************************************************/
VOID
SidCacheAdd(
        HANDLE          UniqueProcessId,
        LARGE_INTEGER   CreateTime,
        PSID            pNewSid
        )
{
    DWORD                   SidLength;
    NTSTATUS                Status;
    PLIST_ENTRY             pNewListEntry;
    PSID_CACHE_LIST_ENTRY   pNewCacheRecord;
    PSID                    pSid;

    //
    //  If the lock didn't initialize, bail.
    //
    if (!gbRpcSidCacheOK) {
        return;
    }

    //
    //  Initialize memory for cache record. Failure is not a problem;
    //  the sid just won't be cached.
    //
    pNewCacheRecord = MemAlloc(sizeof(SID_CACHE_LIST_ENTRY));
    if (pNewCacheRecord == NULL) {
        return;
    }

    pNewCacheRecord->pSid = pNewSid;
    pNewCacheRecord->ProcId = UniqueProcessId;
    pNewCacheRecord->CreateTime = CreateTime;
    pNewListEntry = &pNewCacheRecord->ListEntry;

    //
    //  Lock the Sid Cache and add the new member.
    //
    RtlEnterCriticalSection(&gRpcSidCacheLock);
    InsertTailList(&gSidCacheHead, pNewListEntry);

    gMaxSidCacheEntries++;
    RtlLeaveCriticalSection(&gRpcSidCacheLock);
}


/*******************************************************************************
 *
 *  SidCacheFind
 *
 *  NOTE: Use RtlLengthSid, alloc memory, and RtlCopySid for the return value!
 *        Otherwise, you may free memory being used by the Cache!!
 *
 ******************************************************************************/
PSID
SidCacheFind(
    HANDLE          UniqueProcessId,
    LARGE_INTEGER   CreateTime
    )
{
    PLIST_ENTRY             pTempEntry;
    PSID_CACHE_LIST_ENTRY   pSidCacheEntry;
    PSID                    pRetSid = NULL;

    //
    //  If the lock didn't initialize, bail.
    //
    if (!gbRpcSidCacheOK) {
        return(NULL);
    }

    //
    //  Lock the Sid Cache.
    //
    RtlEnterCriticalSection(&gRpcSidCacheLock);

    //
    //  The list head is a place holder, start searching from the head's
    //  Flink. Stop when we reach the list head again.
    //
    pTempEntry = gSidCacheHead.Flink;

    while(pTempEntry != &gSidCacheHead) {
        pSidCacheEntry = CONTAINING_RECORD(
                            pTempEntry,
                            SID_CACHE_LIST_ENTRY,
                            ListEntry
                            );

        if (pSidCacheEntry->ProcId != UniqueProcessId) {
            pTempEntry = pTempEntry->Flink;
        } else {
            if (pSidCacheEntry->CreateTime.QuadPart == CreateTime.QuadPart) {
                pRetSid = pSidCacheEntry->pSid;
            } else {
                //
                //  If the PID matches, but the create time doesn't, this record is
                //  stale. Remove it from the list and free the memory associated with
                //  it. There can only be one entry in the cache per PID, therefore,
                //  stop searching after freeing.
                //
                RemoveEntryList(pTempEntry);
                if (pSidCacheEntry->pSid != NULL) {
                    MemFree(pSidCacheEntry->pSid);
                }
                MemFree(pSidCacheEntry);
            }
            break;
        }
    }

    //
    //  Release the Sid Cache.
    //
    RtlLeaveCriticalSection(&gRpcSidCacheLock);
    return(pRetSid);
}


/*******************************************************************************
 *
 *  SidCacheFree
 *
 *
 ******************************************************************************/
VOID
SidCacheFree(
    PLIST_ENTRY pListHead
    )
{
    PLIST_ENTRY pTempEntry = pListHead->Flink;

    //
    //  Lock the Sid Cache.
    //

    RtlEnterCriticalSection(&gRpcSidCacheLock);


    //
    //  The list head is a place holder, start freeing from the head's
    //  Flink. Stop when we reach the list head again.
    //

    while (pTempEntry != pListHead) {
        PSID_CACHE_LIST_ENTRY pSidCacheEntry;
        pSidCacheEntry = CONTAINING_RECORD(
                            pTempEntry,
                            SID_CACHE_LIST_ENTRY,
                            ListEntry
                            );

        if (pSidCacheEntry->pSid != NULL) {
            MemFree(pSidCacheEntry->pSid);
        }


        RemoveEntryList(pTempEntry);
        pTempEntry = pTempEntry->Flink;
        MemFree(pSidCacheEntry);

    }

    //
    //  Release the Sid Cache.
    //

    RtlLeaveCriticalSection(&gRpcSidCacheLock);
}

/*******************************************************************************
 *
 *  SidCacheUpdate
 *
 *
 ******************************************************************************/
VOID
SidCacheUpdate(
    VOID
    )
{

    //
    //  TODO: Figure out a way to get rid of stale cache entries!
    //

}

/*******************************************************************************
 *
 *    GetSidFromProcessId
 *
 *  NOTE: GetSid returns a normal, local memory pointer. The caller should
 *        copy this sid based on its needs. For example, RpcWinStationGAP
 *        would copy this sid to a GAP pointer. The caller should NOT free
 *        the returned pointer, as it is also being cached!
 *
 ******************************************************************************/
NTSTATUS
GetSidFromProcessId(
    HANDLE          UniqueProcessId,
    LARGE_INTEGER   CreateTime,
    PSID            *ppProcessSid
    )
{
    BOOLEAN             bResult = FALSE;
    DWORD               ReturnLength;
    DWORD               BufferLength;
    DWORD               SidLength;
    PSID                pSid;
    NTSTATUS            Status;
    PTOKEN_USER         pTokenUser = NULL;
    HANDLE              hProcess;
    HANDLE              hToken;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    CLIENT_ID           ClientId;
    KERNEL_USER_TIMES   TimeInfo;

    //
    //  Look in sid cache first.
    //

    *ppProcessSid = SidCacheFind(UniqueProcessId, CreateTime);
    if (*ppProcessSid != NULL) {
        return(STATUS_SUCCESS);
    }

    //
    //  Take the long road...
    //  Get the Process Handle
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );
    ClientId.UniqueThread = (HANDLE)NULL;
    ClientId.UniqueProcess = (HANDLE)UniqueProcessId;

    Status = NtOpenProcess(
                &hProcess,
                PROCESS_QUERY_INFORMATION,
                &ObjectAttributes,
                &ClientId
                );

    if (NT_SUCCESS(Status)) {

        //
        //  Get the Process CreateTime information
        //

        Status = NtQueryInformationProcess(
                    hProcess,
                    ProcessTimes,
                    (PVOID)&TimeInfo,
                    sizeof(TimeInfo),
                    NULL
                    );

        //
        //  Verify that the passed in PID and CreateTime match
        //  the current environment (i.e. don't bother getting
        //  information on a stale PID).
        //

        if (NT_SUCCESS(Status)) {
            if ((TimeInfo.CreateTime.LowPart != CreateTime.LowPart) ||
                (TimeInfo.CreateTime.HighPart != CreateTime.HighPart)) {
                CloseHandle(hProcess);
                return(STATUS_INVALID_HANDLE);  //  What should we return?
            }
        } else {
            CloseHandle(hProcess);
            return(Status);
        }

        //
        //  Get the Process Token
        //

        Status = NtOpenProcessToken(
                    hProcess,
                    TOKEN_QUERY,
                    &hToken
                    );

        if (NT_SUCCESS(Status)) {

            //
            //  Query the TokenUser size, then allocate space
            //  and re-query.
            //

            Status = NtQueryInformationToken(
                         hToken,
                         TokenUser,
                         NULL,
                         0,
                         &ReturnLength
                         );

            if (ReturnLength == 0) {
                CloseHandle(hProcess);
                CloseHandle(hToken);
                return(Status);
            }

            BufferLength = ReturnLength;
            pTokenUser = MemAlloc(BufferLength);
            if( pTokenUser == NULL ) {
                CloseHandle(hProcess);
                CloseHandle(hToken);
                return(STATUS_NO_MEMORY);
            }

            Status = NtQueryInformationToken(
                         hToken,
                         TokenUser,
                         pTokenUser,
                         BufferLength,
                         &ReturnLength
                         );

            CloseHandle(hToken);

            if (NT_SUCCESS(Status)) {

                //
                //  A valid Sid has been found; copy it and add it to
                //  the cache.
                //

                SidLength = RtlLengthSid(pTokenUser->User.Sid);
                pSid = MemAlloc(SidLength);

                if (pSid != NULL) {
                    Status = RtlCopySid(
                                SidLength,
                                pSid,
                                pTokenUser->User.Sid
                                );

                    if (NT_SUCCESS(Status)) {
                        *ppProcessSid = pSid;
                        bResult = TRUE;
                        SidCacheAdd(UniqueProcessId, CreateTime, pSid);
                    }
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }
            MemFree(pTokenUser);
        }
        CloseHandle(hProcess);
    }
    return(Status);
}


VOID
CheckSidCacheSize()

{

    // if cache has grown over limit, free all the entries
    // and reset the cache entries counter

    if (gMaxSidCacheEntries >= MAX_SID_CACHE_ENTRIES) {
        SidCacheFree(&gSidCacheHead);
        InitializeListHead(&gSidCacheHead);
        gMaxSidCacheEntries = 0;

    }

}

//
// This function converts sys buffer to ts buffer. also counts the processes, and returns array procids.
// CALLER NEED TO LocalFree the *ppProcIds, thats allocaed.
BOOL ConvertSysBufferToTSBuffer(PBYTE *ppSysProcessBuffer, DWORD ByteCount, ULONG *pProcesses, PHANDLE *ppProcIds)
{
    PBYTE                       pTSProcessBuffer = NULL;
    PSYSTEM_PROCESS_INFORMATION pSysProcessInfo  = NULL;
    PTS_SYS_PROCESS_INFORMATION_NT6 pTSProcessInfo   = NULL;
    ULONG                       TotalOffset      = 0;
    ULONG                       i;

    HANDLE                      *pProcessIds     = NULL;
    UINT                        uiNumProcess     = 0;

    ASSERT(ppSysProcessBuffer);
    ASSERT(*ppSysProcessBuffer);
    ASSERT(ByteCount);
    ASSERT(pProcesses);
    ASSERT(ppProcIds);
        
    // allocate target buffer.
    pTSProcessBuffer = MIDL_user_allocate(ByteCount);

    if (pTSProcessBuffer == NULL)
    {
        *ppProcIds = NULL;
        *pProcesses = 0;
        return FALSE;
    }

    
    uiNumProcess = 0;
    TotalOffset = 0;

    do
    {
        ASSERT(TotalOffset < ByteCount);
        pSysProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &((*ppSysProcessBuffer)[TotalOffset]);
        pTSProcessInfo  = (PTS_SYS_PROCESS_INFORMATION_NT6)&(pTSProcessBuffer[TotalOffset]);

        // now copy the information over.
        /* ULONG */ pTSProcessInfo->NextEntryOffset = pSysProcessInfo->NextEntryOffset;
        /* ULONG */ pTSProcessInfo->NumberOfThreads = pSysProcessInfo->NumberOfThreads;
        /* LARGE_INTEGER */ pTSProcessInfo->SpareLi1 = pSysProcessInfo->SpareLi1;
        /* LARGE_INTEGER */ pTSProcessInfo->SpareLi2 = pSysProcessInfo->SpareLi2;
        /* LARGE_INTEGER */ pTSProcessInfo->SpareLi3 = pSysProcessInfo->SpareLi3;
        /* LARGE_INTEGER */ pTSProcessInfo->CreateTime = pSysProcessInfo->CreateTime;
        /* LARGE_INTEGER */ pTSProcessInfo->UserTime = pSysProcessInfo->UserTime;
        /* LARGE_INTEGER */ pTSProcessInfo->KernelTime = pSysProcessInfo->KernelTime;

        if (pSysProcessInfo->ImageName.Buffer != NULL && pSysProcessInfo->ImageName.Length != 0)
        {
            pTSProcessInfo->ImageName.Buffer = (PWSTR)(pTSProcessBuffer + ((PBYTE) pSysProcessInfo->ImageName.Buffer - *ppSysProcessBuffer));
            memcpy(pTSProcessInfo->ImageName.Buffer, pSysProcessInfo->ImageName.Buffer, pSysProcessInfo->ImageName.Length );            
            pTSProcessInfo->ImageName.Length = pSysProcessInfo->ImageName.Length;
            pTSProcessInfo->ImageName.MaximumLength = pSysProcessInfo->ImageName.MaximumLength;
        }
        else
        {
            pTSProcessInfo->ImageName.Buffer = NULL;
            pTSProcessInfo->ImageName.Length = 0;
        }

        /* KPRIORITY */ pTSProcessInfo->BasePriority = pSysProcessInfo->BasePriority;
        /* HANDLE */ pTSProcessInfo->UniqueProcessId = HandleToULong(pSysProcessInfo->UniqueProcessId);
        /* HANDLE */ pTSProcessInfo->InheritedFromUniqueProcessId = HandleToULong(pSysProcessInfo->InheritedFromUniqueProcessId);
        /* ULONG */ pTSProcessInfo->HandleCount = pSysProcessInfo->HandleCount;
        /* ULONG */ pTSProcessInfo->SessionId = pSysProcessInfo->SessionId;
        // /* ULONG_PTR */ pTSProcessInfo->PageDirectoryBase = pSysProcessInfo->PageDirectoryBase;
        /* SIZE_T */ pTSProcessInfo->PeakVirtualSize = pSysProcessInfo->PeakVirtualSize;
        /* SIZE_T */ pTSProcessInfo->VirtualSize = pSysProcessInfo->VirtualSize;
        /* ULONG */ pTSProcessInfo->PageFaultCount = pSysProcessInfo->PageFaultCount;
        /* SIZE_T */ pTSProcessInfo->PeakWorkingSetSize =  (ULONG)pSysProcessInfo->PeakWorkingSetSize;
        /* SIZE_T */ pTSProcessInfo->WorkingSetSize = (ULONG)pSysProcessInfo->WorkingSetSize;
        /* SIZE_T */ pTSProcessInfo->QuotaPeakPagedPoolUsage = (ULONG)pSysProcessInfo->QuotaPeakPagedPoolUsage;
        /* SIZE_T */ pTSProcessInfo->QuotaPagedPoolUsage = (ULONG)pSysProcessInfo->QuotaPagedPoolUsage;
        /* SIZE_T */ pTSProcessInfo->QuotaPeakNonPagedPoolUsage = (ULONG)pSysProcessInfo->QuotaPeakNonPagedPoolUsage;
        /* SIZE_T */ pTSProcessInfo->QuotaNonPagedPoolUsage = (ULONG)pSysProcessInfo->QuotaNonPagedPoolUsage;
        /* SIZE_T */ pTSProcessInfo->PagefileUsage = (ULONG)pSysProcessInfo->PagefileUsage;
        /* SIZE_T */ pTSProcessInfo->PeakPagefileUsage = (ULONG)pSysProcessInfo->PeakPagefileUsage;
        /* SIZE_T */ pTSProcessInfo->PrivatePageCount = (ULONG)pSysProcessInfo->PrivatePageCount;


        TotalOffset += pSysProcessInfo->NextEntryOffset;
        uiNumProcess++;
    }
    while (pSysProcessInfo->NextEntryOffset != 0);


    //
    // now keep the original pid form the original buffer, we have lost some data while converting it to ts format.

    // allocate memory for  process ids.
    pProcessIds = LocalAlloc(LMEM_FIXED, sizeof(HANDLE) * uiNumProcess);

    if (!pProcessIds)
    {
        MIDL_user_free(pTSProcessBuffer);
        *ppProcIds = NULL;
        *pProcesses = 0;
        return FALSE;
    }

    TotalOffset = 0;
    for (i = 0; i < uiNumProcess; i++)
    {
        pSysProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &((*ppSysProcessBuffer)[TotalOffset]);
        ASSERT(TotalOffset < ByteCount);

        pProcessIds[i] =  pSysProcessInfo->UniqueProcessId;

        TotalOffset += pSysProcessInfo->NextEntryOffset;
    }
    
    ASSERT(pSysProcessInfo->NextEntryOffset == 0);

    // now lets get rid of the original buffer, and replace it with our new TS process buffer
    LocalFree(*ppSysProcessBuffer);

    *ppProcIds          = pProcessIds;
    *pProcesses         = uiNumProcess;
    *ppSysProcessBuffer = pTSProcessBuffer;
    
    return TRUE;
}

/***********************************************************************************************************
 *  WinStationGetAllProcessesWorker
 *
 *    Worker routine for RpcWinStationGetAllProcesses(Win2K) and RpcWinStationGetAllProcesses_NT6(Whistler).
 *
 * EXIT:
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *    FALSE -- The operation failed.  Extended error status is returned in pResult.
 ***********************************************************************************************************/
BOOLEAN
WinStationGetAllProcessesWorker(
        HANDLE  hServer,
        DWORD   *pResult,
        ULONG   Level,
        ULONG   *pNumberOfProcesses,
        PBYTE	*ppTsAllProcessesInfo
        )
{
    PTS_SYS_PROCESS_INFORMATION_NT6 pProcessInfo = NULL;
    PTS_ALL_PROCESSES_INFO_NT6 pProcessArray = NULL;

    ULONG   TotalOffset;
    ULONG   NumberOfProcesses = 1;  // at least 1 process
    ULONG i;

    if (gbRpcGetAllProcessesOK == FALSE)
    {
        *pResult = STATUS_NO_MEMORY;
        *pNumberOfProcesses = 0;
        *ppTsAllProcessesInfo = NULL;
        return FALSE;
    }
    
    //
    //  this critical section will be released in
    //  RpcWinStationGetAllProcesses_notify_flag
    //
    RtlEnterCriticalSection(&gRpcGetAllProcessesLock);

    // Check if SID cache hasn't grown too much

    CheckSidCacheSize();


    if (!NT_SUCCESS(InitializeGAPPointersDatabase()))
    {
        *pResult = STATUS_NO_MEMORY;
        *pNumberOfProcesses = 0;
        *ppTsAllProcessesInfo = NULL;
        return FALSE;
    }

    //
    //  make sure requested information level is known
    //
    if (Level != GAP_LEVEL_BASIC)     // only info level known on this version
    {
        *pResult = STATUS_NOT_IMPLEMENTED;
    }
    else        // OK
    {
        PBYTE       pProcessBuffer = NULL;
        PSID        pSid;
        DWORD       RequiredByteCount = 0;
        DWORD       ByteCount = (MAX_PATH*sizeof(WCHAR)) + 1;   // Give the minimum length first. We will get the correct on subsequent calls.
        NTSTATUS    Status = STATUS_INFO_LENGTH_MISMATCH;		// Assume that this length is wrong. In fact it *is* wrong initially.
        HANDLE      *pProcessids = NULL;

        while ( Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            //
            //  Allocate a buffer
            //
            pProcessBuffer = MIDL_user_allocate(ByteCount);

            if (pProcessBuffer == NULL)
            {
                Status = STATUS_NO_MEMORY;
                *pResult = STATUS_NO_MEMORY;
                *pNumberOfProcesses = 0;
                *ppTsAllProcessesInfo = NULL;
                break;
            }

            //
            //  Perform process enumeration.
            //	NOTE: We had a mismatch in the structure for the process information in Win2K and whistler from RPC point of view.
            //	Win2K RPC interpretes the size of the image name is twice of what whistler does. So, to take care of this problem,
            //	where Win2K client may call Whistler server, we will allocate more bytes than actually required. So, we will pass
            //	less number of bytes to the system call by the same amount.
            //
            Status = NtQuerySystemInformation( SystemProcessInformation,
                                                 (PVOID)pProcessBuffer,
                                                 ByteCount - (MAX_PATH*sizeof(WCHAR)),
                                                 &RequiredByteCount );
            if (Status == STATUS_INFO_LENGTH_MISMATCH)
            {
                // Allocate little more bytes than required.
                ByteCount = RequiredByteCount + (MAX_PATH*sizeof(WCHAR));
                LocalFree(pProcessBuffer);
            }
        }
        
        if ( Status != STATUS_SUCCESS)
        {
            *pResult = STATUS_NO_MEMORY;
            if (pProcessBuffer != NULL)
            {
                LocalFree(pProcessBuffer);
                pProcessBuffer = NULL;
            }
        }
        else if (!ConvertSysBufferToTSBuffer(&pProcessBuffer, ByteCount, &NumberOfProcesses, &pProcessids))
        {
            // failed to convert sysbuffer to ts buffer.
            // lets bail out.
            *pResult = STATUS_NO_MEMORY;
            if (pProcessBuffer != NULL)
            {
                LocalFree(pProcessBuffer);
                pProcessBuffer = NULL;
            }
        }
        else    // everything's fine
        {
            ASSERT(pProcessids);
            ASSERT(pProcessBuffer);
            ASSERT(NumberOfProcesses > 0);


            pProcessArray = AllocateGAPPointer(NumberOfProcesses * sizeof(TS_ALL_PROCESSES_INFO_NT6));

            if (pProcessArray == NULL)
            {
                *pResult = STATUS_NO_MEMORY;
                LocalFree(pProcessBuffer);
                pProcessBuffer = NULL;
            }
            else
            {

                RtlZeroMemory(pProcessArray,
                              NumberOfProcesses * sizeof(TS_ALL_PROCESSES_INFO_NT6));
                *pResult = STATUS_SUCCESS;
                pProcessInfo = (PTS_SYS_PROCESS_INFORMATION_NT6)pProcessBuffer;
                TotalOffset = 0;

                //
                // Walk the returned buffer again to set the correct pointers in pProcessArray
                //
                for (i=0; i < NumberOfProcesses; i++)
                {
                    pProcessArray[i].pTsProcessInfo = (PTS_SYS_PROCESS_INFORMATION_NT6)pProcessInfo;

                    //
                    // keep some trace of the "internal" pointers
                    // so that the RPC server stub do not try to free them.
                    //

                    if (!NT_SUCCESS(InsertPointerInGAPDatabase(pProcessArray[i].pTsProcessInfo)))
                    {
                        *pResult = STATUS_NO_MEMORY;
                        break;
                    }

                    if ( pProcessInfo->ImageName.Buffer )
                    {
                        if (!NT_SUCCESS(InsertPointerInGAPDatabase(pProcessInfo->ImageName.Buffer)))
                        {
                            *pResult = STATUS_NO_MEMORY;
                            break;
                        }
                    }

                    //
                    //  Get the Sid
                    //
                    if (NT_SUCCESS(GetSidFromProcessId(
                                    pProcessids[i],
                                    pProcessInfo->CreateTime,
                                    &pSid
                                    )
                                  )
                       )
                    {
                        //
                        // set the length for the Sid
                        //
                        pProcessArray[i].SizeOfSid = RtlLengthSid(pSid);
                        // GAP allocate a pointer and copy!
                        pProcessArray[i].pSid = AllocateGAPPointer(
                                                    pProcessArray[i].SizeOfSid
                                                    );
                        if (pProcessArray[i].pSid == NULL) {
                            *pResult = STATUS_NO_MEMORY;
                            break;
                        }

                        *pResult = RtlCopySid(
                                    pProcessArray[i].SizeOfSid,
                                    pProcessArray[i].pSid,
                                    pSid
                                    );
                        if (!(NT_SUCCESS(*pResult))) {
                            break;
                        }


                    }
                    else
                    {
                        //
                        // set a NULL Sid
                        //
                        pProcessArray[i].pSid = NULL;
                        pProcessArray[i].SizeOfSid = 0;
                    }
                    //
                    // next entry
                    //

                    TotalOffset += pProcessInfo->NextEntryOffset;

                    
                    pProcessInfo = (PTS_SYS_PROCESS_INFORMATION_NT6)&pProcessBuffer[TotalOffset];

                    
                }
                
                if (*pResult != STATUS_SUCCESS) // we finally failed !
                {
//                    DBGPRINT(( "TERMSRV: RpcWinStationGAP: ultimate failure\n"));

                    //
                    //  free all SIDs
                    //
                    for (i=0; i < NumberOfProcesses; i++)
                    {
                        if (pProcessArray[i].pSid != NULL)
                        {
                            LocalFree(pProcessArray[i].pSid);
                        }
                    }
                    //
                    //  free the array
                    //
                    LocalFree(pProcessArray);
                    pProcessArray = NULL;
                    //
                    //  free the buffer
                    //
                    LocalFree(pProcessBuffer);
                    pProcessBuffer = NULL;
                }
            }

			if (pProcessids)
				LocalFree(pProcessids);

        }
    }

    if (NT_SUCCESS(*pResult))
    {
//        DBGPRINT(( "TERMSRV: RpcWinStationGAP: Everything went fine\n"));

        //
        //  From that moment, we may receive some MIDL_user_free
        //  so enable the database checking
        //
        ValidateGAPPointersDatabase(NumberOfProcesses);

        *pNumberOfProcesses = NumberOfProcesses;
        *ppTsAllProcessesInfo = (PBYTE) pProcessArray;
    
    }
    else    // error case
    {
        *pNumberOfProcesses = 0;
        *ppTsAllProcessesInfo = NULL;
    }


    return ( (NT_SUCCESS(*pResult))? TRUE : FALSE);
}


/*******************************************************************************
 *  RpcWinStationGetAllProcesses_NT6
 *
 *    Replaces RpcWinStationGetAllProcesses for Win2K servers.
 *
 * EXIT:
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *    FALSE -- The operation failed.  Extended error status is returned in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationGetAllProcesses_NT6(
        HANDLE  hServer,
        DWORD   *pResult,
        ULONG   Level,
        ULONG   *pNumberOfProcesses,
        PTS_ALL_PROCESSES_INFO_NT6  *ppTsAllProcessesInfo
        )
{
    BOOLEAN Result;
    PTS_ALL_PROCESSES_INFO_NT6	pProcessInfo;

    Result = WinStationGetAllProcessesWorker(
        hServer, 
        pResult, 
        Level, 
        pNumberOfProcesses,
        (PBYTE *)&pProcessInfo
        );

    *ppTsAllProcessesInfo = pProcessInfo;

    return Result;
}



/*******************************************************************************
 *
 *  RpcWinStationGetAllProcesses
 *
 *    Replaces RpcWinStationEnumerateProcesses for NT5.0 servers.
 *		(Now used only by winsta client of Win2K)
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is returned in pResult.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationGetAllProcesses(
    HANDLE  hServer,
    DWORD   *pResult,
    ULONG   Level,
    ULONG   *pNumberOfProcesses,
    PTS_ALL_PROCESSES_INFO  *ppTsAllProcessesInfo
    )
{
    BOOLEAN Result;
    PTS_ALL_PROCESSES_INFO	pProcessInfo;

    Result = WinStationGetAllProcessesWorker(
        hServer, 
        pResult, 
        Level, 
        pNumberOfProcesses,
        (PBYTE *)&pProcessInfo
        );

    *ppTsAllProcessesInfo = pProcessInfo;

    return Result;
}


/*******************************************************************************
 *  RpcWinStationGetLanAdapterName
 *
 * EXIT:
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *    FALSE -- The operation failed.  Extended error status is returned in pResult.
 ******************************************************************************/

#define RELEASEPTR(iPointer)  \
    if (iPointer) {  \
        iPointer->lpVtbl->Release(iPointer);  \
        iPointer = NULL;  \
    }

BOOLEAN RpcWinStationGetLanAdapterName(
        HANDLE  hServer,
        DWORD   *pResult,
        DWORD PdNameSize,
        PWCHAR  pPdName,
        ULONG   LanAdapter,
        ULONG   *pLength,
        PWCHAR  *ppLanAdapterName)
{
    HRESULT hResult = S_OK;
    HRESULT hr = S_OK;

    //Interface pointer declarations
    WCHAR szProtocol[256];
    INetCfg * pnetCfg = NULL;
    INetCfgClass * pNetCfgClass = NULL;
    INetCfgClass * pNetCfgClassAdapter = NULL;
    INetCfgComponent * pNetCfgComponent = NULL;
    INetCfgComponent * pNetCfgComponentprot = NULL;
    IEnumNetCfgComponent * pEnumComponent = NULL;
    INetCfgComponentBindings * pBinding = NULL;
    LPWSTR pDisplayName = NULL;
    DWORD dwCharacteristics;
    ULONG count = 0;
    PWCHAR pLanAdapter = NULL;

    *ppLanAdapterName = NULL;
    *pLength = 0;
    *pResult = STATUS_SUCCESS;    

    // 0 corresponds to "All network adapters"

    if (0 == LanAdapter) {
        pLanAdapter = MIDL_user_allocate((DEVICENAME_LENGTH + 1) * sizeof(WCHAR));
        if (pLanAdapter == NULL) {
            *pResult = STATUS_NO_MEMORY;
            goto done;
        }
        else {
            if (!LoadString(hModuleWin, STR_ALL_LAN_ADAPTERS, pLanAdapter,
                    DEVICENAME_LENGTH + 1)) {
                *pResult = STATUS_UNSUCCESSFUL;
                MIDL_user_free(pLanAdapter);
                goto done;
            }

            *ppLanAdapterName = pLanAdapter;
            *pLength = (DEVICENAME_LENGTH + 1);
            goto done;
        }
    }

    try{

        NTSTATUS StringStatus ; 

        // Do some buffer validation
        // No of bytes (and not no of WCHARS) is sent from the Client, so send half the length got 
        StringStatus = IsZeroterminateStringW(pPdName, PdNameSize / sizeof(WCHAR) );
        if (StringStatus != STATUS_SUCCESS) {
            *pResult = STATUS_INVALID_PARAMETER;
             goto done;
        }

        if (0 == _wcsnicmp( pPdName , L"tcp", PdNameSize/sizeof(WCHAR))) {
            lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_TCPIP);
        }
        else if( 0 == _wcsnicmp( pPdName , L"netbios", PdNameSize/sizeof(WCHAR)) ) {
            lstrcpy(szProtocol,NETCFG_SERVICE_CID_MS_NETBIOS);
        }
        else if( 0 == _wcsnicmp( pPdName , L"ipx", PdNameSize/sizeof(WCHAR)) ) {
            lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
        }
        else if( 0 == _wcsnicmp( pPdName , L"spx", PdNameSize/sizeof(WCHAR)) ) {
            lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWSPX);
        }
        else {
            *pResult = STATUS_INVALID_PARAMETER;
            goto done;
        }
    } except(EXCEPTION_EXECUTE_HANDLER){
       *pResult =  STATUS_INVALID_PARAMETER;
       goto done;
    }


    hResult = CoCreateInstance(&CLSID_CNetCfg, NULL, CLSCTX_SERVER,
            &IID_INetCfg, (LPVOID *)&pnetCfg);
    if (FAILED(hResult)) {
        *pResult = STATUS_UNSUCCESSFUL;
        goto done;
    }

    if (pnetCfg != NULL) {
        hResult = pnetCfg->lpVtbl->Initialize(pnetCfg,NULL );
        if (FAILED(hResult) || pnetCfg == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        if (lstrcmpi(szProtocol, NETCFG_SERVICE_CID_MS_NETBIOS) == 0) {
            hResult = pnetCfg->lpVtbl->QueryNetCfgClass(pnetCfg,
                    &GUID_DEVCLASS_NETSERVICE, &IID_INetCfgClass,
                    (void **)&pNetCfgClass);
            if (FAILED(hResult) || pNetCfgClass == NULL) {
                *pResult = STATUS_UNSUCCESSFUL;
                goto done;
            }
        }
        else {
            hResult = pnetCfg->lpVtbl->QueryNetCfgClass(pnetCfg,
                    &GUID_DEVCLASS_NETTRANS, &IID_INetCfgClass,
                    (void **)&pNetCfgClass);
            if (FAILED( hResult ) || pNetCfgClass == NULL) {
                *pResult = STATUS_UNSUCCESSFUL;
                goto done;
            }
        }

        hResult = pnetCfg->lpVtbl->QueryNetCfgClass(pnetCfg,
                &GUID_DEVCLASS_NET, &IID_INetCfgClass,
                (void **)&pNetCfgClassAdapter);
        if (FAILED( hResult ) || pNetCfgClassAdapter == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        hResult = pNetCfgClass->lpVtbl->FindComponent(pNetCfgClass,
                szProtocol, &pNetCfgComponentprot);
        if (FAILED( hResult ) || pNetCfgComponentprot == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        hResult = pNetCfgComponentprot->lpVtbl->QueryInterface(
                pNetCfgComponentprot, &IID_INetCfgComponentBindings,
                (void **)&pBinding);
        if (FAILED( hResult ) || pBinding == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        hResult = pNetCfgClassAdapter->lpVtbl->EnumComponents(
                pNetCfgClassAdapter, &pEnumComponent);

        RELEASEPTR(pNetCfgClassAdapter);

        if (FAILED( hResult ) || pEnumComponent == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        *pResult = STATUS_UNSUCCESSFUL;

        while(TRUE) {
            hr = pEnumComponent->lpVtbl->Next(pEnumComponent, 1,
                    &pNetCfgComponent,&count);
            if (count == 0 || NULL == pNetCfgComponent)
                break;

            hr = pNetCfgComponent->lpVtbl->GetCharacteristics(
                    pNetCfgComponent,&dwCharacteristics);
            if (FAILED(hr)) {
                RELEASEPTR(pNetCfgComponent);
                continue;
            }

            if (dwCharacteristics & NCF_PHYSICAL) {
                if (S_OK == pBinding->lpVtbl->IsBoundTo(pBinding,
                        pNetCfgComponent)) {
                    GUID guidNIC;
                    /*index++;
                    if(index == LanAdapter)
                    {
                        hResult = pNetCfgComponent->lpVtbl->GetDisplayName(pNetCfgComponent,&pLanAdapter);

                         if( FAILED( hResult ) )
                         {
                             *pResult = STATUS_UNSUCCESSFUL;
                         }
                         else
                         {
                             *ppLanAdapterName = MIDL_user_allocate((lstrlen(pLanAdapter) + 1) * sizeof(WCHAR));
                             if (*ppLanAdapterName  == NULL)
                             {
                                 *pResult = STATUS_NO_MEMORY;
                             }
                             else
                             {
                                 lstrcpy(*ppLanAdapterName,pLanAdapter);
                                 *pLength = (lstrlen(pLanAdapter) + 1);
                                 *pResult = STATUS_SUCCESS;
                             }
                             CoTaskMemFree(pLanAdapter);
                             break;
                        }
                    }
                    */

                    hResult = pNetCfgComponent->lpVtbl->GetInstanceGuid(
                            pNetCfgComponent , &guidNIC);
                    if (SUCCEEDED( hResult )) {
                        hResult = pNetCfgComponent->lpVtbl->GetDisplayName(
                                pNetCfgComponent, &pLanAdapter);
                    }
                    if (SUCCEEDED(hResult)) {
                        WCHAR wchRegKey[ MAX_PATH ];
                        WCHAR wchGUID[ 40 ];
                        HKEY hKey;

                        lstrcpy( wchRegKey , REG_GUID_TABLE );

                        // convert the 128bit value into a string
                        StringFromGUID2(&guidNIC, wchGUID,
                                sizeof( wchGUID ) / sizeof( WCHAR ));

                        // create the full regkey
                        lstrcat( wchRegKey , wchGUID );

                        // find guid in guid table
                        hResult = (HRESULT)RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                wchRegKey, 0, KEY_READ, &hKey);

                        if (hResult == ERROR_SUCCESS) {
                            DWORD dwSize = sizeof( DWORD );
                            DWORD dwLana = 0;

                            RegQueryValueEx(hKey, LANA_ID, NULL, NULL,
                                    (LPBYTE)&dwLana, &dwSize);
                            RegCloseKey(hKey);

                            // if we have a match allocate space for the lanadapter name
                            // and then lets split
                            if (LanAdapter == dwLana) {
                                *ppLanAdapterName = MIDL_user_allocate(
                                        (lstrlen(pLanAdapter) + 1) *
                                        sizeof(WCHAR));

                                if ( *ppLanAdapterName == NULL ) {
                                    *pResult = STATUS_NO_MEMORY;
                                }
                                else {
                                    lstrcpy( *ppLanAdapterName , pLanAdapter );
                                    *pLength = ( lstrlen( pLanAdapter ) + 1 );
                                    *pResult = STATUS_SUCCESS;
                                }

                                CoTaskMemFree(pLanAdapter);
                                break;
                            }
                        }

                        CoTaskMemFree(pLanAdapter);
                    }
                }
            }
        }

        RELEASEPTR(pNetCfgComponent);
    }


done:
    RELEASEPTR(pBinding);
    RELEASEPTR(pEnumComponent);
    RELEASEPTR(pNetCfgComponentprot);
    RELEASEPTR(pNetCfgComponent);
    RELEASEPTR(pNetCfgClass);

    if ( pnetCfg != NULL )
        pnetCfg->lpVtbl->Uninitialize(pnetCfg);

    RELEASEPTR(pnetCfg);

    CoUninitialize();

    return *pResult == STATUS_SUCCESS ? TRUE : FALSE;
}


/*******************************************************************************
 *
 *    RpcWinStationGetAllProcesses_NT6_notify_flag
 *
 *      This callback function is called by the RPC server stub at the very end
 *      (after all the calls to MIDL_user_free).
 *      This allows us to free the remaining pointers.
 *      We also release the lock so that a new RpcWinStationGetAllProcesses
 *      can be processed.
 *
 ******************************************************************************/
void RpcWinStationGetAllProcesses_NT6_notify_flag(boolean fServerCalled)
{
//    DBGPRINT(( "TERMSRV: Entering RpcWinStationGAP_notify\n"));

    if (!fServerCalled)
        return;

    if (gbRpcGetAllProcessesOK == TRUE)
    {
        //
        // free our own pointers, free the database and disable the checking
        //
        ReleaseGAPPointersDatabase();

        //
        // release the lock that has been held since we entered
        // RpcWinStationGetAllProcesses
        //
        RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
    }
}


/*******************************************************************************
 *
 *    RpcWinStationGetAllProcesses_notify_flag
 *
 *      This callback function is called by the RPC server stub at the very end
 *      (after all the calls to MIDL_user_free).
 *      This allows us to free the remaining pointers.
 *      We also release the lock so that a new RpcWinStationGetAllProcesses
 *      can be processed.
 *
 ******************************************************************************/
void RpcWinStationGetAllProcesses_notify_flag(boolean fServerCalled)
{
//    DBGPRINT(( "TERMSRV: Entering RpcWinStationGAP_notify\n"));

    if (!fServerCalled)
        return;

    if (gbRpcGetAllProcessesOK == TRUE)
    {
        //
        // free our own pointers, free the database and disable the checking
        //
        ReleaseGAPPointersDatabase();

        //
        // release the lock that has been held since we entered
        // RpcWinStationGetAllProcesses
        //
        RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
    }
}


/*****************************************************************************
 *
 *  RpcWinStationGetProcessSid
 *
 *   RpcWinStationGetProcessSid API
 *
 * ENTRY:
 *   hServer           - input, The serrver handle to work on.
 *   dwUniqueProcessId - input, ProcessID (its not really unique)
 *   ProcessStartTime  - input, ProcessStartTime combined with ProcessID
 *                       identifies a unique process
 *   pResult           - output, error code
 *   pProcessUserSid   - output, process user sid
 *   dwSidSize         - input, sid size allocated.
 *
 * EXIT:
 *   TRUE   -   Requested Sid is in pProcessUserSid.
 *   FALSE  -   The operation failed. Status code is in pResult.
 *
 ****************************************************************************/
BOOLEAN RpcWinStationGetProcessSid(
        HANDLE          hServer,
        DWORD           dwUniqueProcessId,
        LARGE_INTEGER   ProcessStartTime,
        LONG            *pResult,   //  Really an NTSTATUS
        PBYTE           pProcessUserSid,
        DWORD           dwSidSize,
        DWORD           *pdwSizeNeeded)
{
    PSID pSid;

    RtlEnterCriticalSection(&gRpcGetAllProcessesLock);

    // Check if SID cache hasn't grown too much
    CheckSidCacheSize();

    *pResult = GetSidFromProcessId(
                (HANDLE)(ULONG_PTR)dwUniqueProcessId,
                ProcessStartTime,
                &pSid
                );

    if (NT_SUCCESS(*pResult)) {
        *pdwSizeNeeded = RtlLengthSid(pSid);

        if (*pdwSizeNeeded <= dwSidSize) {
            if (pProcessUserSid == NULL) {
                *pResult = STATUS_INVALID_PARAMETER;
            } else {
                *pResult = RtlCopySid(
                            *pdwSizeNeeded,
                            pProcessUserSid,
                            pSid
                            );
            }
        } else {
            *pResult = STATUS_BUFFER_TOO_SMALL;
        }
    } else {
        *pdwSizeNeeded = 0;
    }

    RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);

    return(*pResult == STATUS_SUCCESS ? TRUE : FALSE);
}


/*******************************************************************************
 *
 *  RpcWinStationRename
 *
 *    Renames a window station object in the session manager.
 *
 * ENTRY:
 *
 *    pWinStationNameOld (input)
 *       Old name of window station.
 *
 *    pWinStationNameNew (input)
 *       New name of window station.
 *
 *
 * EXIT:
 *
 *    TRUE  -- The rename operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationRename(
        HANDLE hServer,
        DWORD   *pResult,
        PWCHAR pWinStationNameOld,
        DWORD  NameOldSize,
        PWCHAR pWinStationNameNew,
        DWORD  NameNewSize
        )
{
    *pResult = WinStationRenameWorker(
                   pWinStationNameOld,
                   NameOldSize,
                   pWinStationNameNew,
                   NameNewSize
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationQueryInformation
 *
 *    Queries configuration information about a window station object.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_QUERY access.
 *
 *    WinStationInformationClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       window station object.
 *
 *    pWinStationInformation (output)
 *       A pointer to a buffer that will receive information about the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being queried.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 *    pReturnLength (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes placed in the window station information buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationQueryInformation(
        HANDLE hServer,
        DWORD  *pResult,
        ULONG  LogonId,
        DWORD  WinStationInformationClass,
        PCHAR  pWinStationInformation,
        DWORD  WinStationInformationLength,
        DWORD  *pReturnLength
        )
{
    if (!pReturnLength) {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }

    // Do minimal buffer validation
    if ((pWinStationInformation == NULL ) && (WinStationInformationLength != 0)) {
       *pResult = STATUS_INVALID_USER_BUFFER;
       return FALSE;
    }


    *pResult = xxxWinStationQueryInformation(
                   LogonId,
                   WinStationInformationClass,
                   pWinStationInformation,
                   WinStationInformationLength,
                   pReturnLength
                   );


    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationSetInformation
 *
 *    Sets configuration information for a window station object.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_SET access.
 *
 *    WinStationInformationClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       window station object.
 *
 *    pWinStationInformation (input)
 *       A pointer to a buffer that contains information to set for the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being set.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The set operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationSetInformation(
        HANDLE hServer,
        DWORD  *pResult,
        ULONG  LogonId,
        DWORD  WinStationInformationClass,
        PCHAR  pWinStationInformation,
        ULONG  WinStationInformationLength
        )
{
    // Do minimal buffer validation
    if ((pWinStationInformation == NULL ) && (WinStationInformationLength != 0)) {
       *pResult = STATUS_INVALID_USER_BUFFER;
       return FALSE;
    }


    *pResult = xxxWinStationSetInformation(
                   LogonId,
                   WinStationInformationClass,
                   pWinStationInformation,
                   WinStationInformationLength
                   );


    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcLogonIdFromWinStationName
 *
 *    Returns the LogonId for the specified window station name.
 *
 * ENTRY:
 *
 *    pWinStationName (input)
 *       Window station name.
 *
 *    pLogonId (output)
 *       Pointer to where to place the LogonId if found
 *
 * EXIT:
 *
 *    If the function succeeds, the return value is TRUE, otherwise, it is
 *    FALSE.
 *    To get extended error information, use the GetLastError function.
 *
 ******************************************************************************/
BOOLEAN
RpcLogonIdFromWinStationName(
        HANDLE hServer,
        DWORD  *pResult,
        PWCHAR pWinStationName,
        DWORD  NameSize,
        PULONG pLogonId
        )
{

    *pResult = LogonIdFromWinStationNameWorker(
                   pWinStationName,
                   NameSize,
                   pLogonId
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationNameFromLogonId
 *
 *    Returns the WinStation name for the specified LogonId.
 *
 * ENTRY:
 *
 *    LogonId (output)
 *       LogonId to query
 *
 *    pWinStationName (input)
 *       Location to return WinStation name
 *
 * EXIT:
 *
 *    If the function succeeds, the return value is TRUE, otherwise, it is
 *    FALSE.
 *    To get extended error information, use the GetLastError function.
 *
 ******************************************************************************/
BOOLEAN
RpcWinStationNameFromLogonId(
        HANDLE hServer,
        DWORD  *pResult,
        ULONG  LogonId,
        PWCHAR pWinStationName,
        DWORD  NameSize
        )
{
    if((NameSize < ((WINSTATIONNAME_LENGTH + 1) * sizeof(WCHAR))) ||
        (IsBadWritePtr(pWinStationName, NameSize)))
    {
         *pResult = STATUS_INVALID_PARAMETER;
         return FALSE;
    }

    *pResult = IcaWinStationNameFromLogonId(
                   LogonId,
                   pWinStationName
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationDisconnect
 *
 *    Disconects a window station object from the configured terminal and Pd.
 *    While disconnected all window station i/o is bit bucketed.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       ID of window station object to disconnect.
 *    bWait (input)
 *       Specifies whether or not to wait for disconnect to complete
 *
 * EXIT:
 *
 *    TRUE  -- The disconnect operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/
BOOLEAN
RpcWinStationDisconnect(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    *pResult = WinStationDisconnectWorker(
                   LogonId,
                   bWait,
                   TRUE
                   );
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationConnect
 *
 *    Connects a window station object to the configured terminal and Pd.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       ID of window station object to connect.
 *
 *    TargetLogonId (input)
 *       ID of target window station.
 *
 *    pPassword (input)
 *       password of LogonId window station (not needed if same domain/username)
 *
 *    bWait (input)
 *       Specifies whether or not to wait for connect to complete
 *
 * EXIT:
 *
 *    TRUE  -- The connect operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/
BOOLEAN
RpcWinStationConnect(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  ClientLogonId,
    ULONG  ConnectLogonId,
    ULONG  TargetLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize,
    BOOLEAN bWait
    )
{

    // Do some buffer Validation


    *pResult = IsZeroterminateStringW(pPassword, PasswordSize  );

    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = WinStationConnectWorker(
                   ClientLogonId,
                   ConnectLogonId,
                   TargetLogonId,
                   pPassword,
                   PasswordSize,
                   bWait,
                   FALSE
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationVirtualOpen
 *
 *   Open a virtual channel
 ****************************************************************************/
BOOLEAN
RpcWinStationVirtualOpen(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    DWORD Pid,
    PCHAR pVirtualName,   /* ascii name */
    DWORD  NameSize,
    DWORD *pHandle
    )
{
    RPC_STATUS RpcStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PWINSTATION pWinStation;
    HANDLE pidhandle = NULL;
    HANDLE handle = NULL;

    // Check channel name length.

    try{
       ULONG ulChannelNameLength;
       ulChannelNameLength =  strlen( pVirtualName );
       if ( !ulChannelNameLength ||
            (ulChannelNameLength > VIRTUALCHANNELNAME_LENGTH) || 
            ulChannelNameLength >= NameSize
           ) {
           Status = (DWORD)STATUS_INVALID_PARAMETER;
           goto done;
       }
    } except(EXCEPTION_EXECUTE_HANDLER){
       Status = (DWORD)STATUS_INVALID_PARAMETER;
       goto done;
    }

    /*
     * Impersonate the client so that when the attempt is made to open the
     * process, it will fail if the client does not have dup handle access.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationVirtualOpen: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status = (DWORD)STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    pidhandle = OpenProcess( PROCESS_DUP_HANDLE, FALSE, Pid );

    RpcRevertToSelf();

    if ( !pidhandle ) {
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * Make sure the caller has WINSTATION_VIRTUAL access
     */
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_VIRTUAL, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Don't allow VirtualChannel opens on listner or idle sessions
     */
    if( pWinStation->State == State_Listen ||
        pWinStation->State == State_Idle )
    {
        ReleaseWinStation( pWinStation);
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * Duplicate the virtual channel.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Virtual,
                             pVirtualName,
                             &handle );

    ReleaseWinStation( pWinStation );

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                handle,
                                pidhandle,
                                (PHANDLE)pHandle,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );

done:
    if ( handle )
        IcaChannelClose( handle );
    if ( pidhandle )
        NtClose( pidhandle );
    *pResult = Status;

    if ( NT_SUCCESS(Status) )
        return( TRUE );
    else
        return( FALSE );
}


/*****************************************************************************
 *  RpcWinStationBeepOpen
 *
 *   Open a beep channel
 ****************************************************************************/
BOOLEAN
RpcWinStationBeepOpen(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    DWORD Pid,
    DWORD *pHandle
    )
{
    RPC_STATUS RpcStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PWINSTATION pWinStation;
    HANDLE pidhandle = NULL;
    HANDLE handle = NULL;

    /*
     * Impersonate the client so that when the attempt is made to open the
     * process, it will fail if the client does not have dup handle access.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationBeepOpen: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status = (DWORD)STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    pidhandle = OpenProcess( PROCESS_DUP_HANDLE, FALSE, Pid );

    RpcRevertToSelf();

    if ( !pidhandle ) {
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * Make sure the caller has WINSTATION_VIRTUAL access
     */
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_VIRTUAL, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Duplicate the beep channel.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Beep,
                             NULL,
                             &handle );

    ReleaseWinStation( pWinStation );

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                handle,
                                pidhandle,
                                (PHANDLE)pHandle,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );

done:
    if ( handle )
        IcaChannelClose( handle );
    if ( pidhandle )
        NtClose( pidhandle );
    *pResult = Status;

    if ( NT_SUCCESS(Status) )
        return( TRUE );
    else
        return( FALSE );
}


/*******************************************************************************
 *  RpcWinStationReset
 *
 *    Reset the specified window station.
 *
 * ENTRY:
 *    LogonId (input)
 *       Identifies the window station object to reset.
 *    bWait (input)
 *       Specifies whether or not to wait for reset to complete
 *
 * EXIT:
 *    TRUE  -- The reset operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationReset(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    NTSTATUS Status;

    *pResult = WinStationResetWorker(
                   LogonId,
                   bWait,
                   TRUE,    // Rpc caller, must check access
                   TRUE     // By default, recreate the WinStation
                   );

    //
    // dont return STATUS_TIMEOUT.
    //

    if (*pResult == STATUS_TIMEOUT) *pResult = STATUS_UNSUCCESSFUL;
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationShadowStop
 *
 *    Stop any shadow operation on the specified window station.
 *
 * ENTRY:
 *    LogonId (input)
 *       Identifies the window station object to reset.
 *    bWait (input)
 *       Specifies whether or not to wait for reset to complete
 *
 * EXIT:
 *    TRUE  -- The stop shadow operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationShadowStop(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    BOOLEAN bWait // unused - later?
    )
{
    PWINSTATION pWinStation;
    ULONG       ClientLogonId;
    NTSTATUS    Status;
    RPC_STATUS  RpcStatus;
    UINT        LocalFlag;


    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: RpcWinStationShadowStop, LogonId=%d\n", LogonId ));


    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto notfound;
    }

    //
    // If the session is NOT being shadowed then bail out
    //
    if ( !( pWinStation->State == State_Active &&
            !IsListEmpty(&pWinStation->ShadowHead) ) ) {
        Status = STATUS_CTX_SHADOW_NOT_RUNNING;
        goto done;
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadowStop: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status =  STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    //
    // If its remote RPC call we should ignore ClientLogonId
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "ERMSRV: RpcWinStationShadowStop: I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // Get the client session id if it's local
    //
    if (LocalFlag) {
        Status = RpcGetClientLogonId( &ClientLogonId );
        if ( !NT_SUCCESS( Status ) ) {
            RpcRevertToSelf();
            goto done;
        }
    }


    //
    // Check for Disconnect or Reset rights since these two operations
    // would anyway terminate the shadow.
    //
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_DISCONNECT | WINSTATION_RESET, TRUE );

    //
    // If the access is denied then see if the client is on the same session
    // and check to see if the user has the veto right to being shadowed.
    //
    if( !NT_SUCCESS(Status) && LocalFlag && (ClientLogonId == LogonId ) ) {

        switch ( pWinStation->Config.Config.User.Shadow ) {

            case Shadow_EnableInputNotify :
            case Shadow_EnableNoInputNotify :

                Status = STATUS_SUCCESS;
                break;

            default :

                // other cases : don't touch the Status
                break;
        }

    } // else : The call comes from a remote machine or a different session.

    RpcRevertToSelf();

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    Status = WinStationStopAllShadows( pWinStation );

done:

    ReleaseWinStation( pWinStation );

notfound:

    *pResult = Status;

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationShutdownSystem
 *
 *    Shutdown the system and optionally logoff all WinStations
 *    and/or reboot the system.
 *
 * ENTRY:
 *    ShutdownFlags (input)
 *       Flags which specify shutdown options.
 *
 * EXIT:
 *    TRUE  -- The shutdown operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationShutdownSystem(
    HANDLE hServer,
    DWORD  *pResult,
    DWORD  ClientLogonId,
    ULONG  ShutdownFlags
    )
{
    *pResult = WinStationShutdownSystemWorker( ClientLogonId, ShutdownFlags );
    if (AuditingEnabled() && (ShutdownFlags & WSD_LOGOFF)
            && (*pResult == STATUS_SUCCESS))
        AuditShutdownEvent();

    //
    // dont return STATUS_TIMEOUT.
    //

    if (*pResult == STATUS_TIMEOUT) *pResult = STATUS_UNSUCCESSFUL;
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationTerminateProcess
 *
 *    Terminate the specified process
 *
 * ENTRY:
 *    hServer (input)
 *       handle to winframe server
 *    pResult (output)
 *       address to return error status
 *    ProcessId (input)
 *       process id of the process to terminate
 *    ExitCode (input)
 *       Termination status for each thread in the process
 *
 * EXIT:
 *    TRUE  -- The terminate operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationTerminateProcess(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  ProcessId,
    ULONG  ExitCode
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client so that when the attempt is made to terminate
     * the process, it will fail if the account is not admin.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationTerminateProcess: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (DWORD)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    *pResult = WinStationTerminateProcessWorker( ProcessId, ExitCode );

    RpcRevertToSelf();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationWaitSystemEvent
 *
 *    Waits for an event (WinStation create, delete, connect, etc) before
 *    returning to the caller.
 *
 * ENTRY:
 *    EventFlags (input)
 *       Bit mask that specifies which event(s) to wait for.
 *    pEventFlags (output)
 *       Bit mask of event(s) that occurred.
 *
 * EXIT:
 *    TRUE  -- The wait event operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationWaitSystemEvent(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG EventMask,
    PULONG pEventFlags
    )
{
    *pResult = WinStationWaitSystemEventWorker( hServer, EventMask, pEventFlags );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationShadow
 *
 *   Start a Winstation shadow operation
 *
 * ENTRY:
 *   hServer (input)
 *     shadow client server handle
 *   pResult (output)
 *     address to return status
 *   LogonId (input)
 *     shadow client logon id
 *   pTargetServerName (input)
 *     shadow target server name
 *   NameSize (input)
 *     size of pTargetServerName (input)
 *   TargetLogonId (input)
 *     shadow target login id (where the app is running)
 *   HotkeyVk (input)
 *     virtual key to press to stop shadow
 *   HotkeyModifiers (input)
 *     virtual modifer to press to stop shadow (i.e. shift, control)
 ****************************************************************************/
BOOLEAN
RpcWinStationShadow(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    PWSTR pTargetServerName,
    ULONG NameSize,
    ULONG TargetLogonId,
    BYTE HotkeyVk,
    USHORT HotkeyModifiers
    )
{
    RPC_STATUS RpcStatus;

    // Do minimal buffer validation
    if (pTargetServerName != NULL) {
        // No of bytes is sent from the Client, so send half the length got 
        *pResult = (DWORD)IsZeroterminateStringW(pTargetServerName, NameSize / sizeof(WCHAR));
        if (*pResult != STATUS_SUCCESS) {
            return FALSE;
        }

        if (wcslen(pTargetServerName) > (MAX_COMPUTERNAME_LENGTH)) {
            *pResult = STATUS_INVALID_USER_BUFFER;
            return FALSE;
        }
    }

    /*
     * Impersonate the client so that when the shadow connection is
     * created, it will have the correct security.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadow: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (DWORD)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    *pResult = (DWORD)WinStationShadowWorker( LogonId,
                                              pTargetServerName,
                                              TargetLogonId,
                                              HotkeyVk,
                                              HotkeyModifiers );

    RpcRevertToSelf();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationShadowTargetSetup
 *
 *   Setup a Winstation shadow operation
 *
 * ENTRY:
 *   hServer (input)
 *     target server
 *   pResult (output)
 *     address to return status
 *   LogonId (input)
 *      target logon id
 ****************************************************************************/
BOOLEAN
RpcWinStationShadowTargetSetup(
    HANDLE hServer,
    DWORD  *pResult,
    IN ULONG LogonId
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client so that the shadow connect request
     * will be under the correct security context.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadow: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (DWORD)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    *pResult = (DWORD)WinStationShadowTargetSetupWorker( LogonId );

    RpcRevertToSelf();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationShadowTarget
 *
 *   Start a Winstation shadow operation
 *
 * ENTRY:
 *   hServer (input)
 *     target server
 *   pResult (output)
 *     address to return status
 *   LogonId (input)
 *      target logon id
 *   pConfig (input)
 *      pointer to WinStation config data
 *   NameSize (input)
 *      length of config data
 *   pAddress (input)
 *      address of shadow client
 *   AddressSize (input)
 *      length of address
 *   pModuleData (input)
 *      pointer to client module data
 *   ModuleDataLength (input)
 *      length of client module data
 *   pThinwireData (input)
 *      pointer to thinwire module data
 *   ThinwireDataLength (input)
 *      length of thinwire module data
 *   pClientName (input)
 *      pointer to client name string (domain/username)
 *   ClientNameLength (input)
 *      length of client name string
 ****************************************************************************/
BOOLEAN
RpcWinStationShadowTarget(
    HANDLE hServer,
    DWORD  *pResult,
    IN ULONG LogonId,
    IN PBYTE pConfig,
    IN DWORD NameSize,
    IN PBYTE pAddress,
    IN DWORD AddressSize,
    IN PBYTE pModuleData,
    IN DWORD ModuleDataLength,
    IN PBYTE pThinwireData,
    IN DWORD ThinwireDataLength,
    IN PBYTE pClientName,
    IN DWORD ClientNameLength
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Validate  buffers .
     */
    if (AddressSize  <  sizeof(ICA_STACK_ADDRESS) ||
        pClientName == NULL ||
        NameSize  < sizeof(WINSTATIONCONFIG2)) {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }
    // No of bytes is sent from the Client, so send half the length got 
    *pResult = (DWORD)IsZeroterminateStringW((PWCHAR)pClientName,ClientNameLength / sizeof(WCHAR));
    if (*pResult != STATUS_SUCCESS) {
        return FALSE;
    }

    /*
     * Impersonate the client so that the shadow connect request
     * will be under the correct security context.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadow: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (DWORD)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    *pResult = (DWORD)WinStationShadowTargetWorker(
                                                    FALSE,        // Shadower not a Help Assistant session.
                                                    FALSE,  // protocol shadow, can't be help assistant session
                                                    LogonId,
                                                    (PWINSTATIONCONFIG2) pConfig,
                                                    (PICA_STACK_ADDRESS) pAddress,
                                                    (PVOID) pModuleData,
                                                    ModuleDataLength,
                                                    (PVOID) pThinwireData,
                                                    ThinwireDataLength,
                                                    pClientName );

    RpcRevertToSelf();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationGenerateLicense
 *
 *  Called to generate a license from a given serial number string.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pSerialNumberString (input)
 *       Pointer to a null-terminated, wide-character Serial Number string
 *    pLicense (output)
 *       Pointer to a License structure that will be filled in with
 *       information based on pSerialNumberString
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *    TRUE  -- The generate operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationGenerateLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PWCHAR pSerialNumberString,
    DWORD  Length,
    PCHAR  pLicense,
    DWORD  LicenseSize
    )
{
    RPC_STATUS RpcStatus;

    //
    // The WinFrame licensing API's load the Ulm DLL in the context
    // of the ICASRV process, and then attempt to access the
    // WinFrame licensing registry keys. By impersonating the caller,
    // we can make sure that the license key operation is done under
    // the callers subject context. This will fail for non-admin callers, as
    // defined by the ACL placed on the licensing keys.
    //

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationGenerateLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationGenerateLicense(
                 pSerialNumberString,
                 Length,
                 pLicense,
                 LicenseSize
                 );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationGenerateLicense ) {
            *pResult = pWsx->pWsxWinStationGenerateLicense(
                         pSerialNumberString,
                         Length,
                         pLicense,
                         LicenseSize
                         );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "WinStationGenerateLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationInstallLicense
 *
 *  Called to install a license.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be installed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *    TRUE  -- The install operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationInstallLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR  pLicense,
    DWORD  LicenseSize
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationInstallLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationInstallLicense(
                 pLicense,
                 LicenseSize
                 );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationInstallLicense ) {
            *pResult = pWsx->pWsxWinStationInstallLicense(
                        pLicense,
                        LicenseSize
                        );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationInstallLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationEnumerateLicenses
 *
 *  Called to return the list of valid licenses.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\WinStations subkeys in the
 *       registry.  Should be set to 0 for the initial call, and supplied
 *       again (as modified by this function) for multi-call enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pLicense (input/output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of LICENSE structures.  If this parameter
 *       is NULL, then no data will be copied, but just an enumeration count
 *       will be made.
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pWinStationName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pLicense.
 *
 * EXIT:
 *    TRUE  -- The enumerate operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationEnumerateLicenses(
    HANDLE hServer,
    DWORD  *pResult,
    DWORD  *pIndex,
    DWORD  *pEntries,
    PCHAR  pLicense,
    DWORD  LicenseSize,
    DWORD  *pByteCount
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationEnumerateLicenses: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationEnumerateLicenses(
                 pIndex,
                 pEntries,
                 pLicense,
                 pByteCount
                 );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationEnumerateLicenses ) {
            *pResult = pWsx->pWsxWinStationEnumerateLicenses(
                         pIndex,
                         pEntries,
                         pLicense,
                         pByteCount
                         );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationEnumerateLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationActivateLicense
 *
 *  Called to Activate a license for a License
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (output)
 *       Pointer to a License structure that will be filled in with
 *       information based on pSerialNumberString
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *    pActivationCode (input)
 *       Pointer to a null-terminated, wide-character Activation Code string
 *
 * EXIT:
 *    TRUE  -- The activate operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationActivateLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR  pLicense,
    DWORD  LicenseSize,
    PWCHAR pActivationCode,
    DWORD StringSize
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationActivateLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationActivateLicense(
                   pLicense,
                   LicenseSize,
                   pActivationCode,
                   StringSize
                   );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationActivateLicense ) {
            *pResult = pWsx->pWsxWinStationActivateLicense(
                           pLicense,
                           LicenseSize,
                           pActivationCode,
                           StringSize
                           );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationActivateLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationQueryLicense
 *
 *   Query the license(s) on the WinFrame server and the network
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicenseCounts (output)
 *       pointer to buffer to return license count structure
 *    ByteCount (input)
 *       length of buffer in bytes
 *
 * EXIT:
 *    TRUE  -- The query operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ****************************************************************************/
BOOLEAN
RpcWinStationQueryLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR pLicenseCounts,
    ULONG ByteCount
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationQueryLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = QueryLicense(
                   (PLICENSE_COUNTS) pLicenseCounts,
                   ByteCount );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxQueryLicense ) {
            *pResult = pWsx->pWsxQueryLicense(
                           pLicenseCounts,
                           ByteCount );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationQueryLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationQueryUpdateRequired
 *
 *   Query the license(s) on the WinFrame server and determine if an
 *   update is required.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pUpdateFlag (output)
 *       Update flag, set if an update is required
 *
 * EXIT:
 *    TRUE  -- The query operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ****************************************************************************/
BOOLEAN
RpcWinStationQueryUpdateRequired(
    HANDLE hServer,
    DWORD  *pResult,
    PULONG pUpdateFlag
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationQueryUpdateRequired: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationQueryUpdateRequired( pUpdateFlag );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationQueryUpdateRequired ) {
            *pResult = pWsx->pWsxWinStationQueryUpdateRequired( pUpdateFlag );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationRemoveLicense
 *
 *  Called to remove a license diskette.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be removed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *    TRUE  -- The remove operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationRemoveLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR  pLicense,
    DWORD  LicenseSize
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationRemoveLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationRemoveLicense(
                   pLicense,
                   LicenseSize
                   );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationRemoveLicense ) {
            *pResult = pWsx->pWsxWinStationRemoveLicense(
                           pLicense,
                           LicenseSize
                           );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationRemoveLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationSetPoolCount
 *
 *  Called to change the PoolCount for the given license
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be removed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *    TRUE  -- The change operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationSetPoolCount(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR  pLicense,
    DWORD  LicenseSize
    )
{
    RPC_STATUS RpcStatus;

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationSetPoolCount: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationSetPoolCount(
                   pLicense,
                   LicenseSize
                   );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationSetPoolCount ) {
            *pResult = pWsx->pWsxWinStationSetPoolCount(
                           pLicense,
                           LicenseSize
                           );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationSetPoolCount: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationAnnoyancePopup
 ****************************************************************************/
BOOLEAN
RpcWinStationAnnoyancePopup(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  LogonId
    )
{
    PWINSTATION pWinStation;
    NTSTATUS Status;

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( LogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = WinStationLogonAnnoyance( LogonId );
#else
    //  Assume the worst
    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    //  Check for compatibility
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation != NULL ) {
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxWinStationLogonAnnoyance ) {
            UnlockWinStation( pWinStation );
            *pResult = pWinStation->pWsx->pWsxWinStationLogonAnnoyance( LogonId );
            RelockWinStation( pWinStation );
        /*
         * If WinStation has no Wsx structure, wen try to annoy it anyway.
         * This will have the effect of sending annoy msgs to the console.
         */
        } else if ( pWinStation->pWsx == NULL ) {
            PLIST_ENTRY Head, Next;
            PWSEXTENSION pWsx;
            ICASRVPROCADDR IcaSrvProcAddr;

            RtlEnterCriticalSection( &WsxListLock );

            Head = &WsxListHead;
            for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
                pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
                if ( pWsx->pWsxWinStationLogonAnnoyance ) {
                    UnlockWinStation( pWinStation );
                    *pResult = pWsx->pWsxWinStationLogonAnnoyance( LogonId );
                    RelockWinStation( pWinStation );
                    break;
               }
            }

            RtlLeaveCriticalSection( &WsxListLock );
        }
        ReleaseWinStation( pWinStation );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationAnnoyancePopup: 0x%x\n", *pResult ));
#endif

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationCallback
 ****************************************************************************/
BOOLEAN
RpcWinStationCallback(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  LogonId,
    PWCHAR pPhoneNumber,
    DWORD  PhoneNumberSize
    )
{
    NTSTATUS Status;

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( LogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationCallbackWorker( LogonId, pPhoneNumber );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationBreakPoint
 ****************************************************************************/
BOOLEAN
RpcWinStationBreakPoint(
    HANDLE  hServer,
    DWORD   *pResult,
    ULONG   LogonId,
    BOOLEAN KernelFlag
    )
{
    /*
     * This is obsolete and should be removed from the RPC code.
     */
    *pResult = STATUS_NOT_IMPLEMENTED;
    RpcRaiseException(ERROR_INVALID_FUNCTION);
    return FALSE;
}


/*****************************************************************************
 *  RpcWinStationReadRegistry
 ****************************************************************************/
BOOLEAN
RpcWinStationReadRegistry(
    HANDLE  hServer,
    DWORD   *pResult
    )
{
    /*
     * This API is not secured, since it is harmless. It tells the system
     * to make sure all winstations are up to date with the registry. You
     * must be system to write the keys, so the info would match for a normal
     * user poking this call.
     */

    return RpcWinStationUpdateSettings(hServer, pResult, WINSTACFG_LEGACY, 0);
}


/*****************************************************************************
 *  RpcWinStationUpdateSettings
 ****************************************************************************/
BOOLEAN
RpcWinStationUpdateSettings(
    HANDLE  hServer,
    DWORD   *pResult,
    DWORD SettingsClass,
    DWORD SettingsParameters
    )
{
    /*
     * This API is not secured, since it is harmless. It tells the system
     * to make sure all winstations are up to date with the registry. You
     * must be system to write the keys, so the info would match for a normal
     * user poking this call.
     */

    switch (SettingsClass) {

        case WINSTACFG_SESSDIR:
        {
            if (!g_bPersonalTS && g_fAppCompat) {
                *pResult = UpdateSessionDirectory();
            }
            else {
                // Invalid in remote admin or on PTS
                *pResult = STATUS_INVALID_PARAMETER;
            }
        }
        break;

        case WINSTACFG_LEGACY:
        {
            *pResult = WinStationReadRegistryWorker();
        }
        break;

        default:
        {
            *pResult = STATUS_INVALID_PARAMETER;
        }
    }
 
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}



/*****************************************************************************
 *  RpcReInitializeSecurity
 ****************************************************************************/
BOOLEAN
RpcWinStationReInitializeSecurity(
    HANDLE  hServer,
    DWORD   *pResult
    )
{
    /*
     * This API is not secured, since it is harmless. It tells the system
     * to update all winstations security configuration. You
     * must be system to write the keys, so the info would match for a normal
     * user poking this call.
     */

    *pResult = ReInitializeSecurityWorker();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationWaitForConnect
 ****************************************************************************/
BOOLEAN
RpcWinStationWaitForConnect(
    HANDLE  hServer,
    DWORD   *pResult,
    DWORD   ClientLogonId,
    DWORD   ClientProcessId
    )
{
    PWINSTATION pWinStation;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE WinlogonStartHandle = NULL;
    WCHAR  szWinlogonStartEvent[MAX_PATH];
    UNICODE_STRING WinlogonEventName;
    OBJECT_ATTRIBUTES ObjA;
    LARGE_INTEGER TimeOut ;
    ULONG SleepDuration = 90 * 1000; // 90 seconds

    //
    // Winlogon can call into Terminal Server, before we store the session id in its internal structure
    // To prevent this, RpcWinStationWaitForConnect (which is called by Winlogon) will wait for a named event 
    // This is the same Named event (CsrStartEvent) which the Csr also waits for before calling into TermSrv
    //

    if (ClientLogonId != 0) {

        wsprintf(szWinlogonStartEvent,
            L"\\Sessions\\%d\\BaseNamedObjects\\CsrStartEvent",ClientLogonId);

        RtlInitUnicodeString( &WinlogonEventName, szWinlogonStartEvent );
        InitializeObjectAttributes( &ObjA, &WinlogonEventName, OBJ_OPENIF, NULL, NULL );
    
        Status = NtCreateEvent( &WinlogonStartHandle,
                                EVENT_ALL_ACCESS,
                                &ObjA,
                                NotificationEvent,
                                FALSE );

        if (!WinlogonStartHandle) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto error_exit;
        } else {

            TimeOut = RtlEnlargedIntegerMultiply( SleepDuration, -10000);
            Status = NtWaitForSingleObject(WinlogonStartHandle, FALSE, &TimeOut);

            NtClose(WinlogonStartHandle);
            WinlogonStartHandle = NULL;

            if (!NT_SUCCESS(Status) || (Status == STATUS_TIMEOUT)) {
                // We timed out waiting for Session Creation to get complete - cant connect now, just exit 
                goto error_exit;
            }
        }
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitForConnect, LogonId=%d\n",ClientLogonId ));

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        *pResult = (DWORD)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    *pResult = (DWORD)WaitForConnectWorker( pWinStation, (HANDLE)(ULONG_PTR)ClientProcessId );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );

error_exit:
    *pResult = Status;

    //
    // dont return STATUS_TIMEOUT.
    //

    if (*pResult == STATUS_TIMEOUT) *pResult = STATUS_UNSUCCESSFUL;

    return FALSE;

}


/*****************************************************************************
 *  RpcWinStationNotifyLogon
 ****************************************************************************/
BOOLEAN
RpcWinStationNotifyLogon(
    HANDLE  hServer,
    DWORD   *pResult,
    DWORD   ClientLogonId,
    DWORD   ClientProcessId,
    BOOLEAN fUserIsAdmin,
    DWORD   UserToken,
    PWCHAR  pDomain,
    DWORD   DomainSize,
    PWCHAR  pUserName,
    DWORD   UserNameSize,
    PWCHAR  pPassword,
    DWORD   PasswordSize,
    UCHAR   Seed,
    PCHAR   pUserConfig,
    DWORD   ConfigSize
    )
{
    NTSTATUS Status;


    /*
     * Do some buffer validation
     * No of bytes is sent from the Client, so send half the length got 
     */

    *pResult = IsZeroterminateStringW(pPassword, PasswordSize / sizeof(WCHAR) );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = IsZeroterminateStringW(pUserName, UserNameSize / sizeof(WCHAR) );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = IsZeroterminateStringW(pDomain, DomainSize / sizeof(WCHAR) );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationNotifyLogonWorker(
            ClientLogonId,
            ClientProcessId,
            fUserIsAdmin,
            UserToken,
            pDomain,
            DomainSize,
            pUserName,
            UserNameSize,
            pPassword,
            PasswordSize,
            Seed,
            pUserConfig,
            ConfigSize
            );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationNotifyLogoff
 ****************************************************************************/
BOOLEAN
RpcWinStationNotifyLogoff(
    HANDLE  hServer,
    DWORD   ClientLogonId,
    DWORD   ClientProcessId,
    DWORD   *pResult
    )
{
    NTSTATUS Status;

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationNotifyLogoffWorker(
                   ClientLogonId,
                   ClientProcessId
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationNotifyNewSession
 *
 *  THIS FUNCTION IS OBSOLETE AND SHOULD BE REMOVED FROM FUTURE VERSIONS OF
 *  INTERFACE.
 ****************************************************************************/
BOOLEAN
RpcWinStationNotifyNewSession(
    HANDLE hServer,
    DWORD  *pResult,
    DWORD  ClientLogonId
    )
{
    *pResult = STATUS_SUCCESS;

    return(TRUE);
}


/*******************************************************************************
 *  RpcWinStationSendMessage
 *
 *    Sends a message to the specified window station object and optionally
 *    waits for a reply.  The reply is returned to the caller of
 *    WinStationSendMessage.
 *
 * ENTRY:
 *    WinStationHandle (input)
 *       Specifies the window station object to send a message to.
 *    pTitle (input)
 *       Pointer to title for message box to display.
 *    TitleLength (input)
 *       Length of title to display in bytes.
 *    pMessage (input)
 *       Pointer to message to display.
 *    MessageLength (input)
 *       Length of message in bytes to display at the specified window station.
 *    Style (input)
 *       Standard Windows MessageBox() style parameter.
 *    Timeout (input)
 *       Response timeout in seconds.  If message is not responded to in
 *       Timeout seconds then a response code of IDTIMEOUT (cwin.h) is
 *       returned to signify the message timed out.
 *    pResponse (output)
 *       Address to return selected response.
 *    DoNotWait (input)
 *       Do not wait for the response. Causes pResponse to be set to
 *       IDASYNC (cwin.h) if no errors queueing the message.
 *
 * EXIT:
 *    TRUE  -- The send message operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationSendMessage(
        HANDLE hServer,
        DWORD  *pResult,
        ULONG  LogonId,
        PWCHAR pTitle,
        ULONG  TitleLength,
        PWCHAR pMessage,
        ULONG MessageLength,
        ULONG Style,
        ULONG Timeout,
        PULONG pResponse,
        BOOLEAN DoNotWait
        )
{
    PWINSTATION pWinStation;
    WINSTATION_APIMSG WMsg;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        *pResult = (DWORD)STATUS_CTX_WINSTATION_NOT_FOUND;
        return( FALSE );
    }

    Status = RpcCheckClientAccess( pWinStation, WINSTATION_MSG, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        ReleaseWinStation( pWinStation );
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "RpcWinStationSendMessage: pTitle   %S\n", pTitle ));
    TRACE((hTrace,TC_ICASRV,TT_API1, "RpcWinStationSendMessage: pMessage %S\n", pMessage ));

    /*
     * Marshall in the [in] parameters
     *
     * pTitle and pMessage will be mapped into client
     * view at apropriate time and place
     */

    WMsg.u.SendMessage.pTitle = pTitle;
    WMsg.u.SendMessage.TitleLength = TitleLength;
    WMsg.u.SendMessage.pMessage = pMessage;
    WMsg.u.SendMessage.MessageLength = MessageLength;
    WMsg.u.SendMessage.Style = Style;
    WMsg.u.SendMessage.Timeout = Timeout;
    WMsg.u.SendMessage.DoNotWait = DoNotWait;
    WMsg.u.SendMessage.pResponse = pResponse;

    WMsg.ApiNumber = SMWinStationDoMessage;

    /*
     *  Create wait event
     */
    if( !DoNotWait ) {
        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        Status = NtCreateEvent( &WMsg.u.SendMessage.hEvent, EVENT_ALL_ACCESS, &ObjA,
                                NotificationEvent, FALSE );
        if ( !NT_SUCCESS(Status) ) {
            *pResult = Status;
            goto done;
        }
    }

    /*
     *  Initialize response to IDTIMEOUT or IDASYNC
     */

    if (DoNotWait) {
        *pResponse = IDASYNC;
    } else {
        *pResponse = IDTIMEOUT;
    }

    /*
     * Tell the WinStation to display the message box
     */
    *pResult = SendWinStationCommand( pWinStation, &WMsg, 0 );

    /*
     *  Wait for response, pResponse filled in WinStationIcaReplyMessage
     */
    if( !DoNotWait ) {
        if (*pResult == STATUS_SUCCESS) {
            TRACE((hTrace,TC_ICASRV,TT_API1, "RpcWinStationSendMessage: wait for response\n" ));
            UnlockWinStation( pWinStation );
            Status = NtWaitForSingleObject( WMsg.u.SendMessage.hEvent, FALSE, NULL );
            if ( !RelockWinStation( pWinStation ) ) {
                Status = STATUS_CTX_CLOSE_PENDING;
            }
            *pResult = Status;
            TRACE((hTrace,TC_ICASRV,TT_API1, "RpcWinStationSendMessage: got response %u\n", *pResponse ));
        }
        NtClose( WMsg.u.SendMessage.hEvent );
    }

done:

    ReleaseWinStation( pWinStation );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  SERVER_HANDLE_rundown
 *
 *   Required RPC context run down routine.
 *
 *   This gets called when the RPC client drops or closes
 *   the connection and allows us to cleanup any state
 *   information.
 *
 * ENTRY:
 *   phContext (input)
 *     Context handle being rundown
 ****************************************************************************/
VOID
SERVER_HANDLE_rundown(
    HANDLE hContext
    )
{
    DWORD Result;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: Context rundown, %p\n", hContext));

    //RpcWinStationCloseServerEx( &hContext, &Result );
    //ASSERT(hContext == NULL);

    midl_user_free(hContext);
    hContext = NULL;

    return;
}


/*
 * The following functions allow us to control the
 * memory allocation and free functions of the RPC.
 */

void __RPC_FAR * __RPC_USER
MIDL_user_allocate( size_t Size )
{
    return( LocalAlloc(LMEM_FIXED,Size) );
}


void __RPC_USER
MIDL_user_free( void __RPC_FAR *p )
{
    if (!PointerIsInGAPDatabase(p))
    {
//        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: MIDL_user_free for 0x%x....FREE it\n",p));
        LocalFree( p );
    }
    else
    {
//        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: MIDL_user_free for 0x%x..................DON'T FREE IT\n",p));
    }
}


/*******************************************************************************
 *  NotifySystemEvent
 *
 *   Notify clients that a system event occured.
 *
 * ENTRY:
 *    EventMask (input)
 *       mask of event(s) that have occured
 ******************************************************************************/
VOID
NotifySystemEvent( ULONG EventMask )
{
    PLIST_ENTRY Head, Next;
    PEVENT pWaitEvent;
    NTSTATUS Status;

    if ( IsListEmpty( &SystemEventHead ) ) {
        return;
    }

    TRACE((hTrace,TC_ICAAPI,TT_API3, "TERMSRV: NotifySystemEvent, Event=0x%08x\n", EventMask ));

    RtlEnterCriticalSection( &WinStationListLock );
    Head = &SystemEventHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWaitEvent = CONTAINING_RECORD( Next, EVENT, EventListEntry );
        if ( pWaitEvent->EventMask & EventMask ) {
            pWaitEvent->EventFlags |= EventMask;
            if ( pWaitEvent->fWaiter ) {
                pWaitEvent->WaitResult = STATUS_SUCCESS;
                NtSetEvent( pWaitEvent->Event, NULL );
            }
        }
    }

    RtlLeaveCriticalSection( &WinStationListLock );
}


/*****************************************************************************
 *  WinStationDisconnectWorker
 *
 *   Function to disconnect a Winstation based on an RPC API request.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationDisconnectWorker(
    ULONG LogonId,
    BOOLEAN bWait,
    BOOLEAN CallerIsRpc
    )
{
    PWINSTATION pWinStation;
    ULONG ClientLogonId;
    ULONG PdFlag;
    WINSTATIONNAME WinStationName;
    WINSTATIONNAME ListenName;
    NTSTATUS Status;
    BOOLEAN bConsoleSession = FALSE;
    UINT        LocalFlag = FALSE;
    BOOLEAN bRelock;
    BOOLEAN bIncrementFlag = FALSE; 

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationDisconnect, LogonId=%d\n", LogonId ));

    //
    //There are some bad ginas that break 
    //console disconnection bug 345286
    //
    if(LogonId == 0 && !IsGinaVersionCurrent()) {
        Status = STATUS_CTX_CONSOLE_DISCONNECT;
        goto done;
    }

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    if (LogonId == 0 && !bConsoleConnected){

       Status = WaitForConsoleConnectWorker(  pWinStation );
       if (NT_SUCCESS(Status)) {
           bConsoleConnected=TRUE;
       } else {
           ReleaseWinStation( pWinStation );
           goto done;
       }

    }

    /*
     * Note if we are disconnecting a session that is connected to the console terminal.
     */

    bConsoleSession = pWinStation->fOwnsConsoleTerminal;

    /*
     * Verify that client has DISCONNECT access if its an RPC (external) caller.
     *
     * When ICASRV calls this function internally, it is not impersonating
     * and fails the RpcCheckClientAccess() call. Internal calls are
     * not a security problem since they come in as LPC messages on a secured
     * port.
     */
    if ( CallerIsRpc ) {
        RPC_STATUS RpcStatus;

        /*
         * Impersonate the client
         */
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK ) {
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationDisconnectWorker: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            Status = STATUS_CANNOT_IMPERSONATE;
            goto done;
        }

        Status = RpcCheckClientAccess( pWinStation, WINSTATION_DISCONNECT, TRUE );
        if ( !NT_SUCCESS( Status ) ) {
            RpcRevertToSelf();
            ReleaseWinStation( pWinStation );
            goto done;
        }

        //
        // If its remote RPC call we should ignore ClientLogonId
        //
        RpcStatus = I_RpcBindingIsClientLocal(
                        0,    // Active RPC call we are servicing
                        &LocalFlag
                        );

        if( RpcStatus != RPC_S_OK ) {
            RpcRevertToSelf();
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationDisconnectWorker: IsClientLocal failed! RpcStatus 0x%x\n",RpcStatus));
            Status = STATUS_UNSUCCESSFUL;
            goto done;
        }

        if ( LocalFlag ) {
            Status = RpcGetClientLogonId( &ClientLogonId );
            if ( !NT_SUCCESS( Status ) ) {
                RpcRevertToSelf();
                ReleaseWinStation( pWinStation );
                goto done;
            }
        }

        RpcRevertToSelf();
    }

    /*
     * If WinStation is already disconnected, then we're done
     */
    if ( !pWinStation->WinStationName[0] )  {
        ReleaseWinStation( pWinStation );
        return (STATUS_SUCCESS);
    }

    /*
     * If we are disconnecting the console session, we want to make sure
     * that we can precreate a session that would become the console session.
     */
    if (bConsoleSession && !ShutdownInProgress) {
        UnlockWinStation(pWinStation);
        Status = CheckIdleWinstation();
        bRelock = RelockWinStation(pWinStation);
        if (!NT_SUCCESS(Status) || !bRelock) {
            if (NT_SUCCESS(Status)) {
                Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            }
            ReleaseWinStation( pWinStation );
            goto done;
        }

    }

    /*
     * If busy with something already, don't do this
     */
    if ( pWinStation->NeverConnected || pWinStation->Flags ) {

        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto done;
    }


    if (bConsoleSession) {
        InterlockedIncrement(&gConsoleCreationDisable);
        bIncrementFlag = TRUE; 
    }

    /*
     * If no broken reason/source have been set, then set them here.
     *
     * BrokenReason is Disconnect.  BrokenSource is User if we are
     * called via RPC and caller is disconnecting his own LogonId.
     */
    if ( pWinStation->BrokenReason == 0 ) {
        pWinStation->BrokenReason = Broken_Disconnect;
        if ( CallerIsRpc &&  LocalFlag  && ClientLogonId == pWinStation->LogonId ) {
            pWinStation->BrokenSource = BrokenSource_User;
        } else {
            pWinStation->BrokenSource = BrokenSource_Server;
        }
    }

    /*
     * If it's an external request (RPC) then set the last error
     * state to the client to indicate what the reason for the
     * disconnection was.
     *
     */
    if( CallerIsRpc && pWinStation )
    {
        if(pWinStation->pWsx &&
           pWinStation->pWsx->pWsxSetErrorInfo &&
           pWinStation->pWsxContext)
        {
            pWinStation->pWsx->pWsxSetErrorInfo(
                               pWinStation->pWsxContext,
                               TS_ERRINFO_RPC_INITIATED_DISCONNECT,
                               FALSE); //stack lock not held
        }
    }

    /*
     * If the RPC caller did not wish to wait for this disconnect,
     * then queue an internal call for this to be done.
     * This is safe now that we have done all of the above checks
     * to determine that the caller has access to perform the
     * disconnect and have set BrokenSource/Reason above.
     */
    if ( CallerIsRpc && !bWait ) {
        ReleaseWinStation( pWinStation );
        QueueWinStationDisconnect( LogonId );
        Status = STATUS_SUCCESS;
        goto done;
    }

    /*
     * Preserve some of this WinStation's state in case it's
     * needed after we disconnect and release it.
     */
    PdFlag = pWinStation->Config.Pd[0].Create.PdFlag;
    wcscpy( WinStationName, pWinStation->WinStationName );
    if ( !gbServer ) {
        wcscpy( ListenName, pWinStation->ListenName );
    }

    /*
     *  Notify the licensing core of the disconnect. Failures are ignored.
     */

    (VOID)LCProcessConnectionDisconnect(pWinStation);

    /*
     * Disconnect the WinStation
     */
    pWinStation->Flags |= WSF_DISCONNECT;
    Status = WinStationDoDisconnect( pWinStation, NULL, FALSE );
    pWinStation->Flags &= ~WSF_DISCONNECT;

    /*
     * If there is no user logged on (logon time is 0),
     * then queue a reset for this WinStation.
     *
     * We don't want to do this here directly since the RPC client may
     * NOT have reset access.  However, the behavior we want is that if
     * a WinStation with no user logged on is disconnected, it gets reset.
     * This is consistent with how we handle broken connections
     * (see WinStationBrokenConnection() in wstlpc.c).
     */
    if ( RtlLargeIntegerEqualToZero( pWinStation->LogonTime ) ) {
        QueueWinStationReset( pWinStation->LogonId);
    }

    ReleaseWinStation( pWinStation );

    // Increment the total number of disconnected sessions
    if (Status == STATUS_SUCCESS) {
        InterlockedIncrement(&g_TermSrvDiscSessions);
    }



    /*
     * For single-instance transports a listener must be re-created
     * upon disconnection
     */
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WinStationDisconnect: after disconnecting\n" ));


    if ( PdFlag & PD_SINGLE_INST ) {

        Status = QueueWinStationCreate( WinStationName );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WinStationDisconnect: QueueWinStationCreate returned 0x%x\n", Status ));
        if ( !NT_SUCCESS( Status ) ) {
            goto done;
        }
    }

     if ( !gbServer && ListenName[0]) {

         StartStopListeners( ListenName, FALSE );
     }

    /*
     * Determine return status and cleanup
     */
done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationDisconnect, Status=0x%x\n", Status ));

    if (bIncrementFlag) {
        InterlockedDecrement(&gConsoleCreationDisable);
        bIncrementFlag = FALSE;
    }

    // If we disconnected a Session owning the console terminal, go an create a new one
    // to own it.

    if (bConsoleSession) {
        ENTERCRIT(&ConsoleLock);
        if (!WinStationCheckConsoleSession()) {
            /*
             * Wake up the WinStationIdleControlThread
             */
            NtSetEvent(WinStationIdleControlEvent, NULL);

        }
        LEAVECRIT(&ConsoleLock);
    }
    return( Status );
}



/*****************************************************************************
 *  WinStationConnectWorker
 *
 *   Worker for handling WinStation connection called from RPC server.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    bAutoReconnecting (input)
 *      Boolean set to TRUE to indicate that this is a connection for the
 *      purposes of autoreconnection. This is important to allow an atomic
 *      autoreconnection by properly handling the WSF_AUTORECONNECTING flag
 *      that otherwise guards against race conditions while autoreconnecting.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationConnectWorker(
    ULONG  ClientLogonId,
    ULONG  ConnectLogonId,
    ULONG  TargetLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize,
    BOOLEAN bWait,
    BOOLEAN bAutoReconnecting
    )
{
    PWINSTATION pClientWinStation;
    PWINSTATION pSourceWinStation;
    PWINSTATION pTargetWinStation;
    PWINSTATION pWinStation;
    PSID pClientSid;
    UNICODE_STRING PasswordString;
    BOOLEAN fWrongPassword;
    PRECONNECT_INFO pTargetReconnectInfo = NULL;
    PRECONNECT_INFO pSourceReconnectInfo = NULL;
    BOOLEAN SourceConnected = FALSE;
    WINSTATIONNAME SourceWinStationName;
    NTSTATUS Status;
    ULONG    SidLength;
    PTOKEN_USER TokenInfo = NULL;
    HANDLE CurrentThreadToken = NULL;
    BOOLEAN bIsImpersonating = FALSE;
    ULONG Length;
    RPC_STATUS RpcStatus;
    BOOLEAN bConsoleSession = FALSE;
    ULONG ulIndex;
    LONG lActiveCount = 0;
    PLIST_ENTRY Head, Next;
    BOOLEAN fSourceAutoReconnecting = FALSE;
    BOOLEAN fTargetAutoReconnecting = FALSE;


    // Do not allow reconnection to the same session, for any session.
    // BUG 506808
    // This problem was only happening on a non-logged in console (bConsoleConnected=FALSE),  when from 
    // some other session, TsCon was used to connection session0 to console session:
    //      tscon 0 /dest:console
    // 

    if (TargetLogonId == ConnectLogonId)
    {
        Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
        return Status;
    }



    //
    //On session 0 it might happen that user already logged on,
    //but termsrv is not notified yet.
    //in this case "Local\\WinlogonTSSynchronizeEvent" event will be in
    //nonsignaled state. We need to refuse all attempts to connect to
    //session 0 untill this event is signaled.
    //
    if (ConnectLogonId == 0) {
        

        HANDLE hSyncEvent;
        DWORD dwWaitResult;

        hSyncEvent = OpenEventW(SYNCHRONIZE, FALSE, L"Local\\WinlogonTSSynchronizeEvent");
        if ( !hSyncEvent){
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL,
                "TERMSRV: Cannot open WinlogonTSSynchronizeEvent event. ERROR: %d\n",GetLastError()));
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
        
        dwWaitResult = WaitForSingleObject(hSyncEvent,0);

        CloseHandle(hSyncEvent);

        if(dwWaitResult != WAIT_OBJECT_0) {
            TRACE((hTrace,TC_ICASRV,TT_API1,
                "TERMSRV: WinStationConnectWorker. WinlogonTSSynchronizeEvent is not signaled.\n"));
            return STATUS_CTX_WINSTATION_BUSY;
        }

    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationConnect, LogonId=%u, Target LogonId=%u, (%S)\n",
              ConnectLogonId, TargetLogonId, pPassword ));

    /*
     * Allocate RECONNECT_INFO structures
     */

    if ((pTargetReconnectInfo = MemAlloc(sizeof(*pTargetReconnectInfo))) == NULL) {
        return STATUS_NO_MEMORY;
    }

    if ((pSourceReconnectInfo = MemAlloc(sizeof(*pSourceReconnectInfo))) == NULL) {
        MemFree(pTargetReconnectInfo);
        return STATUS_NO_MEMORY;
    }

   /*
    *  Impersonate the client and find the SID of the session initiating the
    *  connect operation
    */
   RpcStatus = RpcImpersonateClient( NULL );
   if ( RpcStatus != RPC_S_OK ) {
      KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: CheckClientAccess: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
      Status = STATUS_CANNOT_IMPERSONATE ;
      goto done;
   } else {
      bIsImpersonating = TRUE;
   }

    Status = NtOpenThreadToken(
                  NtCurrentThread(),
                  TOKEN_QUERY,
                  TRUE,              // Use service's security
                                     // context to open thread token
                  &CurrentThreadToken
                  );

   if (! NT_SUCCESS(Status)) {
       KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "Termsrv: Cannot open the current thread token %08lx\n",
                    Status));
       goto done;
   }
    /*
     * Determine size needed for token info buffer and allocate it
     */
    Status = NtQueryInformationToken( CurrentThreadToken, TokenUser,
                                      NULL, 0, &Length );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        goto done;
    }
    TokenInfo = MemAlloc( Length );
    if ( TokenInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    /*
     * Query token information to get client user's SID
     */
    Status = NtQueryInformationToken( CurrentThreadToken, TokenUser,
                                      TokenInfo, Length, &Length );
    if ( !NT_SUCCESS( Status ) ) {
        MemFree( TokenInfo );
        goto done;
    }


    SidLength = RtlLengthSid( TokenInfo->User.Sid );
    pClientSid = (PSID) MemAlloc( SidLength );
    if (!pClientSid) {
        MemFree( TokenInfo );
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    Status = RtlCopySid(SidLength, pClientSid, TokenInfo->User.Sid);
    if (!NT_SUCCESS(Status)) {
        MemFree( TokenInfo );
        MemFree( pClientSid );
        goto done;
    }

    NtClose( CurrentThreadToken );
    CurrentThreadToken = NULL;
    RpcRevertToSelf();
    bIsImpersonating = FALSE;
    MemFree( TokenInfo );

    /*
     * on non server make sure to fail reconnect if it is going to endup in more than one active session.
     */




    if (!gbServer) {
       Head = &WinStationListHead;
       ENTERCRIT( &WinStationListLock );
       for ( Next = Head->Flink; Next != Head; Next = Next->Flink) {
           pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
           if ( (pWinStation->State == State_Active) || (pWinStation->State == State_Shadow) ){
               if (pWinStation->LogonId != ConnectLogonId && pWinStation->LogonId != TargetLogonId  ) {
                   if (!TSIsSessionHelpSession(pWinStation, NULL)) {
                       lActiveCount ++;
                   }
               }
           }
       }
       LEAVECRIT( &WinStationListLock );
       if (lActiveCount != 0) {
           Status = STATUS_CTX_WINSTATION_NOT_FOUND;
           MemFree( pClientSid );
           goto done;
       }
    }


    /*
     * Find and lock the WinStation (source) for the specified LogonId
     */

    pSourceWinStation = FindWinStationById( ConnectLogonId, FALSE );
    if ( pSourceWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        MemFree( pClientSid );
        goto done;
    }
    if (ConnectLogonId == 0 && !bConsoleConnected ){

       Status = WaitForConsoleConnectWorker(  pSourceWinStation );
       if (NT_SUCCESS(Status)) {
           bConsoleConnected=TRUE;
       } else{
           ReleaseWinStation( pSourceWinStation );
           MemFree( pClientSid );
           goto done;
       }

    }

    /*
     * Verify that there is someone logged on (SALIMC)
     */
    if ( (ConnectLogonId != 0) && !pSourceWinStation->pUserSid ) {
        Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
        ReleaseWinStation( pSourceWinStation );
        MemFree( pClientSid );
        goto done;
    }

    /*
     * Verify that client has CONNECT access
     *
     * NOTE: This function clears pPassword whether successful or not
     *       to prevent its being paged out as clear text.
     */
    Status = _CheckConnectAccess(
                 pSourceWinStation,
                 pClientSid,
                 ClientLogonId,
                 pPassword,
                 PasswordSize
                 );
    MemFree( pClientSid );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pSourceWinStation );
        goto done;
    }

    //
    // Deterime if source is part of an autoreconnection
    //
    fSourceAutoReconnecting = bAutoReconnecting &&                            
                             (pSourceWinStation->Flags & WSF_AUTORECONNECTING);


    /*
     * Mark the winstation as being connected. (SALIMC)
     * If any operation (create/delete/reset/...) is already in progress
     * on this winstation, then don't proceed with the connect.
     * unless that operation is an autoreconnect and we are autoreconnecting
     */
    if (pSourceWinStation->LogonId == 0) {
        if (pSourceWinStation->Flags && !fSourceAutoReconnecting) {
          if ((pSourceWinStation->Flags & WSF_DISCONNECT) && (pSourceWinStation->UserName[0] == L'\0')) { 
             /* Let us wait for sometime here before setting Busy flag and exiting */
              for (ulIndex=0; ulIndex < WINSTATION_WAIT_RETRIES; ulIndex++) {
                  if ( pSourceWinStation->Flags ) {
                      LARGE_INTEGER Timeout;
                      Timeout = RtlEnlargedIntegerMultiply( WINSTATION_WAIT_DURATION, -10000 );
                      UnlockWinStation( pSourceWinStation );
                      NtDelayExecution( FALSE, &Timeout );
                      if ( !RelockWinStation( pSourceWinStation ) ) {
                          ReleaseWinStation( pSourceWinStation );
                          Status = STATUS_CTX_WINSTATION_BUSY;
                          goto done;
                      }
                  } else {
                      break;
                  }
              }
          }
          if (pSourceWinStation->Flags && !fSourceAutoReconnecting) {
              #if DBG
                DbgPrint("WinstationConnectWorker : Even after waiting for 2 mins,Winstation flag is not clear. Sending STATUS_CTX_WINSTATION_BUSY.\n");
              #endif
              Status = STATUS_CTX_WINSTATION_BUSY;
              ReleaseWinStation( pSourceWinStation );
              goto done;
          }
       }

    } else if ( pSourceWinStation->NeverConnected ||
         (pSourceWinStation->Flags && !fSourceAutoReconnecting) ||
         (pSourceWinStation->State != State_Active &&
          pSourceWinStation->State != State_Disconnected) ) {
        Status = STATUS_CTX_WINSTATION_BUSY;
        ReleaseWinStation( pSourceWinStation );
        goto done;
    }

    pSourceWinStation->Flags |= WSF_CONNECT;

    /*
     * Unlock the source WinStation but keep a reference to it.
     */
    UnlockWinStation( pSourceWinStation );

    /*
     * Now find and lock the target WinStation
     */
    pTargetWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pTargetWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto badname;
    }
    if (TargetLogonId == 0 && !bConsoleConnected){

        Status = WaitForConsoleConnectWorker(  pTargetWinStation );
        if (NT_SUCCESS(Status)) {
            bConsoleConnected=TRUE;
        }  else {
            ReleaseWinStation( pTargetWinStation );
            goto badname;
        }
    }

    /*
     * Verify that client has DISCONNECT access
     */
    Status = RpcCheckClientAccess( pTargetWinStation, WINSTATION_DISCONNECT, FALSE );
    if ( !NT_SUCCESS( Status ) )
        goto targetnoaccess;


    /*
     * Do not allow a client running on the same machine to reconnect a the console session to its own session.
     */

    if (pSourceWinStation->fOwnsConsoleTerminal && IsValidLoopBack(pTargetWinStation, ConnectLogonId, pTargetWinStation->Client.ClientSessionId)) {
        Status = STATUS_CTX_CONSOLE_CONNECT;
        goto targetnoconsole;
    }


    /*
     *  On server do not allow reconnecting a non zero session to the iconsole.
     */

    if (pTargetWinStation->fOwnsConsoleTerminal && gbServer && (ConnectLogonId != 0)) {
        Status = STATUS_CTX_CONSOLE_DISCONNECT;
        goto targetnoconsole;
    }

    // Whistler supports reconnecting a session from Console to a given Remote Protocol
    // But Whistler does not support direct reconnect from one remote protocol to a different remote protocol 
    // Check for the above condition and block this scenario

    if ( (pSourceWinStation->Client.ProtocolType != PROTOCOL_CONSOLE) && (pTargetWinStation->Client.ProtocolType != PROTOCOL_CONSOLE) ) {
        // This is not a Direct Console Disconnect/Reconnect Scenario
        if (pSourceWinStation->Client.ProtocolType != pTargetWinStation->Client.ProtocolType) {
            Status = STATUS_CTX_BAD_VIDEO_MODE ;
            goto targetnoaccess;

        }
    }

    /*
     *  Make sure the reconnected session is licensed.
     */

    Status = LCProcessConnectionReconnect(pSourceWinStation, pTargetWinStation);

    if (!NT_SUCCESS(Status))
    {
        goto badlicense;
    }

    fTargetAutoReconnecting = bAutoReconnecting &&                            
                             (pTargetWinStation->Flags & WSF_AUTORECONNECTING);
    /*
     * Mark the winstation as being disconnected.
     * If any operation (create/delete/reset/...) is already in progress
     * on this winstation, then don't proceed with the connect.
     */
    if ( pTargetWinStation->NeverConnected ||
         (pTargetWinStation->Flags && !fTargetAutoReconnecting)) {
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto targetbusy;
    }


    pTargetWinStation->Flags |= WSF_DISCONNECT;


    /*
     * Disconnect the target WinStation
     */
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationConnectWorker Disconnecting target!\n"));

    /*
     * Note if we are disconnecting the session that owns the console
     */
    if (pTargetWinStation->fOwnsConsoleTerminal) {

        bConsoleSession = TRUE;
        UnlockWinStation( pTargetWinStation );
        ENTERCRIT(&ConsoleLock);
        InterlockedIncrement(&gConsoleCreationDisable);
        LEAVECRIT(&ConsoleLock);
        if (!RelockWinStation( pTargetWinStation )) {
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            goto baddisconnecttarget;
        }

    }

    Status = WinStationDoDisconnect( pTargetWinStation, pTargetReconnectInfo, FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "WinStationConnectWorker Disconnecting target failed Status = %x!\n", Status));
        goto baddisconnecttarget;
    }

    /*
     * Unlock target WinStation but leave it referenced
     */
    UnlockWinStation( pTargetWinStation );


    /*
     * Relock the source WinStation
     */
    if ( !RelockWinStation( pSourceWinStation ) )
        goto sourcedeleted;

    /*
     * The source Winstation might have been deleted while it was unlocked.
     * Let's check this didn't happen because we don't want to reconnect to a
     * going away session (Bug#206614).
     */
    if (pSourceWinStation->Terminating || pSourceWinStation->StateFlags & WSF_ST_WINSTATIONTERMINATE)
        goto sourcedeleted;

    /*
     * If the source WinStation is currently connected, then disconnect it.
     */
    if ( pSourceWinStation->WinStationName[0] ) {
        SourceConnected = TRUE;

        /*
         * For single-instance transports a listener must be re-created upon disconnection
         * so we remember the source WinStation name.
         */
        if ( pSourceWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
            wcscpy( SourceWinStationName, pSourceWinStation->WinStationName );
        }

        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationConnectWorker Disconnecting Source!\n"));


        /*
         * Note if we are disconnecting the session that owns the console
         */
        if (pSourceWinStation->fOwnsConsoleTerminal) {
            /*
             * If we are disconnecting the console session, we want to make sure
             * that we can precreate a session that would become the console session.
             */

            UnlockWinStation( pSourceWinStation );
            if ( !ShutdownInProgress) {
                Status = CheckIdleWinstation();
                if (!NT_SUCCESS(Status)) {
                    RelockWinStation(pSourceWinStation);
                    goto baddisconnectsource;
                }

            }

            bConsoleSession = TRUE;
            ENTERCRIT(&ConsoleLock);
            InterlockedIncrement(&gConsoleCreationDisable);
            LEAVECRIT(&ConsoleLock);
            if (!RelockWinStation( pSourceWinStation )) {
                Status = STATUS_CTX_WINSTATION_NOT_FOUND;
                goto baddisconnectsource;
            }

        }


        if(pSourceWinStation->pWsx &&
           pSourceWinStation->pWsx->pWsxSetErrorInfo &&
           pSourceWinStation->pWsxContext)
        {
            //
            // Extended error reporting, set status to client.
            //
            pSourceWinStation->pWsx->pWsxSetErrorInfo(
                               pSourceWinStation->pWsxContext,
                               TS_ERRINFO_DISCONNECTED_BY_OTHERCONNECTION,
                               FALSE); //stack lock not held
        }


        Status = WinStationDoDisconnect( pSourceWinStation, pSourceReconnectInfo, TRUE );
        if ( !NT_SUCCESS( Status ) )  {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "WinStationConnectWorker Disconnecting source failed Status = %x!\n", Status));
            goto baddisconnectsource;
        }

                                
    }

    /*
     * Cause the source WinStation to connect using the stack state
     * obtained from the target WinStation.
     */


    Status = WinStationDoReconnect( pSourceWinStation, pTargetReconnectInfo );



    if ( !NT_SUCCESS( Status ) )
        goto badconnectsource;

    /*
     * Indicate source WinStation connect is complete and unlock it.
     */
    pSourceWinStation->Flags &= ~WSF_CONNECT;

    /*
     * Set Last Reconnect Type for the Source WinStation
     */

    if (bAutoReconnecting) {
        pSourceWinStation->LastReconnectType = AutoReconnect;
    } else {
        pSourceWinStation->LastReconnectType = ManualReconnect;
    }

    ReleaseWinStation( pSourceWinStation );


    /*
     * Indicate target WinStation disconnect is complete and unlock it.
     */
    if ( RelockWinStation( pTargetWinStation ) ) {
        pTargetWinStation->Flags &= ~WSF_DISCONNECT;

        /*
         * Clear all client license data and indicate
         * this WinStaion no longer holds a license.
         */
        if ( pTargetWinStation->pWsx &&
             pTargetWinStation->pWsx->pWsxClearContext ) {
            pTargetWinStation->pWsx->pWsxClearContext( pTargetWinStation->pWsxContext );
        }
    }

    ReleaseWinStation( pTargetWinStation );

    /*
     * If the source WinStation was connected and we disconnected it above,
     * then make sure we cleanup the reconnect structure.
     * (This will also complete the disconnect by closing the endpoint
     * that was connected to the source WinStation).
     * Also, if the source WinStation was a single-instance transport,
     * then we must re-create the listener.
     */
    if ( SourceConnected ) {
        CleanupReconnect( pSourceReconnectInfo );
        if ( (pSourceReconnectInfo->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinstationConnectWorker create new winstation: %S \n ", SourceWinStationName));
            QueueWinStationCreate( SourceWinStationName );
        }
    }

    // Stop the listener if the target was the last WinStation.
     if ( !gbServer ) {

         StartStopListeners( NULL, FALSE );
     }

    goto done;

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * Could not connect source WinStation
     */
badconnectsource:
    /*
     * If source WinStation was connected, try to reconnect if it is
     * NOT currently terminating.  If the reconnect does not succeed,
     * there's nothing else we can do.
     */
    if ( SourceConnected ) {
        CleanupReconnect( pSourceReconnectInfo );
        if ( !pSourceWinStation->Terminating &&
             !pSourceWinStation->WinStationName[0] ) {
            if ( pSourceReconnectInfo->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
                QueueWinStationCreate( pSourceReconnectInfo->WinStationName );
            }
        } 
    }

    /*
     * Could not disconnect source WinStation
     */
baddisconnectsource:

    /*
     * Source WinStation was deleted
     */
sourcedeleted:
    pSourceWinStation->Flags &= ~WSF_CONNECT;
    ReleaseWinStation( pSourceWinStation );
    pSourceWinStation = NULL;   // indicate source WinStation is released

    /*
     * Try to relock and reconnect the target WinStation.
     */
    if ( RelockWinStation( pTargetWinStation ) &&
         !pTargetWinStation->Terminating &&
         !pTargetWinStation->WinStationName[0] ) {
        NTSTATUS st;

        st = WinStationDoReconnect( pTargetWinStation, pTargetReconnectInfo );
        if ( !NT_SUCCESS( st ) ) {
            CleanupReconnect( pTargetReconnectInfo );
            if ( pTargetReconnectInfo->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
                QueueWinStationCreate( pTargetReconnectInfo->WinStationName );
            }
        }
    } else {
        CleanupReconnect( pTargetReconnectInfo );
    }

    /*
     * Could not disconnect target WinStation
     * Could not query target WinStation stack state
     */
baddisconnecttarget:
    /* clear disconnect flag, unlock/derererence target WinStation */
    pTargetWinStation->Flags &= ~WSF_DISCONNECT;

    /*
     * Target WinStation is busy or is the console
     */
targetbusy:
badlicense:
targetnoconsole:
targetnoaccess:
    ReleaseWinStation( pTargetWinStation );

badname:
    /* clear connect flag, unlock/derererence source WinStation */
    if ( pSourceWinStation ) {
        if ( RelockWinStation( pSourceWinStation ) )
            pSourceWinStation->Flags &= ~WSF_CONNECT;
        ReleaseWinStation( pSourceWinStation );
    }

done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationConnect, Status=0x%x\n", Status ));

    // If we disconnected a Session owning the console terminal, go an create a new one
    // to own it.

    if (bConsoleSession) {
        ENTERCRIT(&ConsoleLock);

        InterlockedDecrement(&gConsoleCreationDisable);





        if (!WinStationCheckConsoleSession()) {
            /*
             * Wake up the WinStationIdleControlThread
             */
            NtSetEvent(WinStationIdleControlEvent, NULL);

        }
        LEAVECRIT(&ConsoleLock);
    }

    // Increment total number of reconnected sessions
    if (Status == STATUS_SUCCESS) {
        InterlockedIncrement(&g_TermSrvReconSessions);
    }
    if (bIsImpersonating) {
       RpcRevertToSelf();
    }
    if (CurrentThreadToken) {
      NtClose( CurrentThreadToken );
    }

    // free RECONNECT_INFO structures

    MemFree(pTargetReconnectInfo);
    MemFree(pSourceReconnectInfo);

    return( Status );
}


/*****************************************************************************
 *  WinStationResetWorker
 *
 *   Function to reset a Winstation based on an RPC API request.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationResetWorker(
    ULONG   LogonId,
    BOOLEAN bWait,
    BOOLEAN CallerIsRpc,
    BOOLEAN bRecreate
    )
{
    PWINSTATION pWinStation;
    ULONG ClientLogonId;
    WINSTATIONNAME ListenName;
    NTSTATUS Status;
    ULONG ulIndex;
    BOOL bConnectDisconnectPending = TRUE;
    BOOL bConsoleSession = FALSE;
    BOOL bListener = FALSE;
    UINT LocalFlag = 0;
    BOOLEAN bRelock;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationReset, LogonId=%d\n", LogonId ));

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Note if we are disconnecting a session that is connected to the console terminal.
     */
    bConsoleSession = pWinStation->fOwnsConsoleTerminal;


    /*
     * If we are Resetting a non-zero console session, we want to make sure
     * that we can precreate a session that would become the console session.
     */
    if (bConsoleSession && !ShutdownInProgress && (pWinStation->LogonId != 0)) {
        UnlockWinStation(pWinStation);
        Status = CheckIdleWinstation();
        bRelock = RelockWinStation(pWinStation);
        if (!NT_SUCCESS(Status) || !bRelock) {
            if (NT_SUCCESS(Status)) {
                Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            }
            ReleaseWinStation( pWinStation );
            goto done;
        }

    }


    /*
     * Save off the listen name if needed later.
     */
    if ( pWinStation->Flags & WSF_LISTEN ) {
        wcscpy(ListenName, pWinStation->WinStationName);
        bListener = TRUE;
    } else if (!gbServer) {
        wcscpy(ListenName, pWinStation->ListenName);
    }

    /*
     * Verify that client has RESET access if its an RPC (external) caller.
     *
     * When ICASRV calls this function internally, it is not impersonating
     * and fails the RpcCheckClientAccess() call. Internal calls are
     * not a security problem since they come in as LPC messages on a secured
     * port.
     */
    if ( CallerIsRpc ) {
        RPC_STATUS RpcStatus;

        /*
         * Impersonate the client
         */
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK ) {
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationResetWorker: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            Status = STATUS_CANNOT_IMPERSONATE;
            goto done;
        }

        Status = RpcCheckClientAccess( pWinStation, WINSTATION_RESET, TRUE );
        if ( !NT_SUCCESS( Status ) ) {
            RpcRevertToSelf();
            ReleaseWinStation( pWinStation );
            goto done;
        }

        //
        // If its remote RPC call we should ignore ClientLogonId
        //
        RpcStatus = I_RpcBindingIsClientLocal(
                        0,    // Active RPC call we are servicing
                        &LocalFlag
                        );

        if( RpcStatus != RPC_S_OK ) {
            RpcRevertToSelf();
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationResetWorker: IsClientLocal failed! RpcStatus 0x%x\n",RpcStatus));
            Status = STATUS_UNSUCCESSFUL;
            goto done;
        }

        if ( LocalFlag ) {
            Status = RpcGetClientLogonId( &ClientLogonId );
            if ( !NT_SUCCESS( Status ) ) {
                RpcRevertToSelf();
                ReleaseWinStation( pWinStation );
                goto done;
            }
        }

        RpcRevertToSelf();

        if(pWinStation->WinStationName[0] &&
           pWinStation->pWsx &&
           pWinStation->pWsx->pWsxSetErrorInfo &&
           pWinStation->pWsxContext)
        {
            pWinStation->pWsx->pWsxSetErrorInfo(
                               pWinStation->pWsxContext,
                               TS_ERRINFO_RPC_INITIATED_LOGOFF,
                               FALSE); //stack lock not held
        }
    }

    /*
     * For console reset, logoff (SALIMC)
     */
    if ( LogonId == 0 ) {
        DWORD dwTimeOut = 120*1000;

#if DBG
        dwTimeOut = 240*1000;
#endif


        Status = LogoffWinStation( pWinStation,EWX_FORCE | EWX_LOGOFF);
        ReleaseWinStation( pWinStation );
        if (NT_SUCCESS(Status) && bWait) {
           DWORD dwRet;
           dwRet = WaitForSingleObject(ConsoleLogoffEvent,120*1000);
           if (dwRet == WAIT_TIMEOUT)
           {
              KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: TimedOut wait for ConsoleLogoffEvent\n"));
              Status = STATUS_TIMEOUT;
           }
        }
        goto done;
    }

    /*
     * Mark the winstation as being reset.
     * If a reset/delete operation is already in progress
     * on this winstation, then don't proceed with the delete.
     * If the WinStation is currently in the process of connecting or
     * disconnecting, then give it some time to complete before we continue.
     * If connect/disconnect doesn't complete whithin timeout duration
     * do not proceed with termination (bug#204614).
     */
    for (ulIndex=0; ulIndex < WINSTATION_WAIT_COMPLETE_RETRIES; ulIndex++) {
        if ( pWinStation->Flags & (WSF_RESET | WSF_DELETE) ) {
            ReleaseWinStation( pWinStation );
            Status = STATUS_CTX_WINSTATION_BUSY;
            goto done;
        }

        if ( pWinStation->Flags & (WSF_CONNECT | WSF_DISCONNECT |
                                   WSF_AUTORECONNECTING) ) {
            LARGE_INTEGER Timeout;
            Timeout = RtlEnlargedIntegerMultiply( WINSTATION_WAIT_COMPLETE_DURATION, -10000 );
            UnlockWinStation( pWinStation );
            NtDelayExecution( FALSE, &Timeout );
            if ( !RelockWinStation( pWinStation ) ) {
                ReleaseWinStation( pWinStation );
                Status = STATUS_SUCCESS;
                goto done;
            }
        } else {
            bConnectDisconnectPending = FALSE;
            break;
        }
    }

    if ( bConnectDisconnectPending ) {
        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto done;
    }

    pWinStation->Flags |= WSF_RESET;

    /*
     * If no broken reason/source have been set, then set them here.
     *
     * BrokenReason is Terminate.  BrokenSource is User if we are
     * called via RPC and caller is resetting his own LogonId, or if
     * the "Terminating" field is already set, then this is a reset
     * from the WinStationTerminateThread after seeing WinLogon/CSR exit.
     * Otherwise, this reset is the result of a call from another
     * WinStation or a QueueWinStationReset call from within ICASRV.
     */
    if ( pWinStation->BrokenReason == 0 ) {
        pWinStation->BrokenReason = Broken_Terminate;
        if ( CallerIsRpc && LocalFlag  && ClientLogonId == pWinStation->LogonId
             || pWinStation->Terminating ) {
            pWinStation->BrokenSource = BrokenSource_User;
        } else {
            pWinStation->BrokenSource = BrokenSource_Server;
        }
    }

    /*
     * If the RPC caller did not wish to wait for this reset,
     * then queue an internal call for this to be done.
     * This is safe now that we have done all of the above checks
     * to determine that the caller has access to perform the
     * reset and have set BrokenSource/Reason above.
     */
    if ( CallerIsRpc && !bWait ) {
        // clear reset flag so the internal reset will proceed
        pWinStation->Flags &= ~WSF_RESET;
        ReleaseWinStation( pWinStation );
        QueueWinStationReset( LogonId);
        Status = STATUS_SUCCESS;
        goto done;
    }

    /*
     * Make sure this WinStation is ready to reset
     */
    WinStationTerminate( pWinStation );

    /*
     * If it's a listener, reset all active winstations of the same type
     */
    if ((pWinStation->Flags & WSF_LISTEN) && ListenName[0] && bRecreate) {
        ResetGroupByListener(ListenName);
    }

    /*
     * If WinStation is marked DownPending (and is not disconnected),
     * then set it to the Down state, clear the DownPending and Reset flags,
     * and release the WinStation.
     */
    if ( (pWinStation->Flags & WSF_DOWNPENDING) && pWinStation->WinStationName[0] ) {
        pWinStation->State = State_Down;
        pWinStation->Flags &= ~(WSF_DOWNPENDING | WSF_RESET);
        ReleaseWinStation( pWinStation );
        Status = STATUS_SUCCESS;

    /*
     * The WinStation is not DownPending so complete deleting it
     * and then recreate it.
     */
    } else {
        ULONG PdFlag;
        ULONG WinStationFlags;
        WINSTATIONNAME WinStationName;

        /*
         * Save WinStation name for later create call
         */
        WinStationFlags = pWinStation->Flags;
        PdFlag = pWinStation->Config.Pd[0].Create.PdFlag;
        wcscpy( WinStationName, pWinStation->WinStationName );

        /*
         * Call the WinStationDelete worker
         */
        WinStationDeleteWorker( pWinStation );

        /*
         * Now recreate the WinStation
         */
        if ( WinStationName[0] &&
             bRecreate &&
             ((WinStationFlags & WSF_LISTEN) || (PdFlag & PD_SINGLE_INST)) ) {
            Status = WinStationCreateWorker( WinStationName, NULL );
        } else if ( WinStationFlags & WSF_IDLE ) {
            // wake up WinStationIdleControlThread so that it recreates an idle session
            NtSetEvent(WinStationIdleControlEvent, NULL);
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    // If we disconnected a Session owning the console terminal, go an create a new one
    // to own it.
    if (bConsoleSession) {
        ENTERCRIT(&ConsoleLock);
        if (!WinStationCheckConsoleSession()) {
            /*
             * Wake up the WinStationIdleControlThread
             */
            NtSetEvent(WinStationIdleControlEvent, NULL);

        }
        LEAVECRIT(&ConsoleLock);
    }

     if ( !gbServer && !bListener && ListenName[0] ) {

         StartStopListeners( ListenName, FALSE );
     }
    /*
     * Save return status
     */
done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationReset, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *  WinStationShutdownSystemWorker
 *
 *   Function to shutdown the system from an RPC API request
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationShutdownSystemWorker(
    ULONG ClientLogonId,
    ULONG ShutdownFlags
    )
{
    BOOL     rc;
    BOOLEAN WasEnabled;
    NTSTATUS Status = 0;
    NTSTATUS Status2;
    PWINSTATION pWinStation;
    UINT ExitWindowsFlags;
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;


    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationShutdownSystem, Flags=%d\n", ShutdownFlags ));

    /*
     * Impersonate the client so that when the attempt is made to enable
     * the SE_SHUTDOWN_PRIVILEGE, it will fail if the account is not admin.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status =  STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    //
    // If its remote RPC call we should ignore ClientLogonId
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // we dont care about client logon id if this is called from remote machine.
    // so lets set it zero. So its treated as shutdown from session 0.
    //
    if (!LocalFlag) {
        ClientLogonId = 0;
    }


    /*
     * We are called under RPC impersonation so that the current
     * thread token represents the RPC client. If the RPC client
     * does not have SE_SHUTDOWN_PRIVILEGE, the RtlAdjustPrivilege()
     * will fail.
     */
    Status = RtlAdjustPrivilege(
                 SE_SHUTDOWN_PRIVILEGE,
                 TRUE,    // Enable the PRIVILEGE
                 TRUE,    // Use Thread token (under impersonation)
                 &WasEnabled
                 );
    if( NT_SUCCESS( Status ) && !WasEnabled ) {
        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need. So we must disable the shutdown privilege
         * if it was just a logoff force.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_SHUTDOWN_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      TRUE,     // Use Thread token (under impersonation)
                      &WasEnabled
                      );

        ASSERT( NT_SUCCESS(Status2) );
    }

    RpcRevertToSelf();

    if ( Status == STATUS_NO_TOKEN ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: No Thread token!\n"));
        goto done;
    }

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: RtlAdjustPrivilege failure 0x%x\n",Status));
        goto done;
    }

    if ( ShutdownFlags == 0 )
        goto done;

    //
    // At this point we know that the client has access to shutdown the machine.
    // Now enable Shutdown privilege for the termsrv.exe process. This is done
    // because winlogon only allow system processes to shutdown the machine if
    // if no one is logged on the console session. If we just enable privilige
    // for the impersonating thread winlogon will not consider it as a system
    // process
    //
    Status = RtlAdjustPrivilege(
                 SE_SHUTDOWN_PRIVILEGE,
                 TRUE,    // Enable the PRIVILEGE
                 FALSE,   // Use Process Token
                 &WasEnabled
                 );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: RtlAdjustPrivilege failure 0x%x\n",Status));
        goto done;
    }

    /*
     * Set global shutdown flag
     */
    ShutdownInProgress = TRUE;

    /*
     * If logoff option is specified, then cause all WinStations
     * to logoff now and don't restart them.
     */
    if ( ShutdownFlags & (WSD_SHUTDOWN | WSD_LOGOFF) ) {
        Status = ShutdownLogoff( ClientLogonId, ShutdownFlags );
    }

    if ( ShutdownFlags & (WSD_SHUTDOWN | WSD_REBOOT | WSD_POWEROFF) ) {
        /*
         * If system will be rebooted or powered off, then cause
         * the client WinStation that called us to logoff now.
         * If shutdown from non-console, close the connection (self) here.
         */
        if ( (ShutdownFlags & (WSD_REBOOT | WSD_POWEROFF)) || ClientLogonId != 0) {
            
            if (!ShutDownFromSessionID)
                ShutDownFromSessionID = ClientLogonId;

            // ShutdownTerminateNoWait = TRUE;
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: Start reset of last WinStation\n" ));
            (VOID) DoForWinStationGroup( &ClientLogonId, 1,
                                         (LPTHREAD_START_ROUTINE) WinStationShutdownReset );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: Last WinStation reset\n" ));
            
            
            if ( ClientLogonId == 0 ) {

                DWORD dwRet;
                dwRet = WaitForSingleObject(ConsoleLogoffEvent,120*1000);
                if (dwRet == WAIT_TIMEOUT)
                {
                   KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: Timedout waiting for ConsoleLogoffEvent\n"));
                   Status = STATUS_TIMEOUT;
                }
            }
        }

        /*
         * Now complete system shutdown.
         *
         * Use ExitWindowsEx() so that console winlogon completes
         * our shutdown. This is so that services get shutdown
         * properly.
         */
        if (ClientLogonId == (USER_SHARED_DATA->ActiveConsoleId) ) {
            ExitWindowsFlags = 0;
        } else {
            ExitWindowsFlags = EWX_FORCE;
        }
        if ( ShutdownFlags & WSD_REBOOT )
            ExitWindowsFlags |= EWX_REBOOT;
        else if ( ShutdownFlags & WSD_POWEROFF )
            ExitWindowsFlags |= EWX_POWEROFF;
        else
            ExitWindowsFlags |= EWX_SHUTDOWN;

        /*
         * Need to pass the EWX_TERMSRV_INITIATED to let winlogon know 
         * that the shutdown was initiated by termsrv.
         */
        rc = ExitWindowsEx( ExitWindowsFlags | EWX_TERMSRV_INITIATED, 0 );
        if( !rc ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: ExitWindowsEx failed %d\n",GetLastError() ));
        }
    }

    if( !WasEnabled ) {

        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need. So we must disable the shutdown privilege
         * if it was just a logoff force.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_SHUTDOWN_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      FALSE,    // Use Process Token
                      &WasEnabled
                      );
        ASSERT( NT_SUCCESS(Status2) );
    }

    /*
     * Save return status in API message
     */
done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationShutdownSystem, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *  WinStationTerminateProcessWorker
 *
 *    Terminate the specified process
 *
 * ENTRY:
 *    ProcessId (input)
 *       process id of the process to terminate
 *    ExitCode (input)
 *       Termination status for each thread in the process
 ****************************************************************************/
NTSTATUS
WinStationTerminateProcessWorker(
    ULONG  ProcessId,
    ULONG  ExitCode
    )
{
    OBJECT_ATTRIBUTES Obja;
    CLIENT_ID ClientId;
    BOOLEAN fWasEnabled = FALSE;
    NTSTATUS Status;
    NTSTATUS Status2;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;
    HANDLE ProcHandle = NULL;
    HANDLE TokenHandle = NULL;
    PTOKEN_USER pTokenInfo = NULL;
    ULONG TokenInfoLength;
    ULONG ReturnLength;
    int rc;

    TRACE(( hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationTerminateProcess, PID=%d, ExitCode %u\n",
            ProcessId, ExitCode ));

    /*
     *  If possible, enable the debug privilege
     */
    (void) RtlAdjustPrivilege( SE_DEBUG_PRIVILEGE,
                               TRUE,    // Enable the PRIVILEGE
                               TRUE,    // Use Thread token (under impersonation)
                               &fWasEnabled );

    /*
     * Attempt to open the process for query and terminate access.
     */
    ClientId.UniqueThread  = (HANDLE) NULL;
    ClientId.UniqueProcess = (HANDLE) LongToHandle( ProcessId );
    InitializeObjectAttributes( &Obja, NULL, 0, NULL, NULL );
    Status = NtOpenProcess( &ProcHandle,
                            PROCESS_QUERY_INFORMATION | PROCESS_TERMINATE,
                            &Obja,
                            &ClientId );
    if ( !NT_SUCCESS(Status) )
        goto restore;

    /*
     * Open the process token so we can query the user SID.  If the user
     * SID for this process is the SYSTEM SID, we will deny access to it.
     * This is to prevent ADMINs from killing system processes.
     */
    Status = NtOpenProcessToken( ProcHandle, TOKEN_QUERY, &TokenHandle );

    /*
     * Its possible for OpenProcess above to succeed and NtOpenProcessToken
     * to fail.  One scenario is an ADMIN user trying to kill a USER process.
     * Standard security allows ADMIN terminate access to the process but
     * does not allow any access to the process token.  In this case we
     * will just skip the SID check and do the terminate below.
     */
    if ( NT_SUCCESS( Status ) ) {
        /*
         * Allocate buffer for reading user SID
         */
        TokenInfoLength = sizeof(TOKEN_USER) +
                          RtlLengthRequiredSid( SID_MAX_SUB_AUTHORITIES );
        pTokenInfo = MemAlloc( TokenInfoLength );
        if ( pTokenInfo == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto freeit;
        }

        /*
         * Query the user SID in the token
         */
        Status = NtQueryInformationToken( TokenHandle, TokenUser, pTokenInfo,
                                          TokenInfoLength, &ReturnLength );
        if ( !NT_SUCCESS( Status ) )
            goto freeit;

        /*
         * If user SID for this process is the SYSTEM SID,
         * then we don't allow it to be terminated.
         */
        if ( RtlEqualSid( gSystemSid, pTokenInfo->User.Sid ) ) {
            Status = STATUS_ACCESS_DENIED;
            goto freeit;
        }
    }

    /*
     * Now try to terminate the process
     */
    Status = NtTerminateProcess( ProcHandle, (NTSTATUS)ExitCode );

freeit:
    if ( pTokenInfo )
        MemFree( pTokenInfo );

    if ( TokenHandle )
        CloseHandle( TokenHandle );

    if ( ProcHandle )
        CloseHandle( ProcHandle );

restore:
    if( !fWasEnabled ) {

        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need. So we must disable the debug privilege
         * if it was not enabled on entry to this routine.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_DEBUG_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      TRUE,     // Use Thread token (under impersonation)
                      &fWasEnabled
                      );

        ASSERT( NT_SUCCESS(Status2) );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationTerminateProcess, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *  WinStationWaitSystemEventWorker
 *
 *   Function to wait for a system event from an RPC API request.
 *
 *   Only one event wait may be posted per server handle at a time. The
 *   code protects itself from misuse by returning STATUS_PIPE_BUSY if
 *   an eventwait is already outstanding, and the request is not a cancel.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationWaitSystemEventWorker(
    HANDLE hServer,
    ULONG EventMask,
    PULONG pEventFlags
    )
{
    NTSTATUS Status;
    PEVENT pWaitEvent;
    OBJECT_ATTRIBUTES ObjA;
    PRPC_CLIENT_CONTEXT pContext = (PRPC_CLIENT_CONTEXT)hServer;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEventWorker, Mask=0x%08x\n", EventMask ));

    /*
     * Protect ourselves from multiple threads calling in at once
     */
    RtlEnterCriticalSection( &WinStationListLock );

    /*
     * If client doesn't already have an event block,
     * then allocate and initialize one now.
     */
    if ( pContext->pWaitEvent == NULL ) {

        // If event mask is null or flush specified, then nothing to do
        if ( EventMask == WEVENT_NONE || (EventMask & WEVENT_FLUSH) ) {
            Status = STATUS_SUCCESS;
            RtlLeaveCriticalSection( &WinStationListLock );
            goto done;
        }

        /*
         * Allocate event block and initialize it
         */
        if ( (pWaitEvent = MemAlloc( sizeof(EVENT) )) == NULL ) {
            Status = STATUS_NO_MEMORY;
            RtlLeaveCriticalSection( &WinStationListLock );
            goto done;
        }
        RtlZeroMemory( pWaitEvent, sizeof(EVENT) );

        pWaitEvent->fWaiter = FALSE;
        pWaitEvent->EventMask = EventMask;
        pWaitEvent->EventFlags = 0;

        /*
         * Create an event to wait on
         */
        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        Status = NtCreateEvent( &pWaitEvent->Event, EVENT_ALL_ACCESS, &ObjA,
                                NotificationEvent, FALSE );

        if( !NT_SUCCESS(Status) ) {
            MemFree( pWaitEvent );
            RtlLeaveCriticalSection( &WinStationListLock );
            goto done;
        }
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Event=%p\n", pWaitEvent->Event ));

        TRACE((hTrace,TC_ICAAPI,TT_API3, "TERMSRV: WinStationWaitSystemEvent, Event block=%p\n", pWaitEvent ));

        /*
         * Save event block pointer in RPC client context structure
         * and insert in system event list.
         */
        pContext->pWaitEvent = pWaitEvent;
        InsertTailList( &SystemEventHead, &pWaitEvent->EventListEntry );

        /*
         * Wait for the event to be signaled
         */
        pWaitEvent->fWaiter = TRUE;
        RtlLeaveCriticalSection( &WinStationListLock );
        Status = WaitForSingleObject( pWaitEvent->Event, (DWORD)-1 );
        RtlEnterCriticalSection( &WinStationListLock );
        pWaitEvent->fWaiter = FALSE;

        if ( NT_SUCCESS(Status) ) {
            Status = pWaitEvent->WaitResult;
            if( NT_SUCCESS(Status) ) {
                *pEventFlags = pWaitEvent->EventFlags;
                /*
                * makarp - Fix For . (#21929)
                */
                pWaitEvent->EventFlags = 0;
            }
        }

        /*
         * If fClosing is set, then cleanup the eventwait entry and free it.
         */
        if ( pWaitEvent->fClosing ) {
            pContext->pWaitEvent = NULL;
            RemoveEntryList( &pWaitEvent->EventListEntry );
            RtlLeaveCriticalSection( &WinStationListLock );
            NtClose( pWaitEvent->Event );
            pWaitEvent->Event = NULL;
            MemFree( pWaitEvent );
        } else {
            RtlLeaveCriticalSection( &WinStationListLock );
        }
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
        return( Status );

    /*
     * Client has an event block but wants to remove it
     */
    } else if ( EventMask == WEVENT_NONE ) {

        pWaitEvent = pContext->pWaitEvent;

        // If we have a waiter, mark the eventwait struct as closing
        // and let the waiter clean up.
        if ( pWaitEvent->fWaiter ) {
            pWaitEvent->fClosing = TRUE;
            pWaitEvent->WaitResult = STATUS_CANCELLED;
            NtSetEvent( pWaitEvent->Event, NULL );
            RtlLeaveCriticalSection( &WinStationListLock );
            Status = STATUS_SUCCESS;
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
            return( Status );
        }
        pContext->pWaitEvent = NULL;
        RemoveEntryList( &pWaitEvent->EventListEntry );
        RtlLeaveCriticalSection( &WinStationListLock );
        NtClose( pWaitEvent->Event );
        pWaitEvent->Event = NULL;
        MemFree( pWaitEvent );
        Status = STATUS_SUCCESS;
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
        return( Status );

    /*
     * Flush specified so we must release waiting client
     */
    } else if ( EventMask & WEVENT_FLUSH ) {
        pWaitEvent = pContext->pWaitEvent;
        if ( pWaitEvent->fWaiter ) {
            pWaitEvent->WaitResult = STATUS_CANCELLED;
            NtSetEvent( pWaitEvent->Event, NULL );
            TRACE((hTrace,TC_ICAAPI,TT_API3, "TERMSRV: WinStationWaitSystemEvent, event wait cancelled\n" ));
        }
        RtlLeaveCriticalSection( &WinStationListLock );
        Status = STATUS_SUCCESS;
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
        return( Status );

    /*
     * Client already has an event block and is calling again
     * to wait for another event.  Update the EventMask in case it
     * changed from the original call.
     */
    } else {

        pWaitEvent = pContext->pWaitEvent;

        // Only allow one waiter
        if ( pWaitEvent->fWaiter ) {
            RtlLeaveCriticalSection( &WinStationListLock );
            Status = STATUS_PIPE_BUSY;
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
            return( Status );
        }

        pWaitEvent->EventMask = EventMask;

        /*
         * If additional events occured while client was processing
         * previous events, then just return to the client now.
         */
        if ( pWaitEvent->EventFlags &= EventMask ) {
            *pEventFlags = pWaitEvent->EventFlags;
            pWaitEvent->EventFlags = 0;
            Status = STATUS_SUCCESS;
            RtlLeaveCriticalSection( &WinStationListLock );
            TRACE((hTrace,TC_ICAAPI,TT_API3, "TERMSRV: WinStationWaitSystemEvent, returning immediately\n" ));
               return( Status );
        } else {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, waiting for event\n" ));

            // Reset the event
            NtResetEvent( pWaitEvent->Event, NULL );

            /*
             * Wait for the event to be signaled
             */
            pWaitEvent->fWaiter = TRUE;
            RtlLeaveCriticalSection( &WinStationListLock );
            Status = WaitForSingleObject( pWaitEvent->Event, (DWORD)-1 );
            RtlEnterCriticalSection( &WinStationListLock );
            pWaitEvent->fWaiter = FALSE;

            if( NT_SUCCESS(Status) ) {
                Status = pWaitEvent->WaitResult;
                if( NT_SUCCESS(Status) ) {
                    *pEventFlags = pWaitEvent->EventFlags;
                    /*
                     * makarp - Fix For . (#21929)
                     */
                    pWaitEvent->EventFlags = 0;
                }
            }

            /*
             * If fClosing is set, then cleanup the eventwait entry and free it.
             */
            if ( pWaitEvent->fClosing ) {
                pContext->pWaitEvent = NULL;
                RemoveEntryList( &pWaitEvent->EventListEntry );
                RtlLeaveCriticalSection( &WinStationListLock );
                NtClose( pWaitEvent->Event );
                pWaitEvent->Event = NULL;
                MemFree( pWaitEvent );
            } else {
                RtlLeaveCriticalSection( &WinStationListLock );
            }
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
               return( Status );
        }
    }

done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *  WinStationCallbackWorker
 *
 *   Perform callback processing for the specified WinStation.
 *
 * ENTRY:
 *    LogonId (input)
 *      Logon Id of WinStation
 *    pPhoneNumber (input)
 *      Phone number string suitable for processing by TAPI
 ****************************************************************************/
NTSTATUS
WinStationCallbackWorker(
    ULONG  LogonId,
    PWCHAR pPhoneNumber
    )
{
    PWINSTATION pWinStation;
    NTSTATUS Status;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        return( Status );
    }

    /*
     * Unlock WinStation while Callback is in progress
     */
    UnlockWinStation( pWinStation );

    if (pWinStation->hStack != NULL) {
        Status = IcaStackCallback( pWinStation->hStack,
                                   &pWinStation->Config,
                                   pPhoneNumber,
                                   pWinStation->pEndpoint,
                                   pWinStation->EndpointLength,
                                   &pWinStation->EndpointLength );
    } else {
        Status = STATUS_INVALID_PARAMETER;

    }

    return( Status );
}


/*****************************************************************************
 *  WinStationBreakPointWorker
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationBreakPointWorker(
    ULONG   LogonId,
    BOOLEAN KernelFlag
    )
{
    NTSTATUS Status;
    NTSTATUS Status2;
    BOOLEAN WasEnabled;
    WINSTATION_APIMSG WMsg;
    PWINSTATION pWinStation;

    /*
     * We are called under RPC impersonation so that the current
     * thread token represents the RPC client. If the RPC client
     * does not have SE_SHUTDOWN_PRIVILEGE, the RtlAdjustPrivilege()
     * will fail.
     *
     * SE_SHUTDOWN_PRIVILEGE is used for breakpoints because that is
     * effectively what a break point does to the system.
     */
    Status = RtlAdjustPrivilege(
                 SE_SHUTDOWN_PRIVILEGE,
                 TRUE,    // Enable the PRIVILEGE
                 TRUE,    // Use Thread token (under impersonation)
                 &WasEnabled
                 );

    if ( Status == STATUS_NO_TOKEN ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationBreakPointWorker: No Thread token!\n"));
        return( Status );
    }

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationBreakPointWorker: RtlAdjustPrivilege failure 0x%x\n",Status));
        return( Status );
    }

    /*
     * Stop here if that's what was requested
     */
    if ( LogonId == (ULONG)-2 ) {
        DbgBreakPoint();
        Status = STATUS_SUCCESS;
        goto Done;
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto Done;
    }

    /*
     * Tell the WinStation to breakpoint
     */

    WMsg.ApiNumber = SMWinStationDoBreakPoint;
    WMsg.u.BreakPoint.KernelFlag = KernelFlag;
    Status = SendWinStationCommand( pWinStation, &WMsg, 0 );

    ReleaseWinStation( pWinStation );

Done:

    if( !WasEnabled ) {
        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_SHUTDOWN_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      TRUE,     // Use Thread token (under impersonation)
                      &WasEnabled
                      );

        ASSERT( NT_SUCCESS(Status2) );
    }

    return( Status );
}


NTSTATUS
WinStationEnableSessionIo( 
    PWINSTATION pWinStation, 
    BOOL bEnable
    )
/*++

Description:

    Funtion to disable keyboard and mouse input from session, this is to prevent
    security hole that a hacker can send keystrock to bring up utility manager 
    before shadowing.

Parameters:

    pWinStation (INPUT) : Pointer to winstation, function will ignore if session is 
                          not a help session.
    bEnable (INPUT) : TRUE to enable keyboard/mouse, FALSE otherwise.

Returns:

    ...

Note:

WINSTATION structure must be locked. Two new IOCTL code so we don't introduce any regression.
    

--*/
{
    HANDLE ChannelHandle;
    NTSTATUS Status;

    if( pWinStation->fOwnsConsoleTerminal )
    {
        //
        // Don't want to disable mouse/keyboard input on active console session,
        //
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = IcaChannelOpen( 
                            pWinStation->hIca,
                            Channel_Keyboard,
                            NULL,
                            &ChannelHandle 
                        );
        if ( NT_SUCCESS( Status ) ) {
            Status = IcaChannelIoControl( 
                                    ChannelHandle,
                                    (bEnable) ? IOCTL_ICA_CHANNEL_ENABLE_SESSION_IO : IOCTL_ICA_CHANNEL_DISABLE_SESSION_IO,
                                    NULL, 0, NULL, 0, NULL 
                                );
            IcaChannelClose( ChannelHandle );
        }

        Status = IcaChannelOpen( 
                            pWinStation->hIca,
                            Channel_Mouse,
                            NULL,
                            &ChannelHandle 
                        );
        if ( NT_SUCCESS( Status ) ) {
            Status = IcaChannelIoControl( ChannelHandle,
                                          (bEnable) ? IOCTL_ICA_CHANNEL_ENABLE_SESSION_IO : IOCTL_ICA_CHANNEL_DISABLE_SESSION_IO,
                                          NULL, 0, NULL, 0, NULL );
            IcaChannelClose( ChannelHandle );    
        }
    }

    return Status;
}

/*****************************************************************************
 *  WinStationNotifyLogonWorker
 *
 *   Message parameter unmarshalling function for WinStation API.
 ****************************************************************************/
NTSTATUS WinStationNotifyLogonWorker(
        DWORD   ClientLogonId,
        DWORD   ClientProcessId,
        BOOLEAN fUserIsAdmin,
        DWORD   UserToken,
        PWCHAR  pDomain,
        DWORD   DomainSize,
        PWCHAR  pUserName,
        DWORD   UserNameSize,
        PWCHAR  pPassword,
        DWORD   PasswordSize,
        UCHAR   Seed,
        PCHAR   pUserConfig,
        DWORD   ConfigSize)
{
    extern GENERIC_MAPPING WinStaMapping;
    extern LPCWSTR szTermsrv;
    extern LPCWSTR szTermsrvSession;

    PWINSTATION pWinStation;
    HANDLE ClientToken, NewToken;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE ImpersonationToken;
    PTOKEN_USER TokenInfo;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG UserNameLength = USERNAME_LENGTH;
    ULONG DomainLength = DOMAIN_LENGTH;
    BOOL bAccessCheckOk = FALSE;
    DWORD GrantedAccess;
    BOOL AccessStatus;
    BOOL fGenerateOnClose;
    PTSSD_CreateSessionInfo pCreateInfo = NULL;
    BOOL bHaveCreateInfo = FALSE;
    BOOL bQueueReset = FALSE;
    BOOL bRedirect = FALSE;     // TRUE: redirect this connection

    BOOL bValidHelpSession;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogon, LogonId=%d\n", ClientLogonId ));

    if( sizeof( USERCONFIGW ) > ConfigSize ) {
        return( STATUS_ACCESS_VIOLATION );
    }

    //
    // If this is a notification from Session 0, then clear the Mpr notification information
    // Termsrv already erases this after query, but since this is critical information, lets Erase everything again
    // This is to take care of the case where reconnect to Session 0 failed for some reason and we do not Erase these after Query
    //

    if (ClientLogonId == 0) {
        RtlSecureZeroMemory( g_MprNotifyInfo.Domain, wcslen(g_MprNotifyInfo.Domain) * sizeof(WCHAR) );
        RtlSecureZeroMemory( g_MprNotifyInfo.UserName, wcslen(g_MprNotifyInfo.UserName) * sizeof(WCHAR) );
        RtlSecureZeroMemory( g_MprNotifyInfo.Password, wcslen(g_MprNotifyInfo.Password) * sizeof(WCHAR) );
    }

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    pCreateInfo = MemAlloc(sizeof(TSSD_CreateSessionInfo));
    if (NULL == pCreateInfo) {
        return ( STATUS_NO_MEMORY ); 
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }


    //
    // Release filtered address
    //
    if (pWinStation->pRememberedAddress != NULL) {
        Filter_RemoveOutstandingConnection( &pWinStation->pRememberedAddress->addr[0], pWinStation->pRememberedAddress->length );
        MemFree(pWinStation->pRememberedAddress);
        pWinStation->pRememberedAddress = NULL;
        if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
           if (hConnectEvent != NULL)
           {
               SetEvent(hConnectEvent);
           }
        }


    }

    // The client has communicated its initial configuration
    // information. Check if we need to redirect the client for
    // load balancing. Ignore the console!
    // Note: Only go through this if SD is enabled, i.e. GetTSSD() returns valid value
    if (ClientLogonId != 0 && !g_bPersonalTS && g_fAppCompat && GetTSSD()) {
        PTS_LOAD_BALANCE_INFO pLBInfo = NULL;
        PWINSTATION pTargetWinStation = pWinStation;
        ULONG ReturnLength;
        BOOL bSuccess = FALSE;

        pLBInfo = MemAlloc(sizeof(TS_LOAD_BALANCE_INFO));
        if (NULL == pLBInfo) {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

        // need to release it
        ReleaseTSSD();
    
        // Get the client load balance capability info. We continue onward
        // to do a session directory query only when the client supports
        // redirection and has not already been redirected to this server.
        memset(pLBInfo, 0, sizeof(TS_LOAD_BALANCE_INFO));
        Status = IcaStackIoControl(pTargetWinStation->hStack,
                IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO,
                NULL, 0,
                pLBInfo, sizeof(TS_LOAD_BALANCE_INFO),
                &ReturnLength);
               
        // Only check for possible redirection if this is the initial request
        if (NT_SUCCESS(Status) && !pLBInfo->bRequestedSessionIDFieldValid) {
            // On non-success, we'll have FALSE for all of our entries, on
            // success valid values. So, save off the cluster info into the
            // WinStation struct now.
            pTargetWinStation->bClientSupportsRedirection =
                    pLBInfo->bClientSupportsRedirection;
            pTargetWinStation->bRequestedSessionIDFieldValid =
                    pLBInfo->bRequestedSessionIDFieldValid;
            pTargetWinStation->bClientRequireServerAddr =
                    pLBInfo->bClientRequireServerAddr;
            pTargetWinStation->RequestedSessionID = pLBInfo->RequestedSessionID;
        
            // Use the name & domain they used to actually log on
            memset(pLBInfo->Domain, 0, sizeof(pLBInfo->Domain));
            memset(pLBInfo->UserName, 0, sizeof(pLBInfo->UserName));        
            wcsncpy(pLBInfo->Domain, pDomain, DomainLength);
            wcsncpy(pLBInfo->UserName, pUserName, UserNameLength);

            TRACE((hTrace,TC_LOAD,TT_API1, 
                    "Client LBInfo: Supports Redirect [%lx], "
                    "Session Id valid [%lx]:%lx, "
                    "Creds [%S\\%S]\n",
                    pLBInfo->bClientSupportsRedirection,
                    pLBInfo->bRequestedSessionIDFieldValid,
                    pLBInfo->RequestedSessionID,
                    pLBInfo->UserName, pLBInfo->Domain));

            wcsncpy(pLBInfo->Password, pPassword, PasswordSize);

            bSuccess = SessDirCheckRedirectClient(pTargetWinStation, pLBInfo);

            // Clear password
            if (0 != PasswordSize)
                memset(pLBInfo->Password, 0, PasswordSize);

            if (bSuccess) {
                // The client should drop the socket, and we'll
                // go ahead and drop this ongoing connection.
                // Set an error status.
                Status = STATUS_UNSUCCESSFUL;
                bRedirect = TRUE;

                TRACE((hTrace,TC_LOAD,TT_API1, 
                       "Disconnected session found: redirecting client!\n"));

                if (pLBInfo != NULL) {
                    MemFree(pLBInfo);
                    pLBInfo = NULL;
                }

                goto release;
            }
            else
                TRACE((hTrace,TC_LOAD,TT_API1, 
                       "Disconnected session not found: status [%lx], pers [%ld], appcompat [%ld]\n",
                       Status, g_bPersonalTS, g_fAppCompat));
        }

        if (pLBInfo != NULL) {
            MemFree(pLBInfo);
            pLBInfo = NULL;
        }
    }
    

    if (ClientLogonId == 0) {
       //
       //ReSet the Console Logon Event
       //
       KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WinStationNotifyLogon, ReSetting ConsoleLogoffEvent\n"));
       NtResetEvent(ConsoleLogoffEvent, NULL);
    }
    /*
     * Do not do anything if the session is not connected. The processing in this API assumes we are connected and have a
     * valid stack.
     */
    
    if ((ClientLogonId != 0) && ((pWinStation->State != State_Connected) ||  pWinStation->StateFlags & WSF_ST_IN_DISCONNECT)) {
        Status = STATUS_CTX_CLOSE_PENDING;
        ReleaseWinStation( pWinStation );
        goto done;
    }
    

    if (ClientLogonId == 0 && !bConsoleConnected ){

       Status = WaitForConsoleConnectWorker(  pWinStation );
       if (NT_SUCCESS(Status)) {
           bConsoleConnected=TRUE;
       } else {
           ReleaseWinStation( pWinStation );
           goto done;
       }
    }

    /*
     * Upper level code has verified that this RPC
     * is coming from a local client with SYSTEM access.
     *
     * We should be able to trust the ClientProcessId from
     * SYSTEM code.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        /*
         * The console has a special problem with NTSD starting winlogon.
         * It doesn't get notified until now what the PID if winlogon.exe
         * instead of ntsd.exe is.
         */
        if ( !pWinStation->LogonId && !pWinStation->InitialProcessSet ) {
            pWinStation->InitialCommandProcess = OpenProcess(
                PROCESS_ALL_ACCESS,
                FALSE,
                (DWORD) ClientProcessId );

            if ( pWinStation->InitialCommandProcess == NULL ) {
                Status = STATUS_ACCESS_DENIED;
                goto done;
            }
            pWinStation->InitialCommandProcessId = (HANDLE)(ULONG_PTR)ClientProcessId;
            pWinStation->InitialProcessSet = TRUE;

        }
        else {
            //Set flag saying that WinStationNotifyLogonWorker 
            //was successfully completed
            pWinStation->StateFlags |= WSF_ST_LOGON_NOTIFIED;

            ReleaseWinStation( pWinStation );
            Status = STATUS_SUCCESS;
            goto done;
        }
    }

    /*
     * Verify the client license if appropriate
     */
    if ( pWinStation->pWsx && pWinStation->pWsx->pWsxVerifyClientLicense ) {
        Status = pWinStation->pWsx->pWsxVerifyClientLicense(
                pWinStation->pWsxContext,
                pWinStation->Config.Pd[0].Create.SdClass);
    }

    if ( Status != STATUS_SUCCESS) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    //
    //  DON'T CHECK RpcClientAccess. The client is always winlogon (verified
    //  before the call to this function) so this call does not check against
    //  the actual user logging in. This is done further down from here.
    //
#if 0
    if (ClientLogonId != 0)
    {
        Status = RpcCheckClientAccess( pWinStation, WINSTATION_LOGON, FALSE );
        if ( !NT_SUCCESS( Status ) ) {
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationNotifyLogon, RpcCheckClientAccess failed=%x\n", Status ));

            goto done;
        }
    }
#endif

    /*
     * Save user status
     *
     * NOTE: This flag should only be used by the annoyance thread,
     *       and not for any security sensitive operations. All
     *       security sensitive operations need to go through the
     *       NT SeAccessCheck so that auditing is done properly.
     */

    pWinStation->fUserIsAdmin = fUserIsAdmin;

    if (!ClientLogonId && !pWinStation->pWsx) {
        PLIST_ENTRY Head, Next;
        PWSEXTENSION pWsx;
        ICASRVPROCADDR IcaSrvProcAddr;

        RtlEnterCriticalSection( &WsxListLock );

        Head = &WsxListHead;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
            if ( pWsx->pWsxGetLicense ) {
                if (!pWinStation->pWsxContext && pWsx->pWsxWinStationInitialize) {
                    Status = pWsx->pWsxWinStationInitialize(&pWinStation->pWsxContext);
                }
                Status = pWsx->pWsxGetLicense(pWinStation->pWsxContext,
                                              pWinStation->hStack,
                                              pWinStation->LogonId,
                                              fUserIsAdmin);
                break;
           }
        }

        RtlLeaveCriticalSection( &WsxListLock );
    } else {
        if ( pWinStation->pWsx && pWinStation->pWsx->pWsxGetLicense ) {
            Status = pWinStation->pWsx->pWsxGetLicense( pWinStation->pWsxContext,
                                                        pWinStation->hStack,
                                                        pWinStation->LogonId,
                                                        fUserIsAdmin );
        }
    }

    if ( Status != STATUS_SUCCESS) {
        HANDLE h;
        PWSTR Strings[2];

        /*
         * Send event to event log
         */
        h = RegisterEventSource(NULL, gpszServiceName);
        if (h) {
           //
           //  Would have used UserName and Domain in this error message,
           //  but they aren't set yet.
           //
           Strings[0] = pUserName;
           Strings[1] = pDomain;
           ReportEvent(h, EVENTLOG_WARNING_TYPE, 0, EVENT_NO_LICENSES, NULL, 2, 0, Strings, NULL);
           DeregisterEventSource(h);
        }

        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Get a valid copy of the clients token handle
     */
    Status = NtDuplicateObject( pWinStation->InitialCommandProcess,
                                (HANDLE)LongToHandle( UserToken ),
                                NtCurrentProcess(),
                                &ClientToken,
                                0, 0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );
    if ( !NT_SUCCESS( Status ) )
        goto baddupobject;

    /*
     * ClientToken is a primary token - create an impersonation token
     * version of it so we can set it on our thread
     */
    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;


    Status = NtDuplicateToken( ClientToken,
                               TOKEN_IMPERSONATE,
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               &ImpersonationToken );
    if ( !NT_SUCCESS( Status ) )
        goto badduptoken;

    /*
     * Impersonate the client
     */
    Status = NtSetInformationThread( NtCurrentThread(),
                                     ThreadImpersonationToken,
                                     (PVOID)&ImpersonationToken,
                                     (ULONG)sizeof(HANDLE) );
    if ( !NT_SUCCESS( Status ) )
        goto badimpersonate;

    //
    //  security check
    //
    Status = ApplyWinStaMapping( pWinStation );
    if( !NT_SUCCESS( Status ) )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationNotifyLogon, ApplyWinStaMapping failed=%x\n", Status ));
        goto noaccess;
    }

    if (ClientLogonId != (USER_SHARED_DATA->ActiveConsoleId))
    //
    // Since for PTS the remote session could have an ID of 0 or (1),
    // we check for access only if session is not on console.
    //
    {

        bAccessCheckOk = AccessCheckAndAuditAlarm(szTermsrv,
                             NULL,
                             (LPWSTR)szTermsrvSession,
                             (LPWSTR)szTermsrvSession,
                             WinStationGetSecurityDescriptor(pWinStation),
                             WINSTATION_LOGON,
                             &WinStaMapping,
                             FALSE,
                             &GrantedAccess,
                             &AccessStatus,
                             &fGenerateOnClose);

        if (bAccessCheckOk)
        {
            if (AccessStatus == FALSE)
            {
                TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationNotifyLogon, AccessCheckAndAuditAlarm(%u) returned error 0x%x\n",
                          pWinStation->LogonId, GetLastError() ));
                Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
                goto noaccess;
            }
            else
            {
                TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationNotifyLogon, AccessCheckAndAuditAlarm(%u) returned no error \n",
                          pWinStation->LogonId));
            }
        }
        else
        {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationNotifyLogon, AccessCheckAndAuditAlarm(%u) failed 0x%x\n",
                      pWinStation->LogonId, GetLastError() ));
            goto noaccess;
        }
    }

    /*
     * Revert back to our threads default token.
     */
    NewToken = NULL;
    NtSetInformationThread( NtCurrentThread(),
                            ThreadImpersonationToken,
                            (PVOID)&NewToken,
                            (ULONG)sizeof(HANDLE) );

    /*
     * See if OpenWinStation was successful
     */
    if ( !NT_SUCCESS( Status ) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationNotifyLogon, OpenWinStation(%u) failed 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto noaccess;
    }

    /*
     * Save User Name and Domain Name. Do this before the call into the
     * license core so that the core knows who is calling.
     */

    wcsncpy( pWinStation->Domain, pDomain, DomainLength );
    wcsncpy( pWinStation->UserName, pUserName, UserNameLength );

    /*
     *  Call into the licensing core.
     */

    Status = LCProcessConnectionPostLogon(pWinStation);

    if (Status != STATUS_SUCCESS)
    {
        goto nolicense;
    }


    if (pWinStation->pWsx &&
        pWinStation->pWsx->pWsxLogonNotify) {
        if ((ClientLogonId != 0) && (pWinStation->State != State_Connected || pWinStation->StateFlags & WSF_ST_IN_DISCONNECT)) {
            Status = STATUS_CTX_CLOSE_PENDING;
        } else {

            PWCHAR pDomainToSend, pUserNameToSend ;
            
            // Use the Notification given by GINA (WinStationUpdateClientCachedCredentials) if they are available 
            // This is because the credentials got in this call are not UPN names
            if (pWinStation->pNewNotificationCredentials) {
                pDomainToSend = pWinStation->pNewNotificationCredentials->Domain;
                pUserNameToSend = pWinStation->pNewNotificationCredentials->UserName;
            } else {
                pDomainToSend = pDomain;
                pUserNameToSend = pUserName;
            }

            /*
             * Reset any autoreconnect information prior to reconnection
             * as it is stale. New information will be generated by the stack
             * when login completes.
             */
            ResetAutoReconnectInfo(pWinStation);

            Status = pWinStation->pWsx->pWsxLogonNotify(pWinStation->pWsxContext,
                                                  pWinStation->LogonId,
                                                  ClientToken,
                                                  pDomainToSend,
                                                  pUserNameToSend);

            if (pWinStation->pNewNotificationCredentials != NULL) {
                MemFree(pWinStation->pNewNotificationCredentials);
                pWinStation->pNewNotificationCredentials = NULL;
            }


        }

    }

    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: pWsxLogonNotify rejected logon status 0x%x\n",Status));
        goto badwsxnotify;
    }

    /*
     * Determine size needed for token info buffer and allocate it
     */
    Status = NtQueryInformationToken( ClientToken, TokenUser,
                                      NULL, 0, &Length );
    if ( Status != STATUS_BUFFER_TOO_SMALL )
        goto badquerytoken;
    TokenInfo = MemAlloc( Length );
    if ( TokenInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badquerytoken;
    }

    /*
     * Query token information to get user's SID
     */
    Status = NtQueryInformationToken( ClientToken, TokenUser,
                                      TokenInfo, Length, &Length );
    if ( !NT_SUCCESS( Status ) ) {
        MemFree( TokenInfo );
        goto badquerytoken;
    }

    /*
     * Save copy of user's SID and password in WinStation
     */
    Length = RtlLengthSid( TokenInfo->User.Sid );

    if (pWinStation->pUserSid) {
       MemFree(pWinStation->pUserSid);
    }
    // clean up usertoken
    if ( pWinStation->UserToken ) {
        NtClose( pWinStation->UserToken );
        pWinStation->UserToken = NULL;
    }

    pWinStation->pUserSid = MemAlloc( Length );

    /* makarp; check for allocation failure. #182624 */
    if (!pWinStation->pUserSid) {
        Status = STATUS_NO_MEMORY;
        goto badusersid;
    }

    RtlCopySid( Length, pWinStation->pUserSid, TokenInfo->User.Sid );
    MemFree( TokenInfo );
    NtClose( ImpersonationToken );

    //For console session profile cleanup is done at next
    //logon because the session is never unloaded.
    if (pWinStation->pProfileSid != NULL) {
       ASSERT(pWinStation->LogonId == 0);
       if (pWinStation->LogonId == 0) {
          if (!RtlEqualSid(pWinStation->pProfileSid, pWinStation->pUserSid  )) {
             WinstationUnloadProfile(pWinStation);
          }
       }
       MemFree(pWinStation->pProfileSid);
       pWinStation->pProfileSid = NULL;
    }


    /*
     * Save copy of Client token in WinStation
     */
    pWinStation->UserToken = ClientToken;

#if 0
    //
    // C2 WARNING - WARNING - WARNING
    //
    // This is no longer done, or needed. See comments in acl.c
    //
    // C2 WARNING - WARNING - WARNING
    //
    RtlCopyMemory( pWinStation->Password, pPassword,
                   sizeof(pWinStation->Password) );

    pWinStation->Seed = Seed;
#endif

    /*
     * Fixup the security descriptors for the session
     * so this user has access to their named WIN32
     * object directory's.
     */
    ConfigurePerSessionSecurity( pWinStation );

    /*
     * Add ACE for logged on user to the WinStation object SD
     */
    AddUserAce( pWinStation );

    /*
     * Notify clients of WinStation logon
     */
    NotifySystemEvent( WEVENT_LOGON );
    NotifyLogon(pWinStation);

    /*
     * State is now active
     */
    if ( pWinStation->State != (ULONG) State_Active ) {
        pWinStation->State = State_Active;
        NotifySystemEvent( WEVENT_STATECHANGE );
    }

    (VOID) NtQuerySystemTime( &(pWinStation->LogonTime) );

    // 2nd and 3rd parama are NULL, since we don't yet have policy data. 
    // policy data will be aquired when user hive is loaded and winlogin fires
    // a shell-startup notify.
    MergeUserConfigData(pWinStation, NULL, NULL, (PUSERCONFIGW)pUserConfig ) ;

    /*
     * Save User Name and Domain Name into the USERCONFIG of the WINSTATION
     */
    wcsncpy( pWinStation->Config.Config.User.UserName, pUserName, UserNameLength );
    wcsncpy( pWinStation->Config.Config.User.Domain, pDomain, DomainLength );

    /*
     * Convert any "published app" to absolute path.  This will also return
     * failure if a non-published app is trying to run on a WinStation that
     * is configured to only run published apps.
     */
    if ( pWinStation->pWsx &&
            pWinStation->pWsx->pWsxConvertPublishedApp ) {
        if ((Status = pWinStation->pWsx->pWsxConvertPublishedApp(
                pWinStation->pWsxContext, &pWinStation->Config.Config.User)) !=
                STATUS_SUCCESS)
            goto release;
    }

    // Now that we have all the WinStation data, notify the session directory.
    // Copy off the pertinent info, which we will send to the directory after
    // we release the WinStation lock.
    wcsncpy(pCreateInfo->UserName, pWinStation->UserName,
            sizeof(pCreateInfo->UserName) / sizeof(WCHAR) - 1);
    wcsncpy(pCreateInfo->Domain, pWinStation->Domain,
            sizeof(pCreateInfo->Domain) / sizeof(WCHAR) - 1);
    pCreateInfo->SessionID = pWinStation->LogonId;
    pCreateInfo->TSProtocol = pWinStation->Client.ProtocolType;
    wcsncpy(pCreateInfo->ApplicationType, pWinStation->Client.InitialProgram,
            sizeof(pCreateInfo->ApplicationType) / sizeof(WCHAR) - 1);
    pCreateInfo->ResolutionWidth = pWinStation->Client.HRes;
    pCreateInfo->ResolutionHeight = pWinStation->Client.VRes;
    pCreateInfo->ColorDepth = pWinStation->Client.ColorDepth;
    memcpy(&(pCreateInfo->CreateTime), &pWinStation->LogonTime,
            sizeof(pCreateInfo->CreateTime));
    bHaveCreateInfo = TRUE;

    
    if(Status == STATUS_SUCCESS)
    {
        //Set flag saying that WinStationNotifyLogonWorker 
        //was successfully completed
        pWinStation->StateFlags |= WSF_ST_LOGON_NOTIFIED;
    }


    if( TSIsSessionHelpSession(pWinStation, &bValidHelpSession) )
    {
        // we disconnect RA if ticket is invalid at conntion time so assert
        // if we ever come to this.
        ASSERT( TRUE == bValidHelpSession );

        //
        // Disable IO from Help Session
        //
        WinStationEnableSessionIo( pWinStation, FALSE );

        //
        // Verify help session ticket and log event if ticket is
        // invalid, sessmgr is the centralize event logging
        // component, in the case that we are going to log an event,
        // call inside sessmgr CAN NOT invoke any winstation API
        // to retrieve/set any information in this winstation or will
        // have circular deadlock since we are holding winstation lock
        // here
        //
        if( FALSE == TSVerifyHelpSessionAndLogSalemEvent( pWinStation ) )
        {
            // Help Session is either invalid or can't 
            // startup session manager, return error code to client
            if(pWinStation->WinStationName[0] &&
               pWinStation->pWsx &&
               pWinStation->pWsx->pWsxSetErrorInfo &&
               pWinStation->pWsxContext)
            {
                pWinStation->pWsx->pWsxSetErrorInfo(
                                   pWinStation->pWsxContext,
                                   TS_ERRINFO_SERVER_DENIED_CONNECTION,
                                   FALSE); //stack lock not held
            }

            //
            // We have queued a reset on winstation, don't bother about
            // notifying sessdir
            bQueueReset = TRUE;

            //
            // Disconnect client
            //
            QueueWinStationReset( pWinStation->LogonId);
        }
        else
        {
            WINSTATION_APIMSG msg;
            msg.ApiNumber = SMWinStationNotify;
            msg.WaitForReply = FALSE;
            msg.u.DoNotify.NotifyEvent = WinStation_Notify_DisableScrnSaver;
            Status = SendWinStationCommand( pWinStation, &msg, 0 );

            ASSERT( NT_SUCCESS(Status) );

            // ignore this error, help can still proceed.
            Status = STATUS_SUCCESS;
        }
    }

    /*
     * Release the winstation lock
     */
release:
    ReleaseWinStation( pWinStation );

    // Now inform the session directory while we're not holding the lock.
    if (!bQueueReset && bHaveCreateInfo && !g_bPersonalTS && g_fAppCompat && !bRedirect)
        SessDirNotifyLogon(pCreateInfo);

    /*
     * Save return status in API message
     */
done:
    // Clear password
    if (0 != PasswordSize)
        memset(pPassword, 0, PasswordSize);
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogon, Status=0x%x\n", Status ));

    if (pCreateInfo != NULL) {
        MemFree(pCreateInfo);
        pCreateInfo = NULL;
    }

    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    return Status;

/*=============================================================================
==   Error returns
=============================================================================*/

    /* Could not allocate for pWinStation->pUserSid,  makarp #182624 */
badusersid:
    MemFree( TokenInfo );

    /*
     * Could not query token info
     * WinStation Open failed (no access)
     * Could not impersonate client token
     * Could not duplicate client token
     */
badquerytoken:
badwsxnotify:
nolicense:
noaccess:
badimpersonate:
    NtClose( ImpersonationToken );
badduptoken:
    NtClose( ClientToken );

    /*
     * Could not duplicate client token handle
     */
baddupobject:
#ifdef not_hydrix
    pWinStation->HasLicense = FALSE;
    RtlZeroMemory( pWinStation->ClientLicense,
                   sizeof(pWinStation->ClientLicense) );
#else
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxClearContext ) {
        pWinStation->pWsx->pWsxClearContext( pWinStation->pWsxContext );
    }
#endif
    ReleaseWinStation( pWinStation );
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogon, Status=0x%x\n", Status ));

    // Clear password
    if (0 != PasswordSize)
        memset(pPassword, 0, PasswordSize);

    if (pCreateInfo != NULL) {
        MemFree(pCreateInfo);
        pCreateInfo = NULL;
    }

    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    return Status;
}


/*****************************************************************************
 *  WinStationNotifyLogoffWorker
 *
 *   Message parameter unmarshalling function for WinStation API.
 ****************************************************************************/
NTSTATUS WinStationNotifyLogoffWorker(
        DWORD ClientLogonId,
        DWORD ClientProcessId)
{

    NTSTATUS Status;
    PWINSTATION pWinStation;
    DWORD SessionID;


    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogoff, LogonId=%d\n", ClientLogonId ));
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationNotifyLogoff, LogonId=%d\n", ClientLogonId ));

    Status = STATUS_SUCCESS;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }
    
    //See if WinStation was notified of logon
    if(pWinStation->StateFlags & WSF_ST_LOGON_NOTIFIED)
    {
        //Clear the flag
        pWinStation->StateFlags &= ~WSF_ST_LOGON_NOTIFIED;
    }
    else
    {
        //WinStation was not notified of logon.
        //do nothing;

        KdPrint(("TERMSRV: WinStationNotifyLogoff FAILED, WinStation was not notified of logon!\n"));
        ReleaseWinStation( pWinStation );
        Status = STATUS_INVALID_PARAMETER; //probably need some special error code
        goto done;
    }


    /*
     * The upper level has verified the client caller
     * is local and has SYSTEM access. So we can trust
     * the parameters passed.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Stop the shadow on console if needed.
     */
    if ( pWinStation->fOwnsConsoleTerminal ) {
        WinStationStopAllShadows( pWinStation );
    }
    
    /*
     * Remove ACE for logged on user to the WinStation object SD
     */
    RemoveUserAce( pWinStation );
    if ( pWinStation->pUserSid ) {
        ASSERT(pWinStation->pProfileSid == NULL);
        pWinStation->pProfileSid = pWinStation->pUserSid;
        pWinStation->pUserSid = NULL;
    }

    /*
     * Cleanup UserToken
     */
    if ( pWinStation->UserToken ) {
        NtClose( pWinStation->UserToken );
        pWinStation->UserToken = NULL;
    }

    /*
     * Indicate this WinStation no longer has a license
     */
#ifdef not_hydrix
    pWinStation->HasLicense = FALSE;
    RtlZeroMemory( pWinStation->ClientLicense,
                   sizeof(pWinStation->ClientLicense) );
#else
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxClearContext ) {
        pWinStation->pWsx->pWsxClearContext( pWinStation->pWsxContext );
    }
#endif
 
    /*
     * do needed data cleanup.
     */

    RtlZeroMemory( pWinStation->Domain,
                   sizeof( pWinStation->Domain ) );
    RtlZeroMemory( pWinStation->UserName,
                   sizeof( pWinStation->UserName ) );
    RtlZeroMemory( &pWinStation->LogonTime,
                   sizeof( pWinStation->LogonTime ) );

    ResetUserConfigData( pWinStation );

    pWinStation->Config.Config.User.UserName[0] = L'\0';
    pWinStation->Config.Config.User.Domain[0] = L'\0';
    pWinStation->Config.Config.User.Password[0] = L'\0';

    if ( pWinStation->LogonId == 0 ) {


        /*
         * No need to do anything else for console state change.
         */
        
        if ( pWinStation->State != (ULONG) State_Connected &&
            pWinStation->State != (ULONG) State_Disconnected) {
            pWinStation->State = State_Connected;
            NotifySystemEvent( WEVENT_STATECHANGE );
        }
        
        pWinStation->Config.Config.User.fPromptForPassword = TRUE;
        //
        //Set the Console Logon Event
        //

        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationNotifyLogoff, Setting ConsoleLogoffEvent\n"));
        NtSetEvent(ConsoleLogoffEvent, NULL);

    /*
     * For non-Console WinStations, mark this WinStation as terminating
     * and set the broken reason and source for later use.
     */
    } else {
        //pWinStation->Terminating = TRUE;
        pWinStation->BrokenReason = Broken_Terminate;
        pWinStation->BrokenSource = BrokenSource_User;

        // Save off the session dir for sending to the session directory
        // below.
        SessionID = pWinStation->LogonId;
    }

    // Clean up the New Client Credentials struct for Long UserName

    if (pWinStation->pNewClientCredentials != NULL) {

        MemFree(pWinStation->pNewClientCredentials);
        pWinStation->pNewClientCredentials = NULL;
    }

    /*
     * Call into licensing core for logoff. Ignore errors.
     */
    (VOID)LCProcessConnectionLogoff(pWinStation);


    NotifyLogoff(pWinStation);
    ReleaseWinStation( pWinStation );

    // Notify the session directory.
    if (!g_bPersonalTS && g_fAppCompat)
        SessDirNotifyLogoff(SessionID);

    /*
     * Notify clients of WinStation logoff
     */
    NotifySystemEvent(WEVENT_LOGOFF);

done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogoff, Status=0x%x\n", Status ));
    return Status;
}


/*****************************************************************************
 *  OldRpcWinStationEnumerateProcesses
 *
 *   WinStationEnumerateProcesses API for Beta servers
 *
 *   The format changed after Beta.  New winsta.dll's were trapping when talking
 *   to old hosts.
 ****************************************************************************/
BOOLEAN
OldRpcWinStationEnumerateProcesses(
    HANDLE  hServer,
    DWORD   *pResult,
    PBYTE   pProcessBuffer,
    DWORD   ByteCount
    )
{
    return ( RpcWinStationEnumerateProcesses( hServer, pResult, pProcessBuffer, ByteCount ) );
}


/*******************************************************************************
 *  RpcWinStationCheckForApplicationName
 *
 *    Handles published applications.
 *
 * EXIT:
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationCheckForApplicationName(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  LogonId,
    PWCHAR pUserName,
    DWORD  UserNameSize,
    PWCHAR pDomain,
    DWORD  DomainSize,
    PWCHAR pPassword,
    DWORD  *pPasswordSize,
    DWORD  MaxPasswordSize,
    PCHAR  pSeed,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    )
{
    /*
     * This is obsolete and should be removed from the RPC
     */
    *pResult = STATUS_NOT_IMPLEMENTED;
    RpcRaiseException(ERROR_INVALID_FUNCTION);
    return FALSE;
}


/*******************************************************************************
 *
 *  RpcWinStationGetApplicationInfo
 *
 *    Gets info about published applications.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationGetApplicationInfo(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  LogonId,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    )
{
    /*
     * This is obsolete and should be removed from the RPC code.
     */
    *pResult = STATUS_NOT_IMPLEMENTED;
    RpcRaiseException(ERROR_INVALID_FUNCTION);
    return FALSE;
}


/*******************************************************************************
 *
 *  RpcWinStationNtsdDebug
 *
 *    Sets up connection for Ntsd to debug processes belonging to another
 *    CSR.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationNtsdDebug(
    HANDLE     hServer,
    DWORD     *pResult,
    ULONG      LogonId,
    LONG       ProcessId,
    ULONG      DbgProcessId,
    ULONG      DbgThreadId,
    DWORD_PTR  AttachCompletionRoutine
    )
{

    *pResult = STATUS_NOT_IMPLEMENTED;
    RpcRaiseException(ERROR_INVALID_FUNCTION);
    return FALSE;
}

/*******************************************************************************
 *
 *  RpcWinStationGetTermSrvCountersValue
 *
 *    Gets TermSrv Counters value
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationGetTermSrvCountersValue(
    HANDLE hServer,
    DWORD  *pResult,
    DWORD  dwEntries,
    PTS_COUNTER pCounter
    )
{
    UINT i;
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    BOOLEAN     bWalkedList = FALSE;
    ULONG       cActive, cDisconnected;

    *pResult = STATUS_UNSUCCESSFUL;

    if (pCounter != NULL) {
        for (i = 0; i < dwEntries; i++) {
            // set the TermSrv counter value.  Currently, startTime is always
            // set to 0 because we don't support time stamp.
            pCounter[i].startTime.QuadPart = 0;

            switch (pCounter[i].counterHead.dwCounterID) {

                case TERMSRV_TOTAL_SESSIONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvTotalSessions;

                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_DISC_SESSIONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvDiscSessions;

                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_RECON_SESSIONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvReconSessions;

                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_CURRENT_ACTIVE_SESSIONS:
                case TERMSRV_CURRENT_DISC_SESSIONS:
                {
                    if ( !bWalkedList ) {

                        cActive = cDisconnected = 0;

                        Head = &WinStationListHead;
                        ENTERCRIT( &WinStationListLock );
                        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

                            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

                            if ( (pWinStation->State == State_Active) ||
                                 (pWinStation->State == State_Shadow) ) 
                                cActive ++;

                            if ( pWinStation->State == State_Disconnected ) 
                                if ( pWinStation->LogonId != 0 )
                                    cDisconnected ++;
                                else if ( pWinStation->UserName[0] )
                                    // For session 0, test if a user is logged on.
                                    cDisconnected ++;
                        }
                        LEAVECRIT( &WinStationListLock );

                        bWalkedList = TRUE;
                    }

                    pCounter[i].counterHead.bResult = TRUE;

                    if ( pCounter[i].counterHead.dwCounterID == TERMSRV_CURRENT_ACTIVE_SESSIONS ) 
                        pCounter[i].dwValue = cActive;
                    else
                        pCounter[i].dwValue = cDisconnected;

                    *pResult = STATUS_SUCCESS;
                }
                break;

                default:
                {
                    pCounter[i].counterHead.bResult = FALSE;
                    pCounter[i].dwValue = 0;
                }
            }
        }
    }

    return ( *pResult == STATUS_SUCCESS );
}

/******************************************************************************
 *
 *  RpcServerGetInternetConnectorStatus
 *
 *    Returns whether Internet Connector licensing is being used
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and pfEnabled contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is in pResult
 *
 *****************************************************************************/

BOOLEAN
RpcServerGetInternetConnectorStatus(
    HANDLE   hServer,
    DWORD    *pResult,
    PBOOLEAN pfEnabled
    )
{
#if 0
    if (pResult != NULL)
    {
        *pResult = STATUS_NOT_IMPLEMENTED;
    }

    if (pfEnabled != NULL)
    {
        *pfEnabled = FALSE;
    }

    return(FALSE);
#else
    //
    //  TEMPORARY FUNCTION! THIS WILL GET NUKED ONCE THE LCRPC
    //  INTERFACE IS UP AND RUNNING AND TSCC CHANGES HAVE BEEN
    //  MADE!
    //

    if (pResult == NULL)
    {
        return(FALSE);
    }

    if (pfEnabled == NULL)
    {
        *pResult = STATUS_INVALID_PARAMETER;
        return(FALSE);
    }

    *pfEnabled = (LCGetPolicy() == (ULONG)3);

    *pResult = STATUS_SUCCESS;
    return(TRUE);
#endif
}

/******************************************************************************
 *
 *  RpcServerSetInternetConnectorStatus
 *
 *    This function will (if fEnabled has changed from its previous setting):
 *       Check that the caller has administrative privileges,
 *       Modify the corresponding value in the registry,
 *       Change licensing mode (between normal per-seat and Internet Connector.
 *       Enable/Disable the TsInternetUser account appropriately
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is in pResult
 *
 ******************************************************************************/

BOOLEAN
RpcServerSetInternetConnectorStatus(
    HANDLE   hServer,
    DWORD    *pResult,
    BOOLEAN  fEnabled
    )
{
#if 0
    if (pResult != NULL)
    {
        *pResult = STATUS_NOT_IMPLEMENTED;
    }

    return(FALSE);
#else
    //
    //  TEMPORARY FUNCTION! THIS WILL GET NUKED ONCE THE LCRPC
    //  INTERFACE IS UP AND RUNNING AND TSCC CHANGES HAVE BEEN
    //  MADE!
    //

    NTSTATUS NewStatus;
    RPC_STATUS RpcStatus;

    if (pResult == NULL)
    {
        return FALSE;
    }

    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        *pResult = STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    if (!IsCallerAdmin())
    {
        RpcRevertToSelf();
        *pResult = STATUS_PRIVILEGE_NOT_HELD;
        return FALSE;
    }

    RpcRevertToSelf();

    *pResult = LCSetPolicy(fEnabled ? 3 : 2, &NewStatus);

    if ((*pResult == STATUS_SUCCESS) && (NewStatus == STATUS_SUCCESS))
    {
        return(TRUE);
    }

    //
    //  If there was an error, it was either in the core or the new policy.
    //  If its in the core, NewStatus will be success. If its in the new
    //  policy, *pResult will be unsuccessful, and the real error will be in
    //  NewStatus. Return the real error.
    //  

    if (NewStatus != STATUS_SUCCESS)
    {
        *pResult = NewStatus;
    }

    return(FALSE);
#endif
}

/******************************************************************************
 *
 *  RpcServerQueryInetConnectorInformation
 *
 *    Queries configuration information about a Internet Connector licensing.
 *
 * ENTRY:
 *
 *    pWinStationInformation (output)
 *       A pointer to a buffer that will receive information about the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being queried.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 *    pReturnLength (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes placed in the window station information buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    False -- The operation failed or Internet Connector licensing isn't
 *             turned on.  Extended error status is in pResult
 *
 *****************************************************************************/

BOOLEAN
RpcServerQueryInetConnectorInformation(
        HANDLE hServer,
        DWORD  *pResult,
        PCHAR  pWinStationInformation,
        DWORD  WinStationInformationLength,
        DWORD  *pReturnLength
        )
{
    // doesn't return
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);

    return FALSE;
}

/******************************************************************************
 *
 *  RpcWinStationQueryLogonCredentials
 *
 *    Queries autologon credentials for use in Winlogon/GINA.
 *
 *****************************************************************************/

BOOLEAN
RpcWinStationQueryLogonCredentials(
    HANDLE hServer,
    ULONG LogonId,
    PCHAR *ppWire,
    PULONG pcbWire
    )
{
    BOOL fRet;
    BOOL fUseLcCredentials;
    LCCREDENTIALS LcCredentials;
    NTSTATUS Status;
    PWINSTATION pWinStation;
    RPC_STATUS RpcStatus;
    WLX_CLIENT_CREDENTIALS_INFO_V2_0 WlxCredentials;
    BOOL fHelpAssistant = FALSE;
    BOOL bValidHelpSession;

    pExtendedClientCredentials pHelpAssistantCredential = NULL;

    //
    //  Impersonate client.
    //
    
    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        return(FALSE);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerSystem())
    {
        RpcRevertToSelf();
        return(FALSE);
    }

    RpcRevertToSelf();

    pWinStation = FindWinStationById(LogonId, FALSE);

    if (pWinStation == NULL)
    {
        return(FALSE);
    }

    pHelpAssistantCredential = MemAlloc(sizeof(ExtendedClientCredentials));
    if (pHelpAssistantCredential == NULL) {
        ReleaseWinStation(pWinStation);
        return FALSE;
    }

    ZeroMemory(&WlxCredentials, sizeof(WLX_CLIENT_CREDENTIALS_INFO_V2_0));
    WlxCredentials.dwType = WLX_CREDENTIAL_TYPE_V2_0;

    if( TSIsSessionHelpSession( pWinStation, &bValidHelpSession ) )
    {
        //
        // We should not hit this since we will disconnect at winstation transfer time
        //        
        ASSERT( TRUE == bValidHelpSession );

        Status = TSHelpAssistantQueryLogonCredentials(pHelpAssistantCredential);

        if( STATUS_SUCCESS == Status )
        {
            WlxCredentials.fDisconnectOnLogonFailure = TRUE;
            WlxCredentials.fPromptForPassword = FALSE;
            WlxCredentials.pszUserName = pHelpAssistantCredential->UserName;
            WlxCredentials.pszDomain = pHelpAssistantCredential->Domain;
            WlxCredentials.pszPassword = pHelpAssistantCredential->Password;

            fUseLcCredentials = FALSE;

            fHelpAssistant = TRUE;
        }
    }

    if( FALSE == fHelpAssistant )
    {
        //
        // Not Help Assistant, use whatever send in from client.
        //
        ZeroMemory(&LcCredentials, sizeof(LCCREDENTIALS));

        Status = LCProvideAutoLogonCredentials(
            pWinStation,
            &fUseLcCredentials,
            &LcCredentials
            );

   
        if (Status == STATUS_SUCCESS)
        {
            if (fUseLcCredentials)
            {
                WlxCredentials.fDisconnectOnLogonFailure = TRUE;
                WlxCredentials.fPromptForPassword = FALSE;
                WlxCredentials.pszUserName = LcCredentials.pUserName;
                WlxCredentials.pszDomain = LcCredentials.pDomain;
                WlxCredentials.pszPassword = LcCredentials.pPassword;
            }
            else
            {    
                WlxCredentials.fDisconnectOnLogonFailure = FALSE;
                WlxCredentials.fPromptForPassword = pWinStation->Config.Config.User.fPromptForPassword;
                
                // If it's an app server, check if it's a SD redirected connection
                // If yes, ignore fPromptForPassword setting and allow auto-logon
                // Note: Only do it if SD is enabled, i.e. GetTSSD() returns a valide value
                if (!g_bPersonalTS && g_fAppCompat && GetTSSD()) {
                    TS_LOAD_BALANCE_INFO LBInfo;
                    ULONG ReturnLength;

                    // need to release it
                    ReleaseTSSD();

                    memset(&LBInfo, 0, sizeof(LBInfo));
                    Status = IcaStackIoControl(pWinStation->hStack,
                                               IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO,
                                               NULL, 0,
                                               &LBInfo, sizeof(LBInfo),
                                               &ReturnLength); 
                
                    if (NT_SUCCESS(Status)) {
                        if (LBInfo.RequestedSessionID &&
                            (LBInfo.ClientRedirectionVersion >= TS_CLUSTER_REDIRECTION_VERSION3)) {
                            WlxCredentials.fPromptForPassword = FALSE;
                        }
                    }   
                }

                // Check if we have to use New Credentials for long UserName and copy accordingly
                if (pWinStation->pNewClientCredentials != NULL) {
                    WlxCredentials.pszUserName = pWinStation->pNewClientCredentials->UserName;
                    WlxCredentials.pszDomain = pWinStation->pNewClientCredentials->Domain;
                    WlxCredentials.pszPassword = pWinStation->pNewClientCredentials->Password;
                } else { 
                    WlxCredentials.pszUserName = pWinStation->Config.Config.User.UserName ;
                    WlxCredentials.pszDomain = pWinStation->Config.Config.User.Domain ;
                    WlxCredentials.pszPassword = pWinStation->Config.Config.User.Password ;
                }
            }   

        }
        else
        {
            fRet = FALSE;
            goto exit;
        }
    }

    ASSERT(WlxCredentials.pszUserName != NULL);
    ASSERT(WlxCredentials.pszDomain != NULL);
    ASSERT(WlxCredentials.pszPassword != NULL);

    *pcbWire = AllocateAndCopyCredToWire((PWLXCLIENTCREDWIREW*)ppWire, &WlxCredentials);

    fRet = *pcbWire > 0;

    //
    //  The values in LcCredentials are LocalAlloc-ed by the core.
    //

    if (fUseLcCredentials)
    {
        if (LcCredentials.pUserName != NULL)
        {
            LocalFree(LcCredentials.pUserName);
        }

        if (LcCredentials.pDomain != NULL)
        {
            LocalFree(LcCredentials.pDomain);
        }

        if (LcCredentials.pPassword != NULL)
        {
            LocalFree(LcCredentials.pPassword);
        }
    }

    if( TRUE == fHelpAssistant )
    {
        // Zero out memory that contains password
        ZeroMemory( pHelpAssistantCredential, sizeof(ExtendedClientCredentials));
    }

exit:
    ReleaseWinStation(pWinStation);

    if (pHelpAssistantCredential != NULL) {
        MemFree(pHelpAssistantCredential);
        pHelpAssistantCredential = NULL;
    }


    return((BOOLEAN)fRet);
}

/*****************************************************************************
 *  RPcWinStationBroadcastSystemMessage
 *      This is the server side for cleint's WinStationBroadcastSystemMessage
 *
 *   Perform the the equivalent to BroadcastSystemMessage to each specified sessions
 *
 * Limittations:
 *   Caller must be system or Admin, and lparam can not be zero unless
 *      msg is WM_DEVICECHANGE
 *      Error checking is done on the clinet side (winsta\client\winsta.c)
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *        sessionID
 *            this idefntifies the hydra session to which message is being sent
 *        timeOut
 *            set this to the amount of time you are willing to wait to get a response
 *            from the specified winstation. Even though Window's SendMessage API
 *            is blocking, the call from this side MUST choose how long it is willing to
 *            wait for a response.
 *        dwFlags
 *                 Option flags. Can be a combination of the following values: Value Meaning
 *                 BSF_ALLOWSFW Windows NT 5.0 and later: Enables the recipient to set the foreground window while
 *                     processing the message.
 *                 BSF_FLUSHDISK Flush the disk after each recipient processes the message.
 *                 BSF_FORCEIFHUNG Continue to broadcast the message, even if the time-out period elapses or one of
 *                     the recipients is hung..
 *                 BSF_IGNORECURRENTTASK Do not send the message to windows that belong to the current task.
 *                     This prevents an application from receiving its own message.
 *                 BSF_NOHANG Force a hung application to time out. If one of the recipients times out, do not continue
 *                     broadcasting the message.
 *                 BSF_NOTIMEOUTIFNOTHUNG Wait for a response to the message, as long as the recipient is not hung.
 *                     Do not time out.
 *                   ***
 *                 *** DO NOT USE *** BSF_POSTMESSAGE Post the message. Do not use in combination with BSF_QUERY.
 *                   ***
 *                 BSF_QUERY Send the message to one recipient at a time, sending to a subsequent recipient only if the
 *                     current recipient returns TRUE.
 *        lpdwRecipients
 *                         Pointer to a variable that contains and receives information about the recipients of the message. The variable can be a combination of the following values: Value Meaning
 *                         BSM_ALLCOMPONENTS Broadcast to all system components.
 *                         BSM_ALLDESKTOPS Windows NT: Broadcast to all desktops. Requires the SE_TCB_NAME privilege.
 *                         BSM_APPLICATIONS Broadcast to applications.
 *                         BSM_INSTALLABLEDRIVERS Windows 95 and Windows 98: Broadcast to installable drivers.
 *                         BSM_NETDRIVER Windows 95 and Windows 98: Broadcast to network drivers.
 *                         BSM_VXDS Windows 95 and Windows 98: Broadcast to all system-level device drivers.
 *                         When the function returns, this variable receives a combination of these values identifying which recipients actually received the message.
 *                         If this parameter is NULL, the function broadcasts to all components.
 *        uiMessage
 *            the window's message to send
 *        wParam
 *            first message param
 *        lParam
 *            second message parameter
 *
 *         pResponse
 *            This is the response to the broadcasted message
 *                  If the function succeeds, the value is a positive value.
 *                  If the function is unable to broadcast the message, the value is ?1.
 *                  If the dwFlags parameter is BSF_QUERY and at least one recipient returned
 *                     BROADCAST_QUERY_DENY to the corresponding message, the return value is zero
 *
 * EXIT:
 *        TRUE    if all went well or
 *        FALSE if something went wrong.
 *
 * WARNING:
 *            Do not use flag  BSF_POSTMESSAGE, since an app/window on a winstation is not setup to send back
 *            a response to the query in an asynchronous fashion. You must wait for the response (until the time out period).
 *
 * Comments:
 *      For more info, please see MSDN for BroadcastSystemMessage()
 *
 ****************************************************************************/
LONG RpcWinStationBroadcastSystemMessage(
    HANDLE      hServer,
    ULONG       sessionID,
    ULONG       waitTime,
    DWORD       dwFlags,
    DWORD       *lpdwRecipients,
    ULONG       uiMessage,
    WPARAM      wParam,
    LPARAM      lParam,
    PBYTE       rpcBuffer,
    ULONG       bufferSize,
    BOOLEAN     fBufferHasValidData,
    LONG        *pResponse
    )
{
    // Broadcast system message to all winstations.

    PWINSTATION pWinStation=NULL;
    WINSTATION_APIMSG WMsg;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    LONG    rc;
    int i;
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;

    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "in RpcWinStationBroadcastSystemMessage()\n"));

    //
    //
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        SetLastError(ERROR_CANNOT_IMPERSONATE );
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        SetLastError(ERROR_ACCESS_DENIED);
        return( FALSE );
    }

    if( !LocalFlag ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " Not a local client call\n"));
        RpcRevertToSelf();
        return( FALSE );
    }

    // if the caller is system or admin, then let it thru, else, return
    if( !(IsCallerSystem() | IsCallerAdmin() ) )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " Caller must be system or admin \n"));
        SetLastError(ERROR_ACCESS_DENIED);
        RpcRevertToSelf();
        return( FALSE );
    }

    //
    // if we got this far, then client is admin or system
    //

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();


    /*
     * Marshall in the [in] parameters
     *
     */

    WMsg.WaitForReply=TRUE;
    WMsg.u.bMsg.dwFlags = dwFlags;
    WMsg.u.bMsg.dwRecipients= *lpdwRecipients;  //note that we are passing the value, and we will get a new value back
    WMsg.u.bMsg.uiMessage = uiMessage;
    WMsg.u.bMsg.wParam = wParam;
    WMsg.u.bMsg.lParam = lParam;
    WMsg.u.bMsg.dataBuffer = NULL;
    WMsg.u.bMsg.bufferSize = 0;
    WMsg.u.bMsg.Response = *pResponse;

    WMsg.ApiNumber = SMWinStationBroadcastSystemMessage ;

    /*
     * Find and lock client WinStation
     */
    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "in RpcWinStationBroadcastSystemMessage() for sessionID = %d \n", sessionID ));
    pWinStation = FindWinStationById( sessionID, FALSE );

    if ( pWinStation == NULL )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "Winstation not found \n"));
        return( FALSE );
    }

    if ( pWinStation->Flags & WSF_LISTEN )
    {
        // this is a "listen" winstation, not an interactive one, so return an empty response.
        *pResponse = 0;
        ReleaseWinStation( pWinStation );
        return( TRUE );
    }

    if ( !((pWinStation->State == State_Active) ||
            (pWinStation->State == State_Disconnected) ) )
    {
        // This is something that winsta.C checks for, but it's possibele that from the time it
        // took to get here, a winstation was logged out from.
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\t request aborted, winstation State should be Active or Disconnected, neither in this case. \n"));
        *pResponse = 0;
        ReleaseWinStation( pWinStation );
        return( TRUE );
    }

    // if we have valid data, then set the msg dataBuffer to point to it
    if ( fBufferHasValidData )
    {
       WMsg.u.bMsg.dataBuffer = rpcBuffer;
       WMsg.u.bMsg.bufferSize = bufferSize;
    }

    /*
     * send message to winstation
     */
    rc = SendWinStationCommand( pWinStation, &WMsg, waitTime );

    ReleaseWinStation( pWinStation );

    if ( NT_SUCCESS( rc ) )
    {
        *pResponse = WMsg.u.bMsg.Response;
        *lpdwRecipients = WMsg.u.bMsg.dwRecipients;
        return (TRUE);
    }
    else
        return ( FALSE );

}


/*****************************************************************************
 *
 *  RpcWinStationSendWindowMessage
 *
 *   Perform the the equivalent to SendMessage to a specific winstation as
 *        identified by the session ID.  This is an exported function, at least used
 *        by the PNP manager to send a device change message (or any other window's message)
 *
 * Limitations:
 *   Caller must be system or Admin, and lparam can not be zero unless
 *      msg is WM_DEVICECHANGE
 *      Error checking is done on the clinet side (winsta\client\winsta.c)
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *        sessionID
 *            this idefntifies the hydra session to which message is being sent
 *        timeOut
 *            set this to the amount of time you are willing to wait to get a response
 *            from the specified winstation. Even though Window's SendMessage API
 *            is blocking, the call from this side MUST choose how long it is willing to
 *            wait for a response.
 *        hWnd
 *            This is the HWND of the target window in the specified session that
 *            a message will be sent to.
 *        Msg
 *            the window's message to send
 *        wParam
 *            first message param
 *        lParam
 *            second message parameter
 *        pResponse
 *          this is the response to the message sent, it depends on the type of message sent, see MSDN
 *
 *
 * EXIT:
 *        TRUE if all went well , check presponse for the actual response to the send message
 *        FALSE if something went wrong, the value of pResponse is not altered.
 *
 * WARNINGs:
 *        since the RPC call never blocks, you need to specify a reasonable timeOut if you want to wait for
 *         a response. Please remember that since this message is being sent to all winstations, the timeOut value
 *        will be on per-winstation.
 *
 *
 * Comments:
 *      For more info, please see MSDN for SendMessage()
 *
 ****************************************************************************/
LONG
   RpcWinStationSendWindowMessage(
    HANDLE      hServer,
    ULONG       sessionID,
    ULONG       waitTime,
    ULONG       hWnd,      // handle of destination window
    ULONG       Msg,       // message to send
    WPARAM      wParam,  // first message parameter
    LPARAM      lParam,   // second message parameter
    PBYTE       rpcBuffer,
    ULONG       bufferSize,
    BOOLEAN     fBufferHasValidData,
    LONG        *pResponse    // reply to the message sent
  )
{
    PWINSTATION pWinStation=NULL;
    WINSTATION_APIMSG WMsg;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    LONG    rc;
    int i;
    PVOID pData;
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;


    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "in RpcWinStationSendWindowMessage()\n"));

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\tNot impersonating! RpcStatus 0x%x\n",RpcStatus));
        SetLastError(ERROR_CANNOT_IMPERSONATE );
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\tI_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        SetLastError(ERROR_ACCESS_DENIED);
        return( FALSE );
    }

    if( !LocalFlag ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\tNot a local client call\n"));
        RpcRevertToSelf();
        return( FALSE );
    }

    // if the caller is system or admin, then let it thru, else, return
    if( !(IsCallerSystem() | IsCallerAdmin() ) )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\tCaller must be system or admin \n"));
        SetLastError(ERROR_ACCESS_DENIED);
        RpcRevertToSelf();
        return( FALSE );
    }

    //
    // if we got this far, then client is admin or system
    //

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();


    /*
     * Marshall in the [in] parameters
     *
     */

    WMsg.WaitForReply=TRUE;
    WMsg.u.sMsg.hWnd = (HWND)LongToHandle( hWnd );
    WMsg.u.sMsg.Msg = Msg;
    WMsg.u.sMsg.wParam = wParam;
    WMsg.u.sMsg.lParam = lParam;
    WMsg.u.sMsg.dataBuffer = NULL;
    WMsg.u.sMsg.bufferSize = 0;
    WMsg.u.sMsg.Response = *pResponse;

    WMsg.ApiNumber = SMWinStationSendWindowMessage ;


    /*
     * Find and lock client WinStation
     */
    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "in RpcWinStationSendWindowMessage() for essionID = %d \n", sessionID ));
    pWinStation = FindWinStationById( sessionID, FALSE );

    if ( pWinStation == NULL )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "Winstation not found \n"));
        return( FALSE );
    }

    if ( pWinStation->Flags & WSF_LISTEN )
    {
        // this is a "listen" winstation, not an interactive one
        ReleaseWinStation( pWinStation );
        return( FALSE );        // this is normal situation, not an error, but no caller of this func should send a message to this w/s
    }

    if ( !((pWinStation->State == State_Active) ||
            (pWinStation->State == State_Disconnected) ) )
    {
        // This is something that winsta.C checks for, but it's possibele that from the time it
        // took to get here, a winstation was logged out from.
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\t request aborted, winstation State should be Active or Disconnected, neither in this case. \n"));
        *pResponse = 0;
        ReleaseWinStation( pWinStation );
        return( TRUE );
    }

    // if we have valid data, then set the msg dataBuffer to point to it
    if ( fBufferHasValidData )
    {
        WMsg.u.sMsg.dataBuffer = rpcBuffer;
        WMsg.u.sMsg.bufferSize = bufferSize;

    }

    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "  dataBuffer = 0x%lx \n", WMsg.u.sMsg.dataBuffer ));
    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "  bufferSize = %d \n", WMsg.u.sMsg.bufferSize ));

    /*
     * send message to winstation
     */
    rc = SendWinStationCommand( pWinStation, &WMsg, waitTime );

    ReleaseWinStation( pWinStation );

    if ( NT_SUCCESS( rc ) )
    {
        *pResponse = WMsg.u.sMsg.Response;
        return (TRUE);
    }
    else
        return ( FALSE );
}

NTSTATUS
IsZeroterminateStringA(
    PBYTE pString,
    DWORD  dwLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;



    if ( (pString == NULL) || (memchr(pString, '\0', dwLength) == NULL)) {
       Status = STATUS_INVALID_PARAMETER;
    }
    return Status;

}

NTSTATUS
IsZeroterminateStringW(
    PWCHAR pwString,
    DWORD  dwLength
    )
{


    if (pwString == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
    for (; 0 < dwLength; ++pwString, --dwLength ) {
        if (*pwString == (WCHAR)0) {
        return STATUS_SUCCESS;
        }
    }
    return STATUS_INVALID_PARAMETER;


}


/*****************************************************************************
*  GetTextualSid()
*     given a sid, return the text of that sid
*
*  Params:
*     [in]    user sid binary
*     [out]   text of user sid stuffed in the buffer which was passed in by the caller
*     [in]    the size of buffer passed in.
*
*  Return:
*     TRUE if no errors.
*
******************************************************************************/
BOOL
GetTextualSid(
    PSID pSid,          // binary Sid
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD cchSidSize  // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidCopy;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy) {
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(TextualSid, TEXT("S-%lu-"), SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}

/*****************************************************************************
*  RpcWinStationUpdateUserConfig()
*     Called by notify when winlogon tells notify that shell startup is about to happen
*     We open the user profile and get the policy data, and then override any data found
*     in user's sessions's USERCONFIGW
*
*  Params:
*     [in]    hServer,
*     [in]    ClientLogonId,
*     [in]    ClientProcessId,
*     [in]    UserToken,
*     [in]    pDomain,
*     [in]    DomainSize,
*     [in]    pUserName,
*     [in]    UserNameSize,
*     [out]  *pResult
*
*  Return:
*     TRUE if no errors, FALSE otherwise, see pResult for the NTSTATUS of the error
*
*
*
* *****************************************************************************/
BOOLEAN
RpcWinStationUpdateUserConfig(
    HANDLE  hServer,
    DWORD   ClientLogonId,
    DWORD   ClientProcessId,
    DWORD   UserToken,
    DWORD   *pResult
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               Length;
    DWORD               rc = ERROR_SUCCESS;
    ULONG               Error;
    USERCONFIGW         *pTmpUserConfig;
    POLICY_TS_USER      userPolicy;
    USERCONFIGW         userPolicyData;
    HANDLE              NewToken;

    PWINSTATION         pWinStation;
    OBJECT_ATTRIBUTES   ObjA;

    PTOKEN_USER         pTokenInfo = NULL;
    HANDLE              hClientToken=NULL;

    // @@@ make these dynamic later
    TCHAR               szSidText [MAX_PATH ];
    DWORD               sidTextSize = MAX_PATH;


    *pResult=0;

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationUpdateUserConfig, LogonId=%d\n", ClientLogonId ));
    
    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL )
    {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        *pResult = Status;
        return( FALSE );
    }
    
    /*
     * Get a valid copy of the clients token handle
     */
    Status = NtDuplicateObject( pWinStation->InitialCommandProcess,
                                (HANDLE)LongToHandle( UserToken ),
                                NtCurrentProcess(),
                                &hClientToken,
                                0, 0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );

    if ( !NT_SUCCESS( Status ) )
        goto done;

     /*
     * Determine size needed for token info buffer and allocate it
     */
     Status = NtQueryInformationToken ( hClientToken, TokenUser,
                                       NULL, 0, &Length );

     if ( Status != STATUS_BUFFER_TOO_SMALL ) 
     {
         goto done;
     }

     pTokenInfo = MemAlloc( Length );
     if ( pTokenInfo == NULL ) 
     {
         Status = STATUS_NO_MEMORY;
         goto done;
     }

     /*
      * Query token information to get client user's SID
      */
     Status = NtQueryInformationToken ( hClientToken, TokenUser,
                                       pTokenInfo, Length, &Length );
     if ( NT_SUCCESS( Status ) ) 
     {

        if ( GetTextualSid( pTokenInfo->User.Sid , szSidText, &sidTextSize ) )
        {
        
            // We now have the user SID
            
            /*
            * Get User policy from HKCU
            */
            if ( RegGetUserPolicy( szSidText, &userPolicy, & userPolicyData ) )
            {
                // 4th param is NULL, since config data is already part of pWinstation 
                // due to the call into NotifyLogonWorker from Winlogon. We are now
                // going to override data by any/all user group policy data.
                MergeUserConfigData( pWinStation, &userPolicy, &userPolicyData, NULL );
            }
            // else we were not able to get user policy, so no merge was done.
            
        }
    }

 done:

    if (pTokenInfo )
    {
        MemFree( pTokenInfo );
    }

    if (hClientToken)
    {   
        NtClose( hClientToken );
    }

    /*
     * Start logon timers anyway, in case of any errors, we should still start the timers since
     * some machine policy might have set them up. 
     */
    StartLogonTimers( pWinStation );

    ReleaseWinStation( pWinStation );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: RpcWinStationUpdateUserConfig, Status=0x%x\n", Status ));

    *pResult = Status ;

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


BOOLEAN RpcWinStationRegisterConsoleNotification (
    HANDLE      hServer,
    DWORD       *pResult,
    ULONG       SessionId,
    ULONG       hWnd,      // handle of destination window
    DWORD       dwFlags
)
{

    RPC_STATUS RpcStatus;
    UINT  LocalFlag;

    if (pResult == NULL) {
        return FALSE;
    }

    //
    // Calling this function from the remote machine, does not make sense, and
    // we should not allow it.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        *pResult = STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return( FALSE );
    }

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();


    // BUGBUG : MakarP, can we check if the calling process owns this hWnd ?
    // using GetWindowThreadProcessId ? Does it work across the sessions ?

    *pResult = RegisterConsoleNotification ( hWnd, SessionId, dwFlags );
    return (*pResult == STATUS_SUCCESS);
}

BOOLEAN RpcWinStationUnRegisterConsoleNotification (
    HANDLE      hServer,
    DWORD       *pResult,
    ULONG       SessionId,
    ULONG       hWnd      // handle of destination window
)
{
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;

    if (pResult == NULL) {
        return FALSE;
    }

    //
    // Calling this function from the remote machine, does not make sense, and
    // we should not allow it.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        *pResult = STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return( FALSE );
    }

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();


    // BUGBUG : MakarP, can we check if the calling process owns this hWnd ?
    // using GetWindowThreadProcessId ? Does it work across the sessions ?

    *pResult = UnRegisterConsoleNotification ( hWnd, SessionId);

    return (*pResult == STATUS_SUCCESS);
}

BOOLEAN RpcWinStationIsHelpAssistantSession (
    HANDLE      hServer,     
    DWORD       *pResult,           // function status
    ULONG       SessionId           // user logon id
    )
/*++ 

    RpcWinStationIsSessionHelpAssistantSession returns if a 
    given session is created by Salem HelpAssistant account.

Parameters:

    hServer : Handle to server, unused, just to match all
              other RPC function.
    SessionId : User session ID.

Returns:

    TRUE/FALSE

--*/
{
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;
    PWINSTATION pWinStation=NULL;
    BOOLEAN bReturn;
    BOOL bValidHelpSession;

    *pResult=0;

    //
    // Do we need to check system or only LPC call?
    //

    //
    // Find and lock client WinStation
    //
    pWinStation = FindWinStationById( SessionId, FALSE );
    if ( pWinStation == NULL )
    {
        *pResult = STATUS_CTX_WINSTATION_NOT_FOUND;
        return( FALSE );
    }

    bReturn = (BOOLEAN)TSIsSessionHelpSession( pWinStation, &bValidHelpSession );

    if( TRUE == bReturn )
    {
        if( FALSE == bValidHelpSession )
        {
            *pResult = STATUS_WRONG_PASSWORD;
        }
    }

    
    ReleaseWinStation( pWinStation );
    return bReturn;
}

BOOLEAN RpcRemoteAssistancePrepareSystemRestore (
    HANDLE      hServer,     
    DWORD       *pResult           // function status
    )
/*++ 

    Prepare TermSrv/Salem for system restore.

Parameters:

    hServer : Handle to server, unused, just to match all
              other RPC function.
    pResult : Pointer to DWORD to receive status of function.

Returns:

    TRUE/FALSE

--*/
{
    BOOLEAN bReturn = TRUE;
    RPC_STATUS RpcStatus;   
    BOOL LocalFlag;
    HRESULT hRes;

    if (pResult == NULL) {
        return FALSE;
    }

    //
    // Calling this function from the remote machine, does not make sense, and
    // we should not allow it.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Allow ony local admin to invoke this call.
    //
    if( !IsCallerAdmin() ) {
        RpcRevertToSelf();    
        *pResult = ERROR_ACCESS_DENIED;
        return (FALSE);
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = ERROR_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        *pResult = ERROR_ACCESS_DENIED;
        RpcRevertToSelf();
        return( FALSE );
    }

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();

    *pResult=0;

    hRes = TSRemoteAssistancePrepareSystemRestore();
    if( S_OK != hRes ) {
       bReturn = FALSE;
       *pResult = hRes;
    }

    return bReturn;
}


/*
* RpcWinStationGetMachinePolicy
*
*   Return (a copye of ) the machine policy to the caller 
*
*   Parameters:
*
*    hServer : Handle to server, unused, just to match all
*              other RPC function.
*
*    pointer to the policy struct
*   
*    size of the policy struct.
*
*/
BOOLEAN 
RpcWinStationGetMachinePolicy(
       SERVER_HANDLE                hServer,
       PBYTE                        pPolicy,
       ULONG                        bufferSize )
{
    if (pPolicy == NULL) {
        return FALSE;
    }
    // Check if BufferSize if big enough
    if (bufferSize < sizeof(POLICY_TS_MACHINE)) {
        return FALSE;
    }
    RtlCopyMemory( pPolicy , & g_MachinePolicy, sizeof( POLICY_TS_MACHINE ) );
    return TRUE;
}

/*++ 

    RpcWinStationUpdateClientCachedCredentials is used to store the ACTUAL credentials
    used to log on by a client. This is stored in WINSTATION struct which is later
    on used to notify the client about the logon credentials. This API is called
    from MSGINA.

Parameters:

    ClientLogonId : Logon Id of the new session opened by the client
    
    pDomian, pUserName : Credentials used by the client to log on

Returns:

    TRUE if the call succeeded in updating the credentials.

--*/

BOOLEAN
RpcWinStationUpdateClientCachedCredentials(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId,
    PWCHAR      pDomain,
    DWORD       DomainSize,
    PWCHAR      pUserName,
    DWORD       UserNameSize
    )
{
    NTSTATUS Status;


    /*
     * Do some buffer validation
     */
    *pResult = IsZeroterminateStringW(pUserName, UserNameSize  );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = IsZeroterminateStringW(pDomain, DomainSize  );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon) 
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationUpdateClientCachedCredentialsWorker(
                    ClientLogonId,
                    ClientProcessId,
                    pDomain,
                    DomainSize,
                    pUserName,
                    UserNameSize
                    );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

/*****************************************************************************
 *  WinStationUpdateClientCachedCredentialsWorker
 *
 *   Worker function for RPCWinStationUpdateClientCachedCredentials
 ****************************************************************************/
NTSTATUS WinStationUpdateClientCachedCredentialsWorker(
        DWORD       ClientLogonId,
        ULONG_PTR   ClientProcessId,
        PWCHAR      pDomain,
        DWORD       DomainSize,
        PWCHAR      pUserName,
        DWORD       UserNameSize)
{

    PWINSTATION pWinStation;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationUpdateClientCachedCredentialsWorker, LogonId=%d\n", ClientLogonId ));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Do not do anything if the session is not connected. The processing in this API assumes we are connected and have a
     * valid stack.
     */
    if ((ClientLogonId != 0) && ((pWinStation->State != State_Connected) ||  pWinStation->StateFlags & WSF_ST_IN_DISCONNECT)) {
        Status = STATUS_CTX_CLOSE_PENDING;
        ReleaseWinStation( pWinStation );
        goto done;
    }
    
    /*
     * Upper level code has verified that this RPC
     * is coming from a local client with SYSTEM access.
     *
     * We should be able to trust the ClientProcessId from
     * SYSTEM code.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Save User Name and Domain Name which we will later use to send Notification to the Client 
     */
    pWinStation->pNewNotificationCredentials = MemAlloc(sizeof(CLIENTNOTIFICATIONCREDENTIALS)); 
    if (pWinStation->pNewNotificationCredentials == NULL) {
        Status = STATUS_NO_MEMORY ; 
        ReleaseWinStation( pWinStation );
        goto done ; 
    }

    // pDomain and pUserName are sent from Winlogon - these cannot exceed the size of the pWinstation buffers
    // because of the restrictions in the credentials lengths imposed by winlogon
    // But anyway check for their length and truncate them if they are more than the length of pWinstation buffers

    if ( wcslen(pDomain) > EXTENDED_DOMAIN_LEN ) {
        pDomain[EXTENDED_DOMAIN_LEN] = L'\0';
    }

    if ( wcslen(pUserName) > EXTENDED_USERNAME_LEN ) {
        pUserName[EXTENDED_USERNAME_LEN] = L'\0';
    }

    wcscpy( pWinStation->pNewNotificationCredentials->Domain, pDomain);
    wcscpy( pWinStation->pNewNotificationCredentials->UserName, pUserName);

    /*
     * Release the winstation lock
     */
    ReleaseWinStation( pWinStation );

done:
    /*
     * Save return status in API message
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationUpdateClientCachedCredentialsWorker, Status=0x%x\n", Status ));
    return Status;

}

/*++ 

    RpcWinStationFUSCanRemoteUserDisconnect - this API is used in a FUS Scenario 
    when there is someone at the console and another user tries to open a remote 
    session. This API askes the local user if it is ok to disconnect his/her session
    and allow the remote user to connect.

Parameters:

    TargetLogonId : Session ID which is being requested for connection
    
    ClientLogonId : Session ID of the temperory new session
  
    pDomain : Domain Name of the user who is trying to connect from remote
    
    pUserName : UserName of the user who is trying to connect from remote
   

Returns:

    TRUE - The local user has agreed to connect the remote user - so this user's session
           will be disconnected
           
    FALSE - Local user does not allow the remote user to connect           

--*/

BOOLEAN
RpcWinStationFUSCanRemoteUserDisconnect(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       TargetLogonId,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId,
    PWCHAR      pDomain,
    DWORD       DomainSize,
    PWCHAR      pUserName,
    DWORD       UserNameSize
    )
{
    NTSTATUS Status;

    /*
     * Do some buffer validation
     */
    *pResult = IsZeroterminateStringW(pUserName, UserNameSize  );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = IsZeroterminateStringW(pDomain, DomainSize  );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon) 
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationFUSCanRemoteUserDisconnectWorker(
                    TargetLogonId,
                    ClientLogonId,
                    ClientProcessId,
                    pDomain,
                    DomainSize,
                    pUserName,
                    UserNameSize
                    );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

/*****************************************************************************
 *  WinStationFUSCanRemoteUserDisconnectWorker
 *
 *   Worker function for WinStationFUSCanRemoteUserDisconnect
 ****************************************************************************/
NTSTATUS WinStationFUSCanRemoteUserDisconnectWorker(
        DWORD       TargetLogonId,
        DWORD       ClientLogonId,
        ULONG_PTR   ClientProcessId,
        PWCHAR      pDomain,
        DWORD       DomainSize,
        PWCHAR      pUserName,
        DWORD       UserNameSize)
{

    PWINSTATION pTargetWinStation, pClientWinStation;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;

    WINSTATION_APIMSG msg;
    ULONG DisconnectResponse;
    OBJECT_ATTRIBUTES ObjA;
    int cchTitle, cchMessage;
    
    WCHAR *szTitle = NULL;
    WCHAR *szMsg = NULL;
    WCHAR *FUSDisconnectMsg = NULL;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationFUSCanRemoteUserDisconnect, LogonId=%d\n", ClientLogonId ));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    // Allocate the strings needed to display the Popup MessageBox
    if ((szTitle = LocalAlloc(LMEM_FIXED, MAX_STRING_BYTES * sizeof(WCHAR))) == NULL) {
        Status = STATUS_NO_MEMORY ;
        goto done;
    }

    if ((szMsg = LocalAlloc(LMEM_FIXED, MAX_STRING_BYTES * sizeof(WCHAR))) == NULL) {
        Status = STATUS_NO_MEMORY ;
        goto done;
    }

    if ((FUSDisconnectMsg = LocalAlloc(LMEM_FIXED, MAX_STRING_BYTES * sizeof(WCHAR))) == NULL) {
        Status = STATUS_NO_MEMORY ;
        goto done;
    }

    /*
     * Find and lock client WinStation
     */
    pClientWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pClientWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Do not do anything if the session is not connected. The processing in this API assumes we are connected and have a
     * valid stack.
     */
    if ((ClientLogonId != 0) && ((pClientWinStation->State != State_Connected) ||  pClientWinStation->StateFlags & WSF_ST_IN_DISCONNECT)) {
        Status = STATUS_CTX_CLOSE_PENDING;
        ReleaseWinStation(pClientWinStation);
        goto done;
    } 
    
    /*
     * Upper level code has verified that this RPC
     * is coming from a local client with SYSTEM access.
     *
     * We should be able to trust the ClientProcessId from
     * SYSTEM code.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pClientWinStation->InitialCommandProcessId ) {
        ReleaseWinStation(pClientWinStation);
        goto done;
    } 

    /*
     * Client WinStation is not needed anymore, so release that lock
     */
    ReleaseWinStation(pClientWinStation);

    /*
     * Find and lock target WinStation
     */
    pTargetWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pTargetWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Display a MessageBox to the User in the present session - the main purpose of this API 
     */
    cchTitle = LoadString( hModuleWin, STR_FUS_REMOTE_DISCONNECT_TITLE, szTitle, MAX_STRING_BYTES);

    LoadString( hModuleWin, STR_FUS_REMOTE_DISCONNECT_MSG, szMsg, MAX_STRING_BYTES);

    cchMessage = wsprintf( FUSDisconnectMsg, L"%s\\%s %s", pDomain, pUserName, szMsg );
    /*
     * Send message and wait for reply
     */
    msg.u.SendMessage.pTitle = szTitle;
    msg.u.SendMessage.TitleLength = (cchTitle+1) * sizeof(WCHAR);
    msg.u.SendMessage.pMessage = FUSDisconnectMsg;
    msg.u.SendMessage.MessageLength = (cchMessage+1) * sizeof(WCHAR);
    msg.u.SendMessage.Style = MB_YESNO | MB_DEFBUTTON1 | MB_ICONQUESTION;
    msg.u.SendMessage.Timeout = 20;
    msg.u.SendMessage.DoNotWait = FALSE;
    msg.u.SendMessage.pResponse = &DisconnectResponse;

    msg.ApiNumber = SMWinStationDoMessage;

    /*
     *  Create wait event
     */
    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
    Status = NtCreateEvent( &msg.u.SendMessage.hEvent, EVENT_ALL_ACCESS, &ObjA,
                            NotificationEvent, FALSE );
    if ( !NT_SUCCESS(Status) ) {
        ReleaseWinStation(pTargetWinStation);
        goto done;
    }

    /*
     *  Initialize response to IDTIMEOUT
     */
    DisconnectResponse = IDTIMEOUT;

    /*
     * Tell the WinStation to display the message box
     */
    Status = SendWinStationCommand( pTargetWinStation, &msg, 0 );

    /*
     *  Wait for response
     */
    if ( Status == STATUS_SUCCESS ) {
        TRACE((hTrace,TC_ICASRV,TT_API1, "WinStationSendMessage: wait for response\n" ));
        UnlockWinStation( pTargetWinStation );
        Status = NtWaitForSingleObject( msg.u.SendMessage.hEvent, FALSE, NULL );
        if ( !RelockWinStation( pTargetWinStation ) ) {
            Status = STATUS_CTX_CLOSE_PENDING;
        }
        TRACE((hTrace,TC_ICASRV,TT_API1, "WinStationSendMessage: got response %u\n", DisconnectResponse ));
        NtClose( msg.u.SendMessage.hEvent );
    } else {
        /* close the event in case of SendWinStationCommand failure */
        NtClose( msg.u.SendMessage.hEvent );
    }

    if (Status == STATUS_SUCCESS && DisconnectResponse == IDNO) {
        Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
    }

    /*
     * Release the target winstation lock
     */
    ReleaseWinStation( pTargetWinStation );

done:
    /*
     * Do some memory cleanup
     */
    if (szTitle != NULL) {
        LocalFree(szTitle);
        szTitle = NULL;
    }

    if (szMsg != NULL) {
        LocalFree(szMsg);
        szMsg = NULL;
    }

    if (FUSDisconnectMsg != NULL) {
        LocalFree(FUSDisconnectMsg);
        FUSDisconnectMsg = NULL;
    }

    /*
     * Save return status in API message
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationFUSCanRemoteUserDisconnectWorker, Status=0x%x\n", Status ));
    return Status;

}

/*++ 

    RPCWinStationCheckLoopBack checks for loopback during connections. This API
    is called from Winlogon. 

Parameters:

    ClientSessionId : Session ID from where the TS Client was started
            
    TargetLogonId : Session ID to which we are trying to connect
    
    pTargetServerName : Name of the Server we are trying to connect to
    
Returns:

    TRUE if there is a loopBack, FALSE otherwise 

--*/

BOOLEAN
RpcWinStationCheckLoopBack(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       ClientSessionId,
    DWORD       TargetLogonId,
    PWCHAR      pTargetServerName,
    DWORD       NameSize
    )
{
    
    NTSTATUS Status;


    /*
     * Do some buffer validation
     */
    *pResult = IsZeroterminateStringW(pTargetServerName, NameSize );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }

    *pResult = WinStationCheckLoopBackWorker(
                    TargetLogonId,
                    ClientSessionId,
                    pTargetServerName,
                    NameSize
                    );

    // NOTE - If Worker function returns STATUS_SUCCESS that means there is no loopback, so return FALSE
    return( *pResult == STATUS_SUCCESS ? FALSE : TRUE );
}

/*****************************************************************************
 *  WinStationCheckLoopBackWorker
 *
 *   Worker function for RPCWinStationCheckLoopBack
 ****************************************************************************/
NTSTATUS WinStationCheckLoopBackWorker(
        DWORD       TargetLogonId,
        DWORD       ClientSessionId,
        PWCHAR      pTargetServerName,
        DWORD       NameSize)
{
    PWINSTATION pWinStation;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCheckLoopBackWorker, ClientSessionId=%d, TargetLogonId = %d\n", ClientSessionId, TargetLogonId ));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    // Do the actual processing to call the CheckLoopBack routine here
    // Use the _CheckShadowLoop function which already detects for a loop during Shadowing

    Status = _CheckShadowLoop(ClientSessionId, pTargetServerName, TargetLogonId);

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCheckLoopBackWorker, Status=0x%x\n", Status ));
    return Status;

}

/****************************************************************************\
 *
 * IsValidLoopBack first checks if the client is running on the same machine
 * If client is running on the same machine, it makes a call to 
 * WinStationCheckLoopBackWorker to detect if this is a loopback
 *
\****************************************************************************/

BOOL IsValidLoopBack(PWINSTATION pWinStation, ULONG TargetSessionId, ULONG ClientSessionId)
{
    BOOL  IsClientOnSameMachine_Result = FALSE ;
    BOOL  IsLoopBack = FALSE ; 
    DWORD NameSize ; 
    PWCHAR pComputerName = NULL;
    DWORD dwComputerNameSize;

    pComputerName = MemAlloc( MAX_STRING_BYTES * sizeof(WCHAR));
    if (pComputerName == NULL) {
        return FALSE;
    }

    dwComputerNameSize = MAX_STRING_BYTES ; 
    if (!GetComputerName(pComputerName,&dwComputerNameSize)) {
        return FALSE;
    }

    IsClientOnSameMachine_Result = IsClientOnSameMachine(pWinStation);

    // If Client is not on the same machine, then we need not go through this API to termsrv
    // There are some valid cases where Client is on the same machine but there is no loopback - this call checks that

    if (IsClientOnSameMachine_Result == TRUE) {
        NameSize = lstrlenW(pComputerName) + 1;
        IsLoopBack = WinStationCheckLoopBackWorker(
                                        TargetSessionId,
                                        ClientSessionId,
                                        pComputerName,
                                        NameSize);
    }

    if (pComputerName != NULL) {
        MemFree( pComputerName );
        pComputerName = NULL;
    }
    #if DBG
        if (TRUE == IsLoopBack) {
            DbgPrint("TermSrv - loop back detected in WinstationConnectWorker.");
        }
    #endif
    return IsLoopBack ; 
}

/*******************************************************************************
 * RpcConnectCallBack
 *
 * Initiate connect back to TS client.  For Whistler, this is Salem only call.
 *
 *
 * Returns :
 *    TRUE  -- 
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcConnectCallback(
    HANDLE hServer,     // needed?
    DWORD  *pResult,
    DWORD  Timeout,
    ULONG  AddressType,     // should be one of the TDI_ADDRESS_TYPE_XXX
    PBYTE  pAddress,        // should be one of the TDI_ADDRESS_XXX
    ULONG  AddressLength
    )
{
    NTSTATUS    Status;
    RPC_STATUS  RpcStatus;
    ICA_STACK_ADDRESS StackAddress;
    PICA_STACK_ADDRESS pStackAddress = &StackAddress;
    PTDI_ADDRESS_IP pTargetIpAddress;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: RpcConnectCallBack" ));

    if( ShutdownInProgress )
    {
        *pResult = STATUS_SYSTEM_SHUTDOWN;
        return FALSE;
    }

    //
    // We only support IPV4 address, Need to modify tdtcp.sys to support IPv6
    //
    if( AddressType != TDI_ADDRESS_TYPE_IP )
    {
        *pResult = STATUS_NOT_SUPPORTED;
        return FALSE;
    }

    //
    // Extra checking, making sure we gets everything.
    //
    if( AddressLength != TDI_ADDRESS_LENGTH_IP )
    {
        *pResult = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    ZeroMemory( &StackAddress, 0 );
    

    // 
    // ??? What other security we want to apply here
    //

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadowStop: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status =  STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    //
    // For Whistler, this call is Salem rdshost.exe only, rdshost.exe is kick off by helpctr
    // running under system context.
    //
    if( !IsCallerSystem() ) {

#if DISABLESECURITYCHECKS

        //
        // Private testing only, allowing administrator to make this call.
        //
        if( !IsCallerAdmin() ) {
            RpcRevertToSelf();    
            Status = STATUS_ACCESS_DENIED;
            goto done;
        }
#else

        RpcRevertToSelf();    
        Status = STATUS_ACCESS_DENIED;
        goto done;

#endif

    }

    RpcRevertToSelf();


    //
    // winsta.h, byte 0, 1, family, 2-n address.
    //
    *(PUSHORT)pStackAddress = (USHORT)AddressType;
    if ( AddressLength <= (sizeof(ICA_STACK_ADDRESS) - 2) ) {
        //
        // Refer to TDI_ADDRESS_IP, last 8 char is not use.
        // Adding a timeout to pass into TD will require changes to ICA_STACK_ADDRESS
        // too risky for Whister but needed on next.
        //
        pTargetIpAddress = (PTDI_ADDRESS_IP)pAddress;
        RtlCopyMemory( &(pTargetIpAddress->sin_zero[0]), &Timeout, sizeof(Timeout) );

        RtlCopyMemory( &((PCHAR)pStackAddress)[2], pAddress, AddressLength );
    } else {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    #if DBG
    {
        PULONG pData = (PULONG)pStackAddress;
        PTDI_ADDRESS_IP pIpAddress = (PTDI_ADDRESS_IP)&((PCHAR)pStackAddress)[2];

        DbgPrint(
                "TERMSRV: Connect API: address port %u  address 0x%x (%u.%u.%u.%u)\n",
                ntohs(pIpAddress->sin_port),
                pIpAddress->in_addr,
                (pIpAddress->in_addr & 0xff000000) >> 24,
                (pIpAddress->in_addr & 0x00ff0000) >> 16,
                (pIpAddress->in_addr & 0x0000ff00) >> 8,
                (pIpAddress->in_addr & 0x000000ff)
            );
    }
    #endif

    Status = TransferConnectionToIdleWinStation( NULL, // no listen winstation
                                                 NULL, // no Endpoint,
                                                 0, //  EndpointLength,
                                                 &StackAddress );

done:

    *pResult = Status;

    return( NT_SUCCESS(*pResult) ? TRUE : FALSE );
}

//*************************************************************
//
//  IsGinaVersionCurrent()
//
//  Purpose:    Loads the gina DLL and negotiates the version number
//
//  Parameters: NONE
//
//  Return:     TRUE  if gina is of current version
//              FALSE if version of gina is not current
//                    or in case of any error
//
//*************************************************************

BOOL 
IsGinaVersionCurrent()
{
    HMODULE hGina = NULL;
    LPWSTR wszGinaName = NULL;
    PWLX_NEGOTIATE pWlxNegotiate = NULL;
    DWORD dwGinaLevel = 0;
    BOOL bResult = FALSE;
    
    wszGinaName = (LPWSTR) LocalAlloc(LPTR,(MAX_PATH+1)*sizeof(WCHAR));

    if(!wszGinaName)
    {
        //
        //Not enough memory
        //
        return FALSE;
    }

    GetProfileStringW(
                L"WINLOGON",
                L"GinaDll",
                L"msgina.dll",
                wszGinaName,
                MAX_PATH);
    
    
    if(!_wcsicmp(L"msgina.dll",wszGinaName))
    {
        //
        //If it is "msgina.dll", 
        //assume that it is a Windows native gina.
        //
        LocalFree(wszGinaName);
        return TRUE;
    }

    //
    //Load gina
    //if we cannot load gina, assume that it is incompatible
    //with TS
    //
    hGina = LoadLibraryW(wszGinaName);

    if (hGina)
    {
        //
        // Get the "WlxNegotiate" function pointer
        //
        pWlxNegotiate = (PWLX_NEGOTIATE) GetProcAddress(hGina, WLX_NEGOTIATE_NAME);

        if (pWlxNegotiate)
        {
            //
            // Negotiate a version number with the gina
            //
            
            if ( pWlxNegotiate(WLX_CURRENT_VERSION, &dwGinaLevel) && 
                (dwGinaLevel == WLX_CURRENT_VERSION) )
            {
                bResult = TRUE;
            }

        }

        FreeLibrary(hGina);
    }
    
    LocalFree(wszGinaName);
    return bResult;
}

/*++ 

    RPCWinStationNotifyDisconnectPipe notifies session 0 Winlogon to disconnect from the autologon named pipe
    
Parameters:

    ClientSessionId : Session ID of the calling process

    ClientProcessId : Process ID of the calling process
    
    
Returns:

    TRUE if notification is successful, FALSE otherwise

--*/

BOOLEAN
RpcWinStationNotifyDisconnectPipe(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    )
{
    
    NTSTATUS Status;

    /*
     * Make sure the caller is SYSTEM (WinLogon) 
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }


    *pResult = WinStationNotifyDisconnectPipeWorker(
                    ClientLogonId,
                    ClientProcessId
                    );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

/*****************************************************************************
 *  WinStationNotifyDisconnectPipeWorker
 *
 *   Worker function for RpcWinstationNotifyDisconnectPipe
 ****************************************************************************/
NTSTATUS WinStationNotifyDisconnectPipeWorker(
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    )

{
    PWINSTATION pWinStation, pTargetWinStation;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;
    WINSTATION_APIMSG DisconnectPipeMsg;
    DWORD SessionZeroLogonId = 0; 

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyDisconnectPipeWorker, ClientLogonId=%d \n", ClientLogonId));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Upper level code has verified that this RPC
     * is coming from a local client with SYSTEM access.
     *
     * We should be able to trust the ClientProcessId from
     * SYSTEM code.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        Status = STATUS_ACCESS_DENIED; 
        ReleaseWinStation( pWinStation );
        goto done;
    }

    ReleaseWinStation(pWinStation); 

    /*
     * Send the Notification to disconnect the autologon Pipe to Winlogon in session 0
     */
    pTargetWinStation = FindWinStationById( SessionZeroLogonId, FALSE );
    if ( pTargetWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    DisconnectPipeMsg.ApiNumber = SMWinStationNotify;
    DisconnectPipeMsg.WaitForReply = FALSE;
    DisconnectPipeMsg.u.DoNotify.NotifyEvent = WinStation_Notify_DisconnectPipe;
    Status = SendWinStationCommand( pTargetWinStation, &DisconnectPipeMsg, 0 );

    /*
     * Release the winstation lock
     */
    ReleaseWinStation( pTargetWinStation );

done:
    /*
     * Save return status in API message
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinstationNotifyDisconnectPipeWorker, Status=0x%x\n", Status ));
    return Status;

}

/*++ 

    RpcWinstationSessionInitialized informs termsrv that winlogon has created the window station and desktop for this session
    
Parameters:

    ClientSessionId : Session ID of the calling process

    ClientProcessId : Process ID of the calling process
    
    
Returns:

    TRUE if everything went well. FALSE otherwise

--*/

BOOLEAN
RpcWinStationSessionInitialized(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    )
{
    return( FALSE );
}


/*******************************************************************************
 *  RpcWinStationAutoReconnect
 *
 *   Does atomic autoreconnection policy work
 *
 * ENTRY:
 *    IN  hServer - RPC caller handle - API restricted to local use
 *    OUT pResult - Result code in NTSTATUS format with information class set
 *    IN  LogonId - Session to autoreconnect
 *    IN  flags   - extra options (currently unused)
 *
 * EXIT:
 *    STATUS_SUCCESS             - if we successfully autoreconnected
 *    STATUS_CTX_WINSTATION_BUSY - if session is already disconnected, or busy
 *    STATUS_ACCESS_DENIED       - if the target winstation was not found
 *                                 or if the autoreconnection check failed
 *    STATUS_NOT_FOUND           - autoreconnect info was not specified
 ******************************************************************************/
BOOLEAN
RpcWinStationAutoReconnect(
   SERVER_HANDLE hServer,
   DWORD         *pResult,
   DWORD         LogonId,
   DWORD         flags
   )
{
    RPC_STATUS RpcStatus;
    UINT LocalFlag = 0;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PWINSTATION pSourceWinStation = NULL;
    PWINSTATION pTargetWinStation = NULL;
    TS_AUTORECONNECTINFO autoReconnectInfo;
    BYTE abClientRandom[512];
    LONG cbClientRandomLen = 0;
    ULONG BytesGot = 0;
    DWORD SourceID;
    DWORD TargetID;

    TRACE((hTrace,TC_ICASRV,TT_API2,"RPC RpcWinStationAutoReconnect for %d\n",
           LogonId));

    //
    // Only allow system caller for security reasons
    //

    RpcStatus = RpcImpersonateClient(NULL);
    if (RpcStatus != RPC_S_OK) {
        Status = STATUS_UNSUCCESSFUL;
        goto rpcaccessdenied;
    }

    //
    //  Check for System caller
    //
    if (!IsCallerSystem()) {
        RpcRevertToSelf();
        Status = STATUS_ACCESS_DENIED;
        goto rpcaccessdenied;
    }
    RpcRevertToSelf();


    //
    // Only allow local access for security reasons
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL,
                   "TERMSRV: RpcWinStationAutoReconnect:" \
                   "I_RpcBindingIsClientLocal() failed: 0x%x\n", RpcStatus));
        Status = STATUS_UNSUCCESSFUL;
        goto rpcaccessdenied;
    }

    //
    // Do the check for local access
    //
    if (!LocalFlag) {
        Status = (DWORD)STATUS_INVALID_PARAMETER;
        goto rpcaccessdenied;
    }

    pSourceWinStation = FindWinStationById( LogonId, FALSE);
    if (pSourceWinStation == NULL) {

        TRACE((hTrace,TC_ICASRV,TT_ERROR,
               "RpcWinStationAutoReconnect source session not found: %d\n",
               LogonId));

        Status = STATUS_ACCESS_DENIED;
        goto badconnectsource;
    }

    if (pSourceWinStation->Terminating ||
        pSourceWinStation->StateFlags & WSF_ST_WINSTATIONTERMINATE ||
        !pSourceWinStation->WinStationName[0]) {

        TRACE((hTrace,TC_ICASRV,TT_ERROR,
               "RpcWinStationAutoReconnect source session disconnected %d\n",
               LogonId));

        Status = STATUS_ACCESS_DENIED;
        goto badconnectsource;
    }

    if (pSourceWinStation->Flags) {
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto badconnectsource;
    }

    //
    // Check if Winstation logons are disabled and prevent ARC from
    // happening in this case. Bug#532238
    //
    if (GetProfileInt(APPLICATION_NAME, WINSTATIONS_DISABLED, 0) == 1) {
        
        //
        // Fail the ARC and tell the client
        //
        Status = STATUS_ACCESS_DENIED;
        pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus(
                    pSourceWinStation->pWsxContext,
                    0,
                    FALSE); //stack lock held

        ReleaseWinStation(pSourceWinStation);
        pSourceWinStation = NULL;
        goto done;
    }

    //
    // Get the client autoreconnect info
    //
    if (pSourceWinStation->pWsx &&
        pSourceWinStation->pWsx->pWsxEscape) {
        Status = pSourceWinStation->pWsx->pWsxEscape(
                                              pSourceWinStation->pWsxContext,
                                              GET_CS_AUTORECONNECT_INFO,
                                              NULL,
                                              0,
                                              &autoReconnectInfo,
                                              sizeof(autoReconnectInfo),
                                              &BytesGot);
    }
    TRACE((hTrace,TC_ICASRV,TT_API3,
           "RpcWinStationAutoReconnect get GET_CS_AUTORECONNECT_INFO: 0x%x\n",
           Status));

    if (0 == BytesGot ) {

        //
        // Skip the rest of the processing if we didn't get any arc info
        //

        //
        // This is not strictly an error condition, the client could have
        // just not sent up any autoreconnect info
        //

        Status = STATUS_NOT_FOUND;
        goto badconnectsource;
    }

    //
    // Get the client random
    //
    if (NT_SUCCESS(Status)) {
        if (pSourceWinStation->pWsx &&
            pSourceWinStation->pWsx->pWsxEscape) {
            Status = pSourceWinStation->pWsx->pWsxEscape(
                                              pSourceWinStation->pWsxContext,
                                              GET_CLIENT_RANDOM,
                                              NULL,
                                              0,
                                              &abClientRandom,
                                              sizeof(abClientRandom),
                                              &BytesGot);

            TRACE((hTrace,TC_ICASRV,TT_API3,
                   "RpcWinStationAutoReconnect get GET_CLIENT_RANDOM: 0x%x\n",
                   Status));

        }
    }

    //
    // Source winstation locked here
    // Target not set yet
    //

    if (NT_SUCCESS(Status)) {

        cbClientRandomLen = BytesGot;

        //
        // Flag the winstation as part of the autoreconnection
        // to prevent a race where it might be reconnected somewhere
        // else while we unlock it
        //
        pSourceWinStation->Flags |= WSF_AUTORECONNECTING;
        SourceID = pSourceWinStation->LogonId;

        //
        // Unlock the winstation because we are about to try to
        // lock the target winstation
        //
        UnlockWinStation(pSourceWinStation);

        //
        // Use the autoreconnect info to find the target winstation
        // Returns a LOCKED winstation on success
        //
        pTargetWinStation = GetWinStationFromArcInfo(
            (PBYTE)abClientRandom,
            cbClientRandomLen,
            (PTS_AUTORECONNECTINFO)&autoReconnectInfo
            );

        if (pTargetWinStation) {

            //
            // Check if the target is busy or if AutoReconnect is disallowed
            //
            if (pTargetWinStation->Flags || pTargetWinStation->fDisallowAutoReconnect) {

                if (pTargetWinStation->fDisallowAutoReconnect) {
                    Status = STATUS_ACCESS_DENIED;
                } else {
                    Status = STATUS_CTX_WINSTATION_BUSY;
                }

                ReleaseWinStation(pTargetWinStation);
                pTargetWinStation = NULL;

                RelockWinStation(pSourceWinStation);

                //
                // Tell the client that ARC failed
                //
                if (pSourceWinStation->pWsx &&
                    pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus) {

                            pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus(
                                    pSourceWinStation->pWsxContext,
                                    0,
                                    FALSE); //stack lock held
                }

                pSourceWinStation->Flags &= ~WSF_AUTORECONNECTING;
                ReleaseWinStation(pSourceWinStation);

                goto done;
            }

            //
            // Success! We found a winstation to autoreconnect to
            // flag it and unlock it so we can make the connect call
            //
            TargetID = pTargetWinStation->LogonId;
            pTargetWinStation->Flags |= WSF_AUTORECONNECTING;
            UnlockWinStation(pTargetWinStation);

        }
        else {

            TRACE((hTrace,TC_ICASRV,TT_ERROR,
                   "TERMSRV: GetWinStationFromArcInfo failed\n"));

            //
            // Relock the source and cancel the autoreconnect flag
            //
            if (RelockWinStation(pSourceWinStation)) {

                //
                // Tell the client that ARC failed
                //
                if (pSourceWinStation->pWsx &&
                    pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus) {
    
                        Status = pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus(
                                    pSourceWinStation->pWsxContext,
                                    0,
                                    FALSE); //stack lock held
                }
            }
            else {
                //
                // This is a failure path anyway so it doesn't
                // matter if the winstation was deleted. It just means
                // we can't send status to the client
                //
            }

            pSourceWinStation->Flags &= ~WSF_AUTORECONNECTING;
            ReleaseWinStation(pSourceWinStation);
            pSourceWinStation = NULL;

            Status = STATUS_ACCESS_DENIED;
            
            goto done;
        }
    }
    else {
        goto badconnectsource;
    }

    //
    // At this point neither winstation is locked
    //

    if (NT_SUCCESS(Status)) {

        ASSERT(pTargetWinStation);

        //
        // Trigger an autoreconnection from Source->Target
        //
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "RpcWinStationAutoReconnect doing ARC from %d to %d\n",
               SourceID, TargetID));

        //
        // Do the reconnection
        //
        // The autoreconnect flag allows the connect worker to properly
        // handle the WSF_AUTORECONNECTING flag whose purpose is to
        // prevent a race where the sessions could be reconnected while
        // the winstations are unlocked
        //
        Status = WinStationConnectWorker(
                    LOGONID_CURRENT,
                    TargetID,
                    SourceID,
                    NULL,
                    0,
                    TRUE,
                    TRUE //flag that this is an autoreconnection
                    );

        //
        // Relock and then release the source
        //
        if (!RelockWinStation(pSourceWinStation)) {
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        }
        pSourceWinStation->Flags &= ~WSF_AUTORECONNECTING;
        ReleaseWinStation(pSourceWinStation);
        pSourceWinStation = NULL;

        //
        // Relock and then release the target
        //
        if (!RelockWinStation(pTargetWinStation)) {
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        }
        pTargetWinStation->Flags &= ~WSF_AUTORECONNECTING;
        ReleaseWinStation(pTargetWinStation);
        pTargetWinStation = NULL;


        TRACE((hTrace,TC_ICASRV,TT_API1,
               "RpcWinStationAutoReconnect ARC ConnectWorker result: 0x%x\n",
               Status));

        if (NT_SUCCESS(Status)) {

            //
            // Call succeeded AND we autoreconnected
            //
            TRACE((hTrace,TC_ICASRV,TT_API1,
                   "RpcWinStationAutoReconnect ARC Succeeded\n"));
        }

    }
    goto done;

badconnectsource:
    if (pSourceWinStation) {
        ReleaseWinStation(pSourceWinStation);
    }
rpcaccessdenied:
done:
    *pResult = Status;

    return NT_SUCCESS(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\winset.c ===
/*************************************************************************
*
* winset.c
*
* Window station set APS
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop
#include "conntfy.h" // for SetLockedState

/*
 *  External Procedures
 */
NTSTATUS xxxWinStationSetInformation( ULONG, WINSTATIONINFOCLASS,
                                      PVOID, ULONG );
VOID _ReadUserProfile( PWCHAR, PWCHAR, PUSERCONFIG );
extern BOOL IsCallerSystem( VOID );
extern BOOL IsCallerAdmin( VOID );

/*
 * Internal Procedures used
 */
NTSTATUS _SetConfig( PWINSTATION, PWINSTATIONCONFIG, ULONG );
NTSTATUS _SetPdParams( PWINSTATION, PPDPARAMS, ULONG );
NTSTATUS _SetBeep( PWINSTATION, PBEEPINPUT, ULONG );
NTSTATUS WinStationShadowChangeMode( PWINSTATION, PWINSTATIONSHADOW, ULONG );

NTSTATUS FlushVirtualInput( PWINSTATION, VIRTUALCHANNELCLASS, ULONG );

NTSTATUS
RpcCheckClientAccess(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

NTSTATUS
CheckWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen,
                PVOID *ppLocalBuf,
                PULONG pLocalBufLen);

/*
 *  Global data
 */
typedef ULONG_PTR (*PFN)();
HMODULE ghNetApiDll = NULL;
PFN pNetGetAnyDCName = NULL;
PFN pNetApiBufferFree = NULL;

/*
 *  External data
 */



NTSTATUS 
_CheckCallerLocalAndSystem()
/*++

Checking caller is calling from local and also is running
under system context

--*/
{
    NTSTATUS Status;
    BOOL bRevert = FALSE;
    UINT        LocalFlag;

    Status = RpcImpersonateClient( NULL );
    if( Status != RPC_S_OK ) {
        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",Status));
        Status = STATUS_CANNOT_IMPERSONATE;
        goto CLEANUPANDEXIT;
    }

    bRevert = TRUE;

    //
    // Inquire if local RPC call
    //
    Status = I_RpcBindingIsClientLocal(
                            0,    // Active RPC call we are servicing
                            &LocalFlag
                            );

    if( Status != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",Status));
        Status = STATUS_ACCESS_DENIED;
        goto CLEANUPANDEXIT;
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        Status = STATUS_ACCESS_DENIED;
        goto CLEANUPANDEXIT;
    }

    Status = (IsCallerSystem()) ? STATUS_SUCCESS : STATUS_ACCESS_DENIED;

CLEANUPANDEXIT:

    if( TRUE == bRevert ) {
        RpcRevertToSelf();
    }

    return Status;
}

/*******************************************************************************
 *
 *  xxxWinStationSetInformation
 *
 *    set window station information  (worker routine)
 *
 * ENTRY:
 *    pWinStation (input)
 *       pointer to citrix window station structure
 *    WinStationInformationClass (input)
 *       Specifies the type of information to set at the specified window
 *       station object.
 *    pWinStationInformation (input)
 *       A pointer to a buffer that contains information to set for the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being set.
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
xxxWinStationSetInformation( ULONG LogonId,
                             WINSTATIONINFOCLASS WinStationInformationClass,
                             PVOID pWinStationInformation,
                             ULONG WinStationInformationLength )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWINSTATION pWinStation;
    ULONG cbReturned;
    WINSTATION_APIMSG msg;
    PWINSTATIONCONFIG pConfig;
    ULONG ConfigLength;
    PPDPARAMS pPdParams;
    ULONG PdParamsLength;
    RPC_STATUS RpcStatus;

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationSetInformation LogonId=%d, Class=%d\n",
            LogonId, (ULONG)WinStationInformationClass ));

    /*
     * Find the WinStation
     * Return error if not found or currently terminating.
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( !pWinStation )
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    if ( pWinStation->Terminating ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_CTX_CLOSE_PENDING );
    }

    /*
     * Verify that client has SET access
     */
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_SET, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        return( Status );
    }

    switch ( WinStationInformationClass ) {

        case WinStationPdParams :

            Status = CheckWireBuffer(WinStationInformationClass,
                                     pWinStationInformation,
                                     WinStationInformationLength,
                                     &pPdParams,
                                     &PdParamsLength);

            if ( !NT_SUCCESS(Status) ) {
                break;
            }

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_SET_PARAMS,
                                            pPdParams,
                                            PdParamsLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }

            LocalFree((PVOID)pPdParams);
            break;


        case WinStationConfiguration :

            Status = CheckWireBuffer(WinStationInformationClass,
                                     pWinStationInformation,
                                     WinStationInformationLength,
                                     &pConfig,
                                     &ConfigLength);

            if ( !NT_SUCCESS(Status) ) {
                break;
            }

            Status = _SetConfig( pWinStation,
                                 pConfig,
                                 ConfigLength );

            LocalFree((PVOID)pConfig);
            break;

        case WinStationTrace :

            RpcStatus = RpcImpersonateClient( NULL );
            if( RpcStatus != RPC_S_OK ) {
                Status = STATUS_CANNOT_IMPERSONATE;
                break;
            }

            if (!IsCallerAdmin() && !IsCallerSystem()) {
                Status = STATUS_ACCESS_DENIED;
            }
            RpcRevertToSelf();
            if (!NT_SUCCESS(Status)) {
                break;
            }


            if ( WinStationInformationLength < sizeof(ICA_TRACE) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if ( pWinStation->hIca ) {
                Status = IcaIoControl( pWinStation->hIca,
                                       IOCTL_ICA_SET_TRACE,
                                       pWinStationInformation,
                                       WinStationInformationLength,
                                       NULL,
                                       0,
                                       NULL );
            }
            break;

        case WinStationSystemTrace :

            RpcStatus = RpcImpersonateClient( NULL );
            if( RpcStatus != RPC_S_OK ) {
               Status = STATUS_CANNOT_IMPERSONATE;
               break;
            }

            if (!IsCallerAdmin() && !IsCallerSystem()) {
                Status = STATUS_ACCESS_DENIED;
            }
            RpcRevertToSelf();
            if (!NT_SUCCESS(Status)) {
                break;
            }

            if ( WinStationInformationLength < sizeof(ICA_TRACE) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            /*
             *  Open ICA device driver
             */
            if ( hTrace == NULL ) {
                Status = IcaOpen( &hTrace );
                if ( !NT_SUCCESS(Status) )
                    hTrace = NULL;
            }

            if ( hTrace ) {
                Status = IcaIoControl( hTrace,
                                       IOCTL_ICA_SET_SYSTEM_TRACE,
                                       pWinStationInformation,
                                       WinStationInformationLength,
                                       NULL,
                                       0,
                                       NULL );
            }
            break;

        case WinStationPrinter :
            break;

    case WinStationBeep :

            if (WinStationInformationLength < sizeof(BEEPINPUT)) {
                Status =  STATUS_BUFFER_TOO_SMALL ;
                break;
            }
            Status = _SetBeep( pWinStation,
                              (PBEEPINPUT) pWinStationInformation,
                              WinStationInformationLength );
            break;

        case WinStationEncryptionOff :

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_ENCRYPTION_OFF,
                                            pWinStationInformation,
                                            WinStationInformationLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }
            break;

        case WinStationEncryptionPerm :

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_ENCRYPTION_PERM,
                                            pWinStationInformation,
                                            WinStationInformationLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }
            break;

        case WinStationSecureDesktopEnter :

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_ENCRYPTION_ENTER,
                                            pWinStationInformation,
                                            WinStationInformationLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }
            break;

        case WinStationSecureDesktopExit :

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_ENCRYPTION_EXIT,
                                            pWinStationInformation,
                                            WinStationInformationLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }
            break;

        /*
         * Give focus to winlogon security desktop
         * -- used by progman.exe
         */
        case WinStationNtSecurity :

            /*
             * Tell the WinStation to Send Winlogon the CTR-ALT-DEL message
             */
            msg.ApiNumber = SMWinStationNtSecurity;
            Status = SendWinStationCommand( pWinStation, &msg, 0 );
            break;

        case WinStationClientData :
            //
            // Handles multiple client data items.  The data buffer
            // format is:
            //     ULONG                // Length of next data item
            //     WINSTATIONCLIENTDATA // Including variable length part
            //     ULONG                // Length of next data item
            //     WINSTATIONCLIENTDATA // Including variable length part
            //     etc
            //
            // WinStationInformationLength is the length of the entire
            // data buffer.  Keep processing client data items until
            // the buffer is exhausted.
            //
            if ( WinStationInformationLength < sizeof(ULONG) +
                                               sizeof(WINSTATIONCLIENTDATA) )
               {
               Status = STATUS_INFO_LENGTH_MISMATCH;
               break;
               }

            if ( pWinStation->hStack )
               {
               //  Check for availability
               if ( pWinStation->pWsx &&
                    pWinStation->pWsx->pWsxIcaStackIoControl )
                  {
                  ULONG CurLen;
                  ULONG LenUsed =0;
                  PBYTE CurPtr = (PBYTE)pWinStationInformation;

                  while (LenUsed + sizeof(ULONG) < WinStationInformationLength)
                     {
                     CurLen = *(ULONG UNALIGNED *)CurPtr;
                     LenUsed += sizeof(ULONG);
                     CurPtr += sizeof(ULONG);

                     if ( (LenUsed + CurLen >= LenUsed) &&
                          (LenUsed + CurLen <= WinStationInformationLength))
                        {
                        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                        pWinStation->pWsxContext,
                                        pWinStation->hIca,
                                        pWinStation->hStack,
                                        IOCTL_ICA_STACK_SET_CLIENT_DATA,
                                        CurPtr,
                                        CurLen,
                                        NULL,
                                        0,
                                        NULL );
                        LenUsed += CurLen;
                        CurPtr += CurLen;
                        }else
                        {
                        Status = STATUS_INVALID_USER_BUFFER;
                        break;
                        }
                     }
                  }
               else
                  {
                  Status = STATUS_INVALID_INFO_CLASS;
                  }
               }

            break;

       case WinStationInitialProgram :

            /*
             * Identify first program, non-consoles only
             */
            if ( LogonId != 0 ) {

                /*
                 * Tell the WinStation this is the initial program
                 */
                msg.ApiNumber = SMWinStationInitialProgram;
                Status = SendWinStationCommand( pWinStation, &msg, 0 );
            }
            break;

        case WinStationShadowInfo:
            Status = _CheckCallerLocalAndSystem();
            if( NT_SUCCESS(Status) ) {
                Status = WinStationShadowChangeMode( pWinStation,
                                                     (PWINSTATIONSHADOW) pWinStationInformation,
                                                     WinStationInformationLength );
            }
    
            break;

        case WinStationLockedState:
        {
            
            BOOL bLockedState;
            if (WinStationInformationLength == sizeof(bLockedState))
            {
                bLockedState = * (LPBOOL) pWinStationInformation;
                Status = SetLockedState (pWinStation, bLockedState);
            }
            else
            {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }

        case WinStationDisallowAutoReconnect:
        {

            RpcStatus = RpcImpersonateClient( NULL );
            if( RpcStatus != RPC_S_OK ) {
               Status = STATUS_CANNOT_IMPERSONATE;
               break;
            }

            if (!IsCallerSystem()) {
                Status = STATUS_ACCESS_DENIED;
            }
            RpcRevertToSelf();
            if (Status != STATUS_SUCCESS) {
                break;
            }
    
            if (WinStationInformationLength == sizeof(BOOLEAN)) {
                pWinStation->fDisallowAutoReconnect = * (PBOOLEAN) pWinStationInformation;
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }

        case WinStationMprNotifyInfo: 
        {
            Status = _CheckCallerLocalAndSystem();
            if (Status != STATUS_SUCCESS) {
                break;
            }

            if (WinStationInformationLength == sizeof(ExtendedClientCredentials)) {

                pExtendedClientCredentials pMprInfo ;
                pMprInfo = (pExtendedClientCredentials) pWinStationInformation;

                wcsncpy(g_MprNotifyInfo.Domain, pMprInfo->Domain, EXTENDED_DOMAIN_LEN);
                g_MprNotifyInfo.Domain[EXTENDED_DOMAIN_LEN] = L'\0';

                wcsncpy(g_MprNotifyInfo.UserName, pMprInfo->UserName, EXTENDED_USERNAME_LEN);
                g_MprNotifyInfo.UserName[EXTENDED_USERNAME_LEN] = L'\0';

                wcsncpy(g_MprNotifyInfo.Password, pMprInfo->Password, EXTENDED_PASSWORD_LEN);
                g_MprNotifyInfo.Password[EXTENDED_PASSWORD_LEN] = L'\0';

            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }

       default:
            /*
             * Fail the call
             */
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

    ReleaseWinStation( pWinStation );

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationSetInformation LogonId=%d, Class=%d, Status=0x%x\n",
            LogonId, (ULONG)WinStationInformationClass, Status));

    return( Status );
}


/*******************************************************************************
 *
 *  _SetConfig
 *
 *    set window station configuration
 *
 * ENTRY:
 *    pWinStation (input)
 *       pointer to citrix window station structure
 *    pConfig (input)
 *       pointer to configuration structure
 *    Length (input)
 *       length of configuration structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_SetConfig( PWINSTATION pWinStation,
            PWINSTATIONCONFIG pConfig,
            ULONG Length )
{
    USERCONFIG          UserConfig;

    /*
     *  Validate length
     */
    if ( Length < sizeof(WINSTATIONCONFIG) )
        return( STATUS_BUFFER_TOO_SMALL );

    /*
     *  Copy structure
     */
    pWinStation->Config.Config = *pConfig;

    /*
     *  Merge client data into winstation structure
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxInitializeUserConfig ) {
        pWinStation->pWsx->pWsxInitializeUserConfig( pWinStation->pWsxContext,
                                                pWinStation->hStack,
                                                pWinStation->hIcaThinwireChannel,
                                                &pWinStation->Config.Config.User,
                                                &pWinStation->Client.HRes,
                                                &pWinStation->Client.VRes,
                                                &pWinStation->Client.ColorDepth);
    }

    /*
     * If user is logged on -> merge user profile data
     */
    if ( pWinStation->UserName[0] ) {

        /*
         *  Read user profile data
         */
        _ReadUserProfile( pWinStation->Domain,
                          pWinStation->UserName,
                          &UserConfig );

#if NT2195
        /*
         * Merge user config data into the winstation
         */
        MergeUserConfigData( pWinStation, &UserConfig );

#else
        // @@@
        DbgPrint(("WARNING: _SetConfig is if-def'd out \n" ) );

#endif


    }

    /*
     *  Convert any "published app" to absolute path
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxConvertPublishedApp ) {
        (void) pWinStation->pWsx->pWsxConvertPublishedApp( pWinStation->pWsxContext,
                                                           &pWinStation->Config.Config.User);
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _ReadUserProfile
 *
 *  This routine reads the user profile data from the registry
 *
 * ENTRY:
 *   pDomain (input)
 *      domain of user
 *   pUserName (input)
 *      user name to read
 *   pUserConfig (output)
 *      address to return user profile data
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID
_ReadUserProfile( PWCHAR pDomain, PWCHAR pUserName, PUSERCONFIG pUserConfig )
{
    PWCHAR pServerName;
    ULONG Length;
    LONG Error;

    /*
     * Get Domain Controller name and userconfig data.
     * If no userconfig data for user then get default values.
     */
    if ( ghNetApiDll == NULL ) {
        ghNetApiDll = LoadLibrary( L"NETAPI32" );
        if ( ghNetApiDll ) {
            pNetGetAnyDCName = GetProcAddress( ghNetApiDll, "NetGetAnyDCName" );
            pNetApiBufferFree = GetProcAddress( ghNetApiDll, "NetApiBufferFree" );
        }
    }

    /*
     * Check to make sure we got a server name
     */
    if ( pNetGetAnyDCName == NULL ||
         pNetGetAnyDCName( NULL, pDomain, (LPBYTE *)&pServerName ) != ERROR_SUCCESS )
        pServerName = NULL;

    /*
     *  Read user profile data
     */
    Error = RegUserConfigQuery( pServerName,
                                pUserName,
                                pUserConfig,
                                sizeof(USERCONFIG),
                                &Length );
    TRACE((hTrace,TC_ICASRV,TT_API1, "RegUserConfigQuery: \\\\%S\\%S, server %S, Error=%u\n",
               pDomain, pUserName, pServerName, Error ));

    if ( Error != ERROR_SUCCESS ) {
        Error = RegDefaultUserConfigQuery( pServerName, pUserConfig,
                                           sizeof(USERCONFIG), &Length );
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "RegDefaultUserConfigQuery, Error=%u\n", Error ));
    }

    /*
     *  Free memory
     */
    if ( pServerName && pNetApiBufferFree )
        pNetApiBufferFree( pServerName );
}


/*******************************************************************************
 *
 *  _SetBeep
 *
 *    Beep the WinStation
 *
 * ENTRY:
 *    pWinStation (input)
 *       pointer to citrix window station structure
 *    pBeepInput (input)
 *       pointer to Beep input structure
 *    Length (input)
 *       length of Beep input structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_SetBeep( PWINSTATION pWinStation,
          PBEEPINPUT  pBeepInput,
          ULONG Length)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BEEP_SET_PARAMETERS BeepParameters;
    IO_STATUS_BLOCK IoStatus;

    /*
     * Do the regular Beep, so you can support fancy Beeps from
     * sound cards.
     */
    if ( pWinStation->LogonId == 0 ) {
        if ( MessageBeep( pBeepInput->uType ) )
            return( STATUS_SUCCESS );
        else
            return( STATUS_UNSUCCESSFUL );
    }

    BeepParameters.Frequency = 440;
    BeepParameters.Duration = 125;

    if ( pWinStation->hIcaBeepChannel ) {
        Status = NtDeviceIoControlFile( pWinStation->hIcaBeepChannel,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_BEEP_SET,
                                        &BeepParameters,
                                        sizeof( BeepParameters ),
                                        NULL,
                                        0
                                      );
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\wsxmgr.c ===
/*************************************************************************
*
* wsxmgr.c
*
* Routines to manage Window Station extensions.
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/


#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   Macros
=============================================================================*/


/*=============================================================================
==   External procedures defined
=============================================================================*/

PWSEXTENSION FindWinStationExtensionDll( PWSTR pszWsxDll, ULONG WdFlag );


/*=============================================================================
==   Local Data
=============================================================================*/

RTL_CRITICAL_SECTION WsxListLock;
LIST_ENTRY WsxListHead;


/*=============================================================================
==   External Data
=============================================================================*/

extern LIST_ENTRY WinStationListHead;    // protected by WinStationListLock


/*******************************************************************************
 *
 *  WsxInit
 *
 *
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    STATUS_SUCCESS on success, the return value of InitCritSec on failure.
 *
 ******************************************************************************/

NTSTATUS
WsxInit( VOID )
{
    InitializeListHead( &WsxListHead );
    return(RtlInitializeCriticalSection( &WsxListLock ));
}


/*******************************************************************************
 *
 *  _WinStationEnumCallback
 *
 *
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
_WinStationEnumCallback(PCALLBACK_PRIMARY pPrimaryCallback,
                        PCALLBACK_COMPLETION pCompletionCallback,
                        PVOID pWsxEnum
)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;

    RtlEnterCriticalSection( &WinStationListLock );

    //  call primary if valid
    if ( pPrimaryCallback ) {

        Head = &WinStationListHead;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
            if ( pWinStation->pWsx ) {
                pPrimaryCallback( pWinStation->pWsx->hInstance, pWinStation->pWsxContext, pWsxEnum );
            } else {
                pPrimaryCallback( NULL, pWinStation->pWsxContext, pWsxEnum );
            }
        }
    }

    //  call completion if valid
    if ( pCompletionCallback ) {
        pCompletionCallback( pWsxEnum );
    }

    RtlLeaveCriticalSection( &WinStationListLock );
}


/*******************************************************************************
 *
 *  _SendWinStationMessage
 *
 *
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
_SendWinStationMessage(
    ULONG LogonId,
    PWCHAR pTitle,
    PWCHAR pMessage,
    ULONG MessageTimeout )
{
    PWINSTATION pWinStation;
    WINSTATION_APIMSG msg;
    NTSTATUS Status;

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    }

    /*
     *  Build message
     */
    msg.u.SendMessage.pTitle = pTitle;
    msg.u.SendMessage.TitleLength = wcslen( pTitle ) * sizeof(WCHAR);
    msg.u.SendMessage.pMessage = pMessage;
    msg.u.SendMessage.MessageLength = wcslen( pMessage ) * sizeof(WCHAR);
    msg.u.SendMessage.Style = MB_OK | MB_ICONSTOP;
    msg.u.SendMessage.Timeout = MessageTimeout;
    msg.u.SendMessage.Response = 0;
    msg.u.SendMessage.DoNotWait = TRUE;
    msg.ApiNumber = SMWinStationDoMessage;

    /*
     *  Send message
     */
    Status = SendWinStationCommand( pWinStation, &msg, 0 );

    /*
     *  Done with winstation
     */
    ReleaseWinStation( pWinStation );

    return( Status );
}


/*******************************************************************************
 *
 *  _GetContextForLogonId
 *
 *
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
_GetContextForLogonId(
    ULONG LogonId,
    PVOID * ppWsxContext
    )
{
    PWINSTATION pWinStation;
    WINSTATION_APIMSG msg;

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        *ppWsxContext = NULL;
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    }

    /*
     *  Return context
     */
    *ppWsxContext = pWinStation->pWsxContext;

    /*
     *  Done with winstation
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _LoadWsxDll
 *
 *   Load and Initialize Window Station Extension DLL.
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

PWSEXTENSION
_LoadWsxDll( PWSTR pszWsxDll )
{
    PWSEXTENSION    pWsx;
    HINSTANCE       hDllInstance;

    if ( pszWsxDll == NULL || *pszWsxDll == UNICODE_NULL )  
        return( NULL );

    hDllInstance = LoadLibrary(pszWsxDll);

    if (!hDllInstance) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d, _LoadWsxDll(%s) failed\n",
                GetLastError(), pszWsxDll));
        return(NULL);
    }

    pWsx = MemAlloc( sizeof(WSEXTENSION) );
    if ( !pWsx ) {
        return(NULL);
    }
    RtlZeroMemory( pWsx, sizeof(WSEXTENSION) );

    RtlCopyMemory( pWsx->WsxDLL, pszWsxDll, sizeof(pWsx->WsxDLL) );
    pWsx->hInstance = hDllInstance;

    /*
     *  Initialize Dll support functions
     */
    pWsx->pWsxInitialize = (PWSX_INITIALIZE) GetProcAddress(hDllInstance, WSX_INITIALIZE);
    if (!pWsx->pWsxInitialize) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Could not find pWsxInitialize entry point\n"));
        goto LoadWsx_ErrorReturn;
    }

    /*
     *  Client Drive Mapping Extensions
     */
    pWsx->pWsxCdmConnect = (PWSX_CDMCONNECT)
        GetProcAddress(hDllInstance,  WSX_CDMCONNECT);

    pWsx->pWsxCdmDisconnect = (PWSX_CDMDISCONNECT)
        GetProcAddress(hDllInstance,  WSX_CDMDISCONNECT);

    pWsx->pWsxVerifyClientLicense = (PWSX_VERIFYCLIENTLICENSE)
        GetProcAddress(hDllInstance, WSX_VERIFYCLIENTLICENSE);

    pWsx->pWsxQueryLicense = (PWSX_QUERYLICENSE)
        GetProcAddress(hDllInstance,  WSX_QUERYLICENSE);

    pWsx->pWsxGetLicense = (PWSX_GETLICENSE)
        GetProcAddress(hDllInstance,  WSX_GETLICENSE);

    pWsx->pWsxWinStationLogonAnnoyance = (PWSX_WINSTATIONLOGONANNOYANCE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONLOGONANNOYANCE);

    pWsx->pWsxWinStationGenerateLicense = (PWSX_WINSTATIONGENERATELICENSE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONGENERATELICENSE);

    pWsx->pWsxWinStationInstallLicense = (PWSX_WINSTATIONINSTALLLICENSE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONINSTALLLICENSE);

    pWsx->pWsxWinStationEnumerateLicenses = (PWSX_WINSTATIONENUMERATELICENSES)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONENUMERATELICENSES);

    pWsx->pWsxWinStationActivateLicense = (PWSX_WINSTATIONACTIVATELICENSE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONACTIVATELICENSE);

    pWsx->pWsxWinStationRemoveLicense = (PWSX_WINSTATIONREMOVELICENSE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONREMOVELICENSE);

    pWsx->pWsxWinStationSetPoolCount = (PWSX_WINSTATIONSETPOOLCOUNT)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONSETPOOLCOUNT);

    pWsx->pWsxWinStationQueryUpdateRequired = (PWSX_WINSTATIONQUERYUPDATEREQUIRED)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONQUERYUPDATEREQUIRED);

    pWsx->pWsxWinStationAnnoyanceThread = (PWSX_WINSTATIONANNOYANCETHREAD)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONANNOYANCETHREAD);

    pWsx->pWsxInitializeClientData = (PWSX_INITIALIZECLIENTDATA)
        GetProcAddress(hDllInstance,  WSX_INITIALIZECLIENTDATA);

    pWsx->pWsxInitializeUserConfig = (PWSX_INITIALIZEUSERCONFIG)
        GetProcAddress(hDllInstance,  WSX_INITIALIZEUSERCONFIG);

    pWsx->pWsxConvertPublishedApp = (PWSX_CONVERTPUBLISHEDAPP)
        GetProcAddress(hDllInstance,  WSX_CONVERTPUBLISHEDAPP);

    pWsx->pWsxWinStationInitialize = (PWSX_WINSTATIONINITIALIZE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONINITIALIZE);

    pWsx->pWsxWinStationReInitialize = (PWSX_WINSTATIONREINITIALIZE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONREINITIALIZE);

    pWsx->pWsxWinStationRundown = (PWSX_WINSTATIONRUNDOWN)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONRUNDOWN);

    pWsx->pWsxDuplicateContext = (PWSX_DUPLICATECONTEXT)
        GetProcAddress(hDllInstance,  WSX_DUPLICATECONTEXT);

    pWsx->pWsxCopyContext = (PWSX_COPYCONTEXT)
        GetProcAddress(hDllInstance,  WSX_COPYCONTEXT);

    pWsx->pWsxClearContext = (PWSX_CLEARCONTEXT)
        GetProcAddress(hDllInstance,  WSX_CLEARCONTEXT);

    pWsx->pWsxVirtualChannelSecurity = (PWSX_VIRTUALCHANNELSECURITY)
        GetProcAddress(hDllInstance,  WSX_VIRTUALCHANNELSECURITY);

    pWsx->pWsxIcaStackIoControl = (PWSX_ICASTACKIOCONTROL)
        GetProcAddress(hDllInstance,  WSX_ICASTACKIOCONTROL);

    pWsx->pWsxBrokenConnection = (PWSX_BROKENCONNECTION)
        GetProcAddress(hDllInstance,  WSX_BROKENCONNECTION);

    pWsx->pWsxLogonNotify = (PWSX_LOGONNOTIFY)
        GetProcAddress(hDllInstance,  WSX_LOGONNOTIFY);

    pWsx->pWsxSetErrorInfo = (PWSX_SETERRORINFO)
        GetProcAddress(hDllInstance,  WSX_SETERRORINFO);

    pWsx->pWsxSendAutoReconnectStatus = (PWSX_SENDAUTORECONNECTSTATUS)
        GetProcAddress(hDllInstance, WSX_SENDAUTORECONNECTSTATUS);

    pWsx->pWsxEscape = (PWSX_ESCAPE)
        GetProcAddress(hDllInstance,  WSX_ESCAPE);

    return(pWsx);

LoadWsx_ErrorReturn:

    LocalFree(pWsx);
    return(NULL);
}


/*******************************************************************************
 *
 *  FindWinStationExtensionDll
 *
 *   Perform initialization of Window Station Extensions
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

PWSEXTENSION
FindWinStationExtensionDll( PWSTR pszWsxDll, ULONG WdFlag )
{
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx = NULL;
    ICASRVPROCADDR IcaSrvProcAddr;
                    
    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( !_wcsicmp( pszWsxDll, pWsx->WsxDLL ) ){
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    if ( Next != Head ) {
        return( pWsx );
    }

    /*
     *  Load winstation extensions dll
     */
    if ( (pWsx = _LoadWsxDll( pszWsxDll )) != NULL ) {

        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "TERMSRV: FindWinStationExtensionDll(%S) succeeded\n", pszWsxDll ));

        IcaSrvProcAddr.cbProcAddr               =
            (ULONG) sizeof(ICASRVPROCADDR);

        IcaSrvProcAddr.pNotifySystemEvent       =
            (PICASRV_NOTIFYSYSTEMEVENT) NotifySystemEvent;

        IcaSrvProcAddr.pSendWinStationMessage =
            (PICASRV_SENDWINSTATIONMESSAGE) _SendWinStationMessage;

        IcaSrvProcAddr.pGetContextForLogonId =
            (PICASRV_GETCONTEXTFORLOGONID) _GetContextForLogonId;

        IcaSrvProcAddr.pWinStationEnumCallBack  =
            (PICASRV_WINSTATIONENUMCALLBACK) _WinStationEnumCallback;

        //  initialize dll support procs
        if ( pWsx->pWsxInitialize( &IcaSrvProcAddr ) ) {
            RtlEnterCriticalSection( &WsxListLock );
            InsertHeadList( &WsxListHead, &pWsx->Links );
            RtlLeaveCriticalSection( &WsxListLock );
        } else {
            LocalFree( pWsx );
            pWsx = NULL;
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: FindWinStationExtensionDll(%S) failed\n", pszWsxDll ));
        }
    }
    else {
        KdPrintEx(( DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: FindWinStationExtensionDll(%S) failed\n", pszWsxDll ));
    }


    /*
     *  Create the thread which will monitor the condition of the
     *  WinFrame Licenses and if necessary send Annoyance Messages.
     */
    if ( pWsx && pWsx->pWsxWinStationAnnoyanceThread ) {
        DWORD ThreadId;
        HANDLE ThreadHandle;

        ThreadHandle = CreateThread( NULL,
                      0,
                      (LPTHREAD_START_ROUTINE)pWsx->pWsxWinStationAnnoyanceThread,
                      NULL,
                      THREAD_SET_INFORMATION,
                      &ThreadId );

        if(ThreadHandle )
            NtClose( ThreadHandle );
    }


    return( pWsx );
}


/*******************************************************************************
 *
 *  WsxStackIoControl
 *
 *   Callback routine called from ICAAPI.DLL to issue StackIoControl calls.
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
WsxStackIoControl(
    IN PVOID pContext,
    IN HANDLE pStack,
    IN ULONG IoControlCode,
    IN PVOID pInBuffer,
    IN ULONG InBufferSize,
    OUT PVOID pOutBuffer,
    IN ULONG OutBufferSize,
    OUT PULONG pBytesReturned )
{
    PWINSTATION pWinStation = (PWINSTATION)pContext;
    NTSTATUS Status;

    TRACE((hTrace, TC_ICASRV, TT_API1,
           "TERMSRV: Enter WsxIcaIoControl, IoControlCode=%d\n",
           (IoControlCode >> 2) & 0xfff));

    if ( pWinStation &&
         pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pStack,
                                IoControlCode,
                                pInBuffer,
                                InBufferSize,
                                pOutBuffer,
                                OutBufferSize,
                                pBytesReturned );
    } else {
        Status = IcaStackIoControl(
                                pStack,
                                IoControlCode,
                                pInBuffer,
                                InBufferSize,
                                pOutBuffer,
                                OutBufferSize,
                                pBytesReturned );
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\wstlpc.c ===
/*************************************************************************
*
* wstlpc.c
*
* WinStation LPC Initialization and dispatch functions for NT ICA Server
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include <rpc.h>
#include "icaevent.h"

/*
 * August 19, 1996 JohnR:
 *
 *  The ICASRV and WinStation API's have been now reorganized.
 *
 *  The main visible API's that client applications such as winadmin,
 *  winquery, and system components such as the spooler see are now
 *  based on RPC.
 *
 *  Internally where ICASRV communicates with WinStations, the reverse
 *  LPC is used. This is because the client of these API's is
 *  the WIN32K.SYS kernel mode module. Non-system mode callers of
 *  the LPC API's are no longer allowed, and must use RPC.
 */


typedef NTSTATUS (*PWINSTATION_API) (
    IN PLPC_CLIENT_CONTEXT pContext,
    IN OUT PWINSTATION_APIMSG ApiMsg
    );


/*
 * entry for the list that keeps track of currently active LPC contexts
 */
typedef struct _TERMSRVLPCCONTEXT {
    LIST_ENTRY Links;
    PVOID      pContext;
} TERMSRVLPCCONTEXT, *PTERMSRVLPCCONTEXT; 

LIST_ENTRY gTermsrvLpcListHead;


/*
 * External Functions
 */
NTSTATUS SendWinStationCommand( PWINSTATION, PWINSTATION_APIMSG, ULONG );


/*
 * Internal Functions
 */
VOID InsertLpcContext(PVOID pContext);
VOID RemoveLpcContext(PVOID pContext);
BOOL GetSessionIdFromLpcContext(PLPC_CLIENT_CONTEXT pContext, PULONG pSessionId);
NTSTATUS WinStationLpcThread( IN PVOID ThreadParameter );
NTSTATUS WinStationLpcHandleConnectionRequest( PPORT_MESSAGE );
VOID     WinStationLpcClientHasTerminated( PLPC_CLIENT_CONTEXT );

NTSTATUS WinStationInternalCreate( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationInternalReset( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationInternalDisconnect( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationWCharLog( PLPC_CLIENT_CONTEXT pContext, PWINSTATION_APIMSG pMsg );
NTSTATUS WinStationGetSMCommand( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationBrokenConnection( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationIcaReplyMessage( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationIcaShadowHotkey( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationWindowInvalid( PLPC_CLIENT_CONTEXT pContext,PWINSTATION_APIMSG pMsg );

/*
 * External functions we call out to do the actual WinStation control
 */
NTSTATUS WinStationDisconnectWorker( ULONG, BOOLEAN, BOOLEAN );
NTSTATUS WinStationDoDisconnect( PWINSTATION, PRECONNECT_INFO, BOOLEAN );
NTSTATUS WinStationExceptionFilter( PWSTR, PEXCEPTION_POINTERS );
NTSTATUS QueueWinStationCreate( PWINSTATIONNAME );
PSECURITY_DESCRIPTOR BuildSystemOnlySecurityDescriptor();

/*
 * Local variables
 */
ULONG MinApiThreads;
ULONG MaxApiThreads;
ULONG NumApiThreads;
ULONG WaitingApiThreads;
RTL_CRITICAL_SECTION ApiThreadLock;
HANDLE SsWinStationLpcPort;
BOOLEAN ShutdownInProgress;
ULONG MessageId = 1;

/*
 * ICASRV WinStation LPC Dispatch Table
 *
 * If this table is changed, the table below must be modified too.
 */
PWINSTATION_API WinStationLpcDispatch[SMWinStationMaxApiNumber] = {

    WinStationInternalCreate,           // for ICASRV internal use only
    WinStationInternalReset,            // for ICASRV internal use only
    WinStationInternalDisconnect,       // for ICASRV internal use only
    WinStationWCharLog,                 // for ICASRV internal use only
    WinStationGetSMCommand,
    WinStationBrokenConnection,
    WinStationIcaReplyMessage,
    WinStationIcaShadowHotkey,
    NULL, // WinStationDoConnect,      // needed for connect and reconnect (I.E. InitMouse)
    NULL, // WinStationDoDisconnect,   // needed for disconnect (I.E. disable screen)
    NULL, // WinStationDoReconnect     // Reconnect
    NULL, // WinStationExitWindows,    // Logoff
    NULL, // WinStationTerminate,      // Terminate process (less gentle than logoff?)
    NULL, // WinStationNtSecurity,     // CTL-ALT-DEL screen
    NULL, // WinStationDoMessage,      // Message box
    NULL, // WinStationDoBreakPoint    // WinStation breakpoint
    NULL, // WinStationThinwireStats   // Get thinwire stats
    NULL, // WinStationShadowSetup,
    NULL, // WinStationShadowStart,
    NULL, // WinStationShadowStop,
    NULL, // WinStationShadowCleanup,
    NULL, // WinStationPassthruEnable,
    NULL, // WinStationPassthruDisable,
    NULL, // WinStationSetTimeZone,    // Set Time Zone
    NULL, // WinStationInitialProgram,
    NULL, // WinStationNtsdDebug,
    NULL, // WinStationBroadcastSystemMessage    // For PNP: This is the counter part to BroadcastSystemMessage on console
    NULL, // WinStationSendWindowMessage                   // General Window's SendMessage() API
    NULL, // SMWinStationNotify
    WinStationWindowInvalid
};

#if DBG
PSZ WinStationLpcName[SMWinStationMaxApiNumber] = {
    "WinStationInternalCreate",
    "WinStationInternalReset",
    "WinStationInternalDisconnect",
    "WinStationWCharLog",
    "WinStationGetSMCommand",
    "WinStationBrokenConnection",
    "WinStationIcaReplyMessage",
    "WinStationShadowHotkey",
    "WinStationDoConnect",
    "WinStationDoDisconnect",
    "WinStationDoReconnect",
    "WinStationExitWindows",
    "WinStationTerminate",
    "WinStationNtSecurity",
    "WinStationDoMessage",
    "WinStationDoBreakPoint",
    "WinStationThinwireStats",
    "WinStationShadowSetup",
    "WinStationShadowStart",
    "WinStationShadowStop",
    "WinStationShadowCleanup",
    "WinStationPassthruEnable",
    "WinStationPassthruDisable",
    "WinStationSetTimeZone",
    "WinStationInitialProgram",
    "WinStationNtsdDebug",
    "WinStationBroadcastSystemMessage",
    "WinStationSendWindowMessage",
    "SMWinStationNotify",
    "WinStationWindowInvalid"
};

PSZ WinStationStateName[] = {
    "Active",
    "Connected",
    "ConnectQuery",
    "VirtualIO",
    "Disconnected",
    "Idle",
    "Off",
    "Reset",
    "Down",
    "Init",
};
#endif // DBG


/*****************************************************************************
 *
 *  WinStationInitLPC
 *
 *   Create the Session manager WinStation API LPC port and Thread
 *
 * ENTRY:
 *   No Parameters
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInitLPC()
{
    ULONG i;
    NTSTATUS st;
    ANSI_STRING Name;
    UNICODE_STRING UnicodeName;
    OBJECT_ATTRIBUTES ObjA;
    ULONG Length;
    SYSTEM_BASIC_INFORMATION SysInfo;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: WinSta: Init WinStation LPC Channels\n"));

    /*
     * Initialize PC context LIst
     */
    InitializeListHead(&gTermsrvLpcListHead);

    /*
     * create a security descriptor that allows only SYSTEM access
     */
    SecurityDescriptor = BuildSystemOnlySecurityDescriptor();

    if (!SecurityDescriptor)
    {
        return STATUS_NO_MEMORY;
    }

    /*
     * Create the port for the WIN32 CSRSS's to connect to.
     */
    RtlInitAnsiString( &Name, "\\SmSsWinStationApiPort" );
    st = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE);
    if (!NT_SUCCESS(st))
    {
        MemFree( SecurityDescriptor );
        return st;

    }

    InitializeObjectAttributes( &ObjA, &UnicodeName, 0, NULL,
            SecurityDescriptor );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: Creating SsApiPort\n"));

    ASSERT( sizeof(WINSTATION_APIMSG) <= PORT_MAXIMUM_MESSAGE_LENGTH );

    st = NtCreatePort( &SsWinStationLpcPort,
                       &ObjA,
                       sizeof(WINSTATIONAPI_CONNECT_INFO),
                       sizeof(WINSTATION_APIMSG),
                       sizeof(WINSTATION_APIMSG) * 32 );

    RtlFreeUnicodeString(&UnicodeName);

    /*
     * Clean up security stuff
     */
    MemFree( SecurityDescriptor );

    if (!NT_SUCCESS(st))
    {
        return st;
    }



    /*
     * Determine min/max number of API threads we will support
     */
    if (g_bPersonalTS) {
        MinApiThreads = 1;
        MaxApiThreads = 100;
    }
    else {
        MinApiThreads = 3;
        st = NtQuerySystemInformation( SystemBasicInformation,
                                       &SysInfo, sizeof(SysInfo), &Length );
        if ( NT_SUCCESS( st ) )
            MaxApiThreads = 100; //  (3 + SysInfo.NumberOfProcessors * 2);
        else {
            DBGPRINT(( "TERMSRV: NtQuerySystemInfo failed, rc=0x%x\n", st ));
            MaxApiThreads = 100;
        }
    }
    NumApiThreads = 0;
    WaitingApiThreads = 0;
    st = RtlInitializeCriticalSection( &ApiThreadLock );
    if(!(NT_SUCCESS(st))) {
        return(st);
    }

    /*
     * Create Initial Set of Server Threads
     */
    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: Creating WinStation LPC Server Threads\n"));

    for ( i = 0; i < MinApiThreads; i++ ) {
        DWORD ThreadId;
        HANDLE Handle;

        Handle = CreateThread( NULL,
                               0,
                               (LPTHREAD_START_ROUTINE)WinStationLpcThread,
                               NULL,
                               THREAD_SET_INFORMATION,
                               &ThreadId );
        if ( !Handle ) {
            return( STATUS_TOO_MANY_THREADS );
        } else {
            NtClose( Handle );
        }
    }

    RtlEnterCriticalSection( &ApiThreadLock );
    NumApiThreads += MinApiThreads;
    RtlLeaveCriticalSection( &ApiThreadLock );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Done Creating Service API Service Threads\n" ));

    return STATUS_SUCCESS;
}


/*****************************************************************************
 *
 *  WinStationLpcThread
 *
 *   Main service thread for internal Winstation LPC connections.
 *
 * ENTRY:
 *    ThreadParameter (input)
 *      Not used standard NT ThreadCreate() parameter
 *
 * EXIT:
 *   Should never exit
 *
 ****************************************************************************/


NTSTATUS
WinStationLpcThread( IN PVOID ThreadParameter )
{
    WINSTATION_APIMSG ApiMsg;
    PWINSTATION_APIMSG ReplyMsg;
    PLPC_CLIENT_CONTEXT pContext;
    NTSTATUS Status;
    HANDLE Handle;

    ReplyMsg = NULL;

    /*
     * Loop forever processing API requests
     */
    for ( ; ; ) {

        /*
         * If there are more than the minimum number of API threads active,
         * and at least 1 waiting thread, then this thread will terminate.
         * But first, any pending reply message must be sent.
         */
        RtlEnterCriticalSection( &ApiThreadLock );
#ifdef notdef
        if ( NumApiThreads > MinApiThreads && WaitingApiThreads ) {
            NumApiThreads--;
            RtlLeaveCriticalSection( &ApiThreadLock );
            if ( ReplyMsg ) {
                (VOID) NtReplyPort( SsWinStationLpcPort,
                                    (PPORT_MESSAGE) ReplyMsg );
            }
            break;
        }
#endif

        /*
         * Increment the number of waiting threads and wait for an LPC request
         */
        WaitingApiThreads++;
        RtlLeaveCriticalSection( &ApiThreadLock );
        Status = NtReplyWaitReceivePort( SsWinStationLpcPort,
                                         (PVOID *) &pContext,
                                         (PPORT_MESSAGE) ReplyMsg,
                                         (PPORT_MESSAGE) &ApiMsg );
        RtlEnterCriticalSection( &ApiThreadLock );

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStation LPC Service Thread got a message\n" ));
        /*
         * If there are no more waiting threads,
         * then create a new API thread to process requests.
         */
        if ( --WaitingApiThreads == 0 && NumApiThreads < MaxApiThreads ) {
            DWORD ThreadId;

            NumApiThreads++;
            RtlLeaveCriticalSection( &ApiThreadLock );
            Handle = CreateThread( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)WinStationLpcThread,
                                   NULL,
                                   THREAD_SET_INFORMATION,
                                   &ThreadId );

            if ( !Handle ) {
                RtlEnterCriticalSection( &ApiThreadLock );
                NumApiThreads--;
                RtlLeaveCriticalSection( &ApiThreadLock );
            } else {
               NtClose( Handle );
            }

        } else {
            RtlLeaveCriticalSection( &ApiThreadLock );
        }


        if ( !NT_SUCCESS(Status) ) {
            ReplyMsg = NULL;
            continue;
        }

        try {

            /*
             * Process connection request from a new client
             */
            if ( ApiMsg.h.u2.s2.Type == LPC_CONNECTION_REQUEST ) {
                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStation LPC Service Thread got connection message\n" ));
                // CONNECT_INFO is in ApiMsg from NtReplyWaitReceivePort() when
                // a connection request is received. This differs from
                // NtListenPort() which passes separate pointers for CONNECT_INFO.

                WinStationLpcHandleConnectionRequest( (PPORT_MESSAGE)&ApiMsg );
                ReplyMsg = NULL;
                continue;
            }

            /*
             * Process port closed message
             */
            if ( ApiMsg.h.u2.s2.Type == LPC_PORT_CLOSED ) {
                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStation LPC Service Thread got PORT_CLOSED message pContext %p\n",
                          pContext));
                // NOTE: This function frees the CONTEXT struct
                WinStationLpcClientHasTerminated( pContext );
                ReplyMsg = NULL;
                continue;
            }

            ASSERT(sizeof(WinStationLpcDispatch)/sizeof(WinStationLpcDispatch[0]) == SMWinStationMaxApiNumber);
            ASSERT(sizeof(WinStationLpcName)/sizeof(WinStationLpcName[0]) == SMWinStationMaxApiNumber);

            /*
             * Process API request from client
             */
            ReplyMsg = &ApiMsg;
            if ((ULONG) ApiMsg.ApiNumber >= (ULONG)SMWinStationMaxApiNumber ) {
                DBGPRINT(( "TERMSRV: WinStation LPC Service Thread Bad API number %d\n",
                          ApiMsg.ApiNumber ));
                ApiMsg.ReturnedStatus = STATUS_NOT_IMPLEMENTED;

            } else {
                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStation LPC Service Thread got %s message\n",
                          WinStationLpcName[ApiMsg.ApiNumber] ));
                if ( WinStationLpcDispatch[ApiMsg.ApiNumber] ) {

                    // Save Msg for use by CheckClientAccess
                    NtCurrentTeb()->Win32ThreadInfo = &ApiMsg;

                    // The functions set ApiMsg.ReturnedStatus
                    Status = (WinStationLpcDispatch[ApiMsg.ApiNumber])( pContext, &ApiMsg );

                    // Clear thread Msg pointer
                    NtCurrentTeb()->Win32ThreadInfo = NULL;

                } else {
                    // This API is not implemented in Session Manager
                    ApiMsg.ReturnedStatus = STATUS_NOT_IMPLEMENTED;
                }

                /*
                 * If client does not expect a reply or reply is pending
                 * (will be sent asynchronously), then clear ReplyMsg pointer.
                 */
                if ( !ApiMsg.WaitForReply || Status == STATUS_PENDING )
                    ReplyMsg = NULL;
            }
        } except( WinStationExceptionFilter( L"WinStationLpcThread trapped!!",
                                             GetExceptionInformation() ) ) {
            ReplyMsg = NULL;
        }
    }

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  WinStationLpcHandleConnectionRequest
 *
 *   Handle connection requests and create our local data structures
 *
 * ENTRY:
 *    ConnectionRequest (input)
 *      NT LPC PORT_MESSAGE describing the request
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationLpcHandleConnectionRequest(
    IN PPORT_MESSAGE ConnectionRequest
    )
{
    NTSTATUS st;
    HANDLE CommunicationPort;
    BOOLEAN Accept;
    PWINSTATIONAPI_CONNECT_INFO info;
    REMOTE_PORT_VIEW ClientView;
    REMOTE_PORT_VIEW *pClientView = NULL;
    PORT_VIEW ServerView;
    PORT_VIEW * pServerView = NULL;
    LARGE_INTEGER SectionSize;
    HANDLE PortSection = NULL ;
    PWINSTATION pWinStation;
    PLPC_CLIENT_CONTEXT pContext = NULL;
    ULONG ClientLogonId;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationLpcHandleConnectionRequest called\n" ));

    Accept = TRUE; // Assume we will accept

    // An undocumented NT LPC feature is that the CONNECT_INFO structure
    // follows the PORT_MESSAGE header when the connection request is
    // received through NtReplyWaitReceivePort(), which is useful since we
    // only have to maintain (1) thread for WinStation LPC API's, and
    // do not have to dedicated one to NtListenPort() just for connection
    // requests.

    if ( ConnectionRequest->u1.s1.DataLength != sizeof(WINSTATIONAPI_CONNECT_INFO) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WSTAPI: Bad CONNECTINFO length %d\n",
                   ConnectionRequest->u1.s1.DataLength ));
        Accept = FALSE;
    } else {

        info = (PWINSTATIONAPI_CONNECT_INFO)
                 ((ULONG_PTR)ConnectionRequest + sizeof(PORT_MESSAGE));

        //
        // We can set Accept to FALSE at anytime here for certain types
        // of requests and/or caller identities.
        //
        if ( ConnectionRequest->ClientViewSize == 0 ) {
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WSTAPI: Creating View memory\n" ));

            pServerView = &ServerView;

            // Setup Port memory for larger data transfers

            SectionSize.LowPart = WINSTATIONAPI_PORT_MEMORY_SIZE;
            SectionSize.HighPart = 0;

            st = NtCreateSection(&PortSection, SECTION_ALL_ACCESS, NULL,
                                 &SectionSize, PAGE_READWRITE, SEC_COMMIT, NULL);

            if (!NT_SUCCESS(st)) {
                TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error Creating Section 0x%x\n", st));
                Accept = FALSE;
                info->AcceptStatus = st;
            } else {
                ServerView.Length = sizeof(ServerView);
                ServerView.SectionHandle = PortSection;
                ServerView.SectionOffset = 0;
                ServerView.ViewSize = SectionSize.LowPart;
                ServerView.ViewBase = 0;
                ServerView.ViewRemoteBase = 0;
            }

        }


        if ( Accept ) {
            // Init the REMOTE_VIEW structure
            ClientView.Length = sizeof(ClientView);
            ClientView.ViewSize = 0;
            ClientView.ViewBase = 0;
            pClientView = &ClientView;

            info->AcceptStatus = STATUS_SUCCESS;

            if ( info->Version != CITRIX_WINSTATIONAPI_VERSION ) {
                info->AcceptStatus = 1; // Fill in bad version param code
                TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: WSTAPI: Bad Version %d\n", info->Version));
                Accept = FALSE;
            }

            // Add checks for info.RequestedAccess against the requesting
            // threads security rights for WinStation access. Use the Se* stuff
            // to do the checking and audit generation

            // On Security Access failure:
            // Accept = FALSE;
            // info->AcceptStatus = NT invalid rights message
        }

    }

    //
    // Get the ClientLogonId
    //
    if ( Accept ) {
        HANDLE ClientProcessHandle;
        OBJECT_ATTRIBUTES ObjA;

        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        st = NtOpenProcess( &ClientProcessHandle, GENERIC_READ,
                            &ObjA, &ConnectionRequest->ClientId );

        if (NT_SUCCESS(st)) {
            GetProcessLogonId( ClientProcessHandle, &ClientLogonId );
            NtClose( ClientProcessHandle );
        } else {
            Accept = FALSE;
            info->AcceptStatus = st;
        }
    }

    //
    // Allocate a context connection control block.
    // The address of this block is used as the
    // port context in all calls from a client process
    //

    if ( Accept ) {
        pContext = MemAlloc( sizeof(LPC_CLIENT_CONTEXT) );
        if ( pContext ) {
            pContext->CommunicationPort = NULL;
            pContext->AccessRights = info->RequestedAccess;
        } else {
            Accept = FALSE;
            info->AcceptStatus = STATUS_NO_MEMORY;
        }
    }

    // More undocumented NT. Many parameters are missing here and in ntlpcapi.h
    // from the documentation. The CONNECTION_INFO message is part
    // of the message body following PORT_MESSAGE, just like
    // NtReplyWaitReceivePort().

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: WSTAPI: Calling AcceptConnectPort, Accept %d\n", Accept));
    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: pContext %p, ConnectionRequest %p, info %p\n",
              pContext, ConnectionRequest, info));

    if (!Accept) {
        pClientView = NULL;
        pServerView = NULL;
    }

    st = NtAcceptConnectPort(
            &CommunicationPort,
            (PVOID)pContext,
            ConnectionRequest,
            Accept,
            pServerView,
            pClientView
            );

    if (!NT_SUCCESS(st)) {
       if (PortSection != NULL) {
          NtClose(PortSection);
       }
       if (pContext != NULL) {
          MemFree( pContext );
       }
       return st;
    }

    // Close the PortSection (LPC will hold the reference now)
    if ( pServerView )
        NtClose(PortSection);

    // Insert the context before completing the connect because as soon
    // as the complete is done, the client thread can send a request and 
    // if this request is serviced by another LPC thread then the context
    // won't be found (WinStationBrokenConnection case, by instance).
    InsertLpcContext(pContext);

    if ( Accept ) {

       pContext->ClientViewBase = ClientView.ViewBase;
       pContext->ClientViewBounds = (PVOID)((ULONG_PTR)ClientView.ViewBase + ClientView.ViewSize);
       if ( pServerView ) {
           pContext->ViewBase = ServerView.ViewBase;
           pContext->ViewSize = ServerView.ViewSize;
           pContext->ViewRemoteBase = ServerView.ViewRemoteBase;
           TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: ViewBase %p, ViewSize 0x%x, ViewRemoteBase %p\n",
             pContext->ViewBase, pContext->ViewSize, pContext->ViewRemoteBase));
       } else {
           pContext->ViewBase = NULL;
           pContext->ViewSize = 0;
           pContext->ViewRemoteBase = NULL;
       }

       pContext->ClientLogonId = ClientLogonId;

       TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: WSTAPI: Calling CompleteConnect port %p\n",CommunicationPort));
       pContext->CommunicationPort = CommunicationPort;
       st = NtCompleteConnectPort(CommunicationPort);

    }

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: WinStation LPC Connection %sAccepted, Logonid %d pContext %p Status 0x%x\n",
              (Accept?"":"Not "), pContext->ClientLogonId, pContext, st));

    return( st );
}


/*****************************************************************************
 *
 *  WinStationLpcClientHasTerminated
 *
 *   Cleanup after an LPC communications channel has been closed.
 *
 * ENTRY:
 *    pContext (input)
 *       Pointer to our context structure describing the connnection
 *
 *    ClientId (input)
 *       Pointer to the NT LPC CLIENT_ID structure that describes the
 *       unique process and thread.
 *
 * EXIT:
 *   VOID
 *
 ****************************************************************************/

VOID
WinStationLpcClientHasTerminated(
    IN PLPC_CLIENT_CONTEXT pContext
    )
{
    PWINSTATION pWinStation;
    NTSTATUS Status;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationLpcClientHasTerminated called, pContext %p\n",
              pContext));

    //
    //  We can be called here with a NULL pContext if the allocation failed
    //  in WinStationLpcHandleConnectionRequest()
    //
    if (!pContext) {
        return;
    }

    RemoveLpcContext(pContext);

    // Hack for #241885
    // This bug is due to client diying in the window beetween
    // server doing NtAcceptConnectPort() and  NtCompleteConnectPort().
    // This is an  LPC problem (we should not reveive LPC_PORT_CLOSED in such a window).
    // or possibly to the way termsrv uses undocumented LPC features to avoid
    // using a dedicated thread to do NtListenPort(). This is a temporary workaround
    // to avoid stress break.
    //
    // Close the communication port handle

   try {
     if (pContext->CommunicationPort == NULL) {
        return;
     }
     Status = NtClose( pContext->CommunicationPort );
     if (!NT_SUCCESS(Status)) {
        return;

     }
   } except( EXCEPTION_EXECUTE_HANDLER ) {
     return;

   }


    /*
     * Flush the Win32 command queue.
     * If the Win32 command list is not empty, then loop through each
     * entry on the list and unlink it and trigger the wait event.
     */
    pWinStation = FindWinStationById( pContext->ClientLogonId, FALSE );
    if ( pWinStation != NULL ) {
        if ( pContext == pWinStation->pWin32Context ) {
            while ( !IsListEmpty( &pWinStation->Win32CommandHead ) ) {
                PLIST_ENTRY Head;
                PCOMMAND_ENTRY pCommand;

                Head = pWinStation->Win32CommandHead.Flink;
                pCommand = CONTAINING_RECORD( Head, COMMAND_ENTRY, Links );
                RemoveEntryList( &pCommand->Links );
                if ( !pCommand->pMsg->WaitForReply ) {
                    ASSERT( pCommand->Event == NULL );
                    MemFree( pCommand );
                } else {
                    pCommand->Links.Flink = NULL;
                    pCommand->pMsg->ReturnedStatus = STATUS_CTX_CLOSE_PENDING;
                    NtSetEvent( pCommand->Event, NULL );
                }
            }
            pWinStation->pWin32Context = NULL;
        }
        ReleaseWinStation( pWinStation );
    }

    // Free the context struct passed in by the LPC
    MemFree( pContext );
}


/*****************************************************************************
 *
 *  WinStationInternalCreate
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInternalCreate( PLPC_CLIENT_CONTEXT pContext,
                          PWINSTATION_APIMSG pMsg )
{
    WINSTATIONCREATEMSG *m = &pMsg->u.Create;

    /*
     * Call the create worker
     */
    if ( m->WinStationName[0] ) {
        pMsg->ReturnedStatus = WinStationCreateWorker( m->WinStationName,
                                                       &m->LogonId );
    } else {
        pMsg->ReturnedStatus = WinStationCreateWorker( NULL,
                                                       &m->LogonId );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCreate, Status=0x%x\n", pMsg->ReturnedStatus ));

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  WinStationInternalReset
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInternalReset( PLPC_CLIENT_CONTEXT pContext,
                         PWINSTATION_APIMSG pMsg )
{
    WINSTATIONRESETMSG *m = &pMsg->u.Reset;

    /*
     * Call the reset worker
     */
    pMsg->ReturnedStatus = WinStationResetWorker( m->LogonId, FALSE, FALSE, TRUE );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationReset, Status=0x%x\n", pMsg->ReturnedStatus ));

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  WinStationInternalDisconnect
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInternalDisconnect( PLPC_CLIENT_CONTEXT pContext,
                              PWINSTATION_APIMSG pMsg )
{
    WINSTATIONDISCONNECTMSG *m = &pMsg->u.Disconnect;

    /*
     * Call the disconnect worker
     */
    pMsg->ReturnedStatus = WinStationDisconnectWorker( m->LogonId, FALSE, FALSE );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationDisconnect, Status=0x%x\n", pMsg->ReturnedStatus ));

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  WinStationWCharLog
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationWCharLog( PLPC_CLIENT_CONTEXT pContext,
                              PWINSTATION_APIMSG pMsg )
{
    extern WCHAR gpszServiceName[];
    WINSTATIONWCHARLOG *m= &pMsg->u.WCharLog;
    PWCHAR ModulePath = m->Buffer;
    HANDLE h;

    h = RegisterEventSource(NULL, gpszServiceName);
    if (h != NULL)
       {
       ReportEvent(h, EVENTLOG_ERROR_TYPE, 0, EVENT_STACK_LOAD_FAILED, NULL, 1, 0, &ModulePath, NULL);
       DeregisterEventSource(h);
       }

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  WinStationGetSMCommand
 *
 *   This is the API that the Winstations call in order to get
 *   work to do. We send Winstations commands from SendWinStationCommand()
 *   once they have called this API.
 *
 *   NOTE: Only WinStations may call this command!
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationGetSMCommand( PLPC_CLIENT_CONTEXT pContext,
                        PWINSTATION_APIMSG pMsg )
{
    PLIST_ENTRY Head;
    PWINSTATION pWinStation;
    PCOMMAND_ENTRY pCommand;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand, LogonId=%d\n",
              pContext->ClientLogonId ));

    /*
     * Find and lock client WinStation
     */

    pWinStation = FindWinStationById( pContext->ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand LogonId=%d not found\n",
                   pContext->ClientLogonId ));
        return( STATUS_SUCCESS );
    }

    /*
     * Ensure this is the Win32 subsystem calling
     */
    if ( pWinStation->WindowsSubSysProcessId &&
         pMsg->h.ClientId.UniqueProcess != pWinStation->WindowsSubSysProcessId ) {
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand LogonId=%d wrong process id %d != %d\n",
                   pContext->ClientLogonId,
                   pMsg->h.ClientId.UniqueProcess,
                   pWinStation->WindowsSubSysProcessId ));
#if DBG
        DbgBreakPoint();
#endif
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * If the LPC context pointer has not been saved yet, do it now
     */
    if ( pWinStation->pWin32Context == NULL )
        pWinStation->pWin32Context = pContext;

    /*
     * If this message is a reply to a previous Win32 command,
     * then verify the reply is for the message on the head of the
     * Win32 command queue and complete the command processing.
     */
    if ( pMsg->WaitForReply ) {

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand wait for reply\n"));

        if ( !IsListEmpty( &pWinStation->Win32CommandHead ) ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand list entry\n"));

            Head = pWinStation->Win32CommandHead.Flink;
            pCommand = CONTAINING_RECORD( Head, COMMAND_ENTRY, Links );
            if ( pCommand->pMsg->MessageId == pMsg->MessageId ) {
                WINSTATION_APINUMBER ApiNumber;

                /*
                 * Copy reply msg back to command entry
                 * (make sure we preserve original API number)
                 */
                ApiNumber = pCommand->pMsg->ApiNumber;
                *pCommand->pMsg = *pMsg;
                pCommand->pMsg->ApiNumber = ApiNumber;

                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand, LogonId=%d, Reply for Cmd %s, Status=0x%x\n",
                          pContext->ClientLogonId,
                          WinStationLpcName[pCommand->pMsg->ApiNumber],
                          pMsg->ReturnedStatus ));

                /*
                 * Unlink this command entry and
                 * trigger event to wakeup the waiter.
                 */
                RemoveEntryList( &pCommand->Links );
                pCommand->Links.Flink = NULL;
                NtSetEvent( pCommand->Event, NULL );
            }
            else {
                DBGPRINT(("TERMSRV: WinStationGetSMCommand, no cmd entry for MessageId 0x%x\n", pMsg->MessageId ));
            }
        }
        else {
            DBGPRINT(( "TERMSRV: WinStationGetSMCommand, cmd queue empty for MessageId 0x%x\n", pMsg->MessageId ));
        }
    }

    /*
     * If the head of the Win32 command queue is non-empty,
     * then send the first command in the queue to Win32.
     */
    if ( !IsListEmpty( &pWinStation->Win32CommandHead ) ) {

        Head = pWinStation->Win32CommandHead.Flink;
        pCommand = CONTAINING_RECORD( Head, COMMAND_ENTRY, Links );

        /*
         * Send the msg contained in the command entry, but be sure to use
         * the LPC PORT_MESSAGE fields from the original msg we received
         * since we are sending the command as an LPC reply message.
         */
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand, LogonId=%d, sending next cmd\n",
                  pWinStation->LogonId ));

#ifdef notdef // no longer needed - but good example of using view memory
        /*
         * Do connect needs to copy data to the view
         */
        if ( pCommand->pMsg->ApiNumber == SMWinStationDoConnect ) {

             pCommand->pMsg->u.DoConnect.VDInfoLength =
                   min ( pCommand->pMsg->u.DoConnect.VDInfoLength,
                         pContext->ViewSize );

             TRACE((hTrace,TC_ICASRV,TT_API1, "SMSS: WinStationGetSMCommand, Copying VD Info data %d\n", pCommand->pMsg->u.DoConnect.VDInfoLength ));
             RtlCopyMemory( pContext->ViewBase,
                            pCommand->pMsg->u.DoConnect.VDInfo,
                            pCommand->pMsg->u.DoConnect.VDInfoLength );
                            pCommand->pMsg->u.DoConnect.VDInfo = pContext->ViewRemoteBase;
        }
#endif

        /*
         * On DoMessage API copy to client view and free temp memory
         */
        if ( pCommand->pMsg->ApiNumber == SMWinStationDoMessage ) {

            PVOID pTitle;
            PVOID pMessage;

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: pulled SMWinStationDoMessage, copy to client view\n" ));

            // Get pointers to client view of memory

            pTitle = pContext->ViewBase;
            pMessage = (PVOID)((ULONG_PTR)pTitle + pCommand->pMsg->u.SendMessage.TitleLength);

            // Copy out the pTitle and pMessage strings to client view

            RtlMoveMemory( pTitle, pCommand->pMsg->u.SendMessage.pTitle,
                                   pCommand->pMsg->u.SendMessage.TitleLength );
            RtlMoveMemory( pMessage, pCommand->pMsg->u.SendMessage.pMessage,
                                   pCommand->pMsg->u.SendMessage.MessageLength );

            MemFree( pCommand->pMsg->u.SendMessage.pTitle );
            MemFree( pCommand->pMsg->u.SendMessage.pMessage );

            pCommand->pMsg->u.SendMessage.pTitle   =
                          (PVOID)(pContext->ViewRemoteBase);
            pCommand->pMsg->u.SendMessage.pMessage =
                          (PVOID) ((ULONG_PTR)pContext->ViewRemoteBase + pCommand->pMsg->u.SendMessage.TitleLength);

        } else if ( pCommand->pMsg->ApiNumber == SMWinStationShadowStart ||
                    pCommand->pMsg->ApiNumber == SMWinStationShadowCleanup ) {

            PVOID pData;

            // Get pointers to client view of memory

            pData = pContext->ViewBase;

            // Copy out the Thinwire data to client view

            RtlMoveMemory( pData, pCommand->pMsg->u.ShadowStart.pThinwireData,
                           pCommand->pMsg->u.ShadowStart.ThinwireDataLength );

            MemFree( pCommand->pMsg->u.ShadowStart.pThinwireData );

            pCommand->pMsg->u.ShadowStart.pThinwireData =
                          (PVOID)(pContext->ViewRemoteBase);

        } else if ( pCommand->pMsg->ApiNumber == SMWinStationSendWindowMessage) {
             
            PVOID               pView;

            // Get pointers to client view of memory
            pView = pContext->ViewBase;

            RtlMoveMemory( pView, pCommand->pMsg->u.sMsg.dataBuffer, 
                                    pCommand->pMsg->u.sMsg.bufferSize );
                                    
            MemFree( pCommand->pMsg->u.sMsg.dataBuffer );

            // Update msg
            pCommand->pMsg->u.sMsg.dataBuffer   = 
                            (PVOID)pContext->ViewRemoteBase;
            
        
        } else if ( pCommand->pMsg->ApiNumber == SMWinStationBroadcastSystemMessage) {
            
            PVOID               pView;
            
            // Get pointers to client view of memory
            pView = pContext->ViewBase;

            RtlMoveMemory( pView, pCommand->pMsg->u.bMsg.dataBuffer, 
                                    pCommand->pMsg->u.bMsg.bufferSize );
            
            MemFree( pCommand->pMsg->u.bMsg.dataBuffer );
            
            // Update msg
            pCommand->pMsg->u.bMsg.dataBuffer   = 
                            (PVOID)pContext->ViewRemoteBase;
        
        }

        pCommand->pMsg->h = pMsg->h;
        NtReplyPort( pContext->CommunicationPort,
                     (PPORT_MESSAGE)pCommand->pMsg );

        /*
         * If no reply is expected, then unlink/free this command entry.
         */
        if ( !pCommand->pMsg->WaitForReply ) {
            RemoveEntryList( &pCommand->Links );
            ASSERT( pCommand->Event == NULL );
            MemFree( pCommand );
        }

    /*
     * The Win32 command queue is empty.  Save the port handle and port
     * message in the WinStation.  The next time a command is to be
     * sent to this WinStation, these will be used to send it.
     */
    } else {
        ASSERT( pWinStation->Win32CommandPort == NULL );
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand queue empty port %p\n",
                    pContext->CommunicationPort));
        pWinStation->Win32CommandPort = pContext->CommunicationPort;
        pWinStation->Win32CommandPortMsg = pMsg->h;
    }

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );

    /*
     * We ALWAYS return STATUS_PENDING so the msg dispatch routine
     * does not send a reply message now.  ALL replies to this message
     * are handled above or in the SendWinStationCommand() routine.
     */
    return( STATUS_PENDING );
}


/*****************************************************************************
 *
 *  WinStationBrokenConnection
 *
 *   API called from Winstation requesting a broken connection
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationBrokenConnection( PLPC_CLIENT_CONTEXT pContext,
                            PWINSTATION_APIMSG pMsg )
{
    WINSTATIONBROKENCONNECTIONMSG *m = &pMsg->u.Broken;
    BROKENCLASS Reason = (BROKENCLASS) m->Reason;
    PWINSTATION pWinStation;
    ULONG SessionId;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationBrokenConnection, LogonId=%d, Reason=%u\n",
               pContext->ClientLogonId, Reason ));

    /*
     * Indicate A reply will be returned to client
     */
    pMsg->WaitForReply = TRUE;


    /*
     * Make sure the context is still active and get session Id from it.
     */


    if (!GetSessionIdFromLpcContext(pContext, &SessionId)) {
        return STATUS_SUCCESS;
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( SessionId, FALSE );
    if ( pWinStation == NULL )
        return( STATUS_SUCCESS );

    /*
     * Ensure this is the Win32 subsystem calling
     */
    if ( pWinStation->WindowsSubSysProcessId &&
         pMsg->h.ClientId.UniqueProcess != pWinStation->WindowsSubSysProcessId ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * If WinStation is already disconnected, then we're done
     */
    if ( !pWinStation->WinStationName[0] )  {
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * If busy with something already, don't do this
     */
    if ( pWinStation->Flags ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_CTX_WINSTATION_BUSY );
    }

    /*
     * Save reason/source for this broken connection
     */
    pWinStation->BrokenReason = Reason;
    pWinStation->BrokenSource = m->Source;

    if ( pWinStation->NeverConnected ) {
        pWinStation->StateFlags |= WSF_ST_BROKEN_CONNECTION;
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }


    /*
     * if any of the following is TRUE;
     *  - the session is a Salem 'help assistant' session.
     *  - no user is logged on (logon time is 0)
     *  - reset is requested
     *  - unexpected broken connection and current user is
     *    setup to reset on broken connection
     * then queue a reset request
     */
    if (RtlLargeIntegerEqualToZero( pWinStation->LogonTime ) ||
        (Reason == Broken_Terminate) ||
         ((Reason == Broken_Unexpected) && pWinStation->Config.Config.User.fResetBroken) ||
         TSIsSessionHelpSession(pWinStation, NULL)) {
         
        QueueWinStationReset( pWinStation->LogonId);

    /*
     * Otherwise, disconnect the WinStation
     */
    } else {
    
        QueueWinStationDisconnect( pWinStation->LogonId );
    }

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  WinStationIcaReplyMessage
 *
 *   API called from Winstation for user response to message box
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationIcaReplyMessage( PLPC_CLIENT_CONTEXT pContext,
                           PWINSTATION_APIMSG pMsg )
{
    PWINSTATION pWinStation;

    DBGPRINT(("TERMSRV: WinStationIcaReplyMessage, LogonId=%d\n",
               pContext->ClientLogonId ));

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationIcaReplyMessage, LogonId=%d\n",
               pContext->ClientLogonId ));

    /*
     * Indicate A reply will be returned to client
     */
    pMsg->WaitForReply = TRUE;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( pContext->ClientLogonId, FALSE );
    if ( pWinStation == NULL )
        return( STATUS_SUCCESS );

    /*
     * Ensure this is the Win32 subsystem calling
     */
    if ( pWinStation->WindowsSubSysProcessId &&
         pMsg->h.ClientId.UniqueProcess != pWinStation->WindowsSubSysProcessId ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * Fill in response
     */
    *pMsg->u.ReplyMessage.pResponse = pMsg->u.ReplyMessage.Response;

    /*
     * Release RPC thread
     */
    NtSetEvent( pMsg->u.ReplyMessage.hEvent, NULL );

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  WinStationIcaShadowHotkey
 *
 *   API called from Winstation that has received a shadow hotkey
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationIcaShadowHotkey( PLPC_CLIENT_CONTEXT pContext,
                           PWINSTATION_APIMSG pMsg )
{
    PWINSTATION pWinStation;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationIcaShadowHotkey, LogonId=%d\n",
               pContext->ClientLogonId ));

    /*
     * Indicate A reply will be returned to client
     */
    pMsg->WaitForReply = TRUE;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( pContext->ClientLogonId, FALSE );
    if ( pWinStation == NULL )
        return( STATUS_SUCCESS );

    /*
     * Ensure this is the Win32 subsystem calling
     */
    if ( pWinStation->WindowsSubSysProcessId &&
         pMsg->h.ClientId.UniqueProcess != pWinStation->WindowsSubSysProcessId ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * Process the shadow hotkey.
     *
     * If the shadow client is still waiting for the target
     * to connect, then terminate the passthru stack now to break
     * out of the connection wait.  Also, set the shadow
     * broken event if it is non-NULL.
     */
    if ( pWinStation->hPassthruStack &&
         pWinStation->ShadowConnectionWait ) {
        IcaStackClose( pWinStation->hPassthruStack );
        pWinStation->hPassthruStack = NULL;
    }
    if ( pWinStation->ShadowBrokenEvent ) {
        NtSetEvent( pWinStation->ShadowBrokenEvent, NULL );
    }

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  SendWinStationCommand
 *
 *   Send a command to a WinStation and optionally wait for a reply.
 *
 *   NOTE: This works using a reverse LPC in which the WINSTATION must
 *         have sent a "request" to us for work to do. This prevents
 *         blocking the ICASRV while waiting on a WINSTATION that
 *         could be hung.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to send command to
 *    pMsg (input/output)
 *       Pointer to message to send
 *    WaitTime (input)
 *       Time in seconds to wait for a reply message
 *
 * EXIT:
 *    STATUS_SUCCESS - if successful
 *
 ******************************************************************************/

NTSTATUS
SendWinStationCommand( PWINSTATION pWinStation,
                       PWINSTATION_APIMSG pMsg,
                       ULONG WaitTime )
{
    OBJECT_ATTRIBUTES ObjA;
    COMMAND_ENTRY Command;
    PCOMMAND_ENTRY pCommand;
    NTSTATUS Status;
    BOOLEAN bFreeCommand = FALSE;
    BOOLEAN bTitlenMessageAllocated = FALSE;
    
    //
    // These are only used by the SendWindowMessage and the
    // BroadcastSystemMessage APIs.
    //
    PVOID   pdataBuffer;
    

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand, LogonId=%d, Cmd=%s, Timeout=%d\n",
              pWinStation->LogonId,
              WinStationLpcName[pMsg->ApiNumber],
              WaitTime ));

    ASSERT( IsWinStationLockedByCaller( pWinStation ) );
    ASSERT( !(pWinStation->Flags & WSF_LISTEN) );

    /*
     * Initialize the message id for this message
     */
    pMsg->MessageId = InterlockedIncrement(&MessageId);
    pMsg->ReturnedStatus = 0;
    pMsg->WaitForReply = (WaitTime != 0) ? TRUE : FALSE;

    /*
     * If we will wait for a reply, then create an event to wait on.
     * Since we will wait for a response, its OK to use the static
     * COMMAND entry above.
     */
    if ( pMsg->WaitForReply ) {
        pCommand = &Command;
        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        Status = NtCreateEvent( &pCommand->Event, EVENT_ALL_ACCESS, &ObjA,
                                NotificationEvent, FALSE );
        if ( !NT_SUCCESS(Status) )
            return( Status );
        pCommand->pMsg = pMsg;

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand pCommand %p pCommand->pMsg %p\n", pCommand, pCommand->pMsg ));


    /*
     * We will not wait for a reply, but the WinStation is currently busy
     * processing a command.  Allocate a dynamic COMMAND entry which will
     * be linked into the the command list and sent when it reaches the
     * head of the list.
     */
    } else if ( pWinStation->Win32CommandPort == NULL ) {
        pCommand = MemAlloc( sizeof(*pCommand) + sizeof(*pMsg) );

        /* makarp; check for MemAlloc failures. #182622 */
        if (!pCommand) {
            return (STATUS_NO_MEMORY);
        }
        pCommand->Event = NULL;
        pCommand->pMsg = (PWINSTATION_APIMSG)(pCommand + 1);
        *pCommand->pMsg = *pMsg;
        Status = STATUS_SUCCESS;

    /*
     * We will not wait for a reply and the WinStation is NOT busy
     * with a command, so there is no need for a COMMAND entry.
     * The current message will be sent below.
     */
    } else {
        pCommand = NULL;
    }

    /*
     * On DoMessage API either copy message to client view or strdup strings.
     */
    if ( pMsg->ApiNumber == SMWinStationDoMessage ) {

        PVOID pTitle;
        PVOID pMessage;
        PLPC_CLIENT_CONTEXT pContext;

        // get winstation context
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            bFreeCommand = TRUE;
            goto done;
        }

        // validate size of parameters
        if ((pMsg->u.SendMessage.TitleLength + pMsg->u.SendMessage.MessageLength) > pContext->ViewSize ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR Message or Title too long\n" ));
            Status = STATUS_INVALID_PARAMETER;
            bFreeCommand = TRUE;
            goto done;
        }

        //  busy? then strdup string else copy to client view
        if ( pWinStation->Win32CommandPort ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC IDLE, process now\n" ));

            // Get pointers to client view of memory
            pTitle = pContext->ViewBase;
            pMessage = (PVOID)((ULONG_PTR)pTitle + pMsg->u.SendMessage.TitleLength);

            // Copy out the pTitle and pMessage strings to client view
            RtlMoveMemory( pTitle, pMsg->u.SendMessage.pTitle, pMsg->u.SendMessage.TitleLength );
            RtlMoveMemory( pMessage, pMsg->u.SendMessage.pMessage, pMsg->u.SendMessage.MessageLength );

            // Update msg
            pMsg->u.SendMessage.pTitle   =
                          (PVOID)(pContext->ViewRemoteBase);
            pMsg->u.SendMessage.pMessage =
                          (PVOID) ((ULONG_PTR)pContext->ViewRemoteBase + pMsg->u.SendMessage.TitleLength);
        }
        else if ( pCommand )  {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC BUSY, queue for later processing\n" ));

            // Get pointers to temporary memory
            pTitle = MemAlloc( pMsg->u.SendMessage.TitleLength );
            if (pTitle == NULL) {
                Status = STATUS_NO_MEMORY;
                bFreeCommand = TRUE;
                goto done;
            }
            pMessage = MemAlloc( pMsg->u.SendMessage.MessageLength );
            if (pMessage == NULL) {
                Status = STATUS_NO_MEMORY;
                MemFree( pTitle );
                bFreeCommand = TRUE;
                goto done;
            }

            bTitlenMessageAllocated = TRUE;

            // Copy out the pTitle and pMessage strings to temp memory
            RtlMoveMemory( pTitle, pMsg->u.SendMessage.pTitle, pMsg->u.SendMessage.TitleLength );
            RtlMoveMemory( pMessage, pMsg->u.SendMessage.pMessage, pMsg->u.SendMessage.MessageLength );

            // Update msg
            pCommand->pMsg->u.SendMessage.pTitle = pTitle;
            pCommand->pMsg->u.SendMessage.pMessage = pMessage;
        }

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SMWinStationDoMessage pTitle   %S\n", pTitle ));
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SMWinStationDoMessage pMessage %S\n", pMessage ));

    } else if ( pMsg->ApiNumber == SMWinStationShadowStart ||
                pMsg->ApiNumber == SMWinStationShadowCleanup ) {

        PVOID pData;
        PLPC_CLIENT_CONTEXT pContext;

        // get winstation contect
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            bFreeCommand = TRUE;
            goto done;
        }

        //  busy? then strdup string else copy to client view
        if ( pWinStation->Win32CommandPort ) {

            // Get pointers to client view of memory
            pData = pContext->ViewBase;

            // Copy out the ThinwireData to client view
            RtlCopyMemory( pData, pMsg->u.ShadowStart.pThinwireData,
                           pMsg->u.ShadowStart.ThinwireDataLength );

            // Update msg
            pMsg->u.ShadowStart.pThinwireData =
                          (PVOID) (pContext->ViewRemoteBase);
        }
        else if ( pCommand )  {

            // Get pointers to temporary memory
            pData = MemAlloc( pMsg->u.ShadowStart.ThinwireDataLength );
            if (pData == NULL) {
                Status = STATUS_NO_MEMORY;
                bFreeCommand = TRUE;
                goto done;
            }

            // Copy out the ThinwireData to temp memory
            RtlCopyMemory( pData, pMsg->u.ShadowStart.pThinwireData,
                           pMsg->u.ShadowStart.ThinwireDataLength );

            // Update msg
            pCommand->pMsg->u.ShadowStart.pThinwireData = pData;
        }
    }
    else if ( pMsg->ApiNumber == SMWinStationSendWindowMessage )// This msg always has WaitForReply=TRUE
    {
        PLPC_CLIENT_CONTEXT pContext;
        PVOID   pView;
        
         // get winstation context
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            // @@@
            // Do i need this? : bFreeCommand = TRUE;
            // Since we are waiting for a reply, then we have not allocated memory for pCommand,
            // hence, we don't need to set this flag.
            goto done;
        }

        // validate size of parameters
        if ((pMsg->u.sMsg.bufferSize ) > pContext->ViewSize ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR Message or Title too long\n" ));
            Status = STATUS_INVALID_PARAMETER;
            // @@@
            // Do i need this? : bFreeCommand = TRUE;
            // Since we are waiting for a reply, then we have not allocated memory for pCommand,
            // hence, we don't need to set this flag.
            goto done;
        }

        //  if not busy? then copy to client view
        if ( pWinStation->Win32CommandPort ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC IDLE, process now\n" ));

            // Get pointers to client view of memory
            pView = pContext->ViewBase;

            RtlMoveMemory( pView, pMsg->u.sMsg.dataBuffer, pMsg->u.sMsg.bufferSize );

            // Update msg
            pMsg->u.sMsg.dataBuffer   = (PVOID)pContext->ViewRemoteBase;
            
        }
        else if ( pCommand )    // this is on the stack, since this msg always has WaitForReply=TRUE
        {
            pdataBuffer = MemAlloc(pMsg->u.sMsg.bufferSize );
            if ( pdataBuffer == NULL )
            {
                Status = STATUS_NO_MEMORY;
                goto done;
            }
            
            // copy into tmp memory
            RtlMoveMemory(pdataBuffer, pMsg->u.sMsg.dataBuffer, pMsg->u.sMsg.bufferSize );
            
            pCommand->pMsg->u.sMsg.dataBuffer = pdataBuffer;
        }
            
    }
    else if ( pMsg->ApiNumber == SMWinStationBroadcastSystemMessage )// this msg always has WaitForReply=TRUE
    {
        PLPC_CLIENT_CONTEXT pContext;
        PVOID   pView;
        
         // get winstation context
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            // @@@
            // Do i need this? : bFreeCommand = TRUE;
            // Since we are waiting for a reply, then we have not allocated memory for pCommand,
            // hence, we don't need to set this flag.
            goto done;
        }

        // validate size of parameters
        if ((pMsg->u.bMsg.bufferSize ) > pContext->ViewSize ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR Message or Title too long\n" ));
            Status = STATUS_INVALID_PARAMETER;
            // @@@
            // Do i need this? : bFreeCommand = TRUE;
            // Since we are waiting for a reply, then we have not allocated memory for pCommand,
            // hence, we don't need to set this flag.
            goto done;
        }

        //  if not busy? then copy to client view
        if ( pWinStation->Win32CommandPort ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC IDLE, process now\n" ));

            // Get pointers to client view of memory
            pView = pContext->ViewBase;

            RtlMoveMemory( pView, pMsg->u.bMsg.dataBuffer, pMsg->u.bMsg.bufferSize );

            // Update msg
            pMsg->u.bMsg.dataBuffer   = (PVOID)pContext->ViewRemoteBase;
            
        }
        else if ( pCommand )    // this is on the stack, since this msg always has WaitForReply=TRUE
        {
            pdataBuffer = MemAlloc(pMsg->u.bMsg.bufferSize );
            if ( pdataBuffer == NULL )
            {
                Status = STATUS_NO_MEMORY;
                goto done;
            }
            
            // copy into tmp memory
            RtlMoveMemory(pdataBuffer, pMsg->u.bMsg.dataBuffer, pMsg->u.bMsg.bufferSize );
            
            pCommand->pMsg->u.bMsg.dataBuffer = pdataBuffer;
        }
    }

    /*
     * If the WinStation is not currently busy processing a command,
     * then send this command now.
     */
    if ( pWinStation->Win32CommandPort ) {
        ASSERT( IsListEmpty( &pWinStation->Win32CommandHead ) );

        /*
         * Send the command msg, but be sure to use the LPC PORT_MESSAGE
         * fields saved from the original msg we received since we are
         * sending the command as an LPC reply message.
         */
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand, LogonId=%d, sending cmd\n",
                  pWinStation->LogonId ));

        pMsg->h = pWinStation->Win32CommandPortMsg;
        Status = NtReplyPort( pWinStation->Win32CommandPort,
                              (PPORT_MESSAGE) pMsg );
        pWinStation->Win32CommandPort = NULL;
        if ( !NT_SUCCESS( Status ) )
            goto done;
    }

    /*
     * If we have a command entry, add it to the command list.
     */
    if ( pCommand )
        InsertTailList( &pWinStation->Win32CommandHead, &pCommand->Links );

    /*
     * If we need to wait for a reply, then do it now.
     */
    if ( pMsg->WaitForReply ) {
        ULONG mSecs;
        LARGE_INTEGER Timeout;

#if DBG
//        if ( (WaitTime != (ULONG)(-1)) && WaitTime < 120 ) // give plenty of time on debug builds
//            WaitTime = 120; 
#endif
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand, LogonId=%d, waiting for response\n",
                  pWinStation->LogonId ));

        if ( WaitTime != (ULONG)(-1) ) {
            mSecs = WaitTime * 1000;
            Timeout = RtlEnlargedIntegerMultiply( mSecs, -10000 );
        }
        UnlockWinStation( pWinStation );
        if ( WaitTime != (ULONG)(-1) ) {

            Status = NtWaitForSingleObject( pCommand->Event, FALSE, &Timeout );

        }
        else {
            DBGPRINT(("Waiting for command with no timeout\n"));
            Status = NtWaitForSingleObject( pCommand->Event, FALSE, NULL );
        }

        if ( !RelockWinStation( pWinStation ) )
            Status = STATUS_CTX_CLOSE_PENDING;


        if ( pCommand->Links.Flink != NULL )
            RemoveEntryList( &pCommand->Links );
        if ( Status == STATUS_SUCCESS )
            Status = pMsg->ReturnedStatus;
        else if ( Status == STATUS_TIMEOUT )
            Status = STATUS_CTX_WINSTATION_BUSY;
    }

done:
    if ( pCommand ) {
        if ( pCommand->Event ) {
            NtClose( pCommand->Event );
        }

        if ( !pMsg->WaitForReply && bFreeCommand ) {

            // makarp:182622
            if (bTitlenMessageAllocated)
            {
                ASSERT(pCommand->pMsg->u.SendMessage.pTitle);
                ASSERT(pCommand->pMsg->u.SendMessage.pMessage);

                MemFree(pCommand->pMsg->u.SendMessage.pTitle);
                MemFree(pCommand->pMsg->u.SendMessage.pMessage);
            }

            MemFree( pCommand );

        }
        
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand, LogonId=%d, Cmd=%s, Status=0x%x\n",
              pWinStation->LogonId,
              WinStationLpcName[pMsg->ApiNumber],
              Status ));

    return( Status );
}

NTSTATUS RemoveBadHwnd(ULONG hWnd, ULONG SessionId);

NTSTATUS
WinStationWindowInvalid( PLPC_CLIENT_CONTEXT pContext,
                         PWINSTATION_APIMSG pMsg )
{
    ASSERT(pMsg);
    ASSERT(pMsg->ApiNumber == SMWinStationWindowInvalid);
    ASSERT(pMsg->u.WindowInvalid.hWnd);

    UNREFERENCED_PARAMETER(pContext);
    
    return RemoveBadHwnd(pMsg->u.WindowInvalid.hWnd, pMsg->u.WindowInvalid.SessionId);
}

VOID InsertLpcContext(PVOID pContext)
{
    PTERMSRVLPCCONTEXT pLpcContextEntry = MemAlloc(sizeof(TERMSRVLPCCONTEXT)); 
    if (pLpcContextEntry != NULL) {
        pLpcContextEntry->pContext = pContext;
        RtlEnterCriticalSection( &ApiThreadLock );
        InsertTailList( &gTermsrvLpcListHead, &pLpcContextEntry->Links );
        RtlLeaveCriticalSection( &ApiThreadLock );
    }
}



VOID RemoveLpcContext(PVOID pContext)
{
    PTERMSRVLPCCONTEXT pLpcContextEntry ; 
    PLIST_ENTRY Head, Next;
    BOOL bFoundContext = FALSE;


    Head = &gTermsrvLpcListHead;
    RtlEnterCriticalSection( &ApiThreadLock );

    /*
     * Search the list for a the same context .
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pLpcContextEntry = CONTAINING_RECORD( Next, TERMSRVLPCCONTEXT, Links );
        if ( pLpcContextEntry->pContext == pContext ) {
            RemoveEntryList(&pLpcContextEntry->Links);
            bFoundContext = TRUE;
            break;

        }
    }
    RtlLeaveCriticalSection( &ApiThreadLock );
    if (bFoundContext) {
        MemFree(pLpcContextEntry);
    }

}

BOOL GetSessionIdFromLpcContext(PLPC_CLIENT_CONTEXT pContext, 
                                PULONG pSessionId)
{
    PTERMSRVLPCCONTEXT pLpcContextEntry ; 
    PLIST_ENTRY Head, Next;
    BOOL bFoundContext = FALSE;


    Head = &gTermsrvLpcListHead;
    RtlEnterCriticalSection( &ApiThreadLock );

    /*
     * Search the list for a the same context .
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pLpcContextEntry = CONTAINING_RECORD( Next, TERMSRVLPCCONTEXT, Links );
        if ( pLpcContextEntry->pContext == pContext ) {
            *pSessionId = pContext->ClientLogonId;
            bFoundContext = TRUE;
            break;

        }
    }
    RtlLeaveCriticalSection( &ApiThreadLock );
    return bFoundContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\conv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib) 5-Aug-1998

Revision History:

--*/

#ifndef USES_CONVERSION

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)								                \
												                \
	((__pUnicode = pStr) == 0 ? (PSTR) 0 : (	                \
												                \
	__nLength = WideCharToMultiByte(				            \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		0,										                \
		0,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
												                \
	WideCharToMultiByte(						                \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		(PSTR) __pAscii,						                \
		__nLength,								                \
		0,										                \
		0										                \
	),											                \
												                \
	(PSTR) __pAscii))							                \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)								                \
												                \
	((__pAscii = pStr) == 0 ? (PWSTR) 0 : (					    \
												                \
	__nLength = MultiByteToWideChar(				            \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),	\
												                \
	MultiByteToWideChar(						                \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		(PWSTR) __pUnicode,							            \
		__nLength									            \
	),											                \
												                \
	(PWSTR) __pUnicode))							            \

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE. 
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid 
//   the compiler warning "symbol defined but not used" due to the variables 
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
	#define T2A(pStr) W2A(pStr)
	#define A2T(pStr) A2W(pStr)
	#define T2W(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define W2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2DA(pStr) W2A(pStr)
	#define A2DT(pStr) A2W(pStr)
	#define T2DW(pStr) _wcsdupa(pStr)
	#define W2DT(pStr) _wcsdupa(pStr)
#else //UNICODE
	#define T2A(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define A2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2W(pStr) A2W(pStr)
	#define W2T(pStr) W2A(pStr)
	#define T2DA(pStr) _strdupa(pStr)
	#define A2DT(pStr) _strdupa(pStr)
	#define T2DW(pStr) A2W(pStr)
	#define W2DT(pStr) W2A(pStr)
#endif //UNICODE


//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//	 pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    wcscpy((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))    \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    strcpy((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))        \


#ifdef UNICODE 
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif


#endif //USES_CONVERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\assoc.cpp ===
//=================================================================
//
// assoc.cpp -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================
#include <stdafx.h>
#include "precomp.h"
#include <assertbreak.h>

#include "Assoc.h"

CAssociation::CAssociation(
    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName
    ) : Provider(pwszClassName, pwszNamespaceName)
{
    ASSERT_BREAK( ( pwszClassName != NULL ) &&
                  ( pwszLeftClassName != NULL ) &&
                  ( pwszRightClassName != NULL) &&
                  ( pwszLeftPropertyName != NULL ) &&
                  ( pwszRightPropertyName != NULL) );

    m_pwszLeftClassName = pwszLeftClassName;
    m_pwszRightClassName = pwszRightClassName;

    m_pwszLeftPropertyName = pwszLeftPropertyName;
    m_pwszRightPropertyName = pwszRightPropertyName;

}

CAssociation::~CAssociation()
{
}

HRESULT CAssociation::ExecQuery(

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> lefts;

    CHStringArray sLeftPaths, sRightPaths;
    pQuery.GetValuesForProp ( m_pwszLeftPropertyName, sLeftPaths ) ;
    pQuery.GetValuesForProp ( m_pwszRightPropertyName, sRightPaths ) ;

    if (sLeftPaths.GetSize() == 0)
    {
        // GetLeftInstances populates lefts
        hr = GetLeftInstances(pMethodContext, lefts);
    }
    else
    {
        // For each sLeftPaths that is valid, create an entry in lefts
        hr = ValidateLeftObjectPaths(pMethodContext, sLeftPaths, lefts);
    }

    if (SUCCEEDED(hr) && lefts.GetSize() > 0)
    {
        if (sRightPaths.GetSize() == 0)
        {
            // GetRightInstances takes the 'lefts' and rubs all the
            // rights against them creating instances where appropriate
            hr = GetRightInstances(pMethodContext, &lefts);
        }
        else
        {
            TRefPointerCollection<CInstance> rights;

            // For each sRightPaths that is valid, create an instance
            hr = ValidateRightObjectPaths(pMethodContext, sRightPaths, lefts);
        }
    }

    return hr;
}

HRESULT CAssociation::GetObject(

    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString sLeftPath, sRightPath;

    // Get the two endpoints
    if (pInstance->GetCHString(m_pwszLeftPropertyName, sLeftPath ) &&
        pInstance->GetCHString(m_pwszRightPropertyName, sRightPath ) )
    {
        CInstancePtr pLeft, pRight;

        // Try to get the objects
        if (SUCCEEDED(hr = RetrieveLeftInstance(sLeftPath, &pLeft, pInstance->GetMethodContext())) &&
            SUCCEEDED(hr = RetrieveRightInstance(sRightPath, &pRight, pInstance->GetMethodContext())) )
        {

            hr = WBEM_E_NOT_FOUND;

            // So, the end points exist.  Are they derived from or equal to the classes we are working with?
            CHString sLeftClass, sRightClass;

            pLeft->GetCHString(L"__CLASS", sLeftClass);
            pRight->GetCHString(L"__CLASS", sRightClass);

            BOOL bDerived = _wcsicmp(m_pwszLeftClassName, sLeftClass) == 0;
            if (!bDerived)
            {
                bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszLeftClassName, sLeftClass, pInstance->GetMethodContext());
            }

            if (bDerived)
            {
                // Left side was correct, now let's check the right
                bDerived = _wcsicmp(m_pwszRightClassName, sRightClass) == 0;

                if (!bDerived)
                {
                    bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszRightClassName, sRightClass, pInstance->GetMethodContext());
                }
            }

            if (bDerived)
            {
                // Just because two instances are valid and derive from the right class, doesn't mean they are related.  Do
                // any other checks.
                if (AreRelated(pLeft, pRight))
                {
                    hr = LoadPropertyValues(pInstance, pLeft, pRight);
                }
            }
        }
    }

    return hr;
}

HRESULT CAssociation::EnumerateInstances(

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRefPointerCollection<CInstance> lefts;

    // GetLeftInstances populates lefts
    if (SUCCEEDED(hr = GetLeftInstances(pMethodContext, lefts)))
    {
        // GetRightInstances takes the 'lefts' and rubs all the
        // rights against them
        hr = GetRightInstances(pMethodContext, &lefts);
    }

    return hr;
}

HRESULT CAssociation::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_pwszRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        NULL,
        pMethodContext,
        lefts);

    return hr;
}

HRESULT WINAPI CAssociation::StaticEnumerationCallback(

    Provider* pThat,
    CInstance* pInstance,
    MethodContext* pContext,
    void* pUserData
)
{
    HRESULT hr;

    CAssociation *pThis = (CAssociation *) pThat;
    ASSERT_BREAK(pThis != NULL);

    if (pThis)
    {
        hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
    }
    else
    {
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

HRESULT CAssociation::EnumerationCallback(

    CInstance *pRight,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    HRESULT hr = WBEM_E_FAILED;

    CInstancePtr pLeft;
    REFPTRCOLLECTION_POSITION posLeft;
    CHString sLeftPath, sRightPath;

    // Cast for userdata back to what it is
    TRefPointerCollection<CInstance> *pLefts = (TRefPointerCollection<CInstance> *)pUserData;

    if (pLefts->BeginEnum(posLeft))
    {
        hr = WBEM_S_NO_ERROR;

        // Walk all the pLefts
        for (pLeft.Attach(pLefts->GetNext(posLeft)) ;
            (SUCCEEDED(hr)) && (pLeft != NULL) ;
            pLeft.Attach(pLefts->GetNext(posLeft)) )
        {
            // Compare it to the current pRight
            if(AreRelated(pLeft, pRight))
            {
                // We have a winner.  Populate the properties and send it in.
                if (GetLocalInstancePath(pLeft,  sLeftPath) &&
                    GetLocalInstancePath(pRight, sRightPath))
                {
                    CInstancePtr pNewAssoc(CreateNewInstance(pMethodContext), false);

                    if (pNewAssoc->SetCHString(m_pwszLeftPropertyName, sLeftPath) &&
                        pNewAssoc->SetCHString(m_pwszRightPropertyName, sRightPath) )
                    {
                        if (SUCCEEDED(hr = LoadPropertyValues(pNewAssoc, pLeft, pRight)))
                        {
                            hr = pNewAssoc->Commit();
                        }
                    }
                    else
                    {
                        ASSERT_BREAK(0);
                    }
                }
            }
        }

        pLefts->EndEnum();
    }

    return hr;
}

HRESULT CAssociation::ValidateLeftObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0; x < sPaths.GetSize(); x++)
    {

        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        int nStatus = objpathParser.Parse( sPaths[x],  &pParsedPath );

        if ( 0 == nStatus )
        {
            BOOL bDerived;

            try
            {
                 bDerived = _wcsicmp(m_pwszLeftClassName, pParsedPath->m_pClass) == 0;
                 if (!bDerived)
                 {
                    bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszLeftClassName, pParsedPath->m_pClass, pMethodContext);
                 }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );

            if (bDerived)
            {
                // See if it is valid
                if (SUCCEEDED(RetrieveLeftInstance(sPaths[x], &pInstance, pMethodContext)))
                {
                    // Yup, add it to the list
                    lefts.Add(pInstance);
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CAssociation::ValidateRightObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    HRESULT hr = WBEM_S_NO_ERROR;;
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0;
         (x < sPaths.GetSize()) && SUCCEEDED(hr);
         x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        int nStatus = objpathParser.Parse( sPaths[x],  &pParsedPath );

        if ( 0 == nStatus )
        {
            BOOL bDerived;
            try
            {
                 bDerived = _wcsicmp(m_pwszRightClassName, pParsedPath->m_pClass) == 0;
                 if (!bDerived)
                 {
                     bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszRightClassName, pParsedPath->m_pClass, pMethodContext);
                 }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );

            if (bDerived)
            {
                // See if it is valid
                if (SUCCEEDED(RetrieveRightInstance(sPaths[x], &pInstance, pMethodContext)))
                {
                    hr = EnumerationCallback(pInstance, pMethodContext, &lefts);
                }
            }
        }
    }

    return hr;
}

HRESULT CAssociation::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_pwszLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext);
}

HRESULT CAssociation::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

HRESULT CAssociation::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}


/*
//========================
CAssocSystemToOS::CAssocSystemToOS(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName
) : CAssociation (

    pwszClassName,
    pwszNamespaceName,

    pwszLeftClassName,
    pwszRightClassName,

    pwszLeftPropertyName,
    pwszRightPropertyName
    )
{
}

CAssocSystemToOS::~CAssocSystemToOS()
{
}

HRESULT CAssocSystemToOS::LoadPropertyValues(

    CInstance *pInstance,
    const CInstance *pLeft,
    const CInstance *pRight
)
{
    CAssociation::LoadPropertyValues(pInstance, pLeft, pRight);

    // This will work... until win32_os returns more than one instance.
    pInstance->Setbool(L"PrimaryOS", true);

    return WBEM_S_NO_ERROR;
}


CAssocSystemToOS MySystemToOperatingSystem(
    L"Win32_SystemOperatingSystem",
    L"root\\cimv2",
    L"Win32_ComputerSystem",
    L"Win32_OperatingSystem",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

  */
bool CAssociation::IsInstance(const CInstance *pInstance)
{
    DWORD dwGenus = 0;

    pInstance->GetDWORD(L"__Genus", dwGenus);

    return dwGenus == WBEM_GENUS_INSTANCE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\assertbreak.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  AssertBreak.h
//
//  Purpose: AssertBreak macro definition
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _ASSERT_BREAK_HMH_
#define _ASSERT_BREAK_HMH_

// Needed to add L to the __FILE__
#define __FRT2(x)      L ## x
#define _FRT2(x)       __FRT2(x)

// We'll need both of these values in case we're running in NT.
// Since our project is not an NT-only project, these are #ifdefd
// out of windows.h

#ifndef _WIN32_WINNT
#define MB_SERVICE_NOTIFICATION          0x00200000L
#define MB_SERVICE_NOTIFICATION_NT3X     0x00040000L
#endif

void WINAPI assert_break( LPCWSTR pszReason, LPCWSTR pszFilename, int nLine );

#if (defined DEBUG || defined _DEBUG)
#define ASSERT_BREAK(exp)    \
    if (!(exp)) { \
        assert_break( _FRT2(#exp), _FRT2(__FILE__), __LINE__ ); \
    }
#else
#define ASSERT_BREAK(exp)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\tsremdsk\tsremdsk.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    salemlib.cpp

Abstract:

    All Salem related function, this library is shared by termsrv.dll
    and salem sessmgr.exe

Author:

    HueiWang    4/26/2000

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <ntlsapi.h>
#include <stdio.h>
#include <rpc.h>
#include <rpcdce.h>
#include <wincrypt.h>
#include <regapi.h>
#include "winsta.h"
#include "tsremdsk.h"
#include "base64.h"

#ifdef AllocMemory

#undef AllocMemory
#undef FreeMemory

#endif

#define AllocMemory(size) LocalAlloc(LPTR, size)
#define FreeMemory(ptr) LocalFree(ptr)

//
// Global Crypto provider
//
HCRYPTPROV gm_hCryptProv = NULL;    // Crypto provider

// 
// CryptEncrypt()/CryptDecrypt() not thread safe
//
HANDLE gm_hMutex = NULL;


extern DWORD
StoreKeyWithLSA(
    IN PWCHAR  pwszKeyName,
    IN BYTE *  pbKey,
    IN DWORD   cbKey 
);

extern DWORD
RetrieveKeyFromLSA(
    IN PWCHAR pwszKeyName,
    OUT PBYTE * ppbKey,
    OUT DWORD * pcbKey 
);

void
EncryptUnlock();

DWORD
EncryptLock();


void
InitLsaString(
    IN OUT PLSA_UNICODE_STRING LsaString,
    IN LPWSTR String 
    )
/*++

Routine Description:

    Initialize LSA unicode string.

Parameters:

    LsaString : Pointer to LSA_UNICODE_STRING to be initialized.
    String : String to initialize LsaString.

Returns:

    None.

Note:

    Refer to LSA_UNICODE_STRING

--*/
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}


DWORD
OpenPolicy(
    IN LPWSTR ServerName,
    IN DWORD  DesiredAccess,
    OUT PLSA_HANDLE PolicyHandle 
    )
/*++

Routine Description:

    Create/return a LSA policy handle.

Parameters:
    
    ServerName : Name of server, refer to LsaOpenPolicy().
    DesiredAccess : Desired access level, refer to LsaOpenPolicy().
    PolicyHandle : Return PLSA_HANDLE.

Returns:

    ERROR_SUCCESS or  LSA error code

--*/
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaOpenPolicy(
                    Server,
                    &ObjectAttributes,
                    DesiredAccess,
                    PolicyHandle ) );
}

DWORD
StoreKeyWithLSA(
    IN PWCHAR  pwszKeyName,
    IN BYTE *  pbKey,
    IN DWORD   cbKey 
    )
/*++

Routine Description:

    Save private data to LSA.

Parameters:

    pwszKeyName : Name of the key this data going to be stored under.
    pbKey : Binary data to be saved.
    cbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    LSA return code

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;
    
    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_CREATE_SECRET, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}


DWORD
RetrieveKeyFromLSA(
    IN PWCHAR pwszKeyName,
    OUT PBYTE * ppbKey,
    OUT DWORD * pcbKey 
    )
/*++

Routine Description:

    Retrieve private data previously stored with StoreKeyWithLSA().

Parameters:

    pwszKeyName : Name of the key.
    ppbKey : Pointer to PBYTE to receive binary data.
    pcbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    ERROR_FILE_NOT_FOUND
    LSA return code

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) || ( NULL == ppbKey ) || ( NULL == pcbKey ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_GET_PRIVATE_INFORMATION, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        SetLastError( LsaNtStatusToWinError(Status) );
        return GetLastError();
    }

    Status = LsaRetrievePrivateData(
                            PolicyHandle,
                            &SecretKeyName,
                            &pSecretData
                        );

    LsaClose( PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        SetLastError( LsaNtStatusToWinError(Status) );
        return GetLastError();
    }

    if(pSecretData != NULL && pSecretData->Length)
    {
        *ppbKey = (LPBYTE)AllocMemory( pSecretData->Length );

        if( *ppbKey )
        {
            *pcbKey = pSecretData->Length;
            CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
            Status = ERROR_SUCCESS;
        } 
        else 
        {
            Status = GetLastError();
        }
    }
    else
    {
        Status = ERROR_FILE_NOT_FOUND;
        SetLastError( Status );
        *pcbKey = 0;
        *ppbKey = NULL;
    }

    if (pSecretData != NULL) {
        ZeroMemory( pSecretData->Buffer, pSecretData->Length );
        LsaFreeMemory( pSecretData );
    }

    return Status;
}

DWORD
TSSetEncryptionKey(
    IN PBYTE pbData,
    IN DWORD  cbData
    )
/*++

Routine Description:

    Cache random password that use to deriving encryption cycle key.

Parameters:

    pbData :
    cbData :

Returns:

    ERROR_SUCCESS or error code

--*/
{
    DWORD status;

    if( !pbData || cbData == 0 )
    {
        status = ERROR_INVALID_PARAMETER;
        goto CLEANUPANDEXIT;
    }

    status = EncryptLock();
    if( ERROR_SUCCESS == status )
    {
        //
        // Load password to derive session encryption key from LSA   
        //
        status = StoreKeyWithLSA(
                            SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                            pbData,
                            cbData
                        );

        EncryptUnlock();
    }

CLEANUPANDEXIT:

    return status;
}

DWORD
TSGetEncryptionKey(
    OUT PBYTE* ppbData,
    OUT DWORD* pcbData
    )
/*++

Routine Description:

    Cache random password that use to deriving encryption cycle key.

Parameters:

    pbData :
    cbData :

Returns:

    ERROR_SUCCESS or error code

--*/
{
    DWORD status;

    if( !ppbData || !pcbData )
    {
        status = ERROR_INVALID_PARAMETER;
        goto CLEANUPANDEXIT;
    }

    status = EncryptLock();
    if( ERROR_SUCCESS == status )
    {
        //
        // Load password to derive session encryption key from LSA   
        //
        status = RetrieveKeyFromLSA(
                                    SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                    ppbData,
                                    pcbData
                                );

        EncryptUnlock();
    }

CLEANUPANDEXIT:

    return status;
}

DWORD
TSGetHelpAssistantAccountPassword(
    OUT LPWSTR* ppszAccPwd
    )
/*++

--*/
{
    DWORD cbHelpAccPwd = 0;
    DWORD Status;

    Status = RetrieveKeyFromLSA(
                            SALEMHELPASSISTANTACCOUNT_PASSWORDKEY,
                            (PBYTE *)ppszAccPwd,
                            &cbHelpAccPwd
                        );

    if( ERROR_SUCCESS != Status )
    {
        // password is not set, assuming no help
        Status = ERROR_INVALID_ACCESS;
    }

    return Status;
}

	
DWORD
TSGetHelpAssistantAccountName(
    OUT LPWSTR* ppszAccDomain,
    OUT LPWSTR* ppszAcctName
    )
/*++

Routine Description:

    Get HelpAssistant account name.

Parameters:

    ppszAcctName : Pointer to LPWSTR to receive account name, use LocalFree()
                   to free the buffer.

Returns:

    ERROR_SUCCESS or error code

--*/
{
    LPWSTR pszHelpAcctName = NULL;
    LPWSTR pszHelpAcctDomain = NULL;
    DWORD cbHelpAcctName = 0;
    DWORD cbHelpAcctDomain = 0;
    SID_NAME_USE sidUse;

    DWORD Status;
    BOOL bSuccess;
    PSID pLsaHelpAccSid = NULL;
    DWORD cbLsaHelpAccSid = 0;

    //
    // Retrieve HelpAccount SID we cached in LSA
    Status = RetrieveKeyFromLSA(
                            SALEMHELPASSISTANTACCOUNT_SIDKEY,
                            (PBYTE *)&pLsaHelpAccSid,
                            &cbLsaHelpAccSid
                        );

    if( ERROR_SUCCESS != Status )
    {
        // Salem is not installed or not active on this machine
        goto CLEANUPANDEXIT;
    }

    //
    // Lookup account name from SID
    //
    bSuccess = LookupAccountSid(
                            NULL,
                            pLsaHelpAccSid,
                            NULL,
                            &cbHelpAcctName,
                            NULL,
                            &cbHelpAcctDomain,
                            &sidUse
                        );

    if( bSuccess == FALSE && ERROR_NONE_MAPPED == GetLastError() )
    {
        // Can't retrieve either because network error or account
        // does not exist, error out.
        Status = ERROR_FILE_NOT_FOUND;
        goto CLEANUPANDEXIT;
    }

    pszHelpAcctName = (LPTSTR)AllocMemory( (cbHelpAcctName+1)*sizeof(WCHAR) );
    pszHelpAcctDomain = (LPTSTR)AllocMemory( (cbHelpAcctDomain+1)*sizeof(WCHAR) );

    if( NULL == pszHelpAcctName || NULL == pszHelpAcctDomain )
    {
        Status = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    bSuccess = LookupAccountSid(
                            NULL,
                            pLsaHelpAccSid,
                            pszHelpAcctName,
                            &cbHelpAcctName,
                            pszHelpAcctDomain,
                            &cbHelpAcctDomain,
                            &sidUse
                        );

    if( FALSE == bSuccess )
    {
        Status = GetLastError();
        goto CLEANUPANDEXIT;
    }

    *ppszAcctName = pszHelpAcctName;
    *ppszAccDomain = pszHelpAcctDomain;

    // don't free account name.
    pszHelpAcctName = NULL;
    pszHelpAcctDomain = NULL;

CLEANUPANDEXIT:

    if( NULL != pLsaHelpAccSid )
    {
        ZeroMemory( pLsaHelpAccSid, cbLsaHelpAccSid );
        FreeMemory( pLsaHelpAccSid );
    }

    if( NULL != pszHelpAcctDomain )
    {
        FreeMemory( pszHelpAcctDomain );
    }

    if( NULL != pszHelpAcctName )
    {
        FreeMemory(pszHelpAcctName);
    }

    return Status;
}

BOOL
TSIsMachineInHelpMode()
/*++

Routine Description:

    Return if machine is in GetHelp mode
    
Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    //
    // machine can only be in help mode if we have some
    // password to derive session encryption key, if
    // no pending help session exist, sessmgr will end
    // encryption cycle.
    return TSHelpAssistantInEncryptionCycle();
}

////////////////////////////////////////////////////////////////////////////

DWORD
EncryptLock()
/*++

Routine Description:

    Acquire encryption/decryption routine lock.

Parameters:

    None.

Returns:

    None.

--*/
{
    DWORD dwStatus;

    ASSERT( NULL != gm_hMutex );

    if( gm_hMutex )
    {
        dwStatus = WaitForSingleObject( gm_hMutex, INFINITE );

        ASSERT( WAIT_FAILED != dwStatus );
    }
    else
    {
        dwStatus = ERROR_INTERNAL_ERROR;
    }

    return dwStatus;
}

void
EncryptUnlock()
/*++

Routine Description:

    Release encryption/decryption routine lock.

Parameters:

    None.

Returns:

    None.

--*/
{
    BOOL bSuccess;

    bSuccess = ReleaseMutex( gm_hMutex );
    ASSERT( TRUE == bSuccess );
}


LPTSTR 
GenerateEncryptionPassword()
/*++

Routine Description:

    Generate a random password to derive encryption key.

Parameters:

    N/A

Returns:

    NULL or random password, GetLastError() to 
    retrieve detail error.

Note:

    Use UUID as password to derive encryption key.

--*/
{
    RPC_STATUS rpcStatus;
    UUID uuid;
    LPTSTR pszUuidString = NULL;

    rpcStatus = UuidCreate( &uuid );

    if( rpcStatus == RPC_S_OK || rpcStatus == RPC_S_UUID_LOCAL_ONLY ||
        rpcStatus == RPC_S_UUID_NO_ADDRESS )
    {
        rpcStatus = UuidToString( &uuid, &pszUuidString );
    }

    return pszUuidString;
}

BOOL
TSHelpAssistantInEncryptionCycle()
{
    LPTSTR pszEncryptKey = NULL;
    DWORD cbEncryptKey = 0;
    DWORD dwStatus;

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Sessmgr will reset encryption password to NULL 
        // if there is no help pending
        //
        dwStatus = RetrieveKeyFromLSA(
                                    SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                    (PBYTE *)&pszEncryptKey,
                                    &cbEncryptKey
                                );

        if( NULL != pszEncryptKey )
        {
            FreeMemory( pszEncryptKey );
        }

        EncryptUnlock();
    }

    return ERROR_SUCCESS == dwStatus;
}


DWORD
TSHelpAssistantBeginEncryptionCycle()
{
    DWORD dwStatus;
    LPTSTR pszKey = NULL;
    DWORD cbKey;

    ASSERT( NULL != gm_hMutex );

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Generate a random password for deriving encryption key
        //
        pszKey = GenerateEncryptionPassword();
        if( NULL != pszKey )
        {
            //
            // Store key deriving password into LSA
            //
            dwStatus = StoreKeyWithLSA( 
                                    SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                    (PBYTE)pszKey,
                                    (lstrlenW(pszKey)+1) * sizeof(WCHAR) 
                                );
        }
        else
        {
            dwStatus = GetLastError();
        }

        EncryptUnlock();
    }

    if( ERROR_SUCCESS == dwStatus )
    {
        HKEY Handle = NULL;
        DWORD dwInHelpMode = 1;

        dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                           KEY_READ | KEY_SET_VALUE, &Handle );
        if ( dwStatus == ERROR_SUCCESS )
        {
            dwStatus = RegSetValueEx(Handle,REG_MACHINE_IN_HELP_MODE,
                                  0,REG_DWORD,(const BYTE *)&dwInHelpMode,
                                  sizeof(dwInHelpMode));

         }
         if(Handle)
         {
             RegCloseKey(Handle);
         }

         ASSERT( ERROR_SUCCESS == dwStatus );

    }

    if( NULL != pszKey )
    {
        // string is generated by UuidToString()
        RpcStringFree( &pszKey );
    }

    return dwStatus;
}


DWORD
TSHelpAssisantEndEncryptionCycle()
/*++

Routine Description:

    End an encryption cycle, a cycle is defined between first help
    created in help session manager to last pending help been resolved.

Parameters:

    N/A

Returns:

    ERROR_SUCCESS or LSA error code

--*/
{
    DWORD dwStatus;

    ASSERT( NULL != gm_hMutex );

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = StoreKeyWithLSA(
                                    SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                    (PBYTE)NULL,
                                    0
                                );

        EncryptUnlock();
    }

    if( ERROR_SUCCESS == dwStatus ) // should we not always do it?
    {
        HKEY Handle = NULL;
        DWORD dwInHelpMode = 0;

        dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                           KEY_READ | KEY_SET_VALUE, &Handle );
        if ( dwStatus == ERROR_SUCCESS )
        {
            dwStatus = RegSetValueEx(Handle,REG_MACHINE_IN_HELP_MODE,
                                  0,REG_DWORD,(const BYTE *)&dwInHelpMode,
                                  sizeof(dwInHelpMode));

         }
         if(Handle)
         {
             RegCloseKey(Handle);
         }

         ASSERT( ERROR_SUCCESS == dwStatus );

    }

    return dwStatus;
}    


HCRYPTKEY
CreateEncryptDecryptKey(
    IN LPCTSTR pszEncryptPrefix,
    IN LPCTSTR pszPassword
    )
/*++

Routine Description:

    CreateEncryptDecryptKey() derive a session encryption/decryption
    key from password string.

Parameters:

    pszEncryptPrefix : Optional string to be concatenated with password string to derives
                an encryption key.
    pszPassword : Pointer to password string to derives a session encryption
                  decryption key.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Caller must invoke EncryptLock();

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    HCRYPTHASH hCryptHash = NULL;
    HCRYPTKEY hCryptKey = NULL;
    BOOL bStatus;
    LPTSTR pszEncryptKey = NULL;


    ASSERT( NULL != pszPassword );
    ASSERT( NULL != gm_hCryptProv );

    if( NULL != pszPassword && NULL != gm_hCryptProv )
    {
        if( pszEncryptPrefix )
        {
            pszEncryptKey = (LPTSTR)AllocMemory( (lstrlen(pszEncryptPrefix) + lstrlen(pszPassword) + 1) * sizeof(TCHAR) );
            if( NULL == pszEncryptKey )
            {
                // Out of memory, can't continue.
                goto CLEANUPANDEXIT;
            }

            lstrcpy( pszEncryptKey, pszEncryptPrefix );
            lstrcat( pszEncryptKey, pszPassword );
        }
                

        //
        // Derives a session key for encryption/decryption.
        //
        bStatus = CryptCreateHash(
                                gm_hCryptProv,
                                CALG_MD5,
                                0,
                                0,
                                &hCryptHash
                            );

        if( FALSE == bStatus )
        {
            dwStatus = GetLastError();
            ASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        if( pszEncryptKey )
        { 
            bStatus = CryptHashData(
                                hCryptHash,
                                (BYTE *)pszEncryptKey,
                                lstrlen(pszEncryptKey) * sizeof(TCHAR),
                                0
                            );
        }
        else
        {
            bStatus = CryptHashData(
                                hCryptHash,
                                (BYTE *)pszPassword,
                                lstrlen(pszPassword) * sizeof(TCHAR),
                                0
                            );
        }

        if( FALSE == bStatus )
        {
            dwStatus = GetLastError();
            ASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        //
        // derive a session key for encrypt/decrypt
        //
        bStatus = CryptDeriveKey(
                                gm_hCryptProv,
                                ENCRYPT_ALGORITHM,  
                                hCryptHash,
                                0,
                                &hCryptKey
                            );

        if( FALSE == bStatus )
        {
            dwStatus = GetLastError();
            ASSERT(FALSE);
        }
    }
    else
    {
        SetLastError( dwStatus = ERROR_INVALID_PARAMETER );
    }

       
CLEANUPANDEXIT:

    if( NULL != hCryptHash )
    {
        (void)CryptDestroyHash( hCryptHash );
    }

    if( NULL != pszEncryptKey )
    {
        FreeMemory( pszEncryptKey );
    }
                
    return hCryptKey;
}


DWORD 
EnsureCryptoProviderCreated()
{
    BOOL bStatus;
    DWORD dwStatus = ERROR_SUCCESS;

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Acquire a global Crypto provider 
        //
        if( NULL == gm_hCryptProv )
        {
            bStatus = CryptAcquireContext(
                                &gm_hCryptProv,
                                HELPASSISTANT_CRYPT_CONTAINER,
                                MS_DEF_PROV,                
                                PROV_RSA_FULL,
                                0
                            );

            if( FALSE == bStatus )
            {
                // Create a container if not exists.
                bStatus = CryptAcquireContext(
                                    &gm_hCryptProv,
                                    HELPASSISTANT_CRYPT_CONTAINER,
                                    MS_DEF_PROV,                
                                    PROV_RSA_FULL,
                                    CRYPT_NEWKEYSET
                                );

                if( FALSE == bStatus )
                {
                    dwStatus = GetLastError();
                    ASSERT(FALSE);
                }
            }
        }

        EncryptUnlock();
    }

    return dwStatus;
}

HCRYPTKEY
GetEncryptionCycleKey(
    IN LPCTSTR pszEncryptPrefix
    )
/*++

Routine Description:

    Create a encryption/decryption key for current encryption 
    cycle, function first load password to derive session encryption 
    key from LSA and invoke CryptAPI to create the session encryption 
    key.  If password is not in LSA, function return error.

Parameters:

    None.

Returns:

    Handle to session encryption key, NULL if error, use GetLastError to
    to retrieve detail error code.

Note:

    Caller must invoke EncryptLock();


--*/
{
    LPTSTR pszEncryptKey;
    DWORD cbEncryptKey;
    DWORD dwStatus;
    HCRYPTKEY hCryptKey = NULL;

    //
    // Load password to derive session encryption key from LSA   
    //
    dwStatus = RetrieveKeyFromLSA(
                                SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                (PBYTE *)&pszEncryptKey,
                                &cbEncryptKey
                            );

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Make sure global crypto provider exists.
        //
        dwStatus = EnsureCryptoProviderCreated();

        if( ERROR_SUCCESS == dwStatus )
        {
            //
            // Create the session encryption key.
            //
            hCryptKey = CreateEncryptDecryptKey( pszEncryptPrefix, pszEncryptKey );
        }

        FreeMemory( pszEncryptKey ); 
    }

    return hCryptKey;
}


VOID
TSHelpAssistantEndEncryptionLib()
{
    //
    // ignore error code, this is only for shutdown
    //
    if( NULL != gm_hCryptProv )
    {
        CryptReleaseContext( gm_hCryptProv, 0 );
        gm_hCryptProv = NULL;    
    }

    if( NULL != gm_hMutex )
    {
        ReleaseMutex( gm_hMutex );
    }
    return;
}


DWORD
TSHelpAssistantInitializeEncryptionLib()
/*++

Routine Description:

    Initialize encryption/decryption library

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bStatus;
    LPTSTR pszEncryptKey;
    DWORD cbEncryptKey;


    ASSERT( NULL == gm_hCryptProv );
    ASSERT( NULL == gm_hMutex );

    //
    // Create a global mutex
    //
    gm_hMutex = CreateMutex(
                        NULL,
                        FALSE,
                        SALEMHELPASSISTANTACCOUNT_ENCRYPTMUTEX
                    );

    
    if( NULL == gm_hMutex )
    {
        dwStatus = GetLastError();
        ASSERT( NULL != gm_hMutex );
    }

    return dwStatus;
}


DWORD
TSHelpAssistantEncryptData(
    IN LPCWSTR pszEncryptPrefixKey,
    IN OUT PBYTE pbData,
    IN OUT DWORD* pcbData
    )
/*++

Routine Description:

    Encrypt binary data, called must have invoked
    TSHelpAssistantInitializeEncryptionLib() and 
    TSHelpAssistantBeginEncryptionCycle().

Parameters:

    pbData : Pointer to binary data to be encrypted.
    pcbData : Size of binary data to be encrypted.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Caller need to free ppbEncryptedData via LocalFree().

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bStatus;
    HCRYPTKEY hCryptKey = NULL;
    EXCEPTION_RECORD ExceptionCode;
    DWORD cbBufSize = *pcbData;


    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Retrieve current cycle encryption key
        //
        hCryptKey = GetEncryptionCycleKey(pszEncryptPrefixKey);

        if( NULL == hCryptKey )
        {
            dwStatus = GetLastError();

            EncryptUnlock();
            goto CLEANUPANDEXIT;
        }

        //
        // Encrypt the data, not thread safe.
        //
        __try{

            // Stream cipher - same buffer size
            bStatus = CryptEncrypt(
                                hCryptKey,
                                NULL,
                                TRUE,
                                0,
                                pbData,      // buffer to be encrypted
                                pcbData,     // buffer size
                                cbBufSize    // number of byte to be encrypt
                            );

            if( FALSE == bStatus )
            {
                dwStatus = GetLastError();
            }
        }
        __except(
            ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
            EXCEPTION_EXECUTE_HANDLER )
        {
            bStatus = FALSE;
            dwStatus = ExceptionCode.ExceptionCode;
        }

        EncryptUnlock();

        //
        // Using stream cipher, has to be same size.
        //
        ASSERT( cbBufSize == *pcbData );
    }

CLEANUPANDEXIT:

    if( NULL != hCryptKey )
    {
        CryptDestroyKey( hCryptKey );
    }

    return dwStatus;
}


DWORD
TSHelpAssistantDecryptData(
    IN LPCWSTR pszEncryptPrefixKey,
    IN OUT PBYTE pbData,
    IN OUT DWORD* pcbData
    )
/*++

Routine Description:

    Decrypt data previously encrypted using TSHelpAssistantEncryptBase64EncodeData().

Parameters:

    pbData : Stream of binary data to be decoded/decrypted.
    pcbData : Size of data in bytes to be decrypted/decoded.

Returns:

    ERROR_SUCCESS or error code

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bStatus;
    HCRYPTKEY hCryptKey = NULL;
    EXCEPTION_RECORD ExceptionCode;
    DWORD dwBufSize = *pcbData;

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Retrieve session encryption key for this encryption cycle.
        //
        hCryptKey = GetEncryptionCycleKey(pszEncryptPrefixKey);

        if( NULL == hCryptKey )
        {
            dwStatus = GetLastError();
            EncryptUnlock();
            goto CLEANUPANDEXIT;
        }


        __try {
            // Stream cipher - same buffer size
            bStatus = CryptDecrypt(
                                hCryptKey,
                                NULL,
                                TRUE,
                                0,
                                pbData,
                                pcbData
                            );

            if( FALSE == bStatus )
            {
                dwStatus = GetLastError();
            }
        }
        __except(
            ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
            EXCEPTION_EXECUTE_HANDLER )
        {
            bStatus = FALSE;
            dwStatus = ExceptionCode.ExceptionCode;
        }

        EncryptUnlock();

        //
        // Stream cipher, same buffer size
        ASSERT( dwBufSize == *pcbData );
    }

CLEANUPANDEXIT:

    if( NULL != hCryptKey )
    {
        CryptDestroyKey( hCryptKey );
    }
        
    return dwStatus;
}

BOOL
TSIsMachinePolicyAllowHelp()
/*++

Routine Description:

    Check if 'GetHelp' is enabled on local machine, routine first query 
    system policy registry key, if policy is not set, then read salem
    specific registry.  Default to 'enable' is registry value does not
    exist.

Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    return RegIsMachinePolicyAllowHelp();
}

BOOL
TSIsMachineInSystemRestore()
/*+=

Routine Description:

    Check if our special reg. value exist that indicate system restore 
    has rebooted machine.

Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    DWORD dwStatus;
    HKEY hKey = NULL;
    DWORD cbData;
    DWORD value;
    DWORD type;
    BOOL bInSystemRestore = FALSE;

    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_REMDSK L"\\" REG_CONTROL_HELPSESSIONENTRY,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey
                    );

    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    cbData = sizeof(value);
    value = 0;
    dwStatus = RegQueryValueEx( 
                        hKey,
                        REG_VALUE_SYSTEMRESTORE,
                        0,
                        &type,
                        (LPBYTE)&value,
                        &cbData
                    );

    if( ERROR_SUCCESS == dwStatus && type == REG_DWORD && value == 1 )
    {
        bInSystemRestore = TRUE;
    }

CLEANUPANDEXIT:

    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    return bInSystemRestore;
}

DWORD
TSSystemRestoreCacheValues()
/*++

Routine Description:

    Cache necessary LSA data that we use in Salem for system restore.

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

Note:

    We can't cache HelpAssistant account SID as 
    1) System restore will restore all user account.
    2) System restore also restore our LSA SID key.

    since our account is created at setup time, account has to 
    match SID we cached.
--*/
{
    DWORD dwStatus;
    DWORD dwSize;
    DWORD dwValue;
    PBYTE pbData = NULL;
    HKEY hCacheKey = NULL;
    HKEY hRegControlKey = NULL;
    DWORD dwType;


    //
    // Check if we just start up after rebooted from system restore.
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_REMDSK L"\\" REG_CONTROL_HELPSESSIONENTRY,
                        0,
                        KEY_ALL_ACCESS,
                        &hCacheKey
                    );

    if( ERROR_SUCCESS != dwStatus ) 
    {
        // This registry key is created at setup time so must exist.
        ASSERT(FALSE);
        dwStatus = ERROR_INTERNAL_ERROR;
        goto CLEANUPANDEXIT;
    }

    //
    // Mark that we are in system restore.
    //
    dwSize = sizeof(dwValue);
    dwValue = 1;
    dwStatus = RegSetValueEx( 
                        hCacheKey,
                        REG_VALUE_SYSTEMRESTORE,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        dwSize
                    );

    //
    // Cache encryption cycle key.
    //    
    dwStatus = TSGetEncryptionKey( &pbData, &dwSize );
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = RegSetValueEx(
                        hCacheKey,
                        REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY,
                        0,
                        REG_BINARY,
                        pbData,
                        dwSize
                    );

    //
    // Cache fAllowToGetHelp
    //
    dwStatus = RegOpenKeyEx( 
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_TSERVER,
                        0,
                        KEY_READ,
                        &hRegControlKey
                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwSize = sizeof(dwValue);
    dwValue = 0;
    dwType = 0;

    dwStatus = RegQueryValueEx(
                            hRegControlKey,
                            POLICY_TS_REMDSK_ALLOWTOGETHELP,
                            0,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwSize
                        );
    
    // Key does not exist, assume no help is allow.
    if( ERROR_SUCCESS != dwStatus || dwType != REG_DWORD )
    {
        dwValue = 0;
    }

    dwStatus = RegSetValueEx(
                        hCacheKey,
                        REG_VALUE_SYSTEMRESTORE_ALLOWTOGETHELP,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        dwSize
                    );
                

    //
    // Cache fInHelpMode
    //   
    dwSize = sizeof(dwValue);
    dwValue = 0;
    dwType = 0;

    dwStatus = RegQueryValueEx(
                            hRegControlKey,
                            REG_MACHINE_IN_HELP_MODE,
                            0,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwSize
                        );
    
    // Key does not exist, assume No help
    if( ERROR_SUCCESS != dwStatus || dwType != REG_DWORD )
    {
        dwValue = 0;
    }

    dwStatus = RegSetValueEx(
                        hCacheKey,
                        REG_VALUE_SYSTEMRESTORE_INHELPMODE,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        dwSize
                    );

CLEANUPANDEXIT:

    if( NULL != hCacheKey )
    {
        RegCloseKey( hCacheKey );
    }

    if( NULL != hRegControlKey )
    {
        RegCloseKey( hRegControlKey );
    }

    if( NULL != pbData )
    {
        LocalFree( pbData );
    }

    return dwStatus;
}
    

DWORD
TSSystemRestoreResetValues()
/*++

Routine Description:

    Reset necessary LSA data that we use in Salem for system restore.

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    PBYTE pbData = NULL;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwValue;
    HKEY hRegControlKey = NULL;
    HKEY hCacheKey = NULL;

    //
    // Check if we just start up after rebooted from system restore.
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_REMDSK L"\\" REG_CONTROL_HELPSESSIONENTRY,
                        0,
                        KEY_ALL_ACCESS,
                        &hCacheKey
                    );

    if( ERROR_SUCCESS != dwStatus ) 
    {
        // This registry key is created at setup time so must exist.
        ASSERT(FALSE);
        dwStatus = ERROR_INTERNAL_ERROR;
        goto CLEANUPANDEXIT;
    }

    //
    // Restore necessary LSA values.
    //
    dwSize = 0;
    dwStatus = RegQueryValueEx(
                            hCacheKey,
                            REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY,
                            0,
                            &dwType,
                            NULL,
                            &dwSize
                        );

    if( ERROR_SUCCESS != dwStatus || dwType != REG_BINARY )
    {
        goto CLEANUPANDEXIT;
    }

    pbData = (PBYTE) LocalAlloc( LPTR, dwSize );
    if( NULL == pbData )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    // Restore encryption key
    dwStatus = RegQueryValueEx(
                            hCacheKey,
                            REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY,
                            0,
                            &dwType,
                            pbData,
                            &dwSize
                        );
    
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = TSSetEncryptionKey(pbData, dwSize);

    //
    // Reset fAllowToGetHelp
    //
    dwStatus = RegOpenKeyEx( 
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_TSERVER,
                        0,
                        KEY_READ | KEY_SET_VALUE,
                        &hRegControlKey
                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwSize = sizeof(dwValue);
    dwValue = 0;
    dwType = 0;

    dwStatus = RegQueryValueEx(
                            hCacheKey,
                            REG_VALUE_SYSTEMRESTORE_ALLOWTOGETHELP,
                            0,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwSize
                        );
    
    // Key does not exist, assume no help is allow.
    if( ERROR_SUCCESS != dwStatus || dwType != REG_DWORD )
    {
        dwValue = 0;
    }

    dwStatus = RegSetValueEx(
                        hRegControlKey,
                        POLICY_TS_REMDSK_ALLOWTOGETHELP,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        dwSize
                    );
                

    //
    // Reset fInHelpMode
    //   
    dwSize = sizeof(dwValue);
    dwValue = 0;
    dwType = 0;

    dwStatus = RegQueryValueEx(
                            hCacheKey,
                            REG_VALUE_SYSTEMRESTORE_INHELPMODE, 
                            0,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwSize
                        );
    
    // Key does not exist, assume not in help
    if( ERROR_SUCCESS != dwStatus || dwType != REG_DWORD )
    {
        dwValue = 0;
    }

    dwStatus = RegSetValueEx(
                        hRegControlKey,
                        REG_MACHINE_IN_HELP_MODE,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        dwSize
                    );

CLEANUPANDEXIT:

    if( NULL != pbData )
    {
        LocalFree(pbData);
    }

    if( NULL != hCacheKey )
    {
        RegDeleteValue( hCacheKey, REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY );
        RegDeleteValue( hCacheKey, REG_VALUE_SYSTEMRESTORE );
        RegDeleteValue( hCacheKey, REG_VALUE_SYSTEMRESTORE_ALLOWTOGETHELP );
        RegDeleteValue( hCacheKey, REG_VALUE_SYSTEMRESTORE_INHELPMODE );
        RegCloseKey( hCacheKey );
    }

    if( NULL != hRegControlKey )
    {
        RegCloseKey( hRegControlKey );
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\binding.cpp ===
//=================================================================
//
// binding.cpp -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================
#include <stdafx.h>
#include "precomp.h"
#include <assertbreak.h>

#include "Assoc.h"
#include "Binding.h"


bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2) 
{
   
   if (v1->vt == v2->vt) {
      switch (v1->vt) {
      case VT_BOOL: return (v1->boolVal == v2->boolVal);
      case VT_UI1:  return (v1->bVal == v2->bVal);
      case VT_I2:   return (v1->iVal == v2->iVal);
      case VT_I4:   return (v1->lVal == v2->lVal);
      case VT_R4:   return (v1->fltVal == v2->fltVal);
      case VT_R8:   return (v1->dblVal == v2->dblVal);
      case VT_BSTR: return (0 == _wcsicmp(v1->bstrVal, v2->bstrVal));
      default:
         ASSERT_BREAK(0);
      }
   }
   return false;
}

CBinding::CBinding(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName,

    LPCWSTR pwszLeftBindingPropertyName,
    LPCWSTR pwszRightBindingPropertyName
)

: CAssociation (

    pwszClassName,
    pwszNamespaceName,
    pwszLeftClassName,
    pwszRightClassName,
    pwszLeftPropertyName,
    pwszRightPropertyName
)
{
    ASSERT_BREAK( ( pwszLeftBindingPropertyName != NULL ) && ( pwszRightBindingPropertyName != NULL) );

    m_pwszLeftBindingPropertyName = pwszLeftBindingPropertyName;
    m_pwszRightBindingPropertyName = pwszRightBindingPropertyName;
}

CBinding::~CBinding()
{
}

//========================
BOOL CBinding::AreRelated(

    const CInstance *pLeft,
    const CInstance *pRight
)
{
    BOOL bRet = FALSE;

    variant_t   LeftBindingPropertyValue,
                RightBindingPropertyValue;

    if (pLeft->GetVariant(m_pwszLeftBindingPropertyName, LeftBindingPropertyValue) &&
        pRight->GetVariant(m_pwszRightBindingPropertyName,  RightBindingPropertyValue) )
    {
        bRet = CompareVariantsNoCase(&LeftBindingPropertyValue, &RightBindingPropertyValue);
    }
    else
    {
        ASSERT_BREAK(0);
    }

    return bRet;
}

HRESULT CBinding::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH, %s FROM %s", m_pwszRightBindingPropertyName, m_pwszRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        NULL,
        pMethodContext,
        lefts);

    return hr;
}

HRESULT CBinding::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH, %s FROM %s", m_pwszLeftBindingPropertyName, m_pwszLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext);
}

HRESULT CBinding::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__RELPATH");
    csaProperties.Add(m_pwszLeftBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

HRESULT CBinding::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__RELPATH");
    csaProperties.Add(m_pwszRightBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

// =========================================================================================================


CBinding MyTerminalServiceToSetting(
    L"Win32_TerminalServiceToSetting",
    L"root\\cimv2",
    L"Win32_TerminalService",
    L"Win32_TerminalServiceSetting",
    L"Element",
    L"Setting",
    L"Name",
    L"ServerName"
);

CBinding MyTerminalTerminalSetting(
    L"Win32_TerminalTerminalSetting",
    L"root\\cimv2",
    L"Win32_Terminal",
    L"Win32_TerminalSetting",
    L"Element",
    L"Setting",
    L"TerminalName",
    L"TerminalName"

);

CBinding MyTSSessionDirectorySetting(
    L"Win32_TSSessionDirectorySetting",
    L"root\\cimv2",
    L"Win32_TerminalService",
    L"Win32_TSSessionDirectory",
    L"Element",
    L"Setting",
    L"Name",
    L"SessionDirectoryActive"
);

/*
CBinding MyTSPermissionsSetting(
    L"Win32_TSPermissionsSetting",
    L"root\\cimv2",
    L"Win32_Terminal",
    L"Win32_TSAccount",
    L"Element",
    L"Setting",
    L"TerminalName",
    L"AccountName"
);

CBinding MyTSNetworkAdapterListSetting(
    L"Win32_TSNetworkAdapterListSetting",
    L"root\\cimv2",
    L"Win32_NetworkAdapter",
    L"Win32_TSNetworkAdapterSetting",
    L"Element",
    L"Setting",
    L"DeviceID",
    L"TerminalName"
);

*/

/*

CBinding MyNetAdaptToNetAdaptConfig(
    L"Win32_NetworkAdapterSetting",
    L"root\\cimv2",
    L"Win32_NetworkAdapter",
    L"Win32_NetworkAdapterConfiguration",
    L"Element",
    L"Setting",
    IDS_Index,
    IDS_Index);

CBinding PageFileToPagefileSetting(
    L"Win32_PageFileElementSetting",
    L"root\\cimv2",
    L"Win32_PageFileUsage",
    L"Win32_PageFileSetting",
    L"Element",
    L"Setting",
    IDS_Name,
    IDS_Name);

CBinding MyPrinterSetting(
    L"Win32_PrinterSetting",
    L"root\\cimv2",
    L"Win32_Printer",
    L"Win32_PrinterConfiguration",
    L"Element",
    L"Setting",
    IDS_DeviceID,
    IDS_Name);

CBinding MyDiskToPartitionSet(
    L"Win32_DiskDriveToDiskPartition",
    L"root\\cimv2",
    L"Win32_DiskDrive",
    L"Win32_DiskPartition",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_Index,
    IDS_DiskIndex
);

CBinding assocPOTSModemToSerialPort(
    L"Win32_POTSModemToSerialPort",
    L"root\\cimv2",
    L"Win32_SerialPort",
    L"Win32_POTSModem",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_DeviceID,
    IDS_AttachedTo
);

CBinding OStoQFE(
    L"Win32_OperatingSystemQFE",
    L"root\\cimv2",
    L"Win32_OperatingSystem",
    L"Win32_QuickFixEngineering",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_CSName,
    IDS_CSName
);

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\binding.h ===
//=================================================================
//
// binding.h -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================

#pragma once
class CBinding : public CAssociation
{
    public:

        CBinding(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName,

            LPCWSTR pwszLeftBindingPropertyName,
            LPCWSTR pwszRightBindingPropertyName
        );

        ~CBinding();

    protected:

        BOOL AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        );

        HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts
        );

        HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        LPCWSTR m_pwszLeftBindingPropertyName;
        LPCWSTR m_pwszRightBindingPropertyName;
};

bool WINAPI CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\assoc.h ===
//=================================================================
//
// assoc.h -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================

class CAssociation : public Provider
{
    public:

        CAssociation(
        LPCWSTR pwszClassName,
        LPCWSTR pwszNamespaceName,

        LPCWSTR pwszLeftClassName,
        LPCWSTR pwszRightClassName,

        LPCWSTR pwszLeftPropertyName,
        LPCWSTR pwszRightPropertyName
        );

        ~CAssociation();

        HRESULT ExecQuery(

            MethodContext* pMethodContext, 
            CFrameworkQuery &pQuery, 
            long lFlags 
        );

        HRESULT GetObject(

            CInstance* pInstance, 
            long lFlags,
            CFrameworkQuery &pQuery
        );

        HRESULT EnumerateInstances(

            MethodContext *pMethodContext,
            long lFlags /*= 0L*/
        );

    protected:
        
        bool IsInstance(const CInstance *pInstance);

        static HRESULT WINAPI StaticEnumerationCallback(

            Provider* pThat,
            CInstance* pInstance,
            MethodContext* pContext,
            void* pUserData
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT EnumerationCallback(

            CInstance *pRight, 
            MethodContext *pMethodContext, 
            void *pUserData
        );

        virtual HRESULT ValidateLeftObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT ValidateRightObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual BOOL AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return IsInstance(pLeft) && IsInstance(pRight);
        }

        virtual HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts
        );

        LPCWSTR m_pwszLeftClassName;
        LPCWSTR m_pwszRightClassName;

        LPCWSTR m_pwszLeftPropertyName;
        LPCWSTR m_pwszRightPropertyName;
};

/*
class CAssocSystemToOS : public CAssociation
{
    public:

        CAssocSystemToOS(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName

        );

        ~CAssocSystemToOS();

    protected:
        HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        );


};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\logmsg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.h: interface for the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
#define AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_
#define _LOGMESSAGE_INCLUDED_

#include <TCHAR.H>

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class LogMsg
{

    

private:

    TCHAR m_szLogFile[MAX_PATH];
    TCHAR m_szLogModule[MAX_PATH];
    int m_temp;

public:
	
    
                LogMsg          (int value);
	virtual     ~LogMsg         ();

    DWORD       Init            (LPCTSTR szLogFile, LPCTSTR szLogModule);
    DWORD       Log             (LPCTSTR file, int line, TCHAR *fmt, ...);

 //   static LogMsg GetLogObject();

};

// instantiated in LogMsg.cpp.
#ifndef _LOGMESSAGE_CPP_

extern LogMsg thelog;

#endif

// maks_todo : how to make sure that we get compiler error if we use macro with fewer parameters when we should have used macro with more parameters ?
// for example : LOGERROR1(_T("Show Two Values %s, %s"), firstvalue, secondvalue) how to catch this error during compilation ?
#define LOGMESSAGEINIT(logfile, module)                 thelog.Init(logfile, module)
#define LOGMESSAGE0(msg)                                thelog.Log(TEXT(__FILE__), __LINE__, msg)
#define LOGMESSAGE1(msg, arg1)                          thelog.Log(TEXT(__FILE__), __LINE__, msg, arg1)
#define LOGMESSAGE2(msg, arg1, arg2)                    thelog.Log(TEXT(__FILE__), __LINE__, msg, arg1, arg2)
#define LOGMESSAGE3(msg, arg1, arg2, arg3)              thelog.Log(TEXT(__FILE__), __LINE__, msg, arg1, arg2, arg3)
#define LOGMESSAGE4(msg, arg1, arg2, arg3, arg4)        thelog.Log(TEXT(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4)
#define LOGMESSAGE5(msg, arg1, arg2, arg3, arg4, arg5)  thelog.Log(TEXT(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4, arg5)

#endif // !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\logmsg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.cpp: implementation of the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#define _LOGMESSAGE_CPP_
//#define _UNICODE
#include "stdafx.h"
#include "LogMsg.h"
#include <conv.h>
#include <maksassert.h>
#include <malloc.h>

DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz);


// maks_todo: is there any standard file to be used for  logs.
//////////////////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////////////////
const UINT        LOG_ENTRY_SIZE             = 1024;
const UINT        STAMP_SIZE                 = 1024;
LPCTSTR           UNINITIALIZED              = _T("uninitialized");


//////////////////////////////////////////////////////////////////////
// globals.
////////////////////////////////////////////////////////////////////////
LogMsg thelog(26);  // used by LOGMESSAGE macros.


//////////////////////////////////////////////////////////////////////
// Construction / destruction
////////////////////////////////////////////////////////////////////////
LogMsg::LogMsg(int value)
{
    m_temp = value;
    _tcscpy(m_szLogFile, UNINITIALIZED);
}

LogMsg::~LogMsg()
{
    LOGMESSAGE0(_T("********Terminating Log"));
}

/*--------------------------------------------------------------------------------------------------------
* DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
* creates/opens the szLogFile for logging messages.
* must be called befour using the Log Function.
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
{
    USES_CONVERSION;
    ASSERT(szLogFile);
    ASSERT(szLogModule);

    // dont call this function twice.
    // maks_todo:why is the constructor not getting called?
    // maks_todo:enable this assert.
    //ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) == 0);

    ASSERT(_tcslen(szLogFile) < MAX_PATH);
    ASSERT(_tcslen(szLogModule) < MAX_PATH);

    _tcscpy(m_szLogFile, szLogFile);
    _tcscpy(m_szLogModule, szLogModule);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(m_szLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {

        // lets prepare for writing to the file.
        SetFilePointer(hfile, 0, NULL, FILE_END);
        DWORD  bytes;

        // get the current time/date stamp.
        TCHAR   time[STAMP_SIZE];
        TCHAR   date[STAMP_SIZE];
        TCHAR   output_unicode[LOG_ENTRY_SIZE];

        _tstrdate(date);
        _tstrtime(time);


        _stprintf(output_unicode, _T("\r\n\r\n*******Initializing Message Log:%s %s %s\r\n"), m_szLogModule, date, time);
        ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


        // TCharStringToAnsiString(output_unicode, output);

        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);


        // now write some more info about the version etc.
        OSVERSIONINFO OsV;
        OsV.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&OsV)== 0)
        {
            // get version failed.
            _stprintf(output_unicode, _T("GetVersionEx failed, ErrrorCode = %lu\r\n"), GetLastError());

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);

        }
        else
        {
            //
            // ok we have the version info, write it out
            //

            _stprintf(output_unicode, _T("*******Version:Major=%lu, Minor=%lu, Build=%lu, PlatForm=%lu, CSDVer=%s, %s\r\n\r\n"),
                OsV.dwMajorVersion,
                OsV.dwMinorVersion,
                OsV.dwBuildNumber,
                OsV.dwPlatformId,
                OsV.szCSDVersion,
#ifdef DBG
                _T("Checked")
#else
                _T("Free")
#endif
                );

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        }

        CloseHandle(hfile);
    }

    return GetLastError();
}


/*--------------------------------------------------------------------------------------------------------
* void log(TCHAR *fmt, ...)
* writes message to the log file. (LOGFILE)
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Log(LPCTSTR file, int line, TCHAR *fmt, ...)
{

    USES_CONVERSION;
    ASSERT(file);
    ASSERT(fmt);
//    ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) != 0);

     // write down file and line info into the buffer..
    TCHAR   fileline_unicode[LOG_ENTRY_SIZE];

    // file is actually full path to the file.
    ASSERT(_tcschr(file, '\\'));

    // we want to print only file name not full path
    UINT uiFileLen = _tcslen(file);
    while (uiFileLen && *(file + uiFileLen - 1) != '\\')
    {
        uiFileLen--;
    }
    ASSERT(uiFileLen);

    _stprintf(fileline_unicode, _T("%s(%d)"), (file+uiFileLen), line);



    // create the output string
    TCHAR  output_unicode[LOG_ENTRY_SIZE];
    va_list vaList;
    va_start(vaList, fmt);
    _vstprintf(output_unicode, fmt, vaList);
    va_end(vaList);

    ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);

        DWORD  bytes;
        const LPCSTR CRLF = "\r\n";
        WriteFile(hfile, T2A(fileline_unicode), _tcslen(fileline_unicode), &bytes, NULL);
        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        WriteFile(hfile, CRLF, strlen(CRLF) * sizeof(char), &bytes, NULL);

        CloseHandle(hfile);
    }

    return GetLastError();
}

/*--------------------------------------------------------------------------------------------------------
* TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
* converts the given TCHAR * to char *
* -------------------------------------------------------------------------------------------------------*/

DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
{

    ASSERT(tsz && asz);

#ifdef UNICODE
    DWORD count;

    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > STAMP_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}



// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\makefile.inc ===
$(O)\tscfgwmi.mof $(O)\tscfgwmi.mfl: tscfgwmi.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\tscfgwmi.mof -MFL:$(O)\tscfgwmi.mfl tscfgwmi.mof
    copy $(O)\tscfgwmi.mof+$(O)\tscfgwmi.mfl $(O)\tscfgwmi.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\maksassert.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*
*  Module Name:
*
*      maksassert.cpp
*
*  Abstract:
*
*      Implementas the assert functions.
*      maks_todo : use common assert macros instead.
*
*  Author:
*
*      Makarand Patwardhan  - March 6, 1998
*
*  Comments
*   This file is here only because I could not find the right friendly assert includes.
*    maks_todo : should be removed later.
*/

#include "stdafx.h"
#include "maksassert.h"
#include <TCHAR.h>
//#define _UNICODE

void MaksAssert(LPCTSTR exp, LPCTSTR file, int line)
{
    TCHAR szMsg[1024];
    _stprintf(szMsg, _T("assertion [%s] failed at [%s,%d]. Want to Debug?\n"), exp, file, line);

#if defined(_LOGMESSAGE_INCLUDED_)
    LOGMESSAGE0(szMsg);
#endif

    OutputDebugString(szMsg);

    if (MessageBox(0, szMsg, _T("TsOc.dll"), MB_YESNO  ) == IDYES )
    {
        DebugBreak();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (C) 2000 Microsoft Corp.
//
//***************************************************************************
#include "stdafx.h"
#include <FWcommon.h>
//#include <thrdbase.h>
#include <objbase.h>
#include <initguid.h>
#include <regapi.h>
#include <tchar.h>
//#include "LogMsg.h"
#include "trace.h"
#include "terminal.h"
#include "winstation.h"

HINSTANCE g_hInstance = NULL;

#ifdef UNICODE
#pragma message("Its unicode")
#else
#pragma message("Its ansi")
#endif 

//============

// {39524FB7-028F-4035-8C2B-8E65D2B17E67}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONDIRECTORY, 
0x39524fb7, 0x28f, 0x4035, 0x8c, 0x2b, 0x8e, 0x65, 0xd2, 0xb1, 0x7e, 0x67);

// {7970614A-BD82-439e-A828-CC96F8E91428}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINALSERVICE, 
0x7970614a, 0xbd82, 0x439e, 0xa8, 0x28, 0xcc, 0x96, 0xf8, 0xe9, 0x14, 0x28);

// {6BD6AECA-AFB0-45b7-BAC4-F292EC0F3F41}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINALSERVICESETTING, 
0x6bd6aeca, 0xafb0, 0x45b7, 0xba, 0xc4, 0xf2, 0x92, 0xec, 0xf, 0x3f, 0x41);

// {74628299-57EC-4f12-BA1C-08B477BF447A}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINAL,
0x74628299, 0x57ec, 0x4f12, 0xba, 0x1c, 0x8, 0xb4, 0x77, 0xbf, 0x44, 0x7a);

// {4C8A0917-F587-4ecf-9C89-48147528F4E1}
DEFINE_GUID(CLSID_CIM_WIN32_TSGENERALSETTING, 
0x4c8a0917, 0xf587, 0x4ecf, 0x9c, 0x89, 0x48, 0x14, 0x75, 0x28, 0xf4, 0xe1);

// {C41FF872-07B1-4926-819B-8C94E6B1FBB9}
DEFINE_GUID(CLSID_CIM_WIN32_TSLOGONSETTING, 
0xc41ff872, 0x7b1, 0x4926, 0x81, 0x9b, 0x8c, 0x94, 0xe6, 0xb1, 0xfb, 0xb9);

// {BE9B3133-250B-44a5-A278-C532B7B7FF76}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONSETTING, 
0xbe9b3133, 0x250b, 0x44a5, 0xa2, 0x78, 0xc5, 0x32, 0xb7, 0xb7, 0xff, 0x76);


// {9A17DFD1-34FA-4d61-B9BB-3A1097E7FADF}
DEFINE_GUID(CLSID_CIM_WIN32_TSENVIRONMENTSETTING, 
0x9a17dfd1, 0x34fa, 0x4d61, 0xb9, 0xbb, 0x3a, 0x10, 0x97, 0xe7, 0xfa, 0xdf);


// {DBD71B6B-F717-4a61-A914-2337BC50B0D6}
DEFINE_GUID(CLSID_CIM_WIN32_TSREMOTECONTROLSETTING, 
0xdbd71b6b, 0xf717, 0x4a61, 0xa9, 0x14, 0x23, 0x37, 0xbc, 0x50, 0xb0, 0xd6);


// {647BD8C2-658B-4eca-ABC7-FC5C0BF1704D}
DEFINE_GUID(CLSID_CIM_WIN32_TSCLIENTSETTING,
0x647bd8c2, 0x658b, 0x4eca, 0xab, 0xc7, 0xfc, 0x5c, 0xb, 0xf1, 0x70, 0x4d);


// {D25E0260-AAB7-48cb-A192-4D73D2FD375F}
DEFINE_GUID(CLSID_CIM_WIN32_TSNETWORKADAPTERSETTING,
0xd25e0260, 0xaab7, 0x48cb, 0xa1, 0x92, 0x4d, 0x73, 0xd2, 0xfd, 0x37, 0x5f);


// {FA06375D-F0A4-4a47-AD8D-148595F1E0B8}
DEFINE_GUID(CLSID_CIM_WIN32_TSPERMISSIONSSETTING, 
0xfa06375d, 0xf0a4, 0x4a47, 0xad, 0x8d, 0x14, 0x85, 0x95, 0xf1, 0xe0, 0xb8);


// {7757BA9B-7986-4866-B53F-A31E89FCBA15}
DEFINE_GUID(CLSID_CIM_WIN32_TSNETWORKADAPTERLISTSETTING, 
0x7757ba9b, 0x7986, 0x4866, 0xb5, 0x3f, 0xa3, 0x1e, 0x89, 0xfc, 0xba, 0x15);


// {BDF9E8B8-6C66-4e45-BA15-E050393DD079}
DEFINE_GUID(CLSID_CIM_WIN32_TSACCOUNT, 
0xbdf9e8b8, 0x6c66, 0x4e45, 0xba, 0x15, 0xe0, 0x50, 0x39, 0x3d, 0xd0, 0x79);


// {B490264C-8D8F-40fd-B1BE-CD69AD779EC1}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINALSERVICETOSETTING,
0xb490264c, 0x8d8f, 0x40fd, 0xb1, 0xbe, 0xcd, 0x69, 0xad, 0x77, 0x9e, 0xc1);

// {BA4EAC04-AFCE-441a-A4F0-C4A97545425A}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINALTERMINALSETTING, 
0xba4eac04, 0xafce, 0x441a, 0xa4, 0xf0, 0xc4, 0xa9, 0x75, 0x45, 0x42, 0x5a);

// {CCBA37FC-982B-433b-8AC2-455E616A8559}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONDIRECTORYSETTING, 
0xccba37fc, 0x982b, 0x433b, 0x8a, 0xc2, 0x45, 0x5e, 0x61, 0x6a, 0x85, 0x59);

CRITICAL_SECTION g_critsect;

CWin32_TerminalServiceSetting* g_pobj = NULL;

CWin32_TerminalService* g_pTerminalServiceObj = NULL;

CWin32_TSSessionDirectory* g_pTSSessionDirectoryObj = NULL;

CWin32_Terminal* g_pTerminalObj = NULL;

CWin32_TSGeneralSetting* g_pTSGeneralSettingObj = NULL;

CWin32_TSLogonSetting* g_pTSLogonSettingObj = NULL;

CWin32_TSSessionSetting* g_pTSSessionSettingObj = NULL;

CWin32_TSEnvironmentSetting* g_pTSEnvironmentSettingObj = NULL;

CWin32_TSRemoteControlSetting* g_pTSRemoteControlSettingObj = NULL;

CWin32_TSClientSetting* g_pTSClientSettingObj = NULL;

CWin32_TSNetworkAdapterSetting* g_pTSNetworkAdapterSettingObj = NULL;

CWin32_TSPermissionsSetting* g_pTSPermissionsSettingObj = NULL;

CWin32_TSNetworkAdapterListSetting* g_pTSNetworkAdapterListSettingObj = NULL;

CWin32_TSAccount* g_pTSAccountObj = NULL;

DEFINE_GUID(CLSID__CfgComp,0xBB0D7187,0x3C44,0x11D2,0xBB,0x98,0x30,0x78,0x30,0x2C,0x20,0x30);

DEFINE_GUID(IID__ICfgComp,0xBB0D7186,0x3C44,0x11D2,0xBB,0x98,0x30,0x78,0x30,0x2C,0x20,0x30);

//Count number of objects and number of locks.
long g_cLock=0;



/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue (

    wchar_t *pszKey, 
    wchar_t *pszSubkey, 
    wchar_t *pszValueName, 
    wchar_t *pszValue
)
{
    HKEY        hKey;
    TCHAR       szKey[MAX_PATH+1];

    if(lstrlen(pszKey) > MAX_PATH)
    {
        return FALSE;
    }
    
    lstrcpy(szKey, pszKey);    

    if (NULL!=pszSubkey && (lstrlen(pszKey)+lstrlen(pszSubkey)+1) <= MAX_PATH )
    {
        lstrcat(szKey, TEXT("\\"));
        lstrcat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, (LPCTSTR)pszValueName, 0, REG_SZ, (BYTE *)(LPCTSTR)pszValue
            , (_tcslen(pszValue)+1)*sizeof(TCHAR)))
            return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}


HRESULT RegisterServer (

    TCHAR *a_pName, 
    REFGUID a_rguid
)
{   
    WCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH];
    TCHAR * pName = TEXT("WBEM Framework Instance Provider");
    TCHAR * pModel;
    HKEY hKey1;

    GetModuleFileName(g_hInstance, szModule,  MAX_PATH);

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = TEXT("Apartment") ;
    else
        pModel = TEXT("Apartment") ;

    // Create the path.

    StringFromGUID2(a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

    lstrcat(szCLSID, wcID);

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID,TEXT("SOFTWARE\\CLASSES\\APPID\\"));

    lstrcat(szProviderCLSIDAppID, wcID);

    if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_pName ))
        return SELFREG_E_CLASS;
#endif

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)a_pName, (lstrlen(a_pName)+1) * 
        sizeof(TCHAR));


#ifdef LOCALSERVER

    if (FALSE ==SetKeyAndValue(szCLSID, TEXT("LocalServer32"), NULL,szModule))
        return SELFREG_E_CLASS;

    if (FALSE ==SetKeyAndValue(szCLSID, TEXT("LocalServer32"),TEXT("ThreadingModel"), pModel))
        return SELFREG_E_CLASS;
#else

    HKEY hKey2 ;
    RegCreateKey(hKey1, TEXT("InprocServer32"), &hKey2);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
        (lstrlen(szModule)+1) * sizeof(TCHAR));
    RegSetValueEx(hKey2, TEXT("ThreadingModel"), 0, REG_SZ, 
        (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(TCHAR));

    CloseHandle(hKey2);

#endif

    CloseHandle(hKey1);

    return S_OK;
}

HRESULT UnregisterServer (

    REFGUID a_rguid
)
{
    TCHAR    szID[128];
    WCHAR    wcID[128];
    TCHAR    szCLSID[128];
    HKEY    hKey;

    // Create the path using the CLSID

    StringFromGUID2( a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

    lstrcat(szCLSID, wcID);

    DWORD dwRet ;

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID,TEXT("SOFTWARE\\CLASSES\\APPID\\"));
    _tcscat(szProviderCLSIDAppID,szCLSID);

    //Delete entries under APPID

    DWORD hrStatus = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

    TCHAR szTemp[128];
    _stprintf(szTemp, TEXT("%s\\%s"),szCLSID, TEXT("LocalServer32"));
    hrStatus = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#else

    // First delete the InProcServer subkey.

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, TEXT("InProcServer32") );
        CloseHandle(hKey);
    }

#endif

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }
    else
    {
        ERR((TB,"UnregisterServer ret 0x%x\n", dwRet));
    }

    return HRESULT_FROM_WIN32( dwRet );
    
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if     it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    CWbemGlueFactory *pObj;

    if ( ( CLSID_CIM_WIN32_TERMINALSERVICESETTING == rclsid ) || 
        ( CLSID_CIM_WIN32_TERMINAL == rclsid ) || ( CLSID_CIM_WIN32_TSGENERALSETTING == rclsid ) ||
        ( CLSID_CIM_WIN32_TSLOGONSETTING == rclsid ) || ( CLSID_CIM_WIN32_TSSESSIONSETTING == rclsid ) ||
        ( CLSID_CIM_WIN32_TSENVIRONMENTSETTING == rclsid ) || ( CLSID_CIM_WIN32_TSCLIENTSETTING == rclsid ) ||
        ( CLSID_CIM_WIN32_TSNETWORKADAPTERSETTING == rclsid ) || ( CLSID_CIM_WIN32_TSPERMISSIONSSETTING == rclsid) ||
        ( CLSID_CIM_WIN32_TSNETWORKADAPTERLISTSETTING == rclsid ) || (CLSID_CIM_WIN32_TSACCOUNT == rclsid) ||
        ( CLSID_CIM_WIN32_TSREMOTECONTROLSETTING == rclsid ) || ( CLSID_CIM_WIN32_TERMINALSERVICE == rclsid ) || 
        ( CLSID_CIM_WIN32_TERMINALSERVICETOSETTING == rclsid ) || ( CLSID_CIM_WIN32_TERMINALTERMINALSETTING == rclsid) ||
        ( CLSID_CIM_WIN32_TSSESSIONDIRECTORYSETTING == rclsid ) || ( CLSID_CIM_WIN32_TSSESSIONDIRECTORY == rclsid ))

    {
        EnterCriticalSection(&g_critsect);

        try{
            pObj =new CWbemGlueFactory () ;

            if (NULL==pObj)
            {                
                hr =  E_OUTOFMEMORY;
            }
            else
            {            
                hr=pObj->QueryInterface(riid, ppv);

                if (FAILED(hr))
                    delete pObj;
            }

            if( SUCCEEDED(hr) )
            {
                // EnterCriticalSection prevents more than one threads from instantiating the global pointers to the objects.

                if( g_pobj == NULL )
                {                
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TerminalServiceSetting object created"));

                    g_pobj = new CWin32_TerminalServiceSetting( PROVIDER_NAME_Win32_WIN32_TERMINALSERVICESETTING_Prov, L"root\\cimv2"); 
                }

                if( g_pTerminalServiceObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TerminalService object created"));

                    g_pTerminalServiceObj = new CWin32_TerminalService( PROVIDER_NAME_Win32_WIN32_TERMINALSERVICE_Prov, L"root\\cimv2");
                }
    
                if( g_pTSSessionDirectoryObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSSessionDirectory object created"));

                    g_pTSSessionDirectoryObj = new CWin32_TSSessionDirectory( PROVIDER_NAME_Win32_WIN32_TSSESSIONDIRECTORY_Prov, L"root\\cimv2");

                }

                if( g_pTerminalObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_Terminal object created"));

                    g_pTerminalObj = new CWin32_Terminal( PROVIDER_NAME_Win32_WIN32_TERMINAL_Prov, L"root\\cimv2");
                }

                if( g_pTSGeneralSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSGeneralSetting object created"));

                    g_pTSGeneralSettingObj = new CWin32_TSGeneralSetting( PROVIDER_NAME_Win32_WIN32_TSGENERALSETTING_Prov, L"root\\cimv2");
                }

                if( g_pTSLogonSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSLogonSetting object created"));

                    g_pTSLogonSettingObj = new CWin32_TSLogonSetting( PROVIDER_NAME_Win32_WIN32_TSLOGONSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSSessionSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSSessionSetting object created"));

                    g_pTSSessionSettingObj = new CWin32_TSSessionSetting( PROVIDER_NAME_Win32_WIN32_TSSESSIONSETTING_Prov, L"root\\cimv2");
                }

                if( g_pTSEnvironmentSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSEnvironmentSetting object created"));

                    g_pTSEnvironmentSettingObj = new CWin32_TSEnvironmentSetting( PROVIDER_NAME_Win32_WIN32_TSENVIRONMENTSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSRemoteControlSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TRemoteControlSetting object created"));

                    g_pTSRemoteControlSettingObj = new CWin32_TSRemoteControlSetting( PROVIDER_NAME_Win32_WIN32_TSREMOTECONTROLSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSClientSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSClientSetting object created"));

                    g_pTSClientSettingObj = new CWin32_TSClientSetting( PROVIDER_NAME_Win32_WIN32_TSCLIENTSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSNetworkAdapterSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSNetworkAdapterSetting object created"));

                    g_pTSNetworkAdapterSettingObj = new CWin32_TSNetworkAdapterSetting( PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSPermissionsSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSPermissionsSetting object created"));

                    g_pTSPermissionsSettingObj = new CWin32_TSPermissionsSetting( PROVIDER_NAME_Win32_WIN32_TSPERMISSIONSSETTING_Prov, L"root\\cimv2");                     

                }

                if( g_pTSNetworkAdapterListSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSNetworkAdapterListSetting object created"));

                    g_pTSNetworkAdapterListSettingObj = new CWin32_TSNetworkAdapterListSetting( PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERLISTSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSAccountObj == NULL )
                {                
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSAccount object created"));

                    g_pTSAccountObj = new CWin32_TSAccount( PROVIDER_NAME_Win32_WIN32_TSACCOUNT_Prov, L"root\\cimv2");
                }
            }       
        }
        catch (...)
        {
            hr = E_OUTOFMEMORY;
        }

        LeaveCriticalSection(&g_critsect);

    }
    else
    {
        hr=E_FAIL;
        ERR((TB, "DllGetClassObject ret 0x%x\n" , hr));
    }

    return hr;
}



//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"TSCFGWMI"))
    {
        // EnterCriticalSection prevents multiple threads from accessing the global pointers concurrently and
        // allows only one thread access to free the objects based on the condition that g_cLock count is zero
        // and FrameworkLogoffDLL is TRUE.

		EnterCriticalSection(&g_critsect);

        if( g_pobj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TerminalServiceSetting object deleted"));

                delete g_pobj;

                g_pobj = NULL;
            }

            if( g_pTerminalServiceObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TerminalService object deleted"));

                delete g_pTerminalServiceObj;

                g_pTerminalServiceObj = NULL;
            }

            if( g_pTSSessionDirectoryObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSSessionDirectory object deleted"));

                delete g_pTSSessionDirectoryObj;

                g_pTSSessionDirectoryObj = NULL;
            }

            if( g_pTerminalObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_Terminal object deleted"));

                delete g_pTerminalObj;

                g_pTerminalObj = NULL;
            }

            if( g_pTSGeneralSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSGeneralSetting object deleted"));

                delete g_pTSGeneralSettingObj;

                g_pTSGeneralSettingObj = NULL;
            }

            if( g_pTSLogonSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSLogonSetting object deleted"));

                delete g_pTSLogonSettingObj;

                g_pTSLogonSettingObj = NULL;
            }

            if( g_pTSSessionSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSSessionSetting object deleted"));

                delete g_pTSSessionSettingObj;

                g_pTSSessionSettingObj = NULL;
            }

            if( g_pTSEnvironmentSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSEnvironmentSetting object deleted"));

                delete g_pTSEnvironmentSettingObj;

                g_pTSEnvironmentSettingObj = NULL;
            }

            if( g_pTSRemoteControlSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSRemoteControlSetting object deleted"));

                delete g_pTSRemoteControlSettingObj;

                g_pTSRemoteControlSettingObj = NULL;
            }

            if( g_pTSClientSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSClientSetting object deleted"));

                delete g_pTSClientSettingObj;

                g_pTSClientSettingObj = NULL;
            }

            if( g_pTSNetworkAdapterSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSNetworkAdapterSetting object deleted"));

                delete g_pTSNetworkAdapterSettingObj;

                g_pTSNetworkAdapterSettingObj = NULL;
            }

            if( g_pTSPermissionsSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSPermissionsSetting object deleted"));

                delete g_pTSPermissionsSettingObj;

                g_pTSPermissionsSettingObj = NULL;
            }

            if( g_pTSNetworkAdapterListSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSNetworkAdapterListSetting object deleted"));

                delete g_pTSNetworkAdapterListSettingObj;

                g_pTSNetworkAdapterListSettingObj = NULL;
            }

            if( g_pTSAccountObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSAccount object deleted"));

                delete g_pTSAccountObj;

                g_pTSAccountObj = NULL;
            }

            // LeaveCriticalSection releases the critical section once the thread has freed all objects.

		    LeaveCriticalSection(&g_critsect);

        sc = S_OK;
    }
    else
    {
        sc = S_FALSE;
     //   ERR((TB, "DllCanUnloadNow ret 0x%x\n" , sc));
    }

    return sc;
}







//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    HRESULT hrStatus;


    hrStatus = RegisterServer( TEXT("WBEM Win32_TERMINALSERVICESETTING Provider"), CLSID_CIM_WIN32_TERMINALSERVICESETTING ) ;
    
    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TERMINALSERVICESETTING: succeeded"));      

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TERMINAL Provider"), CLSID_CIM_WIN32_TERMINAL ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TERMINAL: succeeded"));
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TERMINALSERVICE Provider"), CLSID_CIM_WIN32_TERMINALSERVICE ) ;

    }


    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TERMINALSERVICE: succeeded"));
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONDIRECTORY Provider"), CLSID_CIM_WIN32_TSSESSIONDIRECTORY ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSSESSIONDIRECTORY: succeeded"));        
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSGENERALSETTING Provider"), CLSID_CIM_WIN32_TSGENERALSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSGENERALSETTING: succeeded")); 

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSLOGONSETTING Provider"), CLSID_CIM_WIN32_TSLOGONSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSLOGONSETTING: succeeded")); 
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONSETTING Provider"), CLSID_CIM_WIN32_TSSESSIONSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSSESSIONSETTING: succeeded"));

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSENVIRONMENTSETTING Provider"), CLSID_CIM_WIN32_TSENVIRONMENTSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSENVIRONMENTSETTING: succeeded"));
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSREMOTECONTROLSETTING Provider"), CLSID_CIM_WIN32_TSREMOTECONTROLSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSREMOTECONTROLSETTING: succeeded"));  

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSCLIENTSETTING Provider"), CLSID_CIM_WIN32_TSCLIENTSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSCLIENTSETTING: succeeded")); 
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSNETWORKADAPTERSETTING Provider"), CLSID_CIM_WIN32_TSNETWORKADAPTERSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSNETWORKADAPTERSETTING: succeeded"));
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSPERMISSIONSSETTING Provider"), CLSID_CIM_WIN32_TSPERMISSIONSSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSPERMISSIONSSETTING: succeeded"));
        
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSNETWORKADAPTERLISTSETTING Provider"), CLSID_CIM_WIN32_TSNETWORKADAPTERLISTSETTING ) ;

    }

    
    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSNETWORKADAPTERLISTSETTINGS: succeeded"));

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSACCOUNT Provider"), CLSID_CIM_WIN32_TSACCOUNT ) ;
    }


    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSACCOUNT: succeeded"));  
        
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TERMINALSERVICETOSETTING Provider"), CLSID_CIM_WIN32_TERMINALSERVICETOSETTING ) ;
    }

    if (SUCCEEDED( hrStatus ) )
    {
        TRC2((TB, "RegisterServer Win32_TERMINALSERVICETOSETTING: succeeded"));

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TERMINALTERMINALSETTING Provider"), CLSID_CIM_WIN32_TERMINALTERMINALSETTING ) ;
    }

    if (SUCCEEDED( hrStatus ) )
    {
        TRC2((TB, "RegisterServer Win32_TERMINALTERMINALSETTING: succeeded"));

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONDIRECTORYSETTING Provider"), CLSID_CIM_WIN32_TSSESSIONDIRECTORYSETTING ) ;
    }
    

    if (SUCCEEDED( hrStatus ) )
    {
        TRC2((TB, "RegisterServer Win32_TSSESSIONDIRECTORYSETTING: succeeded"));
    
    }

    return hrStatus;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    
    UnregisterServer( CLSID_CIM_WIN32_TERMINALSERVICE );

    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONDIRECTORY ) ;

    UnregisterServer( CLSID_CIM_WIN32_TERMINALSERVICESETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TERMINAL ) ;
    
    UnregisterServer( CLSID_CIM_WIN32_TSGENERALSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSLOGONSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSENVIRONMENTSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSREMOTECONTROLSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSCLIENTSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSNETWORKADAPTERSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSPERMISSIONSSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSNETWORKADAPTERLISTSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSACCOUNT ) ;

    UnregisterServer( CLSID_CIM_WIN32_TERMINALSERVICETOSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TERMINALTERMINALSETTING ) ;
    
    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONDIRECTORYSETTING ) ;

    return S_OK;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************


BOOL APIENTRY DllMain ( HINSTANCE hInstDLL, // handle to dll module
                        DWORD  fdwReason,    // reason for calling function
                        LPVOID lpReserved   )   // reserved
{
    BOOL bRet = TRUE;

    // Perform actions based on the reason for calling.
    if( DLL_PROCESS_ATTACH == fdwReason )
    {

        DisableThreadLibraryCalls(hInstDLL);
        // CriticalSection object is initialized on Thread attach.

        __try
        {
		    InitializeCriticalSection(&g_critsect);                
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
         {
	        return E_FAIL;
         }    
            
        g_hInstance = hInstDLL ;
      
        bRet = CWbemProviderGlue :: FrameworkLoginDLL ( L"TSCFGWMI" ) ;
        
    }

    else if( DLL_PROCESS_DETACH == fdwReason )
    {
        // CriticalSection object is deleted

		DeleteCriticalSection(&g_critsect);

    }

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\resource.h ===
/****************************************************************************/
// Resource.h
//
// Resource file for TsCfgComp.dll
//
// Copyright (C) 2000 Microsoft Corp.
/****************************************************************************/

#define IDS_ERR_ENUMTSSETTINGS 40000
#define IDS_ERR_ENUMTERMINAL 40001
#define IDS_ERR_ENUMTSGCONFIG 40002
#define IDS_ERR_ENUMTSLCONFIG 40003
#define IDS_ERR_ENUMTSSCONFIG 40004
#define IDS_ERR_ENUMTSECONFIG 40005
#define IDS_ERR_ENUMTSRCONFIG 40006
#define IDS_ERR_ENUMTSCCONFIG 40007
#define IDS_ERR_ENUMTSNCONFIG 40008
#define IDS_ERR_ENUMTSPCONFIG 40009
#define IDS_ERR_PUTTERMINAL 40010
#define IDS_ERR_PUTTSGCONFIG 40011
#define IDS_ERR_PUTTSLCONFIG 40012
#define IDS_ERR_PUTTSSCONFIG 40013
#define IDS_ERR_PUTTSECONFIG 40014
#define IDS_ERR_PUTTSRCONFIG 40015
#define IDS_ERR_PUTTSCCONFIG 40016
#define IDS_ERR_PUTTSNCONFIG 40017
#define IDS_ERR_PUTTSPCONFIG 40018
#define IDS_ERR_PUTINSTANCE 40019
#define IDS_ERR_ENUMINSTANCE 40020
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\precomp.h ===
#pragma message("Precompiling header...")
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

#include <fwcommon.h>
//#include "brodcast.h"
//#include "dllutils.h"
#include "smartptr.h"
//#include <strings.h>
//#include "ConfgMgr.h"
//#define MAXDWORD MAXULONG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\maksassert.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

#ifndef _maksassert_h_
#define _maksassert_h_
/*
*
*  Module Name:
*
*      maksassert.h
*
*  Abstract:
*
*      Defines assert, verify macros.
*      remove maksassert.h and maksassert.cpp from project when we get a good assert.
*       // maks_todo : remove this code when we get proper ASSERT headers.
*
*  Author:
*
*      Makarand Patwardhan  - March 6, 1998
*
*  Comments
*   This file is here only because I could not find the right friendly assert includes.
*    maks_todo : should be removed later.
*/

//#define _UNICODE

#ifdef DBG

void MaksAssert(LPCTSTR exp, LPCTSTR file, int line);

#undef ASSERT
#undef VERIFY
//;

#define ASSERT(exp) (void)( (exp) || (MaksAssert(_T(#exp), _T(__FILE__), __LINE__), 0) )
#define VERIFY(exp) (void)( (exp) || (MaksAssert(_T(#exp), _T(__FILE__), __LINE__), 0) )

#else

#define	ASSERT(exp)
#define VERIFY(exp) (exp)

#endif



#endif // _maksassert_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\registry.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.h
*
*  Abstract:
*
*      declaration of a simple registry class CRegistry.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#if !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)
#define AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000




#include <winreg.h>



#define ASSERT(x) NULL
#define VERIFY(x) NULL

class CRegistry
{
private:

    LPBYTE      m_pMemBlock;
    HKEY        m_hKey;
    int         m_iEnumIndex;
    int         m_iEnumValueIndex;

    DWORD       ReadReg             (LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype);
    void *      Allocate            (DWORD dwSize);



    //
    // This class is not designed to allow copy constructors, = assignments,
    // therefore we should ensure that copy ctor, assignment operator are not
    // generated by compiler. we do that by declaring these functions private
    // and not implementing them. This will ensure that these functions are
    // not generated by compilers, and caller will get error if he tries to
    // use them.
    //

                CRegistry           (const CRegistry &reg);     // copy ctor
  CRegistry &   operator=           (const CRegistry &reg);     // = oprerator



#ifdef DBG
    DWORD       m_dwSizeDebugOnly;
#endif

public:
                CRegistry           ();
    virtual     ~CRegistry          ();
    void        Release             ();

    operator    HKEY                ()    {return m_hKey;}


    DWORD       OpenKey             (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS);
    DWORD       CreateKey           (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, DWORD *pDisposition = NULL, LPSECURITY_ATTRIBUTES lpSecAttr  = NULL );

    DWORD       DeleteValue         (LPCTSTR lpValue);
    DWORD       RecurseDeleteKey    (LPCTSTR lpSubKey);

    DWORD       ReadRegString       (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegDWord        (LPCTSTR lpValue, DWORD *pdw);
    DWORD       ReadRegMultiString  (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegBinary       (LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw);

    DWORD       WriteRegString      (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegDWord       (LPCTSTR lpValueName, DWORD dwValue);
    DWORD       WriteRegMultiString (LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize);


    DWORD       GetFirstSubKey      (LPTSTR *lppStr, DWORD *pdw);
    DWORD       GetNextSubKey       (LPTSTR *lppStr, DWORD *pdw);

    DWORD       GetFirstValue       (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);
    DWORD       GetNextValue        (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);

    DWORD       GetSecurity         (PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize);
    DWORD       SetSecurity         (PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation);

};

#endif // !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\registry.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.cpp
*
*  Abstract:
*
*      Registry.cpp: implementation of the CRegistry class.
*      This class helps with registry by allocating memory by itself
*      As a result caller must copy the pointer returned by Get functions
*      immediately.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/
#include "stdafx.h"
#include <fwcommon.h>  // This must be the first include.

#include "Registry.h"


/*--------------------------------------------------------------------------------------------------------
* Constructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::CRegistry()
{
    m_pMemBlock = NULL;
    m_hKey = NULL;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;

#ifdef DBG
    m_dwSizeDebugOnly = 0;
#endif
}

/*--------------------------------------------------------------------------------------------------------
* Destructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::~CRegistry()
{
    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
    Release();
}

/*--------------------------------------------------------------------------------------------------------
* void Allocate (DWORD dwSize)
* This private function is used for allocating the memory for
* reading registry
* returns the pointer to memory allocated.
* -------------------------------------------------------------------------------------------------------*/
void *CRegistry::Allocate (DWORD dwSize)
{
    ASSERT(dwSize != 0);
    if (m_pMemBlock)
        Release();
    
    m_pMemBlock = new BYTE[dwSize];

#ifdef DBG
    // remember the size of the block to be allocated.
    m_dwSizeDebugOnly = dwSize;
#endif

    return m_pMemBlock;
}

/*--------------------------------------------------------------------------------------------------------
* void Release ()
* This private function is used for releasing internal memory block
* -------------------------------------------------------------------------------------------------------*/
void CRegistry::Release ()
{
    if (m_pMemBlock)
    {

#ifdef DBG
        // fistly fill up the block we allocated previously with garbage.
        // so that if anybody is using this block, it is more lilely to 
        // catch the bug.
        ASSERT(m_dwSizeDebugOnly != 0);
        FillMemory(m_pMemBlock, m_dwSizeDebugOnly, 'c');
        m_dwSizeDebugOnly = 0;

#endif

        delete [] m_pMemBlock;
    }
    
    m_pMemBlock = 0;
}


///*--------------------------------------------------------------------------------------------------------
//* DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
//* opens/creates the key specified. before attempting any operation on any key/value. this function
//* must be called.
//* hKey - hive
//* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
//* access - access desired. like REG_READ, REG_WRITE..
//* RETURNS error code.
//* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    // security descriptor should be null or it should be a valid one.
    ASSERT(!lpSecAttr || IsValidSecurityDescriptor(lpSecAttr->lpSecurityDescriptor));

    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(
                    hKey,               // handle of an open key
                    lpSubKey,           // address of subkey name
                    0,                  // reserved
                    NULL,               // address of class string
                    REG_OPTION_NON_VOLATILE ,  // special options flag
                    access,             // desired security access
                    lpSecAttr,          // address of key security structure
                    &m_hKey,            // address of buffer for opened handle
                    &dwDisposition      // address of disposition value buffer
                    );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    if (pDisposition)
        *pDisposition = dwDisposition;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access) ()
* opens the key specified. before attempting any operation on any key/value. this function
* must be called.
* hKey - hive
* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
* access - access desired. like REG_READ, REG_WRITE..
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/ )
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    LONG lResult = RegOpenKeyEx(
        hKey,                       // handle of open key
        lpSubKey,                   // address of name of subkey to open
        0 ,                         // reserved
        access,                     // security access mask
        &m_hKey                     // address of handle of open key
        );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    return lResult;
}

DWORD CRegistry::DeleteValue (LPCTSTR lpValue)
{
    ASSERT(lpValue);
    ASSERT(m_hKey);
    return RegDeleteValue(m_hKey, lpValue);

}
DWORD CRegistry::RecurseDeleteKey (LPCTSTR lpSubKey)
{
    ASSERT(lpSubKey);
    ASSERT(m_hKey);

    CRegistry reg;
    DWORD dwError = reg.OpenKey(m_hKey, lpSubKey);
    if (dwError != ERROR_SUCCESS)
        return dwError;


    LPTSTR lpChildKey;
    DWORD  dwSize;

    // we needn't/shouldn't use GetNextSubKey in this here
    // as we are deleting the key during the loop.
    while (ERROR_SUCCESS == reg.GetFirstSubKey(&lpChildKey, &dwSize))
    {
        VERIFY(reg.RecurseDeleteKey(lpChildKey) == ERROR_SUCCESS);
    }

    return RegDeleteKey(m_hKey, lpSubKey);

}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
* Reads the registry used internally.
* LPCTSTR lpValue - value to be read.
* LPBYTE *lppbyte - address of the lpbyte at which to place the output buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* dword datatype - datatype you are expecting.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
{
    ASSERT(lpValue);
    ASSERT(lppbyte);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    *pdw = 0;

    DWORD dwType;
    DWORD lResult = RegQueryValueEx(
        m_hKey,             // handle of key to query
        lpValue,            // address of name of value to query
        0,                  // reserved
        &dwType,            // address of buffer for value type 
        0,                  // address of data buffer 
        pdw                 // address of data buffer size 
        ); 
    
    if (lResult == ERROR_SUCCESS)
    {
        ASSERT(dwType == dwDatatype || dwType == REG_EXPAND_SZ);
    
        if (0 == Allocate(*pdw))
            return ERROR_OUTOFMEMORY;

        lResult = RegQueryValueEx( 
            m_hKey,                 // handle of key to query 
            lpValue,                // address of name of value to query
            0,                      // reserved 
            &dwType,                // address of buffer for value type 
            m_pMemBlock,            // address of data buffer 
            pdw                     // address of data buffer size 
            ); 
    
        ASSERT (ERROR_MORE_DATA != lResult);
    
        if (lResult == ERROR_SUCCESS)
            *lppbyte = m_pMemBlock;
    }
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* DWORD  *pdw  - address of dword in which the read dword returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
{
    ASSERT(pdw);

    DWORD dwSize;
    LPBYTE pByte;
    DWORD dwReturn = ReadReg(lpValue, &pByte, &dwSize, REG_DWORD);
    //ASSERT(dwReturn != ERROR_SUCCESS || dwSize == sizeof(DWORD));

    if (dwReturn == ERROR_SUCCESS)
        *pdw = * LPDWORD(pByte);

    return dwReturn;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_MULTI_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPBYTE *lppByte - address of LPBYTE in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
{
    return ReadReg(lpValue, lppByte, pdw, REG_BINARY);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
* Reads a first subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    m_iEnumIndex = 0;
    
    return GetNextSubKey(lppStr, pdw);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextSubKey(LPTSTR *lppStr, DWORD *pdw
* Reads the next subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumIndex >= 0); // must call GetFirstSubKey first.
    
    //FILETIME unused;
    
    *pdw = 256;
    if (0 == Allocate(*pdw))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumKeyEx( 
        m_hKey,                     // handle of key to enumerate 
        m_iEnumIndex,               // index of subkey to enumerate 
        (LPTSTR)m_pMemBlock,        // address of buffer for subkey name 
        pdw,                        // address for size of subkey buffer 
        0,                          // reserved 
        NULL,                       // address of buffer for class string 
        NULL,                       // address for size of class buffer 
        NULL                        // address for time key last written to 
        ); 
    
    (*pdw)++;    // since null is not included in the size.
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;
    
    m_iEnumIndex++;
    
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a first value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);

    m_iEnumValueIndex = 0;
    return GetNextValue(lppStr, pdw, pDataType);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a next value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumValueIndex >= 0); // must call GetFirstSubKey first.
    
    *pdw = 256;
    if (0 == Allocate(*pdw))
        return ERROR_NOT_ENOUGH_MEMORY;
    
    LONG lResult = RegEnumValue( 
        m_hKey,                     // handle of key to query 
        m_iEnumValueIndex,          // index of value to query 
        (LPTSTR)m_pMemBlock,        // address of buffer for value string 
        pdw,                        // address for size of value buffer 
        0,                          // reserved 
        pDataType,                  // address of buffer for type code 
        NULL,                       // address of buffer for value data    maks_todo : use this
        NULL                        // address for size of data buffer 
        ); 
    
    (*pdw)++;    // since null is not included in the size.
    
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;
    
    
    m_iEnumValueIndex++;
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
* writes REG_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR lpStr - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = ( lstrlen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx( 
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_SZ,                 // flag for value type 
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
* writes REG_MULTI_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

#ifdef DBG
    
    // lets make sure that the given size is right.
    LPCTSTR lpTemp = lpStr;
    DWORD rightsize = 0;
    while (lstrlen(lpTemp) > 0)
    {
        rightsize  += lstrlen(lpTemp) + 1;
        lpTemp += lstrlen(lpTemp) + 1;
    }

    ASSERT(*lpTemp == 0);           // final NULL.
    rightsize++;                    // account for final terminating null

    rightsize *= sizeof(TCHAR) / sizeof(BYTE); // size must be in bytes.

    ASSERT(dwSize == rightsize);
    
#endif

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_MULTI_SZ,           // flag for value type
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
* writes REG_DWORD value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR dwValue - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);

    return RegSetValueEx( 
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_DWORD,              // flag for value type
        (LPBYTE)&dwValue,       // address of value data 
        sizeof(dwValue)         // size of value data 
        ); 
}

// copy the buffer immediately
DWORD CRegistry::GetSecurity(PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(ppSec);
    ASSERT(pdwSize);
    DWORD dwError;

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    *pdwSize = 0;   // we just want to get the right size during the first call.
    
    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        &pSecurityDescriptor,    // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    // this call can not succeed. as we have set the size = 0
    ASSERT(dwError != ERROR_SUCCESS);

    if (dwError != ERROR_INSUFFICIENT_BUFFER)
    {
        // something else has went wronng.
        // return the error code
        return dwError;
    }

    ASSERT(*pdwSize != 0);

    // now we have got the right size, allocate it.
    if (0 == Allocate(*pdwSize))
        return ERROR_OUTOFMEMORY;

    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        m_pMemBlock,             // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    ASSERT(dwError != ERROR_INSUFFICIENT_BUFFER);
    
    if (dwError == ERROR_SUCCESS)
        *ppSec = m_pMemBlock;

    return dwError;
           
}

DWORD CRegistry::SetSecurity(PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    return RegSetKeySecurity(
        m_hKey,                 // open handle of key to set
        SecurityInformation,    // descriptor contents
        pSec                    // address of descriptor for key
        );
}


#ifdef _Maks_AutoTest_

//
// make sure that CRegistry does not support
// Copy constructor & assignment operator
//
void TestRegistry (CRegistry reg)
{
    CRegistry reg2 = reg;   // should get error for copy constructor
    CRegistry reg3(reg);     // should get error for copy constructor
    CRegistry reg4;
    reg4 = reg;             // should get error for = operator.
    TestRegistry(reg);       // should get error for copy construtor
}

#endif // _Maks_AutoTest_

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\stdafx.h ===
/****************************************************************************/
// stdafx.h
//
// Copyright (C) 2000 Microsoft Corp.
/****************************************************************************/

#ifndef _STDAFX_H_
#define _STDAFX_H_

#include "cfgbkend.h"

extern HINSTANCE g_hInstance;

#ifdef DBG


#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[256]; \
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }

#define ODS OutputDebugString

#else

#define DBGMSG
#define ODS

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\smartptr.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  SmartPtr.h
//
//  Purpose: Declare smartpointer typedefs
//
//***************************************************************************

#pragma once
#include <io.h>

#include <comdef.h>

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));


_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IUnsecuredApartment, __uuidof(IUnsecuredApartment));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));
_COM_SMARTPTR_TYPEDEF(IWbemRefresher, __uuidof(IWbemRefresher));
_COM_SMARTPTR_TYPEDEF(IWbemHiPerfEnum, __uuidof(IWbemHiPerfEnum));
_COM_SMARTPTR_TYPEDEF(IWbemConfigureRefresher, __uuidof(IWbemConfigureRefresher));
_COM_SMARTPTR_TYPEDEF(IMofCompiler, __uuidof(IMofCompiler));
_COM_SMARTPTR_TYPEDEF(ExternalMethodContext, __uuidof(ExternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContext, __uuidof(InternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContextAsynch, __uuidof(InternalMethodContextAsynch));

class SmartCloseHandle
{

private:
	HANDLE m_h;

public:
	SmartCloseHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseHandle(HANDLE h):m_h(h){}
   ~SmartCloseHandle(){if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class Smart_findclose
{

private:
	long m_h;

public:
	Smart_findclose():m_h(0){}
	Smart_findclose(long h):m_h(h){}
   ~Smart_findclose(){if (m_h!=0) _findclose(m_h);}
	long operator =(long h) {if (m_h) _findclose(m_h); m_h=h; return h;}
	operator long() const {return m_h;}
	long* operator &() {if (m_h) _findclose(m_h); m_h = 0; return &m_h;}
};

class SmartFindClose
{

private:
	HANDLE m_h;

public:
	SmartFindClose():m_h(INVALID_HANDLE_VALUE){}
	SmartFindClose(HANDLE h):m_h(h){}
   ~SmartFindClose(){if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class SmartCloseServiceHandle
{

private:
	SC_HANDLE m_h;

public:
	SmartCloseServiceHandle():m_h(NULL){}
	SmartCloseServiceHandle(SC_HANDLE h):m_h(h){}
   ~SmartCloseServiceHandle(){if (m_h!=NULL) CloseServiceHandle(m_h);}
	SC_HANDLE operator =(SC_HANDLE h) {if (m_h!=NULL) CloseServiceHandle(m_h); m_h=h; return h;}
	operator SC_HANDLE() const {return m_h;}
	SC_HANDLE* operator &() {if (m_h!=NULL) CloseServiceHandle(m_h); m_h = NULL; return &m_h;}
};

class CSmartCreatedDC
{
public:
    CSmartCreatedDC(HDC hdc) { m_hdc = hdc;}
	operator HDC() const {return m_hdc;}
    ~CSmartCreatedDC() 
    { 
        if (m_hdc)
            DeleteDC(m_hdc); 
    }

protected:
    HDC m_hdc;
};

class CSmartBuffer
{
private:
	LPBYTE m_pBuffer;

public:
	CSmartBuffer() : m_pBuffer(NULL) {}
	CSmartBuffer(LPBYTE pBuffer) : m_pBuffer(pBuffer) {}
    CSmartBuffer(DWORD dwSize)
    {
        m_pBuffer = new BYTE[dwSize];
        if (m_pBuffer == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    ~CSmartBuffer()
    {
        Free();
    }

	LPBYTE operator =(LPBYTE pBuffer) 
    {
        Free();
            
        m_pBuffer = pBuffer; 
        
        return m_pBuffer;
    }
	
    operator LPBYTE() const { return m_pBuffer; }
	
    LPBYTE* operator &()
    {
        Free();

        m_pBuffer = NULL;
        
        return &m_pBuffer;
    }

protected:
    void Free()
    {
        if (m_pBuffer != NULL) 
        {
            delete [] m_pBuffer;
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\trace.h ===
/****************************************************************************/
// trace.h
//
// Tracing definitions. See trace.c for other information.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#if DBG || defined(_DEBUG)

#include <stdio.h>


// Zones. Up to 32 zones can be defined, these are predefined for general use.
#define Z_ASSRT 0x01
#define Z_ERR    0x02
#define Z_WRN    0x04
#define Z_TRC1   0x08
#define Z_TRC2   0x10

// Defined in msmcs.c.
extern char TB[1024];
extern UINT32 g_TraceMask;
void TracePrintZ(UINT32, char *);

// Error, warning, trace level 1, and trace level 2 definitions.
#define ERR(X) TRCZ(Z_ERR, X)
#define WRN(X) TRCZ(Z_WRN, X)
#define TRC1(X) TRCZ(Z_TRC1, X)
#define TRC2(X) TRCZ(Z_TRC2, X)
#define ASSRT(COND, X) \
{  \
    if (!(COND)) { \
        TRCZ(Z_ASSRT, X); \
        DebugBreak(); \
    }  \
}

#define TRCZ(Z, X) \
{ \
    if (g_TraceMask & (Z)) { \
        sprintf X; \
        TracePrintZ((Z), TB); \
    } \
}


#else  // DBG

#define ERR(X)
#define WRN(X)
#define TRC1(X)
#define TRC2(X)
#define ASSRT(COND, X)

#endif  // DBG



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\terminal.h ===
/******************************************************************
   Copyright (C) 2000 Microsoft Corp.

   Terminal.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _TerminalWinstation_H_
#define _TerminalWinstation_H_
#include "resource.h"
#include <winsta.h>
#include <regapi.h>
#include <utilsub.h>
#include <allproc.h>
#include "trace.h"


#define PROVIDER_NAME_Win32_WIN32_TERMINALSERVICESETTING_Prov L"Win32_TerminalServiceSetting"
#define PROVIDER_NAME_Win32_WIN32_TSPROVIDER_Prov L"Win32_TSProvider"
#define PROVIDER_NAME_Win32_WIN32_TERMINALSERVICE_Prov L"Win32_TerminalService"
#define PROVIDER_NAME_Win32_WIN32_TSSESSIONDIRECTORY_Prov L"Win32_TSSessionDirectory"



#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

extern BOOL g_bInitialized;

// See ExecQuery for details of the usage of these #defines
#define BIT_MODE                            0x00000001
#define BIT_LICENSING                       0x00000002
#define BIT_ACTIVEDESKTOP                   0x00000004
#define BIT_USERPERM                        0x00000008
#define BIT_DELETETEMPDIRS                  0x00000010
#define BIT_PERSESSIONTEMPDIR               0x00000020
#define BIT_LOGONS                          0x00000040
#define BIT_TOTALSESSIONS                   0x00000080
#define BIT_DISCONNECTEDSESSIONS            0x00000100
#define BIT_ESTIMATEDSESSIONCAPACITY        0x00000200
#define BIT_RESOURCECONSTRAINT              0x00000400
#define BIT_RAWSESSIONCAPACITY              0x00000800
#define BIT_SESSIONDIRECTORY                0x00001000
#define BIT_CLUSTERNAME                     0x00002000
#define BIT_HELP                            0x00004000
#define BIT_ADDITIONALPARAMS                0x00008000
#define BIT_SESSIONDIRECTORYACTIVE          0x00010000
#define BIT_ALLOWTSCONNECTIONS              0x00020000
#define BIT_SINGLESESSION                   0x00040000
#define BIT_PROFILEPATH                     0x00080000
#define BIT_HOMEDIRECTORY                   0x00100000
#define BIT_SESSIONDIRECTORYEXPOSESERVERIP  0x00200000
#define BIT_DIRECTCONNECTLICENSESERVERS     0x00400000
#define BIT_SERVERNAME                      0x00800000

#define BIT_ALL_PROPERTIES 0xffffffff

#define SESSDIR_LENGTH 64
#define OPAQUESETTINGS_LENGTH 256 

// Property name externs -- defined in Terminal.cpp
//=================================================

//=--------------------------


class CStackClass
{
    public:
        // Constructor/destructor
        //=======================

        CStackClass();
        virtual ~CStackClass();
        IClassFactory *m_pCfg;
        ICfgComp *m_pCfgComp;
		

    protected:
        // Reading Functions
        //============================
        

        // Writing Functions    
        //============================
       

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CTerminalWinstation should be included here.  
		
   
        
} ;

//=----------



class CWin32_TerminalService : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_TerminalService( LPCWSTR lpwszName, LPCWSTR lpwszNameSpace );
        virtual ~CWin32_TerminalService();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
       

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

        HRESULT LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties, WINSTATIONLOADINDICATORDATA LIData);
    

    private:
        // All data members for CTerminalWinstation should be included here.  
        
      
        TCHAR m_szTotalSessions[ 64 ];
        TCHAR m_szDisconnectedSessions[ 64 ];
        TCHAR m_szEstimatedSessionCapacity[ 64 ];
        TCHAR m_szResourceConstraint[ 64 ];
        TCHAR m_szRawSessionCapacity[ 64 ];
        TCHAR m_szName[ 64 ];
        TCHAR m_szCaption[ 64 ];
       
        
} ;



//=---------


class CWin32_TerminalServiceSetting : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_TerminalServiceSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CWin32_TerminalServiceSetting();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        virtual HRESULT ExecMethod(const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags = 0L );

        HRESULT LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties);


        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CTerminalWinstation should be included here.  
    //    BOOL m_bInitialized;

        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);

        ISettingsComp *m_pSettings;
        POLICY_TS_MACHINE m_gpPolicy;
        TCHAR m_szServerName[ 64 ];
        TCHAR m_szMode[ 64 ];
        TCHAR m_szLicensingName[ 64 ];
        TCHAR m_szLicensingDescription[ 512 ];
        TCHAR m_szActiveDesktop[ 64 ];
        TCHAR m_szUserPerm[ 64 ];
        TCHAR m_szDeleteTempFolders[ 64 ];
        TCHAR m_szUseTempFolders[ 64 ];
        TCHAR m_szLogons[ 64 ];
        TCHAR m_szHelp[ 64 ];
        TCHAR m_szPropertyName[ 64 ];
        TCHAR m_szValue[ 64 ];
        TCHAR m_szChangeMode[ 64 ];
        TCHAR m_szSetPolicyPropertyName[ 64 ];
        TCHAR m_szLicensingType[ 64 ];
        TCHAR m_szAllowTSConnections[ 64 ];
        TCHAR m_szSetAllowTSConnections[ 64 ];
        TCHAR m_szSingleSession[ 64 ];
        TCHAR m_szSetSingleSession[ 64 ];
        TCHAR m_szProfilePath[ 64 ];
        TCHAR m_szHomeDirectory[ 64 ];
        TCHAR m_szSetProfilePath[ 64 ];
        TCHAR m_szSetHomeDirectory[ 64 ];
        TCHAR m_szAddDirectConnectLicenseServer[ 64 ];
        TCHAR m_szDeleteDirectConnectLicenseServer[ 64 ];
        TCHAR m_szLicenseServerName[ 64 ];
        TCHAR m_szDirectConnectLicenseServers[ 64 ];
      
        
} ;


//=---------


class CWin32_TSSessionDirectory : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_TSSessionDirectory(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CWin32_TSSessionDirectory();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
   //     virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        virtual HRESULT ExecMethod(const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags = 0L );

        HRESULT LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties);


        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CTerminalWinstation should be included here.  
    //    BOOL m_bInitialized;

        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);

   //     ADOConnection *m_pConnection;
        POLICY_TS_MACHINE m_gpPolicy;
        TCHAR m_szMode[ 64 ];
        TCHAR m_szSessionDirectoryActive[ 64 ];
        TCHAR m_szSessionDirectoryLocation[ 64 ];
        TCHAR m_szSessionDirectoryClusterName[ 64 ];
        TCHAR m_szSessionDirectoryExposeServerIP[ 64 ];
//        TCHAR m_szSessionDirectoryAdditionalParams[ 64 ];
        TCHAR m_szSetSessionDirectoryProperty[ 64 ];
        TCHAR m_szSetSessionDirectoryActive[ 64 ];
        TCHAR m_szSetSessionDirectoryExposeServerIP[ 64 ];
        TCHAR m_szPropertyName[ 64 ];
        TCHAR m_szValue[ 64 ];
        
} ;




//-----------------------Changed--------------------------

// struct to hold instance information


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\trace.cpp ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/
#include "stdafx.h"
#include <windows.h>
#include "trace.h"

#if DBG || defined(_DEBUG)



struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSRT,  "TERMSRV@TSCFGWMI: !!! ASSERT: " },
    { Z_ERR,    "TERMSRV@TSCFGWMI: *** ERROR: " },
    { Z_WRN,    "TERMSRV@TSCFGWMI: Warning: " },
    { Z_TRC1,   "TERMSRV@TSCFGWMI: " },
    { Z_TRC2,   "TERMSRV@TSCFGWMI: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
//UINT32 g_TraceMask = 0xFFFFFFFF;
UINT32 g_TraceMask = 0x0000000F;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

    // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\terminal.cpp ===
/******************************************************************
   Copyright (C) 2000 Microsoft Corp.

   Terminal.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/
#include "stdafx.h"
#include <fwcommon.h>
#include "Terminal.h"
#include "registry.h"
#include "smartptr.h"
#include <windows.h>
#include "cfgbkend_i.c"


#define TS_PATH TEXT("SYSTEM\\ControlSet\\Control\\Terminal Server")
#define TS_LOGON_PATH TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define TERMINAL_SERVICE_PARAM_DISCOVERY  TEXT("SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters")
#define TERMINAL_SERVICE_PARAM_DISCOVERY_SERVERS  TEXT("SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters\\LicenseServers")


extern TCHAR tchErrorMessage[ 80 ];



// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================


// Property names
//===============


// Property names
//===============

const static WCHAR* pErrorClass = L"\\\\.\\root\\cimv2:TerminalServiceSettingError";


CStackClass::CStackClass ( )
{
    HRESULT hr;

    m_pCfg = NULL;
    m_pCfgComp = NULL;

    hr = CoGetClassObject(CLSID_CfgComp, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&m_pCfg); 
    
    TRC2((TB, "StackClass@Constructor: CoGetClassObject of IClassFactory ret 0x%x", hr));

    if( SUCCEEDED ( hr ) && m_pCfg != NULL )
    {           
        hr = m_pCfg->CreateInstance(NULL, IID_ICfgComp, (void **)&m_pCfgComp); 
        
        TRC2((TB, "StackClass@Constructor: CoCreateInstance of ICfgComp ret 0x%x", hr));
        
        if( SUCCEEDED ( hr ) && m_pCfgComp != NULL )
        {            
            hr = m_pCfgComp->Initialize( );
        }
        else
        {
            m_pCfgComp = NULL;
        }        
    }   
    else
    {
        m_pCfgComp = NULL;
        m_pCfg = NULL;
    }
}


//=--------------------
/******************************************************************************************************
*
*DESCRIPTION :     CWin32_TSProvider class is a base class from which all other classes are derived.
*                  The destructor releases the CfgBkEnd interface pointer.
*                  
********************************************************************************************************/

CStackClass::~CStackClass ()
{
    if ( NULL != m_pCfgComp )
    {
        m_pCfgComp->Release();
       
        TRC2((TB, "StackClass@Destructor for ICfgComp: succeeded"));        
    }    
    if ( NULL != m_pCfg )
    {
        m_pCfg->Release();
       
        TRC2((TB, "StackClass@Destructor for IClassFactory: succeeded"));       
    }
}



//------------------------




/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_TerminalServiceSetting::CWin32_TerminalServiceSetting
 *                  This class reads and sets the Server Settings such as Terminal
 *                  server mode, license type, active desktop state, temp folders,
 *                  logon and Help.
 *
 *****************************************************************************/
CWin32_TerminalServiceSetting::CWin32_TerminalServiceSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
   
    if ( g_hInstance != NULL)
    {

        TRC2((TB, "CWin32_TerminalServiceSetting_ctor"));       

        _tcscpy(m_szServerName, _T("ServerName"));

        _tcscpy(m_szMode, _T("TerminalServerMode"));

        _tcscpy(m_szLicensingName, _T("LicensingName"));

        _tcscpy(m_szLicensingDescription, _T("LicensingDescription"));

        _tcscpy(m_szActiveDesktop, _T("ActiveDesktop"));

        _tcscpy(m_szUserPerm, _T("UserPermission"));

        _tcscpy(m_szDeleteTempFolders, _T("DeleteTempFolders"));

        _tcscpy(m_szUseTempFolders, _T("UseTempFolders"));

        _tcscpy(m_szLogons, _T("Logons"));

        _tcscpy(m_szHelp, _T("Help"));

        _tcscpy(m_szValue, _T("Value"));

        _tcscpy(m_szPropertyName, _T("PropertyName"));
        
        _tcscpy(m_szChangeMode, _T("ChangeMode"));

        _tcscpy(m_szLicensingType, _T("LicensingType"));

        _tcscpy(m_szSetPolicyPropertyName, _T("SetPolicyPropertyName"));

        _tcscpy(m_szAllowTSConnections, _T("AllowTSConnections"));

        _tcscpy(m_szSetAllowTSConnections, _T("SetAllowTSConnections"));

        _tcscpy(m_szSingleSession, _T("SingleSession"));

        _tcscpy(m_szSetSingleSession, _T("SetSingleSession"));

        _tcscpy(m_szProfilePath, _T("ProfilePath"));

        _tcscpy(m_szHomeDirectory, _T("HomeDirectory"));

        _tcscpy(m_szSetProfilePath, _T("SetProfilePath"));

        _tcscpy(m_szSetHomeDirectory, _T("SetHomeDirectory"));

        _tcscpy(m_szDirectConnectLicenseServers, _T("DirectConnectLicenseServers"));

        _tcscpy(m_szAddDirectConnectLicenseServer, _T("AddDirectConnectLicenseServer"));

        _tcscpy(m_szDeleteDirectConnectLicenseServer, _T("DeleteDirectConnectLicenseServer"));

        _tcscpy(m_szLicenseServerName, _T("LicenseServerName"));
        
    }        
    RegGetMachinePolicy(&m_gpPolicy);
                                                                                                                       
}

//=-------------
/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_TerminalServiceSetting::~CWin32_TerminalServiceSetting
 *****************************************************************************/
CWin32_TerminalServiceSetting::~CWin32_TerminalServiceSetting ()
{
}
//=-------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TerminalServiceSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;        
    
    CInstance* pInstance = CreateNewInstance(pMethodContext);

    if( pInstance != NULL )
    {        

        TRC2((TB, "TerminalServiceSetting@EnumerateInstances: CreateNewInstance succeeded"));  
        
        hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES);

        if( SUCCEEDED( hr ))
        {
            hr = pInstance->Commit();            
            
        } 
        pInstance->Release( );
    }

    return hr ;
}
//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key property, the TerminalName. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*****************************************************************************/

HRESULT CWin32_TerminalServiceSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
    

    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwMode = 0;                  // Mode
    BOOL bActivate ;
    DWORD dwStatus = 0;
    CRegistry oRegObject;
    DWORD dwData = 0;
    DWORD dwRequiredProperties = 0;


    if( Query.IsPropertyRequired(m_szServerName))
       dwRequiredProperties |= BIT_SERVERNAME;
 
    if (Query.IsPropertyRequired(m_szMode))
       dwRequiredProperties |= BIT_MODE;

    if (Query.IsPropertyRequired(m_szActiveDesktop))
       dwRequiredProperties |= BIT_ACTIVEDESKTOP;

    if (Query.IsPropertyRequired(m_szDeleteTempFolders))
       dwRequiredProperties |= BIT_DELETETEMPDIRS;

    if (Query.IsPropertyRequired(m_szLicensingType))
       dwRequiredProperties |= BIT_LICENSING;

    if (Query.IsPropertyRequired(m_szLicensingName))
       dwRequiredProperties |= BIT_LICENSING;

    if (Query.IsPropertyRequired(m_szLicensingDescription))
       dwRequiredProperties |= BIT_LICENSING;

    if (Query.IsPropertyRequired(m_szLogons))
       dwRequiredProperties |= BIT_LOGONS;

    if (Query.IsPropertyRequired(m_szUserPerm))
       dwRequiredProperties |= BIT_USERPERM;

    if (Query.IsPropertyRequired(m_szUseTempFolders))
       dwRequiredProperties |= BIT_PERSESSIONTEMPDIR;

    if (Query.IsPropertyRequired(m_szHelp))
       dwRequiredProperties |= BIT_HELP;

    if (Query.IsPropertyRequired(m_szAllowTSConnections))
       dwRequiredProperties |= BIT_ALLOWTSCONNECTIONS;

    if (Query.IsPropertyRequired(m_szSingleSession))
        dwRequiredProperties |= BIT_SINGLESESSION;

    if (Query.IsPropertyRequired(m_szProfilePath))
        dwRequiredProperties |= BIT_PROFILEPATH;

    if (Query.IsPropertyRequired(m_szHomeDirectory))
        dwRequiredProperties |= BIT_HOMEDIRECTORY;

    if (Query.IsPropertyRequired(m_szDirectConnectLicenseServers))
        dwRequiredProperties |= BIT_DIRECTCONNECTLICENSESERVERS;

    hr = LoadPropertyValues(pInstance, dwRequiredProperties);


    return S_OK ;
}
//=---------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::ExecQuery
*
*  DESCRIPTION :    The method context is passed for use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CWin32_TerminalServiceSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwRequiredProperties = 0;
    CHStringArray asNames;
    DWORD dwMode = 0;
    DWORD dwStatus = 0;
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}  	

    // Method 2
    Query.GetValuesForProp(m_szServerName, asNames);

    BOOL bGetAllInstances = asNames.GetSize() == 0;

    // Method 1
    if (Query.IsPropertyRequired(m_szServerName))
        dwRequiredProperties |= BIT_SERVERNAME;

    if (Query.IsPropertyRequired(m_szMode))
       dwRequiredProperties |= BIT_MODE;

    if (Query.IsPropertyRequired(m_szActiveDesktop))
       dwRequiredProperties |= BIT_ACTIVEDESKTOP;

    if (Query.IsPropertyRequired(m_szDeleteTempFolders))
       dwRequiredProperties |= BIT_DELETETEMPDIRS;

    if (Query.IsPropertyRequired(m_szLicensingType))
       dwRequiredProperties |= BIT_LICENSING;

    if (Query.IsPropertyRequired(m_szLogons))
       dwRequiredProperties |= BIT_LOGONS;

    if (Query.IsPropertyRequired(m_szUserPerm))
       dwRequiredProperties |= BIT_USERPERM;

    if (Query.IsPropertyRequired(m_szUseTempFolders))
       dwRequiredProperties |= BIT_PERSESSIONTEMPDIR;

    if (Query.IsPropertyRequired(m_szHelp))
        dwRequiredProperties |= BIT_HELP;

    if (Query.IsPropertyRequired(m_szAllowTSConnections))
       dwRequiredProperties |= BIT_ALLOWTSCONNECTIONS;

    if (Query.IsPropertyRequired(m_szSingleSession))
        dwRequiredProperties |= BIT_SINGLESESSION;

    if (Query.IsPropertyRequired(m_szProfilePath))
        dwRequiredProperties |= BIT_PROFILEPATH;

    if (Query.IsPropertyRequired(m_szHomeDirectory))
        dwRequiredProperties |= BIT_HOMEDIRECTORY;

    if (Query.IsPropertyRequired(m_szDirectConnectLicenseServers))
        dwRequiredProperties |= BIT_DIRECTCONNECTLICENSESERVERS;


    ISettingsComp *pSettings = NULL;
    
    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    do
    {
        if( SUCCEEDED( hr ) && pSettings != NULL )
        {

           // Method 2

            CInstance* pInstance = CreateNewInstance(pMethodContext);

            if( pInstance == NULL)
            {

               ERR((TB, "TerminalServiceSetting@ExecQuery: CreateNewInstance failed"));

               hr = WBEM_E_OUT_OF_MEMORY;

               break;            
            }            
      
            hr = LoadPropertyValues(pInstance, dwRequiredProperties);

            if( SUCCEEDED( hr ) )
            {
               hr = pInstance->Commit();
            }

            pInstance->Release();
        }
    
    }while (0);

    if ( pSettings != NULL )
    {
        pSettings->Release();
    }

    return hr;

}


//=--------------

BOOL CWin32_TerminalServiceSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}


//=---------
/*************************************************************************************
*
*  FUNCTION    : CWin32_TerminalServiceSetting::PutInstance
*
*  DESCRIPTION :    PutInstance is in provider classes that can 
*                   write instance information back to the registry.
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   property - TerminalServerMode.
* 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    :    ActiveDesktop state, UserPerm and Logon are configurable through 
*                   this method as they are not Group Policy based nor server-overridable. 
*
***************************************************************************************/

HRESULT CWin32_TerminalServiceSetting::PutInstance ( const CInstance &Instance, long lFlags)
{   
    HRESULT hr = 0;               
    DWORD dwMode = 0;
    DWORD dwlicensing = 0;         // Licensing mode
    DWORD dwActiveDesktop = 0;     // Active Desktop Enabled or Disabled
    DWORD dwUserPerm = 0;          // Application Compatibility
    DWORD dwDeleteTempFolders = 0; // Delete Temporary Directories on Exit
    DWORD dwUseTempFolders = 0;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    CHString chData;
    CRegistry oRegObject;
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
    TCHAR tch[MAX_PATH] = {0};
	ICfgComp *pCfgComp = NULL;
        
    hr = WBEM_S_NO_ERROR;
    
	CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    ISettingsComp *pSettings = NULL;

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;
    
    do
    {
        if( SUCCEEDED (hr) && pSettings != NULL )
        {           
            if( Instance.GetDWORD(m_szActiveDesktop, dwActiveDesktop ) )
            {
                if( dwActiveDesktop != 0 && dwActiveDesktop != 1 )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }

                pSettings->SetActiveDesktopState( dwActiveDesktop, &dwStatus );

                TRC2((TB, "TerminalServiceSetting@PutInstance: SetActiveDesktopState returned 0x%x\n" , dwStatus));
            }            
            
            if( Instance.GetDWORD( m_szUserPerm, dwUserPerm ) )
            {
                if( dwUserPerm != 0 && dwUserPerm != 1 )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }

                pSettings->SetUserPerm(dwUserPerm, &dwStatus );

                TRC2((TB, "TerminalServiceSetting@PutInstance: SetUserPerm returned 0x%x\n" , dwStatus));               
            }            
            
          

            hr = oRegObject.OpenKey(HKEY_LOCAL_MACHINE, TS_LOGON_PATH);

            chData.Empty();

            if( SUCCEEDED( hr ) )
            {
                if( GetVersionEx( &OsVersionInfo) )
                {
                    if( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion == 0 )
                    {
                        TRC2((TB, "TerminalServiceSetting@GetObject GetVersionInfo is Win2000"));

                        if( Instance.GetCHString(m_szLogons, chData ) )
                        {
                            if( chData.IsEmpty() || ((lstrcmp ((LPCTSTR)chData, L"0") != 0 ) && (lstrcmp ((LPCTSTR) chData, L"1") != 0)) )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                
                                break;
                            }

                            // Todo: Add this for Beta2 to reverse logic

                            /*

                            if( lstrcmp ((LPCTSTR)chData, L"0") == 0 )
                            {
                                chData.Empty();
                                chData = L"1";
                            }
                            else
                            {
                                chData.Empty();
                                chData = L"0";
                            }
                            */
                                              
                            hr = oRegObject.WriteRegString(L"WinStationsDisabled", (LPTSTR) (LPCTSTR) chData);
                        
                            TRC2((TB, "TerminalServiceSetting@PutInstance WinStationsDisabled returned 0x%x\n" , hr));                                                   
                        }
                    }     
    
                    else
                    {
                        TRC2((TB, "TermServiceSetting@PutInstance GetVersionInfo is Whistler"));

                        if( Instance.GetCHString(m_szLogons, chData ) )
                        {
                            if( chData.IsEmpty() || ((lstrcmp ((LPCTSTR)chData, L"0") != 0 ) && (lstrcmp ((LPCTSTR) chData, L"1") != 0)) )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                
                                break;
                            } 
                            
                            /*

                            if( lstrcmp ((LPCTSTR)chData, L"0") == 0 )
                            {
                                chData.Empty();
                                chData = L"1";
                            }
                            else
                            {
                                chData.Empty();
                                chData = L"0";
                            }
                            */
                            
                            hr = oRegObject.WriteRegString(L"WinStationsDisabled", (LPTSTR) (LPCTSTR) chData);
                        
                            TRC2((TB, "TermServiceSetting@PutInstance WinStationDisabled returned 0x%x\n" , hr));
                        }
                    }                                        
                }                                    
            }

            // ForceUpdate() is called explicitly to update WinstationsDisabled in the registry.

            if( SUCCEEDED( hr ) )
            {
                StackObj.m_pCfgComp->ForceUpdate();
            }
        }

    }while(0);
    
	
    if( pSettings != NULL )
    {
        pSettings->Release();
    }
    
    return hr;
    
}


//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CWin32_TerminalServiceSetting::DeleteInstance ( const CInstance &Instance,  long lFlags )
{
    

    return (WBEM_E_PROVIDER_NOT_CAPABLE);

}


//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    :    Provides method to configure the License type base on
*                   the Terminal server mode, UseTempFolders, DeleteTempFolders
*                   and Help that are group policy based.
*
*****************************************************************************/
HRESULT CWin32_TerminalServiceSetting::ExecMethod ( const CInstance& Inst,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags)

{
    
    
    DWORD dwMode = 0;
    DWORD dwLicensing = 0;
    DWORD dwStatus = 0;
    DWORD dwNewStatus = 0;
    DWORD dwData = 0;
    HANDLE hServer = NULL;
    BOOL fRet = FALSE;
    CHString chData;
    bool fData;
    bool bRet;
    CRegistry oRegObject;	
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CStackClass StackObj;
    HKEY hKey = NULL;
    HKEY hOutKey = NULL;
    

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    ISettingsComp *pSettings = NULL;

    if(pInParams == NULL)
    {
        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }
    
    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;
        
    do
    {        
        if( SUCCEEDED (hr) && pSettings != NULL )
        {            
            if( _wcsicmp(bstrMethodName, m_szChangeMode) == 0 )
            {
                // Configures License type based on the Terminal Server Mode. {None, Remote Administration} for "Remote Admin", 
                // {Per Seat, Per CPU, ICL} for "Application Server" and {Personal Terminal Server} for "Personal Terminal Server".
                // uint32 ChangeMode([In] uint32 LicensingType);
                            
                hr = WBEM_S_NO_ERROR ;
                
                
                bRet = pInParams->GetDWORD(m_szLicensingType, dwLicensing);
                
                if ( !bRet )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }                    
                                
                
                hServer = ServerLicensingOpen(NULL);

                if (NULL != hServer)
                {                
                    dwStatus = ServerLicensingSetPolicy(hServer, dwLicensing, &dwNewStatus);                               
                
                    TRC2( (TB, "TermServiceSetting@ExecMethod:ChangeMode ServerLicensingSetPolicy ret old: 0x%x new: 0x%x\n" , dwStatus, dwNewStatus) );  
                
                    if( ERROR_SUCCESS == dwStatus && ERROR_SUCCESS == dwNewStatus && pOutParams != NULL )
                    {
                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }
                    else if( ERROR_SUCCESS != dwStatus || ERROR_SUCCESS != dwNewStatus )
                    {                        
                        hr = WBEM_E_INVALID_OPERATION;                        

                        break;
                    }                    
                }
                
            }

            else if( _wcsicmp( bstrMethodName, m_szSetAllowTSConnections ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDenyTSConnections == 0 )
                {  
                    TRC2((TB, "Condition to update fPolicyDenyTSConnections satisfied"));                        
                      
                    bRet = pInParams->GetDWORD(m_szAllowTSConnections, dwData);
                    

                    if ( !bRet || (dwData != 0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    } 

                    // The bit is negated because it calls the function SetDenyTSConnections which is negative logic.
                    
                    if( dwData == 0 )
                    {
                        dwData = 1;                                            
                    }
                    else if( dwData == 1 )
                    {
                        dwData = 0;
                    }
                                        
                    hr = pSettings->SetDenyTSConnections( dwData , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSTerminalServiceSetting@ExecMethod:  SetAllowTSConnections ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }
            
            else if( _wcsicmp( bstrMethodName, m_szSetSingleSession ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicySingleSessionPerUser == 0 )
                {  
                    TRC2((TB, "Condition to update fSingleSessionPerUser satisfied"));                        
                      
                    bRet = pInParams->GetDWORD(m_szSingleSession, dwData);
                    

                    if ( !bRet || (dwData != 0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                                        
                    
                    hr = pSettings->SetSingleSessionState( dwData , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetSingleSession ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }
            else if( _wcsicmp( bstrMethodName, m_szSetProfilePath ) == 0 )
            {
                
                BSTR bstrVal = NULL;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyWFProfilePath == 0 )
                {  
                    TRC2((TB, "Condition to update WFProfilePath satisfied"));                        
                      
                    bRet = pInParams->GetCHString(m_szProfilePath, chData);                    

                    if ( !bRet )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                                        

                    bstrVal = SysAllocString((LPTSTR) (LPCTSTR) (chData));

                    if(bstrVal != NULL)
                    {                                         
                        hr = pSettings->SetProfilePath( bstrVal , &dwStatus );
                    
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            hr = StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                            TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetProfilePath ret 0x%x\n" , hr  ));
                        }
                    }
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }
            else if( _wcsicmp( bstrMethodName, m_szSetHomeDirectory ) == 0 )
            {
                
                BSTR bstrVal = NULL;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyWFHomeDir == 0 )
                {  
                    TRC2((TB, "Condition to update WFProfilePath satisfied"));                        
                      
                    bRet = pInParams->GetCHString(m_szHomeDirectory, chData);
                    

                    if ( !bRet )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                          

                    bstrVal = SysAllocString((LPTSTR) (LPCTSTR) (chData));

                    if(bstrVal != NULL)
                    {                   
                        hr = pSettings->SetHomeDir( bstrVal , &dwStatus );
                    
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            hr = StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                            TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetHomeDirectory ret 0x%x\n" , hr  ));
                        }
                    }
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }        
            else if( _wcsicmp(bstrMethodName, m_szSetPolicyPropertyName) == 0 )
            {
                //  PropertyName is an enumeration of the properties: 
                //  DeleteTempFolders, UseTempFolders and Help which are flags that are either set
                //  to False or True according as whether Value is set to 0 or 1 respectively.
                //                                  
                //  uint32 SetPolicyPropertyName([In] string PropertyName, [In] boolean Value) ;
                
                RegGetMachinePolicy(&m_gpPolicy);
    
                pInParams->GetCHString(m_szPropertyName, chData);                
                
                if( chData.CompareNoCase(m_szDeleteTempFolders) == 0 )
                {
                    pInParams->Getbool(m_szValue, fData);
                    
                    TRC2((TB, "m_gpPolicy.fPolicyDeleteTempFoldersOnExit ret 0x%x\n", m_gpPolicy.fPolicyDeleteTempFoldersOnExit));                          
                    
                    if( m_gpPolicy.fPolicyDeleteTempFoldersOnExit == 0 )
                    {  
                        TRC2((TB, "Condition to update fPolicyDeleteTempFoldersOnExit satisfied"));
                        
                        if( fData != 0 && fData != 1 )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        hr = pSettings->SetDelDirsOnExit(fData);
                        
                        TRC2((TB, "TerminalServiceSetting@PutInstance: SetDelDirsOnExit"));
                        
                        if( pOutParams != NULL )
                        {
                            pOutParams->SetDWORD(L"ReturnValue", hr);
                        }
                        
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                    }
                }
                else if( chData.CompareNoCase(m_szUseTempFolders) == 0 )
                {
                    pInParams->Getbool(L"Value", fData);
                    
                    TRC2((TB, "m_gpPolicy.fPolicyTempFoldersPerSession ret 0x%x\n", m_gpPolicy.fPolicyTempFoldersPerSession));

                    
                    if( m_gpPolicy.fPolicyTempFoldersPerSession == 0 )
                    {
                        TRC2((TB, "Condition to update fPolicyTempFoldersPerSession satisfied"));
                        
                        if( fData != 0 && fData != 1 )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        hr = pSettings->SetUseTempDirPerSession(fData );
                        
                        TRC2((TB, "TerminalServiceSetting@ExecMethod: SetUseTempDirPerSession"));
                        
                        if( pOutParams != NULL )
                        {
                            pOutParams->SetDWORD(L"ReturnValue", hr);
                        }
                        
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                    }
                }
                else if( chData.CompareNoCase(m_szHelp) == 0 )
                {                      
                    hr = oRegObject.OpenKey(HKEY_LOCAL_MACHINE, TS_POLICY_SUB_TREE);

                    if( SUCCEEDED (hr) )
                    {
                        if( ERROR_SUCCESS != oRegObject.ReadRegDWord(POLICY_TS_REMDSK_ALLOWTOGETHELP, &dwData) )
                        {
                            pInParams->Getbool(m_szValue, fData);                        
        
                            TRC2((TB, "Condition to update fAllowToGetHelp satisfied"));
            
                            if( fData != 0 && fData != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                
                                break;
                            }
            
                            hr = pSettings->SetSalemHelpMode(fData, &dwStatus );
            
                            TRC2((TB, "TerminalServiceSetting@ExecMethod: Help"));
            
                            if( pOutParams != NULL && dwStatus == ERROR_SUCCESS )
                            {                               
                                pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                            }                                                
                            else
                            {
                                hr = WBEM_E_INVALID_OPERATION;
                
                                break;
                            }
                        }
                    }                            
                }
                else
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                
                    break;
                }  
            }

                                
            else if(  _wcsicmp( bstrMethodName, m_szAddDirectConnectLicenseServer ) == 0 )
            {                      
                DWORD dwReturn = 0;
                 
                bRet = pInParams->GetCHString(m_szLicenseServerName, chData);

                if( chData.IsEmpty() )
                {
                    hr = WBEM_E_INVALID_PARAMETER;

                    break;
                }

              
                
                hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TERMINAL_SERVICE_PARAM_DISCOVERY ,
                                    0,
                                    KEY_READ ,
                                    &hKey );

                if( ERROR_SUCCESS == hr )
                { 


                    hr = RegCreateKeyEx( hKey ,
                                            L"LicenseServers",
                                            0,
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hOutKey ,
                                            &dwReturn ); 
                    if( ERROR_SUCCESS == hr )
                    {                                    
                        hr = RegCreateKeyEx( hOutKey ,
                                                chData.LockBuffer(),
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_ALL_ACCESS,
                                                NULL,
                                                &hOutKey ,
                                                &dwReturn );   
                        chData.UnlockBuffer();

                        TRC2((TB, "Win32_TerminalServiceSetting@ExecMethod: AddLicenseServer ret 0x%x" , hr));                 
                    }

                    if( hr == ERROR_SUCCESS )
                    {

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }  
                                        
                    chData.Empty();
                }
            }

            else if(  _wcsicmp( bstrMethodName, m_szDeleteDirectConnectLicenseServer ) == 0 )
            {                      
                DWORD dwReturn = 0;
                 
                bRet = pInParams->GetCHString(m_szLicenseServerName, chData );

                
                if( chData.IsEmpty() )
                {
                    hr = WBEM_E_INVALID_PARAMETER;

                    break;
                }

                hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TERMINAL_SERVICE_PARAM_DISCOVERY_SERVERS,                                        
                                    0,
                                    KEY_ALL_ACCESS ,
                                    &hKey );

                if( ERROR_SUCCESS == hr )
                { 
            
                    hr = RegDeleteKey( hKey ,
                                         chData.LockBuffer() );      

                    TRC2((TB, "Win32_TerminalServiceSetting@ExecMethod: DeleteLicenseServer ret 0x%x" , hr));                       

                    if( hr == ERROR_SUCCESS )
                    {

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }

                    chData.UnlockBuffer();

                    chData.Empty();                        
                
                }
                else
                {
                    hr = S_OK;
                }
            }                                                                                                            
        }

    }while (0);

    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    if(NULL != hOutKey)
    {
        RegCloseKey(hOutKey);
    }

    if( NULL != hServer )
    {
        ServerLicensingClose(hServer);
    }
    
    if( pSettings != NULL )
    {
        pSettings->Release();       
    }
    
    return hr;
}

//=---------

HRESULT CWin32_TerminalServiceSetting::LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties)
{         
    int Licensing;
    DWORD dwMode = 0;
    DWORD dwData = 0;
    ULONG ulMode = 0;
    CRegistry oRegObject;
    DWORD dwSize = 0;
    BOOL bData = 0;
    BOOL bActivate = 0;
    DWORD dwStatus = 0;
    DWORD dwType = 0;
    HANDLE      hServer = NULL;
    BYTE bbyte;
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
    LPTSTR lpLogon; 
    int iData;
    LPLCPOLICYINFO_V1W pPolicyInfo = NULL;
    ULONG  ulInfoStructVersion = LCPOLICYINFOTYPE_CURRENT;	
    CHString chLogon;
    CHString chData;
    HKEY hParamKey = NULL;
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CHString chServerName;
    
    chServerName.Format(L"%s", (LPCTSTR)GetLocalComputerName());

    CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    if( pInstance == NULL )
    {
        ERR((TB, "TermServiceSetting@LoadPropertyValues: invalid interface"));

        return E_FAIL;
    }
    ISettingsComp *pSettings = NULL;

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;    

    if( SUCCEEDED (hr) && pSettings != NULL )
    {

        if( dwRequiredProperties & BIT_SERVERNAME )
        {
            pInstance->SetCHString(m_szServerName, chServerName);            
        }

        if( dwRequiredProperties & BIT_MODE )
        {
            pSettings->GetTermSrvMode(&dwMode , &dwStatus );
        
            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetTermSrvMode returned 0x%x\n" , dwStatus));

            if( ERROR_SUCCESS == dwStatus )
            {            
                pInstance->SetDWORD(m_szMode, dwMode);
            }            
        }

        if( dwRequiredProperties & BIT_LICENSING )
        {            
            hServer = ServerLicensingOpen(NULL);

            if (NULL != hServer)
            {
                if( ServerLicensingGetPolicy( hServer, &ulMode ) )
                {            
                    TRC2((TB, "TermServiceSetting@LoadPropertyValues: ServerLicensingGetPolicy ret 0x%x\n" , dwStatus));
                 
                    pInstance->SetDWORD(m_szLicensingType, (DWORD &)ulMode);   
                    
                    if( ServerLicensingGetPolicyInformation( hServer, ulMode, &ulInfoStructVersion, 
                        (LPLCPOLICYINFOGENERIC *) &pPolicyInfo ))
                    {
                        pInstance->SetCHString(m_szLicensingName, pPolicyInfo->lpPolicyName );
                        pInstance->SetCHString(m_szLicensingDescription, pPolicyInfo->lpPolicyDescription );

                        ServerLicensingFreePolicyInformation((LPLCPOLICYINFOGENERIC *)&pPolicyInfo);
                    }
                }      

                ServerLicensingClose(hServer);
            }
            
        }

        if( dwRequiredProperties & BIT_ACTIVEDESKTOP )
        {
            pSettings->GetActiveDesktopState(&bActivate , &dwStatus );

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetActiveDesktopState returned 0x%x\n" , dwStatus));
            
            if( ERROR_SUCCESS == dwStatus )
            {
                pInstance->SetDWORD(m_szActiveDesktop, (DWORD &)bActivate);
            }

            if( 2 == dwStatus )
            {
                pInstance->SetDWORD(m_szActiveDesktop, 0);
            }
        }

        if( dwRequiredProperties & BIT_USERPERM )
        {
            pSettings->GetUserPerm(&bActivate , &dwStatus );

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetUserPerm returned 0x%x\n" , dwStatus));

            if( ERROR_SUCCESS == dwStatus )
            {
                pInstance->SetDWORD(m_szUserPerm, bActivate);        
            }            
        }        
            

        if( dwRequiredProperties & BIT_DELETETEMPDIRS )
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyDeleteTempFoldersOnExit != 0 )
            {
                bActivate = m_gpPolicy.fDeleteTempFoldersOnExit;
            }
            else
            {
                pSettings->GetDelDirsOnExit( &bActivate );
            }

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetDelDirsOnExit returned 0x%x\n" , hr));
            
            pInstance->SetDWORD(m_szDeleteTempFolders, bActivate);                        
        }

        if( dwRequiredProperties & BIT_PERSESSIONTEMPDIR )
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyTempFoldersPerSession != 0 )
            {
                bActivate = m_gpPolicy.fTempFoldersPerSession;
            }
            else
            {
                pSettings->GetUseTempDirPerSession(&bActivate );
            }

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetUseTempDirsPerSession returned 0x%x\n" , hr));
              
            pInstance->SetDWORD(m_szUseTempFolders, bActivate);                        
        }
        

        if( dwRequiredProperties & BIT_LOGONS )
        {
            hr = oRegObject.OpenKey(HKEY_LOCAL_MACHINE, TS_LOGON_PATH);

            if( SUCCEEDED( hr ) )
            {   
                if( GetVersionEx( &OsVersionInfo) )
                {

                    if( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion == 0 )
                    {
                        TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetVersionInfo is Win2000"));

                        dwData = 0;
                                      
                        hr = oRegObject.ReadRegDWord(L"WinStationsDisabled", &dwData);
                        
                        TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetWinStationsDisabled returned 0x%x\n" , hr));

                        if( SUCCEEDED (hr) )
                        {
                            if( dwData == 0 )
                            {
                                pInstance->SetCharSplat(m_szLogons, L"0");
                            }

                            else
                            {
                                pInstance->SetCharSplat(m_szLogons, L"1");
                            }
                        }                        
                    }     
    
                    else
                    {
                        TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetVersionInfo is Whistler"));                    
          
                        hr = oRegObject.ReadRegString(L"WinStationsDisabled", &lpLogon, &dwData);
                        
                        TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetWinStationsDisabled returned 0x%x\n" , hr));

                        if( SUCCEEDED( hr ) )
                        {        
                            pInstance->SetCharSplat(m_szLogons, lpLogon);
                        }                        
                    }
                }                                                      
            }
        }

        if( dwRequiredProperties & BIT_HELP )
        {
           
            hr = pSettings->GetSalemHelpMode(&iData, &dwStatus );            

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetHelp returned 0x%x" , dwStatus));

            if( S_OK == dwStatus )
            {              
                pInstance->SetDWORD(m_szHelp, iData);            
            }
            else
            {
                pInstance->SetDWORD(m_szHelp, 0);
            }
        }

        if( dwRequiredProperties & BIT_ALLOWTSCONNECTIONS )
        {
           
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyDenyTSConnections != 0 )
            {
                iData = m_gpPolicy.fDenyTSConnections;
            }
            else
            {                
                hr = pSettings->GetDenyTSConnections(&iData, &dwStatus );            

                TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetAllowTSConnections returned 0x%x" , dwStatus));
            }

            // The bit is negated because it calls the function GetDenyTSConnections which is negative logic.

            if( iData == 0)
            {
                iData = 1;
            }
            else if( iData == 1)
            {
                iData = 0;
            }
             
            pInstance->SetDWORD(m_szAllowTSConnections, iData);                                                 
        
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: AllowTSConnections" ));
        }

        if( dwRequiredProperties & BIT_SINGLESESSION)
        {  
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicySingleSessionPerUser != 0 )
            {
                bData = m_gpPolicy.fSingleSessionPerUser;
            }
            else
            {  
                hr = pSettings->GetSingleSessionState( &bData, &dwStatus);
            }
            dwData = bData;

            pInstance->SetDWORD(m_szSingleSession, dwData);                                               
        
            TRC2((TB,"TermServiceSetting@LoadPropertyValues: SingleSession" ));
        }
       
        if( dwRequiredProperties & BIT_PROFILEPATH)
        { 
            BSTR bstrData = NULL;

            chData.Empty();

            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyWFProfilePath != 0 )
            {               
                chData.Format(L"%s", m_gpPolicy.WFProfilePath);
            }
            else
            {                  
                hr = pSettings->GetProfilePath( &bstrData, &dwStatus);

                if( bstrData != NULL)
                {
                    chData.Format(L"%s", (LPCWSTR)(bstrData));

                    SysFreeString(bstrData);
                }
            }            

            pInstance->SetCHString(m_szProfilePath, chData);                          
        
            TRC2((TB,"TermServiceSetting@LoadPropertyValues: ProfilePath" ));
        }

        if( dwRequiredProperties & BIT_HOMEDIRECTORY)
        {  
            BSTR bstrData = NULL;

            chData.Empty();

            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyWFHomeDir != 0 )
            {                
                chData.Format(L"%s", m_gpPolicy.WFHomeDir);               
            }
            else
            {  
                hr = pSettings->GetHomeDir( &bstrData, &dwStatus);

                if(bstrData != NULL)
                {
                    chData.Format(L"%s", (LPCWSTR)(bstrData));

                    SysFreeString(bstrData);
                }
            }           

            pInstance->SetCHString(m_szHomeDirectory, chData);                                                         
        
            TRC2((TB,"TermServiceSetting@LoadPropertyValues: HomeDirectory" ));
        }

        if( dwRequiredProperties & BIT_DIRECTCONNECTLICENSESERVERS)
        {  
            
            DWORD dwValueType;
            DWORD cbValue = 0, dwDisp;
            LONG lReturn;
            DWORD cbServer;
            DWORD cServers;
            DWORD cchServerMax;
            LPWSTR szServer;
            DWORD i, j;
            CHString chServers;
            chServers.Empty();
            
            do
            {            

                lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               TERMINAL_SERVICE_PARAM_DISCOVERY_SERVERS,
                               0,
                               KEY_READ,
                               &hParamKey );

                if (ERROR_SUCCESS != lReturn)
                {
                    break;
                }

                lReturn = RegQueryInfoKey(hParamKey,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &cServers,
                                          &cchServerMax,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL);

                if (ERROR_SUCCESS != lReturn)
                {
                    RegCloseKey( hParamKey );

                    break;
                }

                if (0 == cServers)
                {
                    RegCloseKey( hParamKey );

                    hParamKey = NULL;

                    break;
                }
                

                // Add one for null terminator
                cchServerMax++;

                szServer = (LPWSTR) LocalAlloc(LPTR,cchServerMax * sizeof(WCHAR));

                if(NULL == szServer)
                {
                    LocalFree(szServer);

                    RegCloseKey( hParamKey );

                    hParamKey = NULL;

                    break;
                } 
    
                for (i = 0; i < cServers; i++)
                {
                    if(!chServers.IsEmpty())
                    {
                        chServers+=L"; ";
                    }                                                       

                    cbServer = cchServerMax * sizeof(WCHAR);

                    lReturn = RegEnumKeyEx(hParamKey,
                                           i,
                                           szServer,
                                           &cbServer,
                                           NULL,
                                           NULL,
                                           NULL,
                                           NULL);

                    if (ERROR_SUCCESS != lReturn)
                    {
                        LocalFree(szServer);

                        RegCloseKey( hParamKey );

                        hParamKey = NULL;

                        break;
                    }

                    chServers+= szServer;                

                    
                }

                if(szServer)
                {
                    LocalFree(szServer);                      
                }

                pInstance->SetCHString(m_szDirectConnectLicenseServers, chServers);

            }while(0);
        }
    }
   

    if(hParamKey)
    {
        RegCloseKey(hParamKey);
    }

    if( pSettings != NULL )
    {
        pSettings->Release();
    }
    
    return S_OK;
}

//=---------
/*************************************************************************************
*
*  DESCRIPTION :    CWin32_TerminalService class is subclassed from the Win32_Service
*                   class in CIM schema. It provides live information such as Total
*                   sessions, Disconnected sessions, Resource constraint and 
*                   Raw session capacity.
*
***************************************************************************************/

CWin32_TerminalService::CWin32_TerminalService (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
    if (g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TerminalService_ctor"));

        _tcscpy(m_szName, _T("Name"));

        _tcscpy(m_szCaption, _T("Caption"));

        _tcscpy(m_szTotalSessions, _T("TotalSessions"));

        _tcscpy(m_szDisconnectedSessions, _T("DisconnectedSessions"));

        _tcscpy(m_szResourceConstraint, _T("ResourceConstraint"));

        _tcscpy(m_szRawSessionCapacity, _T("RawSessionCapacity"));

        
    }    
}

//=-----------------

CWin32_TerminalService::~CWin32_TerminalService ()
{
}

//=--------------------
/************************************************************************************
*
*  DESCRIPTION :    Find a single instance based on the key property, "Name". 
*
*  INPUTS      :    A pointer to a CInstance object containing the key property, "Name". 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
**************************************************************************************/

HRESULT CWin32_TerminalService::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chServerName;
    TCHAR tchServer[MAX_PATH] = {0};
    HANDLE hServerName = SERVERNAME_CURRENT;
    ULONG CurrentLogonId = (ULONG) -1;
    WINSTATIONLOADINDICATORDATA LIData;
    ULONG Length = 0;
    DWORD dwRequiredProperties = 0;
    CHString chName;

    pInstance->GetCHString(m_szName, chName);

    pInstance->SetCHString(m_szCaption, chName);

    if( chName.CompareNoCase(L"TermService") == 0 )
    {    
        chServerName.Format(L"%s", (LPCTSTR)GetLocalComputerName());
        wcscpy (tchServer, chServerName);
        bool bRet = 0;

        if (Query.IsPropertyRequired(m_szTotalSessions))
           dwRequiredProperties |= BIT_TOTALSESSIONS;

        if (Query.IsPropertyRequired(m_szDisconnectedSessions))
           dwRequiredProperties |= BIT_DISCONNECTEDSESSIONS;

        if (Query.IsPropertyRequired(m_szEstimatedSessionCapacity))
           dwRequiredProperties |= BIT_ESTIMATEDSESSIONCAPACITY;

        if (Query.IsPropertyRequired(m_szResourceConstraint))
           dwRequiredProperties |= BIT_RESOURCECONSTRAINT;

        if (Query.IsPropertyRequired(m_szRawSessionCapacity))
           dwRequiredProperties |= BIT_RAWSESSIONCAPACITY;

        hServerName = WinStationOpenServer (tchServer);

        CurrentLogonId = GetCurrentLogonId();

        if( hServerName != NULL )
        {
            bRet  = WinStationQueryInformation(hServerName, CurrentLogonId,
                                       WinStationLoadIndicator,
                                       &LIData,
                                       sizeof(LIData), &Length)  ;
            if( bRet )
            {
                hr = LoadPropertyValues(pInstance, dwRequiredProperties, LIData);
            }
        }
        else
        {        
            ERR((TB, "Win32_TerminalService@GetObject: WinStationQueryInformation GetLastError returned: 0x%x\n" ,GetLastError()));
        }
    }
          
    return hr;        
}

//=------------------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalService::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*
*****************************************************************************/

HRESULT CWin32_TerminalService::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{

    return WBEM_S_NO_ERROR;

    // Commented as implementation is protocol dependent
/*
    CHString chServerName;
    TCHAR tchServer[MAX_PATH] = {0};
    HANDLE hServer = SERVERNAME_CURRENT;
    WINSTATIONLOADINDICATORDATA LIData;
    ULONG CurrentLogonId = (ULONG) -1;
    ULONG Length;
    chServerName.Format(L"%s", (LPCTSTR)GetLocalComputerName());
    wcscpy (tchServer, chServerName);
    hServer = WinStationOpenServer (tchServer);
    bool bRet = 0;

    CurrentLogonId = GetCurrentLogonId();

    if (hServer != NULL)
    {        

        bRet  = WinStationQueryInformation(hServer, CurrentLogonId,
                                   WinStationLoadIndicator,
                                   &LIData,
                                   sizeof(LIData), &Length);

        TRC2((TB, "Win32_TerminalService@EnumerateInstances: WinStationQueryInformation bRet: 0x%x\n" , bRet));

        if (bRet)
        {
            CInstance* pInstance = CreateNewInstance(pMethodContext);        
    
            if( pInstance != NULL )
            {
               
                pInstance->SetCHString(m_szServerName, chServerName);                              

                hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES, LIData);

                if ( SUCCEEDED( hr ))
                {            
                    hr = pInstance->Commit();
                }        
                            
                pInstance->Release();             
            }
        }
    }
    else
    {
       
        TRC2((TB, "Win32_TerminalService@EnumerateInstances: WinStationQueryInformation GetLastError returned: 0x%x\n" , hr));
    }
           
    return hr; 
    */
    
}

//=-------------

HRESULT CWin32_TerminalService::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwRequiredProperties = 0;
    CHStringArray asNames;
    DWORD dwMode;
    DWORD dwStatus;
    CHString chServerName;
    TCHAR tchServer[MAX_PATH] = {0};
    bool bRet = 0;

    HANDLE hServerName = SERVERNAME_CURRENT;
    WINSTATIONLOADINDICATORDATA LIData;
    ULONG CurrentLogonId = (ULONG) -1;
    ULONG Length = 0;
    
    chServerName.Format(L"%s", (LPCTSTR)GetLocalComputerName());

    wcscpy (tchServer, chServerName);

    hServerName = WinStationOpenServer (tchServer);    

    CurrentLogonId = GetCurrentLogonId();

    if( hServerName != NULL )
    {
        bRet  = WinStationQueryInformation(hServerName, CurrentLogonId,
                                   WinStationLoadIndicator,
                                   &LIData,
                                  sizeof(LIData), &Length);       
        if( bRet )
        {
        
           // Method 2
           Query.GetValuesForProp(m_szName, asNames);

           BOOL bGetAllInstances = asNames.GetSize() == 0;

           // Method 1
           if (Query.IsPropertyRequired(m_szTotalSessions))
               dwRequiredProperties |= BIT_TOTALSESSIONS;

           if (Query.IsPropertyRequired(m_szDisconnectedSessions))
               dwRequiredProperties |= BIT_DISCONNECTEDSESSIONS;
    
           if (Query.IsPropertyRequired(m_szEstimatedSessionCapacity))
               dwRequiredProperties |= BIT_ESTIMATEDSESSIONCAPACITY;

           if (Query.IsPropertyRequired(m_szResourceConstraint))
               dwRequiredProperties |= BIT_RESOURCECONSTRAINT;

           if (Query.IsPropertyRequired(m_szRawSessionCapacity))
               dwRequiredProperties |= BIT_RAWSESSIONCAPACITY;


           CInstance* pInstance = CreateNewInstance(pMethodContext);

           if( pInstance != NULL)
           {                                                       
               
               pInstance->SetCHString(m_szName, chServerName);

               pInstance->SetCHString(m_szCaption, chServerName);

               hr = LoadPropertyValues( pInstance, dwRequiredProperties, LIData );

               if( SUCCEEDED( hr ) )
               {
                   hr = pInstance->Commit();
               }

               pInstance->Release();
           }
           else
           {
               ERR((TB, "Win32_TerminalService@GetObject@ExecQuery: CreateNewInstance failed"));
               hr = WBEM_E_OUT_OF_MEMORY;
           }
        }
    }
    else
    {
        
        TRC2((TB, "Win32_TerminalService@ExecQuery: WinStationQueryInformation GetLastError returned: 0x%x\n" , GetLastError()));
    }

   return hr;
   
}

//=---------------------


HRESULT CWin32_TerminalService::LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties, WINSTATIONLOADINDICATORDATA LIData)
{

    if( pInstance != NULL )
    {        
        
        if( dwRequiredProperties & BIT_TOTALSESSIONS )
        {
            pInstance->SetDWORD(m_szTotalSessions, LIData.TotalSessions);           
        }

        if( dwRequiredProperties & BIT_DISCONNECTEDSESSIONS )
        {
            pInstance->SetDWORD(m_szDisconnectedSessions, LIData.DisconnectedSessions);
        }

        if( dwRequiredProperties & BIT_ESTIMATEDSESSIONCAPACITY )
        {
            pInstance->SetDWORD(m_szEstimatedSessionCapacity, LIData.RemainingSessionCapacity);
        }
        
        if( dwRequiredProperties & BIT_RESOURCECONSTRAINT )
        { 
            switch( LIData.LoadFactor )
            {
            case 0:                
                pInstance->SetCharSplat(m_szResourceConstraint, L"Error");
                break;
            case 1:
                pInstance->SetCharSplat(m_szResourceConstraint, L"PagedPool");
                break;
            case 2:
                pInstance->SetCharSplat(m_szResourceConstraint, L"NonPagedPool");
                break;
            case 3:
                pInstance->SetCharSplat(m_szResourceConstraint, L"Available Memory");
                break;
            case 4:
                pInstance->SetCharSplat(m_szResourceConstraint, L"System PTEs");
                break;           
            case 5:
                pInstance->SetCharSplat(m_szResourceConstraint, L"CPU");
                break;        
   
            default:
                pInstance->SetCharSplat(m_szResourceConstraint, L"Error");
                break;
            }
        }
        if( dwRequiredProperties & BIT_RAWSESSIONCAPACITY )
        {
            pInstance->SetDWORD(m_szRawSessionCapacity, LIData.RawSessionCapacity); 
        }
    }

    return S_OK;
}


//=--------------

CWin32_TSSessionDirectory::CWin32_TSSessionDirectory (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{    
    if ( g_hInstance != NULL)
    {
        
        TRC2((TB, "CWin32_TSSessionDirectory_ctor"));

        _tcscpy(m_szMode, _T("TerminalServerMode"));

        _tcscpy(m_szSessionDirectoryActive, _T("SessionDirectoryActive"));

        _tcscpy(m_szSessionDirectoryLocation, _T("SessionDirectoryLocation"));

        _tcscpy(m_szSessionDirectoryClusterName, _T("SessionDirectoryClusterName"));

 //       _tcscpy(m_szSessionDirectoryAdditionalParams, _T("SessionDirectoryAdditionalParams"));

        _tcscpy(m_szSetSessionDirectoryProperty, _T("SetSessionDirectoryProperty"));

        _tcscpy(m_szSetSessionDirectoryActive, _T("SetSessionDirectoryActive"));

        _tcscpy(m_szPropertyName, _T("PropertyName"));

        _tcscpy(m_szValue, _T("Value"));

        _tcscpy(m_szSessionDirectoryExposeServerIP, _T("SessionDirectoryExposeServerIP"));

        _tcscpy(m_szSetSessionDirectoryExposeServerIP, _T("SetSessionDirectoryExposeServerIP"));
               
    }   
}

//=-------------

CWin32_TSSessionDirectory::~CWin32_TSSessionDirectory ()
{
 
}

//=------------

HRESULT CWin32_TSSessionDirectory::DeleteInstance ( const CInstance &Instance,  long lFlags )
{    
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//=-------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSSessionDirectory::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSSessionDirectory::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{    

    HRESULT hr = WBEM_E_INVALID_CLASS;
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
    ISettingsComp* pSettings = NULL;
    DWORD dwStatus = 0;
    DWORD dwMode = 0;

	CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( GetVersionEx( &OsVersionInfo) )
    {
        if( ( OsVersionInfo.dwMajorVersion < 5 ) || ( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion < 1 ))
        {
            return WBEM_E_INVALID_CLASS;
            
        }
    }

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    if( SUCCEEDED( hr ) && pSettings != NULL )
    {
        pSettings->GetTermSrvMode(&dwMode , &dwStatus );
        
        TRC2((TB, "Win32_TSSessionDirectory@EnumInst: GetTermSrvMode: dwMode ret 0x%x\n" , dwMode));

        if( ERROR_SUCCESS == dwStatus && dwMode == 1)
        {             
            CInstance* pInstance = CreateNewInstance(pMethodContext);

            if( pInstance != NULL )
            {
                TRC2((TB, "Win32_TSSessionDirectory@EnumerateInstances: CreateNewInstance succeeded"));         

                hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES);

                if( SUCCEEDED( hr ))
                {
                    hr = pInstance->Commit();
                }

                pInstance->Release( );
            }
        }
    }

	
    if( pSettings != NULL)
    {
        pSettings->Release();
    }
    
    return hr ;
}

//=-------------


HRESULT CWin32_TSSessionDirectory::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{    
    
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
    HRESULT hr = WBEM_E_INVALID_CLASS;

    ISettingsComp* pSettings = NULL;
    DWORD dwStatus = 0;
    DWORD dwMode = 0;
	ICfgComp *pCfgComp = NULL;

    if( GetVersionEx( &OsVersionInfo) )
    {
        if( ( OsVersionInfo.dwMajorVersion < 5 ) || ( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion < 1 ) )
        {
            return WBEM_E_INVALID_CLASS;
            
        }
    } 

	CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    if( SUCCEEDED( hr ) && pSettings != NULL )
    {
        pSettings->GetTermSrvMode(&dwMode , &dwStatus );   

        if( ERROR_SUCCESS == dwStatus && dwMode == 1)
        {

            ULONGLONG dwRequiredProperties = 0;

            if (Query.IsPropertyRequired(m_szMode))
               dwRequiredProperties |= BIT_MODE;

            if (Query.IsPropertyRequired(m_szSessionDirectoryActive))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYACTIVE;

            if (Query.IsPropertyRequired(m_szSessionDirectoryLocation))
                dwRequiredProperties |= BIT_SESSIONDIRECTORY;

            if (Query.IsPropertyRequired(m_szSessionDirectoryClusterName))
                dwRequiredProperties |= BIT_CLUSTERNAME;

            if (Query.IsPropertyRequired(m_szSessionDirectoryExposeServerIP))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYEXPOSESERVERIP;
           /* 
            if (Query.IsPropertyRequired(m_szSessionDirectoryAdditionalParams))
                dwRequiredProperties |= BIT_ADDITIONALPARAMS;    
        */
            if( pInstance != NULL )
            {        
                hr  = LoadPropertyValues(pInstance, dwRequiredProperties);

                TRC2((TB, "Win32_TSSessionDirectory@GetObject: LoadPropertyValues ret 0x%x\n" , hr));   
            }
        }
    }

    if( pSettings != NULL)
    {
        pSettings->Release();
    }
        
    return hr;
}

//=-----------------

HRESULT CWin32_TSSessionDirectory::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    DWORD dwRequiredProperties = 0;
    CHStringArray asNames;
    CHString chSessionDirectory;
    HRESULT hr = WBEM_E_INVALID_CLASS;
    ISettingsComp* pSettings = NULL;
    DWORD dwStatus = 0;
    DWORD dwMode = 0;
	ICfgComp *pCfgComp = NULL;

    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);

    if( GetVersionEx( &OsVersionInfo) )
    {
        if( ( OsVersionInfo.dwMajorVersion < 5 ) || ( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion < 1 ))
        {
            return WBEM_E_INVALID_CLASS;
            
        }
    }    

    CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    if( SUCCEEDED( hr ) && pSettings != NULL )
    {
        pSettings->GetTermSrvMode(&dwMode , &dwStatus );   

        if( ERROR_SUCCESS == dwStatus && dwMode == 1)
        {

           // Method 2
          //  Query.GetValuesForProp(m_szSessionDirectoryLocation, asNames);
            Query.GetValuesForProp(m_szMode, asNames);

            BOOL bGetAllInstances = asNames.GetSize() == 0;

           // Method 1

            if (Query.IsPropertyRequired(m_szMode))
               dwRequiredProperties |= BIT_MODE;

            if (Query.IsPropertyRequired(m_szSessionDirectoryActive))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYACTIVE;

            if (Query.IsPropertyRequired(m_szSessionDirectoryLocation))
                dwRequiredProperties |= BIT_SESSIONDIRECTORY;

            if (Query.IsPropertyRequired(m_szSessionDirectoryClusterName))
                dwRequiredProperties |= BIT_CLUSTERNAME;

            if (Query.IsPropertyRequired(m_szSessionDirectoryExposeServerIP))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYEXPOSESERVERIP;
           /* 
            if (Query.IsPropertyRequired(m_szSessionDirectoryAdditionalParams))
                dwRequiredProperties |= BIT_ADDITIONALPARAMS;                  
                  
        */
               // Method 2

            CInstance* pInstance = CreateNewInstance(pMethodContext);       

            if( pInstance != NULL)
            {
               
               pInstance->SetCHString(m_szSessionDirectoryLocation, chSessionDirectory );

               hr = LoadPropertyValues(pInstance, dwRequiredProperties);

               if( SUCCEEDED( hr ) )
               {
                   hr = pInstance->Commit();
               }

               pInstance->Release();
            }
            else
            {
                ERR((TB, "Win32_TSSessionDirectory@ExecQuery: CreateNewInstance failed"));                   

                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    if( pSettings != NULL )
    {
        pSettings->Release();
    }

    return hr;

}


//=--------------

BOOL CWin32_TSSessionDirectory::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for( DWORD x=0; x < dwSize; x++ )
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//=-------------

HRESULT CWin32_TSSessionDirectory::ExecMethod ( const CInstance& Inst,
                                                          const BSTR bstrMethodName,
                                                          CInstance *pInParams,
                                                          CInstance *pOutParams,
                                                          long lFlags)
                                                          
{
                 
    DWORD dwData = 0;
    CHString chData;
    HKEY hKey = NULL;
    LONG lRet = 0;
    bool bRet;
    bool bUpdate = FALSE;
    DWORD dwSize = sizeof (DWORD);
    TCHAR szName[ SESSDIR_LENGTH ];
    ISettingsComp* pSettings = NULL;
    DWORD dwStatus = 0;
    DWORD dwMode = 0;
    HRESULT hr = WBEM_E_INVALID_CLASS;
    ICfgComp *pCfgComp = NULL;
    CHString chSessDirName;
    DWORD cbName;
    
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);

      

    CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    if( pInParams == NULL )
    {
        ERR((TB, "TSSessionDirectory@ExecQuery: invalid interface"));

        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    if( SUCCEEDED( hr ) && pSettings != NULL )
    {
        pSettings->GetTermSrvMode(&dwMode , &dwStatus );   

        if( ERROR_SUCCESS == dwStatus && dwMode == 0)
        {
            return WBEM_E_INVALID_CLASS;
        }
    }

    if( GetVersionEx( &OsVersionInfo) )
    {
        if( ( OsVersionInfo.dwMajorVersion < 5 ) || ( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion < 1 ))
        {
            return WBEM_E_INVALID_CLASS;
            
        }
    }  
   
    /*
    
    Inst.GetCHString(m_szSessionDirectoryLocation, chSessDirName);
    
    if( chSessDirName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chSessDirName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    */    
    
    do
    {
    
        // Sets one of the properties: SessionDirectoryLocation or SessionDirectoryClusterName 

        // uint32 SetSessionDirectoryProperty([In] string PropertyName, string Value);
    
        if( _wcsicmp(bstrMethodName, m_szSetSessionDirectoryProperty) == 0 )
        {
            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                 REG_TS_CLUSTERSETTINGS ,
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 &hKey );

            if( ERROR_SUCCESS != lRet )
            { 
                ERR((TB, "TSSessionDirectory@ExecQuery: RegOpenKeyEx failed"));

                hr = WBEM_E_INITIALIZATION_FAILURE;

                break;
            }
            
            pInParams->GetCHString (m_szPropertyName, chData);

            if( chData.CompareNoCase (m_szSessionDirectoryLocation) == 0 )
            {        
                RegGetMachinePolicy(&m_gpPolicy);

                chData.Empty();
                         
                bRet = pInParams->GetCHString(m_szValue, chData );

                if( ( m_gpPolicy.fPolicySessionDirectoryLocation == 0) && bRet )
                {     

                    if( chData.IsEmpty() )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
            
                        break;
                    }

                    if( chData.GetLength() > SESSDIR_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                        break;
                    }

                    lstrcpy(szName, chData);
                    cbName = (lstrlen(szName)+ 1) * sizeof(TCHAR);
                        
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_CLUSTER_STORESERVERNAME,
                                            NULL ,
                                            REG_SZ,
                                            ( CONST LPBYTE )szName ,
                                            cbName );      

                    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectory returned 0x%x" , lRet));   

                    
                    if( lRet == ERROR_SUCCESS )
                    {
                        bUpdate = TRUE;

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }

                    chData.Empty();
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
                
            }
            else if( chData.CompareNoCase(m_szSessionDirectoryClusterName) == 0 )
            {
                       
                RegGetMachinePolicy(&m_gpPolicy);

                chData.Empty();
                     
                bRet = pInParams->GetCHString(m_szValue, chData );

                if( ( m_gpPolicy.fPolicySessionDirectoryClusterName == 0) && bRet )
                {     

                    if( chData.IsEmpty() )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
        
                        break;
                    }

                    if( chData.GetLength() > SESSDIR_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
        
                        break;
                    }

                    lstrcpy(szName, chData);
                    cbName = (lstrlen(szName)+ 1) * sizeof(TCHAR);
                    
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_CLUSTER_CLUSTERNAME,
                                            NULL ,
                                            REG_SZ,
                                            ( CONST LPBYTE )szName ,
                                            cbName );      

                    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectory returned 0x%x" , lRet));                       

                    if( lRet == ERROR_SUCCESS )
                    {
                        bUpdate = TRUE;

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }

                    chData.Empty();                        
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
            }

            else 
            {
                hr = WBEM_E_INVALID_METHOD;

                break;
            } 

            /*

            else if( chData.CompareNoCase(m_szSessionDirectoryAdditionalParams) == 0 )
            {
                       
                RegGetMachinePolicy(&m_gpPolicy);

                chData.Empty();
                     
                bRet = pInParams->GetCHString(m_szValue, chData );

                if( ( m_gpPolicy.fPolicySessionDirectoryAdditionalParams == 0) && bRet != 0 )
                {     

                    if( chData.IsEmpty() != 0 )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
        
                        break;
                    }

                    if( chData.GetLength() > SESSDIR_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
        
                        break;
                    }

                    lstrcpy(szName, chData);

                    
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_CLUSTER_OPAQUESETTINGS,
                                            NULL ,
                                            REG_SZ,
                                            ( CONST LPBYTE )szName ,
                                            sizeof (szName) );      

                    ERR((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectory returned 0x%x" , lRet));   

                    if( lRet == ERROR_SUCCESS )
                    {
                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }

                    chData.Empty();                        
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
            }
            */
                                               
        }

        // Enables / Disables participation of a server in Session Directory

        // uint32 SetSessionDirectoryActive([In] uint32 Value);

        else if( _wcsicmp(bstrMethodName, m_szSetSessionDirectoryActive) == 0 )
        {
            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_CONTROL_TSERVER ,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hKey );

            if( ERROR_SUCCESS == lRet )
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                bRet = pInParams->GetDWORD( m_szSessionDirectoryActive, dwData );
                
                if( (m_gpPolicy.fPolicySessionDirectoryActive == 0) && bRet )
                {

                    if( dwData != 0 && dwData != 1 )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                
                        break;
                    }
                     
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_SESSDIRACTIVE,
                                            0 ,
                                            REG_DWORD,
                                            ( LPBYTE )&dwData ,
                                            dwSize );                   

                    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectoryActive returned 0x%x" , lRet)); 
                
                    if( ERROR_SUCCESS == lRet )
                    {                      

                        bUpdate = TRUE;

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);                        
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_METHOD;
                }
            }
        }

        // Enables / Disables exposing the IP Address of Session Directory Server

        // uint32 SetSessionDirectoryExposeServerIP([In] uint32 Value);

        else if( _wcsicmp(bstrMethodName, m_szSetSessionDirectoryExposeServerIP) == 0 )
        {
            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_CONTROL_TSERVER ,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hKey );

            if( ERROR_SUCCESS == lRet )
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                bRet = pInParams->GetDWORD( m_szSessionDirectoryExposeServerIP, dwData );
                
                //todo: change the policy to IP
                if( (m_gpPolicy.fPolicySessionDirectoryExposeServerIP == 0) && bRet )
                {

                    if( dwData != 0 && dwData != 1 )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                
                        break;
                    }
                     
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_SESSDIR_EXPOSE_SERVER_ADDR,
                                            0 ,
                                            REG_DWORD,
                                            ( LPBYTE )&dwData ,
                                            dwSize );                   

                    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectoryExposeServerIP returned 0x%x" , lRet)); 
                
                    if( ERROR_SUCCESS == lRet )
                    {                      

                        bUpdate = TRUE;

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);                        
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_METHOD;
                }
            }
        } 

    }while(0);

    if( bUpdate )
    {
        StackObj.m_pCfgComp->UpdateSessionDirectory(&dwStatus);
    }

    if( hKey != NULL )
    {
        RegCloseKey( hKey );
    }

        
    if( pSettings != NULL )
    {
        pSettings->Release();
    }

    return hr;
}


//=-------------

HRESULT CWin32_TSSessionDirectory::LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties)
{         
    LONG lRet = 0;    
    DWORD dwData = 0;
    DWORD dwSize = 0;
    HKEY hKey = NULL;
    static WCHAR tchData[ OPAQUESETTINGS_LENGTH +1] ;
    dwSize = sizeof( DWORD );
    
    
    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_CONTROL_TSERVER ,
                         0,
                         KEY_READ,
                         &hKey );

    if( ERROR_SUCCESS == lRet && hKey != NULL)
    {
        if( dwRequiredProperties & BIT_SESSIONDIRECTORYACTIVE )
        {  
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicySessionDirectoryActive != 0 )
            {
                dwData = m_gpPolicy.SessionDirectoryActive;
            }
            else
            {
                lRet = RegQueryValueEx( hKey ,
                                        REG_TS_SESSDIRACTIVE,
                                        NULL ,
                                        NULL ,
                                        (LPBYTE)&dwData ,
                                        &dwSize );
            }
   
            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: SessionDirectoryActive returned 0x%x" , lRet));

            if( ERROR_SUCCESS == lRet )
            {            
                pInstance->SetDWORD(m_szSessionDirectoryActive, dwData);
            }
        }

        if( dwRequiredProperties & BIT_SESSIONDIRECTORYEXPOSESERVERIP )
        {  
            RegGetMachinePolicy(&m_gpPolicy);
            
            if( m_gpPolicy.fPolicySessionDirectoryExposeServerIP != 0 )
            {
                dwData = m_gpPolicy.SessionDirectoryExposeServerIP;
            }
            else
            {
                lRet = RegQueryValueEx( hKey ,
                                        REG_TS_SESSDIR_EXPOSE_SERVER_ADDR,
                                        NULL ,
                                        NULL ,
                                        (LPBYTE)&dwData ,
                                        &dwSize );
            }
   
            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: SessionDirectoryExposeServerIP returned 0x%x" , lRet));

            if( ERROR_SUCCESS == lRet )
            {            
                pInstance->SetDWORD(m_szSessionDirectoryExposeServerIP, dwData);
            }
        }
        

        RegCloseKey (hKey);
    }

    
    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                 REG_TS_CLUSTERSETTINGS ,
                                 0,
                                 KEY_READ,
                                 &hKey );
    

    if( ERROR_SUCCESS == lRet  && hKey != NULL)
    {

        if( dwRequiredProperties & BIT_SESSIONDIRECTORY )
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicySessionDirectoryLocation != 0 )
            {
                lstrcpy(tchData, m_gpPolicy.SessionDirectoryLocation);
            }
            else
            {
         
                dwSize = sizeof( tchData );
            
                lRet = RegQueryValueEx( hKey ,
                                        REG_TS_CLUSTER_STORESERVERNAME,
                                        NULL ,
                                        NULL ,
                                        (LPBYTE)&tchData ,
                                        &dwSize );
            }
    
            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: SessionDirectoryLocation returned 0x%x" , lRet));

            if( ERROR_SUCCESS == lRet )
            {            
                pInstance->SetCHString(m_szSessionDirectoryLocation, (LPTSTR)(LPCTSTR)&tchData);
            }
        }

        if( dwRequiredProperties & BIT_CLUSTERNAME )
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicySessionDirectoryClusterName != 0 )
            {
                lstrcpy( tchData, m_gpPolicy.SessionDirectoryClusterName );
            }
            else
            {
                dwSize = sizeof( tchData );

                lRet = RegQueryValueEx( hKey ,
                                        REG_TS_CLUSTER_CLUSTERNAME,
                                        NULL ,
                                        NULL ,
                                        (LPBYTE)&tchData ,
                                        &dwSize );
            }

            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: ClusterName returned 0x%x" , lRet));   

            if( ERROR_SUCCESS == lRet )
            {
                pInstance->SetCHString(m_szSessionDirectoryClusterName, (LPTSTR)(LPCTSTR)&tchData);            
            }
        }

/*
        if( dwRequiredProperties & BIT_ADDITIONALPARAMS )
        {

            dwSize = sizeof( tchData );
            
            lRet = RegQueryValueEx( hKey ,
                                    REG_TS_CLUSTER_OPAQUESETTINGS,
                                    NULL ,
                                    NULL ,
                                    (LPBYTE)&tchData ,
                                    &dwSize );
            

            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: AdditionalParams returned 0x%x" , lRet));

            if( ERROR_SUCCESS == lRet )
            {            
                pInstance->SetCHString(m_szSessionDirectoryAdditionalParams, (LPTSTR)(LPCTSTR)&tchData);
            }            
        }
        */

        RegCloseKey( hKey );        
    }    
    
    return S_OK;
}

//=-------------------
/*

HRESULT CWin32_TSSessionDirectory::PutInstance ( const CInstance &Instance, long lFlags)
{   
    LONG hr = 0;               
    DWORD dwData;
    CHString chData;
    HKEY hKey;
    LONG lRet;
    DWORD dwSize = sizeof (DWORD);
    TCHAR szName[ SESSDIR_LENGTH ];
        
    hr = WBEM_S_NO_ERROR;
  
    do
    {
        lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_CONTROL_TSERVER ,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hKey );

        if ( ERROR_SUCCESS == lRet )
        {           
            if( Instance.GetDWORD( m_szSessionDirectoryActive, dwData ) )
            {
                if (dwData != 0 && dwData != 1)
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                
                    break;
                }
                     
                lRet = RegSetValueEx( hKey ,
                                        REG_TS_SESSDIRACTIVE,
                                        0 ,
                                        REG_DWORD,
                                        ( LPBYTE )&dwData ,
                                        dwSize );                   

                ERR((TB, "Win32_TSSessionDirectory@PutInstance: SessionDirectoryActive returned 0x%x" , lRet)); 
                
                if (ERROR_SUCCESS == lRet && g_pCfgComp != NULL)
                {
                    g_pCfgComp->ForceUpdate();
                }
            }

            RegCloseKey (hKey);
        }
    
        lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_TS_CLUSTERSETTINGS ,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hKey );

        if ( ERROR_SUCCESS == lRet )
        { 
            chData.Empty();

            if( Instance.GetCHString(m_szSessionDirectoryLocation, chData ) )
            {
                if (chData.IsEmpty() != 0)
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                
                    break;
                }

                if (chData.GetLength() > SESSDIR_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                
                    break;
                }

                lstrcpy(szName, chData);

                            
                lRet = RegSetValueEx( hKey ,
                                        REG_TS_CLUSTER_STORESERVERNAME,
                                        NULL ,
                                        REG_SZ,
                                        ( CONST LPBYTE )szName ,
                                        sizeof (szName) );      

                ERR((TB, "Win32_TSSessionDirectory@PutInstance: SessionDirectory returned 0x%x" , lRet));   

                chData.Empty();
            }
             
    
            if( Instance.GetCHString( m_szSessionDirectoryClusterName, chData ) )
            {
                if (chData.IsEmpty() != 0)
                {
                    hr = WBEM_E_INVALID_PARAMETER;
            
                    break;
                }

                if (chData.GetLength() > SESSDIR_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                    break;
                }

                lstrcpy(szName, chData);                   

                    
                lRet = RegSetValueEx( hKey ,
                                    REG_TS_CLUSTER_CLUSTERNAME,
                                    NULL ,
                                     REG_SZ,
                                    ( CONST LPBYTE )szName ,
                                    sizeof (szName) );

                ERR((TB, "Win32_TSSessionDirectory@PutInstance: ClusterName returned 0x%x" , lRet)); 

                chData.Empty();
            } 
                        

            if( Instance.GetCHString( m_szSessionDirectoryAdditionalParams, chData ) )
            {
                if (chData.IsEmpty() != 0)
                {
                    hr = WBEM_E_INVALID_PARAMETER;
            
                    break;
                }

                if (chData.GetLength() > OPAQUESETTINGS_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                    break;
                }

                lstrcpy(szName, chData);

                lRet = RegSetValueEx( hKey ,
                                        REG_TS_CLUSTER_OPAQUESETTINGS,
                                        NULL ,
                                        REG_SZ,
                                        ( CONST LPBYTE )szName ,
                                        sizeof (szName) );
        
                ERR((TB, "Win32_TSSessionDirectory@PutInstance: AdditionalParams returned 0x%x" , lRet));
            }                                    

            RegCloseKey( hKey );            
        }
        
        if (g_pCfgComp != NULL)
        {
            g_pCfgComp->ForceUpdate();
        }

    }while (0);

    return hr;   
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\winstation.cpp ===
/******************************************************************
Copyright (C) 2000 Microsoft Corp.

  Terms.CPP -- WMI provider class implementation
  
    Generated by Microsoft WMI Code Generation Engine
    
      TO DO: - See individual function headers
      - When linking, make sure you link to framedyd.lib & 
      msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).
      
        Description: 
        
          
            
******************************************************************/
#include "stdafx.h"
#include <fwcommon.h>  // This must be the first include.
#include "Winstation.h"
#include "registry.h"
#include "winsta.h"
#include "resource.h"
#include <regapi.h>
#include <sddl.h>
#include <provider.h>


#define ARRAYSIZE( rg ) sizeof( rg ) / sizeof( rg[0] )
#define GUID_LENGTH 40
TCHAR tchErrorMessage[ 80 ] = {0};

const static WCHAR* pErrorClass = L"\\\\.\\root\\cimv2:TerminalError";


/*****************************************************************************
*
*  FUNCTION    :   CWin32_Terminal::CWin32_Terminal
*
*  DESCRIPTION :   Constructor
*
*  INPUTS      :   none
*
*  RETURNS     :   nothing
*
*  COMMENTS    :   Calls the Provider constructor.
*
*****************************************************************************/
CWin32_Terminal::CWin32_Terminal (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
    int retval = 1;

    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_Terminal_ctor"));

        _tcscpy(m_szEnableTerminal, _T("fEnableTerminal"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szNewTerminalName, _T("NewTerminalName"));

        _tcscpy(m_szEnable, _T("Enable"));

        _tcscpy(m_szRename, _T("Rename"));

        _tcscpy(m_szDelete, _T("Delete"));
        
    }
}


//==================
/*****************************************************************************
*
*  FUNCTION    :   CWin32_Terminal::~CWin32_Terminal
*  DESCRIPTION :   Destructor
*  INPUTS      :   none
*  RETURNS     :   nothing
*****************************************************************************/

CWin32_Terminal::~CWin32_Terminal ()
{
    
}


//==================
/*****************************************************************************
*
*  FUNCTION    :    CWin32_Terminal::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/



HRESULT CWin32_Terminal::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;    	
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

	hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        

	TRC2((TB,"Terminal@EnumerateInstances: GetWinstationList ret 0x%x" , hr )); 	
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"Terminal@EnumerateInstances: CreateNewInstance failed"));                
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }              
            
            hr = LoadPropertyValues( pInstance, BIT_ALL_PROPERTIES, &pWS[ ulNum ] );
            
            if (SUCCEEDED( hr ) ) 
            {
                hr = pInstance->Commit();       
            }            
            pInstance->Release( );
        }
    }

    if( pWS != NULL)
    {
        CoTaskMemFree(pWS);
    }
    
    return hr;
}


//=--------------------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_Terminal::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key property, TerminalName. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*****************************************************************************/

HRESULT CWin32_Terminal::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;   
    LONG lSize;
    ULONGLONG ulRequiredProperties = 0;
    PWS  pWS = NULL;
    CHString chTermName;

    TRC2((TB,"TSCFGWMI!CWin32_Terminal_GetObject"));
    
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"Terminal@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szEnableTerminal))
        ulRequiredProperties |= BIT_FENABLETERMINAL;

    hr = StackObj.m_pCfgComp->GetWSInfo( ( LPTSTR )( LPCTSTR )chTermName, &lSize, &pWS);
    
    if( SUCCEEDED (hr) && pWS != NULL )        
    {
        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS);        
    }
    else
    {
        hr = WBEM_E_INVALID_OBJECT;
    }
    

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }    

    return hr ;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_Terminal::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*                  There are two different ways query processing
*                  can be used to improve performance.  
* 
* Method 1 - Returns data for only those fields that were requested.  This can  
*            optimize performance if some properties are very expensive to retrieve.  
*
* Method 2 - Returns only the requested records in the "Where" clause. There is a method
*            that can be run against the CFrameworkQuery object where you pass it the name
*            of a property, and it will tell you all the values they requested.  For example,  
*            if the query is of the form 
*            'Select * from Win32_Terminal where TerminalName = "RDP-Tcp" or TerminalName = "ICA-Tcp"',
*            GetValuesForProp(L"TerminalName") sends back an array that contains {"RDP-Tcp", "ICA-Tcp"}.  
*            Or if the query was of the form 
*            'Select * from Win32_Terminal where TerminalName = "RDP-Tcp" AND fEnableTerminal = TRUE' 
*            (note that this query, unlike the one in the paragraph above, uses AND), then 
*            GetValuesForProp(L"TerminalName") will return {"RDP-Tcp"}.
*
*****************************************************************************/
HRESULT CWin32_Terminal::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{    
   
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szEnableTerminal))
        ulRequiredProperties |= BIT_FENABLETERMINAL;
    
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
	
    
	hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {  
            
            // Method 2 - Check if the query CAN be processed by 'name'. If yes, return only those names.
            
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {                
                CInstance* pInstance = CreateNewInstance(pMethodContext); 
                
                if( pInstance != NULL)
                {            
                    pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                    hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
            
                    if( SUCCEEDED( hr ) )
                    {
                        hr = pInstance->Commit();
                    }                
                    pInstance->Release();
                }
            }
        }
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
    
    return hr;
    
}


//=-----------

BOOL CWin32_Terminal::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    : CWin32_Terminal::PutInstance
*
*  DESCRIPTION :   
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, 
*                       or are creating a 'method only' provider, remove this 
*                       method.
*
*****************************************************************************/
HRESULT CWin32_Terminal::PutInstance ( const CInstance &Instance, long lFlags)
{

    /*
    HRESULT hr = WBEM_S_NO_ERROR; 
    DWORD dwfEnable = 0;
    CHString chTermName; 
    ULONG ulTerminals = 0;
    ULONG ulSize = 0;
    ULONG ulNum = 0;
    PWS pWS = NULL;

    static USERCONFIG g_uc;

    static ASYNCCONFIG g_ac;
    
    if( g_pCfgComp == NULL ) 
    {
        ERR((TB,"Terminal@PutInstance: invalid interface" ));
        
        return WBEM_E_INITIALIZATION_FAILURE;
    }
    
    Instance.GetDWORD(m_szEnableTerminal, dwfEnable);
    
    if ( dwfEnable != 0 && dwfEnable !=1 )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength( ) > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    hr = g_pCfgComp->ForceUpdate();
    

    if( SUCCEEDED( hr ))
    {        
        hr = g_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    }  
    
    do
    {        
        if( SUCCEEDED( hr ) && pWS != NULL )
        {           
            for ( ulNum = 0; ulNum < ulTerminals ; ulNum++)
            {               
                if( _tcsicmp( (LPCTSTR) &pWS[ulNum].Name, (LPTSTR)(LPCTSTR) chTermName) == 0)
                {
                    hr = g_pCfgComp->EnableWinstation( (LPTSTR) (LPCTSTR) chTermName,  dwfEnable);
                    break;
                }
            }

            if( ulNum >= ulTerminals )
            {
                ULONG ulSize = 0;

                lstrcpy( pWS->Name, (LPTSTR)(LPCTSTR)chTermName);
                pWS->fEnableWinstation = 1;
                pWS->uMaxInstanceCount = 0xffffffff;
                lstrcpy( pWS->Comment, L"");
                lstrcpy( pWS->pdName, L"tcp");
                lstrcpy( pWS->wdName, L"Microsoft RDP 5.1");
                pWS->PdClass = 2;
                pWS->LanAdapter = 0;
        
    
                RegDefaultUserConfigQuery( NULL ,
                    &g_uc,
                    sizeof( USERCONFIG ) ,
                    &ulSize );

                hr = g_pCfgComp->CreateNewWS( *pWS, sizeof( USERCONFIG ) , &g_uc, NULL);            
                TRC2((TB,"Terminal@PutInstance: CreateNewWS returned 0x%x\n", hr));
            }
        }       
        if( FAILED( hr ) )
        {
            CHString sRelPath;
        
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
        
            CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance);
        
            if( pErrorInstance != NULL )
            {
                LoadString( g_hInstance , IDS_ERR_PUTTERMINAL, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
            
                LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
            
                pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TERMINAL_Prov);
                pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
            
                pErrorInstance->SetCHString(L"TerminalName", chTermName );
            
                IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
            
                MethodContext *pMethodContext = Instance.GetMethodContext(); 
            
                if( pObj != NULL )
                {
                    if (pMethodContext != NULL)
                    {
                        pMethodContext->SetStatusObject(pObj);
                    }
                
                
                    pObj->Release();
                }
                pErrorInstance->Release();
            }
        }
    }while (0);

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);        
    }
   
    return hr;
    */
    return WBEM_E_PROVIDER_NOT_CAPABLE;

    
}

//=----------------------------------------------------------------------------------------------------------

HRESULT CWin32_Terminal::DeleteInstance ( const CInstance &Instance,  long lFlags )
{
    
    return WBEM_E_PROVIDER_NOT_CAPABLE;
/*
    HRESULT hr = WBEM_E_NOT_FOUND;
    
    CHString chTermName;
    
    if( g_pCfgComp == NULL )
    {
        return WBEM_E_INITIALIZATION_FAILURE;
    }
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }    

    hr = g_pCfgComp->DeleteWS((LPTSTR)(LPCTSTR) chTermName);

    TRC2((TB,"Terminal@ExecMethod: Delete returned 0x%x\n" , hr ));
    
    return hr;
  */     
    
}

//=----------------------------------------------------------------------------------------------------------
HRESULT CWin32_Terminal::ExecMethod ( const CInstance& Inst,
                                     const BSTR bstrMethodName,
                                     CInstance *pInParams,
                                     CInstance *pOutParams,
                                     long lFlags)
                                     
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
	ICfgComp *pCfgComp = NULL;

    if( pInParams == NULL)
    {
        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }

    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    
    if( _wcsicmp(bstrMethodName, m_szEnable ) == 0 )
    {
        // Enables or Disables the Terminal.
        // Return Value: 0 if Success or an error.
        // uint32 Enable ([In] Boolean fEnable)
        
        DWORD dwfEnable = 0;
        ULONG  Size = 0;
        bool bRet;
        
        bRet = pInParams->GetDWORD(m_szEnableTerminal, dwfEnable);
        
        if ( !bRet || ( dwfEnable != 0 && dwfEnable != 1 ) )
        {
            return WBEM_E_INVALID_METHOD_PARAMETERS;
        }
        
        hr = StackObj.m_pCfgComp->EnableWinstation( (LPTSTR)(LPCTSTR) chTermName, dwfEnable);            
        
        TRC2((TB,"Terminal@ExecMethod: Enable returned 0x%x\n" , hr ));

        if( SUCCEEDED( hr ) )
        {
            hr = StackObj.m_pCfgComp->ForceUpdate();
        }
        
        if( SUCCEEDED( hr ) && pOutParams != NULL )
        {
            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
        }                 
    }
    else if( _wcsicmp( bstrMethodName , m_szRename ) == 0 )
    {
        //  Renames the Terminal.
        //  uint32 Rename([In] string NewTerminalName) 
        
        CHString chNewTermName;

        pInParams->GetCHString(m_szNewTerminalName, chNewTermName);
        
        if ( chNewTermName.GetLength() > WINSTATIONNAME_LENGTH)
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        
        if ( chNewTermName.IsEmpty() != 0)
        {
            return WBEM_E_ILLEGAL_NULL;
        }
        
        hr = StackObj.m_pCfgComp->RenameWinstation((LPTSTR)(LPCTSTR) chTermName, (LPTSTR)(LPCTSTR) chNewTermName);
        
        TRC2((TB,"Terminal@ExecMethod: Rename returned 0x%x\n" , hr ));

        if( SUCCEEDED( hr ) )
        {
            hr = StackObj.m_pCfgComp->ForceUpdate();
        }
        
        if (SUCCEEDED (hr) && pOutParams != NULL )
        {
            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
            
        }       
    }
    
    else if (_wcsicmp(bstrMethodName, m_szDelete) == 0)
    {
        //  Delete the Terminal.  
        //  uint32 Delete() ;
        
        hr = StackObj.m_pCfgComp->DeleteWS((LPTSTR)(LPCTSTR) chTermName);

        TRC2((TB,"Terminal@ExecMethod: Delete returned 0x%x\n" , hr ));
        
        if ( SUCCEEDED (hr) && pOutParams != NULL )
        {                
            
            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
        }
        else
        {
            return WBEM_E_INVALID_METHOD_PARAMETERS;
        }                       
    }
    
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }  
    TRC2((TB,"Terminal@ExecMethod: Delete returned 0x%x\n" , hr ));  
	
    return hr;
}
//=--------------------


HRESULT CWin32_Terminal::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
	    
    
    if( pInstance == NULL )
    { 
        TRC2((TB,"Terminal@LoadPropertyValues: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if( ulRequiredProperties & BIT_TERMINALNAME)
    {                
        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        
    } 
    
    if( ulRequiredProperties & BIT_FENABLETERMINAL)
    {                
        pInstance->SetDWORD(m_szEnableTerminal, pWS->fEnableWinstation);
        
    }  	
    
    return S_OK;
}


//------------------------------

CWin32_TSGeneralSetting::CWin32_TSGeneralSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{
    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSGeneralSetting_ctor"));
        
        _tcscpy(m_szTerminalProtocol, _T("TerminalProtocol"));

        _tcscpy(m_szTransport, _T("Transport"));

        _tcscpy(m_szComment, _T("Comment"));

        _tcscpy(m_szWindowsAuthentication, _T("WindowsAuthentication"));

        _tcscpy(m_szEncryptionLevel, _T("MinEncryptionLevel"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szSetEncryptionLevel, _T("SetEncryptionLevel"));
               
    }

    RegGetMachinePolicy(&m_gpPolicy);
}
//=--------------------

CWin32_TSGeneralSetting::~CWin32_TSGeneralSetting ()
{
    
}



//=---------------------

BOOL CWin32_TSGeneralSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=--------------------

HRESULT CWin32_TSGeneralSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    LONG lSize;
    ULONGLONG ulRequiredProperties = 0;
    PWS pWS = NULL;
    CHString chTermName;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSGeneralSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szComment))
        ulRequiredProperties |= BIT_COMMENT;
    
    if (Query.IsPropertyRequired(m_szEncryptionLevel))
        ulRequiredProperties |= BIT_ENCRYPTIONLEVEL;
    
    if (Query.IsPropertyRequired(m_szTerminalProtocol))
        ulRequiredProperties |= BIT_TERMINALPROTOCOL;
    
    if (Query.IsPropertyRequired(m_szTransport))
        ulRequiredProperties |= BIT_TRANSPORT;
    
    if (Query.IsPropertyRequired(m_szWindowsAuthentication))
        ulRequiredProperties |= BIT_WINDOWSAUTHENTICATION;
    
    hr = StackObj.m_pCfgComp->GetWSInfo( (LPTSTR) (LPCTSTR) chTermName, &lSize, &pWS);
    
    TRC2((TB,"TSGeneralSetting@GetObject: returned 0x%x\n" , hr ));   
    
    
    if( SUCCEEDED( hr ) && (pWS != NULL) )
    {           
        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );

        if( !(SUCCEEDED( hr )) )
        {        
            hr = WBEM_E_INVALID_OBJECT;
        }
        
    }
    else
    {
        hr = WBEM_E_INVALID_OBJECT;
    }


    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
    
    return hr ;
}

//=--------------------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSGeneralSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/


HRESULT CWin32_TSGeneralSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSGeneralSetting@EnumerateInstances: CreateNewInstance failed" ));
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSGeneralSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr )); 
            
            hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES, &pWS[ ulNum ] );
            
            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();                               
            }
            
            pInstance->Release( );
        }        
    }
    

    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
}


//=----------------------------------------------------------------------------------------------------------
HRESULT CWin32_TSGeneralSetting::ExecMethod ( const CInstance& Inst,
                                                    const BSTR bstrMethodName,
                                                    CInstance *pInParams,
                                                    CInstance *pOutParams,
                                                    long lFlags)
                                                    
{
    
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    PUSERCONFIG pUser = NULL;
    LONG lSize;
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    
    if( _wcsicmp(bstrMethodName, m_szSetEncryptionLevel ) == 0 )
    {
        // Sets the EncryptionLevel to one of Low, Medium or High. 
        // uint32 SetEncryptionLevel ([In] uint32 EncryptionLevel)
        
        DWORD dwData = 0 ;
        DWORD dwStatus = 0;
        ULONG  Size = 0;
        bool bRet;
        
        RegGetMachinePolicy(&m_gpPolicy);
        
        do
        {
            if( pInParams != NULL )
            {  
                
                bRet = pInParams->GetDWORD(m_szEncryptionLevel, dwData);
                
                TRC2((TB,"m_gpPolicy.fPolicyMinEncryptionLevel ret 0x%x\n", m_gpPolicy.fPolicyMinEncryptionLevel));                 
                
                if( m_gpPolicy.fPolicyMinEncryptionLevel == 0 )
                {
                    TRC2((TB,"Condition to update fPolicyMinEncryptionLevel satisfied"));     
                    
                    hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);

                    if( SUCCEEDED( hr ) && pUser != NULL )
                    {                    
                        if( GetVersionEx( &OsVersionInfo))
                        {
                            if( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion == 0)
                            {

                                if( dwData < 1 || dwData > 3)
                                {
                                    hr = WBEM_E_INVALID_PARAMETER;

                                    break;
                                }
                    
                                pUser->MinEncryptionLevel = dwData;
                    
                                hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );

                                if( SUCCEEDED( hr ))
                                {
                                    hr = StackObj.m_pCfgComp->ForceUpdate();
                                }
                                
                            }
                            else
                            {                               
                                if( dwData < 2 || dwData > 3)
                                {
                                    hr = WBEM_E_INVALID_PARAMETER;

                                    break;
                                }
                    
                                pUser->MinEncryptionLevel = dwData;
                    
                                hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );  
                                
                                if( SUCCEEDED( hr ))
                                {
                                    hr = StackObj.m_pCfgComp->ForceUpdate();
                                }
                            }
                        }
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
                TRC2((TB,"TSGeneralSetting@ExecMethod: SetEncryptionLevel returned 0x%x\n" , hr));                     
                
            }            
            else
            {
                hr = WBEM_E_INVALID_METHOD_PARAMETERS;
            }  
            
        }while (0);

        if (pUser != NULL)
        {
            CoTaskMemFree (pUser);
        }        
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }
	
    return hr;
}


//=--------------------


HRESULT CWin32_TSGeneralSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szComment))
        ulRequiredProperties |= BIT_COMMENT;
    
    if (Query.IsPropertyRequired(m_szEncryptionLevel))
        ulRequiredProperties |= BIT_ENCRYPTIONLEVEL;
    
    if (Query.IsPropertyRequired(m_szTerminalProtocol))
        ulRequiredProperties |= BIT_TERMINALPROTOCOL;
    
    if (Query.IsPropertyRequired(m_szTransport))
        ulRequiredProperties |= BIT_TRANSPORT;
    
    if (Query.IsPropertyRequired(m_szWindowsAuthentication))
        ulRequiredProperties |= BIT_WINDOWSAUTHENTICATION;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    ERR((TB,"TSGeneralSetting@ExecQuery: CreateNewInstance failed"));                    
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);        
    }
    
    return hr;
}




//=----------

HRESULT CWin32_TSGeneralSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG  ulTerminals = 0;
    ULONG  ulNumPd = 0; 
    ULONG ulSize = 0;
    LONG lSize = 0;
    PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSGeneralSetting@LoadPropertyValues: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    if( ulRequiredProperties & BIT_TERMINALNAME)
    {
        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);    
    }
    
    TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetTerminalName"));

    if( pWS != NULL )
    {
    
        if( ulRequiredProperties & BIT_TERMINALPROTOCOL )
        {      
            pInstance->SetWCHARSplat(m_szTerminalProtocol, pWS->wdName);
        
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetTerminalProtocol"));              
        }
    
        if( ulRequiredProperties & BIT_TRANSPORT)
        {
        
            pInstance->SetWCHARSplat(m_szTransport, pWS->pdName);
        
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetTransportTypes"));
        
        }
    
        if( ulRequiredProperties & BIT_COMMENT )
        {
        
            pInstance->SetWCHARSplat(m_szComment, pWS->Comment);
        
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetComment"));
        }
    
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        
        if(( ulRequiredProperties & BIT_WINDOWSAUTHENTICATION) && ( SUCCEEDED(hr) ) && pUser != NULL) 
        {      
            pInstance->SetDWORD(m_szWindowsAuthentication, pUser->fUseDefaultGina);
            
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetComment ret 0x%x\n" , hr));
        }
        
        
        if(( ulRequiredProperties & BIT_ENCRYPTIONLEVEL) && ( SUCCEEDED (hr) ) && pUser != NULL)
        {            
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyMinEncryptionLevel != 0 )
            {
                pInstance->SetDWORD(m_szEncryptionLevel, m_gpPolicy.MinEncryptionLevel );
            }
            else
            {
                pInstance->SetDWORD(m_szEncryptionLevel, pUser->MinEncryptionLevel);
            }
            
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetEncryptionLevel ret 0x%x\n" , hr));        
        }
    }
    
	
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
    
    return hr;
}
//=--------------------

HRESULT CWin32_TSGeneralSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
	
    HRESULT hr= WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    CHString chTermName;
    CHString chData;
    PUSERCONFIG pUser = NULL;   
    PWS  pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
    
    do
    {        
        if (SUCCEEDED ( hr ) && pWS != NULL)
        {
            hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
            
            if(SUCCEEDED (hr)  && pUser != NULL )
            {
                
                Instance.GetCHString(m_szTerminalProtocol, chData);
                
                if (chData.GetLength() > WINSTATIONNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                wcscpy(pWS->wdName, (LPTSTR) (LPCTSTR) chData);
                
                Instance.GetCHString(m_szTransport, chData);
                
                if (chData.GetLength() > WINSTATIONNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                wcscpy(pWS->pdName, (LPTSTR)(LPCTSTR) chData);
                
                Instance.GetCHString(m_szComment, chData);
                
                if ( chData.GetLength() > WINSTATIONCOMMENT_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                wcscpy(pWS->Comment, (LPTSTR) (LPCTSTR) chData);
                
                
                Instance.GetDWORD(m_szWindowsAuthentication, dwData);
                
                if (dwData != 0 && dwData != 1)
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }
                
                pUser->fUseDefaultGina = dwData;
                
                hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                
                TRC2((TB,"TSGeneralSetting@PutInstance: SetUserConfig ret 0x%x\n" , dwStatus));
                
                hr = StackObj.m_pCfgComp->UpDateWS( pWS, (DWORD)BIT_ALL_PROPERTIES , &dwStatus, TRUE );
                
                TRC2((TB,"TSGeneralSetting@PutInstance: UpdateWS ret 0x%x\n" , dwStatus));                                                

                if( SUCCEEDED( hr ))
                {
                    hr = StackObj.m_pCfgComp->ForceUpdate();
                }
            }
            else
            {                
                CHString sRelPath;
                
                Instance.GetCHString(L"__RelPath", sRelPath);
                CInstance *pErrorInstance = NULL;
                
             
                TRC2((TB,"TSGeneralSetting@PutInstance: ret 0x%x\n" , hr));
                
                if( SUCCEEDED( hr ) )
                {
                    if (pErrorInstance != NULL)
                    {
                        LoadString( g_hInstance , IDS_ERR_PUTTSGCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                        pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                        
                        LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                        pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                        
                        pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                        pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSGENERALSETTING_Prov);
                        pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                        
                        IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                        
                        if (pObj != NULL)
                        {                        
                            MethodContext *pMethodContext = Instance.GetMethodContext();  
                            
                            if (pMethodContext != NULL)
                                pMethodContext->SetStatusObject(pObj);
                            
                            pObj->Release();
                        }
                        pErrorInstance->Release();
                    }
                    
                }
                TRC2((TB,"TSGeneralSetting@PutInstance: ret 0x%x\n" , hr));
            }
            
        } 
    }while (0);

    
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }    

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    
    return hr;
}


//=-------------------------------------------------------
CWin32_TSLogonSetting::CWin32_TSLogonSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{	

    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSLogonSetting_ctor"));

        _tcscpy(m_szClientLogonInfoPolicy, _T("ClientLogonInfoPolicy"));

        _tcscpy(m_szPromptForPassword, _T("PromptForPassword"));

        _tcscpy(m_szUserName, _T("UserName"));

        _tcscpy(m_szDomain, _T("Domain"));

        _tcscpy(m_szPassword, _T("Password"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szExplicitLogon, _T("ExplicitLogon"));

        _tcscpy(m_szSetPromptForPassword, _T("SetPromptForPassword"));
    }
    RegGetMachinePolicy(&m_gpPolicy);
}
//=--------------------

CWin32_TSLogonSetting::~CWin32_TSLogonSetting ()
{
    
}

//=------------

BOOL CWin32_TSLogonSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


//=--------------------

HRESULT CWin32_TSLogonSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
    HRESULT hr= WBEM_E_NOT_FOUND;
    LONG  lSize ;
    ULONGLONG ulRequiredProperties = 0;
    PWS pWS = NULL;
    CHString chTermName;

    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        TRC2((TB,"TSLogonSetting@GetObject: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szClientLogonInfoPolicy))
        ulRequiredProperties |= BIT_CLIENTLOGONINFOPOLICY;
    
    if (Query.IsPropertyRequired(m_szDomain))
        ulRequiredProperties |= BIT_DOMAIN;
    
    if (Query.IsPropertyRequired(m_szPromptForPassword))
        ulRequiredProperties |= BIT_PROMPTFORPASSWORD;
    
    if (Query.IsPropertyRequired(m_szUserName))
        ulRequiredProperties |= BIT_USERNAME;
    
    if ( pInstance != NULL )
    {
        hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);

        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );
        }                
    }
    	
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
}
//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSLogonSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSLogonSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG  ulTerminals = 0;
    LONG ulNum = 0;
    ULONG  ulSize = 0; 
    PWS pWS = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR ((TB,"TSLogonSetting@EnumerateInstances: CreateNewInstance failed"));
                                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSLogonSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr));

            hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES, &pWS[ulNum] );
            
            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();
            }
            pInstance->Release();
        }        
    } 
    

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    
    return hr;
}
//=--------------------
//=------@resume here 
HRESULT CWin32_TSLogonSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG lSize = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSLogonSetting@LoadPropertyValues: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    if( ulRequiredProperties & BIT_TERMINALNAME)
    {
        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);    
    }
    
    TRC2((TB,"TSLogonSetting@LoadPropertyValues: GetTerminalName" ));
    
    hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
    
    TRC2((TB,"TSLogonSetting@LoadPropertyValues ret 0x%x\n" , hr ));
    
    if ( SUCCEEDED (hr) && pUser != NULL )
    {
        
        if( ulRequiredProperties & BIT_CLIENTLOGONINFOPOLICY)
        {         
            pInstance->SetDWORD(m_szClientLogonInfoPolicy, pUser->fInheritAutoLogon);
        }
        TRC2((TB,"TSLogonSetting@LoadPropertyValues: ClientLogonInfoPolicy" ));                  
        
        if( ulRequiredProperties & BIT_PROMPTFORPASSWORD)
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyPromptForPassword != 0 )
            {
                pInstance->SetDWORD(m_szPromptForPassword, m_gpPolicy.fPromptForPassword);
            }
            else
            {
                pInstance->SetDWORD(m_szPromptForPassword, pUser->fPromptForPassword);
            }
        }
        TRC2((TB,"TSLogonSetting@LoadPropertyValues: PromptForPassword" ));         
        
        if( ulRequiredProperties & BIT_USERNAME)
        {                          
            pInstance->SetWCHARSplat(m_szUserName, pUser->UserName);
        }
        TRC2((TB,"TSLogonSetting@LoadPropertyValues: UserName" ));                
        
        if( ulRequiredProperties & BIT_DOMAIN)
        {                          
            pInstance->SetWCHARSplat(m_szDomain, pUser->Domain);
        }
        TRC2((TB,"TSLogonSetting@LoadPropertyValues: Domain" ));        
    } 

	
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSLogonSetting::PutInstance ( const CInstance &Instance, long lFlags)
{

    HRESULT hr= WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    CHString chTermName;
    DWORD dwStatus = 0;
    LONG lSize;
    PUSERCONFIG pUser = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        
        if( SUCCEEDED( hr ) && pUser != NULL )
        {
            Instance.GetDWORD(m_szClientLogonInfoPolicy, dwData);
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritAutoLogon = dwData;
            
            hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus ); 
            
            if( SUCCEEDED( hr ) )
            {
                hr = StackObj.m_pCfgComp->ForceUpdate();
            }
        }        
        else
        {
            TRC2((TB,"TSLogonSetting@PutInstance ret 0x%x\n" , hr ));             
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ))
            {
                TRC2((TB,"TSLogonSetting@PutInstance: GetInstanceByPath ret 0x%x\n" , hr ));

                if( pErrorInstance != NULL )
                {
                    
                    LoadString( g_hInstance , IDS_ERR_PUTTSLCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSLOGONSETTING_Prov);
                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                    if( pObj != NULL )
                    {
                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        
                        if( pMethodContext != NULL )
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        pObj->Release();
                    }
                    pErrorInstance->Release();
                }
                
            }            
        }
    }while (0);

	
    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }
    
    return hr;
}
//=--------------------

HRESULT CWin32_TSLogonSetting::ExecMethod ( const CInstance& Inst,
                                                  const BSTR bstrMethodName,
                                                  CInstance *pInParams,
                                                  CInstance *pOutParams,
                                                  long lFlags)
                                                  
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    PUSERCONFIG pUser = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
	
    if( pInParams == NULL)
    {
        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }
            
    
    // Sets the properties UserName, Password and Domain which specify 
    // the credentials explicitly to be used for authentication.
                              
    //  uint32 ExplicitLogon([In] string UserName, [In] string Password, [In] string Domain)
    
    if (_wcsicmp(bstrMethodName, m_szExplicitLogon) == 0)
    {
        
        DWORD dwData = 0;
        DWORD dwStatus = 0;
        CHString chData;
        CHString chTermName;
        LONG lSize;
        
        
        Inst.GetCHString(m_szTerminalName, chTermName);
        
        if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH )
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        
        if( chTermName.IsEmpty() != 0)
        {
            return WBEM_E_ILLEGAL_NULL;
        }
        
    
        hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR) (LPCTSTR) chTermName , &lSize, &pUser, TRUE);
        
        do
        {
            if( SUCCEEDED( hr ) && pUser != NULL )
            {
                dwData = pUser->fInheritAutoLogon;
                
                if( dwData == 0 )
                {   
                    chData.Empty();

                    pInParams->GetCHString( m_szUserName, chData );
                    
                    if( chData.GetLength() > USERNAME_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                        
                        break;
                    }

                    wcscpy(pUser->UserName, (LPTSTR) (LPCTSTR) chData);                        

                    chData.Empty();
                    
                    pInParams->GetCHString( m_szDomain, chData );
                    
                    if( chData.GetLength() > APPSERVERNAME_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                        
                        break;
                    }

                    wcscpy(pUser->Domain, (LPTSTR) (LPCTSTR) chData);                        

                    chData.Empty();
                    
                    pInParams->GetCHString( m_szPassword, chData );
                    
                    if( chData.GetLength() > PASSWORD_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                        
                        break;
                    }
                    
                    wcscpy( pUser->Password, (LPTSTR) (LPCTSTR) chData );                        
                    
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                    if( SUCCEEDED (hr) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSLogonSetting@ExecMethod: ExplicitLogon ret 0x%x\n" , hr ));
                    } 
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;                        
                }
                
            }
        }while(0);
        
    }
    
    else if( _wcsicmp( bstrMethodName, m_szSetPromptForPassword ) == 0 )
    {
        
        DWORD dwData = 0;
        DWORD dwStatus = 0;
        CHString chTermName;
        LONG lSize;
        bool bRet;
        
        
        Inst.GetCHString(m_szTerminalName, chTermName);
        
        if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH )
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        
        if( chTermName.IsEmpty() != 0)
        {
            return WBEM_E_ILLEGAL_NULL;
        }
        
        hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
        
        RegGetMachinePolicy(&m_gpPolicy);
        
        do
        {
            if( SUCCEEDED (hr) && pInParams != NULL && pUser != NULL )
            {      
                bRet = pInParams->GetDWORD( m_szPromptForPassword, dwData );
                
                if( ( m_gpPolicy.fPolicyPromptForPassword == 0) && bRet != 0 )
                {                    
                    if( dwData != 0 && dwData != 1 )
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                        
                        break;
                    }
                    
                    pUser->fPromptForPassword = dwData;
                    
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                    if ( SUCCEEDED (hr) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSLogonSetting@ExecMethod: PromptForPassword ret 0x%x\n" , hr ));
                    } 
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
                
            }
        } while (0);
        
    }
    
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }
    
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }

    return hr;
}

//=----------------------------


HRESULT CWin32_TSLogonSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
	
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szClientLogonInfoPolicy))
        ulRequiredProperties |= BIT_CLIENTLOGONINFOPOLICY;
    
    if (Query.IsPropertyRequired(m_szDomain))
        ulRequiredProperties |= BIT_DOMAIN;
        
    if (Query.IsPropertyRequired(m_szPromptForPassword))
        ulRequiredProperties |= BIT_PROMPTFORPASSWORD;
    
    if (Query.IsPropertyRequired(m_szUserName))
        ulRequiredProperties |= BIT_USERNAME;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++ )
        {  
            
            
            // Method 2 - Check to see if the query CAN be processed by 'name', if so,
            // only return those names.
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name) )
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL )
                {
                    ERR( (TB,"TSLogonSetting@ExecQuery: CreateNewInstance failed" ) );
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString( m_szTerminalName, CHString(pWS[ulNum].Name) );

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }  	
    
    return hr;
    
}




//=--------------------Win32_TSSessionSettingsConfig------------------------



CWin32_TSSessionSetting::CWin32_TSSessionSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{
    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSSessionSetting_ctor"));

        _tcscpy(m_szTimeLimitPolicy, _T("TimeLimitPolicy"));

        _tcscpy(m_szActiveSessionLimit, _T("ActiveSessionLimit"));

        _tcscpy(m_szDisconnectedSessionLimit, _T("DisconnectedSessionLimit"));

        _tcscpy(m_szIdleSessionLimit, _T("IdleSessionLimit"));

        _tcscpy(m_szBrokenConnectionPolicy, _T("BrokenConnectionPolicy"));

        _tcscpy(m_szReconnectionPolicy, _T("ReconnectionPolicy"));

        _tcscpy(m_szBrokenConnectionAction, _T("BrokenConnectionAction"));

        _tcscpy(m_szSessionLimitType, _T("SessionLimitType"));

        _tcscpy(m_szValueLimit, _T("ValueLimit"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szTimeLimit, _T("TimeLimit"));

        _tcscpy(m_szBrokenConnection, _T("BrokenConnection"));

               
    }
}
//=--------------------
CWin32_TSSessionSetting::~CWin32_TSSessionSetting ()
{
    
}

//=-----------------

BOOL CWin32_TSSessionSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=--------------------

HRESULT CWin32_TSSessionSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    DWORD dwData = 0;
    CHString chTermName; 
    LONG  lSize ;
 //   PUSERCONFIG pUser = NULL;
    PWS pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSSessionSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }


    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;

    if (Query.IsPropertyRequired(m_szTimeLimitPolicy))
        ulRequiredProperties |= BIT_ACTIVESESSIONPOLICY;

    if (Query.IsPropertyRequired(m_szBrokenConnectionPolicy))
        ulRequiredProperties |= BIT_BROKENCONNECTIONPOLICY;

    if (Query.IsPropertyRequired(m_szActiveSessionLimit))
        ulRequiredProperties |= BIT_ACTIVESESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szBrokenConnectionAction))
        ulRequiredProperties |= BIT_BROKENCONNECTIONACTION;
    
    if (Query.IsPropertyRequired(m_szDisconnectedSessionLimit))
        ulRequiredProperties |= BIT_DISCONNECTEDSESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szIdleSessionLimit))
        ulRequiredProperties |= BIT_IDLESESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szReconnectionPolicy))
        ulRequiredProperties |= BIT_RECONNECTIONPOLICY;

    hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
    
    if ( pInstance != NULL && SUCCEEDED( hr ) && pWS != NULL )
    {
        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );
    }
    
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    	
    return hr;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSSessionSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSSessionSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{	
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG  ulTerminals = 0;
    ULONG ulNum = 0;
    ULONG  ulSize = 0; 
    LONG lSize = 0;
    PWS  pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSSessionSetting@EnumerateInstances: CreateNewInstance failed" ));
                                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSSessionSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr  ));

            hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ulNum] );

            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();
                                
            }
            
            pInstance->Release( );            
        }
        
    }  
    

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSSessionSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lSize ;
    DWORD dwData = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL ) 
    {
        ERR((TB,"TSSessionSetting@LoadPropertyValues: invalid pointer"  ));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    
    if ( pInstance != NULL && pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);        
        }
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSSessionSetting@LoadPropertyValues: GetUserConfig ret 0x%x\n" , hr   ));
        
        if ( SUCCEEDED (hr) && pUser != NULL )
        {
            
            if( ulRequiredProperties & BIT_ACTIVESESSIONPOLICY)
            {                
                pInstance->SetDWORD(m_szTimeLimitPolicy, pUser->fInheritMaxSessionTime);                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: TimeLimitPolicy"   ));
            
            
            if( ulRequiredProperties & BIT_ACTIVESESSIONLIMIT)
            {                          
                pInstance->SetDWORD(m_szActiveSessionLimit, pUser->MaxConnectionTime);
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: MaxConnectionTime"   ));          
            
            if( ulRequiredProperties & BIT_DISCONNECTEDSESSIONLIMIT)
            {                          
                pInstance->SetDWORD(m_szDisconnectedSessionLimit, pUser->MaxDisconnectionTime);
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: MaxDisconnectionTime" ));      
            
            if( ulRequiredProperties & BIT_IDLESESSIONLIMIT)
            {                          
                pInstance->SetDWORD(m_szIdleSessionLimit, pUser->MaxIdleTime);
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: MaxIdleTime" ));        
            
            if( ulRequiredProperties &  BIT_BROKENCONNECTIONPOLICY)
            {                          
                pInstance->SetDWORD(m_szBrokenConnectionPolicy, pUser->fInheritResetBroken);
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: BrokenConnectionPolicy" ));         
            
            if( ulRequiredProperties & BIT_BROKENCONNECTIONACTION)
            {                          
                pInstance->SetDWORD(m_szBrokenConnectionAction, pUser->fResetBroken);
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: BrokenConnectionAction" ));         
            
            if( ulRequiredProperties & BIT_RECONNECTIONPOLICY)
            {                          
                pInstance->SetDWORD(m_szReconnectionPolicy, pUser->fInheritReconnectSame);
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: ReconnectionPolicy" )); 
                       
        }
        
    }

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }

    return hr;
    
}

//=--------------------

HRESULT CWin32_TSSessionSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
	
    HRESULT hr= WBEM_S_NO_ERROR;
    CHString chTermName ;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    LONG lSize;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR) (LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        if( SUCCEEDED( hr ) && pUser != NULL )
        {
            Instance.GetDWORD(m_szTimeLimitPolicy, dwData);
            
            if (dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritMaxSessionTime = dwData;
            pUser->fInheritMaxDisconnectionTime = dwData;
            pUser->fInheritMaxIdleTime = dwData;
            
            Instance.GetDWORD( m_szBrokenConnectionPolicy, dwData );
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritResetBroken = dwData;
            
            Instance.GetDWORD( m_szReconnectionPolicy, dwData );
            
            if (dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritReconnectSame = dwData;
            
            hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
            
            TRC2((TB,"TSSessionSetting@PutInstance: SetUserConfig ret 0x%x\n" , dwStatus ));  
            
            if( SUCCEEDED( hr ))
            {
                hr = StackObj.m_pCfgComp->ForceUpdate();
            }
        }
        
        else
        {
            ERR((TB,"TSSessionSetting@PutInstance: Failed" ));
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSSessionSetting@PutInstance: GetInstanceByPath succeeded" ));

                if (pErrorInstance != NULL)
                {
                    
                    LoadString( g_hInstance , IDS_ERR_PUTTSSCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSSESSIONSETTING_Prov);
                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                    if (pObj != NULL)
                    {
                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        if (pMethodContext != NULL)
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        pObj->Release();
                    }
                    pErrorInstance->Release();
                }
                
            }
            TRC2((TB,"TSSessionSetting@PutInstance: GetInstanceByPath ret 0x%x\n" , hr ));     
        }
    }while (0);

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }
    	
    return hr;
}

//=--------------------

HRESULT CWin32_TSSessionSetting::ExecMethod ( const CInstance& Inst,
                                                    const BSTR bstrMethodName,
                                                    CInstance *pInParams,
                                                    CInstance *pOutParams,
                                                    long lFlags)
                                                    
{
	
    HRESULT hr= WBEM_E_NOT_FOUND;
    CHString chTermName;
    PUSERCONFIG pUser = NULL;
    LONG lSize;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}    
    
    Inst.GetCHString( m_szTerminalName, chTermName );
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty( ) != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR) (LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        if( SUCCEEDED (hr) && pUser != NULL && pInParams != NULL )
        {
            
            // SessionLimitType is an enumeration of the properties:
            // ActiveSessionLimit, DisconnectedSessionLimit and IdleSessionLimit
            // which specify the Maximum allowed time for Active, Disconnected Session 
            // Idle session limits. Value specifies the time in minutes.
                              
            // uint32 TimeLimit([In] uint32 SessionLimitType, [In] uint32 ValueLimit)
            
            if( _wcsicmp( bstrMethodName, m_szTimeLimit ) == 0 )
            {
                
                CHString chData;
                DWORD dwData = 0;
                DWORD dwStatus = 0;
                DWORD dwSessionType; 
                bool bRet;
                
                chData.Empty();
                
                pInParams->GetCHString( m_szSessionLimitType, chData );
                
                if( chData.IsEmpty() != 0 )
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }
                
                if( chData.CompareNoCase( m_szActiveSessionLimit ) == 0 )
                {
                    dwData = pUser->fInheritMaxSessionTime;

                    if( dwData == 0 )
                    {
                        bRet = pInParams->GetDWORD(m_szValueLimit, dwData);
                        
                        if ( !bRet )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        pUser->MaxConnectionTime = dwData;
                        
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                        
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            hr = StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD( L"ReturnValue", WBEM_S_NO_ERROR );
                            
                            TRC2((TB,"TSSessionSetting@ExecMethod:  TimeLimit - ActiveSessionLimit ret 0x%x\n" , hr  ));         
                        } 
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;                        
                    }
                }
                else if( chData.CompareNoCase( m_szDisconnectedSessionLimit ) == 0 )
                {
                    dwData = pUser->fInheritMaxSessionTime;
                    
                    if( dwData == 0 )
                    {
                        bRet = pInParams->GetDWORD(m_szValueLimit, dwData);
                        
                        if ( !bRet )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        pUser->MaxDisconnectionTime = dwData;
                        
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                        
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                            
                            TRC2((TB,"TSSessionSetting@ExecMethod:  TimeLimit - DisconnectedSessionLimit ret 0x%x\n" , hr  ));      
                        } 
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                        
                    }
                }
                else if( chData.CompareNoCase(m_szIdleSessionLimit) == 0)
                {
                    dwData = pUser->fInheritMaxSessionTime;

                    if( dwData == 0 )
                    {
                        bRet = pInParams->GetDWORD(m_szValueLimit, dwData);
                        

                        if ( !bRet )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        pUser->MaxIdleTime = dwData;
                        
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                        
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                            
                            TRC2((TB,"TSSessionSetting@ExecMethod:  TimeLimit - IdleSessionLimit ret 0x%x\n" , hr  ));    
                        } 
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                        
                    }
                }
                else 
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                    
                    break;
                }                     
            }
            
            else if( _wcsicmp( bstrMethodName, m_szBrokenConnection ) == 0 )
            {
                
                DWORD dwData = 0;
                DWORD dwStatus = 0; 
                bool bRet;
                
                dwData = pUser->fInheritResetBroken;

                if( dwData == 0 )
                {
                    bRet = pInParams->GetDWORD(m_szBrokenConnectionAction, dwData);
                    

                    if ( !bRet )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }
                    
                    pUser->fResetBroken = dwData;
                    
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSSessionSetting@ExecMethod:  BrokenConnection ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }                
            }                         
        }
        
    } while( 0 );


    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
	
    return hr;
}


//=--------------------------

HRESULT CWin32_TSSessionSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;	

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;

	if (Query.IsPropertyRequired(m_szTimeLimitPolicy))
        ulRequiredProperties |= BIT_ACTIVESESSIONPOLICY;

    if (Query.IsPropertyRequired(m_szBrokenConnectionPolicy))
        ulRequiredProperties |= BIT_BROKENCONNECTIONPOLICY;
    
    if (Query.IsPropertyRequired(m_szActiveSessionLimit))
        ulRequiredProperties |= BIT_ACTIVESESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szBrokenConnectionAction))
        ulRequiredProperties |= BIT_BROKENCONNECTIONACTION;
    
    if (Query.IsPropertyRequired(m_szDisconnectedSessionLimit))
        ulRequiredProperties |= BIT_DISCONNECTEDSESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szIdleSessionLimit))
        ulRequiredProperties |= BIT_IDLESESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szReconnectionPolicy))
        ulRequiredProperties |= BIT_RECONNECTIONPOLICY;
   
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {  
            
            // Method 2
            if (bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    TRC2((TB,"TSSessionSetting@ExecQuery: CreateNewInstance failed" ));
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }
    	
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
    	
    return hr;
    
}

//=----------------------Win32_TSEnvironmentSetting---------------------


CWin32_TSEnvironmentSetting::CWin32_TSEnvironmentSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{
    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSEnvironmentSetting_ctor"));

        _tcscpy(m_szInitialProgramPolicy, _T("InitialProgramPolicy"));

        _tcscpy(m_szInitialProgramPath, _T("InitialProgramPath"));

        _tcscpy(m_szStartIn, _T("StartIn"));

        _tcscpy(m_szClientWallPaper, _T("ClientWallPaper"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szInitialProgram, _T("InitialProgram"));
               
    }
}
//=--------------------

CWin32_TSEnvironmentSetting::~CWin32_TSEnvironmentSetting ()
{
}

//=---------------


BOOL CWin32_TSEnvironmentSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


//=--------------------

HRESULT CWin32_TSEnvironmentSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    CHString chTermName;
    LONG  lSize ;
    ULONGLONG ulRequiredProperties = 0;
    PWS pWS = NULL;
  //  PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if(  pInstance == NULL )
    {
        ERR((TB,"TSEnvironmentSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szClientWallPaper))
        ulRequiredProperties |= BIT_CLIENTWALLPAPER;
    
    if (Query.IsPropertyRequired(m_szInitialProgramPath))
        ulRequiredProperties |= BIT_INITIALPROGRAMPATH;
    
    if (Query.IsPropertyRequired(m_szInitialProgramPolicy))
        ulRequiredProperties |= BIT_INITIALPROGRAMPOLICY;
    
    if (Query.IsPropertyRequired(m_szStartIn))
        ulRequiredProperties |= BIT_STARTIN;
    
    if ( pInstance != NULL )
    {
        
        hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);

        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );
        }                        
    }    	

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
	
    return hr;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSEnvironmentSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSEnvironmentSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG ulNum = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    PWS  pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ); ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSEnvironmentSetting@EnumerateInstances: CreateNewInstance Failed" ));                
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }            

            hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES, &pWS[ulNum] );
            
            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();                                
            }
            
            pInstance->Release( );
        }
    }   
    
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
    
    return hr;
}

//=--------------------

HRESULT CWin32_TSEnvironmentSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
 	
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lSize ;
    DWORD dwData = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSEnvironmentSetting@LoadPropertyValues: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    if ( pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        }
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: GetTerminalName ret 0x%x\n" , hr  ));
        
        if ( SUCCEEDED (hr) && pUser != NULL )
        {
            
            if( ulRequiredProperties & BIT_INITIALPROGRAMPOLICY)
            {
                
                pInstance->SetDWORD(m_szInitialProgramPolicy, pUser->fInheritInitialProgram);
                
            }
            TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: InitialProgramPolicy"  ));
            
            if( ulRequiredProperties & BIT_INITIALPROGRAMPATH)
            {                          
                pInstance->SetWCHARSplat(m_szInitialProgramPath, pUser->InitialProgram);
                
            }
            TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: InitialProgramPath"  ));
            
            if( ulRequiredProperties & BIT_STARTIN)
            {                          
                pInstance->SetWCHARSplat(m_szStartIn, pUser->WorkDirectory);
                
            }
            TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: StartIn"  ));
            
            if( ulRequiredProperties & BIT_CLIENTWALLPAPER)
            {                          
                pInstance->SetDWORD(m_szClientWallPaper, pUser->fWallPaperDisabled);
                
            }
            TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: ClientWallPaper"  ));            
        }                  
    }
        
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
	
    return hr;
    
}

//=--------------------

HRESULT CWin32_TSEnvironmentSetting::PutInstance ( const CInstance &Instance, long lFlags)
{	
    HRESULT hr= WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    CHString chTermName;
    LONG lSize;
    PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        
        if( SUCCEEDED (hr) && pUser != NULL )
        {
            Instance.GetDWORD(m_szInitialProgramPolicy, dwData);
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritInitialProgram = dwData;
            
            Instance.GetDWORD( m_szClientWallPaper, dwData );
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fWallPaperDisabled = dwData;
            
            hr = StackObj.m_pCfgComp->SetUserConfig((LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
            
            if( SUCCEEDED( hr ))
            {
                hr = StackObj.m_pCfgComp->ForceUpdate();
            }
            
        }
        else
        {
            TRC2((TB,"TSEnvironmentSetting@PutInstance: ret 0x%x\n" , hr  ));  
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
            
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSEnvironmentSetting@PutInstance: ret 0x%x\n" , hr  ));  
                
                if (pErrorInstance != NULL)
                {
                    LoadString( g_hInstance , IDS_ERR_PUTTSECONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSENVIRONMENTSETTING_Prov);
                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                    if (pObj != NULL)
                    {
                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        
                        if (pMethodContext != NULL)
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        
                        pObj->Release();
                    }
                    pErrorInstance->Release();
                }
                
            }
        }
    }while (0);

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
	
    return hr;
}


//=--------------------


HRESULT CWin32_TSEnvironmentSetting::ExecMethod ( const CInstance& Inst,
                                                        const BSTR bstrMethodName,
                                                        CInstance *pInParams,
                                                        CInstance *pOutParams,
                                                        long lFlags)
                                                        
{	   
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    PUSERCONFIG pUser = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    Inst.GetCHString( m_szTerminalName, chTermName );
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
       
    
    // Sets the properties InitialProgramPath and StartIn which 
    // specify the name and path of the program and the working 
    // directory path for the program the user wants to start on 
    // logon to the Terminal Server.              
    
    // uint32 InitialProgram([In] string InitialProgramPath, [In] string Startin)
    
    do
    {
        if (_wcsicmp(bstrMethodName, m_szInitialProgram) == 0)
        {
            
            DWORD dwData = 0;
            DWORD dwStatus = 0;
            CHString chData;
            LONG lSize;
            
            hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
            
            if( SUCCEEDED (hr) && pUser != NULL )
            {
                
                dwData = pUser->fInheritInitialProgram;
                
                if( (dwData == 0) && pInParams != NULL )
                {   
                    chData.Empty();                       
                    
                    pInParams->GetCHString(m_szInitialProgramPath, chData);
                    
                    if( chData.GetLength() > 256 )
                    {                        
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                        
                        break;
                    }
                                      
                    wcscpy( pUser->InitialProgram, (LPTSTR)(LPCTSTR) chData );
                    
                    chData.Empty();
                                        
                    pInParams->GetCHString( m_szStartIn, chData );
                    
                    if( chData.GetLength() > 256 )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                        
                        break;
                    }
                    
                    wcscpy( pUser->WorkDirectory, (LPTSTR) (LPCTSTR) chData );
                    
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD( L"ReturnValue", WBEM_S_NO_ERROR );
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;                    
                }
            }
        }
    }while (0);

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }    

    return hr;
}


//=-----------------------

HRESULT CWin32_TSEnvironmentSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    // return (WBEM_E_PROVIDER_NOT_CAPABLE);
    
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
   
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szClientWallPaper))
        ulRequiredProperties |= BIT_CLIENTWALLPAPER;
    
    if (Query.IsPropertyRequired(m_szInitialProgramPath))
        ulRequiredProperties |= BIT_INITIALPROGRAMPATH;
    
    if (Query.IsPropertyRequired(m_szInitialProgramPolicy))
        ulRequiredProperties |= BIT_INITIALPROGRAMPOLICY;
    
    if (Query.IsPropertyRequired(m_szStartIn))
        ulRequiredProperties |= BIT_STARTIN;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList( &ulTerminals, &ulSize, &pWS );
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals ; ulNum++)
        {        
            // Method 2
            if (bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    TRC2((TB,"TSEnvironmentSetting@ExecQuery CreateNewInstance failed"  ));  
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString( m_szTerminalName, CHString( pWS[ulNum].Name ) );

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if (SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    
    return hr;
    
}



//=----------------------Win32_TSRemoteControlSettingsConfig---------------------


CWin32_TSRemoteControlSetting::CWin32_TSRemoteControlSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{

    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSRemoteControlSetting_ctor"));

        _tcscpy(m_szRemoteControlPolicy, _T("RemoteControlPolicy"));

        _tcscpy(m_szLevelOfControl, _T("LevelOfControl"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szRemoteControl, _T("RemoteControl"));        
    }

}

//=--------------------

CWin32_TSRemoteControlSetting::~CWin32_TSRemoteControlSetting ()
{
}



//=------------

BOOL CWin32_TSRemoteControlSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=--------------------

HRESULT CWin32_TSRemoteControlSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    CHString chTermName;
    LONG  lSize ;
    PWS pWS = NULL;
    ULONGLONG ulRequiredProperties = 0;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSRemoteControlSetting@Getobject invalid pointer"  ));  
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szRemoteControlPolicy))
        ulRequiredProperties |= BIT_REMOTECONTROLPOLICY;
    
    if (Query.IsPropertyRequired(m_szLevelOfControl))
        ulRequiredProperties |= BIT_LEVELOFCONTROL;
    
    if( pInstance != NULL )
    {
        hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);

        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );
        }               
    }

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    
    return hr;    
}

//=--------------------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSRemoteControlSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSRemoteControlSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    ULONG ulNum = 0;
    PWS  pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    { 

		
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
			
            CInstance* pInstance = CreateNewInstance(pMethodContext);            

            if( pInstance == NULL)
            {
                ERR((TB,"TSRemoteControlSetting@EnumerateInstances CreateNewInstance failed"  ));               
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSRemoteControlSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr  ));    
            
            hr = LoadPropertyValues( pInstance, BIT_ALL_PROPERTIES, &pWS[ulNum] );
            
            if ( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();
            }
			
            pInstance->Release( );

        } 
        
    }  

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSRemoteControlSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{	
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lSize ;
    DWORD dwData = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    
    if ( pInstance != NULL && pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        }
        
        TRC2((TB,"TSRemoteControlSetting@LoadPropertyValues: GetTerminalName"  ));
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSRemoteControlSetting@LoadPropertyValues: GetUserConfig ret 0x%x\n" , hr  ));
        
        if ( SUCCEEDED (hr) && pUser != NULL )
        {
            
            if( ulRequiredProperties & BIT_REMOTECONTROLPOLICY)
            {
                
                pInstance->SetDWORD(m_szRemoteControlPolicy, pUser->fInheritShadow);
				
            }
            TRC2((TB,"TSRemoteControlSetting@LoadPropertyValues: RemoteControlPolicy"  ));
            
            if( ulRequiredProperties & BIT_LEVELOFCONTROL)
            {
                
                pInstance->SetDWORD(m_szLevelOfControl, pUser->Shadow);

            }
            TRC2((TB,"TSRemoteControlSetting@LoadPropertyValues: LevelOfControl"));            
        }                  

    }   

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }
	
    return hr;
}

//=--------------------

HRESULT CWin32_TSRemoteControlSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
	
    HRESULT hr= WBEM_S_NO_ERROR;
    CHString chTermName ;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    LONG  lSize;
    PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        if( SUCCEEDED( hr ) && pUser != NULL )
        {
            if( Instance.GetDWORD( m_szRemoteControlPolicy, dwData ) )
            {
                pUser->fInheritShadow = dwData;
                
                if ( dwData != 0 && dwData != 1 )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }
                
                hr = StackObj.m_pCfgComp->SetUserConfig((LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                
                if( SUCCEEDED( hr ))
                {
                    hr = StackObj.m_pCfgComp->ForceUpdate();
                }
            }
            
        }
        
        else
        {
            TRC2((TB,"TSRemoteControlSetting@PutInstance: ret 0x%x\n" , hr ));
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if(( SUCCEEDED( hr ) ) && (pErrorInstance != NULL))
            {
                
                LoadString( g_hInstance , IDS_ERR_PUTTSRCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                
                LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                
                pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSREMOTECONTROLSETTING_Prov);
                pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                
                IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                if (pObj != NULL)
                {
                    
                    MethodContext *pMethodContext = Instance.GetMethodContext();  
                    
                    if (pMethodContext != NULL)
                    {
                        pMethodContext->SetStatusObject(pObj);
                    }
                    
                    pObj->Release();
                }
                pErrorInstance->Release();
                
            }
            TRC2((TB,"TSRemoteControlSetting@PutInstance: GetInstanceByPath ret 0x%x\n" , hr ));           
        }
    }while (0);

    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSRemoteControlSetting::ExecMethod ( const CInstance& Inst,
                                                          const BSTR bstrMethodName,
                                                          CInstance *pInParams,
                                                          CInstance *pOutParams,
                                                          long lFlags)
                                                          
{
	
    HRESULT hr= WBEM_E_NOT_FOUND;
    CHString chTermName;    

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
        
    
    // Sets the property LevelOfControl which specifies the level of control
    // which is one of Disable, EnableInputNotify, EnableInputNoNotify, 
    // EnableNoInputNotify, EnableNoInputNoNotify. 

    // uint32 RemoteControl([In] uint32 LevelOfControl);
    
    if( _wcsicmp( bstrMethodName, m_szRemoteControl ) == 0 )
    {
        
        DWORD dwRemoteData = 0;
        DWORD dwData = 0;
        DWORD dwStatus = 0;
        bool bRet;
        LONG lSize;
        PUSERCONFIG pUser = NULL;
        
        if ( pInParams != NULL )
        {
            
            hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE );
            
            do
            {
                if ( SUCCEEDED( hr ) && pUser != NULL )
                {
                    dwRemoteData = pUser->fInheritShadow;
                    
                    if ( SUCCEEDED( hr ) && ( dwRemoteData == 0 ))
                    {  
                        bRet = pInParams->GetDWORD(m_szLevelOfControl, dwData);
                        
                        if ( !bRet )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        pUser->Shadow = ( SHADOWCLASS )dwData;
                        
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                        
                        if( SUCCEEDED( hr ) && pOutParams )
                        {
                            hr = StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                            
                        }
                        TRC2((TB,"TSRemoteControlSetting@ExecMethod: LevelOfControl ret 0x%x\n" , hr ));
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                    }
                    
                }
            }while (0);
            
            if ( pUser != NULL )
            {
                CoTaskMemFree(pUser);
            }
        }      
    }

    return hr;
}

//=-------------------------------

HRESULT CWin32_TSRemoteControlSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szRemoteControlPolicy))
        ulRequiredProperties |= BIT_REMOTECONTROLPOLICY;
    
    if (Query.IsPropertyRequired(m_szLevelOfControl))
        ulRequiredProperties |= BIT_LEVELOFCONTROL;
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals ; ulNum++)
        {
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    TRC2((TB,"TSRemoteControlSetting@ExecQuery: CreateNewInstance failed" ));
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }

    return hr;
    
}




//=----------------------Win32_TSClientSetting---------------------


CWin32_TSClientSetting::CWin32_TSClientSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{  
    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSClientSetting_ctor"));

        _tcscpy(m_szConnectionPolicy, _T("ConnectionPolicy"));

        _tcscpy(m_szConnectClientDrivesAtLogon, _T("ConnectClientDrivesAtLogon"));

        _tcscpy(m_szConnectPrinterAtLogon, _T("ConnectPrinterAtLogon"));

        _tcscpy(m_szDefaultToClientPrinter, _T("DefaultToClientPrinter"));

        _tcscpy(m_szWindowsPrinterMapping, _T("WindowsPrinterMapping"));

        _tcscpy(m_szLPTPortMapping, _T("LPTPortMapping"));

        _tcscpy(m_szCOMPortMapping, _T("COMPortMapping"));

        _tcscpy(m_szDriveMapping, _T("DriveMapping"));

        _tcscpy(m_szAudioMapping, _T("AudioMapping"));

        _tcscpy(m_szClipboardMapping, _T("ClipboardMapping"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szPropertyName, _T("PropertyName"));

        _tcscpy(m_szValue, _T("Value"));

        _tcscpy(m_szConnectionSettings, _T("ConnectionSettings"));

        _tcscpy(m_szSetClientProperty, _T("SetClientProperty"));

        _tcscpy(m_szColorDepth, _T("ColorDepth"));

        _tcscpy(m_szSetColorDepth, _T("SetColorDepth"));

        _tcscpy(m_szColorDepthPolicy, _T("ColorDepthPolicy"));

        _tcscpy(m_szSetColorDepthPolicy, _T("SetColorDepthPolicy"));
        
               
    }
    RegGetMachinePolicy(&m_gpPolicy);
}
//=--------------------

CWin32_TSClientSetting::~CWin32_TSClientSetting ()
{
    
}


//=-----------------

BOOL CWin32_TSClientSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


//=--------------------

HRESULT CWin32_TSClientSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    CHString chTermName; 
    LONG  lSize ;
    ULONGLONG ulRequiredProperties = 0;
    PWS pWS = NULL;
//    PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSClientSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szAudioMapping))
        ulRequiredProperties |= BIT_AUDIOMAPPING;
    
    if (Query.IsPropertyRequired(m_szClipboardMapping))
        ulRequiredProperties |= BIT_CLIPBOARDMAPPING;
    
    if (Query.IsPropertyRequired(m_szCOMPortMapping))
        ulRequiredProperties |= BIT_COMPORTMAPPING;
    
    if (Query.IsPropertyRequired(m_szConnectClientDrivesAtLogon))
        ulRequiredProperties |= BIT_CONNECTCLIENTDRIVESATLOGON;
    
    if (Query.IsPropertyRequired(m_szConnectionPolicy))
        ulRequiredProperties |= BIT_CONNECTIONPOLICY;
    
    if (Query.IsPropertyRequired(m_szConnectPrinterAtLogon))
        ulRequiredProperties |= BIT_CONNECTPRINTERATLOGON;
    
    if (Query.IsPropertyRequired(m_szDefaultToClientPrinter))
        ulRequiredProperties |= BIT_DEFAULTTOCLIENTPRINTER;
    
    if (Query.IsPropertyRequired(m_szDriveMapping))
        ulRequiredProperties |= BIT_DRIVEMAPPING;
    
    if (Query.IsPropertyRequired(m_szLPTPortMapping))
        ulRequiredProperties |= BIT_LPTPORTMAPPING;
    
    if (Query.IsPropertyRequired(m_szWindowsPrinterMapping))
        ulRequiredProperties |= BIT_WINDOWSPRINTERMAPPING;

    if (Query.IsPropertyRequired(m_szColorDepth))
        ulRequiredProperties |= BIT_COLORDEPTH;

    if (Query.IsPropertyRequired(m_szColorDepthPolicy))
        ulRequiredProperties |= BIT_COLORDEPTHPOLICY;


    if ( pInstance != NULL )
    {
        hr = StackObj.m_pCfgComp->GetWSInfo( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS );

        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues( pInstance, ulRequiredProperties, pWS );
        }                
    }

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }	
    return hr;
    
}
//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSClientSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSClientSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    ULONG ulNum = 0;
    PWS  pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
        
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSClientSetting@EnumerateInstances: CreateNewInstance failed" ));                
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSClientSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr ));

            hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ ulNum ] );
            
            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();

            }
            pInstance->Release( );
        }
        
    }  

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
  
    return hr;
}
//=--------------------

HRESULT CWin32_TSClientSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lSize ;
    DWORD dwData = 0;
    BOOL bData = 0;
    DWORD dwStatus = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSClientSetting@LoadPropertyValues: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    if( pInstance != NULL && pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
	        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        }

        TRC2((TB,"TSClientSetting@LoadPropertyValues: GetTerminalName"));
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSClientSetting@LoadPropertyValues ret 0x%x\n" , hr));
        
        if( SUCCEEDED (hr) && pUser != NULL )
        {            
            if( ulRequiredProperties & BIT_CONNECTIONPOLICY)
            {                
                pInstance->SetDWORD(m_szConnectionPolicy, pUser->fInheritAutoClient);     
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: ConnectionPolicy" ));
            }
                     
            
            if( ulRequiredProperties & BIT_CONNECTCLIENTDRIVESATLOGON)
            {  
                pInstance->SetDWORD(m_szConnectClientDrivesAtLogon, pUser->fAutoClientDrives);      
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues ConnectClientDrives"));
            }            
                           
            
            if( ulRequiredProperties & BIT_CONNECTPRINTERATLOGON)
            {  
                pInstance->SetDWORD(m_szConnectPrinterAtLogon, pUser->fAutoClientLpts);
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: ConnectPrinter"));
            }
            
            
            if( ulRequiredProperties & BIT_DEFAULTTOCLIENTPRINTER)
            {                
                pInstance->SetDWORD(m_szDefaultToClientPrinter, pUser->fForceClientLptDef); 
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: DefaultToClientPrinter"));
            }
                        
            
            if( ulRequiredProperties & BIT_LPTPORTMAPPING)
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableLPT != 0 )
                {
                    pInstance->SetDWORD(m_szLPTPortMapping, m_gpPolicy.fDisableLPT);
                }
                else
                {
                    pInstance->SetDWORD(m_szLPTPortMapping, pUser->fDisableLPT);
                }                
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: WindowsPrinterMapping"));
            }
                        
            
            if( ulRequiredProperties & BIT_WINDOWSPRINTERMAPPING)
            {
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableCpm != 0 )
                {
                    pInstance->SetDWORD(m_szWindowsPrinterMapping, m_gpPolicy.fDisableCpm);
                }
                else
                {
                    pInstance->SetDWORD(m_szWindowsPrinterMapping, pUser->fDisableCpm);
                }    
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: LPTPortMapping"));            
            }
            
            
            if( ulRequiredProperties & BIT_COMPORTMAPPING)
            {  
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableCcm != 0 )
                {
                    pInstance->SetDWORD(m_szCOMPortMapping, m_gpPolicy.fDisableCcm);
                }
                else
                {
                    pInstance->SetDWORD(m_szCOMPortMapping, pUser->fDisableCcm);
                }
                 
                TRC2((TB,"TSClientSetting@LoadPropertyValues: COMPortMapping"));
            }
            
            
            if( ulRequiredProperties & BIT_DRIVEMAPPING)
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableCdm != 0 )
                {
                    pInstance->SetDWORD(m_szDriveMapping, m_gpPolicy.fDisableCdm);                                                   
                }
                else
                {
                    pInstance->SetDWORD(m_szDriveMapping, pUser->fDisableCdm);
                } 

                TRC2((TB,"TSClientSetting@LoadPropertyValues: DriveMapping"));
            }
            
            
            if( ulRequiredProperties & BIT_AUDIOMAPPING)
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableCam != 0 )
                {
                    pInstance->SetDWORD(m_szAudioMapping, m_gpPolicy.fDisableCam);
                }
                else
                {
                    pInstance->SetDWORD(m_szAudioMapping, pUser->fDisableCam);
                }
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: AudioMapping"));
            }
            
            
            if( ulRequiredProperties & BIT_CLIPBOARDMAPPING)
            {
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableClip != 0 )
                {
                    pInstance->SetDWORD(m_szClipboardMapping, m_gpPolicy.fDisableClip);
                }
                else
                {
                    pInstance->SetDWORD(m_szClipboardMapping, pUser->fDisableClip);
                }
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues ClipboardMapping"));
            }
            
            if( ulRequiredProperties & BIT_COLORDEPTHPOLICY)
            {  
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyColorDepth != 0 )
                {
                    dwData = m_gpPolicy.fPolicyColorDepth;
                }
                else
                {  
                    hr = StackObj.m_pCfgComp->GetColorDepth( pWS->Name, &bData, &dwStatus);
                   
                    dwData = bData;
                }   
                pInstance->SetDWORD(m_szColorDepthPolicy, dwData);    
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: ColorDepthPolicy" ));
            }

            if( ulRequiredProperties & BIT_COLORDEPTH)
            {  
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyColorDepth != 0 )
                {
                    pInstance->SetDWORD(m_szColorDepth, m_gpPolicy.ColorDepth);
                }
                else
                {  
                    pInstance->SetDWORD(m_szColorDepth, pUser->ColorDepth);
                   
                }       
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: ColorDepth" ));
            }
            
        }        
    }
    
    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
	
    return hr;
    
}

//=--------------------
HRESULT CWin32_TSClientSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
	
    HRESULT hr= WBEM_S_NO_ERROR;
    CHString chTermName ;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    LONG lSize;
    PUSERCONFIGW pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        if( SUCCEEDED (hr) && pUser != NULL )
        {
            Instance.GetDWORD(m_szConnectionPolicy, dwData);
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritAutoClient = dwData;                        
            
            hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );    
            
            if( SUCCEEDED( hr ) )
            {
                hr = StackObj.m_pCfgComp->ForceUpdate();
            }
        }
        
        else
        {
            TRC2((TB,"TSClientSetting@PutInstance: ret 0x%x\n" , hr));           
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);

            CInstance *pErrorInstance = NULL;            
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSClientSetting@PutInstance: ret 0x%x\n" , hr));

                if (pErrorInstance != NULL)
                {                    
                    LoadString( g_hInstance , IDS_ERR_PUTTSCCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );

                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );

                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);

                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSCLIENTSETTING_Prov);

                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();

                    if (pObj != NULL)
                    {                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        if (pMethodContext != NULL)
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        pObj->Release();
                    }
                    
                    pErrorInstance->Release();
                }
                
            }           
        }

    }while (0);
    
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }
    
    return hr;
}

//=--------------------
HRESULT CWin32_TSClientSetting::ExecMethod ( const CInstance& Inst,
                                                   const BSTR bstrMethodName,
                                                   CInstance *pInParams,
                                                   CInstance *pOutParams,
                                                   long lFlags)
                                                   
{   
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    PUSERCONFIG pUser = NULL;
    DWORD dwAutoData = 0;
    DWORD dwData = 0;
    DWORD dwStatus = 0;    
    LONG lSize;
    bool fValue;
    CHString chData;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    do
    {        
        
        if( pInParams != NULL )
        {
            // Sets the properties ClientConnectDrivesAtLogon, ConnectPrinterAtLogon 
            // and DefaultPrinterToClient. 
                      
            // uint32 ConnectSettings([In] uint32 ConnectClientDrivesAtLogon, [In] uint32 ConnectPrinterAtLogon, [In] uint32 DefaultToClientPrinter)
        
            if( _wcsicmp( bstrMethodName, m_szConnectionSettings ) == 0 )
            { 
                bool bRet;
            
                hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
                
                if( SUCCEEDED (hr) && pUser != NULL )
                {
                    dwAutoData = pUser->fInheritAutoClient;
                    
                    if( dwAutoData == 0 )
                    {                           
                        bRet = pInParams->GetDWORD(m_szConnectClientDrivesAtLogon, dwData);
                        
                        if ( !bRet || ( dwData != 0 && dwData != 1 ) )
                        {                            
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        pUser->fAutoClientDrives = dwData;
                        
                        bRet = pInParams->GetDWORD(m_szConnectPrinterAtLogon, dwData);
                        
                        if( !bRet || ( dwData != 0 && dwData != 1 ) )
                        {                            
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        pUser->fAutoClientLpts = dwData;
                        
                        bRet = pInParams->GetDWORD(m_szDefaultToClientPrinter, dwData);
                        
                        if( !bRet || ( dwData != 0 && dwData != 1 ) )
                        {                            
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        pUser->fForceClientLptDef = dwData;
                        
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                        
                        TRC2((TB,"TSClientSetting@ExecMethod: ConnectSettings: ret 0x%x\n" , hr ));
                        
                        if( pOutParams != NULL )
                        {
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);                            
                        } 
                    }
                    else
                    {                        
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;                        
                    }                    
                }                                      
            }

            else if( _wcsicmp( bstrMethodName, m_szSetColorDepthPolicy ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0; 
                bool bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyColorDepth == 0 )
                {  
                    TRC2((TB, "ColorDepth is not enabled by Group Policy."));                        
                      
                    bRet = pInParams->GetDWORD(m_szColorDepthPolicy, dwData);
                    

                    if ( !bRet || (dwData != 0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                                        
                    
                    hr = StackObj.m_pCfgComp->SetColorDepth( (LPTSTR)(LPCTSTR) chTermName, dwData , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSClientSetting@ExecMethod:  ColorDepthPolicy ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            } 
            
            else if( _wcsicmp( bstrMethodName, m_szSetColorDepth ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0;
                bool bRet;
                BOOL bData = 0;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyColorDepth == 0 )
                {  
                    TRC2((TB, "Condition to update fInheritColorDepth satisfied"));                        
                      
                    hr = StackObj.m_pCfgComp->GetColorDepth( (LPTSTR)(LPCTSTR) chTermName, &bData, &dwStatus);                  
                    

                    if( FAILED( hr ) || bData == 1)
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                    }                                        

                    bRet = pInParams->GetDWORD(m_szColorDepth, dwData);
                    
                    if ( !bRet || dwData > 3 )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    } 
                  

                    TCHAR tchRegPath[ MAX_PATH ] = WINSTATION_REG_NAME;

                    HKEY hKey = NULL;

                    lstrcat( tchRegPath, L"\\");

                    lstrcat( tchRegPath , chTermName );                
                    
                    hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                             tchRegPath ,
                             0,
                             KEY_READ | KEY_WRITE,
                             &hKey );

                    if( SUCCEEDED( hr)  && hKey != NULL)
                    {

                        hr = RegSetValueEx( hKey ,
                                        TEXT("ColorDepth"),
                                        0 ,
                                        REG_DWORD,
                                        ( LPBYTE )&dwData ,
                                        sizeof(DWORD) );   
                        
                        RegCloseKey( hKey );
                    }
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSClientSetting@ExecMethod:  ColorDepth ret 0x%x\n" , hr  ));
                    } 
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                    }
                    
                }
                else
                {                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;                    
                }
                
            }
        
            //  PropertyName is a string enumeration of the properties: 
            //  LPTPortMapping, COMPortMapping, AudioMapping ClipboardMapping and WindowsPrinterMapping.
            //  They are False or True according as if the Value is set to 0 or 1 respectively.
                

            //  uint32 SetClientProperty([In] string PropertyName, [In] boolean Value)
        
            else if( _wcsicmp( bstrMethodName, m_szSetClientProperty) == 0 )
            {
                hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
            
                RegGetMachinePolicy(&m_gpPolicy);
            
                if( SUCCEEDED( hr ) && pUser != NULL && pOutParams != NULL)
                {
                    pInParams->GetCHString(m_szPropertyName, chData);                
                
                    if( chData.CompareNoCase(m_szLPTPortMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableLPT ret 0x%x\n", m_gpPolicy.fPolicyDisableLPT ));
                    
                        if( m_gpPolicy.fPolicyDisableLPT == 0 )
                        {   
                            TRC2((TB,"Condition to update fPolicyDisableLPT satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableLPT = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    
                    }
                    else if( chData.CompareNoCase(m_szCOMPortMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableCcm ret 0x%x\n", m_gpPolicy.fPolicyDisableCcm ));
                    
                        if( (m_gpPolicy.fPolicyDisableCcm) == 0)
                        {
                            TRC2((TB,"Condition to update fPolicyDisableCcm satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableCcm = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    
                    }
                
                    else if( chData.CompareNoCase(m_szAudioMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);

                        TRC2((TB,"m_gpPolicy.fPolicyDisableCam ret 0x%x\n", m_gpPolicy.fPolicyDisableCam ));                    
                    
                        if( (m_gpPolicy.fPolicyDisableCam) == 0)
                        {                        
                            if(fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableCam = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    }
                
                    else if( chData.CompareNoCase(m_szClipboardMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableClip ret 0x%x\n", m_gpPolicy.fPolicyDisableClip ));                    
                    
                        if( (m_gpPolicy.fPolicyDisableClip) == 0 )
                        {
                            TRC2((TB,"Condition to update fPolicyDisableClip satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableClip = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    }
                    else if( chData.CompareNoCase(m_szWindowsPrinterMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableCpm ret 0x%x\n", m_gpPolicy.fPolicyDisableCpm ));
                    
                        if( (m_gpPolicy.fPolicyDisableCpm) == 0)
                        {
                            TRC2((TB,"Condition to update fPolicyDisableCpm satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableCpm = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    }
                    else if( chData.CompareNoCase(m_szDriveMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableCdm ret 0x%x\n", m_gpPolicy.fPolicyDisableCdm ));
                    
                        if( (m_gpPolicy.fPolicyDisableCdm) == 0)
                        {
                            TRC2((TB,"Condition to update fPolicyDisableCdm satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableCdm = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD;
                        break;
                    }
                
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );

                    if( SUCCEEDED( hr ))
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();
                    }                
                }
            }
        }
        
    }while (0);
    
    if( pUser != NULL )
    {
        CoTaskMemFree( pUser );        
    }

    return hr;   
}

//=-----------------
HRESULT CWin32_TSClientSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szAudioMapping))
        ulRequiredProperties |= BIT_AUDIOMAPPING;
    
    if (Query.IsPropertyRequired(m_szClipboardMapping))
        ulRequiredProperties |= BIT_CLIPBOARDMAPPING;
    
    if (Query.IsPropertyRequired(m_szCOMPortMapping))
        ulRequiredProperties |= BIT_COMPORTMAPPING;
    
    if (Query.IsPropertyRequired(m_szConnectClientDrivesAtLogon))
        ulRequiredProperties |= BIT_CONNECTCLIENTDRIVESATLOGON;
    
    if (Query.IsPropertyRequired(m_szConnectionPolicy))
        ulRequiredProperties |= BIT_CONNECTIONPOLICY;
    
    if (Query.IsPropertyRequired(m_szConnectPrinterAtLogon))
        ulRequiredProperties |= BIT_CONNECTPRINTERATLOGON;
    
    if (Query.IsPropertyRequired(m_szDefaultToClientPrinter))
        ulRequiredProperties |= BIT_DEFAULTTOCLIENTPRINTER;
    
    if (Query.IsPropertyRequired(m_szDriveMapping))
        ulRequiredProperties |= BIT_DRIVEMAPPING;
    
    if (Query.IsPropertyRequired(m_szLPTPortMapping))
        ulRequiredProperties |= BIT_LPTPORTMAPPING;
    
    if (Query.IsPropertyRequired(m_szWindowsPrinterMapping))
        ulRequiredProperties |= BIT_WINDOWSPRINTERMAPPING;

    if (Query.IsPropertyRequired(m_szColorDepth))
        ulRequiredProperties |= BIT_COLORDEPTH;

    if (Query.IsPropertyRequired(m_szColorDepthPolicy))
        ulRequiredProperties |= BIT_COLORDEPTHPOLICY;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals ; ulNum++)
        {   
            // Method 2 
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    ERR((TB,"TSClientSetting@ExecQuery: CreateNewInstance failed" ));
                    
                    hr = WBEM_E_OUT_OF_MEMORY;

                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }    
    	
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);        
    }

    return hr;    
}




//=----------------------Win32_TSNetworkAdapterSetting---------------------


CWin32_TSNetworkAdapterSetting::CWin32_TSNetworkAdapterSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{    
    if( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSNetworkAdapterSetting_ctor"));
        
        _tcscpy(m_szNetworkAdapterID, _T("NetworkAdapterID"));

        _tcscpy(m_szNetworkAdapterName, _T("NetworkAdapterName"));

        _tcscpy(m_szMaximumConnections, _T("MaximumConnections"));

        _tcscpy(m_szSelectNetworkAdapterID, _T("SelectNetworkAdapterID"));

        _tcscpy(m_szSelectAllNetworkAdapters, _T("SelectAllNetworkAdapters"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));


    }
    
    RegGetMachinePolicy(&m_gpPolicy);
}
//=--------------------
CWin32_TSNetworkAdapterSetting::~CWin32_TSNetworkAdapterSetting ()
{
    
}

//=---------------
BOOL CWin32_TSNetworkAdapterSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


//=--------------------
HRESULT CWin32_TSNetworkAdapterSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{ 	
    int i = 0;
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    ULONG ulSize = 0;
    ULONG ulNAdapters =0;
    ULONGLONG ulRequiredProperties = 0;
    LONG  lSize ;
    PWS pWS = NULL;
    TCHAR tch = ';';		    
    TCHAR tchGuid[ GUID_LENGTH ];
    CHString chTermName;
    CHString chGuid;
    CHString chAllGuids;
    CHString chName;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    if( pInstance == NULL )
    {
        ERR((TB,"TSNetworkAdapterSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szNetworkAdapterID))
        ulRequiredProperties |= BIT_NETWORKADAPTERID;
    
    if (Query.IsPropertyRequired(m_szMaximumConnections))
        ulRequiredProperties |= BIT_MAXIMUMCONNECTIONS;
    
    if ( pInstance != NULL )
    {
        hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
        
        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );            
        }

        /*
        hr = pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
        
        if ( SUCCEEDED (hr) )
        {
            hr = pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
            
            if ( SUCCEEDED (hr) && pWS!= NULL && pUser != NULL )
            {            
                
                pInstance->SetDWORD(m_szMaximumConnections, pWS->uMaxInstanceCount);
                
                hr = pCfgComp->GetLanAdapterList2(pWS->pdName, &ulNAdapters , &pGuidtbl );
                
                chAllGuids.Empty();
                chGuid.Empty();
                
                StringFromGUID2 (( pGuidtbl )[ pWS->LanAdapter ].guidNIC, tchGuid, GUID_LENGTH);      
                chGuid.Format (L"%ws", tchGuid);
                
                
                hr = pInstance->SetCHString(m_szNetworkAdapterID, chGuid);     
                
                chAllGuids.Empty();
                chGuid.Empty();
                
                chName = ( pGuidtbl )[ pWS->LanAdapter ].DispName;   
                
                hr = pInstance->SetCHString(m_szNetworkAdapterName, chName); 
                
            }
            else
            {
                hr = WBEM_E_INVALID_OBJECT;
            }
        }
        */
        
    }
    
    /*
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }
    */

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);        
    }

    return hr;
    
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSNetworkAdapterSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSNetworkAdapterSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    
    HRESULT hr = WBEM_S_NO_ERROR;    
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    ULONG ulNum = 0;
    PWS  pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
        
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSNetworkAdapterSetting@EnumerateInstances: CreateNewInstance failed" ));               
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSNetworkAdapterSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr ));

            if( _tcsicmp( pWS[ulNum].pdName, L"Console") != 0 )
            {

                hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ulNum] );
            
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                pInstance->Release( );
            }
        }
        
    }

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    
    return hr;
}
//=--------------------

HRESULT CWin32_TSNetworkAdapterSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
    
    HRESULT hr = WBEM_S_NO_ERROR; 
    PUSERCONFIGW pUser = NULL;
    LONG lSize ;
    ULONG ulNAdapters =0;
    DWORD dwData = 0;    
    DWORD dwStatus = 0;
    int i = 0;
    TCHAR tch = ';';		    
    TCHAR tchGuid[ GUID_LENGTH ];
    PGUIDTBL pGuidtbl = NULL;
    CHString chGuid;
    CHString chAllGuids;
    CHString chName;    
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSNetworkAdapterSetting@LoadPropertyValues: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    
    if( pInstance != NULL && pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);        
        }
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSNetworkAdapterSetting@LoadPropertyValues: GetUserConfig ret 0x%x\n" , hr));
        
        if( SUCCEEDED( hr ) && pUser != NULL )
        {            
            if( ulRequiredProperties & BIT_NETWORKADAPTERID)
            {
                
                pInstance->SetDWORD(m_szNetworkAdapterID, pWS->LanAdapter);
                
            }
            TRC2((TB,"TSNetworkAdapterSetting@LoadPropertyValues: NetworkAdapterID"));      
            
            if( ulRequiredProperties & BIT_MAXIMUMCONNECTIONS)
            {
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyMaxInstanceCount != 0 )
                {
                    pInstance->SetDWORD(m_szMaximumConnections, m_gpPolicy.MaxInstanceCount);                   
                }
                else
                {                
                    pInstance->SetDWORD(m_szMaximumConnections, pWS->uMaxInstanceCount);
                  
                }
            }
            TRC2((TB,"TSNetworkAdapterSetting@LoadPropertyValues: MaxConnections")); 
                        
            
            hr = StackObj.m_pCfgComp->GetLanAdapterList2(pWS->pdName, &ulNAdapters , &pGuidtbl ); 
            
            chAllGuids.Empty();
            chGuid.Empty();
            
            if( pWS->LanAdapter != ((ULONG)-1))
            {
                StringFromGUID2 (( pGuidtbl )[ pWS->LanAdapter ].guidNIC, tchGuid, ARRAYSIZE(tchGuid));            

                chGuid.Format (L"%s", tchGuid);
         
                pInstance->SetCharSplat(m_szNetworkAdapterID, tchGuid);     
            
                chName = ( pGuidtbl )[ pWS->LanAdapter ].DispName;                  
            
                pInstance->SetCHString(m_szNetworkAdapterName, chName);
            }            
            else
            {
                pInstance->SetCHString(m_szNetworkAdapterName, L"");
            }                        
        }          
    }
    
    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }

    if( pGuidtbl != NULL )
    {
        CoTaskMemFree(pGuidtbl);
    }
    
    return S_OK;
    
}
//=--------------------

HRESULT CWin32_TSNetworkAdapterSetting::PutInstance ( const CInstance &Instance, long lFlags)
{	
    HRESULT hr= WBEM_S_NO_ERROR;
    CHString chTermName ;
    DWORD dwData = 0;
    LONG lSize;
    DWORD dwStatus = 0;
    PWS  pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}    
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
    
    RegGetMachinePolicy( &m_gpPolicy );
    
    do
    {
        if( SUCCEEDED (hr) && pWS != NULL )
        {
            Instance.GetDWORD(m_szMaximumConnections, dwData);

            TRC2((TB,"m_gpPolicy.fPolicyMaxInstanceCount ret 0x%x\n", m_gpPolicy.fPolicyMaxInstanceCount));
            
            if( m_gpPolicy.fPolicyMaxInstanceCount == 0 )
            { 
                TRC2((TB,"m_gpPolicy.fPolicyMaxInstanceCount satisfied"));
                

                pWS->uMaxInstanceCount = dwData;
                
                hr = StackObj.m_pCfgComp->UpDateWS( pWS, BIT_ALL_PROPS , &dwStatus, TRUE ); 
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;

                break;
            }          
        }
        
        else
        {
            TRC2((TB,"TSNetworkAdapterSetting@PutInstance ret 0x%x\n" , hr));  
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
                        
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSNetworkAdapterSetting@PutInstance ret 0x%x\n" , hr));

                if( pErrorInstance != NULL )
                {
                    LoadString( g_hInstance , IDS_ERR_PUTTSNCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERSETTING_Prov);
                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                    if( pObj != NULL )
                    {
                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        
                        if( pMethodContext != NULL )
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        pObj->Release();
                    }
                    pErrorInstance->Release();
                }
                
            }
        }
    }while (0);

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }

    return hr;
} 

//=--------------------

HRESULT CWin32_TSNetworkAdapterSetting::ExecMethod ( const CInstance& Inst,
                                                           const BSTR bstrMethodName,
                                                           CInstance *pInParams,
                                                           CInstance *pOutParams,
                                                           long lFlags)
                                                           
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    PWS pWS= NULL;
    PWS pWSList= NULL;
    CRegistry oRegObject;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
   
    
    // Selects all the LanAdapters on the machine.
                              
    // uint32 SelectAllNetworkAdapters();
    
    do
    {
        if( _wcsicmp(bstrMethodName, m_szSelectAllNetworkAdapters) == 0 )
        {
            
            ULONG ulTerminals = 0;
            ULONG ulNum = 0;
            LONG lNum = 0;
            ULONG ulSize = 0;
            DWORD dwStatus = 0;
            DWORD dwData = 0;
            LONG lSize;
            ULONG ulNumAdapters;
            CHStringArray a_chNetworkAdapterIDs;
            TCHAR tchGuid[ GUID_LENGTH ];
            
            hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
            
            if( SUCCEEDED (hr) )
            {
                
                hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWSList);
                
                if( SUCCEEDED( hr ) && pWSList != NULL )
                {   
                    for( ulNum = 0; ulNum < ulTerminals ; ulNum++ )
                    {  
                        if( pWSList[ulNum].LanAdapter == 0 )
                        {
                            hr = WBEM_E_ALREADY_EXISTS;
                            
                            goto Cleanup;
                        }
                    }  
                    
                    hr = StackObj.m_pCfgComp->GetWSInfo( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS );
                    
                    pWS->LanAdapter = 0;
                    
                    hr = StackObj.m_pCfgComp->UpDateWS( pWS, BIT_ALL_PROPS , &dwStatus, TRUE );
                }
                if( pOutParams != NULL && SUCCEEDED( hr ))
                {
                    TRC2((TB,"TSNetworkAdapterSetting@ExecMethod: GetNetworkAdapterIDs ret 0x%x\n" , hr));                    
                    
                    pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                }
            }                
            
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }
        }
        
        
        // Specify the NetworkAdapterID to set.

        // uint32 SelectNetworkAdapterID([In] string NetworkAdapterID);
        
        else if( _wcsicmp(bstrMethodName, m_szSelectNetworkAdapterID) == 0 )
        {
            
            DWORD dwStatus = 0;
            DWORD dwData = 0;
            LONG lSize;
            PGUIDTBL pGuidtbl = NULL;
            BOOL bUniq;
            ULONG ulAdapters = 0;
            TCHAR tchRootKey[ MAX_PATH ] = {0};
            TCHAR tchGuid[ GUID_LENGTH ];
            TCHAR tchSelectGuid[ GUID_LENGTH ];
            HKEY hKey;    
            CHString chGuid;
            
            CHString chGUIDName;

            if(pInParams == NULL)
            {
                hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                break;
            }
            
            pInParams->GetCHString(m_szNetworkAdapterID, chGUIDName);
            
            if( chGUIDName.IsEmpty() != 0 )
            {
                hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                
                break;
            }

            if( chGUIDName.GetLength() > GUID_LENGTH )
            {
                hr = WBEM_E_VALUE_OUT_OF_RANGE;
                
                break;
            }
            
            hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
            
            if( SUCCEEDED( hr ) && pWS != NULL)
            {
                hr = StackObj.m_pCfgComp->GetLanAdapterList2(pWS->pdName, &ulAdapters , &pGuidtbl );
                
                if( SUCCEEDED( hr ) && pGuidtbl != NULL)
                {
                    
                    for( int i = 0 ; i < ulAdapters ; i++)
                    {
                        StringFromGUID2( ( pGuidtbl )[ i ].guidNIC , tchGuid , ARRAYSIZE( tchGuid ) );
                        
                        if( lstrcmpi( tchGuid, (LPCTSTR) chGUIDName) != 0 )
                        {
                            continue;  
                        }
                        
                        hr = StackObj.m_pCfgComp->IsNetWorkConnectionUnique(pWS->wdName, pWS->pdName, i, &bUniq);
                        
                        if( SUCCEEDED( hr ) && bUniq == TRUE )
                        {
                            pWS->LanAdapter = i;
                            
                            hr = StackObj.m_pCfgComp->UpDateWS( pWS, BIT_ALL_PROPS , &dwStatus, TRUE );
                            
                            if( SUCCEEDED( hr ))
                            {                                
                                if( SUCCEEDED( hr ) && pOutParams != NULL)
                                {
                                    pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);

                                    TRC2((TB,"TSNetworkAdapterSetting@ExecMethod: SelectNetworkAdapterID ret 0x%x\n" , hr));
                                } 
                                
                            }
                        }
                        else
                        {                           
                            hr = WBEM_E_INVALID_METHOD_PARAMETERS;                                                       
                        }                        
                    }                    
                }
            }
            
            if ( pGuidtbl != NULL )
            {
                CoTaskMemFree(pGuidtbl);
                
            }
            TRC2((TB,"TSNetworkAdapterSetting@ExecMethod: SelectNetworkAdapterID ret 0x%x\n" , hr));
        }
        
        
        else
        {
            hr = WBEM_E_INVALID_METHOD;

            break;
        }
        
    }while (0);
    
Cleanup:
    
    if( pWS != NULL )
    {
        CoTaskMemFree( pWS );        
    }

    if( pWSList != NULL )
    {
        CoTaskMemFree( pWSList );
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSNetworkAdapterSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szNetworkAdapterID))
        ulRequiredProperties |= BIT_NETWORKADAPTERID;
    
    if (Query.IsPropertyRequired(m_szMaximumConnections))
        ulRequiredProperties |= BIT_MAXIMUMCONNECTIONS;
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++ )
        {    
            // Method 2
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name) )
            {
                CInstancePtr pInstance (NULL);

                pInstance.Attach( CreateNewInstance( pMethodContext ) );
                
                if( pInstance == NULL)
                {
                    ERR((TB,"TSNetworkAdapterSetting@ExecQuery: CreateNewInstance failed"));                    
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }                
            }
        }
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
    
}



//=----------------------Win32_TSPermissionsSettingsConfig---------------------


CWin32_TSPermissionsSetting::CWin32_TSPermissionsSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{  
    if( g_hInstance != NULL )
    {

        TRC2((TB, "CWin32_TSPermissionsSetting_ctor"));

        _tcscpy(m_szPermissionPreSet, _T("PermissionPreSet"));

        _tcscpy(m_szPermissionMask, _T("PermissionMask"));

        _tcscpy(m_szAccountName, _T("AccountName"));

        _tcscpy(m_szAddAccount, _T("AddAccount"));

        _tcscpy(m_szRestoreDefaults, _T("RestoreDefaults"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

    }
}
//=--------------------
CWin32_TSPermissionsSetting::~CWin32_TSPermissionsSetting ()
{
    
}


//=---------------

BOOL CWin32_TSPermissionsSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for( DWORD x=0; x < dwSize; x++ )
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }
    
    return FALSE;
}
//=---------------------

HRESULT CWin32_TSPermissionsSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;   
    LONG lSize;
    ULONGLONG ulRequiredProperties = 0;
    PWS  pWS = NULL;
    CHString chTermName;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    TRC2((TB,"TSCFGWMI!CWin32_TSPermissionsSetting_GetObject"));
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSPermissionsSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;

    hr = StackObj.m_pCfgComp->GetWSInfo( ( LPTSTR )( LPCTSTR )chTermName, &lSize, &pWS);
    
    if( SUCCEEDED (hr) && pWS != NULL )        
    {
        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS);        
    }
    else
    {
        hr = WBEM_E_INVALID_OBJECT;
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }	

    return hr ;


	/*

    HRESULT hr = WBEM_E_NOT_FOUND;
    
    // get the object for the Win32_Terminal
    CHString chsTerminal;
    CInstancePtr pTerminal(NULL);
    
    if( pInstance != NULL )
    {
        pInstance->GetCHString(L"Element", chsTerminal);

        MethodContext* pMethodContext = pInstance->GetMethodContext();    
        
        hr = CWbemProviderGlue::GetInstanceByPath(chsTerminal, &pTerminal, pMethodContext);
        TRC2((TB,"TSPermissionsSetting@GetObject: GetInstanceByPath ret 0x%x\n" , hr ));       
        
        do
        {
            if( SUCCEEDED( hr ) && pTerminal != NULL)
            {
                // Got the account.  Now, match it to the GUID.
                // first, generate a relpath with which to compare.
                CHString chTSAccountSettingInstance;
                CHString chTermName;
                DWORD dwIndex = 0;
                pTerminal->GetCHString(m_szTerminalName, chTermName); 
               
                // create a relpath for the sid
                CHString chsTSAccountSettingPath;
                chsTSAccountSettingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", L"Win32_TSAccount", m_szTerminalName, (LPCTSTR)chTermName);
        
                // get the SID path from the instance
              //  pInstance->SetCHString(L"Setting", chsTSAccountSettingPath);
                pInstance->SetCHString(L"Setting", chTSAccountSettingInstance);

                pInstance->SetCHString(m_szTerminalName, chTermName);         
            }
        }while (0);
    }
    return(hr);
	*/
       
}
//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSPermissionsSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSPermissionsSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
	HRESULT hr = WBEM_S_NO_ERROR;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
   
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    TRC2((TB,"TSPermissionsSetting@EnumerateInstances: GetWinstationList ret 0x%x" , hr )); 
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSPermissionsSetting@EnumerateInstances: CreateNewInstance failed"));                
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }              
            
            hr = LoadPropertyValues( pInstance, BIT_ALL_PROPERTIES, &pWS[ ulNum ] );
            
            if (SUCCEEDED( hr ) ) 
            {
                hr = pInstance->Commit();       
            }            
            pInstance->Release( );
        }
    }

    if( pWS != NULL)
    {
        CoTaskMemFree(pWS);
    }

    return hr;
/*
    HRESULT hr = WBEM_E_FAILED;
    
    CInstancePtr pInstance;
    
    // Collections
    TRefPointerCollection<CInstance>	TerminalList;
    
    // Perform queries
    //================
    
    if( SUCCEEDED( hr = CWbemProviderGlue::GetInstancesByQuery(L"select TerminalName from Win32_Terminal",
        &TerminalList, pMethodContext) ) )
    {
        TRC2((TB,"TSPermissionsSetting@GetObject: EnumerateInstances: GetInstancesByQuery ret 0x%x\n" , hr ));
        
        REFPTRCOLLECTION_POSITION	pos;
        
        CInstancePtr pTerminal(NULL);
        
        if( TerminalList.BeginEnum( pos ) )
        {
            
            for( pTerminal.Attach(TerminalList.GetNext( pos ) ) ;
            SUCCEEDED( hr ) && ( pTerminal != NULL ) ;
            pTerminal.Attach(TerminalList.GetNext( pos ) ) )
            {
                
                CHString chTermName;
                pTerminal->GetCHString(m_szTerminalName, chTermName);
                
                // No maximum limit check
                
                if( chTermName.IsEmpty() != 0)
                {
                    return WBEM_E_ILLEGAL_NULL;
                }        
                
                pInstance.Attach( CreateNewInstance(pMethodContext) );
                
                if( NULL != pInstance )
                {
                    // set relpath to Terminal
                    CHString chsTerminalPath;
                    CHString chsFullTerminalPath;
                    pTerminal->GetCHString(L"__RELPATH", chsTerminalPath);
                    chsFullTerminalPath.Format(L"\\\\%s\\%s:%s", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", (LPCTSTR)chsTerminalPath);
                    pInstance->SetCHString(L"Element", chsFullTerminalPath);
                    pInstance->SetCHString(m_szTerminalName, chTermName);
                    
                    // create a relpath for the TSPermissionsSetting
                    CHString chsTSAccountSettingPath;
                    chsTSAccountSettingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", L"Win32_TSAccount", m_szTerminalName, (LPCTSTR)chTermName);
                    
                    // and set the reference in the association
                    pInstance->SetCHString(L"Setting", chsTSAccountSettingPath);
                    // to that relpath.                                       
                    
                    hr = pInstance->Commit();
                }	// end if
                
            } // pTerminal not null        
            TerminalList.EndEnum();        
        }	// IF BeginEnum        
    }
    return( hr );
    */
}
//=--------------------



HRESULT CWin32_TSPermissionsSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{	
    
    if( pInstance == NULL )
    {   
        ERR((TB,"TSPermissionsSetting@LoadPropertyValues: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if( ulRequiredProperties & BIT_TERMINALNAME )
    {                
        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        
    } 
	
    return S_OK;
}

//=--------------------

HRESULT CWin32_TSPermissionsSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
    
} 

//=--------------------


HRESULT CWin32_TSPermissionsSetting::ExecMethod ( const CInstance& Inst,
                                                        const BSTR bstrMethodName,
                                                        CInstance *pInParams,
                                                        CInstance *pOutParams,
                                                        long lFlags)
                                                        
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    CHString chAccountName;
    DWORD dwPermissionPreSet = 0;
    DWORD dwMask = 0;
    DWORD dwPermissionDenyMask = 0;
    BOOL fAudit = FALSE;
    DWORD dwStatus = 0;	
    IUserSecurity *pUserSecurity = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}        
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );
    
    if( SUCCEEDED( hr ) && pUserSecurity != NULL )
    {       
        // Adds a new user or group to the existing set with 
        // the set of permissions defined.
        // uint32 Add([In] string AccountName, [In] uint32 PermissionPreSet)
        
        do
        {            
            if( _wcsicmp( bstrMethodName, m_szAddAccount ) == 0 )
            {
                if(pInParams == NULL)
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }

                bool bRet;

                chAccountName.Empty();
                
                pInParams->GetCHString(m_szAccountName, chAccountName);
                                
                if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                if( chAccountName.IsEmpty() != 0)
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                    
                    break;
                }
                
                bRet = pInParams->GetDWORD(m_szPermissionPreSet, dwPermissionPreSet);
                
                
                if( !bRet || dwPermissionPreSet > 3 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                if( dwPermissionPreSet == 0 )
                {
                    dwMask = WINSTATION_GUEST_ACCESS;
                }
                
                else if( dwPermissionPreSet == 1 )
                {
                    dwMask = WINSTATION_USER_ACCESS;
                }
                
                else if( dwPermissionPreSet == 2 )
                {
                    dwMask = WINSTATION_ALL_ACCESS;
                }
                
                hr  = pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                    (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                    dwMask,         // winsta permission
                    FALSE ,
                    TRUE  ,              // t - allow permission f - deny perm 
                    FALSE ,              // t - new object f - donot change previous permission                                
                    FALSE ,           // t - enable auditing f - no auditing
                    &dwStatus ); 
                
                TRC2((TB,"TSPermissionsSetting@ExecMethod: Add ret 0x%x\n" , dwStatus ));                
                
                if( SUCCEEDED (dwStatus) && pOutParams != NULL )
                {
                    pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    
                } 
                
                else
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                    
                    TRC2((TB,"TSPermissionsSetting@ExecMethod: Modify ret 0x%x\n" , hr));
                    
                    break;
                }
                
            }

            
            
            // Deletes the permission from the specified user or group.
            // uint32 RestoreDefaults();
            
                
            else if( _wcsicmp(bstrMethodName, m_szRestoreDefaults) == 0 )
            {
    
                dwStatus = 0;
                DWORD dwData = 0;
                LONG lSize;
                ULONG ulOffset = 0;
                DWORD cbItems = 0;
    //            PUSERPERMLIST pUserList = NULL;
                PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
              
                hr = StackObj.m_pCfgComp->GetDefaultSecurityDescriptor( &lSize, &pSecurityDescriptor  );
    
                if( SUCCEEDED( hr ) && pSecurityDescriptor != NULL)
                {
        
                    hr = StackObj.m_pCfgComp->SetSecurityDescriptor((LPTSTR) (LPCTSTR)chTermName, (DWORD) lSize, pSecurityDescriptor);
        
                    if( SUCCEEDED( hr ))
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();
            
                        if( SUCCEEDED( hr ) && pOutParams != NULL)
                        {   
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                
                            TRC2((TB,"TSPermissionsSetting@ExecMethod: RestoreDefaults ret 0x%x\n" , hr));                   
                        }
                    }
                }                
                else
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
          
                }

                if( pSecurityDescriptor != NULL )
                {
                    CoTaskMemFree( pSecurityDescriptor );
                }
            }                        
            
            else
            {
                hr = WBEM_E_INVALID_METHOD;

                break;
            }
            
            
        }while(0);
    }

    if( pUserSecurity != NULL)
    {
        pUserSecurity->Release();
    }

    return hr;
    
}

//=-----------------

HRESULT CWin32_TSPermissionsSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {  
            
            // Method 2 - Check if the query CAN be processed by 'name'. If yes, return only those names.
            
            if (bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                CInstance* pInstance = CreateNewInstance( pMethodContext );
                
                if( pInstance == NULL)
                {
                    TRC2((TB,"TSPermissionsSetting@ExecQuery: CreateNewInstance failed"));
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }

    return hr;
    
}

//=------------------------------

/*
CWin32_TSNetworkAdapterListSetting::CWin32_TSNetworkAdapterListSetting ( const CHString& setName, LPCTSTR pszNameSpace  )
: Provider (setName,pszNameSpace)
{
    

    if ( g_hInstance != NULL)
    {

        TRC2((TB, "CWin32_TSNetworkAdapterListSetting_ctor"));

        LoadString( g_hInstance , IDS_DEVICEID, m_szDeviceID, SIZE_OF_BUFFER(m_szDeviceID)-1 );   

        LoadString( g_hInstance , IDS_INDEX, m_szIndex, SIZE_OF_BUFFER(m_szIndex)-1 );

        LoadString( g_hInstance , IDS_DESCRIPTION, m_szDescription, SIZE_OF_BUFFER(m_szDescription)-1 );
        
        LoadString( g_hInstance , IDS_NETWORKADAPTERID, m_szNetworkAdapterID, SIZE_OF_BUFFER(m_szNetworkAdapterID)-1 );
        
        LoadString( g_hInstance , IDS_TERMINALNAME, m_szTerminalName, SIZE_OF_BUFFER(m_szTerminalName)-1 );

    }
}

CWin32_TSNetworkAdapterListSetting::~CWin32_TSNetworkAdapterListSetting ()
{
}



HRESULT CWin32_TSNetworkAdapterListSetting::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
    
    HRESULT hr = WBEM_E_FAILED;
    
    CInstancePtr pInstance;
    
    // Collections
    TRefPointerCollection<CInstance>	AdapterList;
    
    // Perform queries
    //================
    
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select DeviceID, Description, Index from Win32_NetworkAdapter",
        &AdapterList, pMethodContext)))
    {
        TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: GetInstancesByQuery ret 0x%x\n" , hr));
        
        REFPTRCOLLECTION_POSITION	pos;
        
        CInstancePtr	pAdapter(NULL);
        
        if( AdapterList.BeginEnum( pos ) )
        {
            
            for (pAdapter.Attach(AdapterList.GetNext( pos ) ) ;
            SUCCEEDED(hr) && ( pAdapter != NULL ) ;
            pAdapter.Attach(AdapterList.GetNext( pos ) ) )
            {
                
                CHString chTermName;
                CHString chDeviceID;
                CHString chDescription;
                DWORD dwIndex = 0;
                pAdapter->GetCHString(m_szDeviceID, chDeviceID);
                pAdapter->GetCHString(m_szDescription, chDescription);
                pAdapter->GetDWORD(m_szIndex, dwIndex);
                
                // No maximum limit check
                
                if( chDeviceID.IsEmpty() != 0)
                {
                    return WBEM_E_ILLEGAL_NULL;
                }        
                
                pInstance.Attach(CreateNewInstance(pMethodContext));
                
                if( NULL != pInstance )
                {
                    // set relpath to Adapter
                    CHString chsAdapterPath;
                    CHString chsFullAdapterPath;
                    pAdapter->GetCHString(L"__RELPATH", chsAdapterPath);
                    chsFullAdapterPath.Format(L"\\\\%s\\%s:%s", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", (LPCTSTR)chsAdapterPath);
                    pInstance->SetCHString(L"Element", chsFullAdapterPath);
                    pInstance->SetCHString(m_szDescription, chDescription);
                    pInstance->SetCHString(m_szDeviceID, chDeviceID);
                    pInstance->SetCHString(m_szNetworkAdapterID, chDeviceID);
                    pInstance->SetDWORD(m_szIndex, dwIndex);
                    
                    // create a relpath for the NetworkAdapterSettingsConfig
                    CHString chsNetworkAdapterSettingPath;
                    chsNetworkAdapterSettingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", L"Win32_TSNetworkAdapterSetting", m_szNetworkAdapterID, (LPCTSTR)chDeviceID);
                    
                    // and set the reference in the association
                    pInstance->SetCHString(L"Setting", chsNetworkAdapterSettingPath);
                    // to that relpath.
                    
                    CInstancePtr pNewInstance(NULL);
                    
                    if( SUCCEEDED(hr = CWbemProviderGlue::GetInstanceKeysByPath(chsNetworkAdapterSettingPath, &pNewInstance, pMethodContext)) )
                    {
                        pNewInstance->GetCHString(m_szTerminalName, chTermName);
                        pInstance->SetCHString(m_szTerminalName, chTermName);
                    }
                    TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: GetInstanceKeysByPath ret 0x%x\n" , hr));                    
                    
                    hr = pInstance->Commit();
                }	// end if
                
            } // pAdapter not null        
            AdapterList.EndEnum();        
        }	// IF BeginEnum        
    }
    return(hr);
    
}




HRESULT CWin32_TSNetworkAdapterListSetting::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    
    // get the object for the Win32_Terminal
    CHString chsAdapter;
    CInstancePtr pAdapter(NULL);
    
    if( pInstance != NULL )
    {
        pInstance->GetCHString(L"Element", chsAdapter);
        MethodContext* pMethodContext = pInstance->GetMethodContext();    
        
        hr = CWbemProviderGlue::GetInstanceByPath(chsAdapter, &pAdapter, pMethodContext);
        TRC2((TB,"TSNetworkAdapterListSetting@GetObject: GetInstanceByPath ret 0x%x\n" , hr));
        
        do
        {
            if( SUCCEEDED( hr ) && pAdapter != NULL )
            {
                // Got the account.  Now, match it to the GUID.
                // first, generate a relpath with which to compare.
                CHString chDeviceID;
                CHString chNetworkAdapterSettingInstance;
                CHString chDescription;
                DWORD dwIndex = 0;
                pAdapter->GetCHString(m_szDeviceID, chDeviceID); 
                pAdapter->GetCHString(m_szDescription, chDescription);
                pAdapter->GetDWORD(m_szIndex, dwIndex);
                
                // create a relpath for the sid
                CHString chsNetworkAdapterSettingPath;
                chsNetworkAdapterSettingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", L"Win32_TSNetworkAdapterSetting", m_szNetworkAdapterID, (LPCTSTR)chDeviceID);
                
                // get the SID path from the instance
                pInstance->GetCHString(L"Setting", chNetworkAdapterSettingInstance);
                
                // compare it to our generated relpath
                if( 0 != chNetworkAdapterSettingInstance.CompareNoCase(chsNetworkAdapterSettingPath) )
                {
                    hr = WBEM_E_NOT_FOUND;

                    TRC2((TB,"TSNetworkAdapterListSetting@GetObject: CompareNoCase for relpath ret 0x%x\n" , hr));
                    
                    break;
                }
                pInstance->SetCHString(m_szDescription, chDescription);
                pInstance->SetCHString(m_szDeviceID, chDeviceID);
                pInstance->SetCHString(m_szNetworkAdapterID, chDeviceID);
                pInstance->SetDWORD(m_szIndex, dwIndex);
                
            }
        }while (0);
    }
    return(hr);
}
*/



CWin32_TSNetworkAdapterListSetting::CWin32_TSNetworkAdapterListSetting ( const CHString& setName, LPCTSTR pszNameSpace  )
: Provider (setName,pszNameSpace)
{
    

    if ( g_hInstance != NULL)
    {        

        TRC2((TB, "CWin32_TSNetworkAdapterListSetting_ctor"));
       
        _tcscpy(m_szTerminalProtocol, _T("TerminalProtocol"));

        _tcscpy(m_szTransport, _T("Transport"));

        _tcscpy(m_szDescription, _T("Description"));

        _tcscpy(m_szNetworkAdapterID, _T("NetworkAdapterID"));
                
    }
}

CWin32_TSNetworkAdapterListSetting::~CWin32_TSNetworkAdapterListSetting ()
{
}


/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSNetworkAdapterListSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSNetworkAdapterListSetting::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
	
    HRESULT hr = WBEM_S_NO_ERROR;    
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    ULONG ulNum = 0;
    ULONG ulNumAdapters = 0;
    ULONG ulNAdapters = 0;
    ULONG ulItems = 0;
    DWORD dwSdclass = 0;
    PGUIDTBL pGuidTbl = NULL;
    PWS  pWS = NULL;
    CHString chGuid;
    LPBYTE pBuffer = NULL;
    chGuid.Empty();
    TCHAR tchGuid[ GUID_LENGTH ];
    TCHAR tchDeviceName[MAX_PATH];
    PPDPARAMS pPdParams = NULL;
    ULONG idx = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    if( SUCCEEDED( hr ))
    {
        hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);       
    }
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals ; ++ulNum)
        { 
            if( lstrcmpi( pWS[ulNum].pdName, L"Console") == 0)
            {
                continue;
            }

            hr = StackObj.m_pCfgComp->GetTransportType( pWS[ulNum].wdName , pWS[ulNum].pdName ,  &dwSdclass );

            TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: GetTransportType ret 0x%x\n" , hr )); 
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: dwSdclass is 0x%x\n", dwSdclass  ));

                if( dwSdclass == SdAsync)
                {
                    TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: SdAsync"  ));

                    hr = StackObj.m_pCfgComp->GetDeviceList( pWS[ulNum].pdName, WsName, &ulItems, &pBuffer );

                    TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: GetDeviceList ret 0x%x\n" , hr ));

                    if( SUCCEEDED(  hr ) )
                    {
		                DBGMSG( L"TSCC : GetDeviceList returned %d devices that are available\n" , ulItems );

                        for( idx = 0 , pPdParams = ( PPDPARAMS )pBuffer; idx < ulItems ; idx++, pPdParams++ )
                        {                         

                            if ( *(pPdParams->Async.ModemName) )
                                wsprintf( tchDeviceName, TEXT("%s - %s"),
                                          pPdParams->Async.DeviceName,
                                          pPdParams->Async.ModemName );
                            else
                            {
                                if( lstrlen(pPdParams->Async.DeviceName) < MAX_PATH)
                                {
                                    lstrcpy( tchDeviceName,
                                             pPdParams->Async.DeviceName );
                                }
                            }

                             CInstance* pInstance = CreateNewInstance(pMethodContext);
        
                             if( pInstance == NULL)
                             {
                                 ERR((TB,"TSNetworkAdapterListSetting@EnumerateInstances: CreateNewInstance failed" ));               
            
                                 hr = WBEM_E_OUT_OF_MEMORY;
            
                                 break;
                             }    
                             pInstance->SetCharSplat(m_szTerminalProtocol, pWS[ulNum].pdName);

                             pInstance->SetCharSplat(m_szTransport, pWS[ulNum].wdName);

                             pInstance->SetCHString(m_szNetworkAdapterID, L"Not Applicable");

                             if( BIT_ALL_PROP & BIT_COMMENT )
                             {
                                  if( StackObj.m_pCfgComp->IsAsyncDeviceAvailable( pPdParams->Async.DeviceName ) )
                                  {
                                        pInstance->SetCharSplat(m_szDescription, tchDeviceName);
                                  }  
                             }
                     
                             hr = pInstance->Commit();
                     
                         pInstance->Release( );

                        }
                    }                    
                }   
                
                else if( dwSdclass == SdNetwork)
                {

                    hr = StackObj.m_pCfgComp->GetLanAdapterList2( pWS[ulNum].pdName, &ulNumAdapters, &pGuidTbl );

                    TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: GetLanAdapterList2 ret 0x%x\n" , hr ));
                
                    if( SUCCEEDED( hr )  && pGuidTbl != NULL )
                    {
                        for ( ulNAdapters = 0; ulNAdapters < ulNumAdapters ; ulNAdapters++ )
                        {
                            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
                            if( pInstance == NULL)
                            {
                                ERR((TB,"TSNetworkAdapterListSetting@EnumerateInstances: CreateNewInstance failed" ));               
                
                                hr = WBEM_E_OUT_OF_MEMORY;
                
                                break;
                            }                        

                            StringFromGUID2( ( pGuidTbl )[ ulNAdapters ].guidNIC , tchGuid , ARRAYSIZE( tchGuid ) );
                        
                            chGuid.Format(L"%s", tchGuid);                   

                            pInstance->SetCharSplat(m_szTerminalProtocol, pWS[ulNum].pdName);

                            pInstance->SetCharSplat(m_szTransport, pWS[ulNum].wdName);

                            pInstance->SetCHString(m_szNetworkAdapterID, chGuid);                        

                            if( BIT_ALL_PROP & BIT_COMMENT )
                            {                        
                                pInstance->SetCharSplat(m_szDescription, pGuidTbl[ulNAdapters].DispName);                                       
                            }        
            
                            if( SUCCEEDED( hr ) )
                            {
                                hr = pInstance->Commit();
                            }
                            pInstance->Release( );
                        }
                    }
                }
            }
        }
        
    }

    if( pPdParams != NULL)
    {
        LocalFree( pPdParams);
    }    

    if( pBuffer != NULL )
    {
        LocalFree( pBuffer );
    }
    
    if( pWS != NULL ) 
    {
        CoTaskMemFree(pWS);
        
    }

    if( pGuidTbl != NULL )
    {
        CoTaskMemFree( pGuidTbl );
    }    

    return hr;

}



HRESULT CWin32_TSNetworkAdapterListSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTerminalProtocol;
    CHString chTransport;
    CHString chGuid;
    ULONG ulNAdapters = 0;
    ULONG ulNumAdapters = 0;
    DWORD dwSdclass = 0;
    ULONGLONG ulRequiredProperties = 0;
    PGUIDTBL pGuidTbl = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    if( pInstance == NULL )
    {
        ERR((TB,"TSNetworkAdapterListSetting@GetObject: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalProtocol, chTerminalProtocol);
    
    if( chTerminalProtocol.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTerminalProtocol.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    pInstance->GetCHString(m_szTransport, chTransport);
    
    if( chTransport.GetLength() > NASIUSERNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTransport.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    chGuid.Empty();           
 
    pInstance->GetCHString(m_szNetworkAdapterID, chGuid);

    if( chGuid.GetLength() > GUID_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chGuid.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }   

    hr = StackObj.m_pCfgComp->GetTransportType( (LPTSTR)(LPCTSTR) chTransport , (LPTSTR)(LPCTSTR) chTerminalProtocol , &dwSdclass );

    TRC2((TB,"TSNetworkAdapterListSetting@GetObject: GetTransportType ret 0x%x\n" , hr )); 

    if( SUCCEEDED( hr ) )
    {        
        if( dwSdclass != SdNetwork )
        {
            return WBEM_E_INVALID_OPERATION;
        }     
          
        hr = StackObj.m_pCfgComp->GetLanAdapterList2( (LPTSTR)(LPCTSTR) chTerminalProtocol, &ulNumAdapters, &pGuidTbl );  

        TRC2((TB,"TSNetworkAdapterListSetting@GetObject: GetLanAdapterList2 ret 0x%x\n" , hr )); 

        if( SUCCEEDED( hr ) && pGuidTbl != NULL )
        {      
            for( ulNAdapters = 0; ulNAdapters < ulNumAdapters ; ulNAdapters++ )
            {
              //  hr = LoadPropertyValues(pInstance, ulRequiredProperties, (LPTSTR)(LPCTSTR) chTerminalProtocol, (LPTSTR) (LPCTSTR) chTransport, (LPTSTR) (LPCTSTR) chGuid, pGuidTbl[ulNAdapters].DispName );
                if( ulRequiredProperties & BIT_COMMENT )
                {                        
                    pInstance->SetCharSplat(m_szDescription, pGuidTbl[ulNAdapters].DispName);                                       
                }     
            }
        }
    }

    if( pGuidTbl != NULL )
    {
        CoTaskMemFree( pGuidTbl );
    }

    return hr;
}


/*
HRESULT CWin32_TSNetworkAdapterListSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PTCHAR pdName, PTCHAR wdName, PTCHAR pGuid, PTCHAR DisplayName)
{

    DWORD dwData = 0 ;
    DWORD cbItems = 0;
    ULONG ulAdapters = 0;
    CHString chGuid;
    chGuid.Empty();
    chGuid.Format (L"%s", pGuid);
    CHString chGUIDName;
    HRESULT hr = WBEM_S_NO_ERROR;

    TCHAR tchGuid[ GUID_LENGTH ];        
    

    if( pCfgComp == NULL )
    {
        ERR((TB,"TSNetworkAdapterListSetting@LoadPropertyValues: invalid interface"));
        
        return WBEM_E_INITIALIZATION_FAILURE;        
    }
    
    if( pInstance == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;       
    }   
              
    pInstance->SetCharSplat(m_szTerminalProtocol, pdName);

    pInstance->SetCharSplat(m_szTransport, wdName);

    pInstance->SetCharSplat(m_szNetworkAdapterID, pGuid);

    if( chGuid.IsEmpty() != 0 )
    {         
        pInstance->SetCharSplat(m_szNetworkAdapterID, pGuid);
    }
    else
    {
        pInstance->SetCHString(m_szNetworkAdapterID, chGuid );
    }

    if( ulRequiredProperties & BIT_COMMENT )
    {                        
        pInstance->SetCharSplat(m_szDescription, DisplayName);                                       
    }                                   
    
    return S_OK;
}
*/

//=-------------------------------


CWin32_TSAccount::CWin32_TSAccount (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{
    
    if ( g_hInstance != NULL)
    {

        TRC2((TB, "CWin32_TSAccount_ctor"));

        _tcscpy(m_szPermissionPreSet, _T("PermissionPreSet"));

        _tcscpy(m_szPermissionMask, _T("PermissionMask"));

        _tcscpy(m_szPermissionsAllowed, _T("PermissionsAllowed"));

        _tcscpy(m_szPermissionsDenied, _T("PermissionsDenied"));

        _tcscpy(m_szAuditSuccess, _T("AuditSuccess"));

        _tcscpy(m_szAuditFail, _T("AuditFail"));

        _tcscpy(m_szAllow, _T("Allow"));

        _tcscpy(m_szSuccess, _T("Success"));

        _tcscpy(m_szSID, _T("SID"));

        _tcscpy(m_szDelete, _T("Delete"));

        _tcscpy(m_szModifyPermissions, _T("ModifyPermissions"));

        _tcscpy(m_szModifyAuditPermissions, _T("ModifyAuditPermissions"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szAccountName, _T("AccountName"));        

    }

}
//=--------------------
CWin32_TSAccount::~CWin32_TSAccount ()
{    
}


//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSAccount::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/


HRESULT CWin32_TSAccount::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    ULONG ulNum = 0;
    ULONG ulAuditNum = 0;
    bool bFound = 0;
    DWORD cbItems = 0;
    DWORD cbAuditItems = 0;
    PWS  pWS = NULL;
    PUSERPERMLIST pUserList = NULL;
    PUSERPERMLIST pUserAuditList = NULL;
    IUserSecurity *pUserSecurity = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++ )
        {   
            hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );
            
            if( SUCCEEDED (hr) && pUserSecurity != NULL )
            {                
                
                hr = pUserSecurity->GetUserPermList( pWS[ulNum].Name , &cbItems , &pUserList, 0  );

                hr = pUserSecurity->GetUserPermList( pWS[ulNum].Name , &cbAuditItems , &pUserAuditList, 1  );                
                
                for( DWORD i = 0; i < cbItems && SUCCEEDED( hr ) ; ++i )
                {

                    for( DWORD j = 0;j < cbAuditItems ; j ++ )
                    {
                        bFound = 0;

                        if( lstrcmpi (pUserAuditList[j].Name, pUserList[i].Name) == 0 )
                        {
                            bFound = 1;

                            ulAuditNum = j;

                            break;
                        }
                    }

                    
                    CInstance* pInstance = CreateNewInstance(pMethodContext);
                    
                    if( pInstance == NULL)
                    {
                        ERR((TB,"TSAccount@EnumerateInstances: CreateNewInstance failed"));
                        
                        hr = WBEM_E_OUT_OF_MEMORY;

                        break;                                               
                    }
                    TRC2((TB,"TSAccount@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr));

                    if( bFound == 1 )
                    {
                        hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ulNum], &pUserList[i], &pUserAuditList[ulAuditNum]);
                    }
                    else
                    {
                        hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ulNum], &pUserList[i], NULL);
                    }
                    
                    if( SUCCEEDED( hr ) )
                    {                        
                        hr = pInstance->Commit();                                                                                                
                    }

                    pInstance->Release( );
                }
            }
        }
        
    }

    if( pUserList != NULL )
    {
        CoTaskMemFree( pUserList );
    }

    if( pUserAuditList != NULL )
    {
        CoTaskMemFree( pUserAuditList );
    }    
    
    if( pWS != NULL )
    {
        CoTaskMemFree( pWS );
    }

    if (pUserSecurity != NULL)
    {
        pUserSecurity->Release();
    }

    return hr;
    
}
//=--------------------


HRESULT CWin32_TSAccount::ExecMethod ( const CInstance& Inst,
                                                        const BSTR bstrMethodName,
                                                        CInstance *pInParams,
                                                        CInstance *pOutParams,
                                                        long lFlags)
                                                        
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    CHString chAccountName;
    DWORD dwPermissionPreSet = 0;
    DWORD dwMask = 0;
    DWORD dwPermissionDenyMask = 0;
    BOOL fAudit = FALSE;
    DWORD dwStatus = 0;
    IUserSecurity *pUserSecurity = NULL;
    
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
            
    hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );
    
    if( SUCCEEDED( hr ) && pUserSecurity != NULL  )
    {        
        do
        {
            
            // Deletes the permission from the specified user or group.
            // uint32 Delete();

            if( _wcsicmp(bstrMethodName, m_szDelete) == 0 )
            {
                
                dwStatus = 0;
                DWORD dwData = 0;
                LONG lSize;
                
                RegGetMachinePolicy( &m_gpPolicy );                    
                  
                Inst.GetCHString(m_szAccountName, chAccountName);
                
                
                if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                if( chAccountName.IsEmpty() != 0)
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                    
                    break;
                }
                
                if ( m_gpPolicy.fPolicyWritableTSCCPermissionsTAB == 0)
                {                    
                    hr = pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                        (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                        0,         // winsta permission
                        TRUE ,
                        FALSE  ,              // t - allow permission f - deny perm 
                        FALSE ,              // t - new object f - donot change previous permission                                
                        FALSE ,           // t - enable auditing f - no auditing
                        &dwStatus );
                
                    TRC2((TB,"TSAccount@ExecMethod: Delete with Deny=True and Audit=False ret 0x%x\n", dwStatus));
                
                    hr = pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                        (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                        0,         // winsta permission
                        TRUE ,
                        FALSE  ,              // t - allow permission f - deny perm 
                        FALSE ,              // t - new object f - donot change previous permission                                
                        TRUE ,           // t - enable auditing f - no auditing
                        &dwStatus );
                
                    TRC2((TB,"TSAccount@ExecMethod: Delete with Deny=True and Audit=True ret 0x%x\n", dwStatus));
                                    
                    if (pOutParams != NULL && SUCCEEDED( hr ) && SUCCEEDED( dwStatus ))
                    {
                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }                      
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;  
                        
                        break;
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                }                                                   
                
            }
            
            // Restores the default permissions to default set of users and groups.
            // uint32 ModifyPermissions([In] uint32 PermissionMask, [In] boolean Allow)

            else if( _wcsicmp(bstrMethodName, m_szModifyPermissions) == 0 )
            {                                
                dwStatus = 0;
                DWORD dwData = 0;
                LONG lSize;
                ULONG ulOffset = 0;
                DWORD cbItems = 0;
                ULONG ulPermissionMask = 0;
                bool fAllow;
                bool bRet;

                RegGetMachinePolicy(&m_gpPolicy);
                                           
                Inst.GetCHString(m_szAccountName, chAccountName);
            
            
                if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                
                    break;
                }
            
                if( chAccountName.IsEmpty() != 0 )
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                
                    break;
                }

                if(pInParams == NULL)
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }

                bRet = pInParams->GetDWORD(m_szPermissionMask, ulPermissionMask);
        
        
                if( !bRet || ulPermissionMask > 9 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                    break;
                }               
                
                if(ulPermissionMask == 3)      // WINSTATION_VIRTUAL | STANDARD_RIGHTS_REQUIRED                                          
                {
                    dwMask = 0xF0008;
                }
                else
                {        
                   
                    ULONG ulBase = 1;

                    for (ULONG ulIndex = 1; ulIndex <= ulPermissionMask; ulIndex++)
                    {
                        ulBase *= 2;
        
                    }

                    dwMask = ulBase;   
                }
                
                
                RegGetMachinePolicy(&m_gpPolicy);
        
                pInParams->Getbool(m_szAllow, fAllow);
        
                if( fAllow != 0 && fAllow != 1 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                    break;
                }
        
        /*
        
                if( fAudit != 0 && fAudit != 1 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                    break;
                }
        */

                if( m_gpPolicy.fPolicyWritableTSCCPermissionsTAB == 0 )
                {

                    pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                        (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                        dwMask,         // winsta permission
                        FALSE ,
                        fAllow  ,              // t - allow permission f - deny perm 
                        FALSE ,              // t - new object f - donot change previous permission                                
                        FALSE ,           // t - enable auditing f - no auditing
                        &dwStatus ); 
                
                    TRC2((TB,"TSAccount@ExecMethod: Modify with Audit=0 ret 0x%x\n", dwStatus));
        
                    if( SUCCEEDED (dwStatus) && pOutParams != NULL )
                    {

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
            
                    } 
        
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                        ERR((TB,"TSAccount@ExecMethod: Modify ret 0x%x\n", hr));
            
                        break;
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
            
                           
            }
            
            // Modifies Audit permissions of users and groups.
            // uint32 ModifyAuditPermissions([In] uint32 PermissionMask, [In] boolean Allow)

            else if( _wcsicmp(bstrMethodName, m_szModifyAuditPermissions) == 0 )
            {
                
                dwStatus = 0;
                DWORD dwData = 0;
                LONG lSize;
                ULONG ulOffset = 0;
                DWORD cbItems = 0;
                ULONG ulPermissionMask = 0;
                bool fSuccess;
                bool bRet;
                
                RegGetMachinePolicy( &m_gpPolicy );
                
                Inst.GetCHString(m_szAccountName, chAccountName);
                
                
                if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                if( chAccountName.IsEmpty() != 0)
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                    
                    break;
                }

                if(pInParams == NULL)
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }
               
                bRet = pInParams->GetDWORD(m_szPermissionMask, ulPermissionMask);
                        
                if( !bRet || ulPermissionMask > 9 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                
                    break;
                } 

                if(ulPermissionMask == 3) // WINSTATION_VIRTUAL is defined as 0x00000008 but                                          
                {                         // GetExplicitEntriesFromAcl is returning 983048
                    dwMask = 0xF0008;
                }
                else
                {                                
                    ULONG ulBase = 1;

                    for( ULONG ulIndex = 1; ulIndex <= ulPermissionMask; ulIndex++ )
                    {
                        ulBase *= 2;
            
                    }

                    dwMask = ulBase;
                }            
            
                pInParams->Getbool(m_szSuccess, fSuccess);
            
            
                if( fSuccess != 0 && fSuccess != 1 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                
                    break;
                }
            
                if( m_gpPolicy.fPolicyWritableTSCCPermissionsTAB == 0 )
                {
            
                    pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                        (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                        dwMask,         // winsta permission
                        FALSE ,
                        fSuccess  ,              // t - allow permission f - deny perm 
                        FALSE ,              // t - new object f - donot change previous permission                                
                        TRUE ,           // t - enable auditing f - no auditing
                        &dwStatus ); 

                    TRC2((TB,"TSAccount@ExecMethod: ModifyAuditPermissions ret 0x%x\n", dwStatus));                                               
            
                    if( SUCCEEDED (dwStatus) && pOutParams != NULL )
                    {
                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                
                    } 
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                        TRC2((TB,"TSAccount@ExecMethod: Modify ret 0x%x\n", hr));
                
                        break;
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }            
            }
            
            else
            {
                hr = WBEM_E_INVALID_METHOD;

                break;
            }
            
        }while(0);
    } 

    if( pUserSecurity != NULL)
    {
        pUserSecurity->Release();
    }

    return hr;
    
}

//=--------------------

HRESULT CWin32_TSAccount::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    ULONG ulAuditNum = 0;
    PWS pWS = NULL;
    PUSERPERMLIST pUserList = NULL;
    PUSERPERMLIST pUserAuditList = NULL;
    DWORD cbItems = 0;
    DWORD cbAuditItems = 0;
    bool bFound = 0;
    IUserSecurity *pUserSecurity = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szSID))
        ulRequiredProperties |= BIT_SID;
    
    if (Query.IsPropertyRequired(m_szAccountName))
        ulRequiredProperties |= BIT_ACCOUNTNAME;

    if (Query.IsPropertyRequired(m_szAuditSuccess))
        ulRequiredProperties |= BIT_AUDITSUCCESS;

    if (Query.IsPropertyRequired(m_szAuditFail))
        ulRequiredProperties |= BIT_AUDITFAIL;
    
    if (Query.IsPropertyRequired(m_szPermissionsAllowed))
        ulRequiredProperties |= BIT_PERMISSIONSALLOWED;
    
    if (Query.IsPropertyRequired(m_szPermissionsDenied))
        ulRequiredProperties |= BIT_PERMISSIONSDENIED;
   
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {  
            
            // Method 2 
            if (bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );
                
                if (SUCCEEDED ( hr ) && pUserSecurity != NULL)
                {                   
                    
                    hr = pUserSecurity->GetUserPermList( pWS[ulNum].Name , &cbItems , &pUserList, 0  );

                    hr = pUserSecurity->GetUserPermList( pWS[ulNum].Name , &cbAuditItems , &pUserAuditList, 1  );
                    
                    for( DWORD i = 0; i < cbItems && SUCCEEDED( hr ) ; ++i )
                    {
                        for( DWORD j = 0;j < cbAuditItems ; j ++ )
                        {
                            bFound = 0;

                            if( lstrcmpi (pUserAuditList[j].Name, pUserList[i].Name) == 0 )
                            {
                                bFound = 1;

                                ulAuditNum = j;

                                break;
                            }
                        }
                        
                        CInstance* pInstance = CreateNewInstance(pMethodContext);
                        
                        if( pInstance == NULL )
                        {
                            ERR((TB,"TSAccount@ExecQuery: CreateNewInstance failed"));
                                                        
                            hr = WBEM_E_OUT_OF_MEMORY;

                            break;                                                       
                        }                        
                        
                        if( bFound == 1 )
                        {
                            hr = LoadPropertyValues(pInstance, ulRequiredProperties, &pWS[ulNum], &pUserList[i], &pUserAuditList[ulAuditNum]);
                        }
                        else
                        {
                            hr = LoadPropertyValues(pInstance, ulRequiredProperties, &pWS[ulNum], &pUserList[i], NULL);
                        }


                        if( SUCCEEDED( hr ) )
                        {
                            hr = pInstance->Commit();
                        }
                        
                        pInstance->Release();
                    }
                }
            }
        }
    }

    if( pUserList != NULL )
    {
        CoTaskMemFree( pUserList );
    }

    if( pUserAuditList != NULL )
    {
        CoTaskMemFree( pUserAuditList );
    }    
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    if( pUserSecurity != NULL )
    {
        pUserSecurity->Release();
    }

    return hr;
}

//=------------------------------

HRESULT CWin32_TSAccount::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{	
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    CHString chTermName;
    CHString chAccountName;
    DWORD cbItems = 0;
    DWORD cbAuditItems = 0;
    ULONG ulSize = 0;
    ULONGLONG ulRequiredProperties = 0;
    LONG  lSize = 0;
    bool bFound = 0;
    PWS pWS = NULL;
    PUSERPERMLIST pUserList = NULL;
    PUSERPERMLIST pUserAuditList = NULL;
    ULONG ulNum = 0;
    ULONG ulAuditNum = 0;
    IUserSecurity *pUserSecurity = NULL;
    
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSAccount@GetObject: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    pInstance->GetCHString(m_szAccountName, chAccountName);
    
    if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chAccountName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if( Query.IsPropertyRequired(m_szTerminalName) )
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if( Query.IsPropertyRequired(m_szSID) )
        ulRequiredProperties |= BIT_SID;
    
    if( Query.IsPropertyRequired(m_szAccountName) )
        ulRequiredProperties |= BIT_ACCOUNTNAME;

    if( Query.IsPropertyRequired(m_szAuditSuccess) )
        ulRequiredProperties |= BIT_AUDITSUCCESS;

    if( Query.IsPropertyRequired(m_szAuditFail) )
        ulRequiredProperties |= BIT_AUDITFAIL;
    
    if( Query.IsPropertyRequired(m_szPermissionsAllowed) )
        ulRequiredProperties |= BIT_PERMISSIONSALLOWED;
    
    if( Query.IsPropertyRequired(m_szPermissionsDenied) )
        ulRequiredProperties |= BIT_PERMISSIONSDENIED;
    
    hr = StackObj.m_pCfgComp->GetWSInfo( ( LPTSTR )( LPCTSTR )chTermName, &lSize, &pWS);
    
    hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );

    if( pUserSecurity != NULL && pWS != NULL && SUCCEEDED( hr ))
    {    
        do
        {                    

            hr = pUserSecurity->GetUserPermList( ( LPTSTR )( LPCTSTR ) chTermName , &cbAuditItems , &pUserAuditList, 1 );

            if( SUCCEEDED( hr ) && pUserAuditList != NULL)
            {

                for( ulAuditNum = 0; ulAuditNum < cbAuditItems ; ulAuditNum ++ )
                {
                    bFound = 0;

                    if( lstrcmpi (pUserAuditList[ulAuditNum].Name, (LPCTSTR) chAccountName) == 0 )
                    {
                        bFound = 1;

                        break;
                    }
                }
            }
            
            hr = pUserSecurity->GetUserPermList( ( LPTSTR )( LPCTSTR ) chTermName , &cbItems , &pUserList, 0 );

            if( SUCCEEDED (hr) && pUserList != NULL )
            {                                                    
                for( ulNum = 0; ulNum < cbItems ; ulNum ++  )
                {
                    if( lstrcmpi (pUserList[ulNum].Name, (LPCTSTR) chAccountName) != 0 )
                
                        continue;

                
                    if( bFound == 1 )
                    {
                        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS, &pUserList[ulNum], &pUserAuditList[ulAuditNum]);
                    }
                    else
                    {
                        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS, &pUserList[ulNum], NULL);
                    }
            
                    if( !(SUCCEEDED ( hr ) ))
                    {                                         
                        hr = WBEM_E_INVALID_OBJECT;

                        break;
                    }                                           
                }
            }
        
        }while(0);
    }

    if( pUserList != NULL )
    {
        CoTaskMemFree( pUserList );
    }

    if( pUserAuditList != NULL )
    {
        CoTaskMemFree( pUserAuditList );
    }
       
    if( pWS != NULL )
    {
        CoTaskMemFree (pWS);
    }

    if( pUserSecurity != NULL )
    {
        pUserSecurity->Release();
    }
    
    return hr;
    
}
//=--------------------

BOOL CWin32_TSAccount::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for( DWORD x=0; x < dwSize; x++ )
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=-----------------

HRESULT CWin32_TSAccount::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS, PUSERPERMLIST pUserList, PUSERPERMLIST pUserAuditList)
{	
    HRESULT hr = S_OK;
    LONG lSize ;
    DWORD dwData = 0 ;
    DWORD cbItems = 0;
   
    if( pInstance == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;       
    }   
    
    if( pWS != NULL && pUserList != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME )
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        }
       
        if( ulRequiredProperties & BIT_SID )
        {      
            pInstance->SetWCHARSplat(m_szSID, pUserList->Sid);
        }
        
        if( ulRequiredProperties & BIT_ACCOUNTNAME )
        {   
            pInstance->SetCharSplat(m_szAccountName, pUserList->Name);
        }
        
        if( ulRequiredProperties & BIT_PERMISSIONSALLOWED )
        {   
            if( pUserList->Type == 1 )
            {                  
                pInstance->SetDWORD(m_szPermissionsAllowed, pUserList->Mask);                
            }
            else
            {
                pInstance->SetDWORD(m_szPermissionsAllowed, 0);
            }
        }
        if( ulRequiredProperties & BIT_PERMISSIONSDENIED )
        {
            if( pUserList->Type == 3 )
            {              
                pInstance->SetDWORD(m_szPermissionsDenied, pUserList->Mask);                
            }
            else
            {
                pInstance->SetDWORD(m_szPermissionsDenied, 0);
            }
        }
        
        if( ulRequiredProperties & BIT_AUDITSUCCESS )
        { 
            if( pUserAuditList != NULL && pUserAuditList->Type == 5 )
            {                
                pInstance->SetDWORD(m_szAuditSuccess, pUserAuditList->Mask); 
            }
                
            else
            {
                pInstance->SetDWORD(m_szAuditSuccess, 0);
            }
        }
        if( ulRequiredProperties & BIT_AUDITFAIL )
        {
            if( pUserAuditList != NULL && pUserAuditList->Type == 6 )
            {
                pInstance->SetDWORD(m_szAuditFail, pUserAuditList->Mask);                        
            }
            else
            {
                pInstance->SetDWORD(m_szAuditFail, 0);
            }
        }                   
    } 


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wtsapi\config.c ===
/*******************************************************************************
* config.c
*
* Published Terminal Server APIs
*
* - user configuration routines
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <ntsecapi.h>
#include <lm.h>
#include <winbase.h>
#include <winerror.h>
#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif

#include <utildll.h>

#include <stdio.h>
#include <stdarg.h>

#include <lmaccess.h> // for NetGet[Any]DCName                     KLB 10-07-97
#include <lmerr.h>    // for NERR_Success                          KLB 10-07-97
#include <lmapibuf.h> // for NetApiBufferFree                      KLB 10-07-97

#include <wtsapi32.h>


/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSQueryUserConfigW( LPWSTR, LPWSTR, WTS_CONFIG_CLASS, LPWSTR *, DWORD *);
BOOL WINAPI WTSQueryUserConfigA( LPSTR, LPSTR,  WTS_CONFIG_CLASS, LPSTR *,  DWORD *);
BOOL WINAPI WTSSetUserConfigW( LPWSTR, LPWSTR, WTS_CONFIG_CLASS, LPWSTR, DWORD);
BOOL WINAPI WTSSetUserConfigA( LPSTR, LPSTR,  WTS_CONFIG_CLASS, LPSTR,  DWORD);


/*=============================================================================
==   Internal procedures defined
=============================================================================*/
#ifdef NETWARE

//This should be defined in the wtsapi32.h

typedef struct _WTS_USER_CONFIG_SET_NWSERVERW {
    LPWSTR pNWServerName; 
    LPWSTR pNWDomainAdminName;
    LPWSTR pNWDomainAdminPassword;  
} WTS_USER_CONFIG_SET_NWSERVERW, * PWTS_USER_CONFIG_SET_NWSERVERW;

BOOL
SetNWAuthenticationServer(PWTS_USER_CONFIG_SET_NWSERVERW pInput,
                          LPWSTR pServerNameW,
                          LPWSTR pUserNameW,
                          PUSERCONFIGW pUserConfigW
                         );


#endif
/*=============================================================================
==   Procedures used
=============================================================================*/

BOOL _CopyData( PVOID, ULONG, LPWSTR *, DWORD * );
BOOL _CopyStringW( LPWSTR, LPWSTR *, DWORD * );
BOOL _CopyStringA( LPSTR, LPWSTR *, DWORD * );
BOOL _CopyStringWtoA( LPWSTR, LPSTR *, DWORD * );
BOOL ValidateCopyAnsiToUnicode(LPSTR, DWORD, LPWSTR);
BOOL ValidateCopyUnicodeToUnicode(LPWSTR, DWORD, LPWSTR);
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );


/*=============================================================================
==   Local Data
=============================================================================*/

/****************************************************************************
 *
 *  WTSQueryUserConfigW (UNICODE)
 *
 *    Query information from the SAM for the specified user
 *
 * ENTRY:
 *    pServerName (input)
 *       Name of server to access (NULL for current machine).
 *    pUserName (input)
 *       User name to query
 *    WTSConfigClass (input)
 *       Specifies the type of information to retrieve about the specified user
 *    ppBuffer (output)
 *       Points to the address of a variable to receive information about
 *       the specified session.  The format and contents of the data
 *       depend on the specified information class being queried.  The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 * HISTORY:
 *    Created KLB 10-06-97
 *
 ****************************************************************************/

BOOL
WINAPI
WTSQueryUserConfigW(
                   IN LPWSTR pServerName,
                   IN LPWSTR pUserName,
                   IN WTS_CONFIG_CLASS WTSConfigClass,
                   OUT LPWSTR * ppBuffer,
                   OUT DWORD * pBytesReturned
                   )
{
    USERCONFIGW       UserConfigW;
    ULONG             ulReturnLength;
    LONG              rc;
    BOOL              fSuccess  = FALSE;
    DWORD             dwfInheritInitialProgram;
    DWORD             dwReturnValue;
    PUSER_INFO_0      pUserInfo = NULL;
    WCHAR             netServerName[DOMAIN_LENGTH + 3];

    /*
     * Check the null buffer
     */

    if (!ppBuffer || !pBytesReturned) {
        SetLastError (ERROR_INVALID_PARAMETER);
        fSuccess = FALSE;
        goto done;
    }
    /*
     *  First, we want to make sure the user actually exists on the specified
     *  machine.
     */

    rc = NetUserGetInfo( pServerName,     // server name (can be NULL)
                         pUserName,       // user name
                         0,               // level to query (0 = just name)
                         (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)

    /*
     * append the "\\" in front of server name to check the user name existence again
     */

    if ( rc != NERR_Success && pServerName) {

        lstrcpyW(netServerName, L"\\\\");
        lstrcatW(netServerName, pServerName);

        rc = NetUserGetInfo( netServerName,     // server name (can be NULL)
                             pUserName,       // user name
                             0,               // level to query (0 = user name)
                             (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)

        if ( rc != NERR_Success ) {
            SetLastError( ERROR_NO_SUCH_USER );
            goto done; // exit with fSuccess = FALSE
        }
    }

    /*
     *  Query the user.  If the user config doesn't exist for the user, then 
     *  we query the default values.
     */
    rc = RegUserConfigQuery( pServerName,               // server name
                              pUserName,                 // user name
                              &UserConfigW,              // returned user config
                              (ULONG)sizeof(UserConfigW),// user config length
                              &ulReturnLength );         // #bytes returned
    if ( rc != ERROR_SUCCESS ) {
        rc = RegDefaultUserConfigQuery( pServerName,               // server name
                                         &UserConfigW,              // returned user config
                                         (ULONG)sizeof(UserConfigW),// user config length
                                         &ulReturnLength );         // #bytes returned
    }

    /*
     *  Now, process the results.  Note that in each case, we're allocating a
     *  new buffer which the caller must free
     *  (WTSUserConfigfInheritInitialProgram is just a boolean, but we allocate
     *  a DWORD to send it back).
     */
    if ( rc == ERROR_SUCCESS ) {
        switch ( WTSConfigClass ) {
        case WTSUserConfigInitialProgram:
            fSuccess = _CopyStringW( UserConfigW.InitialProgram, 
                                     ppBuffer,
                                     pBytesReturned );
            break;

        case WTSUserConfigWorkingDirectory:
            fSuccess = _CopyStringW( UserConfigW.WorkDirectory, 
                                     ppBuffer,
                                     pBytesReturned );
            break;

        case WTSUserConfigfInheritInitialProgram:
            dwReturnValue = UserConfigW.fInheritInitialProgram; 
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigfAllowLogonTerminalServer:    //DWORD returned/expected

            dwReturnValue = !(UserConfigW.fLogonDisabled);
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );


            break;
            //Timeout settings
        case WTSUserConfigTimeoutSettingsConnections:
            dwReturnValue = UserConfigW.MaxConnectionTime;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigTimeoutSettingsDisconnections: //DWORD 
            dwReturnValue = UserConfigW.MaxDisconnectionTime;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigTimeoutSettingsIdle:          //DWORD 
            dwReturnValue = UserConfigW.MaxIdleTime;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
        case WTSUserConfigfDeviceClientDrives:                  //DWORD 
            dwReturnValue = UserConfigW.fAutoClientDrives;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigfDeviceClientPrinters:   //DWORD 
            dwReturnValue = UserConfigW.fAutoClientLpts;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigfDeviceClientDefaultPrinter:   //DWORD 
            dwReturnValue = UserConfigW.fForceClientLptDef;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;


            //Connection settings
        case WTSUserConfigBrokenTimeoutSettings:         //DWORD 
            dwReturnValue = UserConfigW.fResetBroken;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
        case WTSUserConfigReconnectSettings:
            dwReturnValue = UserConfigW.fReconnectSame;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

            //Modem settings
        case WTSUserConfigModemCallbackSettings:         //DWORD 
            dwReturnValue = UserConfigW.Callback;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
        case WTSUserConfigModemCallbackPhoneNumber:
            fSuccess = _CopyStringW(UserConfigW.CallbackNumber,
                                    ppBuffer,
                                    pBytesReturned );
            break;

        case WTSUserConfigShadowingSettings:             //DWORD 
            dwReturnValue = UserConfigW.Shadow;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
#ifdef NETWARE
        case WTSUserConfigNWServerName:             // string 
            fSuccess = _CopyStringW(UserConfigW.NWLogonServer,
                                    ppBuffer,
                                    pBytesReturned );

            break;
#endif
        case WTSUserConfigTerminalServerProfilePath:     // string 
            fSuccess = _CopyStringW(UserConfigW.WFProfilePath,
                                    ppBuffer,
                                    pBytesReturned );
            break;

        case WTSUserConfigTerminalServerHomeDir:       // string 
            fSuccess = _CopyStringW(UserConfigW.WFHomeDir,
                                    ppBuffer,
                                    pBytesReturned );
            break;
        case WTSUserConfigTerminalServerHomeDirDrive:    // string 
            fSuccess = _CopyStringW(UserConfigW.WFHomeDirDrive,
                                    ppBuffer,
                                    pBytesReturned );
            break;

        case WTSUserConfigfTerminalServerRemoteHomeDir:                  // DWORD 0:LOCAL 1:REMOTE
            if (wcslen(UserConfigW.WFHomeDirDrive) > 0 ) {
                dwReturnValue = 1;

            } else {
                dwReturnValue = 0;
            }

            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );


            break;
#ifdef NETWARE
        case WTSUserConfigfNWMapRoot:
            dwReturnValue = UserConfigW.fHomeDirectoryMapRoot;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
#endif
        } // switch()
    } //if (rc == ERROR_SUCCESS)

    done:

    if ( pUserInfo ) {
        NetApiBufferFree( pUserInfo );
    }
    
    return( fSuccess );
}



/****************************************************************************
 *
 *  WTSQueryUserConfigA (ANSI)
 *
 *    Query information from the SAM for the specified user
 *
 * ENTRY:
 *
 *    see WTSQueryUserConfigW
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 * HISTORY:
 *    Created KLB 10-06-97
 *
 ****************************************************************************/

BOOL
WINAPI
WTSQueryUserConfigA(
                   IN LPSTR pServerName,
                   IN LPSTR pUserName,
                   IN WTS_CONFIG_CLASS WTSConfigClass,
                   OUT LPSTR * ppBuffer,
                   OUT DWORD * pBytesReturned
                   )
{
    LPWSTR lpBufferW    = NULL;
    BOOL   fSuccess;
    LONG   rc;
    LPWSTR pUserNameW   = NULL;
    LPWSTR pServerNameW = NULL;

    if (!ppBuffer || !pBytesReturned) {
        SetLastError (ERROR_INVALID_PARAMETER);
        fSuccess = FALSE;
        goto done;
    }

    fSuccess = _CopyStringA( pUserName, &pUserNameW, NULL );
    if ( fSuccess ) {
        fSuccess = _CopyStringA( pServerName, &pServerNameW, NULL );
    }
    if ( fSuccess ) {
        fSuccess = WTSQueryUserConfigW( pServerNameW,
                                        pUserNameW,
                                        WTSConfigClass,
                                        &lpBufferW,
                                        pBytesReturned );
        LocalFree( pUserNameW );
    }
    // Now, process the results.
    if ( fSuccess ) switch ( WTSConfigClass ) {
        case WTSUserConfigInitialProgram:
        case WTSUserConfigWorkingDirectory:
        case WTSUserConfigModemCallbackPhoneNumber:
#ifdef NETWARE
        case WTSUserConfigNWServerName:             // string returned/expected
#endif
        case WTSUserConfigTerminalServerProfilePath:     // string returned/expected
        case WTSUserConfigTerminalServerHomeDir:       // string returned/expected
        case WTSUserConfigTerminalServerHomeDirDrive:    // string returned/expected
            /*
             *  String Data - Convert to ANSI
             */
            fSuccess = _CopyStringWtoA( lpBufferW, ppBuffer, pBytesReturned );
            LocalFree( lpBufferW );
            break;

        default:
            /*
             *  Just a DWORD, point buffer at the one returned (caller is
             *  responsible for freeing, so this is cool).
             */
            *ppBuffer = (LPSTR)lpBufferW;
            break;
        } // switch()
    done:
    return( fSuccess );
}


/****************************************************************************
 *
 *  WTSSetUserConfigW (UNICODE)
 *
 *    Set information in the SAM for the specified user
 *
 * ENTRY:
 *    pServerName (input)
 *       Name of server to access (NULL for current machine).
 *    pUserName (input)
 *       User name to query
 *    WTSConfigClass (input)
 *       Specifies the type of information to change for the specified user
 *    pBuffer (input)
 *       Pointer to the data used to modify the specified user's information.
 *    DataLength (input)
 *       The length of the data provided.
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 * HISTORY:
 *    Created KLB 10-06-97
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSetUserConfigW(
                 IN LPWSTR pServerName,
                 IN LPWSTR pUserName,
                 IN WTS_CONFIG_CLASS WTSConfigClass,
                 IN LPWSTR pBuffer,
                 IN DWORD DataLength
                 )
{
    USERCONFIGW       UserConfigW;
    ULONG             ulReturnLength;
    LONG              rc;
    BOOL              fSuccess = FALSE;
    BOOL              fUserConfig = TRUE;          //TRUE - We use RegUserConfigSet
    //FALSE - Use NetUserSetInfo
    DWORD             dwfInheritInitialProgram;
    PDWORD            pdwValue = (DWORD *) pBuffer;
    PUSER_INFO_0      pUserInfo = NULL;
    DWORD             dwParam = 0;
    WCHAR             netServerName[DOMAIN_LENGTH + 3];


    if (!pBuffer || DataLength == 0) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto done; // exit with fSuccess = FALSE
    }
    /*
     *  First, we want to make sure the user actually exists on the specified
     *  machine.
     */


    rc = NetUserGetInfo( pServerName,     // server name (can be NULL)
                         pUserName,       // user name
                         0,               // level to query (0 = just name)
                         (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)

    if ( rc != NERR_Success ) {

        if (pServerName != NULL) {
            lstrcpyW(netServerName, L"\\\\");
            lstrcatW(netServerName, pServerName);
        
             rc = NetUserGetInfo( netServerName,     // server name (can be NULL)
                             pUserName,       // user name
                             3,               // level to query (3 = ust name)
                             (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)
        }
        else {
             rc = NetUserGetInfo( NULL,       // server name is NULL
                             pUserName,       // user name
                             3,               // level to query (3 = ust name)
                             (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)
        }

        if ( rc != NERR_Success ) {
            SetLastError( ERROR_NO_SUCH_USER );
            goto done; // exit with fSuccess = FALSE
        }
    }

    /*
     *  Query the user.  If the user config doesn't exist for the user, then
     *  we query the default values.
     */
    rc = RegUserConfigQuery( pServerName,               // server name
                              pUserName,                 // user name
                              &UserConfigW,              // returned user config
                              (ULONG)sizeof(UserConfigW),// user config length
                              &ulReturnLength );         // #bytes returned
    if ( rc != ERROR_SUCCESS ) {
        rc = RegDefaultUserConfigQuery( pServerName,               // server name
                                         &UserConfigW,              // returned user config
                                         (ULONG)sizeof(UserConfigW),// user config length
                                         &ulReturnLength );         // #bytes returned
    }
    if ( rc != ERROR_SUCCESS ) {
        goto done;
    }

    /*
     *  Now, we plug in the part we want to change.
     */
    switch ( WTSConfigClass ) {
    case WTSUserConfigInitialProgram:
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      INITIALPROGRAM_LENGTH,
                                                      UserConfigW.InitialProgram)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;

    case WTSUserConfigWorkingDirectory:
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      DIRECTORY_LENGTH,
                                                      UserConfigW.WorkDirectory)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;

    case WTSUserConfigfInheritInitialProgram:
        /*
         *  We have to point a DWORD pointer at the data, then assign it
         *  from the DWORD, as that's how it's defined (and this will
         *  ensure that it works okay on non-Intel architectures).
         */
        UserConfigW.fInheritInitialProgram = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigfAllowLogonTerminalServer:
        if (*pdwValue) {
            UserConfigW.fLogonDisabled = FALSE;
        } else {
          UserConfigW.fLogonDisabled = TRUE;
        }

        fSuccess = TRUE;

        break;

    case WTSUserConfigTimeoutSettingsConnections:
        UserConfigW.MaxConnectionTime = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigTimeoutSettingsDisconnections: //DWORD 
        UserConfigW.MaxDisconnectionTime = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigTimeoutSettingsIdle:          //DWORD 
        UserConfigW.MaxIdleTime = *pdwValue;
        fSuccess = TRUE;
        break;
    case WTSUserConfigfDeviceClientDrives:                  //DWORD 
        UserConfigW.fAutoClientDrives = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigfDeviceClientPrinters:   //DWORD 
        UserConfigW.fAutoClientLpts = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigfDeviceClientDefaultPrinter:   //DWORD 
        UserConfigW.fForceClientLptDef = *pdwValue;
        fSuccess = TRUE;
        break;


    case WTSUserConfigBrokenTimeoutSettings:         //DWORD 
        UserConfigW.fResetBroken= *pdwValue;
        fSuccess = TRUE;
        break;
    case WTSUserConfigReconnectSettings:
        UserConfigW.fReconnectSame = *pdwValue;
        fSuccess = TRUE;
        break;

        //Modem settings
    case WTSUserConfigModemCallbackSettings:         //DWORD 
        UserConfigW.Callback = *pdwValue;
        fSuccess = TRUE;
        break;
    case WTSUserConfigModemCallbackPhoneNumber:
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      sizeof(UserConfigW.CallbackNumber) - 1,
                                                      UserConfigW.CallbackNumber)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;


    case WTSUserConfigShadowingSettings:             //DWORD 
        UserConfigW.Shadow = *pdwValue;
        fSuccess = TRUE;
        break;
#ifdef NETWARE
    case WTSUserConfigNWServerName:             // WTS_USER_CONFIG_SET_NWSERVERW

        // Make sure the data structure is correct
        //

        if (DataLength < sizeof (WTS_USER_CONFIG_SET_NWSERVERW)) {
            fSuccess = FALSE;
            SetLastError(ERROR_INVALID_PARAMETER);
            goto done;
        }
        fSuccess = SetNWAuthenticationServer((PWTS_USER_CONFIG_SET_NWSERVERW)pBuffer,
                                             pServerName,
                                             pUserName,
                                             pBuffer,
                                             &UserConfigW);


        goto done;


        break;
#endif

    case WTSUserConfigTerminalServerProfilePath:     // string 
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      sizeof(UserConfigW.WFProfilePath) - 1,
                                                      UserConfigW.WFProfilePath)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;


    case WTSUserConfigTerminalServerHomeDir:       // string 
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      sizeof(UserConfigW.WFHomeDir) - 1,
                                                      UserConfigW.WFHomeDir)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;
    case WTSUserConfigTerminalServerHomeDirDrive:    // string 
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      sizeof(UserConfigW.WFHomeDirDrive) - 1,
                                                      UserConfigW.WFHomeDirDrive)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;

    case WTSUserConfigfTerminalServerRemoteHomeDir:                  // DWORD 0:LOCAL 1:REMOTE
        fSuccess = FALSE;
        SetLastError (ERROR_INVALID_PARAMETER);    // We don't set this parameter
        goto done;
        break;
#ifdef NETWARE
    case WTSUserConfigfNWMapRoot:
        UserConfigW.fHomeDirectoryMapRoot = *pdwValue;
        fSuccess = TRUE;
        break;
#endif
    
    default:
        fSuccess = FALSE;
        SetLastError (ERROR_INVALID_PARAMETER);
        goto done;

    } 

    if ( fSuccess ) {
        if (fUserConfig) {
            /*
             *  Only in here if we successfully changed the data in UserConfigW.
             *  So, we can now write it out to the SAM.
             */

            rc = RegUserConfigSet( pServerName,                // server name
                                    pUserName,                  // user name
                                    &UserConfigW,               // returned user config
                                    (ULONG)sizeof(UserConfigW));// user config length
        }
        fSuccess = (ERROR_SUCCESS == rc);
        if ( !fSuccess ) {
            SetLastError( rc );
        }
    }

    done:
    if ( pUserInfo ) {
        NetApiBufferFree( pUserInfo );
    }

    return(fSuccess);
}


/****************************************************************************
 *
 *  WTSSetUserConfigA (ANSI)
 *
 *    Set information in the SAM for the specified user
 *
 * ENTRY:
 *
 *    see WTSSetUserConfigW
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 * HISTORY:
 *    Created KLB 10-06-97
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSetUserConfigA(
                 IN LPSTR pServerName,
                 IN LPSTR pUserName,
                 IN WTS_CONFIG_CLASS WTSConfigClass,
                 IN LPSTR pBuffer,
                 IN DWORD DataLength
                 )
{
    BOOL   fSuccess = FALSE;
    BOOL   fFreepBufferW = TRUE;
    LPWSTR pUserNameW    = NULL;
    LPWSTR pServerNameW  = NULL;
    LPWSTR pBufferW      = NULL;
    DWORD  dwDataLength;


    if (!pBuffer || DataLength == 0) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto done; // exit with fSuccess = FALSE
    }

    /*
     *  We're going to call WTSSetUserConfigW() to do the actual work.  We need
     *  to convert all ANSI strings to Unicode before calling.  These are the
     *  user name, and the pBuffer data if it's the initial program or the
     *  working directory; if it's the flag for inherit initial program, it'll
     *  be a DWORD in either case, so no conversion is necessary.
     */
    fSuccess = _CopyStringA( pUserName, &pUserNameW, NULL );
    if ( fSuccess ) {
        fSuccess = _CopyStringA( pServerName, &pServerNameW, NULL );
    }
    if ( fSuccess ) switch ( WTSConfigClass ) {
        case WTSUserConfigInitialProgram:
        case WTSUserConfigWorkingDirectory:
        case WTSUserConfigModemCallbackPhoneNumber:

        case WTSUserConfigTerminalServerProfilePath:     // string returned/expected
        case WTSUserConfigTerminalServerHomeDir:       // string returned/expected
        case WTSUserConfigTerminalServerHomeDirDrive:    // string returned/expected
            /*
             *  String Data - Convert to Unicode (_CopyStringA() allocates
             *  pBufferW for us)
             */
            fSuccess = _CopyStringA( pBuffer, &pBufferW, &dwDataLength );
            break;
#ifdef NETWARE
        case WTSUserConfigNWServerName:             // string returned/expected
            {
                //Need to convert the data structure from ASCII to UNICODE
                PWTS_USER_CONFIG_SET_NWSERVERW pSetNWServerParamW = LocalAlloc(LPTR, sizeof(WTS_USER_CONFIG_SET_NWSERVERW));
                PWTS_USER_CONFIG_SET_NWSERVERA pSetNWServerParamA = (PWTS_USER_CONFIG_SET_NWSERVERA)pBuffer;
                DWORD                          dwLen = 0;
                if (pSetNWServerParamW == NULL) {
                    fSuccess = FALSE;
                    break;
                }
                pBufferW = pSetNWServerParamW;

                //----------------------------------------//
                // Allocate the buffer to hold the        //
                // required unicode string                //
                //----------------------------------------//
                dwLen = strlen(pSetNWServerParamA -> pNWServerName);
                if (fSuccess = _CopyStringA(pSetNWServerParamA -> pNWServerName, 
                                            &pSetNWServerParamW -> pNWServerName, 
                                            &dwLen)) {
                    dwLen = strlen(pSetNWServerParamA -> pNWDomainAdminName);
                    if (fSuccess = _CopyStringA(pSetNWServerParamA -> pNWDomainAdminName,
                                                &pSetNWServerParamW -> pNWDomainAdminName, 
                                                &dwLen)) {
                        dwLen = strlen(pSetNWServerParamA -> pNWDomainAdminPassword);
                        fSuccess = _CopyStringA(pSetNWServerParamA -> pNWDomainAdminPassword,
                                                &pSetNWServerParamW -> pNWDomainAdminPassword, 
                                                &dwLen);

                    }

                }

                //-----------------------------------------//
                // Call the UNICODE function               //
                //-----------------------------------------//

                if (fSuccess) {

                    fSuccess = WTSSetUserConfigW( pServerNameW,
                                                  pUserNameW,
                                                  WTSConfigClass,
                                                  pBufferW,
                                                  dwDataLength );
                }


                //----------------------------------------------//
                // Free the storage for the specific function   //
                //----------------------------------------------//

                if (pSetNWServerParamW -> pNWServerName) {
                    LocalFree( pSetNWServerParamW -> pNWServerName );
                }
                if (pSetNWServerParamW -> pNWDomainAdminName) {
                    LocalFree( pSetNWServerParamW -> pNWDomainAdminName );
                }

                if (pSetNWServerParamW -> pNWDomainAdminPassword) {
                    LocalFree( pSetNWServerParamW -> pNWDomainAdminPassword );
                }
                goto done;
                break;
            }
#endif

        default:
            /*
             *  Just a DWORD, point our wide buffer at the narrow buffer passed
             *  in to us and set the data length variable we'll pass down.
             *  NOTE: WE DON'T WANT TO FREE THE BUFFER, since we're re-using
             *  the buffer sent in and the caller expects to free it.  We'll
             *  use a BOOL to decide, rather than allocating an extra buffer
             *  here (performance, memory fragmentation, etc.).    KLB 10-08-97
             */
            pBufferW = (LPWSTR) pBuffer;
            dwDataLength = sizeof(DWORD);
            fFreepBufferW = FALSE;
            break;
        } // switch()

    /*
     *  Now, if fSuccess is TRUE, we've copied all the strings we need.  So, we
     *  can now call WTSSetUserConfigW().
     */
    if ( fSuccess ) {
        fSuccess = WTSSetUserConfigW( pServerNameW,
                                      pUserNameW,
                                      WTSConfigClass,
                                      pBufferW,
                                      dwDataLength );
    }
    done:
    if ( pUserNameW ) {
        LocalFree( pUserNameW );
    }
    if ( fFreepBufferW && pBufferW ) {
        LocalFree( pBufferW );
    }
    return(fSuccess);
}


#ifdef NETWARE
BOOL
SetNWAuthenticationServer(PWTS_USER_CONFIG_SET_NWSERVERW pInput,
                          LPWSTR pServerNameW,
                          LPWSTR pUserNameW,
                          PUSERCONFIGW pUserConfigW
                         )

{
    BOOL             bStatus = TRUE;
    PWKSTA_INFO_100  pWkstaInfo = NULL;
    NWLOGONADMIN     nwLogonAdmin;
    HANDLE           hServer;
    DWORD            dwStatus;
    //----------------------------------//
    // Get a Server handle
    //----------------------------------//
    hServer = RegOpenServer(pServerNameW);
    if (!hServer) {
        SetLastError(GetLastError());
        bStatus = FALSE;
        goto done;
    }

    //----------------------------------
    //find the domain name
    //------------------------------------
    dwStatus = NetWkstaGetInfo(
                              pServerNameW,  
                              100,
                              &pWkstaInfo
                              );
    if (dwStatus != ERROR_SUCCESS) {
        SetLastError(dwStatus);
        goto done;
    }
    //-----------------------------------------------------
    //Copy the parameter to the NWLOGONADMIN structure
    //-----------------------------------------------------
    bStatus = ValidateCopyUnicodeToUnicode(pInput -> pNWDomainAdminName,
                                           sizeof(nwLogonAdmin.Username)-1,
                                           nwLogonAdmin.Username);
    if (!bStatus) {
        goto done;
    }

    bStatus = ValidateCopyUnicodeToUnicode(pInput -> pNWDomainAdminPassword,
                                           sizeof(nwLogonAdmin.Password)-1,
                                           nwLogonAdmin.Password);
    if (!bStatus) {
        goto done;
    }

    bStatus = ValidateCopyUnicodeToUnicode(pWkstaInfo -> wki100_langroup,
                                           sizeof(nwLogonAdmin.Domain)-1,
                                           nwLogonAdmin.Domain);
    if (!bStatus) {
        goto done;
    }


    //------------------------------------------//
    // Set the admin                           //
    //-----------------------------------------//

    bStatus = _NWLogonSetAdmin(hServer,
                               &nwLogonAdmin,
                               sizeof(nwLogonAdmin));

    if (!bStatus) {
        SetLastError(GetLastError());
        goto done;
    }

    done:
    if (pWkstaInfo) {
        NetApiBufferFree(pWkstaInfo);
    }

    return bStatus;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wmi\tscfgwmi\winstation.h ===
/******************************************************************
   Copyright (C) 2000 Microsoft Corp.

   Winstation.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _Winstation_H_
#define _Winstation_H_
#include "resource.h"
#include "Terminal.h"
#include <winsta.h>
#include <regapi.h>
#include "smartptr.h"


#define BIT_FENABLETERMINAL                 0x0000000000000001
#define BIT_TERMINALNAME                    0x0000000000000002
#define BIT_TERMINALPROTOCOL                0x0000000000000004
#define BIT_TRANSPORT                       0x0000000000000008
#define BIT_COMMENT                         0x0000000000000010
#define BIT_WINDOWSAUTHENTICATION           0x0000000000000020
#define BIT_ENCRYPTIONLEVEL                 0x0000000000000040
#define BIT_CLIENTLOGONINFOPOLICY           0x0000000000000080
#define BIT_PROMPTFORPASSWORD               0x0000000000000100
#define BIT_USERNAME                        0x0000000000000200
#define BIT_DOMAIN                          0x0000000000000400
#define BIT_ACTIVESESSIONPOLICY             0x0000000000001000
#define BIT_DISCONNECTEDSESSIONPOLICY       0x0000000000002000
#define BIT_IDLESESSIONPOLICY               0x0000000000004000
#define BIT_ACTIVESESSIONLIMIT              0x0000000000008000
#define BIT_DISCONNECTEDSESSIONLIMIT        0x0000000000010000
#define BIT_IDLESESSIONLIMIT                0x0000000000020000
#define BIT_BROKENCONNECTIONPOLICY          0x0000000000040000
#define BIT_BROKENCONNECTIONACTION          0x0000000000080000
#define BIT_RECONNECTIONPOLICY              0x0000000000100000
#define BIT_INITIALPROGRAMPOLICY            0x0000000000200000
#define BIT_INITIALPROGRAMPATH              0x0000000000400000
#define BIT_STARTIN                         0x0000000000800000
#define BIT_CLIENTWALLPAPER                 0x0000000001000000
#define BIT_REMOTECONTROLPOLICY             0x0000000002000000
#define BIT_LEVELOFCONTROL                  0x0000000004000000
#define BIT_CONNECTIONPOLICY                0x0000000008000000
#define BIT_CONNECTCLIENTDRIVESATLOGON      0x0000000010000000
#define BIT_CONNECTPRINTERATLOGON           0x0000000020000000
#define BIT_DEFAULTTOCLIENTPRINTER          0x0000000040000000
#define BIT_WINDOWSPRINTERMAPPING           0x0000000080000000
#define BIT_LPTPORTMAPPING                  0x0000000100000000
#define BIT_COMPORTMAPPING                  0x0000000200000000
#define BIT_DRIVEMAPPING                    0x0000000400000000
#define BIT_AUDIOMAPPING                    0x0000000800000000
#define BIT_CLIPBOARDMAPPING                0x0000001000000000
#define BIT_NETWORKADAPTERID                0x0000002000000000
#define BIT_MAXIMUMCONNECTIONS              0x0000004000000000
#define BIT_ACCOUNTNAME                     0x0000008000000000
#define BIT_SID                             0x0000010000000000
#define BIT_PERMISSIONSALLOWED              0x0000020000000000
#define BIT_PERMISSIONSDENIED               0x0000040000000000
#define BIT_AUDITSUCCESS                    0x0000080000000000
#define BIT_AUDITFAIL                       0x0000100000000000
#define BIT_COLORDEPTHPOLICY                0x0000200000000000
#define BIT_COLORDEPTH                      0x0000400000000000
#define BIT_ALL_PROP                        0xffffffffffffffff

#define BIT_ALL_PROPS                       0xffffffff


#define TS_PATH TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations")


#define PROVIDER_NAME_Win32_WIN32_TERMINAL_Prov                         L"Win32_Terminal"
#define PROVIDER_NAME_Win32_WIN32_TSGENERALSETTING_Prov                 L"Win32_TSGeneralSetting"
#define PROVIDER_NAME_Win32_WIN32_TSLOGONSETTING_Prov                   L"Win32_TSLogonSetting"
#define PROVIDER_NAME_Win32_WIN32_TSSESSIONSETTING_Prov                 L"Win32_TSSessionSetting"
#define PROVIDER_NAME_Win32_WIN32_TSENVIRONMENTSETTING_Prov             L"Win32_TSEnvironmentSetting"
#define PROVIDER_NAME_Win32_WIN32_TSREMOTECONTROLSETTING_Prov           L"Win32_TSRemoteControlSetting"
#define PROVIDER_NAME_Win32_WIN32_TSCLIENTSETTING_Prov                  L"Win32_TSClientSetting"
#define PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERSETTING_Prov          L"Win32_TSNetworkAdapterSetting"
#define PROVIDER_NAME_Win32_WIN32_TSPERMISSIONSSETTING_Prov             L"Win32_TSPermissionsSetting"
#define PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERLISTSETTING_Prov      L"Win32_TSNetworkAdapterListSetting"
#define PROVIDER_NAME_Win32_WIN32_TSACCOUNT_Prov                        L"Win32_TSAccount"
#define PROVIDER_NAME_Win32_WIN32_TERMINALSERVICETOSETTING_Prov         L"Win32_TerminalServiceToSetting"
#define PROVIDER_NAME_Win32_WIN32_TERMINALTERMINALSETTING_Prov          L"Win32_TerminalTerminalSetting"
#define PROVIDER_NAME_Win32_WIN32_TSSESSIONDIRECTORYSETTING_Prov        L"Win32_TSSessionDirectorySetting"


#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

#define WINSTATIONNAME_LENGTH 32 
#define WINSTATIONCOMMENT_LENGTH 60
#define APPSERVERNAME_LENGTH 17
#define USERNAME_LENGTH 20
#define PASSWORD_LENTH 14


class CWin32_Terminal : public Provider
{
public:
    // Constructor/destructor
    //=======================

    CWin32_Terminal(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_Terminal();
    

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

    // Writing Functions
    //============================

    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
    virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );

    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);


private:  

    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szEnableTerminal[ 64 ] ;
    TCHAR m_szNewTerminalName[ 64 ] ;
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szEnable[ 64 ];
    TCHAR m_szRename[ 64 ];
    TCHAR m_szDelete[ 64 ];

} ;


class CWin32_TSGeneralSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSGeneralSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSGeneralSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
    

    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );
    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);


private:

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szTerminalProtocol[ 64 ];
    TCHAR m_szTransport[ 64 ];
    TCHAR m_szComment[ 64 ];
    TCHAR m_szWindowsAuthentication[ 64 ];
    TCHAR m_szEncryptionLevel[ 64 ];
    TCHAR m_szTerminalName[ 64 ];  
    TCHAR m_szSetEncryptionLevel[ 64 ];

} ;


class CWin32_TSLogonSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSLogonSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSLogonSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
    
    
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
    
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);


private:

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szClientLogonInfoPolicy[ 64 ];
    TCHAR m_szPromptForPassword[ 64 ];
    TCHAR m_szUserName[ 64 ];
    TCHAR m_szDomain[ 64 ];
    TCHAR m_szPassword[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szExplicitLogon[ 64 ];
    TCHAR m_szSetPromptForPassword[ 64 ];

} ;




//-------------------------------------------

class CWin32_TSSessionSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSSessionSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSSessionSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );

    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);

private: 

    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szTimeLimitPolicy[ 64 ];
    TCHAR m_szActiveSessionLimit[ 64 ];
    TCHAR m_szDisconnectedSessionLimit[ 64 ];
    TCHAR m_szIdleSessionLimit[ 64 ];
    TCHAR m_szBrokenConnectionPolicy[ 64 ];
    TCHAR m_szBrokenConnectionAction[ 64 ];
    TCHAR m_szReconnectionPolicy[ 64 ];
    TCHAR m_szSessionLimitType[ 64 ];
    TCHAR m_szValueLimit[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szTimeLimit[ 64 ];
    TCHAR m_szBrokenConnection[ 64 ];

} ;



//----------------------------------------------
class CWin32_TSEnvironmentSetting : public Provider
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSEnvironmentSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSEnvironmentSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );

    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);

private:  

    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szInitialProgramPolicy[ 64 ];
    TCHAR m_szInitialProgramPath[ 64 ];
    TCHAR m_szStartIn[ 64 ];
    TCHAR m_szClientWallPaper[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szInitialProgram[ 64 ];

} ;


//-----------------------------------------------------

class CWin32_TSRemoteControlSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSRemoteControlSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSRemoteControlSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
   
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);

private: 

    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);

    TCHAR m_szRemoteControlPolicy[ 64 ];
    TCHAR m_szLevelOfControl[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szRemoteControl[ 64 ];

} ;




//-----------------------------------------------------

class CWin32_TSClientSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSClientSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSClientSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query); 
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
 
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
   
    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS );

private: 

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szConnectionPolicy [ 64 ];
    TCHAR m_szConnectClientDrivesAtLogon[ 64 ];
    TCHAR m_szConnectPrinterAtLogon[ 64 ];
    TCHAR m_szDefaultToClientPrinter[ 64 ];
    TCHAR m_szWindowsPrinterMapping[ 64 ];
    TCHAR m_szLPTPortMapping[ 64 ];
    TCHAR m_szCOMPortMapping[ 64 ];
    TCHAR m_szDriveMapping[ 64 ];
    TCHAR m_szAudioMapping[ 64 ];
    TCHAR m_szClipboardMapping[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szPropertyName[ 64 ];
    TCHAR m_szValue[ 64 ];
    TCHAR m_szConnectionSettings[ 64 ];
    TCHAR m_szSetClientProperty[ 64 ];
    TCHAR m_szColorDepth[ 64 ];
    TCHAR m_szColorDepthPolicy[ 64 ];
    TCHAR m_szSetColorDepth[ 64 ];    
    TCHAR m_szSetColorDepthPolicy[ 64 ];

} ;



//-----------------------------------------------------

class CWin32_TSNetworkAdapterSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSNetworkAdapterSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSNetworkAdapterSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
    
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
   
    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);
 
private:  

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szNetworkAdapterName[ 64 ];
    TCHAR m_szNetworkAdapterID[ 64 ];
    TCHAR m_szMaximumConnections[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szSelectAllNetworkAdapters[ 64 ];
    TCHAR m_szSelectNetworkAdapterID[ 64 ];

} ;

//-------------------------------

class CWin32_TSPermissionsSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSPermissionsSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSPermissionsSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
    
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);
   

private:  

    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    const WCHAR* m_pszPermissionPreSet;
  
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szAccountName[ 64 ];
    TCHAR m_szPermissionPreSet[ 64 ];
    TCHAR m_szPermissionMask[ 64 ];
    TCHAR m_szSID[ 64 ];  
    TCHAR m_szAddAccount[ 64 ];
    TCHAR m_szRestoreDefaults[ 64 ];
} ;

//=-------------------

class CWin32_TSNetworkAdapterListSetting : public Provider
{
private:
    /*
    TCHAR m_szDeviceID[ 64 ];
    TCHAR m_szIndex[ 64 ];
    TCHAR m_szNetworkAdapterID[ 64 ];
    TCHAR m_szDescription[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
*/
    
    TCHAR m_szTransport[ 64 ];
    TCHAR m_szNetworkAdapterID[ 64 ];
    TCHAR m_szDescription[ 64 ];
    TCHAR m_szTerminalProtocol[ 64 ];

protected:

    

public:
    CWin32_TSNetworkAdapterListSetting (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	~CWin32_TSNetworkAdapterListSetting ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query );

 //   HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PTCHAR pdName, PTCHAR wdName, PTCHAR pGuid, PTCHAR DisplayName);

 //   virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

};	


//=---------------------

class CWin32_TSAccount : public Provider
{

protected:

    

public:
    CWin32_TSAccount (LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
	~CWin32_TSAccount ();

	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

// Writing Functions
    //============================

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );
    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, 
                                PWS pWS, PUSERPERMLIST pUserList, PUSERPERMLIST pUserAuditList);

private:
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    POLICY_TS_MACHINE m_gpPolicy;
    TCHAR m_szPermissionPreSet[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szAccountName[ 64 ];
    TCHAR m_szPermissionMask[ 64 ];
    TCHAR m_szPermissionsAllowed[ 64 ];
    TCHAR m_szPermissionsDenied[ 64 ];
    TCHAR m_szAuditSuccess[ 64 ];
    TCHAR m_szAuditFail[ 64 ]; 
    TCHAR m_szAllow[ 64 ];
    TCHAR m_szSuccess[ 64 ];
    TCHAR m_szSID[ 64 ];  
    TCHAR m_szDelete[ 64 ];
    TCHAR m_szModifyPermissions[ 64 ];
    TCHAR m_szModifyAuditPermissions[ 64 ];    

};	


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wtsapi\server.c ===
/*******************************************************************************
* server.c
*
* Published Terminal Server APIs
*
* - server routines
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif
#include <utildll.h>
#include <stdio.h>
#include <stdarg.h>

#include <wtsapi32.h>

/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSEnumerateServersW( LPWSTR, DWORD, DWORD, PWTS_SERVER_INFOW *, DWORD * );
BOOL WINAPI WTSEnumerateServersA( LPSTR, DWORD, DWORD, PWTS_SERVER_INFOA *, DWORD * );
HANDLE WINAPI WTSOpenServerW( LPWSTR );
HANDLE WINAPI WTSOpenServerA( LPSTR );
VOID   WINAPI WTSCloseServer( HANDLE );


/*=============================================================================
==   Procedures used
=============================================================================*/

VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );


/****************************************************************************
 *
 *  WTSEnumerateServersW (UNICODE)
 *
 *    Returns a list of Terminal servers within the specified NT domain
 *
 * ENTRY:
 *    pDomainName (input)
 *       Pointer to NT domain name (or NULL for current domain)
 *    Reserved (input)
 *       Must be zero
 *    Version (input)
 *       Version of the enumeration request (must be 1)
 *    ppServerInfo (output)
 *       Points to the address of a variable to receive the enumeration results,
 *       which are returned as an array of WTS_SERVER_INFO structures.  The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pCount (output)
 *       Points to the address of a variable to receive the number of
 *       WTS_SERVER_INFO structures returned
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateServersW(
                    IN LPWSTR pDomainName,
                    IN DWORD Reserved,
                    IN DWORD Version,
                    OUT PWTS_SERVER_INFOW * ppServerInfo,
                    OUT DWORD * pCount
                    )
{
    LPWSTR pServerList;
    LPWSTR pData;
    PBYTE pNameData;
    ULONG Length;
    ULONG NameCount;            // number of names
    ULONG NameLength;           // number of bytes of name data
    PWTS_SERVER_INFOW pServerW;

    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    if ( !ppServerInfo || !pCount) {
        SetLastError( ERROR_INVALID_USER_BUFFER);
        goto badparam;
    }

    /*
     *  Enumerate servers and check for an error
     */
    pServerList = EnumerateMultiUserServers( pDomainName );
    
    if ( pServerList == NULL ) {
        SetLastError(ERROR_INVALID_DOMAINNAME);
        goto badenum;
    }

    /*
     *  Count the number of Terminal servers
     */
    NameCount = 0;
    NameLength = 0;
    pData = pServerList;
    while ( *pData ) {
        Length = (wcslen(pData) + 1) * sizeof(WCHAR); // number of bytes
        NameCount++;
        NameLength += Length;
        (PBYTE)pData += Length;
    }

    /*
     *  Allocate user buffer
     */
    pServerW = LocalAlloc( LPTR, (NameCount * sizeof(WTS_SERVER_INFOW)) + NameLength );
    if ( pServerW == NULL )
        goto badalloc;

    /*
     *  Update user parameters
     */
    *ppServerInfo = pServerW;
    *pCount = NameCount;

    /*
     *  Copy data to new buffer
     */
    pData = pServerList;
    pNameData = (PBYTE)pServerW + (NameCount * sizeof(WTS_SERVER_INFOW));
    while ( *pData ) {

        Length = (wcslen(pData) + 1) * sizeof(WCHAR); // number of bytes

        memcpy( pNameData, pData, Length );
        pServerW->pServerName = (LPWSTR) pNameData;

        pServerW++;
        pNameData += Length;
        (PBYTE)pData += Length;
    }

    /*
     *  Free original server list buffer
     */
    LocalFree( pServerList );
    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badalloc:

    badenum:
    badparam:
    if (ppServerInfo) *ppServerInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}



/****************************************************************************
 *
 *  WTSEnumerateServersA (ANSI stub)
 *
 *    Returns a list of Terminal servers within the specified NT domain
 *
 * ENTRY:
 *
 *    see WTSEnumerateServersW
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateServersA(
                    IN LPSTR pDomainName,
                    IN DWORD Reserved,
                    IN DWORD Version,
                    OUT PWTS_SERVER_INFOA * ppServerInfo,
                    OUT DWORD * pCount
                    )
{
    LPWSTR pDomainNameW = NULL;
    ULONG DomainNameWLength;
    PWTS_SERVER_INFOW pServerW;
    PWTS_SERVER_INFOA pServerA;
    PBYTE pNameData;
    ULONG Length;
    ULONG NameLength;           // number of bytes of name data
    ULONG NameCount;
    ULONG i;

    if ( !ppServerInfo || !pCount) {
        SetLastError( ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }


    /*
     *  Convert ansi domain name to unicode
     */
    if ( pDomainName ) {
        DomainNameWLength = (strlen(pDomainName) + 1) * sizeof(WCHAR);
        if ( (pDomainNameW = LocalAlloc( LPTR, DomainNameWLength )) == NULL )
            goto badalloc1;
        AnsiToUnicode( pDomainNameW, DomainNameWLength, pDomainName );
    }

    /*
     *  Enumerate servers (UNICODE)
     */
    if ( !WTSEnumerateServersW( pDomainNameW,
                                Reserved,
                                Version,
                                &pServerW,
                                &NameCount ) ) {
        goto badenum;
    }

    /*
     *  Calculate the length of the name data
     */
    for ( i=0, NameLength=0; i < NameCount; i++ ) {
        NameLength += (wcslen(pServerW[i].pServerName) + 1);
    }

    /*
     *  Allocate user buffer
     */
    pServerA = LocalAlloc( LPTR, (NameCount * sizeof(WTS_SERVER_INFOA)) + NameLength );
    if ( pServerA == NULL )
        goto badalloc2;

    /*
     *  Convert unicode server list to ansi
     */
    pNameData = (PBYTE)pServerA + (NameCount * sizeof(WTS_SERVER_INFOA));
    for ( i=0; i < NameCount; i++ ) {
        Length = wcslen(pServerW[i].pServerName) + 1;

        pServerA[i].pServerName = pNameData;
        UnicodeToAnsi( pNameData, NameLength, pServerW[i].pServerName );

        NameLength -= Length;
        pNameData += Length;
    }

    /*
     *  Free unicode server list buffer
     */
    LocalFree( pServerW );

    /*
     *  Free domain name buffer
     */
    if ( pDomainNameW )
        LocalFree( pDomainNameW );

    /*
     *  Update user parameters
     */
    *ppServerInfo = pServerA;
    *pCount = NameCount;

    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/


    badalloc2:
    LocalFree( pServerW );

    badenum:
    if ( pDomainNameW )
        LocalFree( pDomainNameW );

    badalloc1:
    *ppServerInfo = NULL;
    *pCount = 0;

    return( FALSE );
}


/****************************************************************************
 *
 *  WTSOpenServerW (UNICODE)
 *
 *    Opens a handle to the specified server
 *
 *    NOTE: WTS_SERVER_CURRENT can be used as a handle to the current server
 *
 * ENTRY:
 *    pServerName (input)
 *       Pointer to Terminal server name
 *
 * EXIT:
 *
 *    Handle to specified server (NULL on error)
 *
 *
 ****************************************************************************/

HANDLE
WINAPI
WTSOpenServerW(
              IN LPWSTR pServerName
              )
{
    return( WinStationOpenServerW( pServerName ) );
}


/****************************************************************************
 *
 *  WTSOpenServerA (ANSI)
 *
 *    Opens a handle to the specified server
 *
 *    NOTE: WTS_SERVER_CURRENT can be used as a handle to the current server
 *
 * ENTRY:
 *    pServerName (input)
 *       Pointer to Terminal server name
 *
 * EXIT:
 *
 *    Handle to specified server
 *
 *
 ****************************************************************************/

HANDLE
WINAPI
WTSOpenServerA(
              IN LPSTR pServerName
              )
{
    return( WinStationOpenServerA( pServerName ) );
}


/****************************************************************************
 *
 *  WTSCloseServer
 *
 *    Close server handle
 *
 * ENTRY:
 *    hServer (input)
 *       handle to server
 *
 * EXIT:
 *    nothing
 *
 ****************************************************************************/

VOID
WINAPI
WTSCloseServer(
              IN HANDLE hServer
              )
{
    (void) WinStationCloseServer( hServer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wtsapi\session.c ===
/*******************************************************************************
* session.c
*
* Published Terminal Server APIs
*
* - session routines
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif
#include <utildll.h>
#include <winsock.h>    // for AF_INET, etc.

#include <stdio.h>
#include <stdarg.h>

#include <wtsapi32.h>


/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSEnumerateSessionsW( HANDLE, DWORD, DWORD, PWTS_SESSION_INFOW *,
                                   DWORD * );
BOOL WINAPI WTSEnumerateSessionsA( HANDLE, DWORD, DWORD, PWTS_SESSION_INFOA *,
                                   DWORD * );
BOOL WINAPI WTSQuerySessionInformationW( HANDLE, DWORD, WTS_INFO_CLASS,
                                         LPWSTR *, DWORD * );
BOOL WINAPI WTSQuerySessionInformationA( HANDLE, DWORD, WTS_INFO_CLASS,
                                         LPSTR *, DWORD * );
BOOL WINAPI WTSSendMessageW( HANDLE, DWORD, LPWSTR, DWORD, LPWSTR, DWORD,
                             DWORD, DWORD, DWORD *, BOOL );
BOOL WINAPI WTSSendMessageA( HANDLE, DWORD, LPSTR, DWORD, LPSTR, DWORD,
                             DWORD, DWORD, DWORD *, BOOL );
BOOL WINAPI WTSDisconnectSession( HANDLE, DWORD, BOOL );
BOOL WINAPI WTSLogoffSession( HANDLE, DWORD, BOOL );


/*=============================================================================
==   Internal procedures defined
=============================================================================*/

BOOL _CopyData( PVOID, ULONG, LPWSTR *, DWORD * );
BOOL _CopyStringW( LPWSTR, LPWSTR *, DWORD * );
BOOL _CopyStringA( LPSTR, LPWSTR *, DWORD * );
BOOL _CopyStringWtoA( LPWSTR, LPSTR *, DWORD * );
BOOL ValidateCopyAnsiToUnicode(LPSTR, DWORD, LPWSTR);
BOOL ValidateCopyUnicodeToUnicode(LPWSTR, DWORD, LPWSTR);


/*=============================================================================
==   Procedures used
=============================================================================*/

VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );


/*=============================================================================
==   Local Data
=============================================================================*/

/*
 *  Table to map WINSTATIONSTATECLASS to WTS_CONNECTSTATE_CLASS
 */
WTS_CONNECTSTATE_CLASS WTSStateMapping[] =
{
    WTSActive,
    WTSConnected,
    WTSConnectQuery,
    WTSShadow,
    WTSDisconnected,
    WTSIdle,
    WTSListen,
    WTSReset,
    WTSDown,
    WTSInit,
};

/****************************************************************************
 *
 *  WTSEnumerateSessionsW (UNICODE)
 *
 *    Returns a list of Terminal Server Sessions on the specified server
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    Reserved (input)
 *       Must be zero
 *    Version (input)
 *       Version of the enumeration request (must be 1)
 *    ppSessionInfo (output)
 *       Points to the address of a variable to receive the enumeration results,
 *       which are returned as an array of WTS_SESSION_INFO structures.  The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pCount (output)
 *       Points to the address of a variable to receive the number of
 *       WTS_SESSION_INFO structures returned
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateSessionsW(
                     IN HANDLE hServer,
                     IN DWORD Reserved,
                     IN DWORD Version,
                     OUT PWTS_SESSION_INFOW * ppSessionInfo,
                     OUT DWORD * pCount
                     )
{
    PWTS_SESSION_INFOW pSessionW;
    PLOGONIDW pLogonIds;
    PLOGONIDW pLogonId;
    ULONG SessionCount;
    ULONG NameLength;
    PBYTE pNameData;
    ULONG Length;
    ULONG i;

    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    if (!ppSessionInfo || !pCount) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        goto badparam;
    }

    /*
     *  Enumerate Sessions and check for an error
     */
    if ( !WinStationEnumerateW( hServer,
                                &pLogonIds,
                                &SessionCount ) ) {
        goto badenum;
    }

    /*
     *  Total up the size of the session data
     */
    NameLength = 0;
    for ( i=0; i < SessionCount; i++ ) {
        NameLength += ((wcslen(pLogonIds[i].WinStationName) + 1) * sizeof(WCHAR)); // number of bytes
    }

    /*
     *  Allocate user buffer
     */
    pSessionW = LocalAlloc( LPTR, (SessionCount * sizeof(WTS_SESSION_INFOW)) + NameLength );
    if ( pSessionW == NULL )
        goto badalloc;

    /*
     *  Update user parameters
     */
    *ppSessionInfo = pSessionW;
    *pCount = SessionCount;

    /*
     *  Copy data to new buffer
     */
    pNameData = (PBYTE)pSessionW + (SessionCount * sizeof(WTS_SESSION_INFOW));
    for ( i=0; i < SessionCount; i++ ) {

        pLogonId = &pLogonIds[i];

        Length = (wcslen(pLogonId->WinStationName) + 1) * sizeof(WCHAR); // number of bytes

        memcpy( pNameData, pLogonId->WinStationName, Length );
        pSessionW->pWinStationName = (LPWSTR) pNameData;
        pSessionW->SessionId = pLogonId->LogonId;
        pSessionW->State = WTSStateMapping[ pLogonId->State ];

        pSessionW++;
        pNameData += Length;
    }

    /*
     *  Free original Session list buffer
     */
    WinStationFreeMemory( pLogonIds );

    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badalloc:
    WinStationFreeMemory( pLogonIds );

    badenum:
    badparam:
    if (ppSessionInfo) *ppSessionInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}


/****************************************************************************
 *
 *  WTSEnumerateSessionsA (ANSI stub)
 *
 *    Returns a list of Terminal Server Sessions on the specified server
 *
 * ENTRY:
 *
 *    see WTSEnumerateSessionsW
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateSessionsA(
                     IN HANDLE hServer,
                     IN DWORD Reserved,
                     IN DWORD Version,
                     OUT PWTS_SESSION_INFOA * ppSessionInfo,
                     OUT DWORD * pCount
                     )
{
    PWTS_SESSION_INFOA pSessionA;
    PLOGONIDA pLogonIds;
    PLOGONIDA pLogonId;
    ULONG SessionCount;
    ULONG NameLength;
    PBYTE pNameData;
    ULONG Length;
    ULONG i;

    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }


    if (!ppSessionInfo || !pCount) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        goto badparam;
    }
    /*
     *  Enumerate Sessions and check for an error
     */
    if ( !WinStationEnumerateA( hServer,
                                &pLogonIds,
                                &SessionCount ) ) {
        goto badenum;
    }

    /*
     *  Total up the size of the session data
     */
    NameLength = 0;
    for ( i=0; i < SessionCount; i++ ) {
        NameLength += (strlen(pLogonIds[i].WinStationName) + 1); // number of bytes
    }

    /*
     *  Allocate user buffer
     */
    pSessionA = LocalAlloc( LPTR, (SessionCount * sizeof(WTS_SESSION_INFOA)) + NameLength );
    if ( pSessionA == NULL )
        goto badalloc;

    /*
     *  Update user parameters
     */
    *ppSessionInfo = pSessionA;
    *pCount = SessionCount;

    /*
     *  Copy data to new buffer
     */
    pNameData = (PBYTE)pSessionA + (SessionCount * sizeof(WTS_SESSION_INFOA));
    for ( i=0; i < SessionCount; i++ ) {

        pLogonId = &pLogonIds[i];

        Length = strlen(pLogonId->WinStationName) + 1; // number of bytes

        memcpy( pNameData, pLogonId->WinStationName, Length );
        pSessionA->pWinStationName = (LPSTR) pNameData;
        pSessionA->SessionId = pLogonId->LogonId;
        pSessionA->State = WTSStateMapping[ pLogonId->State ];

        pSessionA++;
        pNameData += Length;
    }

    /*
     *  Free original Session list buffer
     */
    WinStationFreeMemory( pLogonIds );

    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badalloc:
    WinStationFreeMemory( pLogonIds );

    badenum:
    badparam:
    if (ppSessionInfo) *ppSessionInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}


/****************************************************************************
 *
 *  WTSQuerySessionInformationW (UNICODE)
 *
 *    Query information for the specified session and server
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    WTSInfoClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       session
 *    ppBuffer (output)
 *       Points to the address of a variable to receive information about
 *       the specified session.  The format and contents of the data
 *       depend on the specified information class being queried. The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSQuerySessionInformationW(
                           IN HANDLE hServer,
                           IN DWORD SessionId,
                           IN WTS_INFO_CLASS WTSInfoClass,
                           OUT LPWSTR * ppBuffer,
                           OUT DWORD * pBytesReturned
                           )
{
    PWINSTATIONCONFIGW pWSConfig = NULL;
    PWINSTATIONINFORMATIONW pWSInfo = NULL;
    PWINSTATIONCLIENT pWSClient = NULL;
    WTS_CLIENT_DISPLAY ClientDisplay;
    WTS_CLIENT_ADDRESS ClientAddress;
    ULONG WSModulesLength;
    ULONG BytesReturned;
    ULONG i;
    BYTE Version;
    BOOL fSuccess = FALSE;

    if (!ppBuffer || !pBytesReturned) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    /*
     *  Query WinStation Data
     */

    switch ( WTSInfoClass ) {

    case WTSInitialProgram :
    case WTSApplicationName :
    case WTSWorkingDirectory :
    case WTSOEMId :

        pWSConfig = LocalAlloc( LPTR, sizeof(WINSTATIONCONFIGW) );

        if ( pWSConfig == NULL )
            goto no_memory;

        if ( !WinStationQueryInformationW( hServer,
                                           SessionId,
                                           WinStationConfiguration,
                                           pWSConfig,
                                           sizeof(WINSTATIONCONFIGW),
                                           &BytesReturned ) ) {
            goto badquery;
        }
        break;
    }

    switch ( WTSInfoClass ) {

    case WTSSessionId :

        pWSInfo = LocalAlloc( LPTR, sizeof(WINSTATIONINFORMATIONW) );

        if ( pWSInfo == NULL )
            goto no_memory;

        //
        // no need to make a rpc call here
        //

        if (WTS_CURRENT_SESSION == SessionId)
        {
            pWSInfo->LogonId = NtCurrentPeb()->SessionId;
        }
        else
        {
            //
            // why would anybody want to know non current sessionid ?
            //
            pWSInfo->LogonId = SessionId;
        }

        BytesReturned = sizeof(pWSInfo->LogonId);
        break;


    case WTSUserName :
    case WTSWinStationName :
    case WTSDomainName :
    case WTSConnectState :

        pWSInfo = LocalAlloc( LPTR, sizeof(WINSTATIONINFORMATIONW) );

        if ( pWSInfo == NULL )
            goto no_memory;

        if ( !WinStationQueryInformationW( hServer,
                                           SessionId,
                                           WinStationInformation,
                                           pWSInfo,
                                           sizeof(WINSTATIONINFORMATIONW),
                                           &BytesReturned ) ) {
            goto badquery;
        }
        break;
    }

    switch ( WTSInfoClass ) {

    case WTSClientBuildNumber :
    case WTSClientName :
    case WTSClientDirectory :
    case WTSClientProductId :
    case WTSClientHardwareId :
    case WTSClientAddress :
    case WTSClientDisplay :
    case WTSClientProtocolType :

        pWSClient = LocalAlloc( LPTR, sizeof(WINSTATIONCLIENT) );

        if ( pWSClient == NULL )
            goto no_memory;

        if ( !WinStationQueryInformationW( hServer,
                                           SessionId,
                                           WinStationClient,
                                           pWSClient,
                                           sizeof(WINSTATIONCLIENT),
                                           &BytesReturned ) ) {
            goto badquery;
        }
        break;
    }

    /*
     *  Copy the data to the users buffer
     */
    switch ( WTSInfoClass ) {

    case WTSInitialProgram :

        if ( SessionId == 0 )
            return( FALSE );

        fSuccess = _CopyStringW( pWSConfig->User.InitialProgram,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSApplicationName :

        if ( SessionId == 0 )
            return( FALSE );

        fSuccess = _CopyStringW( pWSConfig->User.PublishedName,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSWorkingDirectory :

        fSuccess = _CopyStringW( pWSConfig->User.WorkDirectory,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSOEMId :

        fSuccess = _CopyStringA( pWSConfig->OEMId,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSSessionId :

        fSuccess = _CopyData( &(pWSInfo->LogonId),
                              sizeof(pWSInfo->LogonId),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSConnectState :

        fSuccess = _CopyData( &(pWSInfo->ConnectState),
                              sizeof(pWSInfo->ConnectState),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSWinStationName :

        fSuccess = _CopyStringW( pWSInfo->WinStationName,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSUserName :

        fSuccess = _CopyStringW( pWSInfo->UserName,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSDomainName :

        fSuccess = _CopyStringW( pWSInfo->Domain,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSClientBuildNumber :

        fSuccess = _CopyData( &(pWSClient->ClientBuildNumber),
                              sizeof(pWSClient->ClientBuildNumber),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSClientName :

        fSuccess = _CopyStringW( pWSClient->ClientName,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSClientDirectory :

        fSuccess = _CopyStringW( pWSClient->ClientDirectory,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSClientProductId :

        fSuccess = _CopyData( &(pWSClient->ClientProductId),
                              sizeof(pWSClient->ClientProductId),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSClientHardwareId :

        fSuccess = _CopyData( &(pWSClient->ClientHardwareId),
                              sizeof(pWSClient->ClientHardwareId),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSClientAddress :

        ClientAddress.AddressFamily = pWSClient->ClientAddressFamily;
        switch ( ClientAddress.AddressFamily ) {

        case AF_UNSPEC :
            // force null-termination
            if ( pWSClient->ClientAddress[CLIENTADDRESS_LENGTH+1] != L'\0' )
                pWSClient->ClientAddress[CLIENTADDRESS_LENGTH+1] = L'\0';
            // We do this here instead of in the ANSI version of this
            // function because we've only got 20 bytes to work with
            // (unicode addresses over 10 chars would be truncated).
            // The return is the same for both A and W versions.
            WideCharToMultiByte( CP_ACP, 0L, pWSClient->ClientAddress,
                                 -1, ClientAddress.Address, 20, NULL, NULL );
            break;

        case AF_INET :
            // convert string to binary format
            swscanf( pWSClient->ClientAddress, L"%u.%u.%u.%u",
                     &ClientAddress.Address[2],
                     &ClientAddress.Address[3],
                     &ClientAddress.Address[4],
                     &ClientAddress.Address[5] );
            break;

        case AF_IPX :
            {
                PWCHAR pBuf = pWSClient->ClientAddress;

                _wcsupr( pWSClient->ClientAddress );
                // convert string to binary format
                for ( i=0 ; i<10 ; i++ ) {
                    if ( *pBuf != L':' ) {
                        swscanf( pBuf, L"%2X", &ClientAddress.Address[i] );
                        pBuf += 2;
                    } else {
                        // skip the colon
                        pBuf++;
                        i--;
                        continue;
                    }
                }
            }
            break;
        }

        fSuccess = _CopyData( &ClientAddress,
                              sizeof(ClientAddress),
                              ppBuffer,
                              pBytesReturned );

        break;

    case WTSClientDisplay :

        ClientDisplay.HorizontalResolution = pWSClient->HRes;
        ClientDisplay.VerticalResolution = pWSClient->VRes;
        ClientDisplay.ColorDepth = pWSClient->ColorDepth;

        fSuccess = _CopyData( &ClientDisplay,
                              sizeof(ClientDisplay),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSClientProtocolType :

        fSuccess = _CopyData( &(pWSClient->ProtocolType),
                              sizeof(pWSClient->ProtocolType),
                              ppBuffer,
                              pBytesReturned );
        break;

    }

    if ( pWSConfig )
        LocalFree( pWSConfig );

    if ( pWSInfo )
        LocalFree( pWSInfo );

    if ( pWSClient )
        LocalFree( pWSClient );

    return( fSuccess );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badquery:

    return( FALSE );

    no_memory:

    SetLastError( ERROR_NOT_ENOUGH_MEMORY );

    return( FALSE );
}


/****************************************************************************
 *
 *  WTSQuerySessionInformationA (ANSI)
 *
 *    Query information for the specified session and server
 *
 * ENTRY:
 *
 *    see WTSQuerySessionInformationW
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSQuerySessionInformationA(
                           IN HANDLE hServer,
                           IN DWORD SessionId,
                           IN WTS_INFO_CLASS WTSInfoClass,
                           OUT LPSTR * ppBuffer,
                           OUT DWORD * pBytesReturned
                           )
{
    LPWSTR pBufferW;
    DWORD BytesReturned;
    DWORD DataLength;


    if (!ppBuffer || !pBytesReturned) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    /*
     *  Query the data
     */
    if ( !WTSQuerySessionInformationW( hServer,
                                       SessionId,
                                       WTSInfoClass,
                                       &pBufferW,
                                       &BytesReturned ) ) {
        return( FALSE );
    }

    switch ( WTSInfoClass ) {

    case WTSSessionId :
    case WTSConnectState :
    case WTSClientBuildNumber :
    case WTSClientProductId :
    case WTSClientHardwareId :
    case WTSClientAddress :
    case WTSClientDisplay :
    case WTSClientProtocolType:

        /*
         *  Non-String Data - just return
         */
        *ppBuffer = (LPSTR) pBufferW;
        if ( pBytesReturned ) {
            *pBytesReturned = BytesReturned;
        }
        break;

    case WTSInitialProgram :
    case WTSWorkingDirectory :
    case WTSOEMId :
    case WTSWinStationName :
    case WTSUserName :
    case WTSDomainName :
    case WTSClientName :
    case WTSClientDirectory :
    case WTSApplicationName :

        /*
         *  String Data - Convert to ANSI
         */
        DataLength = wcslen(pBufferW) + 1;
        *ppBuffer = LocalAlloc( LPTR, DataLength );
        if ( *ppBuffer == NULL ) {
            LocalFree( pBufferW );
            return( FALSE );
        }

        UnicodeToAnsi( *ppBuffer, DataLength, pBufferW );
        if ( pBytesReturned ) {
            *pBytesReturned = DataLength;
        }

        LocalFree( pBufferW );
        break;



    }

    return( TRUE );
}


/****************************************************************************
 *
 *  WTSSetSessionInformationW (UNICODE)
 *
 *  NOTE: THIS IS CURRENTLY JUST A STUB SO WE DON'T BREAK EXISTING PROGRAMS.
 *
 *    Modify information for the specified session and server
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    WTSInfoClass (input)
 *       Specifies the type of information to modify for the specified
 *       session
 *    pData (input)
 *       Pointer to the data used to modify the specified session information.
 *    DataLength (output)
 *       The length of the data provided.
 *
 * EXIT:
 *
 *    TRUE  -- The modify operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSetSessionInformationW(
                         IN HANDLE hServer,
                         IN DWORD SessionId,
                         IN WTS_INFO_CLASS WTSInfoClass,
                         IN PVOID pData,
                         IN DWORD DataLength
                         )
{
    return( TRUE );
}


/****************************************************************************
 *
 *  WTSSetSessionInformationA (ANSI)
 *
 *  NOTE: THIS IS CURRENTLY JUST A STUB SO WE DON'T BREAK EXISTING PROGRAMS.
 *
 *    Modify information for the specified session and server
 *
 * ENTRY:
 *
 *    see WTSSetSessionInformationW
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSetSessionInformationA(
                         IN HANDLE hServer,
                         IN DWORD SessionId,
                         IN WTS_INFO_CLASS WTSInfoClass,
                         IN PVOID pData,
                         IN DWORD DataLength
                         )
{
    return( TRUE );
}


/****************************************************************************
 *
 *  WTSSendMessageW (UNICODE)
 *
 *    Send a message box to the specified session
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    pTitle (input)
 *       Pointer to title for message box to display.
 *    TitleLength (input)
 *       Length of title to display in bytes.
 *    pMessage (input)
 *       Pointer to message to display.
 *    MessageLength (input)
 *       Length of message in bytes to display at the specified window station.
 *    Style (input)
 *       Standard Windows MessageBox() style parameter.
 *    Timeout (input)
 *       Response timeout in seconds.  If message is not responded to in
 *       Timeout seconds then a response code of IDTIMEOUT (cwin.h) is
 *       returned to signify the message timed out.
 *    pResponse (output)
 *       Address to return selected response. Valid only when bWait is set.
 *    bWait (input)
 *       Wait for the response
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSendMessageW(
               IN HANDLE hServer,
               IN DWORD SessionId,
               IN LPWSTR pTitle,
               IN DWORD TitleLength,
               IN LPWSTR pMessage,
               IN DWORD MessageLength,
               IN DWORD Style,
               IN DWORD Timeout,
               OUT DWORD * pResponse,
               IN BOOL bWait
               )
{
    if (!pTitle ||
        !pMessage ||
        !pResponse
       ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    return( WinStationSendMessageW( hServer,
                                    SessionId,
                                    pTitle,
                                    TitleLength,
                                    pMessage,
                                    MessageLength,
                                    Style,
                                    Timeout,
                                    pResponse,
                                    (BOOLEAN) !bWait ) );
}


/****************************************************************************
 *
 *  WTSSendMessageA (ANSI)
 *
 *    Send a message box to the specified session
 *
 * ENTRY:
 *
 *    see WTSSendMessageW
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSendMessageA(
               IN HANDLE hServer,
               IN DWORD SessionId,
               IN LPSTR pTitle,
               IN DWORD TitleLength,
               IN LPSTR pMessage,
               IN DWORD MessageLength,
               IN DWORD Style,
               IN DWORD Timeout,
               OUT DWORD * pResponse,
               IN BOOL bWait
               )
{

    if (!pTitle ||
        !pMessage ||
        !pResponse
       ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    return( WinStationSendMessageA( hServer,
                                    SessionId,
                                    pTitle,
                                    TitleLength,
                                    pMessage,
                                    MessageLength,
                                    Style,
                                    Timeout,
                                    pResponse,
                                    (BOOLEAN) !bWait ) );
}


/****************************************************************************
 *
 *  WTSDisconnectSession
 *
 *    Disconnect the specified session
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    bWait (input)
 *       Wait for the operation to complete
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSDisconnectSession(
                    IN HANDLE hServer,
                    IN DWORD SessionId,
                    IN BOOL bWait
                    )
{
    return( WinStationDisconnect( hServer, SessionId, (BOOLEAN) bWait ) );
}


/****************************************************************************
 *
 *  WTSLogoffSession
 *
 *    Logoff the specified session
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    bWait (input)
 *       Wait for the operation to complete
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSLogoffSession(
                IN HANDLE hServer,
                IN DWORD SessionId,
                IN BOOL bWait
                )
{
    return( WinStationReset( hServer, SessionId, (BOOLEAN) bWait ) );
}


/****************************************************************************
 *
 *  _CopyData
 *
 *    Allocate buffer and copy data into it
 *
 * ENTRY:
 *    pData (input)
 *       pointer to data to copy
 *    DataLength (input)
 *       length of data to copy
 *    ppBuffer (output)
 *       Points to the address of a variable to receive the copied data
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The copy operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
_CopyData( PVOID pData,
           ULONG DataLength,
           LPWSTR * ppBuffer,
           DWORD * pBytesReturned )
{
    *ppBuffer = LocalAlloc( LPTR, DataLength );
    if ( *ppBuffer == NULL ) {
        return( FALSE );
    }

    if ( pBytesReturned != NULL ) {
        *pBytesReturned = DataLength;
    }

    memcpy( *ppBuffer, pData, DataLength );

    return( TRUE );
}


/****************************************************************************
 *
 *  _CopyStringW
 *
 *    Allocate a buffer for a unicode string and copy unicode string into it
 *
 * ENTRY:
 *    pString (input)
 *       pointer to unicode string to copy
 *    ppBuffer (output)
 *       Points to the address of a variable to receive the copied data
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The copy operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
_CopyStringW( LPWSTR pString,
              LPWSTR * ppBuffer,
              DWORD * pBytesReturned )
{
    ULONG DataLength;
    BOOL  rc = TRUE;

    /*
     *  If original string is NULL, just make copy NULL.           KLB 11-03-97
     */
    if ( pString == NULL ) {
        *ppBuffer = NULL;
        if ( pBytesReturned != NULL ) {
            *pBytesReturned = 0;
        }
        goto done;
    }

    DataLength = (wcslen( pString ) + 1) * sizeof(WCHAR);

    *ppBuffer = LocalAlloc( LPTR, DataLength );
    if ( *ppBuffer == NULL ) {
        rc = FALSE;
        goto done;
    }

    if ( pBytesReturned != NULL ) {
        *pBytesReturned = DataLength;
    }

    memcpy( *ppBuffer, pString, DataLength );

    done:
    return( rc );
}


/****************************************************************************
 *
 *  _CopyStringA
 *
 *    Allocate a buffer for a unicode string and copy ansi string into it
 *
 * ENTRY:
 *    pString (input)
 *       pointer to ansi string to copy
 *    ppBuffer (output)
 *       Points to the address of a variable to receive the copied data
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The copy operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
_CopyStringA( LPSTR pString,
              LPWSTR * ppBuffer,
              DWORD * pBytesReturned )
{
    ULONG DataLength;
    BOOL  rc = TRUE;

    /*
     *  If original string is NULL, just make copy NULL.           KLB 11-03-97
     */
    if ( pString == NULL ) {
        *ppBuffer = NULL;
        if ( pBytesReturned != NULL ) {
            *pBytesReturned = 0;
        }
        goto done;
    }

    DataLength = (strlen( pString ) + 1) * sizeof(WCHAR);

    *ppBuffer = LocalAlloc( LPTR, DataLength );
    if ( *ppBuffer == NULL ) {
        rc = FALSE;
        goto done;
    }

    if ( pBytesReturned != NULL ) {
        *pBytesReturned = DataLength;
    }

    AnsiToUnicode( *ppBuffer, DataLength, pString );

    done:
    return( rc );
}


/****************************************************************************
 *
 *  _CopyStringWtoA
 *
 *    Allocate a buffer for an ansi string and copy unicode string into it
 *
 * ENTRY:
 *    pString (input)
 *       pointer to unicode string to copy
 *    ppBuffer (output)
 *       Points to the address of a variable to receive the copied data
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The copy operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
_CopyStringWtoA( LPWSTR pString,
                 LPSTR * ppBuffer,
                 DWORD * pBytesReturned )
{
    ULONG DataLength;

    DataLength = (wcslen( pString ) + 1) * sizeof(CHAR);

    *ppBuffer = LocalAlloc( LPTR, DataLength );
    if ( *ppBuffer == NULL )
        return( FALSE );

    if ( pBytesReturned != NULL ) {
        *pBytesReturned = DataLength;
    }

    UnicodeToAnsi( *ppBuffer, DataLength, pString );

    return( TRUE );
}



/****************************************************************************
 *
 *  ValidateCopyUnicodeToUnicode
 *
 *    Determines if the source unicode character string is valid and if so,
 *    copies it to the destination.
 *
 * ENTRY:
 *    pSourceW (input)
 *       pointer to a null terminated string.
 *    MaxLength (input)
 *       The maximum allowed length (in characters).
 *    pDestW (input)
 *       The destination where pSourceW is copied.
 * EXIT:
 *    Returns TRUE if successful, otherwise FALSE.
 *
 ****************************************************************************/
BOOL
ValidateCopyUnicodeToUnicode(LPWSTR pSourceW, DWORD MaxLength, LPWSTR pDestW)
{

    DWORD Length;

    if ( wcslen(pSourceW) > MaxLength ) {
        return(FALSE);
    }
    wcscpy(pDestW,pSourceW);
    return(TRUE);
}


/****************************************************************************
 *
 *  ValidateCopyAnsiToUnicode
 *
 *    Determines if the source ANSI character string is valid and if so,
 *    converts and copies it to the unicode destination.
 *
 * ENTRY:
 *    pSourceA (input)
 *       pointer to a null terminated ANSI string.
 *    MaxLength (input)
 *       The maximum allowed length (in characters).
 *    pDestW (input)
 *       The destination where pSourceA is copied.
 * EXIT:
 *    Returns TRUE if successful, otherwise FALSE.
 *
 ****************************************************************************/
BOOL
ValidateCopyAnsiToUnicode(LPSTR pSourceA, DWORD MaxLength, LPWSTR pDestW)
{
    UINT  Length;
    DWORD DataLength;

    if ( (Length = strlen(pSourceA)) > MaxLength ) {
        return(FALSE);
    }

    DataLength = (Length+1) * sizeof(WCHAR);
    AnsiToUnicode(pDestW,DataLength,pSourceA);
    return(TRUE);
}


/****************************************************************************
 *
 *  WTSRegisterSessionNotification
 *
 *    Register a window handle for console notification
 *    Console notification, are messages sent when console session switch occurs
 *
 * ENTRY:
 *    hWnd (input)
 *       Window handle to be registered.
 *    dwFlags (input)
 *       value must be NOTIFY_FOR_THIS_SESSION
 * EXIT:
 *    Returns TRUE if successful, otherwise FALSE. Sets LastError
 *
 ****************************************************************************/

BOOL WINAPI
WTSRegisterSessionNotification (HWND hWnd, DWORD dwFlags)
{
    DWORD dwProcId;
    HMODULE User32DllHandle = NULL ; 


    //
    // make sure that window handle is valid
    //
    if (!IsWindow(hWnd))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto error ; 
    }

    GetWindowThreadProcessId(hWnd, &dwProcId);

    if (dwProcId != GetCurrentProcessId())
    {
        SetLastError(ERROR_WINDOW_OF_OTHER_THREAD);
        goto error ; 
    }

    if (dwFlags != NOTIFY_FOR_THIS_SESSION && dwFlags != NOTIFY_FOR_ALL_SESSIONS)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto error ; 
    }

    return WinStationRegisterConsoleNotification (WTS_CURRENT_SERVER_HANDLE, hWnd, dwFlags);

    // -------------------------------- Handle Errors and return FALSE -----------------------

    error :

    return FALSE ;
}

/****************************************************************************
 *
 *  WTSUnRegisterSessionNotification
 *
 *    UnRegister a window handle for console notification
 *    Console notification, are messages sent when console session switch occurs
 *
 * ENTRY:
 *    dwFlags (input)
 *       NOTIFY_FOR_THIS_SESSION
 * EXIT:
 *    Returns TRUE if successful, otherwise FALSE. Sets LastError
 *
 ****************************************************************************/

BOOL WINAPI
WTSUnRegisterSessionNotification (HWND hWnd)
{
    DWORD dwProcId;
    HMODULE User32DllHandle = NULL ; 

    //
    // make sure that window handle is valid
    //
    if (!IsWindow(hWnd))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto error ; 
    }

    GetWindowThreadProcessId(hWnd, &dwProcId);

    if (dwProcId != GetCurrentProcessId())
    {
        SetLastError(ERROR_WINDOW_OF_OTHER_THREAD);
        goto error ; 
    }
    
    return WinStationUnRegisterConsoleNotification (WTS_CURRENT_SERVER_HANDLE, hWnd);

    // -------------------------------- Handle Errors and return FALSE -----------------------

    error :

    return FALSE ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wtsapi\virtual.c ===
/*******************************************************************************
* virtual.c
*
* Published Terminal Server Virtual Channel APIs
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
    #include <icadd.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
    #include <citrix\icadd.h>
#endif
#include <utildll.h>

#include <stdio.h>
#include <stdarg.h>

#include <wtsapi32.h>



/*
 *  Virtual Channel Name
 */
#define VIRTUALNAME_LENGTH  7

typedef CHAR VIRTUALNAME[ VIRTUALNAME_LENGTH + 1 ];  // includes null
typedef CHAR * PVIRTUALNAME;



// Handle structure used internally
typedef struct _VCHANDLE {
    ULONG Signature;
    HANDLE hServer;
    DWORD SessionId;
    HANDLE hChannel;
    VIRTUALNAME VirtualName;
} VCHANDLE, *PVCHANDLE;

#define VCHANDLE_SIGNATURE ('V' | ('C' << 8) | ('H' << 16) | ('D' << 24))
#define ValidVCHandle(hVC) ((hVC) && ((hVC)->Signature == VCHANDLE_SIGNATURE))


/****************************************************************************
 *
 *  WTSVirtualChannelOpen
 *
 *    Open the specified virtual channel
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    pVirtualName (input)
 *       Pointer to virtual channel name
 *
 * EXIT:
 *
 *    Handle to specified virtual channel (NULL on error)
 *
 ****************************************************************************/

HANDLE
WINAPI
WTSVirtualChannelOpen(
                     IN HANDLE hServer,
                     IN DWORD SessionId,
                     IN LPSTR pVirtualName   /* ascii name */
                     )
{
    PVCHANDLE pChannelHandle;
    HANDLE hChannel;

    if (hChannel = WinStationVirtualOpen( hServer, SessionId, pVirtualName)) {

        // Allocate the Handle
        if (!(pChannelHandle = (PVCHANDLE) LocalAlloc(LPTR,
                                                      sizeof(VCHANDLE)))) {
            CloseHandle(hChannel);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        pChannelHandle->Signature = VCHANDLE_SIGNATURE;
        pChannelHandle->hServer = hServer;
        pChannelHandle->SessionId = SessionId;
        pChannelHandle->hChannel = hChannel;
        memcpy(pChannelHandle->VirtualName, pVirtualName, sizeof(VIRTUALNAME));
        return((HANDLE)pChannelHandle);
    }
    return(NULL);

}

/****************************************************************************
 *
 *  WTSVirtualChannelClose
 *
 *    Close the specified virtual channel
 *
 * ENTRY:
 *    hChannel (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelClose(HANDLE hChannel)
{
    PVCHANDLE VCHandle = (PVCHANDLE) hChannel;
    BOOL RetVal = FALSE;

    if(!hChannel || IsBadReadPtr(hChannel,sizeof(HANDLE)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }


    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto BadParam;
    }

    if (CloseHandle(VCHandle->hChannel))
        RetVal = TRUE;

    VCHandle->Signature = 0;
    LocalFree(VCHandle);

    BadParam:
    return(RetVal);
}

/****************************************************************************
 *
 *  WTSVirtualChannelWrite
 *
 *    Write data to a virtual channel
 *
 * ENTRY:
 *    ChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *    Buffer (input)
 *       Buffer containing data to write.
 *    Length (input)
 *       Length of data to write (bytes)
 *    pBytesWritten (output)
 *       Returns the amount of data written.
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelWrite(HANDLE hChannel, PCHAR pBuffer, ULONG Length, PULONG pBytesWritten)
{
    PVCHANDLE VCHandle = (PVCHANDLE)hChannel;
    OVERLAPPED  Overlapped;

    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    Overlapped.hEvent = NULL;
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;

    if (!WriteFile(VCHandle->hChannel,
                   pBuffer,
                   Length,
                   pBytesWritten,
                   &Overlapped)) {

        if (GetLastError() == ERROR_IO_PENDING)
            // check on the results of the asynchronous write
            return (GetOverlappedResult(VCHandle->hChannel,
                                        &Overlapped,
                                        pBytesWritten,
                                        TRUE));
        else
            return(FALSE);
    }

    return(TRUE);
}

/****************************************************************************
 *
 *  WTSVirtualChannelRead
 *
 *    Read data from a virtual channel
 *
 * ENTRY:
 *    ChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *    Timeout (input)
 *       The amount of time to wait for the read to complete.
 *    Buffer (input)
 *       Buffer which receive the data read.
 *    BufferLength (input)
 *       Length of the read buffer.
 *    pBytesRead (output)
 *       Returns the amount of data read.
 *
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelRead(HANDLE hChannel, ULONG Timeout, PCHAR pBuffer, ULONG BufferLength, PULONG pBytesRead)
{
    PVCHANDLE VCHandle = (PVCHANDLE)hChannel;
    OVERLAPPED  Overlapped;

    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    Overlapped.hEvent = NULL;
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;

    if (!ReadFile(VCHandle->hChannel,
                  pBuffer,
                  BufferLength,
                  pBytesRead,
                  &Overlapped)) {
        if (GetLastError() == ERROR_IO_PENDING) {
            if (!Timeout) {
                // Read with no timeout - cancel IO and return success.
                // This matches the behavior in WTS 1.7.  This is required for
                // Wyse firmware download software.
                CancelIo(VCHandle->hChannel);
                *pBytesRead = 0;
                return(TRUE);
            }
            if (WaitForSingleObject(VCHandle->hChannel, Timeout) == WAIT_TIMEOUT) {
                CancelIo(VCHandle->hChannel);
                SetLastError(ERROR_IO_INCOMPLETE);
                return(FALSE);
            }
            // check on the results of the asynchronous read
            return(GetOverlappedResult(VCHandle->hChannel,
                                       &Overlapped,
                                       pBytesRead,
                                       FALSE));
        } else {
            return(FALSE);
        }
    }

    return(TRUE);
}

/****************************************************************************
 *
 *  VirtualChannelIoctl
 *
 *    Issues an Ioctl to a virtual channel. This routine was replicated from
 *    icaapi so that OEMs don't need to link with icaapi.dll.
 *
 * ENTRY:
 *    hChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *    IoctlCode (input)
 *       The type of ioctl to do.
 *    pInBuf (input)
 *       Input data required for the Ioctl.
 *    InBufLength (input)
 *       Length of input data.
 *
 *    pOutBuf (output)
 *       Buffer to receive output data.
 *    OutBufLength (input)
 *       Length of the output buffer.
 *    pBytesReturned (output)
 *       Number of bytes returned in OutputBuffer.
 * EXIT:
 *
 *    Returns TRUE if successful, otherwise FALSE.
 *
 ****************************************************************************/
BOOL
VirtualChannelIoctl (HANDLE hChannel,
                     ULONG IoctlCode,
                     PCHAR pInBuf,
                     ULONG InBufLength,
                     PCHAR pOutBuf,
                     ULONG OutBufLength,
                     PULONG pBytesReturned)
{
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    PVCHANDLE VCHandle = (PVCHANDLE)hChannel;

    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }


    /*
     *  Issue ioctl
     */
    Status = NtDeviceIoControlFile( VCHandle->hChannel,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &Iosb,
                                    IoctlCode,
                                    pInBuf,
                                    InBufLength,
                                    pOutBuf,
                                    OutBufLength );

    /*
     *  Wait for ioctl to complete
     */
    if ( Status == STATUS_PENDING ) {
        Status = NtWaitForSingleObject( VCHandle->hChannel, FALSE, NULL );
        if ( NT_SUCCESS(Status))
            Status = Iosb.Status;
    }

    /*
     *  Convert warning into error
     */
    if ( Status == STATUS_BUFFER_OVERFLOW )
        Status = STATUS_BUFFER_TOO_SMALL;

    /*
     *  Initialize bytes returned
     */
    if ( pBytesReturned )
        *pBytesReturned = (ULONG)Iosb.Information;

    /* Return success/failure indication */
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        SetLastError(RtlNtStatusToDosError(Status));
        return(FALSE);
    }
}

/****************************************************************************
 *
 *  WTSVirtualChannelPurgeInput
 *
 *    Purge all queued input data on a virtual channel.
 *
 * ENTRY:
 *    ChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelPurgeInput(IN HANDLE hChannelHandle)
{
    PVCHANDLE VCHandle = (PVCHANDLE) hChannelHandle;

    return(VirtualChannelIoctl(VCHandle,
                               IOCTL_ICA_VIRTUAL_CANCEL_INPUT,
                               (PCHAR) NULL,
                               0,
                               (PCHAR) NULL,
                               0,
                               (PULONG) NULL));

}

/****************************************************************************
 *
 *  WTSVirtualChannelPurgeOutput
 *
 *    Purge all queued output data on a virtual channel.
 *
 * ENTRY:
 *    ChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelPurgeOutput(IN HANDLE hChannelHandle)
{
    PVCHANDLE VCHandle = (PVCHANDLE)hChannelHandle;

    return(VirtualChannelIoctl(VCHandle,
                               IOCTL_ICA_VIRTUAL_CANCEL_OUTPUT,
                               (PCHAR) NULL,
                               0,
                               (PCHAR) NULL,
                               0,
                               (PULONG) NULL));

}

/****************************************************************************
 *
 *  WTSVirtualChannelQuery
 *
 *    Query data related to a virtual channel.
 *
 * ENTRY:
 *    hChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *    VirtualClass (input)
 *       The type of information requested.
 *    ppBuffer (output)
 *       Pointer to a buffer pointer, which is allocated upon successful
 *       return.
 *    pBytesReturned (output)
 *       Pointer to a DWORD which is updated with the length of the data
 *       returned in the allocated buffer upon successful return.
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *    If successful, the caller is responsible for deallocating the
 *    buffer returned.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelQuery(IN HANDLE hChannelHandle,IN WTS_VIRTUAL_CLASS VirtualClass,
                       OUT PVOID *ppBuffer,OUT DWORD *pBytesReturned)
{
    PVCHANDLE VCHandle = (PVCHANDLE) hChannelHandle;
    PVOID DataBuffer;
    DWORD DataBufferLen;

    if (!hChannelHandle || IsBadReadPtr(hChannelHandle,sizeof(HANDLE)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (!ppBuffer || IsBadWritePtr(ppBuffer, sizeof(PVOID)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (!pBytesReturned || IsBadWritePtr(pBytesReturned, sizeof(DWORD)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (VirtualClass) {
    case WTSVirtualFileHandle:
        DataBuffer = LocalAlloc( LPTR, sizeof(HANDLE) );
        if ( DataBuffer == NULL ) {
            return(FALSE);
        }
        memcpy(DataBuffer, &VCHandle->hChannel, sizeof(HANDLE) );
        *ppBuffer = DataBuffer;
        *pBytesReturned = sizeof(HANDLE);
        return(TRUE);
        break;
    case WTSVirtualClientData:
        DataBufferLen = sizeof(VIRTUALNAME) + 1024;
        for (;;) {

            DataBuffer = LocalAlloc( LPTR, DataBufferLen );
            if ( DataBuffer == NULL ) {
                return(FALSE);
            }

            memcpy( DataBuffer,VCHandle->VirtualName,sizeof(VIRTUALNAME));

            if (WinStationQueryInformationW( VCHandle->hServer,
                                             VCHandle->SessionId,
                                             WinStationVirtualData,
                                             DataBuffer,
                                             DataBufferLen,
                                             &DataBufferLen)) {
                *ppBuffer = DataBuffer;
                *pBytesReturned = DataBufferLen;
                return(TRUE);
            }

            if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
                (DataBufferLen < sizeof(VIRTUALNAME))) {
                LocalFree(DataBuffer);
                return(FALSE);
            }
            LocalFree(DataBuffer);
        }
        break;
    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wtsapi\wtsapi32.c ===
/*******************************************************************************
* wtsapi32.c
*
* Published Terminal Server APIs
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif
#include <utildll.h>

#include <stdio.h>
#include <stdarg.h>


#include <wtsapi32.h>

// Private User function that returns user token for session 0 only
// Used in the case when TS is not running
extern 
HANDLE
GetCurrentUserTokenW (
        WCHAR       Winsta[],
        DWORD       DesiredAccess
        );



/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSShutdownSystem( HANDLE, DWORD );
BOOL WINAPI WTSWaitSystemEvent( HANDLE, DWORD, DWORD * );
VOID WINAPI WTSFreeMemory( PVOID pMemory );
BOOL WINAPI WTSQueryUserToken(ULONG SessionId, PHANDLE phToken);




/*=============================================================================
==   Internal procedures defined
=============================================================================*/

BOOL WINAPI DllEntryPoint( HINSTANCE, DWORD, LPVOID );
BOOL IsTerminalServiceRunning(VOID);
BOOL IsProcessPrivileged(CONST PCWSTR szPrivilege);



/*=============================================================================
==   Local function prototypes
=============================================================================*/

BOOLEAN CheckShutdownPrivilege();


/****************************************************************************
 *
 *  WTSShutdowSystem
 *
 *    Shutdown and/or reboot system
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    ShutdownFlags (input)
 *       Flags which specify shutdown options.
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSShutdownSystem(
                 IN HANDLE hServer,
                 IN DWORD ShutdownFlags
                 )
{
    ULONG uiOptions = 0;
    
    // Make sure the user has the proper privilege to shutdown the system when
    // hServer is a local server handle. For remote server, the user privilege
    // is checked when WTSOpenServer is called.

    if (hServer == SERVERNAME_CURRENT && !CheckShutdownPrivilege()) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return(FALSE);
    }

    // Construct the shutdown flag 

    if (ShutdownFlags == WTS_WSD_LOGOFF) {
        // log off all users and deletes sessions
        uiOptions = WSD_LOGOFF;
    } else if (ShutdownFlags == WTS_WSD_SHUTDOWN) {
        uiOptions = WSD_LOGOFF | WSD_SHUTDOWN;
    } else if (ShutdownFlags == WTS_WSD_REBOOT) {
        uiOptions = WSD_LOGOFF | WSD_SHUTDOWN | WSD_REBOOT;
    } else if (ShutdownFlags == WTS_WSD_POWEROFF) {
        uiOptions = WSD_LOGOFF | WSD_SHUTDOWN | WSD_POWEROFF;
    } else if (ShutdownFlags == WTS_WSD_FASTREBOOT) {
        uiOptions = WSD_FASTREBOOT | WSD_REBOOT;
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return( WinStationShutdownSystem( hServer, uiOptions ));

}


/****************************************************************************
 *
 *  WTSWaitSystemEvent
 *
 *    Waits for an event (WinStation create, delete, connect, etc) before
 *    returning to the caller.
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    EventFlags (input)
 *       Bit mask that specifies which event(s) to wait for (WTS_EVENT_?)
 *    pEventFlags (output)
 *       Bit mask of event(s) that occurred.
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSWaitSystemEvent(
                  IN HANDLE hServer,
                  IN DWORD EventMask,
                  OUT DWORD * pEventFlags
                  )
{
    BOOL fSuccess;
    ULONG WSEventMask;
    ULONG WSEventFlags = 0;

    if (IsBadWritePtr(pEventFlags, sizeof(DWORD))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    }


    /*
     *  Map event mask
     */
    WSEventMask = 0;
    if ( EventMask & WTS_EVENT_CREATE )
        WSEventMask |= WEVENT_CREATE;
    if ( EventMask & WTS_EVENT_DELETE )
        WSEventMask |= WEVENT_DELETE;
    if ( EventMask & WTS_EVENT_RENAME )
        WSEventMask |= WEVENT_RENAME;
    if ( EventMask & WTS_EVENT_CONNECT )
        WSEventMask |= WEVENT_CONNECT;
    if ( EventMask & WTS_EVENT_DISCONNECT )
        WSEventMask |= WEVENT_DISCONNECT;
    if ( EventMask & WTS_EVENT_LOGON )
        WSEventMask |= WEVENT_LOGON;
    if ( EventMask & WTS_EVENT_LOGOFF )
        WSEventMask |= WEVENT_LOGOFF;
    if ( EventMask & WTS_EVENT_STATECHANGE )
        WSEventMask |= WEVENT_STATECHANGE;
    if ( EventMask & WTS_EVENT_LICENSE )
        WSEventMask |= WEVENT_LICENSE;

    if ( EventMask & WTS_EVENT_FLUSH )
        WSEventMask |= WEVENT_FLUSH;

    /* 
     *  Wait for system event
     */
    fSuccess = WinStationWaitSystemEvent( hServer, WSEventMask, &WSEventFlags );

    /*
     * Map event mask
     */
    *pEventFlags = 0;
    if ( WSEventFlags & WEVENT_CREATE )
        *pEventFlags |= WTS_EVENT_CREATE;
    if ( WSEventFlags & WEVENT_DELETE )
        *pEventFlags |= WTS_EVENT_DELETE;
    if ( WSEventFlags & WEVENT_RENAME )
        *pEventFlags |= WTS_EVENT_RENAME;
    if ( WSEventFlags & WEVENT_CONNECT )
        *pEventFlags |= WTS_EVENT_CONNECT;
    if ( WSEventFlags & WEVENT_DISCONNECT )
        *pEventFlags |= WTS_EVENT_DISCONNECT;
    if ( WSEventFlags & WEVENT_LOGON )
        *pEventFlags |= WTS_EVENT_LOGON;
    if ( WSEventFlags & WEVENT_LOGOFF )
        *pEventFlags |= WTS_EVENT_LOGOFF;
    if ( WSEventFlags & WEVENT_STATECHANGE )
        *pEventFlags |= WTS_EVENT_STATECHANGE;
    if ( WSEventFlags & WEVENT_LICENSE )
        *pEventFlags |= WTS_EVENT_LICENSE;

    return( fSuccess );
}


/****************************************************************************
 *
 *  WTSFreeMemory
 *
 *    Free memory allocated by Terminal Server APIs
 *
 * ENTRY:
 *    pMemory (input)
 *       Pointer to memory to free
 *
 * EXIT:
 *    nothing
 *
 ****************************************************************************/

VOID
WINAPI
WTSFreeMemory( PVOID pMemory )
{
    LocalFree( pMemory );
}


/****************************************************************************
 *
 * DllEntryPoint
 *
 *   Function is called when the DLL is loaded and unloaded.
 *
 * ENTRY:
 *   hinstDLL (input)
 *     Handle of DLL module
 *   fdwReason (input)
 *     Why function was called
 *   lpvReserved (input)
 *     Reserved; must be NULL
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Error occurred
 *
 ****************************************************************************/

BOOL WINAPI
DllEntryPoint( HINSTANCE hinstDLL,
               DWORD     fdwReason,
               LPVOID    lpvReserved )
{
    switch ( fdwReason ) {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return( TRUE );
}


/*****************************************************************************
 *
 *  CheckShutdownPrivilege
 *
 *   Check whether the current process has shutdown permission.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *
 ****************************************************************************/

BOOLEAN
CheckShutdownPrivilege()
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    //
    // Try the thread token first
    //

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                TRUE,
                                TRUE,
                                &WasEnabled);

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }
    return(TRUE);
}

/*++

Routine Description:
    
    Allows to read the token of the user interactively logged in the session identified by SessionId.
    The caller must be running under local system account and hold SE_TCB_NAME privilege. This API
    is intended for highly trusted services. Service Providers using it must be very cautious not to 
    leak user tokens. 
    
    NOTE : The API is RPC based and hence cannot be called with the loader lock held (specifically
    from DLL attach/detach code)
    
Arguments:

    SessionId: IN. Identifies the session the user is logged in. 
    phToken:  OUT. Points to the user token handle, if the function succeeded.
    
Return Values:

    TRUE in case of success. phToken points to the user token.
    FALSE in case of failure. Use GetLastError() to get extended error code.

    The token returned is a duplicate of a primary token.
    
--*/


BOOL
WINAPI
WTSQueryUserToken(ULONG SessionId, PHANDLE phToken)
{

    BOOL IsTsUp = FALSE;
    BOOL    Result, bHasPrivilege;
    ULONG ReturnLength;
    WINSTATIONUSERTOKEN Info;
    NTSTATUS Status;
    HANDLE hUserToken = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    // Do parameter Validation
    if (NULL == phToken) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // We will first check if the process which is calling us, has SE_TCB_NAME privilege
    bHasPrivilege = IsProcessPrivileged(SE_TCB_NAME);
    if (!bHasPrivilege) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return(FALSE);
    }

    // If it is session 0, don't call winsta. Use GetCurrentUserToken instead. 
    if (SessionId == 0)
    {
        hUserToken = GetCurrentUserTokenW(L"WinSta0",
                                            TOKEN_QUERY |
                                            TOKEN_DUPLICATE |
                                            TOKEN_ASSIGN_PRIMARY
                                            );

        if (hUserToken == NULL)
            return FALSE;
        else 
            *phToken = hUserToken;
    }
    else    // Non-zero sessions
    {
        // No one except TS has any idea about non-zero sessions. So, check if the TS is running.
        IsTsUp = IsTerminalServiceRunning();
        if (IsTsUp) 
        {   // This is so that CSRSS can dup the handle to our process
            Info.ProcessId = LongToHandle(GetCurrentProcessId());
            Info.ThreadId = LongToHandle(GetCurrentThreadId());

            Result = WinStationQueryInformation(
                                SERVERNAME_CURRENT,
                                SessionId,
                                WinStationUserToken,
                                &Info,
                                sizeof(Info),
                                &ReturnLength
                                );

            if( !Result ) 
                return FALSE;
            else 
                *phToken = Info.UserToken ; 
        }
        else
        {   // TS is not running. So, set error for non-zero sessions: WINSTATION_NOT_FOUND.
            SetLastError(ERROR_CTX_WINSTATION_NOT_FOUND);
            return FALSE;
        }
    }
			
    return TRUE;
}

// This function determines if the Terminal Service is currently Running
BOOL IsTerminalServiceRunning (VOID)
{

    BOOL bReturn = FALSE;
    SC_HANDLE hServiceController;

    hServiceController = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hServiceController) {
        SC_HANDLE hTermServ ;
        hTermServ = OpenService(hServiceController, L"TermService", SERVICE_QUERY_STATUS);
        if (hTermServ) {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus)) {
                bReturn = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
            } else {
                CloseServiceHandle(hTermServ);
                CloseServiceHandle(hServiceController);
                return FALSE;
            }
            CloseServiceHandle(hTermServ);
        } else {
            CloseServiceHandle(hServiceController);
            return FALSE;
        }
        CloseServiceHandle(hServiceController);
    } else {
        return FALSE;
    }

    return bReturn;
}


/*++
Routine Description:

    This function checks to see if the specified privilege is enabled
    in the primary access token for the current thread.

Arguments:

    szPrivilege - The privilege to be checked for

Return Value:

    TRUE if the specified privilege is enabled, FALSE otherwise.

--*/
BOOL
IsProcessPrivileged(
    CONST PCWSTR szPrivilege
    )

{
    LUID luidValue;     // LUID (locally unique ID) for the privilege
    BOOL bResult = FALSE, bHasPrivilege = FALSE;
    HANDLE  hToken = NULL;
    PRIVILEGE_SET privilegeSet;

    // Get the LUID for the privilege from the privilege name
    bResult = LookupPrivilegeValue(
                NULL, 
                szPrivilege, 
                &luidValue
                );

    if (!bResult) {
        return FALSE;
    }

    // Get the token of the present thread
    bResult = OpenThreadToken(
                GetCurrentThread(),
                MAXIMUM_ALLOWED,
                FALSE,
                &hToken
                );

    if (!bResult) {
        // We want to use the token for the current process
        bResult = OpenProcessToken(
                    GetCurrentProcess(),
                    MAXIMUM_ALLOWED,
                    &hToken
                    );
        if (!bResult) {
            return FALSE;
        }
    }

    // And check for the privilege
	privilegeSet.PrivilegeCount = 1;
	privilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
	privilegeSet.Privilege[0].Luid = luidValue;
	privilegeSet.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
	
	bResult = PrivilegeCheck(hToken, &privilegeSet, &bHasPrivilege);

    CloseHandle(hToken);

    return (bResult && bHasPrivilege);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wtsapi\process.c ===
/*******************************************************************************
* process.c
*
* Published Terminal Server APIs
*
* - process routines
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <allproc.h>

#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif

#include <utildll.h>

#include <stdio.h>
#include <stdarg.h>

#include <wtsapi32.h>


/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSEnumerateProcessesW( HANDLE, DWORD, DWORD, PWTS_PROCESS_INFOW *, DWORD * );
BOOL WINAPI WTSEnumerateProcessesA( HANDLE, DWORD, DWORD, PWTS_PROCESS_INFOA *, DWORD * );
BOOL WINAPI WTSTerminateProcess( HANDLE, DWORD, DWORD );


/*=============================================================================
==   Procedures used
=============================================================================*/

VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );

/*=============================================================================
 * Internal function
 =============================================================================*/

BOOL
GetProcessSid(HANDLE          Server,
              HANDLE          hUniqueProcessId,
              LARGE_INTEGER   ProcessStartTime,
              PBYTE      *     pProcessUserSid     //Return the SID (allocated here..)
             );

/*=======================================================================
 * Private structure definitions
 *=========================================================================*/
typedef struct _SID_INFO {
    struct _SID_INFO * pNext;
    PBYTE pSid;
} SID_INFO;

/****************************************************************************
 *
 *  WTSEnumerateProcessesW (UNICODE)
 *
 *    Returns a list of Terminal Server Processes on the specified server
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to a Terminal server (or WTS_CURRENT_SERVER)
 *    Reserved (input)
 *       Must be zero
 *    Version (input)
 *       Version of the enumeration request (must be 1)
 *    ppProcessInfo (output)
 *       Points to the address of a variable to receive the enumeration results,
 *       which are returned as an array of WTS_PROCESS_INFO structures.  The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pCount (output)
 *       Points to the address of a variable to receive the number of
 *       WTS_PROCESS_INFO structures returned
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

#if(WINVER >= 0x0500)
BOOL
WINAPI
WTSEnumerateProcessesW(
                      IN HANDLE hServer,
                      IN DWORD Reserved,
                      IN DWORD Version,
                      OUT PWTS_PROCESS_INFOW * ppProcessInfo,
                      OUT DWORD * pCount
                      )
{
    PBYTE pProcessBuffer = NULL;
    PTS_SYS_PROCESS_INFORMATION pProcessInfo;
    PCITRIX_PROCESS_INFORMATION pCitrixInfo;
    ULONG ProcessCount;
    ULONG Offset;
    ULONG DataLength;
    PWTS_PROCESS_INFOW pProcessW;
    PBYTE pProcessData;
    ULONG i;
    ULONG Length;
    PTS_ALL_PROCESSES_INFO  ProcessArray = NULL;
    DWORD dwError;


    SID_INFO   sidInfoHead;                  //The head of the Sid temp storage
    SID_INFO * pSidInfo;                     //Point to a list of temp storage for the
                                             //variable length SID
    sidInfoHead.pNext = NULL;
    sidInfoHead.pSid = NULL;
    pSidInfo = &sidInfoHead;


    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    if (!ppProcessInfo || !pCount) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    //
    // Try the new interface first (Windows 2000 server)
    //
    if (WinStationGetAllProcesses( hServer,
                                   GAP_LEVEL_BASIC,
                                   &ProcessCount,
                                   &ProcessArray) )
    {
        DataLength = 0;

        for (i=0; i<ProcessCount; i++)
        {
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)(ProcessArray[i].pTsProcessInfo);
            DataLength += (pProcessInfo->ImageName.Length + sizeof(WCHAR));
            if (ProcessArray[i].pSid)
            {
                DataLength += GetLengthSid( ProcessArray[i].pSid );
            }
        }

        /*
         *  Allocate user buffer
         */
        pProcessW = LocalAlloc( LPTR, (ProcessCount * sizeof(WTS_PROCESS_INFOW)) + DataLength );
        if ( pProcessW == NULL ) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto GAPErrorReturn;
        }

        /*
         *  Update user parameters
         */
        *ppProcessInfo = pProcessW;
        *pCount = ProcessCount;

        /*
         *  Copy data to new buffer
         */
        pProcessData = (PBYTE)pProcessW + (ProcessCount * sizeof(WTS_PROCESS_INFOW));
        for ( i=0; i < ProcessCount; i++ ) {

            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)(ProcessArray[i].pTsProcessInfo);

            Length = pProcessInfo->ImageName.Length; // number of bytes

            pProcessW->pProcessName = (LPWSTR) pProcessData;
            memcpy( pProcessData, pProcessInfo->ImageName.Buffer, Length );
            *(pProcessData += Length) = (WCHAR)0;
            pProcessData += sizeof(WCHAR);

            pProcessW->ProcessId = (ULONG)(ULONG_PTR)pProcessInfo->UniqueProcessId;
            pProcessW->SessionId = pProcessInfo->SessionId;
            if (ProcessArray[i].pSid)
            {
                Length = GetLengthSid( ProcessArray[i].pSid );
                pProcessW->pUserSid = (LPWSTR) pProcessData;
                memcpy( pProcessData, ProcessArray[i].pSid, Length );
                pProcessData += Length;
            }

            pProcessW++;
        }
        //
        // Free ppProcessArray and all child pointers allocated by the client stub.
        //
        WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, ProcessCount);

    }
    else    // Maybe a TS 4.0 server ?
    {
        //
        //   Check the return code indicating that the interface is not available.
        //
        dwError = GetLastError();
        if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            goto badenum;
        }
        else
        {
            // It might be a TS4.0 server
            // Try the old interface
            //
            //
            //  Enumerate Processes and check for an error
            //
            if ( !WinStationEnumerateProcesses( hServer, &pProcessBuffer ) ) {
                goto badenum;
            }

            //
            //  Count the number of processes and total up the size of the data
            //
            ProcessCount = 0;
            DataLength = 0;
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) pProcessBuffer;
            Offset = 0;
            do {

                pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) ((PBYTE)pProcessInfo + Offset);

                ProcessCount++;

                DataLength += (pProcessInfo->ImageName.Length + sizeof(WCHAR));

                pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                             (((PUCHAR)pProcessInfo) +
                              SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                              (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)pProcessInfo->NumberOfThreads));

                if ( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
                    if ( pCitrixInfo->ProcessSid )
                        DataLength += GetLengthSid( pCitrixInfo->ProcessSid );
                }

                Offset = pProcessInfo->NextEntryOffset;

            } while ( Offset != 0 );

            /*
             *  Allocate user buffer
             */
            pProcessW = LocalAlloc( LPTR, (ProcessCount * sizeof(WTS_PROCESS_INFOW)) + DataLength );
            if ( pProcessW == NULL ) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto badalloc;
            }

            /*
             *  Update user parameters
             */
            *ppProcessInfo = pProcessW;
            *pCount = ProcessCount;

            /*
             *  Copy data to new buffer
             */
            pProcessData = (PBYTE)pProcessW + (ProcessCount * sizeof(WTS_PROCESS_INFOW));
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) pProcessBuffer;
            Offset = 0;
            for ( i=0; i < ProcessCount; i++ ) {

                pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) ((PBYTE)pProcessInfo + Offset);

                Length = pProcessInfo->ImageName.Length; // number of bytes

                pProcessW->pProcessName = (LPWSTR) pProcessData;
                memcpy( pProcessData, pProcessInfo->ImageName.Buffer, Length );
                *(pProcessData += Length) = (WCHAR)0;
                pProcessData += sizeof(WCHAR);

                pProcessW->ProcessId = pProcessInfo->UniqueProcessId;

                /*
                 * Point to the CITRIX_INFORMATION which follows the Threads
                 */
                pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                             (((PUCHAR)pProcessInfo) +
                              SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                              (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)pProcessInfo->NumberOfThreads));

                if ( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
                    pProcessW->SessionId = pCitrixInfo->LogonId;
                    if ( pCitrixInfo->ProcessSid ) {
                        Length = GetLengthSid( pCitrixInfo->ProcessSid );
                        pProcessW->pUserSid = (LPWSTR) pProcessData;
                        memcpy( pProcessData, pCitrixInfo->ProcessSid, Length );
                        pProcessData += Length;
                    }
                } else {
                    pProcessW->SessionId = (ULONG) -1;
                }

                pProcessW++;
                Offset = pProcessInfo->NextEntryOffset;
            }

            /*
             *  Free original Process list buffer
             */
            WinStationFreeMemory( pProcessBuffer );

        }
    }
    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

GAPErrorReturn:
    //
    // Free ppProcessArray and all child pointers allocated by the client stub.
    //
    WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, ProcessCount);
    goto enderror;

badalloc:
    WinStationFreeMemory( pProcessBuffer );

badenum:
badparam:
enderror:
    if (ppProcessInfo) *ppProcessInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}

#else //#if(WINVER>=0x0500)

BOOL
WINAPI
WTSEnumerateProcessesW(
                      IN HANDLE hServer,
                      IN DWORD Reserved,
                      IN DWORD Version,
                      OUT PWTS_PROCESS_INFOW * ppProcessInfo,
                      OUT DWORD * pCount
                      )
{
    PBYTE pProcessBuffer;
    PTS_SYS_PROCESS_INFORMATION pProcessInfo;
    PCITRIX_PROCESS_INFORMATION pCitrixInfo;
    ULONG ProcessCount;
    ULONG Offset;
    ULONG DataLength;
    PWTS_PROCESS_INFOW pProcessW;
    PBYTE pProcessData;
    ULONG i;
    ULONG Length;

    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }


    if (!ppProcessInfo || !pCount) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    /*
     *  Enumerate Processes and check for an error
     */
    if ( !WinStationEnumerateProcesses( hServer, &pProcessBuffer ) ) {
        goto badenum;
    }

    /*
     *  Count the number of processes and total up the size of the data
     */
    ProcessCount = 0;
    DataLength = 0;
    pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) pProcessBuffer;
    Offset = 0;
    do {

        pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) ((PBYTE)pProcessInfo + Offset);

        ProcessCount++;

        DataLength += (pProcessInfo->ImageName.Length + sizeof(WCHAR));

        pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                      ((PBYTE)pProcessInfo +
                       sizeof(SYSTEM_PROCESS_INFORMATION) +
                       (sizeof(SYSTEM_THREAD_INFORMATION) *
                        pProcessInfo->NumberOfThreads));

        if ( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
            if ( pCitrixInfo->ProcessSid )
                DataLength += GetLengthSid( pCitrixInfo->ProcessSid );
        }

        Offset = pProcessInfo->NextEntryOffset;

    } while ( Offset != 0 );

    /*
     *  Allocate user buffer
     */
    pProcessW = LocalAlloc( LPTR, (ProcessCount * sizeof(WTS_PROCESS_INFOW)) + DataLength );
    if ( pProcessW == NULL ) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto badalloc;
    }

    /*
     *  Update user parameters
     */
    *ppProcessInfo = pProcessW;
    *pCount = ProcessCount;

    /*
     *  Copy data to new buffer
     */
    pProcessData = (PBYTE)pProcessW + (ProcessCount * sizeof(WTS_PROCESS_INFOW));
    pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) pProcessBuffer;
    Offset = 0;
    for ( i=0; i < ProcessCount; i++ ) {

        pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) ((PBYTE)pProcessInfo + Offset);

        Length = pProcessInfo->ImageName.Length; // number of bytes

        pProcessW->pProcessName = (LPWSTR) pProcessData;
        memcpy( pProcessData, pProcessInfo->ImageName.Buffer, Length );
        *(pProcessData += Length) = (WCHAR)0;
        pProcessData += sizeof(WCHAR);

        pProcessW->ProcessId = (ULONG) pProcessInfo->UniqueProcessId;

        /*
         * Point to the CITRIX_INFORMATION which follows the Threads
         */
        pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                      ((PBYTE)pProcessInfo +
                       sizeof(SYSTEM_PROCESS_INFORMATION) +
                       (sizeof(SYSTEM_THREAD_INFORMATION) *
                        pProcessInfo->NumberOfThreads));

        if ( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
            pProcessW->SessionId = pCitrixInfo->LogonId;
            if ( pCitrixInfo->ProcessSid ) {
                Length = GetLengthSid( pCitrixInfo->ProcessSid );
                pProcessW->pUserSid = (LPWSTR) pProcessData;
                memcpy( pProcessData, pCitrixInfo->ProcessSid, Length );
                pProcessData += Length;
            }
        } else {
            pProcessW->SessionId = (ULONG) -1;
        }

        pProcessW++;
        Offset = pProcessInfo->NextEntryOffset;
    }

    /*
     *  Free original Process list buffer
     */
    WinStationFreeMemory( pProcessBuffer );

    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badalloc:
    WinStationFreeMemory( pProcessBuffer );

    badenum:
    badparam:
    if (ppProcessInfo) *ppProcessInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}
#endif //#if(WINVER>=0x0500)

/****************************************************************************
 *
 *  WTSEnumerateProcessesA (ANSI stub)
 *
 *    Returns a list of Terminal Server Processes on the specified server
 *
 * ENTRY:
 *
 *    see WTSEnumerateProcessesW
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateProcessesA(
                      IN HANDLE hServer,
                      IN DWORD Reserved,
                      IN DWORD Version,
                      OUT PWTS_PROCESS_INFOA * ppProcessInfo,
                      OUT DWORD * pCount
                      )
{
    PWTS_PROCESS_INFOW pProcessW;
    PWTS_PROCESS_INFOA pProcessA;
    PBYTE pProcessData;
    ULONG Length;
    ULONG DataLength;           // number of bytes of name data
    ULONG NameCount;
    ULONG i;

    /*
     *  Enumerate processes (UNICODE)
     */
    if ( !WTSEnumerateProcessesW( hServer,
                                  Reserved,
                                  Version,
                                  &pProcessW,
                                  &NameCount ) ) {
        goto badenum;
    }

    /*
     *  Calculate the length of the name data
     */
    for ( i=0, DataLength=0; i < NameCount; i++ ) {
        DataLength += (wcslen(pProcessW[i].pProcessName) + 1);
        if ( pProcessW[i].pUserSid )
            DataLength += GetLengthSid( pProcessW[i].pUserSid );
    }

    /*
     *  Allocate user buffer
     */
    pProcessA = LocalAlloc( LPTR, (NameCount * sizeof(WTS_PROCESS_INFOA)) + DataLength );
    if ( pProcessA == NULL )
        goto badalloc2;

    /*
     *  Convert unicode process list to ansi
     */
    pProcessData = (PBYTE)pProcessA + (NameCount * sizeof(WTS_PROCESS_INFOA));
    for ( i=0; i < NameCount; i++ ) {

        pProcessA[i].SessionId = pProcessW[i].SessionId;
        pProcessA[i].ProcessId = pProcessW[i].ProcessId;

        Length = wcslen(pProcessW[i].pProcessName) + 1;
        pProcessA[i].pProcessName = pProcessData;
        UnicodeToAnsi( pProcessData, DataLength, pProcessW[i].pProcessName );
        DataLength -= Length;
        pProcessData += Length;

        if ( pProcessW[i].pUserSid ) {
            Length = GetLengthSid( pProcessW[i].pUserSid );
            pProcessA[i].pUserSid = pProcessData;
            memcpy( pProcessData, pProcessW[i].pUserSid, Length );
            DataLength -= Length;
            pProcessData += Length;
        }
    }

    /*
     *  Free unicode process list buffer
     */
    LocalFree( pProcessW );

    /*
     *  Update user parameters
     */
    if (ppProcessInfo) {
        *ppProcessInfo = pProcessA;
    } else {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return(FALSE);
    }
    if (pCount) {
        *pCount = NameCount;
    } else {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return(FALSE);
    }


    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/


    badalloc2:
    LocalFree( pProcessW );

    badenum:
    // make sure the passed parameter buffer pointer is not NULL
    if (ppProcessInfo) *ppProcessInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}


/*******************************************************************************
 *
 *  WTSTerminateProcess
 *
 *    Terminate the specified process
 *
 * ENTRY:
 *
 *    hServer (input)
 *       handle to Terminal server
 *    ProcessId (input)
 *       process id of the process to terminate
 *    ExitCode (input)
 *       Termination status for each thread in the process
 *
 *
 * EXIT:
 *
 *    TRUE  -- The terminate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOL WINAPI
WTSTerminateProcess(
                   HANDLE hServer,
                   DWORD ProcessId,
                   DWORD ExitCode
                   )
{
    return( WinStationTerminateProcess( hServer, ProcessId, ExitCode ) );
}
#if(WINVER >= 0x0500)
//======================================================================//
// Private functions                                                    //
//======================================================================//
BOOL
GetProcessSid(HANDLE          hServer,
              HANDLE          hUniqueProcessId,
              LARGE_INTEGER    ProcessStartTime,
              PBYTE *          ppSid                     //Return the SID (allocated here..)
             )
{
    DWORD dwSidSize;
    BYTE  tmpSid[128];      //temp storage
    FILETIME  startTime;

    dwSidSize = sizeof(tmpSid);
    *ppSid =  NULL;

    //Convert the time format
    startTime.dwLowDateTime = ProcessStartTime.LowPart;
    startTime.dwHighDateTime = ProcessStartTime.HighPart;

    //-------------------------------------------//
    // Get the SID with the temp Sid storage     //
    //-------------------------------------------//
    if (!WinStationGetProcessSid(hServer,
                                 (DWORD)(ULONG_PTR)hUniqueProcessId,
                                 startTime,
                                 (PBYTE)&tmpSid,
                                 &dwSidSize
                                )) {
        //-------------------------------------------//
        // Sid is too big for the temp storage       //
        //Get the size of the sid and do it again    //
        //-------------------------------------------//
        NTSTATUS status;
        if ((status = GetLastError()) == STATUS_BUFFER_TOO_SMALL) {
            *ppSid = LocalAlloc(LPTR, dwSidSize);
            if (!*ppSid) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto ErrorReturn;
            }
        } else if (dwSidSize == 0) {
            *ppSid = NULL;
            return TRUE;
        } else {
            SetLastError(status);
            goto ErrorReturn;
        }
        //-------------------------------------------//
        // Call the server again to get the SID
        //-------------------------------------------//
        if (!WinStationGetProcessSid(hServer,
                                     (DWORD)(ULONG_PTR)hUniqueProcessId,
                                     startTime,
                                     (PBYTE)ppSid,
                                     &dwSidSize
                                    )) {
            goto ErrorReturn;
        }

    } else {

        //-------------------------------------------//
        // Temp Sid is large enough                  //
        // Allocate the correct size and copy the    //
        // Sid                                       //
        //-------------------------------------------//
        *ppSid = LocalAlloc(LPTR, dwSidSize);
        if (*ppSid) {
            memcpy(*ppSid, tmpSid, dwSidSize);
        } else {
            SetLastError(ERROR_OUTOFMEMORY);
            goto ErrorReturn;
        }
    }

    return TRUE;
ErrorReturn:
    if (*ppSid) {
        LocalFree(*ppSid);
        *ppSid = NULL;
    }
    return FALSE;
}
#endif //#if(WINVER >= 0x0500)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\amd64mk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    amd64mk.inc

Abstract:

        This module contains the x86 specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
DELAYLOAD_VERSION=0x0200
!endif

#
# AMD64 option control
#
UMBASE=$(UMBASE:*=amd64)
UMLIBS=$(UMLIBS:*=amd64)
NTRES=$(NTRES:*=amd64)
UMRES=$(UMRES:*=amd64)
UMOBJS=$(UMOBJS:*=amd64)
LINKLIBS=$(LINKLIBS:*=amd64)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=amd64)
DLLBASE=$(DLLBASE:*=amd64)
DLLDEF=$(DLLDEF:*=amd64)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=amd64)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=amd64)
DYNLINK_LIB=$(DYNLINK_LIB:*=amd64)
TARGETEXEFILES=$(TARGETEXEFILES:*=amd64)
TARGETLIBFILES=$(TARGETLIBFILES:*=amd64)
TARGETOBJFILES=$(TARGETOBJFILES:*=amd64)
UMOBJFILES=$(UMOBJFILES:*=amd64)
UMEXEFILES=$(UMEXEFILES:*=amd64)
HEADERFILE=$(HEADERFILE:*=amd64)
HEADEROBJNAME=$(HEADEROBJNAME:*=amd64)
HEADEROBJ=$(HEADEROBJ:*=amd64)
PRECOMPILED=$(PRECOMPILED:*=amd64) /d1noWchar_t
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=amd64) /d1noWchar_t
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=amd64)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=amd64)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=amd64)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=amd64)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=amd64)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=amd64)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=amd64)
PROCESSOR_LIB_PATH=$(PROCESSOR_LIB_PATH:*=amd64)
ORDER=$(ORDER:*=amd64)
OBJLIBFILES=$(OBJLIBFILES:*=amd64)
MISCFILES=$(MISCFILES) $(AMD64_MISCFILES)

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS) $(SDK_LIB_PATH)\atlamd64.lib

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=amd64)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=amd64)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=amd64)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=amd64)
!endif

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=

DEFAULT_STACKRESERVE=0x40000
DEFAULT_STACKCOMMIT=0x1000

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS)

!IFDEF AMD64_WARNING_LEVEL
MSC_WARNING_LEVEL=$(AMD64_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Wp64 /WX

!ifdef AMD64_PERFFLAGS
PERFFLAGS = $(AMD64_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(AMD64_OPTIMIZATION)
MSC_OPTIMIZATION=$(AMD64_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

WIN32_LIBS=$(WIN32_LIBS) $(LIBRARY_PATH)\ntdll.lib

!IFDEF AMD64_CPPFLAGS
MSC_CPPFLAGS=$(AMD64_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=$(EH_FLAGS) /EHa
!endif
!else
EH_FLAGS=/GX-
!endif

! ifdef USE_RTTI
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif


!ifdef USE_INCREMENTAL_COMPILING
C_INCREMENTAL_FLAG = /Gi
USE_PDB_TO_COMPILE = 1
!else
C_INCREMENTAL_FLAG = /Gi-
!undef USE_PDB_TO_COMPILE
!endif

!ifndef AMD64_CPU_OPTIMIZATION
AMD64_CPU_OPTIMIZATION=
!endif

STDFLAGS= /c /Zel /Zp8 /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(AMD64_CPU_OPTIMIZATION) $(C_INCREMENTAL_FLAG) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING)

!if $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!else
AMD64_ADBGFLAGS=$(AMD64_ADBGFLAGS) /Zi
!endif

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
AMD64_ADBGFLAGS=$(AMD64_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
USE_PDB=1
!ENDIF
# @@END_DDKSPLIT

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\AMD64^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
!  ifndef ROOT
ROOT=$(MAKEDIR)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(ROOT)\$(_OBJ_DIR)\amd64\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\amd64^\
! endif
!endif

#
# amd64 option control
#

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF

STD_DEFINES=-D_WIN64 -D_AMD64_ -DAMD64 $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

#
# This indicates that we are compiling for a siulated (i.e. slow)
# environment.
#
# Remove this when we get a faster environment.
#

STD_DEFINES=$(STD_DEFINES)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
CFLAGS=$(AMD64_FLAGS) $(NTAMD64FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
AMD64_ASMFLAGS=$(AMD64_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

AMD64_CDEFINES=$(CDEFINES)
AMD64_CFLAGS=$(CFLAGS)

CC_NAME = cl -nologo

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef AMD64_ASSEMBLER_NAME
AMD64_ASSEMBLER_NAME  = ml64
!endif

GLOBAL_C_FLAGS = -Iamd64\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS) -d2home

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX) $(MSC_CPPFLAGS) $(NTCPPFLAGS)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) /d1noWchar_t -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_ASM_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(ASM_DEFINES) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

AMD64_ASSEMBLER=$(AMD64_ASSEMBLER_NAME) -c -coff -Cx -nologo -Iamd64\ -I. $(INCPATH1) $(AMD64_ASMFLAGS)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)

ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)


{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

#
# Here is a workaround for a masm code generation bug having to do with
# broken interaction between the preprocessor and the code generator.
#
# The workaround is to generate a preprocessed file first, then assemble
# that.  When the assembler is fixed, delete the following !if-related
# statements and the stuff in the !else block.
#

{..\amd64\}.asm{}.pp:
    $(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$@

{amd64\}.asm{}.pp:
    $(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$@

!if 1

{..\amd64\}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\amd64\$(@B).obj $(MAKEDIR)\$<

{amd64\}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\amd64\$(@B).obj $(MAKEDIR)\$<

{..\amd64\}.asm{$(_OBJ_DIR)\amd64\}.obj:
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{amd64\}.asm{$(_OBJ_DIR)\amd64\}.obj:
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{$(O)\}.asm{$(O)\}.obj:
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

!else

{..\amd64\}.asm{}.lst:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\amd64\$(@B).obj $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

{amd64\}.asm{}.lst:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\amd64\$(@B).obj $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

{..\amd64\}.asm{$(_OBJ_DIR)\amd64\}.obj:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

{amd64\}.asm{$(_OBJ_DIR)\amd64\}.obj:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

{$(O)\}.asm{$(O)\}.obj:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

!endif

!IFDEF _NTAMD64LIBS
_NTLIBS=$(_NTAMD64LIBS)
!ENDIF

COPYDST=$(AMD64COPYDST)
LIB_COPY=ntamd64cp.cmd

!IF "$(NTDEBUGTYPE)" == "windbg" || "$(NTDEBUGTYPE)" == "both"
NTTEST_LINK_OPTIONS=-entry:KiSystemStartup
!ELSE
NTTEST_LINK_OPTIONS=-base:0x80100000 -entry:KiSystemStartup
!ENDIF

LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98

DRIVER_ALIGNMENT=0x0080
KERNEL_ALIGNMENT=0x1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\ia64mk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    ia64mk.inc

Abstract:

        This module contains the ia64 specific build controls.  It is included
        by makefile.def.

        Add the following variable to your env.

        1) To turn on IA64 hazard detection:

                    set _IA64_HAZARD_DETECTION=-X explicit

        2) To turn on Merced MSR access, add the following variable to your env.

                    set _IA64_MERCED_MSR =-A MERCED

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
DELAYLOAD_VERSION=0x0200
!endif

#
# ia64 option control
#

!undef USE_MAPSYM
!undef USE_CV
USE_PDB=1

UMBASE=$(UMBASE:*=ia64)
UMLIBS=$(UMLIBS:*=ia64)
NTRES=$(NTRES:*=ia64)
UMRES=$(UMRES:*=ia64)
UMOBJS=$(UMOBJS:*=ia64)
LINKLIBS=$(LINKLIBS:*=ia64)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=ia64)
DLLBASE=$(DLLBASE:*=ia64)
DLLDEF=$(DLLDEF:*=ia64)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=ia64)
TARGET=$(TARGET:*=ia64)
DYNLINK_LIB=$(DYNLINK_LIB:*=ia64)
TARGETEXEFILES=$(TARGETEXEFILES:*=ia64)
TARGETLIBFILES=$(TARGETLIBFILES:*=ia64)
TARGETOBJFILES=$(TARGETOBJFILES:*=ia64)
UMOBJFILES=$(UMOBJFILES:*=ia64)
UMEXEFILES=$(UMEXEFILES:*=ia64)
HEADERFILE=$(HEADERFILE:*=ia64)
HEADEROBJNAME=$(HEADEROBJNAME:*=ia64)
HEADEROBJ=$(HEADEROBJ:*=ia64)
PRECOMPILED=$(PRECOMPILED:*=ia64)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=ia64)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=ia64)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=ia64)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=ia64)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=ia64)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=ia64)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=ia64)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=ia64)
PROCESSOR_LIB_PATH=$(PROCESSOR_LIB_PATH:*=ia64)
ORDER=$(ORDER:*=ia64)
OBJLIBFILES=$(OBJLIBFILES:*=ia64)
MISCFILES=$(MISCFILES) $(IA64_MISCFILES)
# BINPLACE_FLAGS=$(BINPLACE_FLAGS) -CI 8,halo.exe,-certain,-errata,-quiet

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=ia64)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=ia64)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=ia64)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=ia64)
!endif

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=

DEFAULT_STACKRESERVE=0x100000
DEFAULT_STACKCOMMIT=0x4000

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS) $(SDK_LIB_PATH)\atl21asm.lib

!if !defined(_IA64_HAZARD_DETECTION)
_IA64_HAZARD_DETECTION=-X explicit
!endif

!if !defined(_IA64_MERCED_MSR)
_IA64_MERCED_MSR=-A itanium
!endif

!ifndef GENIA64
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Wp64
!endif

!IF DEFINED(IA64_WARNING_LEVEL)
MSC_WARNING_LEVEL=$(IA64_WARNING_LEVEL)
!ENDIF

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!endif

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IF DEFINED(IA64_PERFFLAGS)
PERFFLAGS = $(IA64_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(IA64_OPTIMIZATION)
MSC_OPTIMIZATION=$(IA64_OPTIMIZATION)
!else
!if !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION)
!endif

!ifndef GENIA64
!if defined(IA64_DEBUGGABLE_OPTIMIZATION)
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Zx
!endif
!ifndef IA64_FULL_FLOATING_POINT
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /QIA64_fr32
!endif
LINK_TIME_CODE_GENERATION_MSC_OPTIMIZATION=
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# Some objects must be built native, so turn off GL for those
LINK_TIME_CODE_GENERATION_MSC_OPTIMIZATION=/GL
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) $(LINK_TIME_CODE_GENERATION_MSC_OPTIMIZATION)
!endif
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) -d debug

WIN32_LIBS=$(WIN32_LIBS) $(LIBRARY_PATH)\ntdll.lib

!if defined(IA64_CPPFLAGS)
MSC_CPPFLAGS=$(IA64_CPPFLAGS)
!elseif defined(386_CPPFLAGS)
MSC_CPPFLAGS=$(386_CPPFLAGS)
!ENDIF

!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=$(EH_FLAGS) /EHa
!endif
!else
EH_FLAGS=/GX-
!endif

! ifdef USE_RTTI
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif

!ifdef USE_INCREMENTAL_COMPILING
C_INCREMENTAL_FLAG=/Gi
USE_PDB_TO_COMPILE=1
!else
C_INCREMENTAL_FLAG=/Gi-
!undef USE_PDB_TO_COMPILE
!endif

ERRATA_FLAGS=

STDFLAGS= /c /Zel /Zp8 /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) \
          $(ERATTA_FLAGS) $(C_INCREMENTAL_FLAG) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING)

!IF $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!ELSE
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) -d debug
!ENDIF

# This is only needed on x86
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) -d debug
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
!ENDIF
# @@END_DDKSPLIT

!IFDEF SECTION_ALIGNMENT
SECTION_ALIGNMENT=-align:$(SECTION_ALIGNMENT)
!ENDIF

KERNEL_ALIGNMENT=0x80
HAL_ALIGNMENT=0x80

LINKER_FLAGS = $(LINKER_FLAGS) $(SECTION_ALIGNMENT) -debugtype:pdata

LINK_LIB_IGNORE_FLAG=$(LINK_LIB_IGNORE_FLAG),4006,4044,4108,4088

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
! else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\ia64^\
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\ia64^\
! endif
!endif

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF


#
#
#
!ifdef GENIA64
STD_DEFINES= -D_WIN64 -D_IA64_=1 -DIA64=1 -DNO_HW_DETECT -D_MSC_EXTENSIONS -D_GENIA64_ $(HALDEF) $(STD_DEFINES) -D_CROSS_PLATFORM_=1
!else
STD_DEFINES= -D_WIN64 -D_IA64_=1 -DIA64=1 -DNO_HW_DETECT -D_MSC_EXTENSIONS $(PTR_SIZE) $(HALDEF) $(STD_DEFINES) -D_MERCED_A0_=1
!endif

!if defined(PC98CHANGE)
STD_DEFINES=$(STD_DEFINES) -D_PC98_
!endif

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
ASM_DEFINES=$(ASM_DEFINES) -D__assembler=1
CFLAGS=$(IA64_FLAGS) $(NTIA64FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
IA64_ASMFLAGS=$(IA64_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

IA64_CDEFINES=$(CDEFINES)
IA64_CFLAGS=$(CFLAGS)

CC_NAME = cl -nologo

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef IA64_ASSEMBLER_NAME
IA64_ASSEMBLER_NAME  = ias
!endif

GLOBAL_C_FLAGS = -Iia64\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX) $(MSC_CPPFLAGS) $(NTCPPFLAGS)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_ASM_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(ASM_DEFINES) $(C_PREPROCESSOR_FLAGS:-EP=-E)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

IA64_ASSEMBLER=$(IA64_ASSEMBLER_NAME) $(_IA64_HAZARD_DETECTION) $(_IA64_MERCED_MSR) -Nso -Iia64\ -I. $(INCPATH1) $(IA64_ADBGFLAGS)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)

ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)


{}.c{}.s:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

{..\ia64\}.s{}.lst:
    $(IA64_ASSEMBLER) -o $(_OBJ_DIR)\ia64\$(@B).obj $<

{ia64\}.s{}.lst:
    $(IA64_ASSEMBLER) -o $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(@B).obj $<

{..\ia64\}.s{$(_OBJ_DIR)\ia64\}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $(MAKEDIR)\..\ia64\$(<F) >$(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    $(IA64_ASSEMBLER) -o $(MAKEDIR)\$@ $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i >nul 2>&1

{$(_OBJ_DIR)\ia64\}.s{$(_OBJ_DIR)\ia64\}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<F) >$(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    $(IA64_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i >nul 2>&1

{ia64\}.s{$(_OBJ_DIR)\ia64\}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $(MAKEDIR)\ia64\$(<F) >$(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    $(IA64_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i >nul 2>&1


!if defined(_NTIA64LIBS)
_NTLIBS=$(_NTIA64LIBS)
!elseif DEFINED(_NT386LIBS)
_NTLIBS=$(_NT386LIBS)
!endif

!if defined(IA64COPYDST)
COPYDST=$(IA64COPYDST)
!elseif defined(386COPYDST)
COPYDST=$(386COPYDST)
!endif
LIB_COPY=ntia64cp.cmd

NTTEST_LINK_OPTIONS=-section:ivt,,align=0x8000 -fixed:no -base:0xE000000083000000 -entry:KiSystemBegin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\i386mk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    i386mk.inc

Abstract:

        This module contains the x86 specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
DELAYLOAD_VERSION=0x0200
!endif

#
# x86 option control
#
UMBASE=$(UMBASE:*=i386)
UMLIBS=$(UMLIBS:*=i386)
NTRES=$(NTRES:*=i386)
UMRES=$(UMRES:*=i386)
UMOBJS=$(UMOBJS:*=i386)
LINKLIBS=$(LINKLIBS:*=i386)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=i386)
DLLBASE=$(DLLBASE:*=i386)
DLLDEF=$(DLLDEF:*=i386)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=i386)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=i386)
DYNLINK_LIB=$(DYNLINK_LIB:*=i386)
TARGETEXEFILES=$(TARGETEXEFILES:*=i386)
TARGETLIBFILES=$(TARGETLIBFILES:*=i386)
TARGETOBJFILES=$(TARGETOBJFILES:*=i386)
UMOBJFILES=$(UMOBJFILES:*=i386)
UMEXEFILES=$(UMEXEFILES:*=i386)
HEADERFILE=$(HEADERFILE:*=i386)
HEADEROBJNAME=$(HEADEROBJNAME:*=i386)
HEADEROBJ=$(HEADEROBJ:*=i386)
PRECOMPILED=$(PRECOMPILED:*=i386)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=i386)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=i386)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=i386)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=i386)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=i386)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=i386)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=i386)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=i386)
PROCESSOR_LIB_PATH=$(PROCESSOR_LIB_PATH:*=i386)
ORDER=$(ORDER:*=i386)
OBJLIBFILES=$(OBJLIBFILES:*=i386)
MISCFILES=$(MISCFILES) $(I386_MISCFILES)

!ifdef CHICAGO_PRODUCT
USE_MAPSYM=1
!endif

# "$(TARGETTYPE)"=="DRIVER"     ||
# "$(TARGETTYPE)" == "HAL" ||
# "$(TARGETTYPE)" == "EXPORT_DRIVER" ||

!IF "$(TARGETTYPE)"=="GDI_DRIVER" || \
    "$(TARGETTYPE)"=="MINIPORT"
#
#Drivers don't link with link libs.
#
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!ELSE
!IF defined(USE_NTDLL) || defined (USE_NOLIBS)
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!ENDIF
!ENDIF

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=i386)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=i386)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=i386)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=i386)
!endif

!IF "$(DLLENTRY)" != "-noentry"
!   IF "$(DLLENTRY:@12=)" == "$(DLLENTRY)"
DLLENTRY=$(DLLENTRY)@12
!   ENDIF
!ENDIF

!IFDEF STD_CALL_ENTRY
UMENTRY=$(UMENTRY)@4
!ENDIF

ENTRY_SUFFIX=@8
GDI_ENTRY_SUFFIX=@12

DEFAULT_STACKRESERVE=0x40000
DEFAULT_STACKCOMMIT=0x1000

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS)

!IFDEF 386_WARNING_LEVEL
MSC_WARNING_LEVEL=$(386_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!ifdef 386_PERFFLAGS
PERFFLAGS = $(386_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(386_OPTIMIZATION)
MSC_OPTIMIZATION=$(386_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

LINK_TIME_CODE_GENERATION_MSC_OPTIMIZATION=
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# Some objects must be built native, so turn off GL for those
LINK_TIME_CODE_GENERATION_MSC_OPTIMIZATION=/GL
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) $(LINK_TIME_CODE_GENERATION_MSC_OPTIMIZATION)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

!IFDEF 386_CPPFLAGS
MSC_CPPFLAGS=$(386_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=$(EH_FLAGS) /EHa
!endif
!else
EH_FLAGS=/GX-
!endif

!ifdef USE_RTTI
RTTI_FLAGS=/GR
!else
RTTI_FLAGS=/GR-
!endif

!ifdef BUFFER_OVERFLOW_CHECKS
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!endif

!ifdef USE_INCREMENTAL_COMPILING
C_INCREMENTAL_FLAG = /Gi /Gm
USE_PDB_TO_COMPILE = 1
!else
C_INCREMENTAL_FLAG = /Gi- /Gm-
!undef USE_PDB_TO_COMPILE
!endif

!ifndef X86_CPU_OPTIMIZATION
X86_CPU_OPTIMIZATION=/G6
!endif

!if defined(VC7_SYMBOLS) || ("$(TARGETTYPE)" == "GDI_DRIVER") || ("$(TARGETTYPE)" == "DRIVER") || ("$(TARGETTYPE)" == "EXPORT_DRIVER")
!if [set _CL_=]
!endif
!if [set _LINK_=]
!endif
!if [set _ML_=]
!endif
!endif


# Undocumented switch definitions
# /QIfdiv- : Don't emit code to test for bad pentiums
# /QIf     : Emit FPO records for every function

ERATTA_FLAGS=/QIfdiv- /QIf

STDFLAGS= /c /Zel /Zp8 /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(X86_CPU_OPTIMIZATION) $(C_INCREMENTAL_FLAG) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING) $(BO_FLAGS)

!IF "$(386_STDCALL)" == "0"
MSC_CALL_TYPE=/Gd
MSC_CALL_DEFINE=
!ELSE
!   IF "$(386_STDCALL)" == "2"
MSC_CALL_TYPE=/Gr
MSC_CALL_DEFINE=
!   ELSE
MSC_CALL_TYPE=/Gz
MSC_CALL_DEFINE=-DSTD_CALL
!   ENDIF
!ENDIF

!IF $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!   IFDEF NTNOFPO
!MESSAGE $(NTMAKEENV)\i386mk.inc(1) : Overriding FPO default with NTNOFPO
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-
!   ELSE
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=1
DBGFLAGS=$(DBGFLAGS) /Oy
!   ENDIF
!ELSE
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
!ENDIF

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
USE_PDB=1
!ENDIF
# @@END_DDKSPLIT

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
!  ifndef ROOT
ROOT=$(MAKEDIR)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(ROOT)\$(_OBJ_DIR)\i386\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\i386^\
! endif
!endif

#
# 386 option control
#

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF

STD_DEFINES= -D_X86_=1 -Di386=1 $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)

!ifdef MANAGED_CXX
CFLAGS=/clr $(CFLAGS)
!endif

386_ASMFLAGS=$(386_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

386_CDEFINES=$(CDEFINES)
386_CFLAGS=$(CFLAGS)

!if "$(SUBSTITUTE_386_CC)" != ""
CC_NAME = $(SUBSTITUTE_386_CC) -nologo
!else
CC_NAME = cl -nologo
!endif

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
CS_COMPILER_NAME    = csc.exe -nologo
VB_NET_COMPILER_NAME = vbc.exe -nologo

!if "$(UNSAFE_CODE)" != ""
UNSAFE_CODE=/unsafe
!endif

MANAGED_STD_FLAGS        = /warnaserror+ $(UNSAFE_CODE) $(USER_CS_FLAGS) $(USER_VB_NET_FLAGS)

!if defined(PERF_INSTRUMENTATION)
MANAGED_STD_FLAGS=$(MANAGED_STD_FLAGS) /define:PROFILE
!endif

!ifndef 386_ASSEMBLER_NAME
386_ASSEMBLER_NAME  = ml
!endif

GLOBAL_C_FLAGS = -Ii386\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX) $(MSC_CPPFLAGS) $(NTCPPFLAGS)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS) 

!if defined(NOMASMCOMPATIBILITY)
386_ASSEMBLER=$(386_ASSEMBLER_NAME) -c -coff -Cx -nologo -Ii386\ -I. $(INCPATH1) $(386_ASMFLAGS)
!else
386_ASSEMBLER=$(386_ASSEMBLER_NAME) -c -coff -Cx -nologo -Ii386\ -I. $(INCPATH1) -Zm $(386_ASMFLAGS)
!endif

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)

ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) \
               $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)


{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

{..\i386\}.asm{}.lst:
    $(386_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\i386\$(@B).obj $(MAKEDIR)\$<

{i386\}.asm{}.lst:
    $(386_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\i386\$(@B).obj $(MAKEDIR)\$<

{..\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{$(_OBJ_DIR)\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

!IFDEF _NT386LIBS
_NTLIBS=$(_NT386LIBS)
!ENDIF

COPYDST=$(386COPYDST)
LIB_COPY=nti386cp.cmd

!IF "$(NTDEBUGTYPE)" == "windbg" || "$(NTDEBUGTYPE)" == "both"
NTTEST_LINK_OPTIONS=-entry:KiSystemStartup@4
!ELSE
NTTEST_LINK_OPTIONS=-base:0x80100000 -entry:KiSystemStartup@4
!ENDIF

!if defined(LINKER_WIN98OPT) || defined (CHICAGO_PRODUCT)
LINKER_FLAGS=$(LINKER_FLAGS) /opt:win98
!else
LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98
!endif

# SEH support for libs built with an older compiler
# @@BEGIN_DDKSPLIT
!if 0
# @@END_DDKSPLIT
!if defined(_NT_TARGET_VERSION)
!    if $(_NT_TARGET_VERSION) < 0x501 && $(_NT_TOOLS_VERSION) >= 0x700
TARGETLIBS=$(TARGETLIBS) $(DDK_LIB_PATH)\sehupd.lib
!    endif
!endif
# @@BEGIN_DDKSPLIT
!endif
# @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\projects.inc ===
ADMIN_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Admin\inc
ADMIN_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Admin\lib
ADMIN_LIB_PATH=$(ADMIN_LIB_DEST)\$(TARGET_DIRECTORY)

BASE_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Base\inc
BASE_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Base\lib
BASE_LIB_PATH=$(BASE_LIB_DEST)\$(TARGET_DIRECTORY)

COM_INC_PATH=$(PUBLIC_INTERNAL_PATH)\COM\inc
COM_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\COM\lib
COM_LIB_PATH=$(COM_LIB_DEST)\$(TARGET_DIRECTORY)

DRIVERS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Drivers\inc
DRIVERS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Drivers\lib
DRIVERS_LIB_PATH=$(DRIVERS_LIB_DEST)\$(TARGET_DIRECTORY)

DS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\DS\inc
DS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\DS\lib
DS_LIB_PATH=$(DS_LIB_DEST)\$(TARGET_DIRECTORY)

ENDUSER_INC_PATH=$(PUBLIC_INTERNAL_PATH)\EndUser\inc
ENDUSER_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\EndUser\lib
ENDUSER_LIB_PATH=$(ENDUSER_LIB_DEST)\$(TARGET_DIRECTORY)

INETCORE_INC_PATH=$(PUBLIC_INTERNAL_PATH)\InetCore\inc
INETCORE_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\InetCore\lib
INETCORE_LIB_PATH=$(INETCORE_LIB_DEST)\$(TARGET_DIRECTORY)

INETSRV_INC_PATH=$(PUBLIC_INTERNAL_PATH)\InetSrv\inc
INETSRV_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\InetSrv\lib
INETSRV_LIB_PATH=$(INETSRV_LIB_DEST)\$(TARGET_DIRECTORY)

MULTIMEDIA_INC_PATH=$(PUBLIC_INTERNAL_PATH)\MultiMedia\inc
MULTIMEDIA_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\MultiMedia\lib
MULTIMEDIA_LIB_PATH=$(MULTIMEDIA_LIB_DEST)\$(TARGET_DIRECTORY)

NET_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Net\inc
NET_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Net\lib
NET_LIB_PATH=$(NET_LIB_DEST)\$(TARGET_DIRECTORY)

PRINTSCAN_INC_PATH=$(PUBLIC_INTERNAL_PATH)\PrintScan\inc
PRINTSCAN_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\PrintScan\lib
PRINTSCAN_LIB_PATH=$(PRINTSCAN_LIB_DEST)\$(TARGET_DIRECTORY)

SDKTOOLS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\SdkTools\inc
SDKTOOLS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\SdkTools\lib
SDKTOOLS_LIB_PATH=$(SDKTOOLS_LIB_DEST)\$(TARGET_DIRECTORY)

SHELL_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Shell\inc
SHELL_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Shell\lib
SHELL_LIB_PATH=$(SHELL_LIB_DEST)\$(TARGET_DIRECTORY)

TERMSRV_INC_PATH=$(PUBLIC_INTERNAL_PATH)\TermSrv\inc
TERMSRV_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\TermSrv\lib
TERMSRV_LIB_PATH=$(TERMSRV_LIB_DEST)\$(TARGET_DIRECTORY)

WINDOWS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Windows\inc
WINDOWS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Windows\lib
WINDOWS_LIB_PATH=$(WINDOWS_LIB_DEST)\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\mppcmk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    mppcmk.inc

Abstract:

	This module contains the MPPC specific build controls.  It is included
	by makefile.def.

Revision History:

!ENDIF

# add the powermac stuff to the path
PATH=$(IMPORT)\msdev\bin\mppc;$(PATH)

#
# MPPC option control
#

!undef USE_MAPSYM

UMBASE=$(UMBASE:*=mppc)
UMLIBS=$(UMLIBS:*=mppc)
NTRES=$(NTRES:*=mppc)
UMRES=$(UMRES:*=mppc)
UMOBJS=$(UMOBJS:*=mppc)
LINKLIBS=$(LINKLIBS:*=mppc)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=mppc)
DLLBASE=$(DLLBASE:*=mppc)
DLLDEF=$(DLLDEF:*=mppc)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=mppc)
TARGET=$(TARGET:*=mppc)
DYNLINK_LIB=$(DYNLINK_LIB:*=mppc)
TARGETEXEFILES=$(TARGETEXEFILES:*=mppc)
TARGETLIBFILES=$(TARGETLIBFILES:*=mppc)
TARGETOBJFILES=$(TARGETOBJFILES:*=mppc)
UMOBJFILES=$(UMOBJFILES:*=mppc)
UMEXEFILES=$(UMEXEFILES:*=mppc)
HEADERFILE=$(HEADERFILE:*=mppc)
HEADEROBJNAME=$(HEADEROBJNAME:*=mppc)
HEADEROBJ=$(HEADEROBJ:*=mppc)
PRECOMPILED=$(PRECOMPILED:*=mppc)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=mppc)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=mppc)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=mppc)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=mppc)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=mppc)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=mppc)
ORDER=$(ORDER:*=mppc)
MISCFILES=$(MISCFILES) $(MPPC_MISCFILES)

#
# Include 64-bit helper library
#
!if "$(TARGETTYPE)" == "DRIVER"     || \
    "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
    "$(TARGETTYPE)" == "HAL" || \
    "$(TARGETTYPE)" == "GDI_DRIVER" || \
    "$(TARGETTYPE)" == "MINIPORT"
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!elseif defined(USE_NTDLL) || \
     defined(USE_SYSDLL) || \
     defined (USE_NOLIBS)
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
! if "$(UMTYPE)" == "nt" || \
     "$(UMTYPE)" == "ntss"
# Do this to avoid multiple library warnings (and allow building csr/server)
UMLIBS=$(SDK_LIB_PATH)\int64.lib $(UMLIBS)
! endif
!elseif "$(UMTYPE)" == "nt" || \
        "$(UMTYPE)" == "ntss"
UMLIBS=$(SDK_LIB_PATH)\int64.lib $(UMLIBS)
!endif

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=mppc)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=mppc)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=mppc)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=mppc)
!endif

!IF "$(GPSIZE)" != "0"
#
# GPSIZE is irrelevant on PowerPC
#
LINKGPSIZE=
!ENDIF

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=


!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
! else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\mppc^\
! endif
!endif

!ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\mppc^\
!endif

!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Z7
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
USE_PDB=1
!ENDIF

!IFDEF MPPC_WARNING_LEVEL
MSC_WARNING_LEVEL=$(MPPC_WARNING_LEVEL)
!ENDIF

!ifdef MPPC_PERFFLAGS
PERFFLAGS = $(MPPC_PERFFLAGS)
!endif

# DEFAULT_MSC_OPT = $(DEFAULT_MSC_OPT:/Oxs=/Ox)

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(MPPC_OPTIMIZATION)
MSC_OPTIMIZATION=$(MPPC_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

!IFDEF MPPC_CPPFLAGS
MSC_CPPFLAGS=$(MPPC_CPPFLAGS)
!ENDIF

!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX /GR
!else
EH_FLAGS=/GX- /GR-
!endif

MPPC_AS=pas
MPPC_DIS=pdis
MPPC_AS_WARNINGS=

MPPC_START_FILE=start.obj

ENV_DEFINES=$(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MSC_CPPFLAGS) $(NTCPPFLAGS) $(PM_DEFINES)
STD_DEFINES=-DMPPC=1 -D_MPPC_=1 -DNO_EXT_KEYS $(STD_DEFINES) -D_MAC

STDFLAGS=-c -Zel -Zp2 -Gy $(STRING_POOLING) $(EH_FLAGS)

MPPC_C_COMPILER_NAME = cl -nologo
# MPPC_C_COMPILER_NAME = cl
MPPC_CC = $(MPPC_C_COMPILER_NAME)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) $(ENV_DEFINES) $(MFC_DEFINES)
CFLAGS=$(MPPC_FLAGS) $(NTMPPCFLAGS) $(STDFLAGS) $(DBGFLAGS) $(USER_C_FLAGS) $(PERFFLAGS)

MPPC_CDEFINES= $(CDEFINES)
MPPC_CFLAGS  = $(CFLAGS)  $(MSC_WARNING_LEVEL) # -DALLOC_TEXT

!IFNDEF MPPC_OPTIONS
MPPC_OPTIONS=
!ENDIF

C_COMPILER_NAME      = $(MPPC_C_COMPILER_NAME)
C_PREPROCESSOR_NAME  = $(MPPC_C_COMPILER_NAME)
CXX_COMPILER_NAME    = $(MPPC_C_COMPILER_NAME)

GLOBAL_C_FLAGS       = -nologo -Imppc\ -I. $(INCPATH0) $(CDEFINES) $(MPPC_OPTIONS) \
                        $(MPPC_CFLAGS) -D__stdcall= -D__cdecl= -DFPO=1 -DLANGUAGE_C

# Disable -WX for now, unless explicitly allowed

!ifndef ALLOW_WX
GLOBAL_C_FLAGS = $(GLOBAL_C_FLAGS:-WX=)
GLOBAL_C_FLAGS = $(GLOBAL_C_FLAGS:/WX=)
!endif

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) $(PRECOMPILED) -EP -Tc

C_PREPROCESSOR       = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_COMPILER           = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
CXX_COMPILER         = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

MPPC_ASSEMBLER        = $(MPPC_AS) $(MPPC_AS_WARNINGS)

ECHO_MSG             = ClPpc $< " $(C_COMPILER) "
ECHO_CXX_MSG         = ClPpc $< " $(CXX_COMPILER) "

ECHO_PRECOMPILED_MSG1=CpPpc $(PRECOMPILED_INCLUDE) \
                     "$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) \
		      $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)"

ECHO_PRECOMPILED_MSG2=CpPpc $(PRECOMPILED_INCLUDE) \
                     "$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) \
		      $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)"

{.\}.cxx{}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{.\}.cxx{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{}.cxx{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{..\mppc\}.s{$(_OBJ_DIR)\mppc\}.obj:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\..\mppc\$(<F) > $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i && $(MPPC_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i >nul 2>&1

{..\mppc\}.s.pp:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\..\mppc\$(<F) > $(MAKEDIR)\$(<B).pp

{mppc\}.s{$(_OBJ_DIR)\mppc\}.obj:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\mppc\$(<F) > $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i && $(MPPC_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i >nul 2>&1

{mppc\}.s.pp:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\mppc\$(<F) > $(MAKEDIR)\$(<B).pp

.SUFFIXES: .il

{}.il{}.cod:
    @-erase $@ >nul 2>&1
    @echo cl $<" $(C_COMPILER) "
    @$(C_COMPILER) -FAac -Fa$(<B).cod -B1..\bootbin\null.exe -Bk$(<B). -Fo$(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).o $(MAKEDIR)\$(<B).c
    @del $(_OBJ_DIR)\mppc\$(<B).o

!IFDEF CAIRO_PRODUCT
!IFDEF _CAIROMPPCTREE
_NTTREE=$(_CAIROMPPCTREE)
_NTTREE_NO_SPLIT=$(_CAIROMPPCTREE_NS)
!ENDIF
!ELSE
!IFDEF _NTMPPCTREE
_NTTREE=$(_NTMPPCTREE)
_NTTREE_NO_SPLIT=$(_NTMPPCTREE_NS)
!ENDIF
!ENDIF

!IFDEF _NTMPPCLIBS
_NTLIBS=$(_NTMPPCLIBS)
!ENDIF

COPYDST=$(MPPCCOPYDST)

LIB_COPY=ntmppccp.cmd

NTTEST_LINK_OPTIONS= -base:0x80010000 -entry:KiSystemStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\sp\data\baseaddress.x86.fre.cs ===
77330000 00090000 comctl32.dll
0fda0000 00030000 sccbase.dll
0fdd0000 00050000 slbcsp.dll
0fe20000 00180000 gpkcsp.dll
0ff80000 00020000 vdmredir.dll
0ff80000 000b0000 ntvdm.exe
0ffa0000 00010000 vcdex.dll
0ffa0000 00030000 dssenh.dll
0ffb0000 00050000 wow32.dll
0ffd0000 00030000 rsaenh.dll
47c80000 00010000 zextens.dll
47c90000 00010000 winclip.dll
47cb0000 00020000 ulkd.dll
47cd0000 00040000 traceprt.dll
47d10000 00020000 timerw32.dll
47d30000 00010000 statw32.dll
47d40000 00010000 secedt.dll
47d50000 00020000 sdbapiu.dll
47d70000 00020000 sdbapi.dll
47d90000 00020000 rwwin32.dll
47db0000 00010000 rwwin16.dll
47dc0000 00020000 rwres32.dll
47de0000 00020000 rwmac.dll
47e00000 00010000 rwinf.dll
47e20000 00010000 rcdata1.dll
47e30000 00010000 pptpkdx.dll
47e40000 00030000 ndrexts.dll
47e70000 00010000 nclipps.dll
47e80000 00040000 msiauto.dll
47ec0000 00010000 mepparty.dll
47ed0000 00020000 lsaexts.dll
47ef0000 00010000 irdakdx.dll
47f00000 00010000 iodll.dll
47f10000 00010000 dtext.dll
47f20000 00010000 depends.dll
47f30000 00010000 cxxflt.dll
47f40000 00010000 certexts.dll
47f50000 00010000 autosock.dll
47f60000 00020000 apidll.dll
47fb0000 00050000 adsiedit.dll
4be40000 00010000 wst.dll
4be90000 00010000 ulcase.dll
4bea0000 00010000 tglcase.dll
4beb0000 00010000 setupexts.dll
4bec0000 00010000 redbook.dll
4bed0000 00010000 pmatch.dll
4bee0000 00040000 msjvc.dll
4bf20000 00010000 mshelp.dll
4bf30000 00010000 mhelp.dll
4bf40000 00010000 justify.dll
4bf50000 00020000 jps.dll
4bf80000 00030000 iviewers.dll
4bfb0000 00030000 hwdll.dll
4bfe0000 00010000 filter.dll
4bff0000 00010000 dflayout.dll
4fae0000 00010000 shlexts.dll
4fb00000 00070000 msvcrtd.dll
4fb70000 00020000 msvcr40d.dll
4fb90000 00020000 msvcirtd.dll
4fbb0000 000d0000 mfco42ud.dll
4fc80000 000d0000 mfco42d.dll
4fd50000 00010000 mfcn42ud.dll
4fd60000 00010000 mfcn42d.dll
4fd70000 00050000 mfcd42ud.dll
4fdc0000 00050000 mfcd42d.dll
4fe10000 000f0000 mfc42ud.dll
4ff00000 000f0000 mfc42d.dll
4fff0000 00010000 conexts.dll
57e70000 00040000 unimdm.tsp
57eb0000 00020000 remotesp.tsp
57ed0000 00010000 ndptsp.tsp
57ef0000 00010000 kmddsp.tsp
57f00000 00010000 ipconf.tsp
57f10000 00010000 hidphone.tsp
57f20000 00050000 h323.tsp
57f70000 00070000 wmvds32.ax
57fe0000 00070000 wmv8ds32.ax
58050000 00010000 wiasf.ax
58060000 00010000 vbisurf.ax
58070000 00010000 psisrndr.ax
58080000 00020000 phdsext.ax
580a0000 00020000 msscds32.ax
580c0000 00010000 msdvbnp.ax
580d0000 00040000 msadds32.ax
58110000 00070000 mpg4ds32.ax
58180000 00030000 mpg2splt.ax
581b0000 00010000 ksxbar.ax
581c0000 00020000 kswdmcap.ax
581e0000 00010000 kstvtune.ax
58200000 00020000 ksproxy.ax
58230000 00030000 ivfsrc.ax
58260000 000e0000 ir41_32.ax
58340000 00010000 ipsink.ax
58350000 00040000 iac25_32.ax
58390000 00010000 g711codc.ax
583a0000 00010000 dshowext.ax
583b0000 00020000 camext30.ax
583e0000 00040000 camext20.ax
58420000 00020000 camexo20.ax
58440000 00010000 bdaplgin.ax
58450000 00010000 agcgauge.ax
58460000 00020000 acelpdec.ax
58480000 00010000 tssoft32.acm
58490000 00020000 sl_anet.acm
584b0000 00010000 msgsm32.acm
584c0000 00020000 msg723.acm
584e0000 00010000 msg711.acm
584f0000 00050000 msaud32.acm
58540000 00090000 l3codeca.acm
585d0000 00010000 imaadp32.acm
585e0000 00020000 wshom.ocx
58600000 00030000 wmp.ocx
58640000 00020000 wmidx.ocx
58660000 00020000 tdc.ocx
58680000 00040000 sysmon.ocx
586c0000 00070000 swflash.ocx
58730000 00020000 proctexe.ocx
58750000 00020000 msscript.ocx
58770000 00020000 logui.ocx
58790000 00020000 ieinfo5.ocx
587b0000 00020000 dmview.ocx
587d0000 00020000 dhtmled.ocx
58800000 00030000 daxctle.ocx
58830000 00020000 cnfgprts.ocx
58850000 00050000 certwiz.ocx
588a0000 00020000 certmap.ocx
588c0000 00020000 asctrls.ocx
588e0000 00020000 timedate.cpl
58900000 00010000 telephon.cpl
58910000 00050000 sysdm.cpl
58960000 00030000 sapi.cpl
58990000 00030000 powercfg.cpl
589c0000 00010000 nwc.cpl
589d0000 00050000 nusrmgr.cpl
58a40000 00010000 ncpa.cpl
58a50000 000a0000 mmsys.cpl
58af0000 00040000 main.cpl
58b30000 00020000 liccpa.cpl
58b50000 00010000 keymgr.cpl
58b60000 00020000 joy.cpl
58b80000 00010000 irprops.cpl
58ba0000 00030000 intl.cpl
58bd0000 00050000 inetcpl.cpl
58c30000 00030000 hdwwiz.cpl
58c60000 00030000 desk.cpl
58c90000 00020000 access.cpl
58cb0000 00050000 msh263.drv
58d00000 00030000 msh261.drv
58d30000 00010000 xxpclru1.dll
58d40000 00030000 xuim750.dll
58d70000 00010000 xrxwbtmp.dll
58d80000 00010000 xrxscnui.dll
58d90000 00040000 xrxnui.dll
58dd0000 00010000 xrxnpcl.dll
58de0000 00030000 xrpr6res.dll
58e10000 00010000 xrpclres.dll
58e20000 00010000 xrenm760.dll
58e30000 00010000 xrenm750.dll
58e40000 00010000 xpclres1.dll
58e50000 00010000 xolehlp.dll
58e60000 00010000 wzcdlg.dll
58e80000 00030000 wuv3is.dll
58eb0000 00010000 wupdinfo.dll
58ec0000 00010000 wstdecod.dll
58ed0000 00010000 wshrm.dll
58ee0000 00010000 wshirda.dll
58ef0000 00010000 wship6.dll
58f00000 00010000 wshcs.dll
58f10000 00010000 wshcon.dll
58f20000 00010000 wshclus.dll
58f30000 00010000 wshatm.dll
58f40000 00090000 wsecedit.dll
58fd0000 00010000 wp9res.dll
58fe0000 00010000 wp24res.dll
58ff0000 00010000 wowfaxui.dll
59000000 00010000 wowfax.dll
59010000 000d0000 wmvdmoe.dll
590e0000 00070000 wmvdmod.dll
59150000 00070000 wmv8dmod.dll
591d0000 00050000 wmstream.dll
59230000 00020000 wmsocm.dll
59250000 00020000 wmsdmoe.dll
59270000 00020000 wmsdmod.dll
59290000 00080000 wmpvis.dll
59320000 00160000 wmpui.dll
59480000 00020000 wmpshell.dll
594a0000 001f0000 wmploc.dll
59690000 00140000 wmpcore.dll
597d0000 00040000 wmpcd.dll
59820000 00040000 wmnetmgr.dll
59860000 00030000 wmmutil.dll
59890000 00050000 wmmres.dll
598f0000 00060000 wmmfilt.dll
59950000 00020000 wmitimep.dll
59970000 00020000 wmisvc.dll
59990000 00010000 wmiscmgr.dll
599b0000 00010000 wmipsess.dll
599c0000 00070000 wmiprvsd.dll
59a30000 00010000 wmiprop.dll
59a40000 00020000 wmipjobj.dll
59a60000 00020000 wmipiprt.dll
59a80000 00020000 wmipicmp.dll
59aa0000 00030000 wmipdskq.dll
59ad0000 00010000 wmipdfs.dll
59ae0000 00030000 wmipcima.dll
59b10000 00030000 wmidcprv.dll
59b40000 00020000 wmicookr.dll
59b60000 00020000 wmiaprpl.dll
59b80000 00010000 wmiapres.dll
59b90000 00010000 wmi2xml.dll
59ba0000 00010000 wmerrenu.dll
59bc0000 00010000 wmerrcsy.dll
59be0000 00010000 wmdmps.dll
59bf0000 00010000 wmdmlog.dll
59c00000 00050000 wmasf.dll
59c50000 00080000 wmadmoe.dll
59cd0000 00040000 wmadmod.dll
59d10000 00020000 wlbsprov.dll
59d30000 00010000 wlbsctrl.dll
59d40000 00010000 wisc10.dll
59d50000 00010000 winstrm.dll
59d60000 000a0000 winssnap.dll
59e00000 00010000 winsrpc.dll
59e10000 00050000 winsmon.dll
59e60000 00010000 winsmib.dll
59e70000 00020000 winsevnt.dll
59e90000 00010000 winsctrs.dll
59f70000 00020000 wsdueng.dll
59f90000 00010000 wsdu.dll
59fb0000 00010000 vidupgrd.dll
59fc0000 00010000 tscomp.dll
5a040000 00010000 tjupg.dll
5a060000 00010000 spxupgrd.dll
5a070000 00020000 eqnupgrd.dll
5a090000 00010000 dgrpupg.dll
5a0a0000 00010000 digpriup.dll
5a0b0000 00020000 digiupg.dll
5a0d0000 00010000 dgupgrd.dll
5a0e0000 00010000 ntdsupg.dll
5a0f0000 00020000 netupgrd.dll
5a120000 00010000 msmqcomp.dll
5a130000 00010000 snadlcug.dll
5a140000 00010000 ntsnaupg.dll
5a150000 00010000 ibmmgug.dll
5a160000 00010000 mdmshrup.dll
5a170000 00010000 inpupgrd.dll
5a180000 00010000 ftcomp.dll
5a190000 00010000 fsfilter.dll
5a1a0000 00010000 cluscomp.dll
5a1d0000 00010000 boscomp.dll
5a1e0000 00010000 apmupgrd.dll
5a1f0000 00170000 winntbbu.dll
5a4d0000 00260000 winnt32u.dll
5a730000 001f0000 winnt32a.dll
5a930000 00020000 hwdb.dll
5a970000 00010000 winmgmtr.dll
5a980000 00030000 wiavusd.dll
5a9b0000 00020000 wiavideo.dll
5a9d0000 00090000 wiashext.dll
5aa60000 00020000 wiascr.dll
5aa80000 00020000 wiamsmud.dll
5aaa0000 00020000 wiafbdrv.dll
5aac0000 00020000 wiadss.dll
5aaf0000 00070000 wiadefui.dll
5ab70000 00030000 webvw.dll
5aba0000 00010000 webhits.dll
5abb0000 00020000 webclnt.dll
5abd0000 00020000 wbemupgd.dll
5abf0000 00010000 wbemperf.dll
5ac00000 00030000 wbemdisp.dll
5ac30000 00030000 wbemcntl.dll
5ac70000 00010000 wbemads.dll
5ac80000 00040000 wavemsp.dll
5acc0000 00010000 wamregps.dll
5acd0000 00010000 wamreg51.dll
5acf0000 00010000 wamreg.dll
5ad00000 00010000 wamps51.dll
5ad10000 00010000 wamps.dll
5ad20000 00020000 wam51.dll
5ad40000 00010000 wam.dll
5ad50000 00020000 wabimp.dll
5ad70000 00010000 wabfind.dll
5ad80000 00040000 wab32res.dll
5add0000 00080000 wab32.dll
5ae50000 00080000 w95upgnt.dll
5aed0000 00010000 w95inf32.dll
5aee0000 00010000 w3tp.dll
5aef0000 00060000 w3svc.dll
5af50000 00010000 w3svapi.dll
5af60000 00010000 w3ssl.dll
5af70000 00010000 w3scfg.dll
5af80000 00010000 w3isapi.dll
5af90000 00020000 w3ext.dll
5afb0000 00010000 w3dt.dll
5afc0000 00010000 w3ctrs51.dll
5afd0000 00010000 w3ctrs.dll
5afe0000 00010000 w3ctrlps.dll
5aff0000 00050000 w3core.dll
5b040000 00010000 w3comlog.dll
5b050000 00010000 w3cache.dll
5b060000 00010000 vwipxspx.dll
5b070000 00020000 vssui.dll
5b090000 00010000 vss_ps.dll
5b0a0000 00010000 vmmreg32.dll
5b0b0000 00010000 vjoy.dll
5b0c0000 00030000 viewprov.dll
5b0f0000 000d0000 vgx.dll
5b1c0000 00010000 vfwwdm32.dll
5b1e0000 00050000 verifier.dll
5b230000 00010000 vdmdbg.dll
5b240000 00010000 vbscs.dll
5b250000 00040000 uxtheme.dll
5b290000 00010000 utildll.dll
5b2a0000 00010000 usrvpa.dll
5b2b0000 00010000 usrvoica.dll
5b2c0000 00010000 usrv80a.dll
5b2d0000 00040000 usrv42a.dll
5b310000 00010000 usrsvpia.dll
5b320000 00010000 usrsdpia.dll
5b330000 00020000 usrrtosa.dll
5b350000 00010000 usrlbva.dll
5b360000 00020000 usrfaxa.dll
5b380000 00060000 usrdtea.dll
5b3e0000 00020000 usrdpa.dll
5b400000 00020000 usrcoina.dll
5b420000 00010000 usrcntra.dll
5b440000 00020000 usbui.dll
5b460000 00040000 upnpui.dll
5b4a0000 00030000 upnphost.dll
5b4d0000 00030000 updprov.dll
5b500000 00050000 untfs.dll
5b550000 00020000 unimdmat.dll
5b570000 00010000 uniansi.dll
5b580000 00010000 umdmxfrm.dll
5b590000 00020000 umaxud32.dll
5b5b0000 00010000 umaxu40.dll
5b5c0000 00010000 umaxu22.dll
5b5d0000 00030000 umaxu12.dll
5b600000 00020000 umaxscan.dll
5b620000 00020000 umaxp60.dll
5b640000 00010000 umaxcam.dll
5b660000 00010000 umandlg.dll
5b670000 00050000 um54scan.dll
5b6c0000 00050000 um34scan.dll
5b710000 00020000 uihelper.dll
5b730000 00020000 ufat.dll
5b750000 00010000 udhisapi.dll
5b760000 00010000 ty2x4res.dll
5b770000 00020000 ty2x3res.dll
5b790000 00020000 txflog.dll
5b7b0000 00010000 twain_32.dll
5b7d0000 00010000 ttyui.dll
5b7e0000 00010000 ttyres.dll
5b7f0000 00010000 tty.dll
5b800000 00010000 tsuserex.dll
5b810000 00010000 tssdjet.dll
5b820000 00020000 tsoc.dll
5b840000 00050000 tshoot.dll
5b890000 00010000 tsec.dll
5b8a0000 00020000 tscfgwmi.dll
5b8c0000 00050000 tscc.dll
5b910000 00010000 tsappcmp.dll
5b930000 00010000 trustmon.dll
5b940000 00020000 trnsprov.dll
5b960000 00010000 trksvr.dll
5b980000 00030000 triedit.dll
5b9b0000 00090000 tridxp.dll
5ba40000 00010000 trialoc.dll
5ba50000 00010000 tp4res.dll
5ba60000 00010000 tp4.dll
5ba70000 00010000 tools.dll
5ba80000 00020000 tmplprov.dll
5baa0000 00010000 tlyp6res.dll
5bab0000 00010000 tly5cres.dll
5bac0000 00010000 tly3res.dll
5bae0000 00010000 tls236.dll
5baf0000 00010000 tlntsvrp.dll
5bb00000 00010000 ti850res.dll
5bb10000 00080000 themeui.dll
5bb90000 00030000 thawbrkr.dll
5bbd0000 00060000 termmgr.dll
5bc30000 00010000 tcpmonui.dll
5bc40000 00010000 tcdata.dll
5bc50000 00020000 tapiui.dll
5bc70000 00050000 tapisnap.dll
5bcc0000 00010000 tapiperf.dll
5bcd0000 000d0000 tapi3.dll
5bda0000 000f0000 t5000uni.dll
5be90000 00010000 t5000ui.dll
5beb0000 00010000 t5000.dll
5bec0000 00010000 t3016.dll
5bed0000 00100000 syssetup.dll
5bfd0000 00030000 sysmod_a.dll
5c000000 00030000 sysmod.dll
5c030000 00010000 sysinv.dll
5c040000 00010000 synceng.dll
5c060000 00020000 sxports.dll
5c0b0000 00010000 swpidflt.dll
5c0c0000 00010000 swpdflt2.dll
5c0d0000 00010000 sw_wheel.dll
5c0f0000 00010000 sw_effct.dll
5c100000 00010000 svcpack.dll
5c110000 00010000 svcext51.dll
5c120000 00010000 svcext.dll
5c140000 00010000 strmfilt.dll
5c150000 00040000 strmdll.dll
5c1a0000 00010000 streamci.dll
5c1b0000 00010000 str9eres.dll
5c1c0000 00020000 str24res.dll
5c1e0000 00020000 storprop.dll
5c200000 00030000 stlnprop.dll
5c230000 00010000 stlncoin.dll
5c240000 00010000 stjtres.dll
5c250000 00030000 sti_ci.dll
5c280000 00020000 stdprov.dll
5c2a0000 00020000 stclient.dll
5c2c0000 00010000 staxmem.dll
5c2d0000 00010000 status.dll
5c2e0000 00020000 star9res.dll
5c300000 00040000 st24eres.dll
5c350000 00010000 sstub.dll
5c360000 00010000 sspifilt.dll
5c370000 00010000 sslcfg.dll
5c380000 00010000 ssinc51.dll
5c390000 00010000 ssinc.dll
5c440000 00040000 swprv.dll
5c4d0000 00020000 srusd.dll
5c4f0000 00020000 srusbusd.dll
5c510000 00040000 srrstr.dll
5c550000 00020000 srclient.dll
5c570000 000d0000 srchui.dll
5c640000 00020000 srchctls.dll
5c660000 00040000 sqlxmlx.dll
5c6a0000 00030000 sqlunirl.dll
5c6d0000 00010000 spxupchk.dll
5c6e0000 00010000 spxcoins.dll
5c6f0000 000c0000 spttseng.dll
5c7b0000 00050000 sptip.dll
5c800000 00020000 sprio800.dll
5c820000 00020000 sprio600.dll
5c840000 00020000 spnike.dll
5c860000 00020000 spdports.dll
5c880000 00010000 spcplui.dll
5c8a0000 00020000 spcommon.dll
5c8c0000 00020000 sonypi.dll
5c8f0000 00020000 sonync.dll
5c920000 00030000 softkbd.dll
5c950000 00010000 snmpthrd.dll
5c960000 00010000 snmpstup.dll
5c970000 00030000 snmpsnap.dll
5c9b0000 00030000 snmpsmir.dll
5c9f0000 00010000 snmpmib.dll
5ca00000 00060000 snmpincl.dll
5ca60000 00040000 snmpcl.dll
5cab0000 00010000 sniffpol.dll
5cac0000 00050000 snapshot.dll
5cb10000 00010000 smtpcons.dll
5cb20000 00020000 sml8xres.dll
5cb50000 00010000 smimsgif.dll
5cb60000 00010000 smierrsy.dll
5cb70000 00010000 smierrsm.dll
5cb80000 00010000 smb6w.dll
5cb90000 00010000 smb3w.dll
5cba0000 00010000 smb0w.dll
5cbb0000 00010000 sma3w.dll
5cbc0000 00010000 sma0w.dll
5cbd0000 00010000 sm9aw.dll
5cbe0000 00010000 sm93w.dll
5cbf0000 00010000 sm92w.dll
5cc00000 00010000 sm91w.dll
5cc10000 00010000 sm90w.dll
5cc20000 00010000 sm8dw.dll
5cc30000 00010000 sm8cw.dll
5cc40000 00010000 sm8aw.dll
5cc50000 00010000 sm89w.dll
5cc60000 00010000 sm87w.dll
5cc70000 00010000 sm81w.dll
5cc80000 00010000 sm59w.dll
5cc90000 00010000 slbs.dll
5cca0000 00010000 slbrccsp.dll
5ccb0000 00020000 slbiop.dll
5ccd0000 00010000 slayerxp.dll
5cce0000 00010000 skdll.dll
5ccf0000 00010000 skcolres.dll
5cd00000 00040000 sisgrv.dll
5cd40000 00010000 sisbkup.dll
5cd50000 00010000 simptcp.dll
5cd60000 00010000 sigtab.dll
5cd70000 00220000 shvlres.dll
5cf90000 00020000 shvl.dll
5cfb0000 00010000 shscrap.dll
5cfc0000 00030000 shmedia.dll
5cff0000 00070000 shimgvw.dll
5d060000 00030000 shimeng.dll
5d090000 00020000 sfmwshat.dll
5d0b0000 00010000 sfmpsprt.dll
5d0c0000 00010000 sfmpsfnt.dll
5d0d0000 000a0000 sfmpsdib.dll
5d180000 00010000 sfmmsg.dll
5d190000 00010000 sfmmon.dll
5d1a0000 00010000 sfmctrs.dll
5d1b0000 00010000 sfmatmsg.dll
5d1c0000 00010000 sfmapi.dll
5d1d0000 00020000 setupqry.dll
5d1f0000 00070000 setupdll.dll
5d260000 00010000 serwvdrv.dll
5d270000 00010000 servdeps.dll
5d290000 00010000 serialui.dll
5d2a0000 00010000 senscfg.dll
5d2b0000 00010000 sendmail.dll
5d2d0000 00010000 sendcmsg.dll
5d2e0000 00010000 sek9res.dll
5d2f0000 00010000 sek24res.dll
5d300000 00030000 sdpblb.dll
5d330000 00010000 scrrncs.dll
5d340000 00030000 scrobj.dll
5d370000 00010000 scriptpw.dll
5d380000 00010000 scripto.dll
5d390000 00030000 script_a.dll
5d3c0000 00040000 script.dll
5d400000 00010000 scredir.dll
5d410000 00010000 scocs.dll
5d420000 00010000 sclgntfy.dll
5d430000 00030000 schmmgmt.dll
5d460000 00030000 sceprov.dll
5d490000 00030000 sccsccp.dll
5d4c0000 00020000 scardssp.dll
5d4f0000 00020000 scarddlg.dll
5d510000 00090000 sblfx.dll
5d5a0000 000b0000 sapi.dll
5d650000 00010000 safrslv.dll
5d660000 00010000 safrdm.dll
5d670000 00010000 safrcdlg.dll
5d680000 00020000 rwia450.dll
5d6a0000 00020000 rwia430.dll
5d6c0000 00020000 rwia330.dll
5d6e0000 00020000 rwia001.dll
5d700000 00010000 rw450ext.dll
5d710000 00010000 rw430ext.dll
5d720000 00010000 rw330ext.dll
5d730000 00010000 rw001ext.dll
5d740000 000c0000 rvseres.dll
5d800000 00010000 rvse.dll
5d820000 00010000 rtrupg.dll
5d830000 00020000 rtrfiltr.dll
5d850000 00020000 rtm.dll
5d870000 00010000 rtipxmib.dll
5d880000 00090000 rtcdll.dll
5d910000 00010000 rsvpperf.dll
5d920000 00010000 rsvpmsg.dll
5d930000 00060000 rstask.dll
5d990000 00010000 rssubps.dll
5d9a0000 00080000 rssub.dll
5da20000 00010000 rsshell.dll
5da30000 00010000 rsservps.dll
5da40000 00020000 rsoptcom.dll
5da60000 00010000 rsmps.dll
5da70000 00050000 rsmover.dll
5dac0000 00010000 rsmgrstr.dll
5dad0000 00090000 rsjob.dll
5db60000 00030000 rsidb.dll
5db90000 00010000 rshx32.dll
5dba0000 00010000 rsfsaps.dll
5dbb0000 00080000 rsfsa.dll
5dc30000 00010000 rsengps.dll
5dc40000 00030000 rseng.dll
5dc70000 00010000 rsconn.dll
5dc80000 00070000 rscommon.dll
5dcf0000 00020000 rscli.dll
5dd20000 000e0000 rsadmin.dll
5de00000 00010000 rrasprxy.dll
5de10000 00010000 rpcref.dll
5de20000 00010000 rpcproxy.dll
5de30000 00010000 rpcns4.dll
5de40000 00010000 routetab.dll
5de50000 00010000 ripagnt.dll
5de60000 00010000 rigpsnap.dll
5de70000 00030000 ricohres.dll
5dea0000 00010000 riafui2.dll
5deb0000 00010000 riafui1.dll
5dec0000 00030000 riafres.dll
5def0000 00020000 reslog32.dll
5df10000 00010000 replprov.dll
5df20000 00020000 rend.dll
5df40000 00020000 remotepg.dll
5df60000 00070000 regwizc.dll
5dfd0000 00010000 rdpsnd.dll
5dfe0000 00010000 rdpcfgex.dll
5dff0000 00030000 rdchost.dll
5e020000 00020000 rcbdyctl.dll
5e040000 00030000 rasuser.dll
5e070000 00010000 rassfm.dll
5e080000 00010000 rasser.dll
5e090000 00010000 rasrad.dll
5e0a0000 00010000 rasmxs.dll
5e0b0000 00030000 rasmontr.dll
5e0e0000 00050000 rasdlg4.dll
5e130000 00010000 rasctrs.dll
5e140000 00010000 rasaudio.dll
5e150000 00010000 racpldlg.dll
5e160000 00010000 qvusd.dll
5e170000 00150000 OPEN
5e2c0000 00010000 qosname.dll
5e2d0000 00010000 qmgrprxy.dll
5e2e0000 00050000 qmgr.dll
5e340000 000c0000 qedwipes.dll
5e400000 00080000 qedit.dll
5e490000 00060000 qdvd.dll
5e4f0000 00050000 qdv.dll
5e540000 00030000 qasf.dll
5e570000 00010000 pwsdata.dll
5e580000 00010000 pwdssp.dll
5e590000 00030000 ptpusd.dll
5e5c0000 00010000 ptpusb.dll
5e5d0000 00010000 pstorec.dll
5e5e0000 00010000 psnppagn.dll
5e5f0000 00010000 psisload.dll
5e600000 00070000 psisdecd.dll
5e670000 00080000 pscript5.dll
5e6f0000 00010000 pschdprf.dll
5e700000 00030000 ps5ui.dll
5e730000 00040000 provthrd.dll
5e770000 00080000 proccon.dll
5e7f0000 00010000 prflbmsg.dll
5e800000 00020000 policman.dll
5e820000 00010000 pngfilt.dll
5e830000 00200000 pmxviceo.dll
5ea30000 00010000 pmxmcro.dll
5ea40000 000d0000 pmxgl.dll
5eb10000 00010000 plustab.dll
5eb20000 00010000 plotui.dll
5eb40000 00010000 plotter.dll
5eb50000 00010000 pifmgr.dll
5eb70000 00010000 pid.dll
5eb80000 00030000 phvfwext.dll
5ebb0000 00030000 photowiz.dll
5ebe0000 00010000 philcam1.dll
5ebf0000 00010000 permchk.dll
5ec50000 00010000 perfts.dll
5ec60000 00010000 perfproc.dll
5ec70000 00010000 perfos.dll
5ec80000 00010000 perfnw.dll
5ec90000 00010000 perfnet.dll
5eca0000 00010000 perfdisk.dll
5ecb0000 00010000 perfctrs.dll
5ecc0000 00030000 pclxl.dll
5ecf0000 00010000 pcleures.dll
5ed10000 000b0000 pcl5ures.dll
5edc0000 00040000 pcl4res.dll
5ee10000 00020000 pchshell.dll
5ee30000 00010000 pbsvrmsg.dll
5ee40000 00010000 pbsmon.dll
5ee50000 00010000 pbserver.dll
5ee60000 00020000 pautoenr.dll
5ee80000 00010000 parser.dll
5ee90000 00030000 paqsp.dll
5eec0000 00010000 panmap.dll
5eed0000 00010000 pagecnt.dll
5eee0000 00010000 pa9w9x.dll
5eef0000 00010000 pa9res.dll
5ef10000 00010000 pa24w9x.dll
5ef20000 00020000 pa24res.dll
5ef40000 000f0000 p5000uni.dll
5f030000 00010000 p5000ui.dll
5f040000 00010000 p5000.dll
5f050000 00010000 ovui2rc.dll
5f060000 00010000 ovui2.dll
5f070000 00010000 ovcomc.dll
5f080000 00020000 ovcodec2.dll
5f0b0000 00020000 osuninst.dll
5f0d0000 00020000 ospfmib.dll
5f0f0000 00010000 ospfagnt.dll
5f100000 00030000 ospf.dll
5f130000 00070000 optrares.dll
5f1a0000 00070000 opteures.dll
5f210000 000d0000 opengl32.dll
5f2e0000 00020000 olepro32.dll
5f300000 00020000 oleprn.dll
5f320000 00010000 oleaccrc.dll
5f330000 00010000 old9res.dll
5f340000 00010000 old24res.dll
5f350000 00010000 ol9res.dll
5f360000 00010000 ol24res.dll
5f370000 00010000 oksidm9.dll
5f380000 00030000 okml9res.dll
5f3b0000 00020000 okm24res.dll
5f3d0000 00030000 okipage.dll
5f400000 00010000 oki9res.dll
5f410000 00010000 oki24res.dll
5f420000 00010000 okd24res.dll
5f440000 00020000 ok9ibres.dll
5f460000 00020000 offfilt.dll
5f480000 00010000 oemiglib.dll
5f490000 00020000 oeimport.dll
5f4b0000 00010000 odbcp32r.dll
5f4c0000 00020000 odbcconf.dll
5f4f0000 00020000 od9ibres.dll
5f510000 00010000 ocmsn.dll
5f520000 00020000 ocmanage.dll
5f540000 00010000 ocgen.dll
5f550000 00010000 oce.dll
5f560000 00020000 occache.dll
5f580000 00050000 objsel.dll
5f5d0000 00020000 nwwks.dll
5f5f0000 00030000 nwprovau.dll
5f620000 00010000 nwevent.dll
5f630000 00010000 nwcfg.dll
5f640000 00020000 nwapi32.dll
5f660000 00010000 nwapi16.dll
5f670000 00010000 ntvdmd.dll
5f680000 00010000 ntsdexts.dll
5f690000 00020000 ntprint.dll
5f6b0000 00020000 ntoc.dll
5f6d0000 00010000 ntmsevt.dll
5f6e0000 00010000 ntlanui2.dll
5f6f0000 00020000 ntfrsres.dll
5f710000 00010000 ntfrsprf.dll
5f720000 00010000 ntfrsapi.dll
5f740000 00040000 ntevt.dll
5f780000 00010000 ntdsperf.dll
5f790000 00060000 ntdsmsg.dll
5f7f0000 00010000 ntdsbmsg.dll
5f800000 00010000 nsepm.dll
5f810000 00010000 npwmsdrm.dll
5f820000 00010000 npptools.dll
5f840000 00060000 npdsplay.dll
5f8a0000 00030000 rsaenhs.dll
5f8d0000 00030000 nmwb.dll
5f900000 00010000 nmsupp.dll
5f910000 00010000 nmpppoe.dll
5f920000 00030000 nmoldwb.dll
5f950000 00010000 nmmkcert.dll
5f960000 00030000 nmft.dll
5f990000 00010000 nmevtmsg.dll
5f9a0000 00020000 nmapi.dll
5f9c0000 00020000 nlhtml.dll
5f9e0000 00030000 nlbmprov.dll
5fa10000 00010000 nextlink.dll
5fa30000 00040000 newdev.dll
5fa70000 000e0000 netplwiz.dll
5fb50000 00020000 netoc.dll
5fb70000 00030000 netid.dll
5fba0000 00040000 neth.dll
5fbf0000 00010000 ndisnpp.dll
5fc10000 00010000 nddenb32.dll
5fc20000 00010000 ncxpnt.dll
5fc30000 00010000 ncpsui.dll
5fc40000 00010000 ncpsres.dll
5fc50000 00020000 ncprov.dll
5fc70000 00010000 ncpclres.dll
5fc80000 00010000 ncobjapi.dll
5fc90000 00010000 nc24res.dll
5fca0000 00020000 narrhook.dll
5fcc0000 000c0000 napmmc.dll
5fd80000 00010000 mxport.dll
5fd90000 00010000 mxicfg.dll
5fda0000 00020000 mwci32.dll
5fdc0000 00010000 mty9res.dll
5fdd0000 00030000 mty24res.dll
5fe00000 00010000 mtxlegih.dll
5fe10000 00010000 mtxex.dll
5fe20000 00010000 mtxdm.dll
5fe30000 00030000 mtpclres.dll
5fe60000 00010000 mtltres.dll
5fe70000 00010000 mtbjres.dll
5fe80000 00010000 mt90res.dll
5fe90000 00010000 mt735res.dll
5fea0000 00010000 msxmlr.dll
5feb0000 00010000 msxml3r.dll
5fec0000 00010000 msxml2r.dll
5fed0000 000b0000 msxml2.dll
5ff80000 00030000 mswmdm.dll
5ffb0000 00040000 mswebdvd.dll
5fff0000 00010000 kbd101.dll
5fff0000 00010000 kbd101a.dll
5fff0000 00010000 kbd101b.dll
5fff0000 00010000 kbd101c.dll
5fff0000 00010000 kbd103.dll
5fff0000 00010000 kbd106.dll
5fff0000 00010000 kbd106n.dll
5fff0000 00010000 kbdal.dll
5fff0000 00010000 kbdarme.dll
5fff0000 00010000 kbdarmw.dll
5fff0000 00010000 kbdax2.dll
5fff0000 00010000 kbdaze.dll
5fff0000 00010000 kbdazel.dll
5fff0000 00010000 kbdbe.dll
5fff0000 00010000 kbdbene.dll
5fff0000 00010000 kbdblr.dll
5fff0000 00010000 kbdbr.dll
5fff0000 00010000 kbdbu.dll
5fff0000 00010000 kbdca.dll
5fff0000 00010000 kbdcan.dll
5fff0000 00010000 kbdcr.dll
5fff0000 00010000 kbdcz.dll
5fff0000 00010000 kbdcz1.dll
5fff0000 00010000 kbdcz2.dll
5fff0000 00010000 kbdda.dll
5fff0000 00010000 kbddv.dll
5fff0000 00010000 kbdes.dll
5fff0000 00010000 kbdest.dll
5fff0000 00010000 kbdfc.dll
5fff0000 00010000 kbdfi.dll
5fff0000 00010000 kbdfo.dll
5fff0000 00010000 kbdfr.dll
5fff0000 00010000 kbdgae.dll
5fff0000 00010000 kbdgeo.dll
5fff0000 00010000 kbdgkl.dll
5fff0000 00010000 kbdgr.dll
5fff0000 00010000 kbdgr1.dll
5fff0000 00010000 kbdhe.dll
5fff0000 00010000 kbdhe220.dll
5fff0000 00010000 kbdhe319.dll
5fff0000 00010000 kbdhela2.dll
5fff0000 00010000 kbdhela3.dll
5fff0000 00010000 kbdhept.dll
5fff0000 00010000 kbdhu.dll
5fff0000 00010000 kbdhu1.dll
5fff0000 00010000 kbdibm02.dll
5fff0000 00010000 kbdic.dll
5fff0000 00010000 kbdir.dll
5fff0000 00010000 kbdit.dll
5fff0000 00010000 kbdit142.dll
5fff0000 00010000 kbdjpn.dll
5fff0000 00010000 kbdkaz.dll
5fff0000 00010000 kbdkor.dll
5fff0000 00010000 kbdla.dll
5fff0000 00010000 kbdlk41a.dll
5fff0000 00010000 kbdlk41j.dll
5fff0000 00010000 kbdlt.dll
5fff0000 00010000 kbdlt1.dll
5fff0000 00010000 kbdlv.dll
5fff0000 00010000 kbdlv1.dll
5fff0000 00010000 kbdmac.dll
5fff0000 00010000 kbdne.dll
5fff0000 00010000 kbdnec.dll
5fff0000 00010000 kbdnec95.dll
5fff0000 00010000 kbdnecat.dll
5fff0000 00010000 kbdnecnt.dll
5fff0000 00010000 kbdno.dll
5fff0000 00010000 kbdpl.dll
5fff0000 00010000 kbdpl1.dll
5fff0000 00010000 kbdpo.dll
5fff0000 00010000 kbdro.dll
5fff0000 00010000 kbdru.dll
5fff0000 00010000 kbdru1.dll
5fff0000 00010000 kbdsf.dll
5fff0000 00010000 kbdsg.dll
5fff0000 00010000 kbdsl.dll
5fff0000 00010000 kbdsl1.dll
5fff0000 00010000 kbdsp.dll
5fff0000 00010000 kbdsw.dll
5fff0000 00010000 kbdtat.dll
5fff0000 00010000 kbdtuf.dll
5fff0000 00010000 kbdtuq.dll
5fff0000 00010000 kbduk.dll
5fff0000 00010000 kbdur.dll
5fff0000 00010000 kbdus.dll
5fff0000 00010000 kbdusa.dll
5fff0000 00010000 kbdusl.dll
5fff0000 00010000 kbdusr.dll
5fff0000 00010000 kbdusx.dll
5fff0000 00010000 kbduzb.dll
5fff0000 00010000 kbdvntc.dll
5fff0000 00010000 kbdycc.dll
5fff0000 00010000 kbdycl.dll
60000000 00020000 msw3prt.dll
60020000 000b0000 appwiz.cpl
600d0000 00050000 OPEN
60120000 00040000 msutb.dll
60160000 00040000 msuni11.dll
601a0000 00050000 mstvgs.dll
601f0000 00060000 mstvca.dll
60250000 00030000 mstsmmc.dll
60280000 00020000 mstsmhst.dll
602a0000 00090000 OPEN
60330000 00080000 mstime.dll
603b0000 00010000 mst123.dll
603c0000 00010000 msswch.dll
603d0000 00010000 mssoapr.dll
603e0000 00040000 mssoap1.dll
60420000 00010000 mssip32.dll
60430000 00030000 msrating.dll
60460000 00020000 msratelc.dll
60480000 00010000 msr2cenu.dll
60490000 00020000 msr2c.dll
604b0000 00010000 msppnxus.dll
604c0000 00040000 msppmgr.dll
60500000 00010000 msppmd5.dll
60510000 00010000 msppmalr.dll
60520000 00010000 mspplkrh.dll
60540000 00010000 msppcntr.dll
60550000 00010000 msppalrt.dll
60560000 00010000 msports.dll
60570000 00040000 mspmsp.dll
605b0000 00010000 mspatcha.dll
605c0000 00010000 msorc32r.dll
605d0000 00260000 msoeres.dll
60840000 00040000 msoeacct.dll
60880000 00130000 msoe.dll
609b0000 00010000 msobweb.dll
609c0000 00010000 msobshel.dll
609d0000 00090000 msobmain.dll
60a60000 00010000 msobjs.dll
60a70000 00010000 msobdl.dll
60a80000 00020000 msobcomm.dll
60aa0000 00030000 msmqocm.dll
60ad0000 00010000 mslwvtts.dll
60ae0000 00010000 mslbui.dll
60b00000 00010000 msisip.dll
60b10000 00060000 msisam11.dll
60b70000 00050000 msiprov.dll
60bc0000 00060000 msinfo.dll
60c20000 000d0000 msimsg.dll
60d00000 00050000 msihnd.dll
60d60000 00040000 msieftp.dll
60da0000 00010000 msidntld.dll
60db0000 00010000 msident.dll
60dc0000 00010000 mshtmler.dll
60de0000 00010000 msgrocm.dll
60df0000 00340000 msgr3en.dll
61130000 00020000 msencode.dll
61150000 00010000 msdxmlc.dll
61160000 00020000 msdvdopt.dll
61180000 00030000 msdtcuiu.dll
611b0000 000e0000 msdtctm.dll
61290000 00020000 msdtcstp.dll
612b0000 00060000 msdtcprx.dll
61310000 00020000 msdtclog.dll
61330000 00010000 msdaurl.dll
61340000 00020000 msdatl3.dll
61360000 00010000 msdaprsr.dll
61370000 00010000 msdaorar.dll
61380000 00020000 msctfp.dll
613a0000 00010000 mscpx32r.dll
613b0000 00010000 msconf.dll
613d0000 00040000 msclus.dll
61410000 00040000 mscandui.dll
61450000 00020000 msaudite.dll
61470000 00020000 msaatext.dll
61490000 00080000 mqutil.dll
61510000 00010000 mqupgrd.dll
61520000 00030000 mqtrig.dll
61550000 00010000 mqtgclus.dll
61560000 00080000 mqsnap.dll
615e0000 00020000 mqsec.dll
61600000 00020000 mqrtdep.dll
61630000 00030000 mqrt.dll
61660000 00010000 mqrperf.dll
61670000 000b0000 mqqm.dll
61720000 00010000 mqperf.dll
61730000 00040000 mqoa.dll
61770000 00040000 mqmigrat.dll
617b0000 00020000 mqlogmgr.dll
617d0000 00010000 mqise.dll
617e0000 00020000 mqgentr.dll
61800000 00010000 mqdssrv.dll
61810000 00010000 mqdscli.dll
61830000 00010000 mqdbodbc.dll
61840000 00020000 mqclus.dll
61860000 00010000 mqcertui.dll
61870000 00040000 mqads.dll
618b0000 00030000 mqad.dll
618e0000 00040000 mq1repl.dll
61920000 00100000 mprsnap.dll
61a20000 00020000 mprmsg.dll
61a40000 00010000 mprdim.dll
61a60000 00020000 mprddm.dll
61a80000 00060000 mpg4dmod.dll
61ae0000 00040000 moricons.dll
61b20000 00020000 mofd.dll
61b50000 00010000 modex.dll
61b60000 00030000 modemui.dll
61b90000 00040000 mobsync.dll
61bd0000 00030000 mn350620.dll
61c00000 00030000 mmutilse.dll
61c30000 00010000 mmfutil.dll
61c40000 000a0000 mltres.dll
61ce0000 00010000 mll_qic.dll
61cf0000 00010000 mll_mtf.dll
61d00000 00010000 mll_hp.dll
61d10000 00010000 miscanw.dll
61d20000 00040000 minqmsui.dll
61d60000 00010000 minqmsps.dll
61d70000 00030000 minolres.dll
61da0000 00030000 mindex.dll
61dd0000 00010000 mimefilt.dll
61de0000 00020000 miglibnt.dll
61e00000 00040000 migism_a.dll
61e40000 00040000 migism.dll
61e80000 00020000 mga.dll
61ea0000 00010000 mfcsubs.dll
61eb0000 00010000 mfc42csy.dll
61ec0000 000f0000 mfc40u.dll
61fb0000 00010000 mfc40csy.dll
61fc0000 000f0000 mfc40.dll
620b0000 00060000 metal_ss.dll
62110000 00040000 metadata.dll
62150000 00020000 metada51.dll
62170000 00090000 memgrp.dll
62200000 00030000 mdwmdmsp.dll
62230000 00010000 mdsync.dll
62240000 00020000 mdminst.dll
62260000 00020000 mdhcp.dll
62280000 00010000 md5filt.dll
62290000 00010000 mciwave.dll
622a0000 00010000 mciseq.dll
622b0000 00010000 mciqtz32.dll
622c0000 00010000 mciole32.dll
622d0000 00010000 mcicda.dll
622f0000 00010000 mchgrcoi.dll
62300000 00010000 mcd32.dll
62310000 00010000 mcastmib.dll
62320000 00010000 mcast.dll
62330000 00020000 mapistub.dll
62360000 00010000 mag_hook.dll
62370000 00020000 m3092dc.dll
62390000 00020000 m3091dc.dll
623b0000 00030000 lxsysui.dll
623e0000 00010000 lxsysres.dll
623f0000 00010000 lxsysrdr.dll
62400000 00060000 lxsyicur.dll
62460000 00020000 lxsyfcic.dll
62490000 000f0000 lxsdclr2.dll
62580000 001c0000 lxsdclr1.dll
62740000 00030000 lxrosui.dll
62770000 00010000 lxrosres.dll
62780000 00010000 lxrosrdr.dll
62790000 00060000 lxroicur.dll
627f0000 00020000 lxrofcic.dll
62820000 00030000 lxmdsui.dll
62850000 00010000 lxmdsres.dll
62860000 00010000 lxmdsrdr.dll
62870000 00060000 lxmdicur.dll
628d0000 00030000 lxmdfcic.dll
62900000 00030000 lxmasui.dll
62930000 00010000 lxmasres.dll
62940000 00010000 lxmasrdr.dll
62950000 00060000 lxmaicur.dll
629b0000 00020000 lxmafcic.dll
629e0000 00010000 lxinkres.dll
62a00000 00010000 lxfmpres.dll
62a10000 00030000 lxcasui.dll
62a40000 00010000 lxcasres.dll
62a50000 00010000 lxcasrdr.dll
62a60000 00060000 lxcaicur.dll
62ac0000 00030000 lxcafcic.dll
62af0000 00030000 lxaesui.dll
62b20000 00010000 lxaesres.dll
62b30000 00010000 lxaesrdr.dll
62b40000 00060000 lxaeicur.dll
62ba0000 00030000 lxaefcic.dll
62bd0000 00030000 lxadsui.dll
62c00000 00010000 lxadsres.dll
62c10000 00010000 lxadsrdr.dll
62c20000 00060000 lxadicur.dll
62c80000 00030000 lxadfcic.dll
62cb0000 00030000 lxacsui.dll
62ce0000 00010000 lxacsres.dll
62cf0000 00010000 lxacsrdr.dll
62d00000 00060000 lxacicur.dll
62d60000 00030000 lxacfcic.dll
62d90000 00030000 lxaasui.dll
62dc0000 00010000 lxaasres.dll
62dd0000 00010000 lxaasrdr.dll
62de0000 00060000 lxaaicur.dll
62e40000 00030000 lxaafcic.dll
62e70000 00010000 lx238res.dll
62e80000 00040000 lrwizdll.dll
62ec0000 00010000 lprmonui.dll
62ed0000 00010000 lprmon.dll
62ee0000 00010000 lprhelp.dll
62ef0000 00010000 lpk.dll
62f00000 00010000 lpdsvc.dll
62f10000 00010000 lonsint.dll
62f20000 00010000 logscrpt.dll
62f30000 00020000 loghours.dll
62f50000 00010000 log.dll
62f60000 00010000 localui.dll
62f70000 00060000 lmrt.dll
62fe0000 00030000 lmpclres.dll
63010000 00090000 lmoptra.dll
630a0000 00010000 lmmib2.dll
630b0000 00010000 lmikjres.dll
630c0000 00010000 llsrpc.dll
630e0000 00020000 licwmi.dll
63100000 00010000 licmgr10.dll
63110000 00010000 licenoc.dll
63120000 00060000 licdll.dll
63180000 00010000 lexutil.dll
63190000 00010000 laprxy.dll
631a0000 00020000 langwrbk.dll
631c0000 00020000 voicesub.dll
631e0000 00110000 voicepad.dll
632f0000 00020000 uniime.dll
63310000 00020000 tmigrate.dll
63330000 00030000 softkey.dll
63360000 00020000 pmigrate.dll
63380000 00020000 pintlcsd.dll
633a0000 00050000 pintlcsa.dll
63400000 00010000 padrs804.dll
63410000 00010000 padrs412.dll
63420000 00010000 padrs411.dll
63430000 00010000 padrs404.dll
63440000 00040000 multibox.dll
63480000 00020000 msir3jp.dll
634a0000 00020000 korwbrkr.dll
634c0000 00060000 imskf.dll
63520000 00080000 imskdic.dll
635a0000 00020000 imlang.dll
635c0000 00050000 imjputyc.dll
63610000 00020000 imjpdct.dll
63630000 000c0000 imjpcus.dll
636f0000 00060000 imjpcic.dll
63750000 000d0000 imjp81k.dll
63820000 00020000 imepadsm.dll
63840000 00020000 imekrmbx.dll
63860000 00020000 imekrcic.dll
63880000 009b0000 hwxkor.dll
64230000 00ce0000 hwxjpn.dll
64f10000 009b0000 hwxcht.dll
658c0000 00010000 hanjadic.dll
658d0000 00010000 ftlx0411.dll
658e0000 00060000 cintime.dll
65940000 00060000 chtskf.dll
659a0000 00030000 chtskdic.dll
659d0000 00040000 chtmbx.dll
65a10000 000d0000 chtbrkr.dll
65af0000 001a0000 chsbrkr.dll
65c90000 00020000 lamebtn.dll
65cb0000 00010000 kyrares.dll
65cc0000 00030000 kyores.dll
65cf0000 00020000 kyofonts.dll
65d10000 00010000 krnlprov.dll
65d20000 00010000 kousd.dll
65d30000 00070000 kmres.dll
65da0000 00040000 keymgr.dll
65de0000 00010000 kerbprsr.dll
65df0000 00050000 kdsusd.dll
65e40000 00020000 kdsui.dll
65e60000 00030000 kdcsvc.dll
65e90000 00010000 kbdurdu.dll
65ea0000 00010000 kbdth3.dll
65eb0000 00010000 kbdth2.dll
65ec0000 00010000 kbdth1.dll
65ed0000 00010000 kbdth0.dll
65ee0000 00010000 kbdsyr2.dll
65ef0000 00010000 kbdsyr1.dll
65f00000 00010000 kbdmon.dll
65f10000 00010000 kbdkyr.dll
65f20000 00010000 kbdintel.dll
65f30000 00010000 kbdintam.dll
65f40000 00010000 kbdinpun.dll
65f50000 00010000 kbdinmar.dll
65f60000 00010000 kbdinkan.dll
65f70000 00010000 kbdinhin.dll
65f80000 00010000 kbdinguj.dll
65f90000 00010000 kbdindev.dll
65fa0000 00010000 kbdheb.dll
65fb0000 00010000 kbdfa.dll
65fc0000 00010000 kbddiv2.dll
65fd0000 00010000 kbddiv1.dll
65fe0000 00010000 kbda3.dll
65ff0000 00010000 kbda2.dll
66000000 00010000 kbda1.dll
66010000 00010000 jupiw.dll
66020000 00010000 jsproxy.dll
66030000 00010000 jscs.dll
66040000 00020000 jp350res.dll
66070000 00010000 jobexec.dll
66090000 00020000 jgsh400.dll
660b0000 00020000 jgsd400.dll
660d0000 00020000 jgpl400.dll
660f0000 00010000 jgmd400.dll
66110000 00030000 jgdw400.dll
66140000 00010000 jgaw400.dll
66160000 000d0000 jet500.dll
66230000 000b0000 jet.dll
662e0000 00010000 ixsso.dll
66300000 00010000 iwrps.dll
66310000 00030000 iuengine.dll
66340000 00020000 iuctl.dll
66360000 00030000 itss.dll
66390000 00030000 itircl.dll
663c0000 00010000 isrdbg32.dll
663d0000 00010000 ismsmtp.dll
663f0000 00010000 ismsink.dll
66400000 00010000 ismip.dll
66410000 00010000 ism.dll
66420000 00020000 isign32.dll
66440000 00010000 iscomlog.dll
66450000 00020000 isatq.dll
66470000 00010000 isapips.dll
66480000 00020000 irmon.dll
664a0000 00010000 irclass.dll
664b0000 00090000 ir50_qc.dll
66540000 000b0000 ir41_qc.dll
665f0000 00080000 ipxsnap.dll
66670000 00020000 ipxsap.dll
66690000 00010000 ipxrtmgr.dll
666a0000 00010000 ipxrip.dll
666b0000 00020000 ipxpromn.dll
666d0000 00020000 ipxmontr.dll
666f0000 00030000 ipv6mon.dll
66720000 000d0000 ipsnap.dll
667f0000 00060000 ipsmsnap.dll
66850000 00060000 ipsecsnp.dll
668b0000 00030000 iprtrmgr.dll
668f0000 00010000 iprtprio.dll
66900000 00010000 iprop.dll
66910000 00020000 iprip2.dll
66930000 00010000 iprip.dll
66940000 00060000 ippromon.dll
669a0000 00080000 ipnathlp.dll
66a20000 00030000 ipmontr.dll
66a50000 00010000 ipm.dll
66a60000 00010000 ipbootp.dll
66a70000 00010000 iologmsg.dll
66a80000 00020000 io8ports.dll
66aa0000 00020000 inseng.dll
66ac0000 00020000 OPEN
66ae0000 00030000 initpki.dll
66b10000 00080000 infosoft.dll
66b90000 00010000 infoctrs.dll
66ba0000 00050000 infocomm.dll
66bf0000 00010000 infoadmn.dll
66c00000 00010000 inetsloc.dll
66c10000 00010000 inetres.dll
66c20000 00010000 inetppui.dll
66c30000 00010000 inetmib1.dll
66c40000 000d0000 inetmgr.dll
66d10000 00020000 inetcplc.dll
66d40000 00050000 inetcfg.dll
66d90000 00030000 imsinsnt.dll
66dc0000 00010000 imirror.dll
66dd0000 00010000 imgutil.dll
66de0000 00010000 imeshare.dll
66df0000 00020000 imadmui.dll
66e10000 00020000 ils.dll
66e30000 00030000 iiswmi.dll
66e60000 00020000 iisw3adm.dll
66e80000 00020000 iisutil.dll
66eb0000 00030000 iisui.dll
66ef0000 00010000 iissuba.dll
66f00000 00020000 iisrtl.dll
66f30000 00010000 iisrstap.dll
66f40000 00010000 iismui.dll
66f50000 00020000 iismap.dll
66f70000 00020000 iislog51.dll
66f90000 00020000 iislog.dll
66fb0000 00010000 iisfecnv.dll
66fc0000 00020000 iisext51.dll
66fe0000 00020000 iisext.dll
67000000 00010000 iiscrmap.dll
67010000 00010000 iisclus3.dll
67020000 00020000 iisclex4.dll
67040000 00020000 iisclex3.dll
67060000 00030000 iische51.dll
67090000 001c0000 iiscfg.dll
67260000 00010000 iisadmin.dll
67270000 00080000 iis.dll
672f0000 00030000 igmpv2.dll
67320000 00010000 igmpagnt.dll
67330000 00020000 ifsutil.dll
67350000 00030000 ifmon.dll
67380000 00020000 iesetup.dll
673a0000 00010000 iernonce.dll
673b0000 00040000 iepeers.dll
673f0000 00050000 iedkcs32.dll
67440000 00040000 ieakui.dll
67480000 00040000 ieaksie.dll
674c0000 00020000 ieakeng.dll
674f0000 00020000 idq.dll
67510000 00010000 icwutil.dll
67520000 00010000 icwres.dll
67540000 00010000 icwphbk.dll
67560000 00030000 icwhelp.dll
67590000 00010000 icwdl.dll
675a0000 00020000 icwdial.dll
675c0000 00010000 icwconn.dll
675d0000 00010000 iconlib.dll
675e0000 00060000 iconf32.dll
67650000 00010000 icmui.dll
67670000 00040000 icm32.dll
676b0000 00010000 icfgnt5.dll
676c0000 00010000 icam5ext.dll
676d0000 00010000 icam5com.dll
676e0000 00020000 icam4ext.dll
67700000 00020000 icam4com.dll
67720000 00010000 icam3ext.dll
67730000 00010000 ibqwres.dll
67740000 00010000 ibps1res.dll
67750000 00010000 ibprores.dll
67760000 00010000 ibppdres.dll
67770000 00010000 ibp24res.dll
67780000 00010000 ibmsgnet.dll
67790000 00010000 ibmptres.dll
677a0000 00010000 ib52res.dll
677b0000 00010000 ib239res.dll
677d0000 00010000 ib238res.dll
677e0000 00020000 iassvcs.dll
67800000 00040000 iassdo.dll
67850000 00020000 iassam.dll
67870000 00030000 iasrecst.dll
678a0000 00020000 iasrad.dll
678d0000 00010000 iaspolcy.dll
678e0000 00010000 iasperf.dll
678f0000 00020000 iasnap.dll
67910000 00040000 iasmmc.dll
67960000 00010000 iashlpr.dll
67970000 00010000 iasads.dll
67980000 00010000 iasacct.dll
67990000 00010000 ias.dll
679a0000 00080000 hypertrm.dll
67a20000 00010000 htui.dll
67a30000 00010000 httpodbc.dll
67a40000 00020000 httpod51.dll
67a60000 00010000 httpmib.dll
67a70000 00010000 httpmb51.dll
67a80000 00040000 httpext.dll
67ad0000 00010000 httpapi.dll
67ae0000 00010000 htrn_jis.dll
67af0000 00010000 hsf_inst.dll
67b00000 00130000 hrtzres.dll
67c30000 00020000 hrtz.dll
67c50000 00010000 hr1w.dll
67c60000 00040000 hpwm5db1.dll
67ca0000 00050000 hpwm50al.dll
67cf0000 00010000 hpvui50.dll
67d00000 00020000 hpvud50.dll
67d20000 00030000 hpvscp50.dll
67d60000 00280000 hpvimg50.dll
67fe0000 00040000 hpvdb820.dll
68020000 00030000 hpvdb720.dll
68050000 00080000 hpv880al.dll
680d0000 00050000 hpv850al.dll
68120000 00060000 hpv820al.dll
68180000 00050000 hpv800al.dll
681e0000 00060000 hpv700al.dll
68240000 00050000 hpv600al.dll
68290000 00060000 hpv200al.dll
682f0000 00010000 hptjres.dll
68300000 00010000 hpsjmcro.dll
68310000 00010000 hpqjres.dll
68320000 00010000 hppjres.dll
68330000 00060000 hpojwia.dll
68390000 00010000 hpoemui.dll
683a0000 00010000 hpmcro32.dll
683b0000 00010000 hpgtmcro.dll
683c0000 00020000 hpgt53tk.dll
683e0000 00030000 hpgt53.dll
68410000 00010000 hpgt42tk.dll
68420000 00020000 hpgt42.dll
68440000 00150000 hpgt34tk.dll
68590000 00020000 hpgt34.dll
685b0000 00140000 hpgt33tk.dll
686f0000 00020000 hpgt33.dll
68710000 00030000 hpgt21tk.dll
68740000 00020000 hpgt21.dll
68760000 00010000 hpfui50.dll
68770000 00020000 hpfud50.dll
68790000 001d0000 hpfimg50.dll
68960000 000e0000 hpf940al.dll
68a40000 00070000 hpf900al.dll
68ab0000 00080000 hpf880al.dll
68b30000 00030000 hpdjres.dll
68b60000 00030000 hpdigwia.dll
68b90000 00010000 hpcstr.dll
68ba0000 00060000 hpclj5ui.dll
68c00000 00010000 hpcjrui.dll
68c10000 00010000 hpcjrrps.dll
68c20000 00010000 hpcjrr.dll
68c30000 00030000 hpcfont.dll
68c60000 00010000 hpccljui.dll
68c70000 00010000 hpcclj1.dll
68c80000 00010000 hpcclj.dll
68c90000 00010000 hpcabout.dll
68ca0000 00020000 hpc4500u.dll
68cd0000 00030000 hotplug.dll
68d00000 00010000 hostmib.dll
68d10000 00060000 home_ss.dll
68d70000 00050000 hnetwiz.dll
68dd0000 00010000 hnetmon.dll
68de0000 00040000 hnetcfg.dll
68e30000 00010000 hmmapi.dll
68e40000 00010000 hidserv.dll
68e50000 00010000 hid.dll
68e60000 00020000 hhctrlui.dll
68e80000 00010000 hexedit.dll
68e90000 00010000 hcappres.dll
68ea0000 000a0000 h323msp.dll
68f40000 00010000 gzip.dll
68f50000 00030000 guitrn_a.dll
68f80000 00030000 guitrn.dll
68fb0000 00010000 grovmsg.dll
68fc0000 00030000 gptext.dll
68ff0000 00010000 gpkrsrc.dll
69000000 00080000 gpedit.dll
69080000 00020000 glu32.dll
690b0000 00050000 glmf32.dll
69100000 000b0000 getuname.dll
691b0000 00020000 gcdef.dll
691d0000 00070000 fxsxp32.dll
69240000 00040000 fxswzrd.dll
69280000 00030000 fxsui.dll
692b0000 00070000 fxstiff.dll
69320000 00010000 fxst30p.dll
69330000 00040000 fxst30.dll
69370000 00090000 fxsst.dll
69400000 00020000 fxsrtmtd.dll
69420000 00010000 fxsroute.dll
69430000 00010000 fxsres.dll
69440000 00010000 fxsperf.dll
69450000 00030000 fxsocm.dll
69480000 00010000 fxsmon.dll
69490000 00010000 fxsext32.dll
694a0000 00020000 fxsevent.dll
694c0000 00010000 fxsdrv.dll
694d0000 00050000 fxscomex.dll
69520000 00020000 fxscom.dll
69540000 00030000 fxsclntr.dll
69570000 00020000 fxscfgwz.dll
69590000 00070000 fxsapi.dll
69610000 00070000 fxsadmin.dll
69680000 00010000 fx5eres.dll
69690000 00020000 fwdprov.dll
696b0000 00020000 fuusd.dll
696d0000 00030000 fupclres.dll
69700000 00010000 fu9res.dll
69710000 00010000 fu24res.dll
69720000 00030000 ftsrch.dll
69760000 00020000 ftpsvc2.dll
69790000 00020000 ftpsv251.dll
697c0000 00010000 ftpsapi2.dll
697d0000 00010000 ftpmib.dll
697e0000 00010000 ftpctrs2.dll
697f0000 00010000 ftlx041e.dll
69800000 00020000 fsusd.dll
69820000 00010000 fsconins.dll
69830000 00010000 fscfg.dll
69840000 00030000 framedyn.dll
69870000 00010000 fpnwclnt.dll
69880000 00010000 fp40ext.dll
69890000 00020000 fontsub.dll
698b0000 00060000 fontext.dll
69920000 00020000 fnfilter.dll
69940000 00010000 fmifs.dll
69950000 00020000 fldrclnr.dll
69970000 00010000 feclient.dll
69980000 00020000 fdeploy.dll
699a0000 00030000 fde.dll
699d0000 00020000 faultrep.dll
699f0000 00010000 f3ahvoas.dll
69a00000 00030000 exts.dll
69a30000 00010000 exstrace.dll
69a40000 00010000 exp24res.dll
69a50000 00010000 evtgprov.dll
69a60000 00010000 evntrprv.dll
69a70000 00020000 evntagnt.dll
69a90000 00010000 eventcls.dll
69aa0000 00010000 pidgen.dll
69ab0000 00010000 esunid.dll
69ad0000 00010000 esunib.dll
69af0000 00010000 esuni.dll
69b10000 00020000 esuimgd.dll
69b30000 00010000 esuimg.dll
69b40000 00010000 esucmd.dll
69b50000 00010000 esucm.dll
69b60000 00010000 esentprf.dll
69b70000 00120000 esent97.dll
69c90000 00100000 esent.dll
69d90000 00010000 escp2res.dll
69da0000 00010000 es1371mp.dll
69db0000 00020000 eqnclass.dll
69dd0000 00010000 epnutx22.dll
69de0000 00120000 epnhtx2h.dll
69f00000 00090000 epnhtx16.dll
69f90000 000a0000 epnhtx15.dll
6a030000 00090000 epnhtx14.dll
6a0d0000 00090000 epnhtx13.dll
6a160000 00080000 epnhtx12.dll
6a1e0000 00090000 epnhtx11.dll
6a270000 00060000 epnhtx0a.dll
6a2d0000 00060000 epnhtx09.dll
6a330000 00070000 epnhtx07.dll
6a3a0000 00070000 epnhtx05.dll
6a410000 00060000 epnhtx04.dll
6a470000 00060000 epnhtx02.dll
6a4d0000 00060000 epnhtx01.dll
6a530000 00160000 epnhte5d.dll
6a690000 00140000 epnhte5a.dll
6a7d0000 00140000 epnhte4s.dll
6a910000 00110000 epnhte4p.dll
6aa20000 00190000 epnhte4n.dll
6abb0000 00170000 epnhte4l.dll
6ad20000 00220000 epnhte4k.dll
6af40000 00200000 epnhte4j.dll
6b140000 00140000 epnhte4i.dll
6b280000 00130000 epnhte4h.dll
6b3b0000 00130000 epnhte4g.dll
6b4e0000 00090000 epnhte4d.dll
6b570000 00110000 epnhte4c.dll
6b680000 00110000 epnhte4b.dll
6b790000 000b0000 epnhte4a.dll
6b840000 000f0000 epnhte3v.dll
6b930000 001b0000 epnhte3t.dll
6bae0000 00160000 epnhte3q.dll
6bc40000 00060000 epnhte3p.dll
6bca0000 00070000 epnhte3o.dll
6bd10000 000f0000 epnhte3n.dll
6be00000 000a0000 epnhte2m.dll
6bea0000 000e0000 epnhte2k.dll
6bf80000 00140000 epnhte2j.dll
6c0c0000 00020000 epngui40.dll
6c0e0000 00020000 epngui30.dll
6c100000 00020000 epngui10.dll
6c120000 00010000 epndrv01.dll
6c130000 00020000 eplvcd00.dll
6c150000 00020000 eplrcz00.dll
6c170000 00010000 epcl5ui.dll
6c180000 00020000 epcl5res.dll
6c1b0000 00010000 ep9res.dll
6c1c0000 00010000 ep9bres.dll
6c1d0000 00020000 ep2bres.dll
6c1f0000 00010000 ep24res.dll
6c200000 00010000 efsadu.dll
6c210000 00110000 edb500.dll
6c330000 00010000 ecp2eres.dll
6c350000 00040000 dxtrans.dll
6c390000 00060000 dxtmsft.dll
6c3f0000 000e0000 dxmrtp.dll
6c4d0000 00080000 dxmasf.dll
6c550000 00130000 dx8vb.dll
6c680000 000a0000 dx7vb.dll
6c720000 00010000 dvusd.dll
6c730000 00050000 duser.dll
6c780000 00010000 dswave.dll
6c790000 00020000 dsuiwiz.dll
6c7b0000 00020000 dsuiext.dll
6c7d0000 00010000 dssec.dll
6c7e0000 00040000 dsquery.dll
6c820000 00020000 dsprov.dll
6c850000 00030000 dsprop.dll
6c880000 00140000 dsound3d.dll
6c9d0000 00030000 dskquoui.dll
6ca00000 00020000 dskquota.dll
6ca20000 00020000 dsdmoprp.dll
6ca40000 00030000 dsdmo.dll
6ca70000 00020000 dsauth.dll
6ca90000 00090000 dsadmin.dll
6cb20000 00020000 drmstor.dll
6cb40000 00010000 dpwsockx.dll
6cb60000 00010000 dpwsock.dll
6cb70000 00020000 dpvvox.dll
6cb90000 00040000 dpvoice.dll
6cbd0000 00010000 dpvacm.dll
6cbe0000 00010000 dpserial.dll
6cc00000 00020000 dpnwsock.dll
6cc20000 00020000 dpnmodem.dll
6cc40000 00010000 dpnlobby.dll
6cc50000 00020000 dpnhupnp.dll
6cc70000 00010000 dpnhpast.dll
6cc80000 00030000 dpnet.dll
6ccb0000 00010000 dpnaddr.dll
6ccc0000 00010000 dpmodemx.dll
6ccd0000 00040000 dplayx.dll
6cd10000 00020000 dplay.dll
6cd30000 00040000 dpcres.dll
6cd70000 00020000 dpcdll.dll
6cda0000 00020000 domadmin.dll
6cdc0000 00010000 docprop2.dll
6cdd0000 00010000 docprop.dll
6cdf0000 00030000 dnsprov.dll
6ce20000 00010000 dnsperf.dll
6ce30000 000d0000 dnsmgr.dll
6cf00000 00020000 dmusic.dll
6cf20000 00020000 dmsynth.dll
6cf40000 00020000 dmstyle.dll
6cf60000 00020000 dmscript.dll
6cf80000 00010000 dmocx.dll
6cf90000 00010000 dmloader.dll
6cfa0000 00010000 dmintf.dll
6cfb0000 00030000 dmime.dll
6cff0000 00050000 dmdlgs.dll
6d040000 000d0000 dmconfig.dll
6d120000 00020000 dmcompos.dll
6d140000 00010000 dmband.dll
6d150000 00020000 divasu.dll
6d170000 00020000 divaprop.dll
6d190000 00010000 divaci.dll
6d1a0000 00020000 disrvsu.dll
6d1c0000 00010000 disrvpp.dll
6d1d0000 00010000 disrvci.dll
6d1e0000 00010000 dispex.dll
6d1f0000 00180000 diskcopy.dll
6d370000 00020000 directdb.dll
6d390000 00040000 dinput8.dll
6d3d0000 00010000 dimap.dll
6d3e0000 00020000 digirlpt.dll
6d400000 00010000 digiisdn.dll
6d410000 00020000 digiinf.dll
6d430000 00030000 digihlc.dll
6d460000 00040000 digifwrk.dll
6d4a0000 00020000 digidbp.dll
6d4d0000 00010000 digiasyn.dll
6d4f0000 00010000 diconres.dll
6d500000 00010000 diapi2nt.dll
6d510000 00010000 diapi232.dll
6d520000 00070000 diactfrm.dll
6d590000 00050000 dhcpssvc.dll
6d5e0000 000f0000 dhcpsnap.dll
6d6d0000 00020000 dhcpsapi.dll
6d6f0000 00070000 dhcpmon.dll
6d760000 00010000 dhcpmib.dll
6d770000 00020000 dgsetup.dll
6d790000 00030000 dgrpsetu.dll
6d7c0000 00030000 dgnet.dll
6d7f0000 00070000 dgconfig.dll
6d860000 00010000 dgclass.dll
6d870000 00010000 dfsshlex.dll
6d880000 00010000 dfssetup.dll
6d890000 00060000 dfsgui.dll
6d8f0000 00020000 dfscore.dll
6d910000 00030000 dfrgui.dll
6d940000 00010000 dfrgsnap.dll
6d950000 00010000 dfrgres.dll
6d970000 00010000 deskperf.dll
6d980000 00010000 deskmon.dll
6d990000 00010000 deskadp.dll
6d9a0000 00010000 debugex.dll
6d9b0000 00010000 ddrawex.dll
6d9c0000 00010000 dcpromo.dll
6d9d0000 00010000 dclsres.dll
6d9e0000 00010000 dc9res.dll
6d9f0000 00020000 dc260usd.dll
6da10000 00010000 dc24res.dll
6da20000 00020000 dc240usd.dll
6da40000 00020000 dc210usd.dll
6da60000 00010000 dc210_32.dll
6da70000 00020000 dbnetlib.dll
6da90000 00080000 dbghelp.dll
6db10000 00100000 dbgeng.dll
6dc10000 00030000 datime.dll
6dc40000 00010000 dataclen.dll
6dc60000 00100000 danim.dll
6dd60000 00020000 d3dxof.dll
6dd80000 00060000 d3drm.dll
6dde0000 000a0000 d3dramp.dll
6de80000 00010000 d3dpmesh.dll
6de90000 00080000 d3dim.dll
6df10000 00010000 d3d8thk.dll
6df20000 00130000 d3d8.dll
6e050000 00010000 cyzports.dll
6e060000 00010000 cyzcoins.dll
6e070000 00010000 cyyports.dll
6e080000 00010000 cyycoins.dll
6e090000 00010000 ctmrclas.dll
6e0a0000 00040000 ctmasetp.dll
6e0e0000 00020000 ctl3d32.dll
6e100000 00010000 ct9res.dll
6e110000 00020000 ct24res.dll
6e130000 00020000 csseqchk.dll
6e150000 00010000 csapi3t1.dll
6e170000 00030000 csamsp.dll
6e1a0000 00010000 cryptext.dll
6e1b0000 00020000 cryptdlg.dll
6e1d0000 000f0000 cqsdclr2.dll
6e2c0000 001c0000 cqsdclr1.dll
6e480000 00030000 cq90sui.dll
6e4b0000 00010000 cq90sres.dll
6e4c0000 00010000 cq90srdr.dll
6e4d0000 00060000 cq90icur.dll
6e530000 00020000 cq90fcic.dll
6e560000 00030000 cq75sui.dll
6e590000 00010000 cq75sres.dll
6e5a0000 00010000 cq75srdr.dll
6e5b0000 00060000 cq75icur.dll
6e610000 00030000 cq75fcic.dll
6e640000 00030000 cq70sui.dll
6e670000 00010000 cq70sres.dll
6e680000 00010000 cq70srdr.dll
6e690000 00060000 cq70icur.dll
6e6f0000 00020000 cq70fcic.dll
6e720000 00030000 cq60sui.dll
6e750000 00010000 cq60sres.dll
6e760000 00010000 cq60srdr.dll
6e770000 00060000 cq60icur.dll
6e7d0000 00030000 cq60fcic.dll
6e800000 00030000 cq30sui.dll
6e830000 00010000 cq30sres.dll
6e840000 00010000 cq30srdr.dll
6e850000 00060000 cq30icur.dll
6e8b0000 00030000 cq30fcic.dll
6e8e0000 00030000 cq12sui.dll
6e910000 00010000 cq12sres.dll
6e920000 00010000 cq12srdr.dll
6e930000 00060000 cq12icur.dll
6e990000 00030000 cq12fcic.dll
6e9c0000 00050000 cpscan.dll
6ea10000 00010000 counters.dll
6ea20000 00010000 corpol.dll
6ea30000 00010000 convmsg.dll
6ea40000 00010000 controt.dll
6ea50000 00020000 console.dll
6ea70000 00060000 confmsp.dll
6ead0000 00010000 confmrsl.dll
6eae0000 00080000 comuid.dll
6eb60000 00030000 comsnap.dll
6eb90000 00050000 comsetup.dll
6ebe0000 00020000 comrepl.dll
6ec00000 00040000 compstui.dll
6ec40000 00010000 compfilt.dll
6ec50000 00040000 compatui.dll
6eca0000 00010000 comcat.dll
6ecb0000 00040000 comadmin.dll
6ecf0000 00010000 comaddin.dll
6ed00000 00010000 coadmin.dll
6ed10000 00010000 cnvfat.dll
6ed20000 00010000 cnusd.dll
6ed30000 00020000 cnlbpres.dll
6ed50000 00010000 cnetcfg.dll
6ed60000 00010000 cnbs4500.dll
6ed70000 00010000 cnbs450.dll
6ed80000 00010000 cnbs400.dll
6ed90000 00010000 cnbpgr08.dll
6eda0000 00030000 cnbpgr05.dll
6edd0000 00040000 cnbpgr03.dll
6ee10000 00010000 cnbpgr02.dll
6ee20000 00010000 cnbpgr01.dll
6ee30000 00010000 cnbostd.dll
6ee40000 00010000 cnbo64.dll
6ee50000 00010000 cnbo59.dll
6ee60000 00050000 cnbjui2.dll
6eeb0000 00040000 cnbjui.dll
6eef0000 00020000 cnbjmon2.dll
6ef10000 00020000 cnbjdrv2.dll
6ef30000 00020000 cnbjdrv.dll
6ef50000 00020000 cnbjdrs.dll
6ef70000 00070000 cnbjdrc.dll
6efe0000 00010000 cnbjcres.dll
6eff0000 00010000 cnb85.dll
6f000000 00010000 cnb820.dll
6f010000 00010000 cnb8000.dll
6f020000 00010000 cnb800.dll
6f030000 00010000 cnb80.dll
6f040000 00010000 cnb7100.dll
6f050000 00010000 cnb7000.dll
6f060000 00010000 cnb70.dll
6f070000 00010000 cnb6500.dll
6f080000 00010000 cnb6200.dll
6f090000 00010000 cnb620.dll
6f0a0000 00010000 cnb6100.dll
6f0b0000 00010000 cnb610.dll
6f0c0000 00010000 cnb600e.dll
6f0d0000 00010000 cnb6000.dll
6f0e0000 00010000 cnb600.dll
6f0f0000 00010000 cnb5500.dll
6f100000 00010000 cnb55.dll
6f110000 00010000 cnb50.dll
6f120000 00010000 cnb4650.dll
6f130000 00010000 cnb4550.dll
6f140000 00010000 cnb4400.dll
6f150000 00010000 cnb4300s.dll
6f160000 00010000 cnb4300.dll
6f170000 00010000 cnb4200s.dll
6f180000 00010000 cnb4200.dll
6f190000 00010000 cnb4100.dll
6f1a0000 00010000 cnb4000.dll
6f1b0000 00010000 cnb3000.dll
6f1c0000 00010000 cnb265sp.dll
6f1d0000 00010000 cnb255sp.dll
6f1e0000 00010000 cnb250.dll
6f1f0000 00010000 cnb240.dll
6f200000 00010000 cnb210sp.dll
6f210000 00010000 cnb2100s.dll
6f220000 00010000 cnb2100.dll
6f230000 00010000 cnb210.dll
6f240000 00010000 cnb2000s.dll
6f250000 00010000 cnb2000.dll
6f260000 00010000 cnb1000s.dll
6f270000 00010000 cnb1000.dll
6f280000 00010000 cn330res.dll
6f290000 00010000 cn32602.dll
6f2a0000 00010000 cn32601.dll
6f2b0000 00010000 cn32600.dll
6f2d0000 00010000 cn2002.dll
6f2e0000 00020000 cn2001.dll
6f300000 00010000 cn2000.dll
6f320000 00010000 cn1760e2.dll
6f330000 00010000 cn1760e1.dll
6f340000 00020000 cn1760e0.dll
6f360000 00010000 cn1602.dll
6f370000 00010000 cn1601.dll
6f380000 00010000 cn1600.dll
6f3a0000 00010000 cn10002.dll
6f3b0000 00010000 cn10001.dll
6f3c0000 00010000 cn10000.dll
6f3e0000 00020000 cmutoa.dll
6f400000 00010000 cmutil.dll
6f410000 00010000 cmroute.dll
6f420000 00010000 cmproxy.dll
6f430000 00040000 cmprops.dll
6f470000 00010000 cmpbk32.dll
6f480000 00110000 cmnresm.dll
6f590000 00040000 cmnclim.dll
6f5d0000 00060000 cmdial32.dll
6f630000 00010000 cmcfg32.dll
6f640000 00020000 cluswmi.dll
6f660000 00010000 clussprt.dll
6f670000 00060000 clusres.dll
6f6d0000 00010000 clusocm.dll
6f6e0000 00010000 clusiis4.dll
6f6f0000 00010000 cluadmmc.dll
6f710000 00030000 cluadmex.dll
6f740000 00010000 clnetrex.dll
6f760000 00010000 clnetres.dll
6f770000 00090000 clcfgsrv.dll
6f810000 00020000 clbcatex.dll
6f830000 00010000 clb.dll
6f840000 00070000 class_ss.dll
6f8b0000 00050000 cladmwiz.dll
6f900000 00010000 citohres.dll
6f910000 00020000 ciodm.dll
6f930000 00140000 cimwin32.dll
6fa70000 00020000 cic.dll
6fa90000 00030000 ciadmin.dll
6fac0000 000d0000 chkrres.dll
6fb90000 00010000 chkr.dll
6fba0000 00010000 cfgbkend.dll
6fbb0000 00030000 cewmdm.dll
6fbf0000 00010000 certxds.dll
6fc00000 00040000 certtmpl.dll
6fc40000 00020000 certpdef.dll
6fc60000 00040000 certocm.dll
6fcb0000 00020000 certobj.dll
6fcd0000 00070000 certmmc.dll
6fd40000 00080000 certmgr.dll
6fdc0000 00010000 certenc.dll
6fdd0000 00020000 certdb.dll
6fdf0000 00020000 certadm.dll
6fe10000 001f0000 cdosys.dll
70010000 00010000 cdmodem.dll
70020000 00010000 cdm.dll
70030000 00030000 cdfview.dll
70060000 00010000 ccfgnt.dll
70070000 00010000 ccfg95.dll
70080000 00020000 ccfapi32.dll
700a0000 000a0000 catsrvut.dll
70140000 00020000 catsrvps.dll
70160000 00040000 catsrv.dll
701a0000 00060000 cards.dll
70200000 00030000 capesnpn.dll
70230000 00010000 camocx.dll
70240000 00020000 camext30.dll
70270000 00040000 camext20.dll
702b0000 00020000 camexo20.dll
702d0000 00020000 cabview.dll
702f0000 00010000 c_iscii.dll
70300000 00010000 c_is2022.dll
70310000 00040000 c_g18030.dll
70350000 00010000 bull9res.dll
70370000 00020000 bul24res.dll
70390000 00010000 bul18res.dll
703a0000 00010000 btpagnt.dll
703b0000 00010000 brserif.dll
703c0000 00010000 brscnrsm.dll
703d0000 00010000 brpinfo.dll
703e0000 00020000 browsewm.dll
70400000 00010000 browscap.dll
70410000 00010000 brothui.dll
70420000 00010000 brother.dll
70430000 00020000 brmfusb.dll
70450000 00010000 brmfpmon.dll
70460000 00030000 brmflpt.dll
70490000 00020000 brmfcwia.dll
704b0000 00010000 brmfbidi.dll
704c0000 000a0000 brhlres.dll
70560000 00010000 brhjres.dll
70570000 00010000 brevif.dll
70580000 00020000 brcoinst.dll
705a0000 00010000 brclrui.dll
705b0000 00010000 brclr0ui.dll
705c0000 000f0000 brclr00.dll
706b0000 00080000 brclr0.dll
70730000 00080000 brclr.dll
707b0000 00010000 brcl00ui.dll
707c0000 00010000 brbidiif.dll
707d0000 00010000 br9res.dll
707e0000 00010000 br24res.dll
70800000 00030000 bnts.dll
70830000 00060000 blue_ss.dll
70890000 00020000 binlsvc.dll
708b0000 00010000 bidispl.dll
708c0000 00010000 bhsupp.dll
708d0000 00010000 bhp025.dll
708e0000 00010000 bhp024.dll
708f0000 00010000 bhp023.dll
70900000 00010000 bhp022.dll
70910000 00020000 bhp021.dll
70940000 00020000 bhp020.dll
70960000 00030000 bhp019.dll
70990000 00010000 bhp018.dll
709a0000 00010000 bhp017.dll
709b0000 00010000 bhp016.dll
709c0000 00040000 bhp015.dll
70a00000 00010000 bhp014.dll
70a10000 00030000 bhp013.dll
70a40000 00010000 bhp012.dll
70a50000 00010000 bhp011.dll
70a60000 00010000 bhp010.dll
70a70000 00030000 bhp009.dll
70aa0000 00010000 bhp008.dll
70ab0000 00020000 bhp007.dll
70ad0000 00010000 bhp006.dll
70ae0000 00010000 bhp005.dll
70af0000 00010000 bhp004.dll
70b00000 00010000 bhp003.dll
70b10000 00010000 bhp002.dll
70b20000 00020000 bhp001.dll
70b40000 001c0000 bckgres.dll
70d10000 00020000 bckg.dll
70d30000 00010000 batt.dll
70d40000 00020000 avwav.dll
70d60000 00040000 avtapi.dll
70da0000 00010000 avmeter.dll
70db0000 00030000 avmenum.dll
70de0000 00020000 avmcoxp.dll
70e00000 00010000 avmc2032.dll
70e10000 00020000 autodisc.dll
70e30000 00010000 authfilt.dll
70e40000 00010000 audiosrv.dll
70e50000 00010000 atrace.dll
70e60000 00010000 atmpvcno.dll
70e70000 00010000 atkctrs.dll
70e80000 00020000 asycfilt.dll
70ea0000 00010000 asptxn.dll
70eb0000 00010000 aspperf.dll
70ec0000 00060000 asp51.dll
70f20000 00060000 asp.dll
70f80000 00010000 asfsipc.dll
70f90000 00010000 asferror.dll
70fa0000 00050000 appmgr.dll
70ff0000 00020000 appconf.dll
71010000 00020000 apcups.dll
71030000 00020000 amstream.dll
71050000 00010000 alrsvc.dll
71060000 00010000 alpsres.dll
71080000 00030000 air300pp.dll
710b0000 00010000 agtintl.dll
710c0000 00010000 agt0c0a.dll
710d0000 00010000 agt0816.dll
710e0000 00010000 agt0804.dll
710f0000 00010000 agt041f.dll
71100000 00010000 agt041d.dll
71110000 00010000 agt0419.dll
71120000 00010000 agt0416.dll
71130000 00010000 agt0415.dll
71140000 00010000 agt0414.dll
71150000 00010000 agt0413.dll
71160000 00010000 agt0412.dll
71170000 00010000 agt0411.dll
71180000 00010000 agt0410.dll
71190000 00010000 agt040e.dll
711a0000 00010000 agt040d.dll
711b0000 00010000 agt040c.dll
711c0000 00010000 agt040b.dll
711d0000 00010000 agt0409.dll
711e0000 00010000 agt0408.dll
711f0000 00010000 agt0407.dll
71200000 00010000 agt0406.dll
71210000 00010000 agt0405.dll
71220000 00010000 agt0404.dll
71230000 00010000 agt0401.dll
71240000 00010000 agentsr.dll
71250000 00010000 agentpsh.dll
71260000 00010000 agentmpx.dll
71270000 00010000 agentdpv.dll
71290000 00010000 agentdp2.dll
712a0000 00040000 agentctl.dll
712e0000 00010000 agentanm.dll
712f0000 00020000 adsnw.dll
71310000 00030000 adsnds.dll
71340000 00020000 adsmsext.dll
71360000 00030000 adsldp.dll
71390000 00050000 adsiis51.dll
713e0000 00050000 adsiis.dll
71430000 00010000 adrot.dll
71450000 000b0000 adprop.dll
71500000 00010000 admxprox.dll
71510000 00010000 admwprox.dll
71520000 00020000 admparse.dll
71540000 00010000 admexs.dll
71550000 00020000 acxtrnal.dll
71580000 00030000 input.dll
715b0000 00070000 acspecfc.dll
71620000 00020000 aclui.dll
71640000 00020000 OPEN
71660000 00080000 aclayers.dll
716e0000 00030000 aclua.dll
71710000 00050000 acverfyr.dll
71760000 000a0000 mstscax.dll
71800000 00030000 OPEN
71830000 00020000 acerscad.dll
71850000 00020000 acctres.dll
71870000 00010000 aaaamon.dll
71880000 00080000 a3dapi.dll
71900000 00030000 a3d.dll
71930000 00010000 OPEN
71940000 00030000 31x5us04.dll
71970000 00030000 31x5uc04.dll
719a0000 00030000 31x5rs04.dll
719d0000 00030000 31x5rc04.dll
71a00000 00010000 31x5ls04.dll
71a10000 00010000 31x5lc04.dll
71a20000 00010000 msafd.dll
71a30000 00040000 mswsock.dll
71a70000 00010000 wshtcpip.dll
71a80000 00010000 ws2help.dll
71a90000 00020000 ws2_32.dll
71ab0000 00010000 wsock32.dll
71ac0000 00020000 ntlanui.dll
71ae0000 00010000 mprui.dll
71b00000 00020000 mpr.dll
71b20000 00030000 netmsg.dll
71b50000 00030000 acledit.dll
71b80000 00050000 netui2.dll
71bd0000 00020000 samlib.dll
71bf0000 00010000 ntlanman.dll
71c00000 00050000 netapi32.dll
71c60000 00010000 netrap.dll
71c70000 00040000 netui1.dll
71cb0000 00020000 netui0.dll
71cd0000 00050000 kerberos.dll
71d20000 00020000 actxprxy.dll
71d40000 00030000 msconv97.dll
71d70000 00020000 url.dll
71d90000 00030000 syncui.dll
71dd0000 00010000 olesvr32.dll
71de0000 00010000 olecnv32.dll
71df0000 00020000 olecli32.dll
71e10000 00020000 olethk32.dll
71e30000 00020000 msapsspc.dll
71e50000 00030000 6to4svc.dll
71e70000 00010000 OPEN
71e80000 00010000 ntdsbcli.dll
71e90000 00010000 ntdsbsrv.dll
71ea0000 00020000 ntdsetup.dll
71ec0000 00010000 hticons.dll
71ed0000 00040000 netevent.dll
71f10000 00010000 wshisn.dll
71f20000 00010000 w32topl.dll
71f30000 00010000 wshnetbs.dll
71f40000 00010000 snmpapi.dll
71f50000 00010000 ipxwan.dll
71f60000 00010000 security.dll
71f70000 00010000 ureg.dll
71f80000 00050000 ulib.dll
71fd0000 00010000 ntdsatq.dll
71fe0000 00010000 uniplat.dll
71ff0000 00010000 wsnmp32.dll
72000000 00010000 mgmtapi.dll
72010000 00010000 tcpmib.dll
72020000 00020000 adptif.dll
72040000 00010000 rastapi.dll
72060000 00020000 xactsrv.dll
72080000 00020000 rasauto.dll
720a0000 00020000 ntdskcc.dll
720c0000 00010000 mssign32.dll
720d0000 00150000 ntdsa.dll
72220000 00040000 rasppp.dll
72260000 00030000 dinput.dll
72290000 00010000 sensapi.dll
722a0000 00010000 winfax.dll
722b0000 00010000 sens.dll
722c0000 00070000 ntmssvc.dll
72330000 00030000 ntmsdba.dll
72360000 00020000 polstore.dll
72380000 00010000 mmcshext.dll
72390000 00020000 hhsetup.dll
723b0000 00020000 winscard.dll
723d0000 00010000 usbmon.dll
723e0000 00010000 tcpmon.dll
723f0000 00020000 mydocs.dll
72410000 00020000 browselc.dll
72430000 00010000 rnr20.dll
72440000 00030000 rasmans.dll
72470000 00010000 ntlsapi.dll
72480000 00010000 mspmspsv.dll
724a0000 00060000 smlogcfg.dll
72500000 00010000 rassapi.dll
72510000 00050000 pdh.dll
72570000 00080000 ntmsmgr.dll
725f0000 00010000 ntmsapi.dll
72600000 00020000 mycomput.dll
72620000 00080000 msxml.dll
726b0000 00120000 mmcndmgr.dll
727d0000 00020000 mmcbase.dll
727f0000 00100000 mfc42u.dll
728f0000 00040000 localsec.dll
72930000 00060000 filemgmt.dll
72990000 00030000 els.dll
729c0000 00010000 dmutil.dll
729e0000 00020000 dmdskres.dll
72a10000 00030000 dmdskmgr.dll
72a50000 00050000 devmgr.dll
72aa0000 00040000 adsnt.dll
72ae0000 00020000 plugin.ocx
72b00000 00050000 msnsspc.dll
72b50000 00050000 OPEN
72ba0000 00010000 xrxnps.dll
72bb0000 000e0000 msdxm.ocx
72c90000 00020000 l3codecx.ax
72cb0000 00010000 msadp32.acm
72cc0000 00010000 zeeverm.dll
72cd0000 00010000 msacm32.drv
72ce0000 00010000 wdmaud.drv
72cf0000 000d0000 xxui1.dll
72dc0000 00120000 msxml3.dll
72ee0000 00030000 wmiprov.dll
72f10000 00010000 zoneoc.dll
72f20000 00020000 loadperf.dll
72f40000 00020000 wmimsg.dll
72f60000 00060000 usp10.dll
72fc0000 00030000 winspool.drv
72ff0000 00010000 wzcsapi.dll
73000000 00010000 rrcm.dll
73010000 00010000 nmasnt.dll
73020000 00010000 h323cc.dll
73030000 00010000 dcap32.dll
73040000 00020000 rsvpsp.dll
73060000 00020000 nmcom.dll
73080000 00020000 nmchat.dll
730a0000 00040000 nmas.dll
730e0000 00040000 nac.dll
73120000 00040000 mst120.dll
73160000 00060000 callcont.dll
731c0000 000c0000 winntbba.dll
73290000 00010000 softpub.dll
732a0000 00010000 riched32.dll
732b0000 00010000 mscat32.dll
732c0000 00080000 vbscript.dll
73340000 00060000 zipfldr.dll
733a0000 00040000 tapisrv.dll
733e0000 00160000 msvbvm60.dll
73540000 00010000 zonelibm.dll
73550000 00010000 traffic.dll
73560000 00030000 scrrun.dll
73590000 00040000 mstask.dll
735e0000 00010000 digest.dll
73600000 00010000 mnmdd.dll
73610000 00020000 mciavi32.dll
73630000 00010000 tsbyuv.dll
73640000 00010000 msyuv.dll
73650000 00010000 msvidc32.dll
73660000 00010000 msrle32.dll
73670000 00010000 msdmo.dll
73680000 00010000 iyuv_32.dll
73690000 00030000 qcap.dll
736d0000 00050000 ir50_qcx.dll
73720000 00050000 ddraw.dll
73770000 00060000 ir41_qcx.dll
737d0000 00060000 ir32_32.dll
73830000 000d0000 ir50_32.dll
73900000 000d0000 d3dim700.dll
739d0000 00020000 xrxwiadr.dll
73a00000 00060000 wiaservc.dll
73a60000 00010000 znetm.dll
73a70000 00020000 zoneclim.dll
73aa0000 00050000 msvcrt20.dll
73af0000 00020000 mscms.dll
73b10000 00020000 avifil32.dll
73b30000 00010000 tsd32.dll
73b40000 00020000 avicap32.dll
73b60000 00020000 sti.dll
73b80000 00010000 dciman32.dll
73b90000 00020000 msvfw32.dll
73bc0000 00020000 iccvid.dll
73be0000 00010000 atmlib.dll
73bf0000 000b0000 spxports.dll
73ca0000 00040000 t2embed.dll
73ce0000 00010000 seclogon.dll
73cf0000 00020000 wbemcons.dll
73d10000 00010000 cryptnet.dll
73d30000 00020000 shgina.dll
73d50000 00030000 crtdll.dll
73d80000 00010000 lz32.dll
73d90000 00100000 mfc42.dll
73e90000 00010000 mmdrv.dll
73ea0000 00010000 ksuser.dll
73eb0000 00010000 devenum.dll
73ed0000 00060000 dsound.dll
73f30000 00150000 quartz.dll
74080000 00150000 msvbvm50.dll
741d0000 00020000 sfman32.dll
741f0000 00050000 devcon32.dll
74240000 00010000 pjlmon.dll
74250000 00010000 icmp.dll
74260000 00010000 cnbjmon.dll
74280000 00020000 win32spl.dll
742b0000 00020000 spoolss.dll
742d0000 00020000 inetpp.dll
742f0000 00050000 localspl.dll
74340000 00010000 winipsec.dll
74350000 00010000 wdigest.dll
74370000 00010000 pstorsvc.dll
74380000 00010000 msprivs.dll
74390000 00020000 psbase.dll
743b0000 00030000 ipsecsvc.dll
743e0000 00030000 scecli.dll
74410000 00070000 samsrv.dll
74480000 00070000 netlogon.dll
744f0000 000b0000 lsasrv.dll
745a0000 000c0000 oakley.dll
74660000 00030000 xuim760.dll
74690000 00030000 msls31.dll
746c0000 00030000 msimtf.dll
746f0000 00050000 msctf.dll
74740000 00090000 mlang.dll
747e0000 002c0000 mshtml.dll
74aa0000 00010000 powrprof.dll
74ab0000 00010000 cfgmgr32.dll
74ac0000 00010000 batmeter.dll
74ad0000 00020000 stobject.dll
74b00000 00050000 webcheck.dll
74b50000 00090000 printui.dll
74be0000 00010000 ssdpsrv.dll
74bf0000 00010000 regsvc.dll
74c10000 00010000 lmhsvc.dll
74c20000 00020000 msdart.dll
74c50000 00030000 oleacc.dll
74c80000 00070000 mshtmled.dll
74d00000 00020000 oledlg.dll
74d30000 00020000 msoert2.dll
74d60000 000a0000 inetcomm.dll
74e00000 00070000 riched20.dll
74e70000 00010000 wshext.dll
74e90000 00010000 wuauserv.dll
74ea0000 00010000 wbemsvc.dll
74ec0000 00010000 wbemprox.dll
74ed0000 00010000 ssdpapi.dll
74ee0000 00020000 rastls.dll
74f00000 00010000 xxpsru1.dll
74f10000 00010000 pchsvc.dll
74f20000 00010000 msidle.dll
74f30000 00010000 msgsvc.dll
74f40000 00010000 icaapi.dll
74f50000 00010000 ersvc.dll
74f60000 00010000 dmserver.dll
74f70000 00010000 cryptsvc.dll
74f90000 00020000 clusapi.dll
74fb0000 00010000 browser.dll
74fd0000 00020000 raschap.dll
74ff0000 00020000 wmiutils.dll
75010000 00030000 upnp.dll
75040000 00020000 trkwks.dll
75060000 00020000 srvsvc.dll
75080000 00020000 resutils.dll
750a0000 00020000 mtxoci.dll
750c0000 00020000 mtxclu.dll
750e0000 00020000 mstlsapi.dll
75100000 00020000 colbact.dll
75120000 00020000 cabinet.dll
75140000 00020000 wkssvc.dll
75170000 00030000 srsvc.dll
751a0000 00030000 schedsvc.dll
751d0000 00030000 repdrvfs.dll
75200000 00030000 appmgmts.dll
75230000 00030000 advpack.dll
75260000 00040000 wbemcomn.dll
752a0000 00040000 termsrv.dll
752e0000 00040000 esscli.dll
75320000 00030000 certcli.dll
75360000 00050000 wbemess.dll
753b0000 00070000 vssapi.dll
75420000 00080000 wbemcore.dll
754a0000 00080000 cryptui.dll
75520000 000a0000 rasdlg.dll
755d0000 000a0000 netcfgx.dll
75670000 000a0000 fastprox.dll
75710000 00120000 comsvcs.dll
75830000 00050000 rpcss.dll
75880000 00010000 eventlog.dll
758a0000 00020000 umpnpmgr.dll
758c0000 00050000 scesrv.dll
75910000 00010000 profmap.dll
75920000 00010000 nddeapi.dll
75930000 00020000 wlnotify.dll
75950000 00100000 msgina.dll
75a50000 000b0000 userenv.dll
75b00000 00020000 xcci2032.dll
75b20000 00010000 csrsrv.dll
75b30000 00010000 basesrv.dll
75b40000 00050000 winsrv.dll
75b90000 000a0000 unires.dll
75c30000 000a0000 jscript.dll
75cd0000 001a0000 netshell.dll
75e70000 000b0000 sxs.dll
75f20000 00020000 apphelp.dll
75f40000 00010000 drprov.dll
75f50000 00010000 davclnt.dll
75f60000 00100000 browseui.dll
76060000 00070000 msvcp60.dll
760d0000 00080000 urlmon.dll
76150000 00090000 shdoclc.dll
761e0000 000a0000 wininet.dll
76280000 00010000 msasn1.dll
762a0000 00090000 crypt32.dll
76330000 00010000 zcorem.dll
76340000 00010000 winsta.dll
76360000 00010000 msimg32.dll
76370000 00020000 imm32.dll
76390000 00050000 comdlg32.dll
763e0000 00200000 msi.dll
765e0000 00020000 cscdll.dll
76600000 00050000 cscui.dll
76660000 000f0000 setupapi.dll
76750000 00010000 mf3216.dll
76760000 00010000 dnsrslvr.dll
76770000 00010000 shfolder.dll
76780000 00010000 cryptdll.dll
76790000 00020000 ntdsapi.dll
767b0000 00030000 w32time.dll
767e0000 00030000 schannel.dll
76810000 00020000 hlink.dll
76830000 00040000 unidrvui.dll
76870000 00040000 unidrv.dll
768c0000 000b0000 pcl5eres.dll
76970000 00010000 linkinfo.dll
76980000 00030000 ntshrui.dll
769b0000 00150000 shdocvw.dll
76b00000 00010000 ctwdm32.dll
76b10000 00020000 atl.dll
76b30000 00030000 winmm.dll
76b60000 00040000 es.dll
76ba0000 00010000 sfc.dll
76bb0000 00010000 regapi.dll
76bc0000 00020000 shsvcs.dll
76be0000 00010000 psapi.dll
76bf0000 00030000 credui.dll
76c20000 00030000 wintrust.dll
76c50000 00030000 sfc_os.dll
76c80000 00030000 imagehlp.dll
76cb0000 00010000 authz.dll
76cd0000 00020000 ntmarta.dll
76d00000 00020000 msv1_0.dll
76d20000 00010000 wmi.dll
76d30000 00020000 mprapi.dll
76d50000 00020000 iphlpapi.dll
76d70000 00020000 dhcpcsvc.dll
76d90000 00040000 wuaueng.dll
76dd0000 00030000 netman.dll
76e00000 00030000 adsldpc.dll
76e30000 00030000 activeds.dll
76e70000 00010000 rtutils.dll
76e80000 00020000 rasman.dll
76ea0000 00030000 tapi32.dll
76ed0000 00040000 rasapi32.dll
76f10000 00030000 dnsapi.dll
76f40000 00010000 wtsapi32.dll
76f50000 00030000 wldap32.dll
76f80000 00010000 secur32.dll
76fa0000 00010000 winrnr.dll
76fb0000 00010000 rasadhlp.dll
76fc0000 00080000 clbcatq.dll
77040000 000d0000 comres.dll
77110000 00090000 oleaut32.dll
771a0000 00120000 ole32.dll
772c0000 00070000 shlwapi.dll
773c0000 00800000 shell32.dll
77bc0000 00010000 midimap.dll
77bd0000 00020000 msacm32.dll
77bf0000 00010000 version.dll
77c00000 00060000 msvcrt.dll
77c60000 00040000 gdi32.dll
77ca0000 00050000 wzcsvc.dll
77cf0000 00040000 OPEN
77d30000 00090000 user32.dll
77dc0000 000a0000 advapi32.dll
77e60000 000f0000 kernel32.dll
77f50000 000b0000 ntdll.dll
78000000 00090000 rpcrt4.dll
78190000 001b0000 asms\10100\msft\windows\gdiplus\gdiplus.dll
7c000000 00130000 msvidctl.dll
7c130000 00160000 query.dll
7c290000 001e0000 acgenral.dll
7d650000 00010000 ntvdm64.dll
7d670000 00010000 kbdurs.dll
7d740000 00010000 kbdinori.dll
7d760000 00010000 kbdinmal.dll
7d7b0000 00010000 kbdinben.dll
7d7c0000 00010000 kbdinasa.dll
7d7d0000 00010000 kbdhebx.dll
7d850000 00010000 isetuc0c.dll
7d860000 00010000 isetu816.dll
7d870000 00010000 isetu804.dll
7d880000 00010000 isetu416.dll
7d890000 00010000 isetu40c.dll
7d8a0000 00010000 isetu404.dll
7d8b0000 00010000 isetu02d.dll
7d8c0000 00010000 isetu024.dll
7d8d0000 00010000 isetu021.dll
7d8e0000 00010000 isetu01f.dll
7d8f0000 00010000 isetu01e.dll
7d900000 00010000 isetu01d.dll
7d910000 00010000 isetu01b.dll
7d920000 00010000 isetu01a.dll
7d930000 00010000 isetu019.dll
7d940000 00010000 isetu015.dll
7d950000 00010000 isetu014.dll
7d960000 00010000 isetu013.dll
7d970000 00010000 isetu012.dll
7d980000 00010000 isetu011.dll
7d990000 00010000 isetu010.dll
7d9a0000 00010000 isetu00e.dll
7d9b0000 00010000 isetu00b.dll
7d9c0000 00010000 isetu00a.dll
7d9d0000 00010000 isetu009.dll
7d9e0000 00010000 isetu008.dll
7d9f0000 00010000 isetu007.dll
7da00000 00010000 isetu006.dll
7da10000 00010000 isetu005.dll
7da20000 00010000 isetu003.dll
7da40000 00010000 _setup.dll
7DAE0000 00070000 wow6432\imm32.dll
7DB50000 00060000 wow6432\secur32.dll
7DBB0000 00090000 wow6432\gdi32.dll
7DC40000 000d0000 wow6432\rpcrt4.dll
7DD10000 000d0000 wow6432\user32.dll
7DDE0000 00120000 wow6432\kernel32.dll
7DF00000 00100000 wow6432\ntdll.dll
bfdd0000 001b0000 g400d.dll
bfdd0000 001b0000 nv4.dll
bfed0000 000b0000 3dfxvs.dll
bfee0000 00090000 i81xdnt5.dll
bff00000 00080000 g200d.dll
bff10000 00060000 sgiul50.dll
bff10000 00070000 tridkb.dll
bff20000 00060000 atidrab.dll
bff20000 00060000 atidvag.dll
bff20000 00060000 banshee.dll
bff20000 00060000 i740dnt5.dll
bff30000 00050000 ati2draa.dll
bff30000 00050000 atidvai.dll
bff30000 00050000 trid3d.dll
bff40000 00040000 mgaud.dll
bff40000 00040000 perm2dll.dll
bff40000 00040000 perm3dd.dll
bff40000 00040000 s3mvirge.dll
bff40000 00040000 s3nb.dll
bff40000 00040000 s3sav4.dll
bff40000 00040000 s3savmx.dll
bff40000 00040000 sis300iv.dll
bff50000 00020000 nv3.dll
bff50000 00030000 atidrae.dll
bff50000 00030000 cl546x.dll
bff50000 00030000 s3mt3d.dll
bff50000 00030000 s3sav3d.dll
bff50000 00030000 sis6306v.dll
bff50000 00030000 sisv256.dll
bff50000 00030000 smidispb.dll
bff50000 00030000 t2r4disp.dll
bff60000 00010000 n9i128v2.dll
bff60000 00010000 neo20xx.dll
bff60000 00010000 s3mtrio.dll
bff60000 00020000 ati.dll
bff60000 00020000 atiraged.dll
bff60000 00020000 cirrus.dll
bff60000 00020000 cl5465.dll
bff60000 00020000 n9i3disp.dll
bff60000 00020000 s3legacy.dll
bff60000 00020000 tgiul50.dll
bff70000 00010000 8514a.dll
bff70000 00010000 framebuf.dll
bff70000 00010000 n9i128.dll
bff70000 00010000 vga.dll
bff70000 00010000 vga256.dll
bff70000 00010000 vga64k.dll
bff70000 00010000 w32.dll
bff70000 00010000 weitekp9.dll
bff80000 00020000 dxg.sys
bffa0000 00050000 atmfd.dll
78090000 000f0000 asms\60100\msft\windows\common\controls\comctl32.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\managed\urt\v1.0.3705\aspnet_perf.h ===
#define OBJECT_1                                           0
#define OBJECT_2                                           2
#define ASPNET_APPLICATION_RESTARTS                        4
#define ASPNET_APPLICATIONS_RUNNING                        6
#define ASPNET_REQUESTS_DISCONNECTED                       8
#define ASPNET_REQUEST_EXECUTION_TIME                      10
#define ASPNET_REQUESTS_REJECTED                           12
#define ASPNET_REQUESTS_QUEUED                             14
#define ASPNET_WPS_RUNNING                                 16
#define ASPNET_WPS_RESTARTS                                18
#define ASPNET_REQUEST_WAIT_TIME                           20
#define ASPNET_STATE_SERVER_SESSIONS_ACTIVE                22
#define ASPNET_STATE_SERVER_SESSIONS_ABANDONED             24
#define ASPNET_STATE_SERVER_SESSIONS_TIMED_OUT             26
#define ASPNET_STATE_SERVER_SESSIONS_TOTAL                 28
#define ASPNET_ANONYMOUS_REQUESTS                          30
#define ASPNET_ANONYMOUS_REQUESTS_RATE                     32
#define ASPNET_TOTAL_CACHE_ENTRIES                         34
#define ASPNET_TOTAL_CACHE_TURNOVER_RATE                   36
#define ASPNET_TOTAL_CACHE_HITS                            38
#define ASPNET_TOTAL_CACHE_MISSES                          40
#define ASPNET_TOTAL_CACHE_RATIO                           42
#define ASPNET_TOTAL_CACHE_RATIO_BASE                      44
#define ASPNET_API_CACHE_ENTRIES                           46
#define ASPNET_API_CACHE_TURNOVER_RATE                     48
#define ASPNET_API_CACHE_HITS                              50
#define ASPNET_API_CACHE_MISSES                            52
#define ASPNET_API_CACHE_RATIO                             54
#define ASPNET_API_CACHE_RATIO_BASE                        56
#define ASPNET_OUTPUT_CACHE_ENTRIES                        58
#define ASPNET_OUTPUT_CACHE_TURNOVER_RATE                  60
#define ASPNET_OUTPUT_CACHE_HITS                           62
#define ASPNET_OUTPUT_CACHE_MISSES                         64
#define ASPNET_OUTPUT_CACHE_RATIO                          66
#define ASPNET_OUTPUT_CACHE_RATIO_BASE                     68
#define ASPNET_COMPILATIONS                                70
#define ASPNET_DEBUGGING_REQUESTS                          72
#define ASPNET_ERRORS_PRE_PROCESSING                       74
#define ASPNET_ERRORS_COMPILING                            76
#define ASPNET_ERRORS_DURING_REQUEST                       78
#define ASPNET_ERRORS_UNHANDLED                            80
#define ASPNET_ERRORS_UNHANDLED_RATE                       82
#define ASPNET_ERRORS_TOTAL                                84
#define ASPNET_ERRORS_TOTAL_RATE                           86
#define ASPNET_PIPELINES                                   88
#define ASPNET_REQUEST_BYTES_IN                            90
#define ASPNET_REQUEST_BYTES_OUT                           92
#define ASPNET_REQUESTS_EXECUTING                          94
#define ASPNET_REQUESTS_FAILED                             96
#define ASPNET_REQUESTS_NOT_FOUND                          98
#define ASPNET_REQUESTS_NOT_AUTHORIZED                     100
#define ASPNET_REQUESTS_TIMED_OUT                          102
#define ASPNET_REQUESTS_SUCCEDED                           104
#define ASPNET_REQUESTS_TOTAL                              106
#define ASPNET_REQUESTS_TOTAL_RATE                         108
#define ASPNET_SESSIONS_ACTIVE                             110
#define ASPNET_SESSIONS_ABANDONED                          112
#define ASPNET_SESSIONS_TIMED_OUT                          114
#define ASPNET_SESSIONS_TOTAL                              116
#define ASPNET_TRANSACTIONS_ABORTED                        118
#define ASPNET_TRANSACTIONS_COMMITTED                      120
#define ASPNET_TRANSACTIONS_PENDING                        122
#define ASPNET_TRANSACTIONS_TOTAL                          124
#define ASPNET_TRANSACTIONS_RATE                           126
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\managed\urt\v1.0.3705\corperfmonsymbols.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------ 
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//------------------------------------------------------------------------ 
#define DotNetCLR_Memory_OBJECT                            0
#define GEN0_COLLECTIONS_COUNTER                           2
#define GEN1_COLLECTIONS_COUNTER                           4
#define GEN2_COLLECTIONS_COUNTER                           6
#define GEN0_BYTES_PROMOTED_COUNTER                        8
#define GEN1_BYTES_PROMOTED_COUNTER                        10
#define GEN0_PROMOTION_RATE                                12
#define GEN1_PROMOTION_RATE                                14
#define GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER           16
#define GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER           18
#define GEN0_HEAP_SIZE_COUNTER                             20
#define GEN1_HEAP_SIZE_COUNTER                             22
#define GEN2_HEAP_SIZE_COUNTER                             24
#define LARGE_OBJECT_SIZE_COUNTER                          26
#define SURVIVE_FINALIZE_COUNTER                           28
#define NUM_HANDLES_COUNTER                                30
#define ALLOCATION_RATE_COUNTER                            32
#define INDUCED_GC_COUNTER                                 34
#define PER_TIME_IN_GC_COUNTER                             36
#define PER_TIME_IN_GC_COUNTER_BASE                        38
#define TOTAL_HEAP_SIZE_COUNTER                            40
#define TOTAL_COMMITTED_MEM_COUNTER                        42
#define TOTAL_RESERVED_MEM_COUNTER                         44
#define GC_PINNED_OBJECTS                                  46
#define GC_SINKBLOCKS                                      48
#define DotNetCLR_Loading_OBJECT                           50
#define LOADING_CLASSES_TOTAL                              52
#define LOADING_TIME                                       54
#define LOADING_ASMSEARCHLEN                               56
#define LOADING_LOADFAILURES_TOTAL                         58
#define LOADING_LOADFAILURES_INST                          60
#define LOADING_HEAPSIZE                                   62
#define LOADING_APPDOMAINS_UNLOADED_TOTAL                  64
#define LOADING_APPDOMAINS_UNLOADED_INST                   66
#define LOADING_CLASSES_CUR                                68
#define LOADING_CLASSES_INST                               70
#define LOADING_APPDOMAINS_CUR                             72
#define LOADING_APPDOMAINS_TOTAL                           74
#define LOADING_APPDOMAINS_INST                            76
#define LOADING_ASSEMBLIES_CUR                             78
#define LOADING_ASSEMBLIES_TOTAL                           80
#define LOADING_ASSEMBLIES_INST                            82
#define DotNetCLR_Jit_OBJECT                               84
#define TOTAL_METHODS_JITTED                               86
#define JITTED_IL_CUR                                      88
#define JITTED_IL_TOTAL                                    90
#define JITTED_IL_INST                                     92
#define JIT_FAILURES                                       94
#define TIME_IN_JIT                                        96
#define TIME_IN_JIT_BASE                                   98
#define DotNetCLR_Interop_OBJECT                           100
#define CURRENT_CCW                                        102
#define CURRENT_STUBS                                      104
#define NUM_MARSHALLING                                    106
#define TOTAL_TLB_IMPORTS                                  108
#define TOTAL_TLB_EXPORTS                                  110
#define DotNetCLR_LocksAndThreads_OBJECT                   112
#define CONTENTION_TOTAL                                   114
#define CONTENTION_INST                                    116
#define QUEUE_LENGTH_CUR                                   118
#define QUEUE_LENGTH_TOTAL                                 120
#define QUEUE_LENGTH_INST                                  122
#define CURRENT_LOGICAL_THREADS                            124
#define CURRENT_PHYSICAL_THREADS                           126
#define RECOGNIZED_THREADS_CUR                             128
#define RECOGNIZED_THREADS_TOTAL                           130
#define RECOGNIZED_THREADS_INST                            132
#define DotNetCLR_Security_OBJECT                          134
#define SECURITY_TOTALRTCHECKS                             136
#define SECURITY_TIMEAUTHORIZE                             138
#define SECURITY_LINKCHECKS                                140
#define SECURITY_TIMERTCHECKS                              142
#define SECURITY_TIMERTCHECKS_BASE                         144
#define SECURITY_DEPTHSECURITY                             146
#define DotNetCLR_Remoting_OBJECT                          148
#define CONTEXT_REMOTECALLS_INST                           150
#define CONTEXT_CHANNELS                                   152
#define CONTEXT_PROXIES                                    154
#define CONTEXT_CLASSES                                    156
#define CONTEXT_OBJALLOC                                   158
#define CONTEXT_CONTEXTS                                   160
#define CONTEXT_REMOTECALLS_TOTAL                          162
#define DotNetCLR_Excep_OBJECT                             164
#define EXCEP_THROWN_TOTAL                                 166
#define EXCEP_THROWN_INST                                  168
#define TOTAL_EXCEP_FILTERS_RUN                            170
#define TOTAL_EXCEP_FINALLYS_RUN                           172
#define EXCEPT_STACK_DEPTH                                 174
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\managed\urt\v1.0.3705\_dataperfcounters.h ===
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
#define DEVICE_COUNTER_6 12;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\buildinfo.h ===
/* BuildInfo.h
 *
 * (c) 1999 ActiveState Tool Corp. All rights reserved. 
 *
 */

#ifndef ___BuildInfo__h___
#define ___BuildInfo__h___

#define PRODUCT_BUILD_NUMBER	"521"
#define PERLFILEVERSION		"5,2,1,0\0"
#define PERLRC_VERSION		5,2,1,0
#define PERLPRODUCTVERSION	"Build " PRODUCT_BUILD_NUMBER "\0"
#define PERLPRODUCTNAME		"ActivePerl\0"

#define ACTIVEPERL_VERSION	"Built "##__TIME__##" "##__DATE__##"\n"
#define ACTIVEPERL_LOCAL_PATCHES_ENTRY	"ActivePerl Build " PRODUCT_BUILD_NUMBER
#define BINARY_BUILD_NOTICE	printf("\n\
Binary build "##PRODUCT_BUILD_NUMBER##" provided by ActiveState Tool Corp. http://www.ActiveState.com\n\
" ACTIVEPERL_VERSION "\n");

#endif  /* ___BuildInfo__h___ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\av.h ===
/*    av.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct xpvav {
    char*	xav_array;      /* pointer to first array element */
    SSize_t	xav_fill;       /* Index of last element present */
    SSize_t	xav_max;        /* Number of elements for which array has space */
    IV		xof_off;	/* ptr is incremented by offset */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* magic for scalar array */
    HV*		xmg_stash;	/* class package */

    SV**	xav_alloc;	/* pointer to malloced string */
    SV*		xav_arylen;
    U8		xav_flags;
};

#define AVf_REAL 1	/* free old entries */
#define AVf_REIFY 2	/* can become real */
#define AVf_REUSED 4	/* got undeffed--don't turn old memory into SVs now */

#define Nullav Null(AV*)

#define AvARRAY(av)	((SV**)((XPVAV*)  SvANY(av))->xav_array)
#define AvALLOC(av)	((XPVAV*)  SvANY(av))->xav_alloc
#define AvMAX(av)	((XPVAV*)  SvANY(av))->xav_max
#define AvFILLp(av)	((XPVAV*)  SvANY(av))->xav_fill
#define AvARYLEN(av)	((XPVAV*)  SvANY(av))->xav_arylen
#define AvFLAGS(av)	((XPVAV*)  SvANY(av))->xav_flags

#define AvREAL(av)	(AvFLAGS(av) & AVf_REAL)
#define AvREAL_on(av)	(AvFLAGS(av) |= AVf_REAL)
#define AvREAL_off(av)	(AvFLAGS(av) &= ~AVf_REAL)
#define AvREIFY(av)	(AvFLAGS(av) & AVf_REIFY)
#define AvREIFY_on(av)	(AvFLAGS(av) |= AVf_REIFY)
#define AvREIFY_off(av)	(AvFLAGS(av) &= ~AVf_REIFY)
#define AvREUSED(av)	(AvFLAGS(av) & AVf_REUSED)
#define AvREUSED_on(av)	(AvFLAGS(av) |= AVf_REUSED)
#define AvREUSED_off(av) (AvFLAGS(av) &= ~AVf_REUSED)

#define AvREALISH(av)	(AvFLAGS(av) & (AVf_REAL|AVf_REIFY))
                                          
#define AvFILL(av)	((SvRMAGICAL((SV *) (av))) \
			  ? mg_size((SV *) av) : AvFILLp(av))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\byterun.h ===
/*
 *      Copyright (c) 1996-1998 Malcolm Beattie
 *
 *      You may distribute under the terms of either the GNU General Public
 *      License or the Artistic License, as specified in the README file.
 *
 */
/*
 * This file is autogenerated from bytecode.pl. Changes made here will be lost.
 */
#ifdef INDIRECT_BGET_MACROS
struct bytestream {
    void *data;
    int (*fgetc)(void *);
    int (*fread)(char *, size_t, size_t, void*);
    void (*freadpv)(U32, void*);
};
#endif /* INDIRECT_BGET_MACROS */

void *bset_obj_store _((void *, I32));

enum {
    INSN_RET,			/* 0 */
    INSN_LDSV,			/* 1 */
    INSN_LDOP,			/* 2 */
    INSN_STSV,			/* 3 */
    INSN_STOP,			/* 4 */
    INSN_LDSPECSV,			/* 5 */
    INSN_NEWSV,			/* 6 */
    INSN_NEWOP,			/* 7 */
    INSN_NEWOPN,			/* 8 */
    INSN_NEWPV,			/* 9 */
    INSN_NOP,			/* 10 */
    INSN_PV_CUR,			/* 11 */
    INSN_PV_FREE,			/* 12 */
    INSN_SV_UPGRADE,			/* 13 */
    INSN_SV_REFCNT,			/* 14 */
    INSN_SV_REFCNT_ADD,			/* 15 */
    INSN_SV_FLAGS,			/* 16 */
    INSN_XRV,			/* 17 */
    INSN_XPV,			/* 18 */
    INSN_XIV32,			/* 19 */
    INSN_XIV64,			/* 20 */
    INSN_XNV,			/* 21 */
    INSN_XLV_TARGOFF,			/* 22 */
    INSN_XLV_TARGLEN,			/* 23 */
    INSN_XLV_TARG,			/* 24 */
    INSN_XLV_TYPE,			/* 25 */
    INSN_XBM_USEFUL,			/* 26 */
    INSN_XBM_PREVIOUS,			/* 27 */
    INSN_XBM_RARE,			/* 28 */
    INSN_XFM_LINES,			/* 29 */
    INSN_XIO_LINES,			/* 30 */
    INSN_XIO_PAGE,			/* 31 */
    INSN_XIO_PAGE_LEN,			/* 32 */
    INSN_XIO_LINES_LEFT,			/* 33 */
    INSN_XIO_TOP_NAME,			/* 34 */
    INSN_COMMENT,			/* 35 */
    INSN_XIO_TOP_GV,			/* 36 */
    INSN_XIO_FMT_NAME,			/* 37 */
    INSN_XIO_FMT_GV,			/* 38 */
    INSN_XIO_BOTTOM_NAME,			/* 39 */
    INSN_XIO_BOTTOM_GV,			/* 40 */
    INSN_XIO_SUBPROCESS,			/* 41 */
    INSN_XIO_TYPE,			/* 42 */
    INSN_XIO_FLAGS,			/* 43 */
    INSN_XCV_STASH,			/* 44 */
    INSN_XCV_START,			/* 45 */
    INSN_XCV_ROOT,			/* 46 */
    INSN_XCV_GV,			/* 47 */
    INSN_XCV_FILEGV,			/* 48 */
    INSN_XCV_DEPTH,			/* 49 */
    INSN_XCV_PADLIST,			/* 50 */
    INSN_XCV_OUTSIDE,			/* 51 */
    INSN_XCV_FLAGS,			/* 52 */
    INSN_AV_EXTEND,			/* 53 */
    INSN_AV_PUSH,			/* 54 */
    INSN_XAV_FILL,			/* 55 */
    INSN_XAV_MAX,			/* 56 */
    INSN_XAV_FLAGS,			/* 57 */
    INSN_XHV_RITER,			/* 58 */
    INSN_XHV_NAME,			/* 59 */
    INSN_HV_STORE,			/* 60 */
    INSN_SV_MAGIC,			/* 61 */
    INSN_MG_OBJ,			/* 62 */
    INSN_MG_PRIVATE,			/* 63 */
    INSN_MG_FLAGS,			/* 64 */
    INSN_MG_PV,			/* 65 */
    INSN_XMG_STASH,			/* 66 */
    INSN_GV_FETCHPV,			/* 67 */
    INSN_GV_STASHPV,			/* 68 */
    INSN_GP_SV,			/* 69 */
    INSN_GP_REFCNT,			/* 70 */
    INSN_GP_REFCNT_ADD,			/* 71 */
    INSN_GP_AV,			/* 72 */
    INSN_GP_HV,			/* 73 */
    INSN_GP_CV,			/* 74 */
    INSN_GP_FILEGV,			/* 75 */
    INSN_GP_IO,			/* 76 */
    INSN_GP_FORM,			/* 77 */
    INSN_GP_CVGEN,			/* 78 */
    INSN_GP_LINE,			/* 79 */
    INSN_GP_SHARE,			/* 80 */
    INSN_XGV_FLAGS,			/* 81 */
    INSN_OP_NEXT,			/* 82 */
    INSN_OP_SIBLING,			/* 83 */
    INSN_OP_PPADDR,			/* 84 */
    INSN_OP_TARG,			/* 85 */
    INSN_OP_TYPE,			/* 86 */
    INSN_OP_SEQ,			/* 87 */
    INSN_OP_FLAGS,			/* 88 */
    INSN_OP_PRIVATE,			/* 89 */
    INSN_OP_FIRST,			/* 90 */
    INSN_OP_LAST,			/* 91 */
    INSN_OP_OTHER,			/* 92 */
    INSN_OP_TRUE,			/* 93 */
    INSN_OP_FALSE,			/* 94 */
    INSN_OP_CHILDREN,			/* 95 */
    INSN_OP_PMREPLROOT,			/* 96 */
    INSN_OP_PMREPLROOTGV,			/* 97 */
    INSN_OP_PMREPLSTART,			/* 98 */
    INSN_OP_PMNEXT,			/* 99 */
    INSN_PREGCOMP,			/* 100 */
    INSN_OP_PMFLAGS,			/* 101 */
    INSN_OP_PMPERMFLAGS,			/* 102 */
    INSN_OP_SV,			/* 103 */
    INSN_OP_GV,			/* 104 */
    INSN_OP_PV,			/* 105 */
    INSN_OP_PV_TR,			/* 106 */
    INSN_OP_REDOOP,			/* 107 */
    INSN_OP_NEXTOP,			/* 108 */
    INSN_OP_LASTOP,			/* 109 */
    INSN_COP_LABEL,			/* 110 */
    INSN_COP_STASH,			/* 111 */
    INSN_COP_FILEGV,			/* 112 */
    INSN_COP_SEQ,			/* 113 */
    INSN_COP_ARYBASE,			/* 114 */
    INSN_COP_LINE,			/* 115 */
    INSN_MAIN_START,			/* 116 */
    INSN_MAIN_ROOT,			/* 117 */
    INSN_CURPAD,			/* 118 */
    MAX_INSN = 118
};

enum {
    OPt_OP,		/* 0 */
    OPt_UNOP,		/* 1 */
    OPt_BINOP,		/* 2 */
    OPt_LOGOP,		/* 3 */
    OPt_CONDOP,		/* 4 */
    OPt_LISTOP,		/* 5 */
    OPt_PMOP,		/* 6 */
    OPt_SVOP,		/* 7 */
    OPt_GVOP,		/* 8 */
    OPt_PVOP,		/* 9 */
    OPt_LOOP,		/* 10 */
    OPt_COP		/* 11 */
};

EXT int optype_size[]
#ifdef DOINIT
= {
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(CONDOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(GVOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP)
}
#endif /* DOINIT */
;

#define INIT_SPECIALSV_LIST STMT_START { \
	PL_specialsv_list[0] = Nullsv; \
	PL_specialsv_list[1] = &PL_sv_undef; \
	PL_specialsv_list[2] = &PL_sv_yes; \
	PL_specialsv_list[3] = &PL_sv_no; \
    } STMT_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\managed\urt\v1.0.3705\_networkingperfcounters.h ===
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\bytecode.h ===
typedef char *pvcontents;
typedef char *strconst;
typedef U32 PV;
typedef char *op_tr_array;
typedef int comment_t;
typedef SV *svindex;
typedef OP *opindex;
typedef IV IV64;

#ifdef INDIRECT_BGET_MACROS
#define BGET_FREAD(argp, len, nelem)	\
	 bs.fread((char*)(argp),(len),(nelem),bs.data)
#define BGET_FGETC() bs.fgetc(bs.data)
#else
#define BGET_FREAD(argp, len, nelem) PerlIO_read(fp, (argp), (len)*(nelem))
#define BGET_FGETC() PerlIO_getc(fp)
#endif /* INDIRECT_BGET_MACROS */

#define BGET_U32(arg)	\
	BGET_FREAD(&arg, sizeof(U32), 1); arg = PerlSock_ntohl((U32)arg)
#define BGET_I32(arg)	\
	BGET_FREAD(&arg, sizeof(I32), 1); arg = (I32)PerlSock_ntohl((U32)arg)
#define BGET_U16(arg)	\
	BGET_FREAD(&arg, sizeof(U16), 1); arg = PerlSock_ntohs((U16)arg)
#define BGET_U8(arg)	arg = BGET_FGETC()

#if INDIRECT_BGET_MACROS
#define BGET_PV(arg)	STMT_START {	\
	BGET_U32(arg);			\
	if (arg)			\
	    bs.freadpv(arg, bs.data);	\
	else {				\
	    PL_bytecode_pv.xpv_pv = 0;		\
	    PL_bytecode_pv.xpv_len = 0;		\
	    PL_bytecode_pv.xpv_cur = 0;		\
	}				\
    } STMT_END
#else
#define BGET_PV(arg)	STMT_START {		\
	BGET_U32(arg);				\
	if (arg) {				\
	    New(666, PL_bytecode_pv.xpv_pv, arg, char);	\
	    PerlIO_read(fp, PL_bytecode_pv.xpv_pv, arg);	\
	    PL_bytecode_pv.xpv_len = arg;			\
	    PL_bytecode_pv.xpv_cur = arg - 1;		\
	} else {				\
	    PL_bytecode_pv.xpv_pv = 0;			\
	    PL_bytecode_pv.xpv_len = 0;			\
	    PL_bytecode_pv.xpv_cur = 0;			\
	}					\
    } STMT_END
#endif /* INDIRECT_BGET_MACROS */

#define BGET_comment_t(arg) \
	do { arg = BGET_FGETC(); } while (arg != '\n' && arg != EOF)

/*
 * In the following, sizeof(IV)*4 is just a way of encoding 32 on 64-bit-IV
 * machines such that 32-bit machine compilers don't whine about the shift
 * count being too high even though the code is never reached there.
 */
#define BGET_IV64(arg) STMT_START {			\
	U32 hi, lo;					\
	BGET_U32(hi);					\
	BGET_U32(lo);					\
	if (sizeof(IV) == 8)				\
	    arg = ((IV)hi << (sizeof(IV)*4) | lo);	\
	else if (((I32)hi == -1 && (I32)lo < 0)		\
		 || ((I32)hi == 0 && (I32)lo >= 0)) {	\
	    arg = (I32)lo;				\
	}						\
	else {						\
	    PL_bytecode_iv_overflows++;				\
	    arg = 0;					\
	}						\
    } STMT_END

#define BGET_op_tr_array(arg) do {	\
	unsigned short *ary;		\
	int i;				\
	New(666, ary, 256, unsigned short); \
	BGET_FREAD(ary, 256, 2);	\
	for (i = 0; i < 256; i++)	\
	    ary[i] = PerlSock_ntohs(ary[i]);	\
	arg = (char *) ary;		\
    } while (0)

#define BGET_pvcontents(arg)	arg = PL_bytecode_pv.xpv_pv
#define BGET_strconst(arg) STMT_START {	\
	for (arg = PL_tokenbuf; (*arg = BGET_FGETC()); arg++) /* nothing */; \
	arg = PL_tokenbuf;			\
    } STMT_END

#define BGET_double(arg) STMT_START {	\
	char *str;			\
	BGET_strconst(str);		\
	arg = atof(str);		\
    } STMT_END

#define BGET_objindex(arg, type) STMT_START {	\
	U32 ix;					\
	BGET_U32(ix);				\
	arg = (type)PL_bytecode_obj_list[ix];		\
    } STMT_END
#define BGET_svindex(arg) BGET_objindex(arg, svindex)
#define BGET_opindex(arg) BGET_objindex(arg, opindex)

#define BSET_ldspecsv(sv, arg) sv = PL_specialsv_list[arg]
				    
#define BSET_sv_refcnt_add(svrefcnt, arg)	svrefcnt += arg
#define BSET_gp_refcnt_add(gprefcnt, arg)	gprefcnt += arg
#define BSET_gp_share(sv, arg) STMT_START {	\
	gp_free((GV*)sv);			\
	GvGP(sv) = GvGP(arg);			\
    } STMT_END

#define BSET_gv_fetchpv(sv, arg)	sv = (SV*)gv_fetchpv(arg, TRUE, SVt_PV)
#define BSET_gv_stashpv(sv, arg)	sv = (SV*)gv_stashpv(arg, TRUE)
#define BSET_sv_magic(sv, arg)		sv_magic(sv, Nullsv, arg, 0, 0)
#define BSET_mg_pv(mg, arg)	mg->mg_ptr = arg; mg->mg_len = PL_bytecode_pv.xpv_cur
#define BSET_sv_upgrade(sv, arg)	(void)SvUPGRADE(sv, arg)
#define BSET_xpv(sv)	do {	\
	SvPV_set(sv, PL_bytecode_pv.xpv_pv);	\
	SvCUR_set(sv, PL_bytecode_pv.xpv_cur);	\
	SvLEN_set(sv, PL_bytecode_pv.xpv_len);	\
    } while (0)
#define BSET_av_extend(sv, arg)	av_extend((AV*)sv, arg)

#define BSET_av_push(sv, arg)	av_push((AV*)sv, arg)
#define BSET_hv_store(sv, arg)	\
	hv_store((HV*)sv, PL_bytecode_pv.xpv_pv, PL_bytecode_pv.xpv_cur, arg, 0)
#define BSET_pv_free(pv)	Safefree(pv.xpv_pv)
#define BSET_pregcomp(o, arg) \
	((PMOP*)o)->op_pmregexp = arg ? \
		CALLREGCOMP(arg, arg + PL_bytecode_pv.xpv_cur, ((PMOP*)o)) : 0
#define BSET_newsv(sv, arg)	sv = NEWSV(666,0); SvUPGRADE(sv, arg)
#define BSET_newop(o, arg)	o = (OP*)safemalloc(optype_size[arg])
#define BSET_newopn(o, arg) STMT_START {	\
	OP *oldop = o;				\
	BSET_newop(o, arg);			\
	oldop->op_next = o;			\
    } STMT_END

#define BSET_ret(foo) return

/*
 * Kludge special-case workaround for OP_MAPSTART
 * which needs the ppaddr for OP_GREPSTART. Blech.
 */
#define BSET_op_type(o, arg) STMT_START {	\
	o->op_type = arg;			\
	if (arg == OP_MAPSTART)			\
	    arg = OP_GREPSTART;			\
	o->op_ppaddr = ppaddr[arg];		\
    } STMT_END
#define BSET_op_ppaddr(o, arg) croak("op_ppaddr not yet implemented")
#define BSET_curpad(pad, arg) pad = AvARRAY(arg)

#define BSET_OBJ_STORE(obj, ix)		\
	(I32)ix > PL_bytecode_obj_list_fill ?	\
	bset_obj_store(obj, (I32)ix) : (PL_bytecode_obj_list[ix] = obj)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\dirent.h ===
// dirent.h

// djl
// Provide UNIX compatibility

#ifndef  _INC_DIRENT
#define  _INC_DIRENT

//
// NT versions of readdir(), etc
// From the MSDOS implementation
//

// Directory entry size 
#ifdef DIRSIZ
#undef DIRSIZ
#endif
#define DIRSIZ(rp)  (sizeof(struct direct))

// needed to compile directory stuff
#define DIRENT direct

// structure of a directory entry
typedef struct direct 
{
	long	d_ino;			// inode number (not used by MS-DOS) 
	int	d_namlen;		// Name length 
	char	d_name[257];		// file name 
} _DIRECT;

// structure for dir operations 
typedef struct _dir_struc
{
	char	*start;			// Starting position
	char	*curr;			// Current position
	long	size;			// Size of string table
	long	nfiles;			// number if filenames in table
	struct direct dirstr;		// Directory structure to return
} DIR;

DIR *		win32_opendir(char *filename);
struct direct *	win32_readdir(DIR *dirp);
long		win32_telldir(DIR *dirp);
void		win32_seekdir(DIR *dirp,long loc);
void		win32_rewinddir(DIR *dirp);
int		win32_closedir(DIR *dirp);


#endif //_INC_DIRENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\cc_runtime.h ===
#define DOOP(ppname) PUTBACK; PL_op = ppname(ARGS); SPAGAIN

#define PP_LIST(g) do {			\
	dMARK;				\
	if (g != G_ARRAY) {		\
	    if (++MARK <= SP)		\
		*MARK = *SP;		\
	    else			\
		*MARK = &PL_sv_undef;	\
	    SP = MARK;			\
	}				\
   } while (0)

#define MAYBE_TAINT_SASSIGN_SRC(sv) \
    if (PL_tainting && PL_tainted && (!SvGMAGICAL(left) || !SvSMAGICAL(left) || \
                                !((mg=mg_find(left, 't')) && mg->mg_len & 1)))\
        TAINT_NOT

#define PP_PREINC(sv) do {	\
	if (SvIOK(sv)) {	\
            ++SvIVX(sv);	\
	    SvFLAGS(sv) &= ~(SVf_NOK|SVf_POK|SVp_NOK|SVp_POK); \
	}			\
	else			\
	    sv_inc(sv);		\
	SvSETMAGIC(sv);		\
    } while (0)

#define PP_UNSTACK do {		\
	TAINT_NOT;		\
	PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;	\
	FREETMPS;		\
	oldsave = PL_scopestack[PL_scopestack_ix - 1]; \
	LEAVE_SCOPE(oldsave);	\
	SPAGAIN;		\
    } while(0)

/* Anyone using eval "" deserves this mess */
#define PP_EVAL(ppaddr, nxt) do {		\
	dJMPENV;				\
	int ret;				\
	PUTBACK;				\
	JMPENV_PUSH(ret);			\
	switch (ret) {				\
	case 0:					\
	    PL_op = ppaddr(ARGS);			\
	    PL_retstack[PL_retstack_ix - 1] = Nullop;	\
	    if (PL_op != nxt) CALLRUNOPS();		\
	    JMPENV_POP;				\
	    break;				\
	case 1: JMPENV_POP; JMPENV_JUMP(1);	\
	case 2: JMPENV_POP; JMPENV_JUMP(2);	\
	case 3:					\
	    JMPENV_POP;				\
	    if (PL_restartop != nxt)		\
		JMPENV_JUMP(3);			\
	}					\
	PL_op = nxt;				\
	SPAGAIN;				\
    } while (0)

#define PP_ENTERTRY(jmpbuf,label) do {		\
	dJMPENV;				\
	int ret;				\
	JMPENV_PUSH(ret);			\
	switch (ret) {				\
	case 1: JMPENV_POP; JMPENV_JUMP(1);	\
	case 2: JMPENV_POP; JMPENV_JUMP(2);	\
	case 3: JMPENV_POP; SPAGAIN; goto label;\
	}					\
    } while (0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\cv.h ===
/*    cv.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* This structure much match the beginning of XPVFM */

struct xpvcv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xp_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xof_off;	/* integer value */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* magic for scalar array */
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    OP *	xcv_start;
    OP *	xcv_root;
    void      (*xcv_xsub) _((CV* _CPERLproto));
    ANY		xcv_xsubany;
    GV *	xcv_gv;
    GV *	xcv_filegv;
    long	xcv_depth;		/* >= 2 indicates recursive call */
    AV *	xcv_padlist;
    CV *	xcv_outside;
#ifdef USE_THREADS
    perl_mutex *xcv_mutexp;
    struct perl_thread *xcv_owner;	/* current owner thread */
#endif /* USE_THREADS */
    cv_flags_t	xcv_flags;
};

#define Nullcv Null(CV*)

#define CvSTASH(sv)	((XPVCV*)SvANY(sv))->xcv_stash
#define CvSTART(sv)	((XPVCV*)SvANY(sv))->xcv_start
#define CvROOT(sv)	((XPVCV*)SvANY(sv))->xcv_root
#define CvXSUB(sv)	((XPVCV*)SvANY(sv))->xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)SvANY(sv))->xcv_xsubany
#define CvGV(sv)	((XPVCV*)SvANY(sv))->xcv_gv
#define CvFILEGV(sv)	((XPVCV*)SvANY(sv))->xcv_filegv
#define CvDEPTH(sv)	((XPVCV*)SvANY(sv))->xcv_depth
#define CvPADLIST(sv)	((XPVCV*)SvANY(sv))->xcv_padlist
#define CvOUTSIDE(sv)	((XPVCV*)SvANY(sv))->xcv_outside
#ifdef USE_THREADS
#define CvMUTEXP(sv)	((XPVCV*)SvANY(sv))->xcv_mutexp
#define CvOWNER(sv)	((XPVCV*)SvANY(sv))->xcv_owner
#endif /* USE_THREADS */
#define CvFLAGS(sv)	((XPVCV*)SvANY(sv))->xcv_flags

#define CVf_CLONE	0x0001	/* anon CV uses external lexicals */
#define CVf_CLONED	0x0002	/* a clone of one of those */
#define CVf_ANON	0x0004	/* CvGV() can't be trusted */
#define CVf_OLDSTYLE	0x0008
#define CVf_UNIQUE	0x0010	/* can't be cloned */
#define CVf_NODEBUG	0x0020	/* no DB::sub indirection for this CV
				   (esp. useful for special XSUBs) */
#define CVf_METHOD	0x0040	/* CV is explicitly marked as a method */
#define CVf_LOCKED	0x0080	/* CV locks itself or first arg on entry */

#define CvCLONE(cv)		(CvFLAGS(cv) & CVf_CLONE)
#define CvCLONE_on(cv)		(CvFLAGS(cv) |= CVf_CLONE)
#define CvCLONE_off(cv)		(CvFLAGS(cv) &= ~CVf_CLONE)

#define CvCLONED(cv)		(CvFLAGS(cv) & CVf_CLONED)
#define CvCLONED_on(cv)		(CvFLAGS(cv) |= CVf_CLONED)
#define CvCLONED_off(cv)	(CvFLAGS(cv) &= ~CVf_CLONED)

#define CvANON(cv)		(CvFLAGS(cv) & CVf_ANON)
#define CvANON_on(cv)		(CvFLAGS(cv) |= CVf_ANON)
#define CvANON_off(cv)		(CvFLAGS(cv) &= ~CVf_ANON)

#define CvOLDSTYLE(cv)		(CvFLAGS(cv) & CVf_OLDSTYLE)
#define CvOLDSTYLE_on(cv)	(CvFLAGS(cv) |= CVf_OLDSTYLE)
#define CvOLDSTYLE_off(cv)	(CvFLAGS(cv) &= ~CVf_OLDSTYLE)

#define CvUNIQUE(cv)		(CvFLAGS(cv) & CVf_UNIQUE)
#define CvUNIQUE_on(cv)		(CvFLAGS(cv) |= CVf_UNIQUE)
#define CvUNIQUE_off(cv)	(CvFLAGS(cv) &= ~CVf_UNIQUE)

#define CvNODEBUG(cv)		(CvFLAGS(cv) & CVf_NODEBUG)
#define CvNODEBUG_on(cv)	(CvFLAGS(cv) |= CVf_NODEBUG)
#define CvNODEBUG_off(cv)	(CvFLAGS(cv) &= ~CVf_NODEBUG)

#define CvMETHOD(cv)		(CvFLAGS(cv) & CVf_METHOD)
#define CvMETHOD_on(cv)		(CvFLAGS(cv) |= CVf_METHOD)
#define CvMETHOD_off(cv)	(CvFLAGS(cv) &= ~CVf_METHOD)

#define CvLOCKED(cv)		(CvFLAGS(cv) & CVf_LOCKED)
#define CvLOCKED_on(cv)		(CvFLAGS(cv) |= CVf_LOCKED)
#define CvLOCKED_off(cv)	(CvFLAGS(cv) &= ~CVf_LOCKED)

#define CvEVAL(cv)		(CvUNIQUE(cv) && !SvFAKE(cv))
#define CvEVAL_on(cv)		(CvUNIQUE_on(cv),SvFAKE_off(cv))
#define CvEVAL_off(cv)		CvUNIQUE_off(cv)

/* BEGIN|INIT|END */
#define CvSPECIAL(cv)		(CvUNIQUE(cv) && SvFAKE(cv))
#define CvSPECIAL_on(cv)	(CvUNIQUE_on(cv),SvFAKE_on(cv))
#define CvSPECIAL_off(cv)	(CvUNIQUE_off(cv),SvFAKE_off(cv))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\dosish.h ===
#define ABORT() abort();

#ifndef SH_PATH
#define SH_PATH "/bin/sh"
#endif

#ifdef DJGPP
#  define BIT_BUCKET "nul"
#  define OP_BINARY O_BINARY
#  define PERL_SYS_INIT(c,v) Perl_DJGPP_init(c,v)
#  include <signal.h>
#  define HAS_UTIME
#  define HAS_KILL
   char *djgpp_pathexp (const char*);
#  if (DJGPP==2 && DJGPP_MINOR < 2)
#    define NO_LOCALECONV_MON_THOUSANDS_SEP
#  endif
#  ifdef USE_THREADS
#    define NEED_PTHREAD_INIT
#    define OLD_PTHREADS_API
#    define YIELD pthread_yield(NULL)
#    define DETACH(t)				\
       STMT_START {				\
         if (pthread_detach(&(t)->self)) {	\
             MUTEX_UNLOCK(&(t)->mutex);		\
             croak("panic: DETACH");		\
         }					\
       } STMT_END
#    define pthread_mutexattr_default NULL
#    define pthread_condattr_default NULL
#    define pthread_addr_t any_t
#    define PTHREAD_CREATE_JOINABLE (&err)
#  endif
#else	/* DJGPP */
#  ifdef WIN32
#    define PERL_SYS_INIT(c,v)	Perl_win32_init(c,v)
#    define BIT_BUCKET "nul"
#  else
#    define PERL_SYS_INIT(c,v)
#    define BIT_BUCKET "\\dev\\nul" /* "wanna be like, umm, Newlined, or somethin?" */
#  endif
#endif	/* DJGPP */

#define PERL_SYS_TERM() MALLOC_TERM
#define dXSUB_SYS
#define TMPPATH "plXXXXXX"

/*
 * 5.003_07 and earlier keyed on #ifdef MSDOS for determining if we were 
 * running on DOS, *and* if we had to cope with 16 bit memory addressing 
 * constraints, *and* we need to have memory allocated as unsigned long.
 *
 * with the advent of *real* compilers for DOS, they are not locked together.
 * MSDOS means "I am running on MSDOS". HAS_64K_LIMIT means "I have 
 * 16 bit memory addressing constraints".
 *
 * if you need the last, try #DEFINE MEM_SIZE unsigned long.
 */
#ifdef MSDOS
 #ifndef DJGPP
  #define HAS_64K_LIMIT
 #endif
#endif

/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
#define Stat_t struct stat

/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/**/

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if if finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
/* #define ALTERNATE_SHEBANG "#!" / **/

/*
 * fwrite1() should be a routine with the same calling sequence as fwrite(),
 * but which outputs all of the bytes requested as a single stream (unlike
 * fwrite() itself, which on some systems outputs several distinct records
 * if the number_of_items parameter is >1).
 */
#define fwrite1 fwrite

#define Fstat(fd,bufptr)   fstat((fd),(bufptr))
#define Fflush(fp)         fflush(fp)
#define Mkdir(path,mode)   mkdir((path),(mode))

#ifndef WIN32
#  define Stat(fname,bufptr) stat((fname),(bufptr))
#else
#  define HAS_IOCTL
#  define HAS_UTIME
#  define HAS_KILL
#  define HAS_WAIT
#  define HAS_CHOWN
/*
 * This provides a layer of functions and macros to ensure extensions will
 * get to use the same RTL functions as the core.
 */
#  ifndef HASATTRIBUTE
#    ifndef PERL_OBJECT
#      include <win32iop.h>
#    endif
#  endif
#endif	/* WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\config.h ===
/*
 * This file was produced by running the config_h.SH script, which
 * gets its values from config.sh, which is generally produced by
 * running Configure.
 *
 * Feel free to modify any of this as the need arises.  Note, however,
 * that running config_h.SH again will wipe out any changes you've made.
 * For a more permanent change edit config.sh and rerun config_h.SH.
 *
 * $Id: Config_h.U,v 3.0.1.5 1997/02/28 14:57:43 ram Exp $
 */

/*
 * Package name      : perl5
 * Source directory  : 
 * Configuration time: undef
 * Configured by     : mikesm
 * Target system     : 
 */

#ifndef _config_h_
#define _config_h_

/* LOC_SED:
 *	This symbol holds the complete pathname to the sed program.
 */
#define LOC_SED 	""	/**/

/* BIN:
 *	This symbol holds the path of the bin directory where the package will
 *	be installed. Program must be prepared to deal with ~name substitution.
 */
/* BIN_EXP:
 *	This symbol is the filename expanded version of the BIN symbol, for
 *	programs that do not want to deal with that at run-time.
 */
#define BIN "P:\\Apps\\ActivePerl\\temp\\bin\\MSWin32-x86-object"	/**/
#define BIN_EXP "P:\\Apps\\ActivePerl\\temp\\bin\\MSWin32-x86-object"	/**/

/* CPPSTDIN:
 *	This symbol contains the first part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.	 Typical value of "cc -E" or "/lib/cpp", but it can also
 *	call a wrapper. See CPPRUN.
 */
/* CPPMINUS:
 *	This symbol contains the second part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
 *	to specify standard input, otherwise the value is "".
 */
#define CPPSTDIN "cl -nologo -E"
#define CPPMINUS ""

/* HAS_ALARM:
 *	This symbol, if defined, indicates that the alarm routine is
 *	available.
 */
/*#define HAS_ALARM		/**/

/* HASATTRIBUTE:
 *	This symbol indicates the C compiler can check for function attributes,
 *	such as printf formats. This is normally only supported by GNU cc.
 */
/*#define HASATTRIBUTE 	/**/
#ifndef HASATTRIBUTE
#define __attribute__(_arg_)
#endif

/* HAS_BCMP:
 *	This symbol is defined if the bcmp() routine is available to
 *	compare blocks of memory.
 */
/*#define HAS_BCMP	/**/

/* HAS_BCOPY:
 *	This symbol is defined if the bcopy() routine is available to
 *	copy blocks of memory.
 */
/*#define HAS_BCOPY	/**/

/* HAS_BZERO:
 *	This symbol is defined if the bzero() routine is available to
 *	set a memory block to 0.
 */
/*#define HAS_BZERO	/**/

/* HAS_CHOWN:
 *	This symbol, if defined, indicates that the chown routine is
 *	available.
 */
/*#define HAS_CHOWN		/**/

/* HAS_CHROOT:
 *	This symbol, if defined, indicates that the chroot routine is
 *	available.
 */
/*#define HAS_CHROOT		/**/

/* HAS_CHSIZE:
 *	This symbol, if defined, indicates that the chsize routine is available
 *	to truncate files.  You might need a -lx to get this routine.
 */
#define	HAS_CHSIZE		/**/

/* HASCONST:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the const type. There is no need to actually test for that symbol
 *	within your programs. The mere use of the "const" keyword will
 *	trigger the necessary tests.
 */
#define HASCONST	/**/
#ifndef HASCONST
#define const
#endif

/* HAS_CRYPT:
 *	This symbol, if defined, indicates that the crypt routine is available
 *	to encrypt passwords and the like.
 */
#define HAS_CRYPT		/**/

/* HAS_CUSERID:
 *	This symbol, if defined, indicates that the cuserid routine is
 *	available to get character login names.
 */
/*#define HAS_CUSERID		/**/

/* HAS_DBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol DBL_DIG, which is the number
 *	of significant digits in a double precision number.  If this
 *	symbol is not defined, a guess of 15 is usually pretty good.
 */
#define HAS_DBL_DIG 	/**/

/* HAS_DIFFTIME:
 *	This symbol, if defined, indicates that the difftime routine is
 *	available.
 */
#define HAS_DIFFTIME		/**/

/* HAS_DLERROR:
 *	This symbol, if defined, indicates that the dlerror routine is
 *	available to return a string describing the last error that
 *	occurred from a call to dlopen(), dlclose() or dlsym().
 */
#define HAS_DLERROR	/**/

/* SETUID_SCRIPTS_ARE_SECURE_NOW:
 *	This symbol, if defined, indicates that the bug that prevents
 *	setuid scripts from being secure is not present in this kernel.
 */
/* DOSUID:
 *	This symbol, if defined, indicates that the C program should
 *	check the script that it is executing for setuid/setgid bits, and
 *	attempt to emulate setuid/setgid on systems that have disabled
 *	setuid #! scripts because the kernel can't do it securely.
 *	It is up to the package designer to make sure that this emulation
 *	is done securely.  Among other things, it should do an fstat on
 *	the script it just opened to make sure it really is a setuid/setgid
 *	script, it should make sure the arguments passed correspond exactly
 *	to the argument on the #! line, and it should not trust any
 *	subprocesses to which it must pass the filename rather than the
 *	file descriptor of the script to be executed.
 */
/*#define SETUID_SCRIPTS_ARE_SECURE_NOW	/**/
/*#define DOSUID		/**/

/* HAS_DUP2:
 *	This symbol, if defined, indicates that the dup2 routine is
 *	available to duplicate file descriptors.
 */
#define HAS_DUP2	/**/

/* HAS_FCHMOD:
 *	This symbol, if defined, indicates that the fchmod routine is available
 *	to change mode of opened files.  If unavailable, use chmod().
 */
/*#define HAS_FCHMOD		/**/

/* HAS_FCHOWN:
 *	This symbol, if defined, indicates that the fchown routine is available
 *	to change ownership of opened files.  If unavailable, use chown().
 */
/*#define HAS_FCHOWN		/**/

/* HAS_FCNTL:
 *	This symbol, if defined, indicates to the C program that
 *	the fcntl() function exists.
 */
/*#define HAS_FCNTL		/**/

/* HAS_FGETPOS:
 *	This symbol, if defined, indicates that the fgetpos routine is
 *	available to get the file position indicator, similar to ftell().
 */
#define HAS_FGETPOS	/**/

/* FLEXFILENAMES:
 *	This symbol, if defined, indicates that the system supports filenames
 *	longer than 14 characters.
 */
#define	FLEXFILENAMES		/**/

/* HAS_FLOCK:
 *	This symbol, if defined, indicates that the flock routine is
 *	available to do file locking.
 */
#define HAS_FLOCK		/**/

/* HAS_FORK:
 *	This symbol, if defined, indicates that the fork routine is
 *	available.
 */
/*#define HAS_FORK		/**/

/* HAS_FSETPOS:
 *	This symbol, if defined, indicates that the fsetpos routine is
 *	available to set the file position indicator, similar to fseek().
 */
#define HAS_FSETPOS	/**/

/* I_SYS_MOUNT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/mount.h>.
 */
/*#define I_SYS_MOUNT		/**/

/* HAS_FSTATFS:
 *	This symbol, if defined, indicates that the fstatfs routine is
 *	available to stat the filesystem of a file descriptor.
 */
/*#define HAS_FSTATFS	/**/

/* HAS_STRUCT_STATFS_FLAGS:
 *	This symbol, if defined, indicates that the struct statfs has
 *	the f_flags member for mount flags.
 */
/*#define HAS_STRUCT_STATFS_FLAGS	/**/

/* I_SYS_STATVFS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/statvfs.h>.
 */
/*#define I_SYS_STATVFS		/**/

/* HAS_FSTATVFS:
 *	This symbol, if defined, indicates that the fstatvfs routine is
 *	available to stat the filesystem of a file descriptor.
 */
/*#define HAS_FSTATVFS	/**/

/* I_MNTENT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <mntent.h>.
 */
/*#define I_MNTENT		/**/

/* HAS_GETMNTENT:
 *	This symbol, if defined, indicates that the getmntent routine is
 *	available to lookup mount entries in some data base or other.
 */
/*#define HAS_GETMNTENT	/**/

/* HAS_HASMNTOPT:
 *	This symbol, if defined, indicates that the hasmntopt routine is
 *	available to query mount entries returned by getmntent.
 */
/*#define HAS_HASMNTOPT	/**/

/* HAS_GETTIMEOFDAY:
 *	This symbol, if defined, indicates that the gettimeofday() system
 *	call is available for a sub-second accuracy clock. Usually, the file
 *	<sys/resource.h> needs to be included (see I_SYS_RESOURCE).
 *	The type "Timeval" should be used to refer to "struct timeval".
 */
/*#define HAS_GETTIMEOFDAY	/**/
#ifdef HAS_GETTIMEOFDAY
#define Timeval struct timeval	/* Structure used by gettimeofday() */
#endif

/* HAS_GETGROUPS:
 *	This symbol, if defined, indicates that the getgroups() routine is
 *	available to get the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_GETGROUPS		/**/

/* HAS_UNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	uname() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and PHOSTNAME.
 */
#define HAS_UNAME		/**/

/* HAS_GETLOGIN:
 *	This symbol, if defined, indicates that the getlogin routine is
 *	available to get the login name.
 */
#define HAS_GETLOGIN		/**/

/* HAS_GETPGID:
 *	This symbol, if defined, indicates to the C program that 
 *	the getpgid(pid) function is available to get the
 *	process group id.
 */
/*#define HAS_GETPGID		/**/

/* HAS_GETPGRP:
 *	This symbol, if defined, indicates that the getpgrp routine is
 *	available to get the current process group.
 */
/* USE_BSD_GETPGRP:
 *	This symbol, if defined, indicates that getpgrp needs one
 *	arguments whereas USG one needs none.
 */
/*#define HAS_GETPGRP		/**/
/*#define USE_BSD_GETPGRP	/**/

/* HAS_GETPGRP2:
 *	This symbol, if defined, indicates that the getpgrp2() (as in DG/UX)
 *	routine is available to get the current process group.
 */
/*#define HAS_GETPGRP2		/**/

/* HAS_GETPPID:
 *	This symbol, if defined, indicates that the getppid routine is
 *	available to get the parent process ID.
 */
/*#define HAS_GETPPID		/**/

/* HAS_GETPRIORITY:
 *	This symbol, if defined, indicates that the getpriority routine is
 *	available to get a process's priority.
 */
/*#define HAS_GETPRIORITY		/**/

/* HAS_HTONL:
 *	This symbol, if defined, indicates that the htonl() routine (and
 *	friends htons() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_HTONS:
 *	This symbol, if defined, indicates that the htons() routine (and
 *	friends htonl() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHL:
 *	This symbol, if defined, indicates that the ntohl() routine (and
 *	friends htonl() htons() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHS:
 *	This symbol, if defined, indicates that the ntohs() routine (and
 *	friends htonl() htons() ntohl()) are available to do network
 *	order byte swapping.
 */
#define HAS_HTONL		/**/
#define HAS_HTONS		/**/
#define HAS_NTOHL		/**/
#define HAS_NTOHS		/**/

/* HAS_INET_ATON:
 *	This symbol, if defined, indicates to the C program that the
 *	inet_aton() function is available to parse IP address "dotted-quad"
 *	strings.
 */
/*#define HAS_INET_ATON		/**/

/* HAS_KILLPG:
 *	This symbol, if defined, indicates that the killpg routine is available
 *	to kill process groups.  If unavailable, you probably should use kill
 *	with a negative process number.
 */
/*#define HAS_KILLPG	/**/

/* HAS_LINK:
 *	This symbol, if defined, indicates that the link routine is
 *	available to create hard links.
 */
/*#define HAS_LINK	/**/

/* HAS_LOCALECONV:
 *	This symbol, if defined, indicates that the localeconv routine is
 *	available for numeric and monetary formatting conventions.
 */
#define HAS_LOCALECONV	/**/

/* HAS_LOCKF:
 *	This symbol, if defined, indicates that the lockf routine is
 *	available to do file locking.
 */
/*#define HAS_LOCKF		/**/

/* HAS_LSTAT:
 *	This symbol, if defined, indicates that the lstat routine is
 *	available to do file stats on symbolic links.
 */
/*#define HAS_LSTAT		/**/

/* HAS_MBLEN:
 *	This symbol, if defined, indicates that the mblen routine is available
 *	to find the number of bytes in a multibye character.
 */
#define HAS_MBLEN		/**/

/* HAS_MBSTOWCS:
 *	This symbol, if defined, indicates that the mbstowcs routine is
 *	available to covert a multibyte string into a wide character string.
 */
#define	HAS_MBSTOWCS		/**/

/* HAS_MBTOWC:
 *	This symbol, if defined, indicates that the mbtowc routine is available
 *	to covert a multibyte to a wide character.
 */
#define HAS_MBTOWC		/**/

/* HAS_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	to compare blocks of memory.
 */
#define HAS_MEMCMP	/**/

/* HAS_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy blocks of memory.
 */
#define HAS_MEMCPY	/**/

/* HAS_MEMMOVE:
 *	This symbol, if defined, indicates that the memmove routine is available
 *	to copy potentially overlapping blocks of memory. This should be used
 *	only when HAS_SAFE_BCOPY is not defined. If neither is there, roll your
 *	own version.
 */
#define HAS_MEMMOVE	/**/

/* HAS_MEMSET:
 *	This symbol, if defined, indicates that the memset routine is available
 *	to set blocks of memory.
 */
#define HAS_MEMSET	/**/

/* HAS_MKDIR:
 *	This symbol, if defined, indicates that the mkdir routine is available
 *	to create directories.  Otherwise you should fork off a new process to
 *	exec /bin/mkdir.
 */
#define HAS_MKDIR		/**/

/* HAS_MKFIFO:
 *	This symbol, if defined, indicates that the mkfifo routine is
 *	available to create FIFOs. Otherwise, mknod should be able to
 *	do it for you. However, if mkfifo is there, mknod might require
 *	super-user privileges which mkfifo will not.
 */
/*#define HAS_MKFIFO		/**/

/* HAS_MKTIME:
 *	This symbol, if defined, indicates that the mktime routine is
 *	available.
 */
#define HAS_MKTIME		/**/

/* HAS_MSG:
 *	This symbol, if defined, indicates that the entire msg*(2) library is
 *	supported (IPC mechanism based on message queues).
 */
/*#define HAS_MSG		/**/

/* HAS_NICE:
 *	This symbol, if defined, indicates that the nice routine is
 *	available.
 */
/*#define HAS_NICE		/**/

/* HAS_PATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given filename.
 */
/* HAS_FPATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given open file descriptor.
 */
/*#define HAS_PATHCONF		/**/
/*#define HAS_FPATHCONF		/**/

/* HAS_PAUSE:
 *	This symbol, if defined, indicates that the pause routine is
 *	available to suspend a process until a signal is received.
 */
#define HAS_PAUSE		/**/

/* HAS_PIPE:
 *	This symbol, if defined, indicates that the pipe routine is
 *	available to create an inter-process channel.
 */
#define HAS_PIPE		/**/

/* HAS_POLL:
 *	This symbol, if defined, indicates that the poll routine is
 *	available to poll active file descriptors. You may safely
 *	include <poll.h> when this symbol is defined.
 */
/*#define HAS_POLL		/**/

/* HAS_READDIR:
 *	This symbol, if defined, indicates that the readdir routine is
 *	available to read directory entries. You may have to include
 *	<dirent.h>. See I_DIRENT.
 */
#define HAS_READDIR		/**/

/* HAS_SEEKDIR:
 *	This symbol, if defined, indicates that the seekdir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_SEEKDIR		/**/

/* HAS_TELLDIR:
 *	This symbol, if defined, indicates that the telldir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_TELLDIR		/**/

/* HAS_REWINDDIR:
 *	This symbol, if defined, indicates that the rewinddir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_REWINDDIR		/**/

/* HAS_READLINK:
 *	This symbol, if defined, indicates that the readlink routine is
 *	available to read the value of a symbolic link.
 */
/*#define HAS_READLINK		/**/

/* HAS_RENAME:
 *	This symbol, if defined, indicates that the rename routine is available
 *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
 *	trick.
 */
#define HAS_RENAME	/**/

/* HAS_RMDIR:
 *	This symbol, if defined, indicates that the rmdir routine is
 *	available to remove directories. Otherwise you should fork off a
 *	new process to exec /bin/rmdir.
 */
#define HAS_RMDIR		/**/

/* HAS_SELECT:
 *	This symbol, if defined, indicates that the select routine is
 *	available to select active file descriptors. If the timeout field
 *	is used, <sys/time.h> may need to be included.
 */
#define HAS_SELECT	/**/

/* HAS_SEM:
 *	This symbol, if defined, indicates that the entire sem*(2) library is
 *	supported.
 */
/*#define HAS_SEM		/**/

/* HAS_SETEGID:
 *	This symbol, if defined, indicates that the setegid routine is available
 *	to change the effective gid of the current program.
 */
/*#define HAS_SETEGID		/**/

/* HAS_SETEUID:
 *	This symbol, if defined, indicates that the seteuid routine is available
 *	to change the effective uid of the current program.
 */
/*#define HAS_SETEUID		/**/

/* HAS_SETLINEBUF:
 *	This symbol, if defined, indicates that the setlinebuf routine is
 *	available to change stderr or stdout from block-buffered or unbuffered
 *	to a line-buffered mode.
 */
/*#define HAS_SETLINEBUF		/**/

/* HAS_SETLOCALE:
 *	This symbol, if defined, indicates that the setlocale routine is
 *	available to handle locale-specific ctype implementations.
 */
#define HAS_SETLOCALE	/**/

/* HAS_SETPGID:
 *	This symbol, if defined, indicates that the setpgid(pid, gpid)
 *	routine is available to set process group ID.
 */
/*#define HAS_SETPGID	/**/

/* HAS_SETPGRP:
 *	This symbol, if defined, indicates that the setpgrp routine is
 *	available to set the current process group.
 */
/* USE_BSD_SETPGRP:
 *	This symbol, if defined, indicates that setpgrp needs two
 *	arguments whereas USG one needs none.  See also HAS_SETPGID
 *	for a POSIX interface.
 */
/*#define HAS_SETPGRP		/**/
/*#define USE_BSD_SETPGRP	/**/

/* HAS_SETPGRP2:
 *	This symbol, if defined, indicates that the setpgrp2() (as in DG/UX)
 *	routine is available to set the current process group.
 */
/*#define HAS_SETPGRP2		/**/

/* HAS_SETPRIORITY:
 *	This symbol, if defined, indicates that the setpriority routine is
 *	available to set a process's priority.
 */
/*#define HAS_SETPRIORITY		/**/

/* HAS_SETREGID:
 *	This symbol, if defined, indicates that the setregid routine is
 *	available to change the real and effective gid of the current
 *	process.
 */
/* HAS_SETRESGID:
 *	This symbol, if defined, indicates that the setresgid routine is
 *	available to change the real, effective and saved gid of the current
 *	process.
 */
/*#define HAS_SETREGID		/**/
/*#define HAS_SETRESGID		/**/

/* HAS_SETREUID:
 *	This symbol, if defined, indicates that the setreuid routine is
 *	available to change the real and effective uid of the current
 *	process.
 */
/* HAS_SETRESUID:
 *	This symbol, if defined, indicates that the setresuid routine is
 *	available to change the real, effective and saved uid of the current
 *	process.
 */
/*#define HAS_SETREUID		/**/
/*#define HAS_SETRESUID		/**/

/* HAS_SETRGID:
 *	This symbol, if defined, indicates that the setrgid routine is available
 *	to change the real gid of the current program.
 */
/*#define HAS_SETRGID		/**/

/* HAS_SETRUID:
 *	This symbol, if defined, indicates that the setruid routine is available
 *	to change the real uid of the current program.
 */
/*#define HAS_SETRUID		/**/

/* HAS_SETSID:
 *	This symbol, if defined, indicates that the setsid routine is
 *	available to set the process group ID.
 */
/*#define HAS_SETSID	/**/

/* HAS_SHM:
 *	This symbol, if defined, indicates that the entire shm*(2) library is
 *	supported.
 */
/*#define HAS_SHM		/**/

/* Shmat_t:
 *	This symbol holds the return type of the shmat() system call.
 *	Usually set to 'void *' or 'char *'.
 */
/* HAS_SHMAT_PROTOTYPE:
 *	This symbol, if defined, indicates that the sys/shm.h includes
 *	a prototype for shmat().  Otherwise, it is up to the program to
 *	guess one.  Shmat_t shmat _((int, Shmat_t, int)) is a good guess,
 *	but not always right so it should be emitted by the program only
 *	when HAS_SHMAT_PROTOTYPE is not defined to avoid conflicting defs.
 */
#define Shmat_t void *	/**/
/*#define HAS_SHMAT_PROTOTYPE	/**/

/* USE_STAT_BLOCKS:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_blksize and st_blocks.
 */
/*#define USE_STAT_BLOCKS 	/**/

/* HAS_STRCHR:
 *	This symbol is defined to indicate that the strchr()/strrchr()
 *	functions are available for string searching. If not, try the
 *	index()/rindex() pair.
 */
/* HAS_INDEX:
 *	This symbol is defined to indicate that the index()/rindex()
 *	functions are available for string searching.
 */
#define HAS_STRCHR	/**/
/*#define HAS_INDEX	/**/

/* HAS_STRCOLL:
 *	This symbol, if defined, indicates that the strcoll routine is
 *	available to compare strings using collating information.
 */
#define HAS_STRCOLL	/**/

/* USE_STRUCT_COPY:
 *	This symbol, if defined, indicates that this C compiler knows how
 *	to copy structures.  If undefined, you'll need to use a block copy
 *	routine of some sort instead.
 */
#define	USE_STRUCT_COPY	/**/

/* HAS_STRERROR:
 *	This symbol, if defined, indicates that the strerror routine is
 *	available to translate error numbers to strings. See the writeup
 *	of Strerror() in this file before you try to define your own.
 */
/* HAS_SYS_ERRLIST:
 *	This symbol, if defined, indicates that the sys_errlist array is
 *	available to translate error numbers to strings. The extern int
 *	sys_nerr gives the size of that table.
 */
/* Strerror:
 *	This preprocessor symbol is defined as a macro if strerror() is
 *	not available to translate error numbers to strings but sys_errlist[]
 *	array is there.
 */
#define HAS_STRERROR		/**/
#define HAS_SYS_ERRLIST	/**/
#define Strerror(e) strerror(e)

/* HAS_STRTOD:
 *	This symbol, if defined, indicates that the strtod routine is
 *	available to provide better numeric string conversion than atof().
 */
#define HAS_STRTOD	/**/

/* HAS_STRTOL:
 *	This symbol, if defined, indicates that the strtol routine is available
 *	to provide better numeric string conversion than atoi() and friends.
 */
#define HAS_STRTOL	/**/

/* HAS_STRTOUL:
 *	This symbol, if defined, indicates that the strtoul routine is
 *	available to provide conversion of strings to unsigned long.
 */
#define HAS_STRTOUL	/**/

/* HAS_STRXFRM:
 *	This symbol, if defined, indicates that the strxfrm() routine is
 *	available to transform strings.
 */
#define HAS_STRXFRM	/**/

/* HAS_SYMLINK:
 *	This symbol, if defined, indicates that the symlink routine is available
 *	to create symbolic links.
 */
/*#define HAS_SYMLINK	/**/

/* HAS_SYSCALL:
 *	This symbol, if defined, indicates that the syscall routine is
 *	available to call arbitrary system calls. If undefined, that's tough.
 */
/*#define HAS_SYSCALL	/**/

/* HAS_SYSCONF:
 *	This symbol, if defined, indicates that sysconf() is available
 *	to determine system related limits and options.
 */
/*#define HAS_SYSCONF	/**/

/* HAS_SYSTEM:
 *	This symbol, if defined, indicates that the system routine is
 *	available to issue a shell command.
 */
#define HAS_SYSTEM	/**/

/* HAS_TCGETPGRP:
 *	This symbol, if defined, indicates that the tcgetpgrp routine is
 *	available to get foreground process group ID.
 */
/*#define HAS_TCGETPGRP		/**/

/* HAS_TCSETPGRP:
 *	This symbol, if defined, indicates that the tcsetpgrp routine is
 *	available to set foreground process group ID.
 */
/*#define HAS_TCSETPGRP		/**/

/* HAS_TRUNCATE:
 *	This symbol, if defined, indicates that the truncate routine is
 *	available to truncate files.
 */
/*#define HAS_TRUNCATE	/**/

/* HAS_TZNAME:
 *	This symbol, if defined, indicates that the tzname[] array is
 *	available to access timezone names.
 */
#define HAS_TZNAME		/**/

/* HAS_UMASK:
 *	This symbol, if defined, indicates that the umask routine is
 *	available to set and get the value of the file creation mask.
 */
#define HAS_UMASK		/**/

/* HAS_VFORK:
 *	This symbol, if defined, indicates that vfork() exists.
 */
/*#define HAS_VFORK	/**/

/* HASVOLATILE:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the volatile declaration.
 */
#define	HASVOLATILE	/**/
#ifndef HASVOLATILE
#define volatile
#endif

/* HAS_WAIT4:
 *	This symbol, if defined, indicates that wait4() exists.
 */
/*#define HAS_WAIT4	/**/

/* HAS_WAITPID:
 *	This symbol, if defined, indicates that the waitpid routine is
 *	available to wait for child process.
 */
#define HAS_WAITPID	/**/

/* HAS_WCSTOMBS:
 *	This symbol, if defined, indicates that the wcstombs routine is
 *	available to convert wide character strings to multibyte strings.
 */
#define HAS_WCSTOMBS	/**/

/* HAS_WCTOMB:
 *	This symbol, if defined, indicates that the wctomb routine is available
 *	to covert a wide character to a multibyte.
 */
#define HAS_WCTOMB		/**/

/* EBCDIC:
 *	This symbol, if defined, indicates that this system uses
 *	EBCDIC encoding.
 */
/*#define	EBCDIC 		/**/

/* I_ARPA_INET:
 *	This symbol, if defined, indicates that <arpa/inet.h> exists and should
 *	be included.
 */
#define I_ARPA_INET	/**/

/* I_DBM:
 *	This symbol, if defined, indicates that <dbm.h> exists and should
 *	be included.
 */
/* I_RPCSVC_DBM:
 *	This symbol, if defined, indicates that <rpcsvc/dbm.h> exists and
 *	should be included.
 */
/*#define I_DBM	/**/
#define I_RPCSVC_DBM	/**/

/* I_DIRENT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <dirent.h>. Using this symbol also triggers the definition
 *	of the Direntry_t define which ends up being 'struct dirent' or
 *	'struct direct' depending on the availability of <dirent.h>.
 */
/* DIRNAMLEN:
 *	This symbol, if defined, indicates to the C program that the length
 *	of directory entry names is provided by a d_namlen field.  Otherwise
 *	you need to do strlen() on the d_name field.
 */
/* Direntry_t:
 *	This symbol is set to 'struct direct' or 'struct dirent' depending on
 *	whether dirent is available or not. You should use this pseudo type to
 *	portably declare your directory entries.
 */
#define I_DIRENT		/**/
#define DIRNAMLEN	/**/
#define Direntry_t struct direct

/* I_DLFCN:
 *	This symbol, if defined, indicates that <dlfcn.h> exists and should
 *	be included.
 */
#define I_DLFCN		/**/

/* I_FCNTL:
 *	This manifest constant tells the C program to include <fcntl.h>.
 */
#define I_FCNTL	/**/

/* I_FLOAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <float.h> to get definition of symbols like DBL_MAX or
 *	DBL_MIN, i.e. machine dependent floating point values.
 */
#define I_FLOAT		/**/

/* I_GRP:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <grp.h>.
 */
/* GRPASSWD:
 *	This symbol, if defined, indicates to the C program that struct group
 *	contains gr_passwd.
 */
/* HAS_SETGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for initializing sequential access of the group database.
 */
/* HAS_GETGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for sequential access of the group database.
 */
/* HAS_ENDGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the group database.
 */
/*#define I_GRP		/**/
/*#define GRPASSWD	/**/
/*#define HAS_SETGRENT	/**/
/*#define HAS_GETGRENT	/**/
/*#define HAS_ENDGRENT	/**/

/* I_LIMITS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <limits.h> to get definition of symbols like WORD_BIT or
 *	LONG_MAX, i.e. machine dependant limitations.
 */
#define I_LIMITS		/**/

/* I_LOCALE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <locale.h>.
 */
#define	I_LOCALE		/**/

/* I_MATH:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <math.h>.
 */
#define I_MATH		/**/

/* I_MEMORY:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <memory.h>.
 */
/*#define I_MEMORY		/**/

/* I_NDBM:
 *	This symbol, if defined, indicates that <ndbm.h> exists and should
 *	be included.
 */
/*#define I_NDBM	/**/

/* I_NET_ERRNO:
 *	This symbol, if defined, indicates that <net/errno.h> exists and 
 *	should be included.
 */
/*#define I_NET_ERRNO		/**/

/* I_NETINET_IN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <netinet/in.h>. Otherwise, you may try <sys/in.h>.
 */
/*#define I_NETINET_IN	/**/

/* I_SFIO:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sfio.h>.
 */
/*#define	I_SFIO		/**/

/* I_STDDEF:
 *	This symbol, if defined, indicates that <stddef.h> exists and should
 *	be included.
 */
#define I_STDDEF	/**/

/* I_STDLIB:
 *	This symbol, if defined, indicates that <stdlib.h> exists and should
 *	be included.
 */
#define I_STDLIB		/**/

/* I_STRING:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <string.h> (USG systems) instead of <strings.h> (BSD systems).
 */
#define I_STRING		/**/

/* I_SYS_DIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/dir.h>.
 */
/*#define I_SYS_DIR		/**/

/* I_SYS_FILE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/file.h> to get definition of R_OK and friends.
 */
/*#define I_SYS_FILE		/**/

/* I_SYS_IOCTL:
 *	This symbol, if defined, indicates that <sys/ioctl.h> exists and should
 *	be included. Otherwise, include <sgtty.h> or <termio.h>.
 */
/*#define	I_SYS_IOCTL		/**/

/* I_SYS_NDIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/ndir.h>.
 */
/*#define I_SYS_NDIR	/**/

/* I_SYS_PARAM:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/param.h>.
 */
/*#define I_SYS_PARAM		/**/

/* I_SYS_RESOURCE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/resource.h>.
 */
/*#define I_SYS_RESOURCE		/**/

/* I_SYS_SELECT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/select.h> in order to get definition of struct timeval.
 */
/*#define I_SYS_SELECT	/**/

/* I_SYS_STAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/stat.h>.
 */
#define	I_SYS_STAT		/**/

/* I_SYS_TIMES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/times.h>.
 */
/*#define	I_SYS_TIMES		/**/

/* I_SYS_TYPES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/types.h>.
 */
#define	I_SYS_TYPES		/**/

/* I_SYS_UN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/un.h> to get UNIX domain socket definitions.
 */
/*#define I_SYS_UN		/**/

/* I_SYS_WAIT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/wait.h>.
 */
/*#define I_SYS_WAIT	/**/

/* I_TERMIO:
 *	This symbol, if defined, indicates that the program should include
 *	<termio.h> rather than <sgtty.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/* I_TERMIOS:
 *	This symbol, if defined, indicates that the program should include
 *	the POSIX termios.h rather than sgtty.h or termio.h.
 *	There are also differences in the ioctl() calls that depend on the
 *	value of this symbol.
 */
/* I_SGTTY:
 *	This symbol, if defined, indicates that the program should include
 *	<sgtty.h> rather than <termio.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/*#define I_TERMIO		/**/
/*#define I_TERMIOS		/**/
/*#define I_SGTTY		/**/

/* I_UNISTD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <unistd.h>.
 */
/*#define I_UNISTD		/**/

/* I_UTIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <utime.h>.
 */
#define I_UTIME		/**/

/* I_VALUES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <values.h> to get definition of symbols like MINFLOAT or
 *	MAXLONG, i.e. machine dependant limitations.  Probably, you
 *	should use <limits.h> instead, if it is available.
 */
/*#define I_VALUES		/**/

/* I_STDARG:
 *	This symbol, if defined, indicates that <stdarg.h> exists and should
 *	be included.
 */
/* I_VARARGS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <varargs.h>.
 */
#define I_STDARG		/**/
/*#define I_VARARGS	/**/

/* I_VFORK:
 *	This symbol, if defined, indicates to the C program that it should
 *	include vfork.h.
 */
/*#define I_VFORK	/**/

/* CAN_PROTOTYPE:
 *	If defined, this macro indicates that the C compiler can handle
 *	function prototypes.
 */
/* _:
 *	This macro is used to declare function parameters for folks who want
 *	to make declarations with prototypes using a different style than
 *	the above macros.  Use double parentheses.  For example:
 *
 *		int main _((int argc, char *argv[]));
 */
#define	CAN_PROTOTYPE	/**/
#ifdef CAN_PROTOTYPE
#define	_(args) args
#else
#define	_(args) ()
#endif

/* SH_PATH:
 *	This symbol contains the full pathname to the shell used on this
 *	on this system to execute Bourne shell scripts.  Usually, this will be
 *	/bin/sh, though it's possible that some systems will have /bin/ksh,
 *	/bin/pdksh, /bin/ash, /bin/bash, or even something such as
 *	D:/bin/sh.exe.
 */
#define SH_PATH "cmd /x /c"  /**/

/* STDCHAR:
 *	This symbol is defined to be the type of char used in stdio.h.
 *	It has the values "unsigned char" or "char".
 */
#define STDCHAR char	/**/

/* MEM_ALIGNBYTES:
 *	 This symbol contains the number of bytes required to align a
 *	 double. Usual values are 2, 4 and 8.
 *	 On NeXT starting with 3.2, you can build "Fat" Multiple Architecture
 *	 Binaries (MAB) for targets with varying alignment.  This only matters
 *	 for perl, where the config.h can be generated and installed on one
 *	 system, and used by a different architecture to build an extension.
 *	 The default is eight, for safety.
 */
#define MEM_ALIGNBYTES 8	/**/

/* BYTEORDER:
 *	This symbol holds the hexadecimal constant defined in byteorder,
 *	i.e. 0x1234 or 0x4321, etc...
 *	On NeXT 3.2 (and greater), you can build "Fat" Multiple Architecture
 *	Binaries (MAB) on either big endian or little endian machines.
 *	The endian-ness is available at compile-time.  This only matters
 *	for perl, where the config.h can be generated and installed on 
 *	one system, and used by a different architecture to build an
 *	extension.  Older versions of NeXT that might not have
 *	defined either *_ENDIAN__ were all on Motorola 680x0 series,
 *	so the default case (for NeXT) is big endian to catch them. 
 *	This might matter for NeXT 3.0.
 */
#ifndef NeXT
#define BYTEORDER 0x1234	/* large digits for MSB */
#else  /* NeXT */
#ifdef __LITTLE_ENDIAN__
#define BYTEORDER 0x1234
#else /* __BIG_ENDIAN__ */
#define BYTEORDER 0x4321
#endif /* ENDIAN CHECK */
#endif /* NeXT */

/* CASTI32:
 *	This symbol is defined if the C compiler can cast negative
 *	or large floating point numbers to 32-bit ints.
 */
#define	CASTI32		/**/

/* CASTNEGFLOAT:
 *	This symbol is defined if the C compiler can cast negative
 *	numbers to unsigned longs, ints and shorts.
 */
/* CASTFLAGS:
 *	This symbol contains flags that say what difficulties the compiler
 *	has casting odd floating values to unsigned long:
 *		0 = ok
 *		1 = couldn't cast < 0
 *		2 = couldn't cast >= 0x80000000
 *		4 = couldn't cast in argument expression list
 */
#define	CASTNEGFLOAT		/**/
#define CASTFLAGS 0		/**/

/* VOID_CLOSEDIR:
 *	This symbol, if defined, indicates that the closedir() routine
 *	does not return a value.
 */
/*#define VOID_CLOSEDIR		/**/

/* Gconvert:
 *	This preprocessor macro is defined to convert a floating point
 *	number to a string without a trailing decimal point.  This
 *	emulates the behavior of sprintf("%g"), but is sometimes much more
 *	efficient.  If gconvert() is not available, but gcvt() drops the
 *	trailing decimal point, then gcvt() is used.  If all else fails,
 *	a macro using sprintf("%g") is used. Arguments for the Gconvert
 *	macro are: value, number of digits, whether trailing zeros should
 *	be retained, and the output buffer.
 *	Possible values are:
 *		d_Gconvert='gconvert((x),(n),(t),(b))'
 *		d_Gconvert='gcvt((x),(n),(b))'
 *		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
 *	The last two assume trailing zeros should not be kept.
 */
#define Gconvert(x,n,t,b) sprintf((b),"%.*g",(n),(x))

/* HAS_GNULIBC:
 *	This symbol, if defined, indicates to the C program that 
 *	the GNU C library is being used.
 */
/*#define HAS_GNULIBC  	/**/
/* HAS_ISASCII:
 *	This manifest constant lets the C program know that isascii 
 *	is available.
 */
#define HAS_ISASCII		/**/

/* HAS_LCHOWN:
 *	This symbol, if defined, indicates that the lchown routine is
 *	available to operate on a symbolic link (instead of following the
 *	link).
 */
/*#define HAS_LCHOWN		/**/

/* HAS_OPEN3:
 *	This manifest constant lets the C program know that the three
 *	argument form of open(2) is available.
 */
/*#define HAS_OPEN3		/**/

/* HAS_SAFE_BCOPY:
 *	This symbol, if defined, indicates that the bcopy routine is available
 *	to copy potentially overlapping memory blocks. Otherwise you should
 *	probably use memmove() or memcpy(). If neither is defined, roll your
 *	own version.
 */
/*#define HAS_SAFE_BCOPY	/**/

/* HAS_SAFE_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy potentially overlapping memory blocks. Otherwise you should
 *	probably use memmove() or memcpy(). If neither is defined, roll your
 *	own version.
 */
/*#define HAS_SAFE_MEMCPY	/**/

/* HAS_SANE_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	and can be used to compare relative magnitudes of chars with their high
 *	bits set.  If it is not defined, roll your own version.
 */
#define HAS_SANE_MEMCMP	/**/

/* HAS_SIGACTION:
 *	This symbol, if defined, indicates that Vr4's sigaction() routine
 *	is available.
 */
/*#define HAS_SIGACTION	/**/

/* Sigjmp_buf:
 *	This is the buffer type to be used with Sigsetjmp and Siglongjmp.
 */
/* Sigsetjmp:
 *	This macro is used in the same way as sigsetjmp(), but will invoke
 *	traditional setjmp() if sigsetjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/* Siglongjmp:
 *	This macro is used in the same way as siglongjmp(), but will invoke
 *	traditional longjmp() if siglongjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/*#define HAS_SIGSETJMP	/**/
#ifdef HAS_SIGSETJMP
#define Sigjmp_buf sigjmp_buf
#define Sigsetjmp(buf,save_mask) sigsetjmp((buf),(save_mask))
#define Siglongjmp(buf,retval) siglongjmp((buf),(retval))
#else
#define Sigjmp_buf jmp_buf
#define Sigsetjmp(buf,save_mask) setjmp((buf))
#define Siglongjmp(buf,retval) longjmp((buf),(retval))
#endif

/* USE_STDIO_PTR:
 *	This symbol is defined if the _ptr and _cnt fields (or similar)
 *	of the stdio FILE structure can be used to access the stdio buffer
 *	for a file handle.  If this is defined, then the FILE_ptr(fp)
 *	and FILE_cnt(fp) macros will also be defined and should be used
 *	to access these fields.
 */
/* FILE_ptr:
 *	This macro is used to access the _ptr field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_PTR_LVALUE:
 *	This symbol is defined if the FILE_ptr macro can be used as an
 *	lvalue.
 */
/* FILE_cnt:
 *	This macro is used to access the _cnt field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_CNT_LVALUE:
 *	This symbol is defined if the FILE_cnt macro can be used as an
 *	lvalue.
 */
#define USE_STDIO_PTR 	/**/
#ifdef USE_STDIO_PTR
#define FILE_ptr(fp)	((fp)->_ptr)
#define STDIO_PTR_LVALUE 		/**/
#define FILE_cnt(fp)	((fp)->_cnt)
#define STDIO_CNT_LVALUE 		/**/
#endif

/* USE_STDIO_BASE:
 *	This symbol is defined if the _base field (or similar) of the
 *	stdio FILE structure can be used to access the stdio buffer for
 *	a file handle.  If this is defined, then the FILE_base(fp) macro
 *	will also be defined and should be used to access this field.
 *	Also, the FILE_bufsiz(fp) macro will be defined and should be used
 *	to determine the number of bytes in the buffer.  USE_STDIO_BASE
 *	will never be defined unless USE_STDIO_PTR is.
 */
/* FILE_base:
 *	This macro is used to access the _base field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_BASE is defined.
 */
/* FILE_bufsiz:
 *	This macro is used to determine the number of bytes in the I/O
 *	buffer pointed to by _base field (or equivalent) of the FILE
 *	structure pointed to its argument. This macro will always be defined
 *	if USE_STDIO_BASE is defined.
 */
#define USE_STDIO_BASE 	/**/
#ifdef USE_STDIO_BASE
#define FILE_base(fp)	((fp)->_base)
#define FILE_bufsiz(fp)	((fp)->_cnt + (fp)->_ptr - (fp)->_base)
#endif

/* HAS_VPRINTF:
 *	This symbol, if defined, indicates that the vprintf routine is available
 *	to printf with a pointer to an argument list.  If unavailable, you
 *	may need to write your own, probably in terms of _doprnt().
 */
/* USE_CHAR_VSPRINTF:
 *	This symbol is defined if this system has vsprintf() returning type
 *	(char*).  The trend seems to be to declare it as "int vsprintf()".  It
 *	is up to the package author to declare vsprintf correctly based on the
 *	symbol.
 */
#define HAS_VPRINTF	/**/
/*#define USE_CHAR_VSPRINTF 	/**/

/* DOUBLESIZE:
 *	This symbol contains the size of a double, so that the C preprocessor
 *	can make decisions based on it.
 */
#define DOUBLESIZE 8		/**/

/* I_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <time.h>.
 */
/* I_SYS_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h>.
 */
/* I_SYS_TIME_KERNEL:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h> with KERNEL defined.
 */
#define I_TIME		/**/
/*#define I_SYS_TIME		/**/
/*#define I_SYS_TIME_KERNEL		/**/

/* INTSIZE:
 *	This symbol contains the value of sizeof(int) so that the C
 *	preprocessor can make decisions based on it.
 */
/* LONGSIZE:
 *	This symbol contains the value of sizeof(long) so that the C
 *	preprocessor can make decisions based on it.
 */
/* SHORTSIZE:
 *	This symbol contains the value of sizeof(short) so that the C
 *	preprocessor can make decisions based on it.
 */
#define INTSIZE 4		/**/
#define LONGSIZE 4		/**/
#define SHORTSIZE 2		/**/

/* VAL_O_NONBLOCK:
 *	This symbol is to be used during open() or fcntl(F_SETFL) to turn on
 *	non-blocking I/O for the file descriptor. Note that there is no way
 *	back, i.e. you cannot turn it blocking again this way. If you wish to
 *	alternatively switch between blocking and non-blocking, use the
 *	ioctl(FIOSNBIO) call instead, but that is not supported by all devices.
 */
/* VAL_EAGAIN:
 *	This symbol holds the errno error code set by read() when no data was
 *	present on the non-blocking file descriptor.
 */
/* RD_NODATA:
 *	This symbol holds the return code from read() when no data is present
 *	on the non-blocking file descriptor. Be careful! If EOF_NONBLOCK is
 *	not defined, then you can't distinguish between no data and EOF by
 *	issuing a read(). You'll have to find another way to tell for sure!
 */
/* EOF_NONBLOCK:
 *	This symbol, if defined, indicates to the C program that a read() on
 *	a non-blocking file descriptor will return 0 on EOF, and not the value
 *	held in RD_NODATA (-1 usually, in that case!).
 */
#define VAL_O_NONBLOCK O_NONBLOCK
#define VAL_EAGAIN EAGAIN
#define RD_NODATA -1
#define EOF_NONBLOCK

/* PTRSIZE:
 *	This symbol contains the size of a pointer, so that the C preprocessor
 *	can make decisions based on it.  It will be sizeof(void *) if
 *	the compiler supports (void *); otherwise it will be
 *	sizeof(char *).
 */
#define PTRSIZE 4		/**/

/* RANDBITS:
 *	This symbol contains the number of bits of random number the rand()
 *	function produces.  Usual values are 15, 16, and 31.
 */
#define RANDBITS 15		/**/

/* SSize_t:
 *	This symbol holds the type used by functions that return
 *	a count of bytes or an error condition.  It must be a signed type.
 *	It is usually ssize_t, but may be long or int, etc.
 *	It may be necessary to include <sys/types.h> or <unistd.h>
 *	to get any typedef'ed information.
 *	We will pick a type such that sizeof(SSize_t) == sizeof(Size_t).
 */
#define SSize_t int	 /* signed count of bytes */

/* OSNAME:
 *	This symbol contains the name of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
#define OSNAME "MSWin32"		/**/

/* CAT2:
 *	This macro catenates 2 tokens together.
 */
/* STRINGIFY:
 *	This macro surrounds its token with double quotes.
 */
#if 42 == 1
#define CAT2(a,b)a/**/b
#define STRINGIFY(a)"a"
		/* If you can get stringification with catify, tell me how! */
#endif
#if 42 == 42
#define CAT2(a,b)a ## b
#define StGiFy(a)# a
#define STRINGIFY(a)StGiFy(a)
#endif
#if 42 != 1 && 42 != 42
#include "Bletch: How does this C preprocessor catenate tokens?"
#endif

/* CSH:
 *	This symbol, if defined, contains the full pathname of csh.
 */
/*#define HAS_CSH		/**/
#ifdef HAS_CSH
#define CSH ""	/**/
#endif

/* HAS_ENDHOSTENT:
 *	This symbol, if defined, indicates that the endhostent() routine is
 *	available to close whatever was being used for host queries.
 */
/*#define HAS_ENDHOSTENT		/**/

/* HAS_ENDNETENT:
 *	This symbol, if defined, indicates that the endnetent() routine is
 *	available to close whatever was being used for network queries.
 */
/*#define HAS_ENDNETENT		/**/

/* HAS_ENDPROTOENT:
 *	This symbol, if defined, indicates that the endprotoent() routine is
 *	available to close whatever was being used for protocol queries.
 */
/*#define HAS_ENDPROTOENT		/**/

/* HAS_ENDSERVENT:
 *	This symbol, if defined, indicates that the endservent() routine is
 *	available to close whatever was being used for service queries.
 */
/*#define HAS_ENDSERVENT		/**/

/* HAS_GETHOSTBYADDR:
 *	This symbol, if defined, indicates that the gethostbyaddr() routine is
 *	available to look up hosts by their IP addresses.
 */
#define HAS_GETHOSTBYADDR		/**/

/* HAS_GETHOSTBYNAME:
 *	This symbol, if defined, indicates that the gethostbyname() routine is
 *	available to look up host names in some data base or other.
 */
#define HAS_GETHOSTBYNAME		/**/

/* HAS_GETHOSTENT:
 *	This symbol, if defined, indicates that the gethostent() routine is
 *	available to look up host names in some data base or another.
 */
/*#define HAS_GETHOSTENT		/**/

/* HAS_GETNETBYADDR:
 *	This symbol, if defined, indicates that the getnetbyaddr() routine is
 *	available to look up networks by their IP addresses.
 */
/*#define HAS_GETNETBYADDR		/**/

/* HAS_GETNETBYNAME:
 *	This symbol, if defined, indicates that the getnetbyname() routine is
 *	available to look up networks by their names.
 */
/*#define HAS_GETNETBYNAME		/**/

/* HAS_GETNETENT:
 *	This symbol, if defined, indicates that the getnetent() routine is
 *	available to look up network names in some data base or another.
 */
/*#define HAS_GETNETENT		/**/

/* HAS_GETPROTOENT:
 *	This symbol, if defined, indicates that the getprotoent() routine is
 *	available to look up protocols in some data base or another.
 */
/*#define HAS_GETPROTOENT		/**/

/* HAS_GETPROTOBYNAME:
 *	This symbol, if defined, indicates that the getprotobyname()
 *	routine is available to look up protocols by their name.
 */
/* HAS_GETPROTOBYNUMBER:
 *	This symbol, if defined, indicates that the getprotobynumber()
 *	routine is available to look up protocols by their number.
 */
#define HAS_GETPROTOBYNAME		/**/
#define HAS_GETPROTOBYNUMBER		/**/

/* HAS_GETSERVENT:
 *	This symbol, if defined, indicates that the getservent() routine is
 *	available to look up network services in some data base or another.
 */
/*#define HAS_GETSERVENT		/**/

/* HAS_GETSERVBYNAME:
 *	This symbol, if defined, indicates that the getservbyname()
 *	routine is available to look up services by their name.
 */
/* HAS_GETSERVBYPORT:
 *	This symbol, if defined, indicates that the getservbyport()
 *	routine is available to look up services by their port.
 */
#define HAS_GETSERVBYNAME		/**/
#define HAS_GETSERVBYPORT		/**/

/* HAS_LONG_DOUBLE:
 *	This symbol will be defined if the C compiler supports long
 *	doubles.
 */
/* LONG_DOUBLESIZE:
 *	This symbol contains the size of a long double, so that the 
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long doubles.
 */
#define HAS_LONG_DOUBLE		/**/
#ifdef HAS_LONG_DOUBLE
#define LONG_DOUBLESIZE 10		/**/
#endif

/* HAS_LONG_LONG:
 *	This symbol will be defined if the C compiler supports
 *	long long.
 */
/* LONGLONGSIZE:
 *	This symbol contains the size of a long long, so that the 
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long long.
 */
/*#define HAS_LONG_LONG		/**/
#ifdef HAS_LONG_LONG
#define LONGLONGSIZE 8		/**/
#endif

/* HAS_SETGROUPS:
 *	This symbol, if defined, indicates that the setgroups() routine is
 *	available to set the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_SETGROUPS		/**/

/* HAS_SETHOSTENT:
 *	This symbol, if defined, indicates that the sethostent() routine is
 *	available.
 */
/*#define HAS_SETHOSTENT		/**/

/* HAS_SETNETENT:
 *	This symbol, if defined, indicates that the setnetent() routine is
 *	available.
 */
/*#define HAS_SETNETENT		/**/

/* HAS_SETPROTOENT:
 *	This symbol, if defined, indicates that the setprotoent() routine is
 *	available.
 */
/*#define HAS_SETPROTOENT		/**/

/* HAS_SETSERVENT:
 *	This symbol, if defined, indicates that the setservent() routine is
 *	available.
 */
/*#define HAS_SETSERVENT		/**/

/* HAS_SETVBUF:
 *	This symbol, if defined, indicates that the setvbuf routine is
 *	available to change buffering on an open stdio stream.
 *	to a line-buffered mode.
 */
#define HAS_SETVBUF		/**/

/* HAS_SOCKET:
 *	This symbol, if defined, indicates that the BSD socket interface is
 *	supported.
 */
/* HAS_SOCKETPAIR:
 *	This symbol, if defined, indicates that the BSD socketpair() call is
 *	supported.
 */
#define HAS_SOCKET		/**/
/*#define HAS_SOCKETPAIR	/**/

/* HAS_UNION_SEMUN:
 *	This symbol, if defined, indicates that the union semun is
 *	defined by including <sys/sem.h>.  If not, the user code
 *	probably needs to define it as:
 *	union semun {
 *	    int val;
 *	    struct semid_ds *buf;
 *	    unsigned short *array;
 *	}
 */
/* USE_SEMCTL_SEMUN:
 *	This symbol, if defined, indicates that union semun is
 *	used for semctl IPC_STAT.
 */
/* USE_SEMCTL_SEMID_DS:
 *	This symbol, if defined, indicates that struct semid_ds * is
 *	used for semctl IPC_STAT.
 */
#define HAS_UNION_SEMUN	/**/
/*#define USE_SEMCTL_SEMUN	/**/
/*#define USE_SEMCTL_SEMID_DS	/**/

/* Signal_t:
 *	This symbol's value is either "void" or "int", corresponding to the
 *	appropriate return type of a signal handler.  Thus, you can declare
 *	a signal handler using "Signal_t (*handler)()", and define the
 *	handler using "Signal_t handler(sig)".
 */
#define Signal_t void	/* Signal handler's return type */

/* Groups_t:
 *	This symbol holds the type used for the second argument to
 *	getgroups() and setgropus().  Usually, this is the same as
 *	gidtype (gid_t) , but sometimes it isn't.
 *	It can be int, ushort, uid_t, etc... 
 *	It may be necessary to include <sys/types.h> to get any 
 *	typedef'ed information.  This is only required if you have
 *	getgroups() or setgropus()..
 */
#if defined(HAS_GETGROUPS) || defined(HAS_SETGROUPS)
#define Groups_t gid_t	/* Type for 2nd arg to [sg]etgroups() */
#endif

/* I_NETDB:
 *	This symbol, if defined, indicates that <netdb.h> exists and
 *	should be included.
 */
/*#define I_NETDB		/**/

/* I_PWD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <pwd.h>.
 */
/* PWQUOTA:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_quota.
 */
/* PWAGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_age.
 */
/* PWCHANGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_change.
 */
/* PWCLASS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_class.
 */
/* PWEXPIRE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_expire.
 */
/* PWCOMMENT:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_comment.
 */
/* PWGECOS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_gecos.
 */
/* PWPASSWD:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_passwd.
 */
/* HAS_SETPWENT:
 *	This symbol, if defined, indicates that the getpwrent routine is
 *	available for initializing sequential access of the passwd database.
 */
/* HAS_GETPWENT:
 *	This symbol, if defined, indicates that the getpwent routine is
 *	available for sequential access of the password database.
 */
/* HAS_ENDPWENT:
 *	This symbol, if defined, indicates that the getpwent routine is
 *	available for finalizing sequential access of the passwd database.
 */
/*#define I_PWD		/**/
/*#define PWQUOTA	/**/
/*#define PWAGE	/**/
/*#define PWCHANGE	/**/
/*#define PWCLASS	/**/
/*#define PWEXPIRE	/**/
/*#define PWCOMMENT	/**/
/*#define PWGECOS	/**/
/*#define PWPASSWD	/**/
/*#define HAS_SETPWENT	/**/
/*#define HAS_GETPWENT	/**/
/*#define HAS_ENDPWENT	/**/

/* Free_t:
 *	This variable contains the return type of free().  It is usually
 * void, but occasionally int.
 */
/* Malloc_t:
 *	This symbol is the type of pointer returned by malloc and realloc.
 */
#define Malloc_t void *			/**/
#define Free_t void			/**/

/* MYMALLOC:
 *	This symbol, if defined, indicates that we're using our own malloc.
 */
/*#define MYMALLOC			/**/

/* SIG_NAME:
 *	This symbol contains a list of signal names in order of
 *	signal number. This is intended
 *	to be used as a static array initialization, like this:
 *		char *sig_name[] = { SIG_NAME };
 *	The signals in the list are separated with commas, and each signal
 *	is surrounded by double quotes. There is no leading SIG in the signal
 *	name, i.e. SIGQUIT is known as "QUIT".
 *	Gaps in the signal numbers (up to NSIG) are filled in with NUMnn,
 *	etc., where nn is the actual signal number (e.g. NUM37).
 *	The signal number for sig_name[i] is stored in sig_num[i].
 *	The last element is 0 to terminate the list with a NULL.  This
 *	corresponds to the 0 at the end of the sig_num list.
 */
/* SIG_NUM:
 *	This symbol contains a list of signal numbers, in the same order as the
 *	SIG_NAME list. It is suitable for static array initialization, as in:
 *		int sig_num[] = { SIG_NUM };
 *	The signals in the list are separated with commas, and the indices
 *	within that list and the SIG_NAME list match, so it's easy to compute
 *	the signal name from a number or vice versa at the price of a small
 *	dynamic linear lookup. 
 *	Duplicates are allowed, but are moved to the end of the list.
 *	The signal number corresponding to sig_name[i] is sig_number[i].
 *	if (i < NSIG) then sig_number[i] == i.  
 *	The last element is 0, corresponding to the 0 at the end of
 *	the sig_name list.
 */
#define SIG_NAME "ZERO", "NUM01", "INT", "QUIT", "ILL", "NUM05", "NUM06", "NUM07", "FPE", "KILL", "NUM10", "SEGV", "NUM12", "PIPE", "ALRM", "TERM", "NUM16", "NUM17", "NUM18", "NUM19", "CHLD", "BREAK", "ABRT", "STOP", "NUM24", "CONT", "CLD", 0		/**/
#define SIG_NUM  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 20, 0		/**/

/* VOIDFLAGS:
 *	This symbol indicates how much support of the void type is given by this
 *	compiler.  What various bits mean:
 *
 *	    1 = supports declaration of void
 *	    2 = supports arrays of pointers to functions returning void
 *	    4 = supports comparisons between pointers to void functions and
 *		    addresses of void functions
 *	    8 = suports declaration of generic void pointers
 *
 *	The package designer should define VOIDUSED to indicate the requirements
 *	of the package.  This can be done either by #defining VOIDUSED before
 *	including config.h, or by defining defvoidused in Myinit.U.  If the
 *	latter approach is taken, only those flags will be tested.  If the
 *	level of void support necessary is not present, defines void to int.
 */
#ifndef VOIDUSED
#define VOIDUSED 15
#endif
#define VOIDFLAGS 15
#if (VOIDFLAGS & VOIDUSED) != VOIDUSED
#define void int		/* is void to be avoided? */
#define M_VOID			/* Xenix strikes again */
#endif

/* ARCHLIB:
 *	This variable, if defined, holds the name of the directory in
 *	which the user wants to put architecture-dependent public
 *	library files for perl5.  It is most often a local directory
 *	such as /usr/local/lib.  Programs using this variable must be
 *	prepared to deal with filename expansion.  If ARCHLIB is the
 *	same as PRIVLIB, it is not defined, since presumably the
 *	program already searches PRIVLIB.
 */
/* ARCHLIB_EXP:
 *	This symbol contains the ~name expanded version of ARCHLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define ARCHLIB "P:\\Apps\\ActivePerl\\temp\\lib\\MSWin32-x86-object"		/**/
/*#define ARCHLIB_EXP ""	/**/

/* DLSYM_NEEDS_UNDERSCORE:
 *	This symbol, if defined, indicates that we need to prepend an
 *	underscore to the symbol name before calling dlsym().  This only
 *	makes sense if you *have* dlsym, which we will presume is the
 *	case if you're using dl_dlopen.xs.
 */
/*#define 	DLSYM_NEEDS_UNDERSCORE 	/**/

/* USE_SFIO:
 *	This symbol, if defined, indicates that sfio should
 *	be used.
 */
/*#define	USE_SFIO		/**/

/* USE_DYNAMIC_LOADING:
 *	This symbol, if defined, indicates that dynamic loading of
 *	some sort is available.
 */
#define USE_DYNAMIC_LOADING		/**/

/* DB_Prefix_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is u_int32_t.
 */
/* DB_Hash_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is size_t.
 */
#define DB_Hash_t	int		/**/
#define DB_Prefix_t	int  	/**/

/* PRIVLIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 */
/* PRIVLIB_EXP:
 *	This symbol contains the ~name expanded version of PRIVLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define PRIVLIB "P:\\Apps\\ActivePerl\\temp\\lib"		/**/
#define PRIVLIB_EXP (win32_get_privlib("5.00503"))	/**/

/* SELECT_MIN_BITS:
 *	This symbol holds the minimum number of bits operated by select.
 *	That is, if you do select(n, ...), how many bits at least will be
 *	cleared in the masks if some activity is detected.  Usually this
 *	is either n or 32*ceil(n/32), especially many little-endians do
 *	the latter.  This is only useful if you have select(), naturally.
 */
#define SELECT_MIN_BITS 	undef	/**/

/* SITEARCH:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	Individual sites may place their own extensions and modules in
 *	this directory.
 */
/* SITEARCH_EXP:
 *	This symbol contains the ~name expanded version of SITEARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define SITEARCH "P:\\Apps\\ActivePerl\\temp\\site\\lib\\MSWin32-x86-object"		/**/
/*#define SITEARCH_EXP ""	/**/

/* SITELIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	Individual sites may place their own extensions and modules in
 *	this directory.
 */
/* SITELIB_EXP:
 *	This symbol contains the ~name expanded version of SITELIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define SITELIB "P:\\Apps\\ActivePerl\\temp\\site\\lib"		/**/
#define SITELIB_EXP (win32_get_sitelib("5.00503"))	/**/

/* STARTPERL:
 *	This variable contains the string to put in front of a perl
 *	script to make sure (one hopes) that it runs with perl and not
 *	some shell.
 */
#define STARTPERL "#!perl"		/**/

/* USE_PERLIO:
 *	This symbol, if defined, indicates that the PerlIO abstraction should
 *	be used throughout.  If not defined, stdio should be
 *	used in a fully backward compatible manner.
 */
/*#define	USE_PERLIO		/**/

/* HAS_GETHOST_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for gethostent(), gethostbyname(), and
 *	gethostbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETHOST_PROTOS	/**/

/* HAS_GETNET_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getnetent(), getnetbyname(), and
 *	getnetbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETNET_PROTOS	/**/

/* HAS_GETPROTO_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getprotoent(), getprotobyname(), and
 *	getprotobyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETPROTO_PROTOS	/**/

/* HAS_GETSERV_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getservent(), getservbyname(), and
 *	getservbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETSERV_PROTOS	/**/

/* Netdb_host_t:
 *	This symbol holds the type used for the 1st argument
 *	to gethostbyaddr().
 */
/* Netdb_hlen_t:
 *	This symbol holds the type used for the 2nd argument
 *	to gethostbyaddr().
 */
/* Netdb_name_t:
 *	This symbol holds the type used for the argument to
 *	gethostbyname().
 */
/* Netdb_net_t:
 *	This symbol holds the type used for the 1st argument to
 *	getnetbyaddr().
 */
#define Netdb_host_t		char * /**/
#define Netdb_hlen_t		int /**/
#define Netdb_name_t		char * /**/
#define Netdb_net_t		long /**/

/* Select_fd_set_t:
 *	This symbol holds the type used for the 2nd, 3rd, and 4th
 *	arguments to select.  Usually, this is 'fd_set *', if HAS_FD_SET
 *	is defined, and 'int *' otherwise.  This is only useful if you 
 *	have select(), of course.
 */
#define Select_fd_set_t 	Perl_fd_set *	/**/

/* ARCHNAME:
 *	This symbol holds a string representing the architecture name.
 *	It may be used to construct an architecture-dependant pathname
 *	where library files may be held under a private library, for
 *	instance.
 */
#define ARCHNAME "MSWin32-x86-object"		/**/

/* I_MACH_CTHREADS:
 *    This symbol, if defined, indicates to the C program that it should
 *    include <mach/cthreads.h>.
 */
/*#define	I_MACH_CTHREADS         /**/

/* I_PTHREAD:
 *    This symbol, if defined, indicates to the C program that it should
 *    include <pthread.h>.
 */
/*#define   I_PTHREAD               /**/

/* HAS_PTHREAD_YIELD:
 *	This symbol, if defined, indicates that the pthread_yield 
 *	routine is available to yield the execution of the current
 *	thread.
 */
/* HAS_SCHED_YIELD:
 *	This symbol, if defined, indicates that the sched_yield
 *	routine is available to yield the execution of the current
 *	thread.
 */
/*#define HAS_PTHREAD_YIELD	/**/
/*#define HAS_SCHED_YIELD	/**/

/* PTHREADS_CREATED_JOINABLE:
 *	This symbol, if defined, indicates that pthreads are created
 *	in the joinable (aka undetached) state.
 */
/*#define PTHREADS_CREATED_JOINABLE /**/

/* USE_THREADS:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use threads.
 */
/* OLD_PTHREADS_API:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use the old draft POSIX threads API.
 */
/*#define	USE_THREADS		/**/
/*#define	OLD_PTHREADS_API		/**/

/* Time_t:
 *	This symbol holds the type returned by time(). It can be long,
 *	or time_t on BSD sites (in which case <sys/types.h> should be
 *	included).
 */
#define Time_t time_t		/* Time type */

/* HAS_TIMES:
 *	This symbol, if defined, indicates that the times() routine exists.
 *	Note that this became obsolete on some systems (SUNOS), which now
 * use getrusage(). It may be necessary to include <sys/times.h>.
 */
#define HAS_TIMES		/**/

/* Fpos_t:
 *	This symbol holds the type used to declare file positions in libc.
 *	It can be fpos_t, long, uint, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Fpos_t fpos_t		/* File position type */

/* Gid_t:
 *	This symbol holds the return type of getgid() and the type of
 *	argument to setrgid() and related functions.  Typically,
 *	it is the type of group ids in the kernel. It can be int, ushort,
 *	uid_t, etc... It may be necessary to include <sys/types.h> to get
 *	any typedef'ed information.
 */
#define Gid_t gid_t		/* Type for getgid(), etc... */

/* Off_t:
 *	This symbol holds the type used to declare offsets in the kernel.
 *	It can be int, long, off_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Off_t off_t		/* <offset> type */

/* Mode_t:
 *	This symbol holds the type used to declare file modes 
 *	for systems calls.  It is usually mode_t, but may be
 *	int or unsigned short.  It may be necessary to include <sys/types.h>
 *	to get any typedef'ed information.
 */
#define Mode_t mode_t	 /* file mode parameter for system calls */

/* Pid_t:
 *	This symbol holds the type used to declare process ids in the kernel.
 *	It can be int, uint, pid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Pid_t int		/* PID type */

/* Size_t:
 *	This symbol holds the type used to declare length parameters
 *	for string functions.  It is usually size_t, but may be
 *	unsigned long, int, etc.  It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Size_t size_t	 /* length paramater for string functions */

/* Uid_t:
 *	This symbol holds the type used to declare user ids in the kernel.
 *	It can be int, ushort, uid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Uid_t uid_t		/* UID type */

#endif
#include <win32.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\cop.h ===
/*    cop.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct cop {
    BASEOP
    char *	cop_label;	/* label for this construct */
    HV *	cop_stash;	/* package line was compiled in */
    GV *	cop_filegv;	/* file the following line # is from */
    U32		cop_seq;	/* parse sequence number */
    I32		cop_arybase;	/* array base this line was compiled with */
    line_t      cop_line;       /* line # of this command */
};

#define Nullcop Null(COP*)

/*
 * Here we have some enormously heavy (or at least ponderous) wizardry.
 */

/* subroutine context */
struct block_sub {
    CV *	cv;
    GV *	gv;
    GV *	dfoutgv;
#ifndef USE_THREADS
    AV *	savearray;
#endif /* USE_THREADS */
    AV *	argarray;
    U16		olddepth;
    U8		hasargs;
};

#define PUSHSUB(cx)							\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.olddepth = CvDEPTH(cv);				\
	cx->blk_sub.hasargs = hasargs;

#define PUSHFORMAT(cx)							\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.gv = gv;						\
	cx->blk_sub.hasargs = 0;					\
	cx->blk_sub.dfoutgv = PL_defoutgv;				\
	(void)SvREFCNT_inc(cx->blk_sub.dfoutgv)

#define POPSUB(cx)							\
	{ struct block_sub cxsub;					\
	  POPSUB1(cx);							\
	  POPSUB2(); }

#define POPSUB1(cx)							\
	cxsub = cx->blk_sub;	/* because DESTROY may clobber *cx */

#ifdef USE_THREADS
#define POPSAVEARRAY() NOOP
#else
#define POPSAVEARRAY()							\
    STMT_START {							\
	SvREFCNT_dec(GvAV(PL_defgv));					\
	GvAV(PL_defgv) = cxsub.savearray;					\
    } STMT_END
#endif /* USE_THREADS */

#define POPSUB2()							\
	if (cxsub.hasargs) {						\
	    POPSAVEARRAY();						\
	    /* destroy arg array */					\
	    av_clear(cxsub.argarray);					\
	    AvREAL_off(cxsub.argarray);					\
	    AvREIFY_on(cxsub.argarray);					\
	}								\
	if (cxsub.cv) {							\
	    if (!(CvDEPTH(cxsub.cv) = cxsub.olddepth))			\
		SvREFCNT_dec(cxsub.cv);					\
	}

#define POPFORMAT(cx)							\
	setdefout(cx->blk_sub.dfoutgv);					\
	SvREFCNT_dec(cx->blk_sub.dfoutgv);

/* eval context */
struct block_eval {
    I32		old_in_eval;
    I32		old_op_type;
    char *	old_name;
    OP *	old_eval_root;
    SV *	cur_text;
};

#define PUSHEVAL(cx,n,fgv)						\
	cx->blk_eval.old_in_eval = PL_in_eval;				\
	cx->blk_eval.old_op_type = PL_op->op_type;				\
	cx->blk_eval.old_name = n;					\
	cx->blk_eval.old_eval_root = PL_eval_root;				\
	cx->blk_eval.cur_text = PL_linestr;

#define POPEVAL(cx)							\
	PL_in_eval = cx->blk_eval.old_in_eval;				\
	optype = cx->blk_eval.old_op_type;				\
	PL_eval_root = cx->blk_eval.old_eval_root;

/* loop context */
struct block_loop {
    char *	label;
    I32		resetsp;
    OP *	redo_op;
    OP *	next_op;
    OP *	last_op;
    SV **	itervar;
    SV *	itersave;
    SV *	iterlval;
    AV *	iterary;
    IV		iterix;
    IV		itermax;
};

#define PUSHLOOP(cx, ivar, s)						\
	cx->blk_loop.label = PL_curcop->cop_label;				\
	cx->blk_loop.resetsp = s - PL_stack_base;				\
	cx->blk_loop.redo_op = cLOOP->op_redoop;			\
	cx->blk_loop.next_op = cLOOP->op_nextop;			\
	cx->blk_loop.last_op = cLOOP->op_lastop;			\
	if (cx->blk_loop.itervar = (ivar))				\
	    cx->blk_loop.itersave = SvREFCNT_inc(*cx->blk_loop.itervar);\
	cx->blk_loop.iterlval = Nullsv;					\
	cx->blk_loop.iterary = Nullav;					\
	cx->blk_loop.iterix = -1;

#define POPLOOP(cx)							\
	{ struct block_loop cxloop;					\
	  POPLOOP1(cx);							\
	  POPLOOP2(); }

#define POPLOOP1(cx)							\
	cxloop = cx->blk_loop;	/* because DESTROY may clobber *cx */	\
	newsp = PL_stack_base + cxloop.resetsp;

#define POPLOOP2()							\
	SvREFCNT_dec(cxloop.iterlval);					\
	if (cxloop.itervar) {						\
	    sv_2mortal(*cxloop.itervar);				\
	    *cxloop.itervar = cxloop.itersave;				\
	}								\
	if (cxloop.iterary && cxloop.iterary != PL_curstack)		\
	    SvREFCNT_dec(cxloop.iterary);

/* context common to subroutines, evals and loops */
struct block {
    I32		blku_oldsp;	/* stack pointer to copy stuff down to */
    COP *	blku_oldcop;	/* old curcop pointer */
    I32		blku_oldretsp;	/* return stack index */
    I32		blku_oldmarksp;	/* mark stack index */
    I32		blku_oldscopesp;	/* scope stack index */
    PMOP *	blku_oldpm;	/* values of pattern match vars */
    U8		blku_gimme;	/* is this block running in list context? */

    union {
	struct block_sub	blku_sub;
	struct block_eval	blku_eval;
	struct block_loop	blku_loop;
    } blk_u;
};
#define blk_oldsp	cx_u.cx_blk.blku_oldsp
#define blk_oldcop	cx_u.cx_blk.blku_oldcop
#define blk_oldretsp	cx_u.cx_blk.blku_oldretsp
#define blk_oldmarksp	cx_u.cx_blk.blku_oldmarksp
#define blk_oldscopesp	cx_u.cx_blk.blku_oldscopesp
#define blk_oldpm	cx_u.cx_blk.blku_oldpm
#define blk_gimme	cx_u.cx_blk.blku_gimme
#define blk_sub		cx_u.cx_blk.blk_u.blku_sub
#define blk_eval	cx_u.cx_blk.blk_u.blku_eval
#define blk_loop	cx_u.cx_blk.blk_u.blku_loop

/* Enter a block. */
#define PUSHBLOCK(cx,t,sp) CXINC, cx = &cxstack[cxstack_ix],		\
	cx->cx_type		= t,					\
	cx->blk_oldsp		= sp - PL_stack_base,			\
	cx->blk_oldcop		= PL_curcop,				\
	cx->blk_oldmarksp	= PL_markstack_ptr - PL_markstack,	\
	cx->blk_oldscopesp	= PL_scopestack_ix,			\
	cx->blk_oldretsp	= PL_retstack_ix,			\
	cx->blk_oldpm		= PL_curpm,				\
	cx->blk_gimme		= gimme;				\
	DEBUG_l( PerlIO_printf(PerlIO_stderr(), "Entering block %ld, type %s\n",	\
		    (long)cxstack_ix, block_type[CxTYPE(cx)]); )

/* Exit a block (RETURN and LAST). */
#define POPBLOCK(cx,pm) cx = &cxstack[cxstack_ix--],			\
	newsp		 = PL_stack_base + cx->blk_oldsp,		\
	PL_curcop	 = cx->blk_oldcop,				\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_retstack_ix	 = cx->blk_oldretsp,				\
	pm		 = cx->blk_oldpm,				\
	gimme		 = cx->blk_gimme;				\
	DEBUG_l( PerlIO_printf(PerlIO_stderr(), "Leaving block %ld, type %s\n",		\
		    (long)cxstack_ix+1,block_type[CxTYPE(cx)]); )

/* Continue a block elsewhere (NEXT and REDO). */
#define TOPBLOCK(cx) cx  = &cxstack[cxstack_ix],			\
	PL_stack_sp	 = PL_stack_base + cx->blk_oldsp,		\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_retstack_ix	 = cx->blk_oldretsp,				\
	PL_curpm         = cx->blk_oldpm

/* substitution context */
struct subst {
    I32		sbu_iters;
    I32		sbu_maxiters;
    I32		sbu_safebase;
    I32		sbu_oldsave;
    bool	sbu_once;
    bool	sbu_rxtainted;
    char *	sbu_orig;
    SV *	sbu_dstr;
    SV *	sbu_targ;
    char *	sbu_s;
    char *	sbu_m;
    char *	sbu_strend;
    void *	sbu_rxres;
    REGEXP *	sbu_rx;
};
#define sb_iters	cx_u.cx_subst.sbu_iters
#define sb_maxiters	cx_u.cx_subst.sbu_maxiters
#define sb_safebase	cx_u.cx_subst.sbu_safebase
#define sb_oldsave	cx_u.cx_subst.sbu_oldsave
#define sb_once		cx_u.cx_subst.sbu_once
#define sb_rxtainted	cx_u.cx_subst.sbu_rxtainted
#define sb_orig		cx_u.cx_subst.sbu_orig
#define sb_dstr		cx_u.cx_subst.sbu_dstr
#define sb_targ		cx_u.cx_subst.sbu_targ
#define sb_s		cx_u.cx_subst.sbu_s
#define sb_m		cx_u.cx_subst.sbu_m
#define sb_strend	cx_u.cx_subst.sbu_strend
#define sb_rxres	cx_u.cx_subst.sbu_rxres
#define sb_rx		cx_u.cx_subst.sbu_rx

#define PUSHSUBST(cx) CXINC, cx = &cxstack[cxstack_ix],			\
	cx->sb_iters		= iters,				\
	cx->sb_maxiters		= maxiters,				\
	cx->sb_safebase		= safebase,				\
	cx->sb_oldsave		= oldsave,				\
	cx->sb_once		= once,					\
	cx->sb_rxtainted	= rxtainted,				\
	cx->sb_orig		= orig,					\
	cx->sb_dstr		= dstr,					\
	cx->sb_targ		= targ,					\
	cx->sb_s		= s,					\
	cx->sb_m		= m,					\
	cx->sb_strend		= strend,				\
	cx->sb_rxres		= Null(void*),				\
	cx->sb_rx		= rx,					\
	cx->cx_type		= CXt_SUBST;				\
	rxres_save(&cx->sb_rxres, rx)

#define POPSUBST(cx) cx = &cxstack[cxstack_ix--];			\
	rxres_free(&cx->sb_rxres)

struct context {
    U32		cx_type;	/* what kind of context this is */
    union {
	struct block	cx_blk;
	struct subst	cx_subst;
    } cx_u;
};

#define CXTYPEMASK	0xff
#define CXt_NULL	0
#define CXt_SUB		1
#define CXt_EVAL	2
#define CXt_LOOP	3
#define CXt_SUBST	4
#define CXt_BLOCK	5

/* private flags for CXt_EVAL */
#define CXp_REAL	0x00000100	/* truly eval'', not a lookalike */

#define CxTYPE(c)	((c)->cx_type & CXTYPEMASK)
#define CxREALEVAL(c)	(((c)->cx_type & (CXt_EVAL|CXp_REAL)) == (CXt_EVAL|CXp_REAL))

#define CXINC (cxstack_ix < cxstack_max ? ++cxstack_ix : (cxstack_ix = cxinc()))

/* "gimme" values */
#define G_SCALAR	0
#define G_ARRAY		1
#define G_VOID		128	/* skip this bit when adding flags below */

/* extra flags for perl_call_* routines */
#define G_DISCARD	2	/* Call FREETMPS. */
#define G_EVAL		4	/* Assume eval {} around subroutine call. */
#define G_NOARGS	8	/* Don't construct a @_ array. */
#define G_KEEPERR      16	/* Append errors to $@, don't overwrite it */
#define G_NODEBUG      32	/* Disable debugging at toplevel.  */

/* Support for switching (stack and block) contexts.
 * This ensures magic doesn't invalidate local stack and cx pointers.
 */

#define PERLSI_UNKNOWN		-1
#define PERLSI_UNDEF		0
#define PERLSI_MAIN		1
#define PERLSI_MAGIC		2
#define PERLSI_SORT		3
#define PERLSI_SIGNAL		4
#define PERLSI_OVERLOAD		5
#define PERLSI_DESTROY		6
#define PERLSI_WARNHOOK		7
#define PERLSI_DIEHOOK		8
#define PERLSI_REQUIRE		9

struct stackinfo {
    AV *		si_stack;	/* stack for current runlevel */
    PERL_CONTEXT *	si_cxstack;	/* context stack for runlevel */
    I32			si_cxix;	/* current context index */
    I32			si_cxmax;	/* maximum allocated index */
    I32			si_type;	/* type of runlevel */
    struct stackinfo *	si_prev;
    struct stackinfo *	si_next;
    I32 *		si_markbase;	/* where markstack begins for us.
					 * currently used only with DEBUGGING,
					 * but not #ifdef-ed for bincompat */
};

typedef struct stackinfo PERL_SI;

#define cxstack		(PL_curstackinfo->si_cxstack)
#define cxstack_ix	(PL_curstackinfo->si_cxix)
#define cxstack_max	(PL_curstackinfo->si_cxmax)

#ifdef DEBUGGING
#  define	SET_MARKBASE PL_curstackinfo->si_markbase = PL_markstack_ptr
#else
#  define	SET_MARKBASE NOOP
#endif

#define PUSHSTACKi(type) \
    STMT_START {							\
	PERL_SI *next = PL_curstackinfo->si_next;			\
	if (!next) {							\
	    next = new_stackinfo(32, 2048/sizeof(PERL_CONTEXT) - 1);	\
	    next->si_prev = PL_curstackinfo;				\
	    PL_curstackinfo->si_next = next;				\
	}								\
	next->si_type = type;						\
	next->si_cxix = -1;						\
	AvFILLp(next->si_stack) = 0;					\
	SWITCHSTACK(PL_curstack,next->si_stack);			\
	PL_curstackinfo = next;						\
	SET_MARKBASE;							\
    } STMT_END

#define PUSHSTACK PUSHSTACKi(PERLSI_UNKNOWN)

#define POPSTACK \
    STMT_START {							\
	PERL_SI *prev = PL_curstackinfo->si_prev;			\
	if (!prev) {							\
	    PerlIO_printf(PerlIO_stderr(), "panic: POPSTACK\n");	\
	    my_exit(1);							\
	}								\
	SWITCHSTACK(PL_curstack,prev->si_stack);			\
	/* don't free prev here, free them all at the END{} */		\
	PL_curstackinfo = prev;						\
    } STMT_END

#define POPSTACK_TO(s) \
    STMT_START {							\
	while (PL_curstack != s) {					\
	    dounwind(-1);						\
	    POPSTACK;							\
	}								\
    } STMT_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\embedvar.h ===
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from global.sym, intrpvar.h,
   and thrdvar.h.  Any changes made here will be lost!
*/

/* (Doing namespace management portably in C is really gross.) */

/*  EMBED has no run-time penalty, but helps keep the Perl namespace
    from colliding with that used by other libraries pulled in
    by extensions or by embedding perl.  Allow a cc -DNO_EMBED
    override, however, to keep binary compatability with previous
    versions of perl.
*/


/* Put interpreter-specific symbols into a struct? */

#ifdef MULTIPLICITY

#ifndef USE_THREADS
/* If we do not have threads then per-thread vars are per-interpreter */

#define PL_Sv			(PL_curinterp->TSv)
#define PL_Xpv			(PL_curinterp->TXpv)
#define PL_av_fetch_sv		(PL_curinterp->Tav_fetch_sv)
#define PL_bodytarget		(PL_curinterp->Tbodytarget)
#define PL_bostr		(PL_curinterp->Tbostr)
#define PL_chopset		(PL_curinterp->Tchopset)
#define PL_colors		(PL_curinterp->Tcolors)
#define PL_colorset		(PL_curinterp->Tcolorset)
#define PL_curcop		(PL_curinterp->Tcurcop)
#define PL_curpad		(PL_curinterp->Tcurpad)
#define PL_curpm		(PL_curinterp->Tcurpm)
#define PL_curstack		(PL_curinterp->Tcurstack)
#define PL_curstackinfo		(PL_curinterp->Tcurstackinfo)
#define PL_curstash		(PL_curinterp->Tcurstash)
#define PL_defoutgv		(PL_curinterp->Tdefoutgv)
#define PL_defstash		(PL_curinterp->Tdefstash)
#define PL_delaymagic		(PL_curinterp->Tdelaymagic)
#define PL_dirty		(PL_curinterp->Tdirty)
#define PL_extralen		(PL_curinterp->Textralen)
#define PL_firstgv		(PL_curinterp->Tfirstgv)
#define PL_formtarget		(PL_curinterp->Tformtarget)
#define PL_hv_fetch_ent_mh	(PL_curinterp->Thv_fetch_ent_mh)
#define PL_hv_fetch_sv		(PL_curinterp->Thv_fetch_sv)
#define PL_in_eval		(PL_curinterp->Tin_eval)
#define PL_last_in_gv		(PL_curinterp->Tlast_in_gv)
#define PL_lastgotoprobe	(PL_curinterp->Tlastgotoprobe)
#define PL_lastscream		(PL_curinterp->Tlastscream)
#define PL_localizing		(PL_curinterp->Tlocalizing)
#define PL_mainstack		(PL_curinterp->Tmainstack)
#define PL_markstack		(PL_curinterp->Tmarkstack)
#define PL_markstack_max	(PL_curinterp->Tmarkstack_max)
#define PL_markstack_ptr	(PL_curinterp->Tmarkstack_ptr)
#define PL_maxscream		(PL_curinterp->Tmaxscream)
#define PL_modcount		(PL_curinterp->Tmodcount)
#define PL_nrs			(PL_curinterp->Tnrs)
#define PL_ofs			(PL_curinterp->Tofs)
#define PL_ofslen		(PL_curinterp->Tofslen)
#define PL_op			(PL_curinterp->Top)
#define PL_opsave		(PL_curinterp->Topsave)
#define PL_reg_eval_set		(PL_curinterp->Treg_eval_set)
#define PL_reg_flags		(PL_curinterp->Treg_flags)
#define PL_reg_start_tmp	(PL_curinterp->Treg_start_tmp)
#define PL_reg_start_tmpl	(PL_curinterp->Treg_start_tmpl)
#define PL_regbol		(PL_curinterp->Tregbol)
#define PL_regcc		(PL_curinterp->Tregcc)
#define PL_regcode		(PL_curinterp->Tregcode)
#define PL_regcomp_parse	(PL_curinterp->Tregcomp_parse)
#define PL_regcomp_rx		(PL_curinterp->Tregcomp_rx)
#define PL_regcompp		(PL_curinterp->Tregcompp)
#define PL_regdata		(PL_curinterp->Tregdata)
#define PL_regdummy		(PL_curinterp->Tregdummy)
#define PL_regendp		(PL_curinterp->Tregendp)
#define PL_regeol		(PL_curinterp->Tregeol)
#define PL_regexecp		(PL_curinterp->Tregexecp)
#define PL_regflags		(PL_curinterp->Tregflags)
#define PL_regindent		(PL_curinterp->Tregindent)
#define PL_reginput		(PL_curinterp->Treginput)
#define PL_reginterp_cnt	(PL_curinterp->Treginterp_cnt)
#define PL_reglastparen		(PL_curinterp->Treglastparen)
#define PL_regnarrate		(PL_curinterp->Tregnarrate)
#define PL_regnaughty		(PL_curinterp->Tregnaughty)
#define PL_regnpar		(PL_curinterp->Tregnpar)
#define PL_regprecomp		(PL_curinterp->Tregprecomp)
#define PL_regprev		(PL_curinterp->Tregprev)
#define PL_regprogram		(PL_curinterp->Tregprogram)
#define PL_regsawback		(PL_curinterp->Tregsawback)
#define PL_regseen		(PL_curinterp->Tregseen)
#define PL_regsize		(PL_curinterp->Tregsize)
#define PL_regstartp		(PL_curinterp->Tregstartp)
#define PL_regtill		(PL_curinterp->Tregtill)
#define PL_regxend		(PL_curinterp->Tregxend)
#define PL_restartop		(PL_curinterp->Trestartop)
#define PL_retstack		(PL_curinterp->Tretstack)
#define PL_retstack_ix		(PL_curinterp->Tretstack_ix)
#define PL_retstack_max		(PL_curinterp->Tretstack_max)
#define PL_rs			(PL_curinterp->Trs)
#define PL_savestack		(PL_curinterp->Tsavestack)
#define PL_savestack_ix		(PL_curinterp->Tsavestack_ix)
#define PL_savestack_max	(PL_curinterp->Tsavestack_max)
#define PL_scopestack		(PL_curinterp->Tscopestack)
#define PL_scopestack_ix	(PL_curinterp->Tscopestack_ix)
#define PL_scopestack_max	(PL_curinterp->Tscopestack_max)
#define PL_screamfirst		(PL_curinterp->Tscreamfirst)
#define PL_screamnext		(PL_curinterp->Tscreamnext)
#define PL_secondgv		(PL_curinterp->Tsecondgv)
#define PL_seen_evals		(PL_curinterp->Tseen_evals)
#define PL_seen_zerolen		(PL_curinterp->Tseen_zerolen)
#define PL_sortcop		(PL_curinterp->Tsortcop)
#define PL_sortcxix		(PL_curinterp->Tsortcxix)
#define PL_sortstash		(PL_curinterp->Tsortstash)
#define PL_stack_base		(PL_curinterp->Tstack_base)
#define PL_stack_max		(PL_curinterp->Tstack_max)
#define PL_stack_sp		(PL_curinterp->Tstack_sp)
#define PL_start_env		(PL_curinterp->Tstart_env)
#define PL_statbuf		(PL_curinterp->Tstatbuf)
#define PL_statcache		(PL_curinterp->Tstatcache)
#define PL_statgv		(PL_curinterp->Tstatgv)
#define PL_statname		(PL_curinterp->Tstatname)
#define PL_tainted		(PL_curinterp->Ttainted)
#define PL_timesbuf		(PL_curinterp->Ttimesbuf)
#define PL_tmps_floor		(PL_curinterp->Ttmps_floor)
#define PL_tmps_ix		(PL_curinterp->Ttmps_ix)
#define PL_tmps_max		(PL_curinterp->Ttmps_max)
#define PL_tmps_stack		(PL_curinterp->Ttmps_stack)
#define PL_top_env		(PL_curinterp->Ttop_env)
#define PL_toptarget		(PL_curinterp->Ttoptarget)

#endif /* !USE_THREADS */

/* These are always per-interpreter if there is more than one */

#define PL_Argv			(PL_curinterp->IArgv)
#define PL_Cmd			(PL_curinterp->ICmd)
#define PL_DBcv			(PL_curinterp->IDBcv)
#define PL_DBgv			(PL_curinterp->IDBgv)
#define PL_DBline		(PL_curinterp->IDBline)
#define PL_DBsignal		(PL_curinterp->IDBsignal)
#define PL_DBsingle		(PL_curinterp->IDBsingle)
#define PL_DBsub		(PL_curinterp->IDBsub)
#define PL_DBtrace		(PL_curinterp->IDBtrace)
#define PL_ampergv		(PL_curinterp->Iampergv)
#define PL_archpat_auto		(PL_curinterp->Iarchpat_auto)
#define PL_argvgv		(PL_curinterp->Iargvgv)
#define PL_argvoutgv		(PL_curinterp->Iargvoutgv)
#define PL_basetime		(PL_curinterp->Ibasetime)
#define PL_beginav		(PL_curinterp->Ibeginav)
#define PL_bytecode_iv_overflows	(PL_curinterp->Ibytecode_iv_overflows)
#define PL_bytecode_obj_list	(PL_curinterp->Ibytecode_obj_list)
#define PL_bytecode_obj_list_fill	(PL_curinterp->Ibytecode_obj_list_fill)
#define PL_bytecode_pv		(PL_curinterp->Ibytecode_pv)
#define PL_bytecode_sv		(PL_curinterp->Ibytecode_sv)
#define PL_cddir		(PL_curinterp->Icddir)
#define PL_compcv		(PL_curinterp->Icompcv)
#define PL_compiling		(PL_curinterp->Icompiling)
#define PL_comppad		(PL_curinterp->Icomppad)
#define PL_comppad_name		(PL_curinterp->Icomppad_name)
#define PL_comppad_name_fill	(PL_curinterp->Icomppad_name_fill)
#define PL_comppad_name_floor	(PL_curinterp->Icomppad_name_floor)
#define PL_copline		(PL_curinterp->Icopline)
#define PL_curcopdb		(PL_curinterp->Icurcopdb)
#define PL_curstname		(PL_curinterp->Icurstname)
#define PL_dbargs		(PL_curinterp->Idbargs)
#define PL_debdelim		(PL_curinterp->Idebdelim)
#define PL_debname		(PL_curinterp->Idebname)
#define PL_debstash		(PL_curinterp->Idebstash)
#define PL_defgv		(PL_curinterp->Idefgv)
#define PL_diehook		(PL_curinterp->Idiehook)
#define PL_dlevel		(PL_curinterp->Idlevel)
#define PL_dlmax		(PL_curinterp->Idlmax)
#define PL_doextract		(PL_curinterp->Idoextract)
#define PL_doswitches		(PL_curinterp->Idoswitches)
#define PL_dowarn		(PL_curinterp->Idowarn)
#define PL_dumplvl		(PL_curinterp->Idumplvl)
#define PL_e_script		(PL_curinterp->Ie_script)
#define PL_endav		(PL_curinterp->Iendav)
#define PL_envgv		(PL_curinterp->Ienvgv)
#define PL_errgv		(PL_curinterp->Ierrgv)
#define PL_eval_root		(PL_curinterp->Ieval_root)
#define PL_eval_start		(PL_curinterp->Ieval_start)
#define PL_exitlist		(PL_curinterp->Iexitlist)
#define PL_exitlistlen		(PL_curinterp->Iexitlistlen)
#define PL_fdpid		(PL_curinterp->Ifdpid)
#define PL_filemode		(PL_curinterp->Ifilemode)
#define PL_forkprocess		(PL_curinterp->Iforkprocess)
#define PL_formfeed		(PL_curinterp->Iformfeed)
#define PL_generation		(PL_curinterp->Igeneration)
#define PL_gensym		(PL_curinterp->Igensym)
#define PL_globalstash		(PL_curinterp->Iglobalstash)
#define PL_hintgv		(PL_curinterp->Ihintgv)
#define PL_in_clean_all		(PL_curinterp->Iin_clean_all)
#define PL_in_clean_objs	(PL_curinterp->Iin_clean_objs)
#define PL_incgv		(PL_curinterp->Iincgv)
#define PL_initav		(PL_curinterp->Iinitav)
#define PL_inplace		(PL_curinterp->Iinplace)
#define PL_last_proto		(PL_curinterp->Ilast_proto)
#define PL_lastfd		(PL_curinterp->Ilastfd)
#define PL_lastsize		(PL_curinterp->Ilastsize)
#define PL_lastspbase		(PL_curinterp->Ilastspbase)
#define PL_laststatval		(PL_curinterp->Ilaststatval)
#define PL_laststype		(PL_curinterp->Ilaststype)
#define PL_leftgv		(PL_curinterp->Ileftgv)
#define PL_lineary		(PL_curinterp->Ilineary)
#define PL_linestart		(PL_curinterp->Ilinestart)
#define PL_localpatches		(PL_curinterp->Ilocalpatches)
#define PL_main_cv		(PL_curinterp->Imain_cv)
#define PL_main_root		(PL_curinterp->Imain_root)
#define PL_main_start		(PL_curinterp->Imain_start)
#define PL_maxsysfd		(PL_curinterp->Imaxsysfd)
#define PL_mess_sv		(PL_curinterp->Imess_sv)
#define PL_minus_F		(PL_curinterp->Iminus_F)
#define PL_minus_a		(PL_curinterp->Iminus_a)
#define PL_minus_c		(PL_curinterp->Iminus_c)
#define PL_minus_l		(PL_curinterp->Iminus_l)
#define PL_minus_n		(PL_curinterp->Iminus_n)
#define PL_minus_p		(PL_curinterp->Iminus_p)
#define PL_modglobal		(PL_curinterp->Imodglobal)
#define PL_multiline		(PL_curinterp->Imultiline)
#define PL_mystrk		(PL_curinterp->Imystrk)
#define PL_ofmt			(PL_curinterp->Iofmt)
#define PL_oldlastpm		(PL_curinterp->Ioldlastpm)
#define PL_oldname		(PL_curinterp->Ioldname)
#define PL_op_mask		(PL_curinterp->Iop_mask)
#define PL_origargc		(PL_curinterp->Iorigargc)
#define PL_origargv		(PL_curinterp->Iorigargv)
#define PL_origfilename		(PL_curinterp->Iorigfilename)
#define PL_ors			(PL_curinterp->Iors)
#define PL_orslen		(PL_curinterp->Iorslen)
#define PL_parsehook		(PL_curinterp->Iparsehook)
#define PL_patchlevel		(PL_curinterp->Ipatchlevel)
#define PL_pending_ident	(PL_curinterp->Ipending_ident)
#define PL_perl_destruct_level	(PL_curinterp->Iperl_destruct_level)
#define PL_perldb		(PL_curinterp->Iperldb)
#define PL_preambleav		(PL_curinterp->Ipreambleav)
#define PL_preambled		(PL_curinterp->Ipreambled)
#define PL_preprocess		(PL_curinterp->Ipreprocess)
#define PL_profiledata		(PL_curinterp->Iprofiledata)
#define PL_replgv		(PL_curinterp->Ireplgv)
#define PL_rightgv		(PL_curinterp->Irightgv)
#define PL_rsfp			(PL_curinterp->Irsfp)
#define PL_rsfp_filters		(PL_curinterp->Irsfp_filters)
#define PL_sawampersand		(PL_curinterp->Isawampersand)
#define PL_sawstudy		(PL_curinterp->Isawstudy)
#define PL_sawvec		(PL_curinterp->Isawvec)
#define PL_siggv		(PL_curinterp->Isiggv)
#define PL_splitstr		(PL_curinterp->Isplitstr)
#define PL_statusvalue		(PL_curinterp->Istatusvalue)
#define PL_statusvalue_vms	(PL_curinterp->Istatusvalue_vms)
#define PL_stdingv		(PL_curinterp->Istdingv)
#define PL_strchop		(PL_curinterp->Istrchop)
#define PL_strtab		(PL_curinterp->Istrtab)
#define PL_strtab_mutex		(PL_curinterp->Istrtab_mutex)
#define PL_sub_generation	(PL_curinterp->Isub_generation)
#define PL_sublex_info		(PL_curinterp->Isublex_info)
#define PL_sv_arenaroot		(PL_curinterp->Isv_arenaroot)
#define PL_sv_count		(PL_curinterp->Isv_count)
#define PL_sv_objcount		(PL_curinterp->Isv_objcount)
#define PL_sv_root		(PL_curinterp->Isv_root)
#define PL_sys_intern		(PL_curinterp->Isys_intern)
#define PL_tainting		(PL_curinterp->Itainting)
#define PL_threadnum		(PL_curinterp->Ithreadnum)
#define PL_thrsv		(PL_curinterp->Ithrsv)
#define PL_unsafe		(PL_curinterp->Iunsafe)
#define PL_warnhook		(PL_curinterp->Iwarnhook)

#else	/* !MULTIPLICITY */

#define PL_IArgv		PL_Argv
#define PL_ICmd			PL_Cmd
#define PL_IDBcv		PL_DBcv
#define PL_IDBgv		PL_DBgv
#define PL_IDBline		PL_DBline
#define PL_IDBsignal		PL_DBsignal
#define PL_IDBsingle		PL_DBsingle
#define PL_IDBsub		PL_DBsub
#define PL_IDBtrace		PL_DBtrace
#define PL_Iampergv		PL_ampergv
#define PL_Iarchpat_auto	PL_archpat_auto
#define PL_Iargvgv		PL_argvgv
#define PL_Iargvoutgv		PL_argvoutgv
#define PL_Ibasetime		PL_basetime
#define PL_Ibeginav		PL_beginav
#define PL_Ibytecode_iv_overflows	PL_bytecode_iv_overflows
#define PL_Ibytecode_obj_list	PL_bytecode_obj_list
#define PL_Ibytecode_obj_list_fill	PL_bytecode_obj_list_fill
#define PL_Ibytecode_pv		PL_bytecode_pv
#define PL_Ibytecode_sv		PL_bytecode_sv
#define PL_Icddir		PL_cddir
#define PL_Icompcv		PL_compcv
#define PL_Icompiling		PL_compiling
#define PL_Icomppad		PL_comppad
#define PL_Icomppad_name	PL_comppad_name
#define PL_Icomppad_name_fill	PL_comppad_name_fill
#define PL_Icomppad_name_floor	PL_comppad_name_floor
#define PL_Icopline		PL_copline
#define PL_Icurcopdb		PL_curcopdb
#define PL_Icurstname		PL_curstname
#define PL_Idbargs		PL_dbargs
#define PL_Idebdelim		PL_debdelim
#define PL_Idebname		PL_debname
#define PL_Idebstash		PL_debstash
#define PL_Idefgv		PL_defgv
#define PL_Idiehook		PL_diehook
#define PL_Idlevel		PL_dlevel
#define PL_Idlmax		PL_dlmax
#define PL_Idoextract		PL_doextract
#define PL_Idoswitches		PL_doswitches
#define PL_Idowarn		PL_dowarn
#define PL_Idumplvl		PL_dumplvl
#define PL_Ie_script		PL_e_script
#define PL_Iendav		PL_endav
#define PL_Ienvgv		PL_envgv
#define PL_Ierrgv		PL_errgv
#define PL_Ieval_root		PL_eval_root
#define PL_Ieval_start		PL_eval_start
#define PL_Iexitlist		PL_exitlist
#define PL_Iexitlistlen		PL_exitlistlen
#define PL_Ifdpid		PL_fdpid
#define PL_Ifilemode		PL_filemode
#define PL_Iforkprocess		PL_forkprocess
#define PL_Iformfeed		PL_formfeed
#define PL_Igeneration		PL_generation
#define PL_Igensym		PL_gensym
#define PL_Iglobalstash		PL_globalstash
#define PL_Ihintgv		PL_hintgv
#define PL_Iin_clean_all	PL_in_clean_all
#define PL_Iin_clean_objs	PL_in_clean_objs
#define PL_Iincgv		PL_incgv
#define PL_Iinitav		PL_initav
#define PL_Iinplace		PL_inplace
#define PL_Ilast_proto		PL_last_proto
#define PL_Ilastfd		PL_lastfd
#define PL_Ilastsize		PL_lastsize
#define PL_Ilastspbase		PL_lastspbase
#define PL_Ilaststatval		PL_laststatval
#define PL_Ilaststype		PL_laststype
#define PL_Ileftgv		PL_leftgv
#define PL_Ilineary		PL_lineary
#define PL_Ilinestart		PL_linestart
#define PL_Ilocalpatches	PL_localpatches
#define PL_Imain_cv		PL_main_cv
#define PL_Imain_root		PL_main_root
#define PL_Imain_start		PL_main_start
#define PL_Imaxsysfd		PL_maxsysfd
#define PL_Imess_sv		PL_mess_sv
#define PL_Iminus_F		PL_minus_F
#define PL_Iminus_a		PL_minus_a
#define PL_Iminus_c		PL_minus_c
#define PL_Iminus_l		PL_minus_l
#define PL_Iminus_n		PL_minus_n
#define PL_Iminus_p		PL_minus_p
#define PL_Imodglobal		PL_modglobal
#define PL_Imultiline		PL_multiline
#define PL_Imystrk		PL_mystrk
#define PL_Iofmt		PL_ofmt
#define PL_Ioldlastpm		PL_oldlastpm
#define PL_Ioldname		PL_oldname
#define PL_Iop_mask		PL_op_mask
#define PL_Iorigargc		PL_origargc
#define PL_Iorigargv		PL_origargv
#define PL_Iorigfilename	PL_origfilename
#define PL_Iors			PL_ors
#define PL_Iorslen		PL_orslen
#define PL_Iparsehook		PL_parsehook
#define PL_Ipatchlevel		PL_patchlevel
#define PL_Ipending_ident	PL_pending_ident
#define PL_Iperl_destruct_level	PL_perl_destruct_level
#define PL_Iperldb		PL_perldb
#define PL_Ipreambleav		PL_preambleav
#define PL_Ipreambled		PL_preambled
#define PL_Ipreprocess		PL_preprocess
#define PL_Iprofiledata		PL_profiledata
#define PL_Ireplgv		PL_replgv
#define PL_Irightgv		PL_rightgv
#define PL_Irsfp		PL_rsfp
#define PL_Irsfp_filters	PL_rsfp_filters
#define PL_Isawampersand	PL_sawampersand
#define PL_Isawstudy		PL_sawstudy
#define PL_Isawvec		PL_sawvec
#define PL_Isiggv		PL_siggv
#define PL_Isplitstr		PL_splitstr
#define PL_Istatusvalue		PL_statusvalue
#define PL_Istatusvalue_vms	PL_statusvalue_vms
#define PL_Istdingv		PL_stdingv
#define PL_Istrchop		PL_strchop
#define PL_Istrtab		PL_strtab
#define PL_Istrtab_mutex	PL_strtab_mutex
#define PL_Isub_generation	PL_sub_generation
#define PL_Isublex_info		PL_sublex_info
#define PL_Isv_arenaroot	PL_sv_arenaroot
#define PL_Isv_count		PL_sv_count
#define PL_Isv_objcount		PL_sv_objcount
#define PL_Isv_root		PL_sv_root
#define PL_Isys_intern		PL_sys_intern
#define PL_Itainting		PL_tainting
#define PL_Ithreadnum		PL_threadnum
#define PL_Ithrsv		PL_thrsv
#define PL_Iunsafe		PL_unsafe
#define PL_Iwarnhook		PL_warnhook

#ifndef USE_THREADS

#define PL_TSv			PL_Sv
#define PL_TXpv			PL_Xpv
#define PL_Tav_fetch_sv		PL_av_fetch_sv
#define PL_Tbodytarget		PL_bodytarget
#define PL_Tbostr		PL_bostr
#define PL_Tchopset		PL_chopset
#define PL_Tcolors		PL_colors
#define PL_Tcolorset		PL_colorset
#define PL_Tcurcop		PL_curcop
#define PL_Tcurpad		PL_curpad
#define PL_Tcurpm		PL_curpm
#define PL_Tcurstack		PL_curstack
#define PL_Tcurstackinfo	PL_curstackinfo
#define PL_Tcurstash		PL_curstash
#define PL_Tdefoutgv		PL_defoutgv
#define PL_Tdefstash		PL_defstash
#define PL_Tdelaymagic		PL_delaymagic
#define PL_Tdirty		PL_dirty
#define PL_Textralen		PL_extralen
#define PL_Tfirstgv		PL_firstgv
#define PL_Tformtarget		PL_formtarget
#define PL_Thv_fetch_ent_mh	PL_hv_fetch_ent_mh
#define PL_Thv_fetch_sv		PL_hv_fetch_sv
#define PL_Tin_eval		PL_in_eval
#define PL_Tlast_in_gv		PL_last_in_gv
#define PL_Tlastgotoprobe	PL_lastgotoprobe
#define PL_Tlastscream		PL_lastscream
#define PL_Tlocalizing		PL_localizing
#define PL_Tmainstack		PL_mainstack
#define PL_Tmarkstack		PL_markstack
#define PL_Tmarkstack_max	PL_markstack_max
#define PL_Tmarkstack_ptr	PL_markstack_ptr
#define PL_Tmaxscream		PL_maxscream
#define PL_Tmodcount		PL_modcount
#define PL_Tnrs			PL_nrs
#define PL_Tofs			PL_ofs
#define PL_Tofslen		PL_ofslen
#define PL_Top			PL_op
#define PL_Topsave		PL_opsave
#define PL_Treg_eval_set	PL_reg_eval_set
#define PL_Treg_flags		PL_reg_flags
#define PL_Treg_start_tmp	PL_reg_start_tmp
#define PL_Treg_start_tmpl	PL_reg_start_tmpl
#define PL_Tregbol		PL_regbol
#define PL_Tregcc		PL_regcc
#define PL_Tregcode		PL_regcode
#define PL_Tregcomp_parse	PL_regcomp_parse
#define PL_Tregcomp_rx		PL_regcomp_rx
#define PL_Tregcompp		PL_regcompp
#define PL_Tregdata		PL_regdata
#define PL_Tregdummy		PL_regdummy
#define PL_Tregendp		PL_regendp
#define PL_Tregeol		PL_regeol
#define PL_Tregexecp		PL_regexecp
#define PL_Tregflags		PL_regflags
#define PL_Tregindent		PL_regindent
#define PL_Treginput		PL_reginput
#define PL_Treginterp_cnt	PL_reginterp_cnt
#define PL_Treglastparen	PL_reglastparen
#define PL_Tregnarrate		PL_regnarrate
#define PL_Tregnaughty		PL_regnaughty
#define PL_Tregnpar		PL_regnpar
#define PL_Tregprecomp		PL_regprecomp
#define PL_Tregprev		PL_regprev
#define PL_Tregprogram		PL_regprogram
#define PL_Tregsawback		PL_regsawback
#define PL_Tregseen		PL_regseen
#define PL_Tregsize		PL_regsize
#define PL_Tregstartp		PL_regstartp
#define PL_Tregtill		PL_regtill
#define PL_Tregxend		PL_regxend
#define PL_Trestartop		PL_restartop
#define PL_Tretstack		PL_retstack
#define PL_Tretstack_ix		PL_retstack_ix
#define PL_Tretstack_max	PL_retstack_max
#define PL_Trs			PL_rs
#define PL_Tsavestack		PL_savestack
#define PL_Tsavestack_ix	PL_savestack_ix
#define PL_Tsavestack_max	PL_savestack_max
#define PL_Tscopestack		PL_scopestack
#define PL_Tscopestack_ix	PL_scopestack_ix
#define PL_Tscopestack_max	PL_scopestack_max
#define PL_Tscreamfirst		PL_screamfirst
#define PL_Tscreamnext		PL_screamnext
#define PL_Tsecondgv		PL_secondgv
#define PL_Tseen_evals		PL_seen_evals
#define PL_Tseen_zerolen	PL_seen_zerolen
#define PL_Tsortcop		PL_sortcop
#define PL_Tsortcxix		PL_sortcxix
#define PL_Tsortstash		PL_sortstash
#define PL_Tstack_base		PL_stack_base
#define PL_Tstack_max		PL_stack_max
#define PL_Tstack_sp		PL_stack_sp
#define PL_Tstart_env		PL_start_env
#define PL_Tstatbuf		PL_statbuf
#define PL_Tstatcache		PL_statcache
#define PL_Tstatgv		PL_statgv
#define PL_Tstatname		PL_statname
#define PL_Ttainted		PL_tainted
#define PL_Ttimesbuf		PL_timesbuf
#define PL_Ttmps_floor		PL_tmps_floor
#define PL_Ttmps_ix		PL_tmps_ix
#define PL_Ttmps_max		PL_tmps_max
#define PL_Ttmps_stack		PL_tmps_stack
#define PL_Ttop_env		PL_top_env
#define PL_Ttoptarget		PL_toptarget

#endif /* USE_THREADS */

/* Hide what would have been interpreter-specific symbols? */

#ifdef EMBED


#ifndef USE_THREADS


#endif /* USE_THREADS */
#endif /* EMBED */
#endif /* MULTIPLICITY */

/* Now same trickey for per-thread variables */

#ifdef USE_THREADS

#define PL_Sv			(thr->TSv)
#define PL_Xpv			(thr->TXpv)
#define PL_av_fetch_sv		(thr->Tav_fetch_sv)
#define PL_bodytarget		(thr->Tbodytarget)
#define PL_bostr		(thr->Tbostr)
#define PL_chopset		(thr->Tchopset)
#define PL_colors		(thr->Tcolors)
#define PL_colorset		(thr->Tcolorset)
#define PL_curcop		(thr->Tcurcop)
#define PL_curpad		(thr->Tcurpad)
#define PL_curpm		(thr->Tcurpm)
#define PL_curstack		(thr->Tcurstack)
#define PL_curstackinfo		(thr->Tcurstackinfo)
#define PL_curstash		(thr->Tcurstash)
#define PL_defoutgv		(thr->Tdefoutgv)
#define PL_defstash		(thr->Tdefstash)
#define PL_delaymagic		(thr->Tdelaymagic)
#define PL_dirty		(thr->Tdirty)
#define PL_extralen		(thr->Textralen)
#define PL_firstgv		(thr->Tfirstgv)
#define PL_formtarget		(thr->Tformtarget)
#define PL_hv_fetch_ent_mh	(thr->Thv_fetch_ent_mh)
#define PL_hv_fetch_sv		(thr->Thv_fetch_sv)
#define PL_in_eval		(thr->Tin_eval)
#define PL_last_in_gv		(thr->Tlast_in_gv)
#define PL_lastgotoprobe	(thr->Tlastgotoprobe)
#define PL_lastscream		(thr->Tlastscream)
#define PL_localizing		(thr->Tlocalizing)
#define PL_mainstack		(thr->Tmainstack)
#define PL_markstack		(thr->Tmarkstack)
#define PL_markstack_max	(thr->Tmarkstack_max)
#define PL_markstack_ptr	(thr->Tmarkstack_ptr)
#define PL_maxscream		(thr->Tmaxscream)
#define PL_modcount		(thr->Tmodcount)
#define PL_nrs			(thr->Tnrs)
#define PL_ofs			(thr->Tofs)
#define PL_ofslen		(thr->Tofslen)
#define PL_op			(thr->Top)
#define PL_opsave		(thr->Topsave)
#define PL_reg_eval_set		(thr->Treg_eval_set)
#define PL_reg_flags		(thr->Treg_flags)
#define PL_reg_start_tmp	(thr->Treg_start_tmp)
#define PL_reg_start_tmpl	(thr->Treg_start_tmpl)
#define PL_regbol		(thr->Tregbol)
#define PL_regcc		(thr->Tregcc)
#define PL_regcode		(thr->Tregcode)
#define PL_regcomp_parse	(thr->Tregcomp_parse)
#define PL_regcomp_rx		(thr->Tregcomp_rx)
#define PL_regcompp		(thr->Tregcompp)
#define PL_regdata		(thr->Tregdata)
#define PL_regdummy		(thr->Tregdummy)
#define PL_regendp		(thr->Tregendp)
#define PL_regeol		(thr->Tregeol)
#define PL_regexecp		(thr->Tregexecp)
#define PL_regflags		(thr->Tregflags)
#define PL_regindent		(thr->Tregindent)
#define PL_reginput		(thr->Treginput)
#define PL_reginterp_cnt	(thr->Treginterp_cnt)
#define PL_reglastparen		(thr->Treglastparen)
#define PL_regnarrate		(thr->Tregnarrate)
#define PL_regnaughty		(thr->Tregnaughty)
#define PL_regnpar		(thr->Tregnpar)
#define PL_regprecomp		(thr->Tregprecomp)
#define PL_regprev		(thr->Tregprev)
#define PL_regprogram		(thr->Tregprogram)
#define PL_regsawback		(thr->Tregsawback)
#define PL_regseen		(thr->Tregseen)
#define PL_regsize		(thr->Tregsize)
#define PL_regstartp		(thr->Tregstartp)
#define PL_regtill		(thr->Tregtill)
#define PL_regxend		(thr->Tregxend)
#define PL_restartop		(thr->Trestartop)
#define PL_retstack		(thr->Tretstack)
#define PL_retstack_ix		(thr->Tretstack_ix)
#define PL_retstack_max		(thr->Tretstack_max)
#define PL_rs			(thr->Trs)
#define PL_savestack		(thr->Tsavestack)
#define PL_savestack_ix		(thr->Tsavestack_ix)
#define PL_savestack_max	(thr->Tsavestack_max)
#define PL_scopestack		(thr->Tscopestack)
#define PL_scopestack_ix	(thr->Tscopestack_ix)
#define PL_scopestack_max	(thr->Tscopestack_max)
#define PL_screamfirst		(thr->Tscreamfirst)
#define PL_screamnext		(thr->Tscreamnext)
#define PL_secondgv		(thr->Tsecondgv)
#define PL_seen_evals		(thr->Tseen_evals)
#define PL_seen_zerolen		(thr->Tseen_zerolen)
#define PL_sortcop		(thr->Tsortcop)
#define PL_sortcxix		(thr->Tsortcxix)
#define PL_sortstash		(thr->Tsortstash)
#define PL_stack_base		(thr->Tstack_base)
#define PL_stack_max		(thr->Tstack_max)
#define PL_stack_sp		(thr->Tstack_sp)
#define PL_start_env		(thr->Tstart_env)
#define PL_statbuf		(thr->Tstatbuf)
#define PL_statcache		(thr->Tstatcache)
#define PL_statgv		(thr->Tstatgv)
#define PL_statname		(thr->Tstatname)
#define PL_tainted		(thr->Ttainted)
#define PL_timesbuf		(thr->Ttimesbuf)
#define PL_tmps_floor		(thr->Ttmps_floor)
#define PL_tmps_ix		(thr->Ttmps_ix)
#define PL_tmps_max		(thr->Ttmps_max)
#define PL_tmps_stack		(thr->Ttmps_stack)
#define PL_top_env		(thr->Ttop_env)
#define PL_toptarget		(thr->Ttoptarget)

#endif /* USE_THREADS */

#ifdef PERL_GLOBAL_STRUCT

#define PL_No			(PL_Vars.GNo)
#define PL_Yes			(PL_Vars.GYes)
#define PL_amagic_generation	(PL_Vars.Gamagic_generation)
#define PL_an			(PL_Vars.Gan)
#define PL_bufend		(PL_Vars.Gbufend)
#define PL_bufptr		(PL_Vars.Gbufptr)
#define PL_collation_ix		(PL_Vars.Gcollation_ix)
#define PL_collation_name	(PL_Vars.Gcollation_name)
#define PL_collation_standard	(PL_Vars.Gcollation_standard)
#define PL_collxfrm_base	(PL_Vars.Gcollxfrm_base)
#define PL_collxfrm_mult	(PL_Vars.Gcollxfrm_mult)
#define PL_cop_seqmax		(PL_Vars.Gcop_seqmax)
#define PL_cred_mutex		(PL_Vars.Gcred_mutex)
#define PL_cryptseen		(PL_Vars.Gcryptseen)
#define PL_cshlen		(PL_Vars.Gcshlen)
#define PL_cshname		(PL_Vars.Gcshname)
#define PL_curinterp		(PL_Vars.Gcurinterp)
#define PL_curthr		(PL_Vars.Gcurthr)
#define PL_debug		(PL_Vars.Gdebug)
#define PL_do_undump		(PL_Vars.Gdo_undump)
#define PL_egid			(PL_Vars.Gegid)
#define PL_error_count		(PL_Vars.Gerror_count)
#define PL_euid			(PL_Vars.Geuid)
#define PL_eval_cond		(PL_Vars.Geval_cond)
#define PL_eval_mutex		(PL_Vars.Geval_mutex)
#define PL_eval_owner		(PL_Vars.Geval_owner)
#define PL_evalseq		(PL_Vars.Gevalseq)
#define PL_expect		(PL_Vars.Gexpect)
#define PL_gid			(PL_Vars.Ggid)
#define PL_he_root		(PL_Vars.Ghe_root)
#define PL_hexdigit		(PL_Vars.Ghexdigit)
#define PL_hints		(PL_Vars.Ghints)
#define PL_in_my		(PL_Vars.Gin_my)
#define PL_in_my_stash		(PL_Vars.Gin_my_stash)
#define PL_last_lop		(PL_Vars.Glast_lop)
#define PL_last_lop_op		(PL_Vars.Glast_lop_op)
#define PL_last_uni		(PL_Vars.Glast_uni)
#define PL_lex_brackets		(PL_Vars.Glex_brackets)
#define PL_lex_brackstack	(PL_Vars.Glex_brackstack)
#define PL_lex_casemods		(PL_Vars.Glex_casemods)
#define PL_lex_casestack	(PL_Vars.Glex_casestack)
#define PL_lex_defer		(PL_Vars.Glex_defer)
#define PL_lex_dojoin		(PL_Vars.Glex_dojoin)
#define PL_lex_expect		(PL_Vars.Glex_expect)
#define PL_lex_fakebrack	(PL_Vars.Glex_fakebrack)
#define PL_lex_formbrack	(PL_Vars.Glex_formbrack)
#define PL_lex_inpat		(PL_Vars.Glex_inpat)
#define PL_lex_inwhat		(PL_Vars.Glex_inwhat)
#define PL_lex_op		(PL_Vars.Glex_op)
#define PL_lex_repl		(PL_Vars.Glex_repl)
#define PL_lex_starts		(PL_Vars.Glex_starts)
#define PL_lex_state		(PL_Vars.Glex_state)
#define PL_lex_stuff		(PL_Vars.Glex_stuff)
#define PL_linestr		(PL_Vars.Glinestr)
#define PL_malloc_mutex		(PL_Vars.Gmalloc_mutex)
#define PL_max_intro_pending	(PL_Vars.Gmax_intro_pending)
#define PL_maxo			(PL_Vars.Gmaxo)
#define PL_min_intro_pending	(PL_Vars.Gmin_intro_pending)
#define PL_multi_close		(PL_Vars.Gmulti_close)
#define PL_multi_end		(PL_Vars.Gmulti_end)
#define PL_multi_open		(PL_Vars.Gmulti_open)
#define PL_multi_start		(PL_Vars.Gmulti_start)
#define PL_na			(PL_Vars.Gna)
#define PL_nexttoke		(PL_Vars.Gnexttoke)
#define PL_nexttype		(PL_Vars.Gnexttype)
#define PL_nextval		(PL_Vars.Gnextval)
#define PL_nice_chunk		(PL_Vars.Gnice_chunk)
#define PL_nice_chunk_size	(PL_Vars.Gnice_chunk_size)
#define PL_ninterps		(PL_Vars.Gninterps)
#define PL_nomemok		(PL_Vars.Gnomemok)
#define PL_nthreads		(PL_Vars.Gnthreads)
#define PL_nthreads_cond	(PL_Vars.Gnthreads_cond)
#define PL_numeric_local	(PL_Vars.Gnumeric_local)
#define PL_numeric_name		(PL_Vars.Gnumeric_name)
#define PL_numeric_standard	(PL_Vars.Gnumeric_standard)
#define PL_oldbufptr		(PL_Vars.Goldbufptr)
#define PL_oldoldbufptr		(PL_Vars.Goldoldbufptr)
#define PL_op_seqmax		(PL_Vars.Gop_seqmax)
#define PL_origalen		(PL_Vars.Gorigalen)
#define PL_origenviron		(PL_Vars.Gorigenviron)
#define PL_osname		(PL_Vars.Gosname)
#define PL_pad_reset_pending	(PL_Vars.Gpad_reset_pending)
#define PL_padix		(PL_Vars.Gpadix)
#define PL_padix_floor		(PL_Vars.Gpadix_floor)
#define PL_patleave		(PL_Vars.Gpatleave)
#define PL_pidstatus		(PL_Vars.Gpidstatus)
#define PL_runops		(PL_Vars.Grunops)
#define PL_sh_path		(PL_Vars.Gsh_path)
#define PL_sighandlerp		(PL_Vars.Gsighandlerp)
#define PL_specialsv_list	(PL_Vars.Gspecialsv_list)
#define PL_subline		(PL_Vars.Gsubline)
#define PL_subname		(PL_Vars.Gsubname)
#define PL_sv_mutex		(PL_Vars.Gsv_mutex)
#define PL_sv_no		(PL_Vars.Gsv_no)
#define PL_sv_undef		(PL_Vars.Gsv_undef)
#define PL_sv_yes		(PL_Vars.Gsv_yes)
#define PL_svref_mutex		(PL_Vars.Gsvref_mutex)
#define PL_thisexpr		(PL_Vars.Gthisexpr)
#define PL_thr_key		(PL_Vars.Gthr_key)
#define PL_threads_mutex	(PL_Vars.Gthreads_mutex)
#define PL_threadsv_names	(PL_Vars.Gthreadsv_names)
#define PL_tokenbuf		(PL_Vars.Gtokenbuf)
#define PL_uid			(PL_Vars.Guid)
#define PL_xiv_arenaroot	(PL_Vars.Gxiv_arenaroot)
#define PL_xiv_root		(PL_Vars.Gxiv_root)
#define PL_xnv_root		(PL_Vars.Gxnv_root)
#define PL_xpv_root		(PL_Vars.Gxpv_root)
#define PL_xrv_root		(PL_Vars.Gxrv_root)

#else /* !PERL_GLOBAL_STRUCT */

#define PL_GNo			PL_No
#define PL_GYes			PL_Yes
#define PL_Gamagic_generation	PL_amagic_generation
#define PL_Gan			PL_an
#define PL_Gbufend		PL_bufend
#define PL_Gbufptr		PL_bufptr
#define PL_Gcollation_ix	PL_collation_ix
#define PL_Gcollation_name	PL_collation_name
#define PL_Gcollation_standard	PL_collation_standard
#define PL_Gcollxfrm_base	PL_collxfrm_base
#define PL_Gcollxfrm_mult	PL_collxfrm_mult
#define PL_Gcop_seqmax		PL_cop_seqmax
#define PL_Gcred_mutex		PL_cred_mutex
#define PL_Gcryptseen		PL_cryptseen
#define PL_Gcshlen		PL_cshlen
#define PL_Gcshname		PL_cshname
#define PL_Gcurinterp		PL_curinterp
#define PL_Gcurthr		PL_curthr
#define PL_Gdebug		PL_debug
#define PL_Gdo_undump		PL_do_undump
#define PL_Gegid		PL_egid
#define PL_Gerror_count		PL_error_count
#define PL_Geuid		PL_euid
#define PL_Geval_cond		PL_eval_cond
#define PL_Geval_mutex		PL_eval_mutex
#define PL_Geval_owner		PL_eval_owner
#define PL_Gevalseq		PL_evalseq
#define PL_Gexpect		PL_expect
#define PL_Ggid			PL_gid
#define PL_Ghe_root		PL_he_root
#define PL_Ghexdigit		PL_hexdigit
#define PL_Ghints		PL_hints
#define PL_Gin_my		PL_in_my
#define PL_Gin_my_stash		PL_in_my_stash
#define PL_Glast_lop		PL_last_lop
#define PL_Glast_lop_op		PL_last_lop_op
#define PL_Glast_uni		PL_last_uni
#define PL_Glex_brackets	PL_lex_brackets
#define PL_Glex_brackstack	PL_lex_brackstack
#define PL_Glex_casemods	PL_lex_casemods
#define PL_Glex_casestack	PL_lex_casestack
#define PL_Glex_defer		PL_lex_defer
#define PL_Glex_dojoin		PL_lex_dojoin
#define PL_Glex_expect		PL_lex_expect
#define PL_Glex_fakebrack	PL_lex_fakebrack
#define PL_Glex_formbrack	PL_lex_formbrack
#define PL_Glex_inpat		PL_lex_inpat
#define PL_Glex_inwhat		PL_lex_inwhat
#define PL_Glex_op		PL_lex_op
#define PL_Glex_repl		PL_lex_repl
#define PL_Glex_starts		PL_lex_starts
#define PL_Glex_state		PL_lex_state
#define PL_Glex_stuff		PL_lex_stuff
#define PL_Glinestr		PL_linestr
#define PL_Gmalloc_mutex	PL_malloc_mutex
#define PL_Gmax_intro_pending	PL_max_intro_pending
#define PL_Gmaxo		PL_maxo
#define PL_Gmin_intro_pending	PL_min_intro_pending
#define PL_Gmulti_close		PL_multi_close
#define PL_Gmulti_end		PL_multi_end
#define PL_Gmulti_open		PL_multi_open
#define PL_Gmulti_start		PL_multi_start
#define PL_Gna			PL_na
#define PL_Gnexttoke		PL_nexttoke
#define PL_Gnexttype		PL_nexttype
#define PL_Gnextval		PL_nextval
#define PL_Gnice_chunk		PL_nice_chunk
#define PL_Gnice_chunk_size	PL_nice_chunk_size
#define PL_Gninterps		PL_ninterps
#define PL_Gnomemok		PL_nomemok
#define PL_Gnthreads		PL_nthreads
#define PL_Gnthreads_cond	PL_nthreads_cond
#define PL_Gnumeric_local	PL_numeric_local
#define PL_Gnumeric_name	PL_numeric_name
#define PL_Gnumeric_standard	PL_numeric_standard
#define PL_Goldbufptr		PL_oldbufptr
#define PL_Goldoldbufptr	PL_oldoldbufptr
#define PL_Gop_seqmax		PL_op_seqmax
#define PL_Gorigalen		PL_origalen
#define PL_Gorigenviron		PL_origenviron
#define PL_Gosname		PL_osname
#define PL_Gpad_reset_pending	PL_pad_reset_pending
#define PL_Gpadix		PL_padix
#define PL_Gpadix_floor		PL_padix_floor
#define PL_Gpatleave		PL_patleave
#define PL_Gpidstatus		PL_pidstatus
#define PL_Grunops		PL_runops
#define PL_Gsh_path		PL_sh_path
#define PL_Gsighandlerp		PL_sighandlerp
#define PL_Gspecialsv_list	PL_specialsv_list
#define PL_Gsubline		PL_subline
#define PL_Gsubname		PL_subname
#define PL_Gsv_mutex		PL_sv_mutex
#define PL_Gsv_no		PL_sv_no
#define PL_Gsv_undef		PL_sv_undef
#define PL_Gsv_yes		PL_sv_yes
#define PL_Gsvref_mutex		PL_svref_mutex
#define PL_Gthisexpr		PL_thisexpr
#define PL_Gthr_key		PL_thr_key
#define PL_Gthreads_mutex	PL_threads_mutex
#define PL_Gthreadsv_names	PL_threadsv_names
#define PL_Gtokenbuf		PL_tokenbuf
#define PL_Guid			PL_uid
#define PL_Gxiv_arenaroot	PL_xiv_arenaroot
#define PL_Gxiv_root		PL_xiv_root
#define PL_Gxnv_root		PL_xnv_root
#define PL_Gxpv_root		PL_xpv_root
#define PL_Gxrv_root		PL_xrv_root

#ifdef EMBED


#endif /* EMBED */
#endif /* PERL_GLOBAL_STRUCT */


#ifndef MIN_PERL_DEFINE  

#define DBsingle		PL_DBsingle
#define DBsub			PL_DBsub
#define compiling		PL_compiling
#define curcop			PL_curcop
#define curstash		PL_curstash
#define debstash		PL_debstash
#define defgv			PL_defgv
#define diehook			PL_diehook
#define dirty			PL_dirty
#define dowarn			PL_dowarn
#define errgv			PL_errgv
#define na			PL_na
#define perl_destruct_level	PL_perl_destruct_level
#define perldb			PL_perldb
#define rsfp			PL_rsfp
#define rsfp_filters		PL_rsfp_filters
#define stack_base		PL_stack_base
#define stack_sp		PL_stack_sp
#define stdingv			PL_stdingv
#define sv_arenaroot		PL_sv_arenaroot
#define sv_no			PL_sv_no
#define sv_undef		PL_sv_undef
#define sv_yes			PL_sv_yes
#define tainted			PL_tainted
#define tainting		PL_tainting

#endif /* MIN_PERL_DEFINE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\embed.h ===
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from global.sym, intrpvar.h,
   and thrdvar.h.  Any changes made here will be lost!
*/

/* (Doing namespace management portably in C is really gross.) */

/*  EMBED has no run-time penalty, but helps keep the Perl namespace
    from colliding with that used by other libraries pulled in
    by extensions or by embedding perl.  Allow a cc -DNO_EMBED
    override, however, to keep binary compatability with previous
    versions of perl.
*/
#ifndef NO_EMBED
#  define EMBED 1 
#endif

/* Hide global symbols? */

#ifdef EMBED

#define AMG_names		Perl_AMG_names
#define Error			Perl_Error
#define Gv_AMupdate		Perl_Gv_AMupdate
#define abs_amg			Perl_abs_amg
#define add_amg			Perl_add_amg
#define add_ass_amg		Perl_add_ass_amg
#define additem			Perl_additem
#define amagic_call		Perl_amagic_call
#define append_elem		Perl_append_elem
#define append_list		Perl_append_list
#define apply			Perl_apply
#define assertref		Perl_assertref
#define atan2_amg		Perl_atan2_amg
#define av_clear		Perl_av_clear
#define av_extend		Perl_av_extend
#define av_fake			Perl_av_fake
#define av_fetch		Perl_av_fetch
#define av_fill			Perl_av_fill
#define av_len			Perl_av_len
#define av_make			Perl_av_make
#define av_pop			Perl_av_pop
#define av_push			Perl_av_push
#define av_reify		Perl_av_reify
#define av_shift		Perl_av_shift
#define av_store		Perl_av_store
#define av_undef		Perl_av_undef
#define av_unshift		Perl_av_unshift
#define avhv_exists_ent		Perl_avhv_exists_ent
#define avhv_fetch_ent		Perl_avhv_fetch_ent
#define avhv_iternext		Perl_avhv_iternext
#define avhv_iterval		Perl_avhv_iterval
#define avhv_keys		Perl_avhv_keys
#define band_amg		Perl_band_amg
#define bind_match		Perl_bind_match
#define block_end		Perl_block_end
#define block_gimme		Perl_block_gimme
#define block_start		Perl_block_start
#define block_type		Perl_block_type
#define bool__amg		Perl_bool__amg
#define boot_core_UNIVERSAL	Perl_boot_core_UNIVERSAL
#define bor_amg			Perl_bor_amg
#define bset_obj_store		Perl_bset_obj_store
#define bxor_amg		Perl_bxor_amg
#define byterun			Perl_byterun
#define call_list		Perl_call_list
#define cando			Perl_cando
#define cast_ulong		Perl_cast_ulong
#define check			Perl_check
#define check_uni		Perl_check_uni
#define checkcomma		Perl_checkcomma
#define ck_aelem		Perl_ck_aelem
#define ck_anoncode		Perl_ck_anoncode
#define ck_bitop		Perl_ck_bitop
#define ck_concat		Perl_ck_concat
#define ck_delete		Perl_ck_delete
#define ck_eof			Perl_ck_eof
#define ck_eval			Perl_ck_eval
#define ck_exec			Perl_ck_exec
#define ck_exists		Perl_ck_exists
#define ck_ftst			Perl_ck_ftst
#define ck_fun			Perl_ck_fun
#define ck_fun_locale		Perl_ck_fun_locale
#define ck_glob			Perl_ck_glob
#define ck_grep			Perl_ck_grep
#define ck_gvconst		Perl_ck_gvconst
#define ck_index		Perl_ck_index
#define ck_lengthconst		Perl_ck_lengthconst
#define ck_lfun			Perl_ck_lfun
#define ck_listiob		Perl_ck_listiob
#define ck_match		Perl_ck_match
#define ck_null			Perl_ck_null
#define ck_repeat		Perl_ck_repeat
#define ck_require		Perl_ck_require
#define ck_retarget		Perl_ck_retarget
#define ck_rfun			Perl_ck_rfun
#define ck_rvconst		Perl_ck_rvconst
#define ck_scmp			Perl_ck_scmp
#define ck_select		Perl_ck_select
#define ck_shift		Perl_ck_shift
#define ck_sort			Perl_ck_sort
#define ck_spair		Perl_ck_spair
#define ck_split		Perl_ck_split
#define ck_subr			Perl_ck_subr
#define ck_svconst		Perl_ck_svconst
#define ck_trunc		Perl_ck_trunc
#define compl_amg		Perl_compl_amg
#define concat_amg		Perl_concat_amg
#define concat_ass_amg		Perl_concat_ass_amg
#define condpair_magic		Perl_condpair_magic
#define convert			Perl_convert
#define cos_amg			Perl_cos_amg
#define croak			Perl_croak
#define cv_ckproto		Perl_cv_ckproto
#define cv_clone		Perl_cv_clone
#define cv_const_sv		Perl_cv_const_sv
#define cv_undef		Perl_cv_undef
#define cx_dump			Perl_cx_dump
#define cxinc			Perl_cxinc
#define dc			Perl_dc
#define deb			Perl_deb
#define deb_growlevel		Perl_deb_growlevel
#define debop			Perl_debop
#define debprofdump		Perl_debprofdump
#define debstack		Perl_debstack
#define debstackptrs		Perl_debstackptrs
#define dec_amg			Perl_dec_amg
#define delimcpy		Perl_delimcpy
#define deprecate		Perl_deprecate
#define di			Perl_di
#define die			Perl_die
#define die_where		Perl_die_where
#define div_amg			Perl_div_amg
#define div_ass_amg		Perl_div_ass_amg
#define do_aexec		Perl_do_aexec
#define do_binmode		Perl_do_binmode
#define do_chomp		Perl_do_chomp
#define do_chop			Perl_do_chop
#define do_close		Perl_do_close
#define do_eof			Perl_do_eof
#define do_exec			Perl_do_exec
#define do_execfree		Perl_do_execfree
#define do_ipcctl		Perl_do_ipcctl
#define do_ipcget		Perl_do_ipcget
#define do_join			Perl_do_join
#define do_kv			Perl_do_kv
#define do_msgrcv		Perl_do_msgrcv
#define do_msgsnd		Perl_do_msgsnd
#define do_open			Perl_do_open
#define do_pipe			Perl_do_pipe
#define do_print		Perl_do_print
#define do_readline		Perl_do_readline
#define do_seek			Perl_do_seek
#define do_semop		Perl_do_semop
#define do_shmio		Perl_do_shmio
#define do_sprintf		Perl_do_sprintf
#define do_sysseek		Perl_do_sysseek
#define do_tell			Perl_do_tell
#define do_trans		Perl_do_trans
#define do_vecset		Perl_do_vecset
#define do_vop			Perl_do_vop
#define dofile			Perl_dofile
#define dofindlabel		Perl_dofindlabel
#define dopoptoeval		Perl_dopoptoeval
#define dounwind		Perl_dounwind
#define dowantarray		Perl_dowantarray
#define ds			Perl_ds
#define dump_all		Perl_dump_all
#define dump_eval		Perl_dump_eval
#define dump_fds		Perl_dump_fds
#define dump_form		Perl_dump_form
#define dump_gv			Perl_dump_gv
#define dump_mstats		Perl_dump_mstats
#define dump_op			Perl_dump_op
#define dump_packsubs		Perl_dump_packsubs
#define dump_pm			Perl_dump_pm
#define dump_sub		Perl_dump_sub
#define eq_amg			Perl_eq_amg
#define exp_amg			Perl_exp_amg
#define expectterm		Perl_expectterm
#define fallback_amg		Perl_fallback_amg
#define fbm_compile		Perl_fbm_compile
#define fbm_instr		Perl_fbm_instr
#define fetch_gv		Perl_fetch_gv
#define fetch_io		Perl_fetch_io
#define filter_add		Perl_filter_add
#define filter_del		Perl_filter_del
#define filter_read		Perl_filter_read
#define find_script		Perl_find_script
#define find_threadsv		Perl_find_threadsv
#define fold			Perl_fold
#define fold_constants		Perl_fold_constants
#define fold_locale		Perl_fold_locale
#define force_ident		Perl_force_ident
#define force_list		Perl_force_list
#define force_next		Perl_force_next
#define force_word		Perl_force_word
#define form			Perl_form
#define free_tmps		Perl_free_tmps
#define freq			Perl_freq
#define ge_amg			Perl_ge_amg
#define gen_constant_list	Perl_gen_constant_list
#define get_no_modify		Perl_get_no_modify
#define get_op_descs		Perl_get_op_descs
#define get_op_names		Perl_get_op_names
#define get_opargs		Perl_get_opargs
#define get_specialsv_list	Perl_get_specialsv_list
#define get_vtbl		Perl_get_vtbl
#define gp_free			Perl_gp_free
#define gp_ref			Perl_gp_ref
#define gt_amg			Perl_gt_amg
#define gv_AVadd		Perl_gv_AVadd
#define gv_HVadd		Perl_gv_HVadd
#define gv_IOadd		Perl_gv_IOadd
#define gv_autoload4		Perl_gv_autoload4
#define gv_check		Perl_gv_check
#define gv_efullname		Perl_gv_efullname
#define gv_efullname3		Perl_gv_efullname3
#define gv_fetchfile		Perl_gv_fetchfile
#define gv_fetchmeth		Perl_gv_fetchmeth
#define gv_fetchmethod		Perl_gv_fetchmethod
#define gv_fetchmethod_autoload	Perl_gv_fetchmethod_autoload
#define gv_fetchpv		Perl_gv_fetchpv
#define gv_fullname		Perl_gv_fullname
#define gv_fullname3		Perl_gv_fullname3
#define gv_init			Perl_gv_init
#define gv_stashpv		Perl_gv_stashpv
#define gv_stashpvn		Perl_gv_stashpvn
#define gv_stashsv		Perl_gv_stashsv
#define hv_clear		Perl_hv_clear
#define hv_delayfree_ent	Perl_hv_delayfree_ent
#define hv_delete		Perl_hv_delete
#define hv_delete_ent		Perl_hv_delete_ent
#define hv_exists		Perl_hv_exists
#define hv_exists_ent		Perl_hv_exists_ent
#define hv_fetch		Perl_hv_fetch
#define hv_fetch_ent		Perl_hv_fetch_ent
#define hv_free_ent		Perl_hv_free_ent
#define hv_iterinit		Perl_hv_iterinit
#define hv_iterkey		Perl_hv_iterkey
#define hv_iterkeysv		Perl_hv_iterkeysv
#define hv_iternext		Perl_hv_iternext
#define hv_iternextsv		Perl_hv_iternextsv
#define hv_iterval		Perl_hv_iterval
#define hv_ksplit		Perl_hv_ksplit
#define hv_magic		Perl_hv_magic
#define hv_stashpv		Perl_hv_stashpv
#define hv_store		Perl_hv_store
#define hv_store_ent		Perl_hv_store_ent
#define hv_undef		Perl_hv_undef
#define ibcmp			Perl_ibcmp
#define ibcmp_locale		Perl_ibcmp_locale
#define inc_amg			Perl_inc_amg
#define ingroup			Perl_ingroup
#define init_stacks		Perl_init_stacks
#define init_thread_intern	Perl_init_thread_intern
#define instr			Perl_instr
#define intro_my		Perl_intro_my
#define intuit_more		Perl_intuit_more
#define invert			Perl_invert
#define io_close		Perl_io_close
#define jmaybe			Perl_jmaybe
#define keyword			Perl_keyword
#define know_next		Perl_know_next
#define le_amg			Perl_le_amg
#define leave_scope		Perl_leave_scope
#define lex_end			Perl_lex_end
#define lex_start		Perl_lex_start
#define linklist		Perl_linklist
#define list			Perl_list
#define listkids		Perl_listkids
#define localize		Perl_localize
#define log_amg			Perl_log_amg
#define looks_like_number	Perl_looks_like_number
#define lshift_amg		Perl_lshift_amg
#define lshift_ass_amg		Perl_lshift_ass_amg
#define lt_amg			Perl_lt_amg
#define magic_clear_all_env	Perl_magic_clear_all_env
#define magic_clearenv		Perl_magic_clearenv
#define magic_clearpack		Perl_magic_clearpack
#define magic_clearsig		Perl_magic_clearsig
#define magic_existspack	Perl_magic_existspack
#define magic_freeregexp	Perl_magic_freeregexp
#define magic_get		Perl_magic_get
#define magic_getarylen		Perl_magic_getarylen
#define magic_getdefelem	Perl_magic_getdefelem
#define magic_getglob		Perl_magic_getglob
#define magic_getnkeys		Perl_magic_getnkeys
#define magic_getpack		Perl_magic_getpack
#define magic_getpos		Perl_magic_getpos
#define magic_getsig		Perl_magic_getsig
#define magic_getsubstr		Perl_magic_getsubstr
#define magic_gettaint		Perl_magic_gettaint
#define magic_getuvar		Perl_magic_getuvar
#define magic_getvec		Perl_magic_getvec
#define magic_len		Perl_magic_len
#define magic_mutexfree		Perl_magic_mutexfree
#define magic_nextpack		Perl_magic_nextpack
#define magic_set		Perl_magic_set
#define magic_set_all_env	Perl_magic_set_all_env
#define magic_setamagic		Perl_magic_setamagic
#define magic_setarylen		Perl_magic_setarylen
#define magic_setbm		Perl_magic_setbm
#define magic_setcollxfrm	Perl_magic_setcollxfrm
#define magic_setdbline		Perl_magic_setdbline
#define magic_setdefelem	Perl_magic_setdefelem
#define magic_setenv		Perl_magic_setenv
#define magic_setfm		Perl_magic_setfm
#define magic_setglob		Perl_magic_setglob
#define magic_setisa		Perl_magic_setisa
#define magic_setmglob		Perl_magic_setmglob
#define magic_setnkeys		Perl_magic_setnkeys
#define magic_setpack		Perl_magic_setpack
#define magic_setpos		Perl_magic_setpos
#define magic_setsig		Perl_magic_setsig
#define magic_setsubstr		Perl_magic_setsubstr
#define magic_settaint		Perl_magic_settaint
#define magic_setuvar		Perl_magic_setuvar
#define magic_setvec		Perl_magic_setvec
#define magic_sizepack		Perl_magic_sizepack
#define magic_wipepack		Perl_magic_wipepack
#define magicname		Perl_magicname
#define malloced_size		Perl_malloced_size
#define markstack_grow		Perl_markstack_grow
#define mem_collxfrm		Perl_mem_collxfrm
#define mess			Perl_mess
#define mg_clear		Perl_mg_clear
#define mg_copy			Perl_mg_copy
#define mg_find			Perl_mg_find
#define mg_free			Perl_mg_free
#define mg_get			Perl_mg_get
#define mg_length		Perl_mg_length
#define mg_magical		Perl_mg_magical
#define mg_set			Perl_mg_set
#define mg_size			Perl_mg_size
#define mod			Perl_mod
#define mod_amg			Perl_mod_amg
#define mod_ass_amg		Perl_mod_ass_amg
#define modkids			Perl_modkids
#define moreswitches		Perl_moreswitches
#define mstats			Perl_mstats
#define mult_amg		Perl_mult_amg
#define mult_ass_amg		Perl_mult_ass_amg
#define my			Perl_my
#define my_bcopy		Perl_my_bcopy
#define my_bzero		Perl_my_bzero
#define my_chsize		Perl_my_chsize
#define my_exit			Perl_my_exit
#define my_failure_exit		Perl_my_failure_exit
#define my_htonl		Perl_my_htonl
#define my_lstat		Perl_my_lstat
#define my_memcmp		Perl_my_memcmp
#define my_memset		Perl_my_memset
#define my_ntohl		Perl_my_ntohl
#define my_pclose		Perl_my_pclose
#define my_popen		Perl_my_popen
#define my_setenv		Perl_my_setenv
#define my_stat			Perl_my_stat
#define my_swap			Perl_my_swap
#define my_unexec		Perl_my_unexec
#define ncmp_amg		Perl_ncmp_amg
#define ne_amg			Perl_ne_amg
#define neg_amg			Perl_neg_amg
#define newANONHASH		Perl_newANONHASH
#define newANONLIST		Perl_newANONLIST
#define newANONSUB		Perl_newANONSUB
#define newASSIGNOP		Perl_newASSIGNOP
#define newAV			Perl_newAV
#define newAVREF		Perl_newAVREF
#define newBINOP		Perl_newBINOP
#define newCONDOP		Perl_newCONDOP
#define newCONSTSUB		Perl_newCONSTSUB
#define newCVREF		Perl_newCVREF
#define newFORM			Perl_newFORM
#define newFOROP		Perl_newFOROP
#define newGVOP			Perl_newGVOP
#define newGVREF		Perl_newGVREF
#define newGVgen		Perl_newGVgen
#define newHV			Perl_newHV
#define newHVREF		Perl_newHVREF
#define newHVhv			Perl_newHVhv
#define newIO			Perl_newIO
#define newLISTOP		Perl_newLISTOP
#define newLOGOP		Perl_newLOGOP
#define newLOOPEX		Perl_newLOOPEX
#define newLOOPOP		Perl_newLOOPOP
#define newNULLLIST		Perl_newNULLLIST
#define newOP			Perl_newOP
#define newPMOP			Perl_newPMOP
#define newPROG			Perl_newPROG
#define newPVOP			Perl_newPVOP
#define newRANGE		Perl_newRANGE
#define newRV			Perl_newRV
#define newRV_noinc		Perl_newRV_noinc
#define newSLICEOP		Perl_newSLICEOP
#define newSTATEOP		Perl_newSTATEOP
#define newSUB			Perl_newSUB
#define newSV			Perl_newSV
#define newSVOP			Perl_newSVOP
#define newSVREF		Perl_newSVREF
#define newSViv			Perl_newSViv
#define newSVnv			Perl_newSVnv
#define newSVpv			Perl_newSVpv
#define newSVpvf		Perl_newSVpvf
#define newSVpvn		Perl_newSVpvn
#define newSVrv			Perl_newSVrv
#define newSVsv			Perl_newSVsv
#define newUNOP			Perl_newUNOP
#define newWHILEOP		Perl_newWHILEOP
#define newXS			Perl_newXS
#define newXSUB			Perl_newXSUB
#define new_stackinfo		Perl_new_stackinfo
#define new_struct_thread	Perl_new_struct_thread
#define nextargv		Perl_nextargv
#define ninstr			Perl_ninstr
#define no_aelem		Perl_no_aelem
#define no_dir_func		Perl_no_dir_func
#define no_bareword_allowed	Perl_no_bareword_allowed
#define no_fh_allowed		Perl_no_fh_allowed
#define no_func			Perl_no_func
#define no_helem		Perl_no_helem
#define no_mem			Perl_no_mem
#define no_modify		Perl_no_modify
#define no_myglob		Perl_no_myglob
#define no_op			Perl_no_op
#define no_security		Perl_no_security
#define no_sock_func		Perl_no_sock_func
#define no_symref		Perl_no_symref
#define no_usym			Perl_no_usym
#define no_wrongref		Perl_no_wrongref
#define nointrp			Perl_nointrp
#define nomem			Perl_nomem
#define nomethod_amg		Perl_nomethod_amg
#define not_amg			Perl_not_amg
#define numer_amg		Perl_numer_amg
#define oopsAV			Perl_oopsAV
#define oopsCV			Perl_oopsCV
#define oopsHV			Perl_oopsHV
#define op_const_sv		Perl_op_const_sv
#define op_desc			Perl_op_desc
#define op_free			Perl_op_free
#define op_name			Perl_op_name
#define opargs			Perl_opargs
#define package			Perl_package
#define pad_alloc		Perl_pad_alloc
#define pad_allocmy		Perl_pad_allocmy
#define pad_findmy		Perl_pad_findmy
#define pad_free		Perl_pad_free
#define pad_leavemy		Perl_pad_leavemy
#define pad_reset		Perl_pad_reset
#define pad_sv			Perl_pad_sv
#define pad_swipe		Perl_pad_swipe
#define peep			Perl_peep
#define pidgone			Perl_pidgone
#define pmflag			Perl_pmflag
#define pmruntime		Perl_pmruntime
#define pmtrans			Perl_pmtrans
#define pop_return		Perl_pop_return
#define pop_scope		Perl_pop_scope
#define pow_amg			Perl_pow_amg
#define pow_ass_amg		Perl_pow_ass_amg
#define pp_aassign		Perl_pp_aassign
#define pp_abs			Perl_pp_abs
#define pp_accept		Perl_pp_accept
#define pp_add			Perl_pp_add
#define pp_aelem		Perl_pp_aelem
#define pp_aelemfast		Perl_pp_aelemfast
#define pp_alarm		Perl_pp_alarm
#define pp_and			Perl_pp_and
#define pp_andassign		Perl_pp_andassign
#define pp_anoncode		Perl_pp_anoncode
#define pp_anonhash		Perl_pp_anonhash
#define pp_anonlist		Perl_pp_anonlist
#define pp_aslice		Perl_pp_aslice
#define pp_atan2		Perl_pp_atan2
#define pp_av2arylen		Perl_pp_av2arylen
#define pp_backtick		Perl_pp_backtick
#define pp_bind			Perl_pp_bind
#define pp_binmode		Perl_pp_binmode
#define pp_bit_and		Perl_pp_bit_and
#define pp_bit_or		Perl_pp_bit_or
#define pp_bit_xor		Perl_pp_bit_xor
#define pp_bless		Perl_pp_bless
#define pp_caller		Perl_pp_caller
#define pp_chdir		Perl_pp_chdir
#define pp_chmod		Perl_pp_chmod
#define pp_chomp		Perl_pp_chomp
#define pp_chop			Perl_pp_chop
#define pp_chown		Perl_pp_chown
#define pp_chr			Perl_pp_chr
#define pp_chroot		Perl_pp_chroot
#define pp_close		Perl_pp_close
#define pp_closedir		Perl_pp_closedir
#define pp_complement		Perl_pp_complement
#define pp_concat		Perl_pp_concat
#define pp_cond_expr		Perl_pp_cond_expr
#define pp_connect		Perl_pp_connect
#define pp_const		Perl_pp_const
#define pp_cos			Perl_pp_cos
#define pp_crypt		Perl_pp_crypt
#define pp_cswitch		Perl_pp_cswitch
#define pp_dbmclose		Perl_pp_dbmclose
#define pp_dbmopen		Perl_pp_dbmopen
#define pp_dbstate		Perl_pp_dbstate
#define pp_defined		Perl_pp_defined
#define pp_delete		Perl_pp_delete
#define pp_die			Perl_pp_die
#define pp_divide		Perl_pp_divide
#define pp_dofile		Perl_pp_dofile
#define pp_dump			Perl_pp_dump
#define pp_each			Perl_pp_each
#define pp_egrent		Perl_pp_egrent
#define pp_ehostent		Perl_pp_ehostent
#define pp_enetent		Perl_pp_enetent
#define pp_enter		Perl_pp_enter
#define pp_entereval		Perl_pp_entereval
#define pp_enteriter		Perl_pp_enteriter
#define pp_enterloop		Perl_pp_enterloop
#define pp_entersub		Perl_pp_entersub
#define pp_entersubr		Perl_pp_entersubr
#define pp_entertry		Perl_pp_entertry
#define pp_enterwrite		Perl_pp_enterwrite
#define pp_eof			Perl_pp_eof
#define pp_eprotoent		Perl_pp_eprotoent
#define pp_epwent		Perl_pp_epwent
#define pp_eq			Perl_pp_eq
#define pp_eservent		Perl_pp_eservent
#define pp_evalonce		Perl_pp_evalonce
#define pp_exec			Perl_pp_exec
#define pp_exists		Perl_pp_exists
#define pp_exit			Perl_pp_exit
#define pp_exp			Perl_pp_exp
#define pp_fcntl		Perl_pp_fcntl
#define pp_fileno		Perl_pp_fileno
#define pp_flip			Perl_pp_flip
#define pp_flock		Perl_pp_flock
#define pp_flop			Perl_pp_flop
#define pp_fork			Perl_pp_fork
#define pp_formline		Perl_pp_formline
#define pp_ftatime		Perl_pp_ftatime
#define pp_ftbinary		Perl_pp_ftbinary
#define pp_ftblk		Perl_pp_ftblk
#define pp_ftchr		Perl_pp_ftchr
#define pp_ftctime		Perl_pp_ftctime
#define pp_ftdir		Perl_pp_ftdir
#define pp_fteexec		Perl_pp_fteexec
#define pp_fteowned		Perl_pp_fteowned
#define pp_fteread		Perl_pp_fteread
#define pp_ftewrite		Perl_pp_ftewrite
#define pp_ftfile		Perl_pp_ftfile
#define pp_ftis			Perl_pp_ftis
#define pp_ftlink		Perl_pp_ftlink
#define pp_ftmtime		Perl_pp_ftmtime
#define pp_ftpipe		Perl_pp_ftpipe
#define pp_ftrexec		Perl_pp_ftrexec
#define pp_ftrowned		Perl_pp_ftrowned
#define pp_ftrread		Perl_pp_ftrread
#define pp_ftrwrite		Perl_pp_ftrwrite
#define pp_ftsgid		Perl_pp_ftsgid
#define pp_ftsize		Perl_pp_ftsize
#define pp_ftsock		Perl_pp_ftsock
#define pp_ftsuid		Perl_pp_ftsuid
#define pp_ftsvtx		Perl_pp_ftsvtx
#define pp_fttext		Perl_pp_fttext
#define pp_fttty		Perl_pp_fttty
#define pp_ftzero		Perl_pp_ftzero
#define pp_ge			Perl_pp_ge
#define pp_gelem		Perl_pp_gelem
#define pp_getc			Perl_pp_getc
#define pp_getlogin		Perl_pp_getlogin
#define pp_getpeername		Perl_pp_getpeername
#define pp_getpgrp		Perl_pp_getpgrp
#define pp_getppid		Perl_pp_getppid
#define pp_getpriority		Perl_pp_getpriority
#define pp_getsockname		Perl_pp_getsockname
#define pp_ggrent		Perl_pp_ggrent
#define pp_ggrgid		Perl_pp_ggrgid
#define pp_ggrnam		Perl_pp_ggrnam
#define pp_ghbyaddr		Perl_pp_ghbyaddr
#define pp_ghbyname		Perl_pp_ghbyname
#define pp_ghostent		Perl_pp_ghostent
#define pp_glob			Perl_pp_glob
#define pp_gmtime		Perl_pp_gmtime
#define pp_gnbyaddr		Perl_pp_gnbyaddr
#define pp_gnbyname		Perl_pp_gnbyname
#define pp_gnetent		Perl_pp_gnetent
#define pp_goto			Perl_pp_goto
#define pp_gpbyname		Perl_pp_gpbyname
#define pp_gpbynumber		Perl_pp_gpbynumber
#define pp_gprotoent		Perl_pp_gprotoent
#define pp_gpwent		Perl_pp_gpwent
#define pp_gpwnam		Perl_pp_gpwnam
#define pp_gpwuid		Perl_pp_gpwuid
#define pp_grepstart		Perl_pp_grepstart
#define pp_grepwhile		Perl_pp_grepwhile
#define pp_gsbyname		Perl_pp_gsbyname
#define pp_gsbyport		Perl_pp_gsbyport
#define pp_gservent		Perl_pp_gservent
#define pp_gsockopt		Perl_pp_gsockopt
#define pp_gt			Perl_pp_gt
#define pp_gv			Perl_pp_gv
#define pp_gvsv			Perl_pp_gvsv
#define pp_helem		Perl_pp_helem
#define pp_hex			Perl_pp_hex
#define pp_hslice		Perl_pp_hslice
#define pp_i_add		Perl_pp_i_add
#define pp_i_divide		Perl_pp_i_divide
#define pp_i_eq			Perl_pp_i_eq
#define pp_i_ge			Perl_pp_i_ge
#define pp_i_gt			Perl_pp_i_gt
#define pp_i_le			Perl_pp_i_le
#define pp_i_lt			Perl_pp_i_lt
#define pp_i_modulo		Perl_pp_i_modulo
#define pp_i_multiply		Perl_pp_i_multiply
#define pp_i_ncmp		Perl_pp_i_ncmp
#define pp_i_ne			Perl_pp_i_ne
#define pp_i_negate		Perl_pp_i_negate
#define pp_i_subtract		Perl_pp_i_subtract
#define pp_index		Perl_pp_index
#define pp_int			Perl_pp_int
#define pp_interp		Perl_pp_interp
#define pp_ioctl		Perl_pp_ioctl
#define pp_iter			Perl_pp_iter
#define pp_join			Perl_pp_join
#define pp_keys			Perl_pp_keys
#define pp_kill			Perl_pp_kill
#define pp_last			Perl_pp_last
#define pp_lc			Perl_pp_lc
#define pp_lcfirst		Perl_pp_lcfirst
#define pp_le			Perl_pp_le
#define pp_leave		Perl_pp_leave
#define pp_leaveeval		Perl_pp_leaveeval
#define pp_leaveloop		Perl_pp_leaveloop
#define pp_leavesub		Perl_pp_leavesub
#define pp_leavetry		Perl_pp_leavetry
#define pp_leavewrite		Perl_pp_leavewrite
#define pp_left_shift		Perl_pp_left_shift
#define pp_length		Perl_pp_length
#define pp_lineseq		Perl_pp_lineseq
#define pp_link			Perl_pp_link
#define pp_list			Perl_pp_list
#define pp_listen		Perl_pp_listen
#define pp_localtime		Perl_pp_localtime
#define pp_lock			Perl_pp_lock
#define pp_log			Perl_pp_log
#define pp_lslice		Perl_pp_lslice
#define pp_lstat		Perl_pp_lstat
#define pp_lt			Perl_pp_lt
#define pp_map			Perl_pp_map
#define pp_mapstart		Perl_pp_mapstart
#define pp_mapwhile		Perl_pp_mapwhile
#define pp_match		Perl_pp_match
#define pp_method		Perl_pp_method
#define pp_mkdir		Perl_pp_mkdir
#define pp_modulo		Perl_pp_modulo
#define pp_msgctl		Perl_pp_msgctl
#define pp_msgget		Perl_pp_msgget
#define pp_msgrcv		Perl_pp_msgrcv
#define pp_msgsnd		Perl_pp_msgsnd
#define pp_multiply		Perl_pp_multiply
#define pp_ncmp			Perl_pp_ncmp
#define pp_ne			Perl_pp_ne
#define pp_negate		Perl_pp_negate
#define pp_next			Perl_pp_next
#define pp_nextstate		Perl_pp_nextstate
#define pp_not			Perl_pp_not
#define pp_nswitch		Perl_pp_nswitch
#define pp_null			Perl_pp_null
#define pp_oct			Perl_pp_oct
#define pp_open			Perl_pp_open
#define pp_open_dir		Perl_pp_open_dir
#define pp_or			Perl_pp_or
#define pp_orassign		Perl_pp_orassign
#define pp_ord			Perl_pp_ord
#define pp_pack			Perl_pp_pack
#define pp_padany		Perl_pp_padany
#define pp_padav		Perl_pp_padav
#define pp_padhv		Perl_pp_padhv
#define pp_padsv		Perl_pp_padsv
#define pp_pipe_op		Perl_pp_pipe_op
#define pp_pop			Perl_pp_pop
#define pp_pos			Perl_pp_pos
#define pp_postdec		Perl_pp_postdec
#define pp_postinc		Perl_pp_postinc
#define pp_pow			Perl_pp_pow
#define pp_predec		Perl_pp_predec
#define pp_preinc		Perl_pp_preinc
#define pp_print		Perl_pp_print
#define pp_prototype		Perl_pp_prototype
#define pp_prtf			Perl_pp_prtf
#define pp_push			Perl_pp_push
#define pp_pushmark		Perl_pp_pushmark
#define pp_pushre		Perl_pp_pushre
#define pp_qr			Perl_pp_qr
#define pp_quotemeta		Perl_pp_quotemeta
#define pp_rand			Perl_pp_rand
#define pp_range		Perl_pp_range
#define pp_rcatline		Perl_pp_rcatline
#define pp_read			Perl_pp_read
#define pp_readdir		Perl_pp_readdir
#define pp_readline		Perl_pp_readline
#define pp_readlink		Perl_pp_readlink
#define pp_recv			Perl_pp_recv
#define pp_redo			Perl_pp_redo
#define pp_ref			Perl_pp_ref
#define pp_refgen		Perl_pp_refgen
#define pp_regcmaybe		Perl_pp_regcmaybe
#define pp_regcomp		Perl_pp_regcomp
#define pp_regcreset		Perl_pp_regcreset
#define pp_rename		Perl_pp_rename
#define pp_repeat		Perl_pp_repeat
#define pp_require		Perl_pp_require
#define pp_reset		Perl_pp_reset
#define pp_return		Perl_pp_return
#define pp_reverse		Perl_pp_reverse
#define pp_rewinddir		Perl_pp_rewinddir
#define pp_right_shift		Perl_pp_right_shift
#define pp_rindex		Perl_pp_rindex
#define pp_rmdir		Perl_pp_rmdir
#define pp_rv2av		Perl_pp_rv2av
#define pp_rv2cv		Perl_pp_rv2cv
#define pp_rv2gv		Perl_pp_rv2gv
#define pp_rv2hv		Perl_pp_rv2hv
#define pp_rv2sv		Perl_pp_rv2sv
#define pp_sassign		Perl_pp_sassign
#define pp_scalar		Perl_pp_scalar
#define pp_schomp		Perl_pp_schomp
#define pp_schop		Perl_pp_schop
#define pp_scmp			Perl_pp_scmp
#define pp_scope		Perl_pp_scope
#define pp_seek			Perl_pp_seek
#define pp_seekdir		Perl_pp_seekdir
#define pp_select		Perl_pp_select
#define pp_semctl		Perl_pp_semctl
#define pp_semget		Perl_pp_semget
#define pp_semop		Perl_pp_semop
#define pp_send			Perl_pp_send
#define pp_seq			Perl_pp_seq
#define pp_setpgrp		Perl_pp_setpgrp
#define pp_setpriority		Perl_pp_setpriority
#define pp_sge			Perl_pp_sge
#define pp_sgrent		Perl_pp_sgrent
#define pp_sgt			Perl_pp_sgt
#define pp_shift		Perl_pp_shift
#define pp_shmctl		Perl_pp_shmctl
#define pp_shmget		Perl_pp_shmget
#define pp_shmread		Perl_pp_shmread
#define pp_shmwrite		Perl_pp_shmwrite
#define pp_shostent		Perl_pp_shostent
#define pp_shutdown		Perl_pp_shutdown
#define pp_sin			Perl_pp_sin
#define pp_sle			Perl_pp_sle
#define pp_sleep		Perl_pp_sleep
#define pp_slt			Perl_pp_slt
#define pp_sne			Perl_pp_sne
#define pp_snetent		Perl_pp_snetent
#define pp_socket		Perl_pp_socket
#define pp_sockpair		Perl_pp_sockpair
#define pp_sort			Perl_pp_sort
#define pp_splice		Perl_pp_splice
#define pp_split		Perl_pp_split
#define pp_sprintf		Perl_pp_sprintf
#define pp_sprotoent		Perl_pp_sprotoent
#define pp_spwent		Perl_pp_spwent
#define pp_sqrt			Perl_pp_sqrt
#define pp_srand		Perl_pp_srand
#define pp_srefgen		Perl_pp_srefgen
#define pp_sselect		Perl_pp_sselect
#define pp_sservent		Perl_pp_sservent
#define pp_ssockopt		Perl_pp_ssockopt
#define pp_stat			Perl_pp_stat
#define pp_stringify		Perl_pp_stringify
#define pp_stub			Perl_pp_stub
#define pp_study		Perl_pp_study
#define pp_subst		Perl_pp_subst
#define pp_substcont		Perl_pp_substcont
#define pp_substr		Perl_pp_substr
#define pp_subtract		Perl_pp_subtract
#define pp_symlink		Perl_pp_symlink
#define pp_syscall		Perl_pp_syscall
#define pp_sysopen		Perl_pp_sysopen
#define pp_sysread		Perl_pp_sysread
#define pp_sysseek		Perl_pp_sysseek
#define pp_system		Perl_pp_system
#define pp_syswrite		Perl_pp_syswrite
#define pp_tell			Perl_pp_tell
#define pp_telldir		Perl_pp_telldir
#define pp_threadsv		Perl_pp_threadsv
#define pp_tie			Perl_pp_tie
#define pp_tied			Perl_pp_tied
#define pp_time			Perl_pp_time
#define pp_tms			Perl_pp_tms
#define pp_trans		Perl_pp_trans
#define pp_truncate		Perl_pp_truncate
#define pp_uc			Perl_pp_uc
#define pp_ucfirst		Perl_pp_ucfirst
#define pp_umask		Perl_pp_umask
#define pp_undef		Perl_pp_undef
#define pp_unlink		Perl_pp_unlink
#define pp_unpack		Perl_pp_unpack
#define pp_unshift		Perl_pp_unshift
#define pp_unstack		Perl_pp_unstack
#define pp_untie		Perl_pp_untie
#define pp_utime		Perl_pp_utime
#define pp_values		Perl_pp_values
#define pp_vec			Perl_pp_vec
#define pp_wait			Perl_pp_wait
#define pp_waitpid		Perl_pp_waitpid
#define pp_wantarray		Perl_pp_wantarray
#define pp_warn			Perl_pp_warn
#define pp_xor			Perl_pp_xor
#define ppaddr			Perl_ppaddr
#define pregcomp		Perl_pregcomp
#define pregexec		Perl_pregexec
#define pregfree		Perl_pregfree
#define prepend_elem		Perl_prepend_elem
#define push_return		Perl_push_return
#define push_scope		Perl_push_scope
#define q			Perl_q
#define reall_srchlen		Perl_reall_srchlen
#define ref			Perl_ref
#define refkids			Perl_refkids
#define regdump			Perl_regdump
#define regexec_flags		Perl_regexec_flags
#define regkind			Perl_regkind
#define regnext			Perl_regnext
#define regprop			Perl_regprop
#define repeat_amg		Perl_repeat_amg
#define repeat_ass_amg		Perl_repeat_ass_amg
#define repeatcpy		Perl_repeatcpy
#define rninstr			Perl_rninstr
#define rshift_amg		Perl_rshift_amg
#define rshift_ass_amg		Perl_rshift_ass_amg
#define rsignal			Perl_rsignal
#define rsignal_restore		Perl_rsignal_restore
#define rsignal_save		Perl_rsignal_save
#define rsignal_state		Perl_rsignal_state
#define runops_debug		Perl_runops_debug
#define runops_standard		Perl_runops_standard
#define rxres_free		Perl_rxres_free
#define rxres_restore		Perl_rxres_restore
#define rxres_save		Perl_rxres_save
#define safecalloc		Perl_safecalloc
#define safefree		Perl_safefree
#define safemalloc		Perl_safemalloc
#define saferealloc		Perl_saferealloc
#define safexcalloc		Perl_safexcalloc
#define safexfree		Perl_safexfree
#define safexmalloc		Perl_safexmalloc
#define safexrealloc		Perl_safexrealloc
#define same_dirent		Perl_same_dirent
#define save_I16		Perl_save_I16
#define save_I32		Perl_save_I32
#define save_aelem		Perl_save_aelem
#define save_aptr		Perl_save_aptr
#define save_ary		Perl_save_ary
#define save_clearsv		Perl_save_clearsv
#define save_delete		Perl_save_delete
#define save_destructor		Perl_save_destructor
#define save_freeop		Perl_save_freeop
#define save_freepv		Perl_save_freepv
#define save_freesv		Perl_save_freesv
#define save_generic_svref	Perl_save_generic_svref
#define save_gp			Perl_save_gp
#define save_hash		Perl_save_hash
#define save_helem		Perl_save_helem
#define save_hints		Perl_save_hints
#define save_hptr		Perl_save_hptr
#define save_int		Perl_save_int
#define save_item		Perl_save_item
#define save_iv			Perl_save_iv
#define save_list		Perl_save_list
#define save_long		Perl_save_long
#define save_nogv		Perl_save_nogv
#define save_op			Perl_save_op
#define save_pptr		Perl_save_pptr
#define save_scalar		Perl_save_scalar
#define save_sptr		Perl_save_sptr
#define save_svref		Perl_save_svref
#define save_threadsv		Perl_save_threadsv
#define savepv			Perl_savepv
#define savepvn			Perl_savepvn
#define savestack_grow		Perl_savestack_grow
#define saw_return		Perl_saw_return
#define sawparens		Perl_sawparens
#define scalar			Perl_scalar
#define scalarkids		Perl_scalarkids
#define scalarseq		Perl_scalarseq
#define scalarvoid		Perl_scalarvoid
#define scan_const		Perl_scan_const
#define scan_formline		Perl_scan_formline
#define scan_heredoc		Perl_scan_heredoc
#define scan_hex		Perl_scan_hex
#define scan_ident		Perl_scan_ident
#define scan_inputsymbol	Perl_scan_inputsymbol
#define scan_num		Perl_scan_num
#define scan_oct		Perl_scan_oct
#define scan_pat		Perl_scan_pat
#define scan_prefix		Perl_scan_prefix
#define scan_str		Perl_scan_str
#define scan_subst		Perl_scan_subst
#define scan_trans		Perl_scan_trans
#define scan_word		Perl_scan_word
#define scmp_amg		Perl_scmp_amg
#define scope			Perl_scope
#define screaminstr		Perl_screaminstr
#define seq_amg			Perl_seq_amg
#define setdefout		Perl_setdefout
#define setenv_getix		Perl_setenv_getix
#define sge_amg			Perl_sge_amg
#define sgt_amg			Perl_sgt_amg
#define share_hek		Perl_share_hek
#define sharepvn		Perl_sharepvn
#define sig_name		Perl_sig_name
#define sig_num			Perl_sig_num
#define sighandler		Perl_sighandler
#define simple			Perl_simple
#define sin_amg			Perl_sin_amg
#define skipspace		Perl_skipspace
#define sle_amg			Perl_sle_amg
#define slt_amg			Perl_slt_amg
#define sne_amg			Perl_sne_amg
#define sqrt_amg		Perl_sqrt_amg
#define stack_grow		Perl_stack_grow
#define start_subparse		Perl_start_subparse
#define string_amg		Perl_string_amg
#define sub_crush_depth		Perl_sub_crush_depth
#define subtr_amg		Perl_subtr_amg
#define subtr_ass_amg		Perl_subtr_ass_amg
#define sv_2bool		Perl_sv_2bool
#define sv_2cv			Perl_sv_2cv
#define sv_2io			Perl_sv_2io
#define sv_2iv			Perl_sv_2iv
#define sv_2mortal		Perl_sv_2mortal
#define sv_2nv			Perl_sv_2nv
#define sv_2pv			Perl_sv_2pv
#define sv_2uv			Perl_sv_2uv
#define sv_add_arena		Perl_sv_add_arena
#define sv_backoff		Perl_sv_backoff
#define sv_bless		Perl_sv_bless
#define sv_catpv		Perl_sv_catpv
#define sv_catpv_mg		Perl_sv_catpv_mg
#define sv_catpvf		Perl_sv_catpvf
#define sv_catpvf_mg		Perl_sv_catpvf_mg
#define sv_catpvn		Perl_sv_catpvn
#define sv_catpvn_mg		Perl_sv_catpvn_mg
#define sv_catsv		Perl_sv_catsv
#define sv_catsv_mg		Perl_sv_catsv_mg
#define sv_chop			Perl_sv_chop
#define sv_clean_all		Perl_sv_clean_all
#define sv_clean_objs		Perl_sv_clean_objs
#define sv_clear		Perl_sv_clear
#define sv_cmp			Perl_sv_cmp
#define sv_cmp_locale		Perl_sv_cmp_locale
#define sv_collxfrm		Perl_sv_collxfrm
#define sv_compile_2op		Perl_sv_compile_2op
#define sv_dec			Perl_sv_dec
#define sv_derived_from		Perl_sv_derived_from
#define sv_dump			Perl_sv_dump
#define sv_eq			Perl_sv_eq
#define sv_free			Perl_sv_free
#define sv_free_arenas		Perl_sv_free_arenas
#define sv_gets			Perl_sv_gets
#define sv_grow			Perl_sv_grow
#define sv_inc			Perl_sv_inc
#define sv_insert		Perl_sv_insert
#define sv_isa			Perl_sv_isa
#define sv_isobject		Perl_sv_isobject
#define sv_iv			Perl_sv_iv
#define sv_len			Perl_sv_len
#define sv_magic		Perl_sv_magic
#define sv_mortalcopy		Perl_sv_mortalcopy
#define sv_newmortal		Perl_sv_newmortal
#define sv_newref		Perl_sv_newref
#define sv_nv			Perl_sv_nv
#define sv_peek			Perl_sv_peek
#define sv_pvn			Perl_sv_pvn
#define sv_pvn_force		Perl_sv_pvn_force
#define sv_ref			Perl_sv_ref
#define sv_reftype		Perl_sv_reftype
#define sv_replace		Perl_sv_replace
#define sv_report_used		Perl_sv_report_used
#define sv_reset		Perl_sv_reset
#define sv_setiv		Perl_sv_setiv
#define sv_setiv_mg		Perl_sv_setiv_mg
#define sv_setnv		Perl_sv_setnv
#define sv_setnv_mg		Perl_sv_setnv_mg
#define sv_setptrobj		Perl_sv_setptrobj
#define sv_setpv		Perl_sv_setpv
#define sv_setpv_mg		Perl_sv_setpv_mg
#define sv_setpvf		Perl_sv_setpvf
#define sv_setpvf_mg		Perl_sv_setpvf_mg
#define sv_setpviv		Perl_sv_setpviv
#define sv_setpviv_mg		Perl_sv_setpviv_mg
#define sv_setpvn		Perl_sv_setpvn
#define sv_setpvn_mg		Perl_sv_setpvn_mg
#define sv_setref_iv		Perl_sv_setref_iv
#define sv_setref_nv		Perl_sv_setref_nv
#define sv_setref_pv		Perl_sv_setref_pv
#define sv_setref_pvn		Perl_sv_setref_pvn
#define sv_setsv		Perl_sv_setsv
#define sv_setsv_mg		Perl_sv_setsv_mg
#define sv_setuv		Perl_sv_setuv
#define sv_setuv_mg		Perl_sv_setuv_mg
#define sv_taint		Perl_sv_taint
#define sv_tainted		Perl_sv_tainted
#define sv_true			Perl_sv_true
#define sv_unmagic		Perl_sv_unmagic
#define sv_unref		Perl_sv_unref
#define sv_untaint		Perl_sv_untaint
#define sv_upgrade		Perl_sv_upgrade
#define sv_usepvn		Perl_sv_usepvn
#define sv_usepvn_mg		Perl_sv_usepvn_mg
#define sv_uv			Perl_sv_uv
#define sv_vcatpvfn		Perl_sv_vcatpvfn
#define sv_vsetpvfn		Perl_sv_vsetpvfn
#define taint_env		Perl_taint_env
#define taint_proper		Perl_taint_proper
#define too_few_arguments	Perl_too_few_arguments
#define too_many_arguments	Perl_too_many_arguments
#define unlnk			Perl_unlnk
#define unlock_condpair		Perl_unlock_condpair
#define unshare_hek		Perl_unshare_hek
#define unsharepvn		Perl_unsharepvn
#define utilize			Perl_utilize
#define varies			Perl_varies
#define vivify_defelem		Perl_vivify_defelem
#define vivify_ref		Perl_vivify_ref
#define vtbl_amagic		Perl_vtbl_amagic
#define vtbl_amagicelem		Perl_vtbl_amagicelem
#define vtbl_arylen		Perl_vtbl_arylen
#define vtbl_bm			Perl_vtbl_bm
#define vtbl_collxfrm		Perl_vtbl_collxfrm
#define vtbl_dbline		Perl_vtbl_dbline
#define vtbl_defelem		Perl_vtbl_defelem
#define vtbl_env		Perl_vtbl_env
#define vtbl_envelem		Perl_vtbl_envelem
#define vtbl_fm			Perl_vtbl_fm
#define vtbl_glob		Perl_vtbl_glob
#define vtbl_isa		Perl_vtbl_isa
#define vtbl_isaelem		Perl_vtbl_isaelem
#define vtbl_mglob		Perl_vtbl_mglob
#define vtbl_mutex		Perl_vtbl_mutex
#define vtbl_nkeys		Perl_vtbl_nkeys
#define vtbl_pack		Perl_vtbl_pack
#define vtbl_packelem		Perl_vtbl_packelem
#define vtbl_pos		Perl_vtbl_pos
#define vtbl_regexp		Perl_vtbl_regexp
#define vtbl_sig		Perl_vtbl_sig
#define vtbl_sigelem		Perl_vtbl_sigelem
#define vtbl_substr		Perl_vtbl_substr
#define vtbl_sv			Perl_vtbl_sv
#define vtbl_taint		Perl_vtbl_taint
#define vtbl_uvar		Perl_vtbl_uvar
#define vtbl_vec		Perl_vtbl_vec
#define wait4pid		Perl_wait4pid
#define warn			Perl_warn
#define warn_nl			Perl_warn_nl
#define warn_nosemi		Perl_warn_nosemi
#define warn_reserved		Perl_warn_reserved
#define warn_uninit		Perl_warn_uninit
#define watch			Perl_watch
#define watchaddr		Perl_watchaddr
#define watchok			Perl_watchok
#define whichsig		Perl_whichsig
#define yychar			Perl_yychar
#define yycheck			Perl_yycheck
#define yydebug			Perl_yydebug
#define yydefred		Perl_yydefred
#define yydestruct		Perl_yydestruct
#define yydgoto			Perl_yydgoto
#define yyerrflag		Perl_yyerrflag
#define yyerror			Perl_yyerror
#define yygindex		Perl_yygindex
#define yylen			Perl_yylen
#define yylex			Perl_yylex
#define yylhs			Perl_yylhs
#define yylval			Perl_yylval
#define yyname			Perl_yyname
#define yynerrs			Perl_yynerrs
#define yyparse			Perl_yyparse
#define yyrindex		Perl_yyrindex
#define yyrule			Perl_yyrule
#define yysindex		Perl_yysindex
#define yytable			Perl_yytable
#define yyval			Perl_yyval
#define yywarn			Perl_yywarn

#endif /* EMBED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\fakethr.h ===
typedef int perl_mutex;
typedef int perl_key;

typedef struct perl_thread *perl_os_thread;
/* With fake threads, thr is global(ish) so we don't need dTHR */
#define dTHR extern int errno

struct perl_wait_queue {
    struct perl_thread *	thread;
    struct perl_wait_queue *	next;
};
typedef struct perl_wait_queue *perl_cond;

/* Ask thread.h to include our per-thread extras */
#define HAVE_THREAD_INTERN
struct thread_intern {
    perl_os_thread next_run, prev_run;  /* Linked list of runnable threads */
    perl_cond   wait_queue;             /* Wait queue that we are waiting on */
    IV          private;                /* Holds data across time slices */
    I32         savemark;               /* Holds MARK for thread join values */
};

#define init_thread_intern(t) 				\
    STMT_START {					\
	t->self = (t);					\
	(t)->i.next_run = (t)->i.prev_run = (t);	\
	(t)->i.wait_queue = 0;				\
	(t)->i.private = 0;				\
    } STMT_END

/*
 * Note that SCHEDULE() is only callable from pp code (which
 * must be expecting to be restarted). We'll have to do
 * something a bit different for XS code.
 */

#define SCHEDULE() return schedule(), PL_op

#define MUTEX_LOCK(m)
#define MUTEX_UNLOCK(m)
#define MUTEX_INIT(m)
#define MUTEX_DESTROY(m)
#define COND_INIT(c) perl_cond_init(c)
#define COND_SIGNAL(c) perl_cond_signal(c)
#define COND_BROADCAST(c) perl_cond_broadcast(c)
#define COND_WAIT(c, m)		\
    STMT_START {		\
	perl_cond_wait(c);	\
	SCHEDULE();		\
    } STMT_END
#define COND_DESTROY(c)

#define THREAD_CREATE(t, f)	f((t))
#define THREAD_POST_CREATE(t)	NOOP

#define YIELD	NOOP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\form.h ===
/*    form.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define FF_END		0
#define FF_LINEMARK	1
#define FF_LITERAL	2
#define FF_SKIP		3
#define FF_FETCH	4
#define FF_CHECKNL	5
#define FF_CHECKCHOP	6
#define FF_SPACE	7
#define FF_HALFSPACE	8
#define FF_ITEM		9
#define FF_CHOP		10
#define FF_LINEGLOB	11
#define FF_DECIMAL	12
#define FF_NEWLINE	13
#define FF_BLANK	14
#define FF_MORE		15
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\gv.h ===
/*    gv.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct gp {
    SV *	gp_sv;		/* scalar value */
    U32		gp_refcnt;	/* how many globs point to this? */
    struct io *	gp_io;		/* filehandle value */
    CV *	gp_form;	/* format value */
    AV *	gp_av;		/* array value */
    HV *	gp_hv;		/* hash value */
    GV *	gp_egv;		/* effective gv, if *glob */
    CV *	gp_cv;		/* subroutine value */
    U32		gp_cvgen;	/* generational validity of cached gv_cv */
    I32		gp_lastexpr;	/* used by nothing_in_common() */
    line_t	gp_line;	/* line first declared at (for -w) */
    GV *	gp_filegv;	/* file first declared in (for -w) */
};

#if defined(CRIPPLED_CC) && (defined(iAPX286) || defined(M_I286) || defined(I80286))
#define MICROPORT
#endif

#define GvXPVGV(gv)	((XPVGV*)SvANY(gv))

#define GvGP(gv)	(GvXPVGV(gv)->xgv_gp)
#define GvNAME(gv)	(GvXPVGV(gv)->xgv_name)
#define GvNAMELEN(gv)	(GvXPVGV(gv)->xgv_namelen)
#define GvSTASH(gv)	(GvXPVGV(gv)->xgv_stash)
#define GvFLAGS(gv)	(GvXPVGV(gv)->xgv_flags)

#define GvSV(gv)	(GvGP(gv)->gp_sv)
#define GvREFCNT(gv)	(GvGP(gv)->gp_refcnt)
#define GvIO(gv)	((gv) && SvTYPE((SV*)gv) == SVt_PVGV ? GvIOp(gv) : 0)
#define GvIOp(gv)	(GvGP(gv)->gp_io)
#define GvIOn(gv)	(GvIO(gv) ? GvIOp(gv) : GvIOp(gv_IOadd(gv)))

#define GvFORM(gv)	(GvGP(gv)->gp_form)
#define GvAV(gv)	(GvGP(gv)->gp_av)

/* This macro is deprecated.  Do not use! */
#define GvREFCNT_inc(gv) ((GV*)SvREFCNT_inc(gv))	/* DO NOT USE */

#ifdef	MICROPORT	/* Microport 2.4 hack */
AV *GvAVn();
#else
#define GvAVn(gv)	(GvGP(gv)->gp_av ? \
			 GvGP(gv)->gp_av : \
			 GvGP(gv_AVadd(gv))->gp_av)
#endif
#define GvHV(gv)	((GvGP(gv))->gp_hv)

#ifdef	MICROPORT	/* Microport 2.4 hack */
HV *GvHVn();
#else
#define GvHVn(gv)	(GvGP(gv)->gp_hv ? \
			 GvGP(gv)->gp_hv : \
			 GvGP(gv_HVadd(gv))->gp_hv)
#endif			/* Microport 2.4 hack */

#define GvCV(gv)	(GvGP(gv)->gp_cv)
#define GvCVGEN(gv)	(GvGP(gv)->gp_cvgen)
#define GvCVu(gv)	(GvGP(gv)->gp_cvgen ? Nullcv : GvGP(gv)->gp_cv)

#define GvLASTEXPR(gv)	(GvGP(gv)->gp_lastexpr)

#define GvLINE(gv)	(GvGP(gv)->gp_line)
#define GvFILEGV(gv)	(GvGP(gv)->gp_filegv)

#define GvEGV(gv)	(GvGP(gv)->gp_egv)
#define GvENAME(gv)	GvNAME(GvEGV(gv) ? GvEGV(gv) : gv)
#define GvESTASH(gv)	GvSTASH(GvEGV(gv) ? GvEGV(gv) : gv)

#define GVf_INTRO	0x01
#define GVf_MULTI	0x02
#define GVf_ASSUMECV	0x04
#define GVf_IMPORTED	0xF0
#define GVf_IMPORTED_SV	  0x10
#define GVf_IMPORTED_AV	  0x20
#define GVf_IMPORTED_HV	  0x40
#define GVf_IMPORTED_CV	  0x80

#define GvINTRO(gv)		(GvFLAGS(gv) & GVf_INTRO)
#define GvINTRO_on(gv)		(GvFLAGS(gv) |= GVf_INTRO)
#define GvINTRO_off(gv)		(GvFLAGS(gv) &= ~GVf_INTRO)

#define GvMULTI(gv)		(GvFLAGS(gv) & GVf_MULTI)
#define GvMULTI_on(gv)		(GvFLAGS(gv) |= GVf_MULTI)
#define GvMULTI_off(gv)		(GvFLAGS(gv) &= ~GVf_MULTI)

#define GvASSUMECV(gv)		(GvFLAGS(gv) & GVf_ASSUMECV)
#define GvASSUMECV_on(gv)	(GvFLAGS(gv) |= GVf_ASSUMECV)
#define GvASSUMECV_off(gv)	(GvFLAGS(gv) &= ~GVf_ASSUMECV)

#define GvIMPORTED(gv)		(GvFLAGS(gv) & GVf_IMPORTED)
#define GvIMPORTED_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED)
#define GvIMPORTED_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED)

#define GvIMPORTED_SV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_SV)
#define GvIMPORTED_SV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_SV)
#define GvIMPORTED_SV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_SV)

#define GvIMPORTED_AV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_AV)
#define GvIMPORTED_AV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_AV)
#define GvIMPORTED_AV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_AV)

#define GvIMPORTED_HV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_HV)
#define GvIMPORTED_HV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_HV)
#define GvIMPORTED_HV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_HV)

#define GvIMPORTED_CV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_CV)
#define GvIMPORTED_CV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_CV)
#define GvIMPORTED_CV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_CV)

#define Nullgv Null(GV*)

#define DM_UID   0x003
#define DM_RUID   0x001
#define DM_EUID   0x002
#define DM_GID   0x030
#define DM_RGID   0x010
#define DM_EGID   0x020
#define DM_DELAY 0x100

/*
 * symbol creation flags, for use in gv_fetchpv() and perl_get_*v()
 */
#define GV_ADD		0x01	/* add, if symbol not already there */
#define GV_ADDMULTI	0x02	/* add, pretending it has been added already */
#define GV_ADDWARN	0x04	/* add, but warn if symbol wasn't already there */
#define GV_ADDINEVAL	0x08	/* add, as though we're doing so within an eval */
#define GV_NOINIT	0x10	/* add, but don't init symbol, if type != PVGV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\extern.h ===
/*    EXTERN.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * EXT  designates a global var which is defined in perl.h
 * dEXT designates a global var which is defined in another
 *      file, so we can't count on finding it in perl.h
 *      (this practice should be avoided).
 */
#undef EXT
#undef dEXT
#undef EXTCONST
#undef dEXTCONST
#if defined(VMS) && !defined(__GNUC__)
    /* Suppress portability warnings from DECC for VMS-specific extensions */
#  ifdef __DECC
#    pragma message disable (GLOBALEXT,NOSHAREEXT,READONLYEXT)
#  endif
#  define EXT globalref
#  define dEXT globaldef {"$GLOBAL_RW_VARS"} noshare
#  define EXTCONST globalref
#  define dEXTCONST globaldef {"$GLOBAL_RO_VARS"} readonly
#else
#  if defined(WIN32) && !defined(PERL_STATIC_SYMS) && !defined(__GNUC__) && !defined(PERL_OBJECT)
#    ifdef PERLDLL
#      define EXT extern __declspec(dllexport)
#      define dEXT 
#      define EXTCONST extern __declspec(dllexport) const
#      define dEXTCONST const
#    else
#      define EXT extern __declspec(dllimport)
#      define dEXT 
#      define EXTCONST extern __declspec(dllimport) const
#      define dEXTCONST const
#    endif
#  else
#    define EXT extern
#    define dEXT
#    define EXTCONST extern const
#    define dEXTCONST const
#  endif
#endif

#undef INIT
#define INIT(x)

#undef DOINIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\hv.h ===
/*    hv.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

typedef struct he HE;
typedef struct hek HEK;

struct he {
    HE		*hent_next;
    HEK		*hent_hek;
    SV		*hent_val;
};

struct hek {
    U32		hek_hash;
    I32		hek_len;
    char	hek_key[1];
};

/* This structure must match the beginning of struct xpvmg in sv.h. */
struct xpvhv {
    char *	xhv_array;	/* pointer to malloced string */
    STRLEN	xhv_fill;	/* how full xhv_array currently is */
    STRLEN	xhv_max;	/* subscript of last element of xhv_array */
    IV		xhv_keys;	/* how many elements in the array */
    double	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* magic for scalar array */
    HV*		xmg_stash;	/* class package */

    I32		xhv_riter;	/* current root of iterator */
    HE		*xhv_eiter;	/* current entry of iterator */
    PMOP	*xhv_pmroot;	/* list of pm's for this package */
    char	*xhv_name;	/* name, if a symbol table */
};

#define PERL_HASH(hash,str,len) \
     STMT_START	{ \
	register char *s_PeRlHaSh = str; \
	register I32 i_PeRlHaSh = len; \
	register U32 hash_PeRlHaSh = 0; \
	while (i_PeRlHaSh--) \
	    hash_PeRlHaSh = hash_PeRlHaSh * 33 + *s_PeRlHaSh++; \
	(hash) = hash_PeRlHaSh; \
    } STMT_END


/* these hash entry flags ride on hent_klen (for use only in magic/tied HVs) */
#define HEf_SVKEY	-2	/* hent_key is a SV* */


#define Nullhv Null(HV*)
#define HvARRAY(hv)	((HE**)((XPVHV*)  SvANY(hv))->xhv_array)
#define HvFILL(hv)	((XPVHV*)  SvANY(hv))->xhv_fill
#define HvMAX(hv)	((XPVHV*)  SvANY(hv))->xhv_max
#define HvKEYS(hv)	((XPVHV*)  SvANY(hv))->xhv_keys
#define HvRITER(hv)	((XPVHV*)  SvANY(hv))->xhv_riter
#define HvEITER(hv)	((XPVHV*)  SvANY(hv))->xhv_eiter
#define HvPMROOT(hv)	((XPVHV*)  SvANY(hv))->xhv_pmroot
#define HvNAME(hv)	((XPVHV*)  SvANY(hv))->xhv_name

#define HvSHAREKEYS(hv)		(SvFLAGS(hv) & SVphv_SHAREKEYS)
#define HvSHAREKEYS_on(hv)	(SvFLAGS(hv) |= SVphv_SHAREKEYS)
#define HvSHAREKEYS_off(hv)	(SvFLAGS(hv) &= ~SVphv_SHAREKEYS)

#define HvLAZYDEL(hv)		(SvFLAGS(hv) & SVphv_LAZYDEL)
#define HvLAZYDEL_on(hv)	(SvFLAGS(hv) |= SVphv_LAZYDEL)
#define HvLAZYDEL_off(hv)	(SvFLAGS(hv) &= ~SVphv_LAZYDEL)

#ifdef OVERLOAD

/* Maybe amagical: */
/* #define HV_AMAGICmb(hv)      (SvFLAGS(hv) & (SVpgv_badAM | SVpgv_AM)) */

#define HV_AMAGIC(hv)        (SvFLAGS(hv) &   SVpgv_AM)
#define HV_AMAGIC_on(hv)     (SvFLAGS(hv) |=  SVpgv_AM)
#define HV_AMAGIC_off(hv)    (SvFLAGS(hv) &= ~SVpgv_AM)

/*
#define HV_AMAGICbad(hv)     (SvFLAGS(hv) & SVpgv_badAM)
#define HV_badAMAGIC_on(hv)  (SvFLAGS(hv) |= SVpgv_badAM)
#define HV_badAMAGIC_off(hv) (SvFLAGS(hv) &= ~SVpgv_badAM)
*/

#endif /* OVERLOAD */

#define Nullhe Null(HE*)
#define HeNEXT(he)		(he)->hent_next
#define HeKEY_hek(he)		(he)->hent_hek
#define HeKEY(he)		HEK_KEY(HeKEY_hek(he))
#define HeKEY_sv(he)		(*(SV**)HeKEY(he))
#define HeKLEN(he)		HEK_LEN(HeKEY_hek(he))
#define HeVAL(he)		(he)->hent_val
#define HeHASH(he)		HEK_HASH(HeKEY_hek(he))
#define HePV(he,lp)		((HeKLEN(he) == HEf_SVKEY) ?		\
				 SvPV(HeKEY_sv(he),lp) :		\
				 (((lp = HeKLEN(he)) >= 0) ?		\
				  HeKEY(he) : Nullch))

#define HeSVKEY(he)		((HeKEY(he) && 				\
				  HeKLEN(he) == HEf_SVKEY) ?		\
				 HeKEY_sv(he) : Nullsv)

#define HeSVKEY_force(he)	(HeKEY(he) ?				\
				 ((HeKLEN(he) == HEf_SVKEY) ?		\
				  HeKEY_sv(he) :			\
				  sv_2mortal(newSVpv(HeKEY(he),		\
						     HeKLEN(he)))) :	\
				 &PL_sv_undef)
#define HeSVKEY_set(he,sv)	((HeKLEN(he) = HEf_SVKEY), (HeKEY_sv(he) = sv))

#define Nullhek Null(HEK*)
#define HEK_BASESIZE		STRUCT_OFFSET(HEK, hek_key[0])
#define HEK_HASH(hek)		(hek)->hek_hash
#define HEK_LEN(hek)		(hek)->hek_len
#define HEK_KEY(hek)		(hek)->hek_key
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\handy.h ===
/*    handy.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#if !defined(__STDC__)
#ifdef NULL
#undef NULL
#endif
#ifndef I286
#  define NULL 0
#else
#  define NULL 0L
#endif
#endif

#define Null(type) ((type)NULL)
#define Nullch Null(char*)
#define Nullfp Null(PerlIO*)
#define Nullsv Null(SV*)

#ifdef TRUE
#undef TRUE
#endif
#ifdef FALSE
#undef FALSE
#endif
#define TRUE (1)
#define FALSE (0)


/* XXX Configure ought to have a test for a boolean type, if I can
   just figure out all the headers such a test needs.
   Andy Dougherty	August 1996
*/
/* bool is built-in for g++-2.6.3, which might be used for an extension.
   If the extension includes <_G_config.h> before this file then
   _G_HAVE_BOOL will be properly set.  If, however, the extension includes
   this file first, then you will have to manually set -DHAS_BOOL in 
   your command line to avoid a conflict.
*/
#ifdef _G_HAVE_BOOL
# if _G_HAVE_BOOL
#  ifndef HAS_BOOL
#   define HAS_BOOL 1
#  endif
# endif
#endif

/* The NeXT dynamic loader headers will not build with the bool macro
   So declare them now to clear confusion.
*/
#ifdef NeXT
# undef FALSE
# undef TRUE
  typedef enum bool { FALSE = 0, TRUE = 1 } bool;
# define ENUM_BOOL 1
# ifndef HAS_BOOL
#  define HAS_BOOL 1
# endif /* !HAS_BOOL */
#endif /* NeXT */

#ifndef HAS_BOOL
# if defined(UTS) || defined(VMS)
#  define bool int
# else
#  define bool char
# endif
#endif

/* XXX A note on the perl source internal type system.  The
   original intent was that I32 be *exactly* 32 bits.

   Currently, we only guarantee that I32 is *at least* 32 bits.
   Specifically, if int is 64 bits, then so is I32.  (This is the case
   for the Cray.)  This has the advantage of meshing nicely with
   standard library calls (where we pass an I32 and the library is
   expecting an int), but the disadvantage that an I32 is not 32 bits.
   Andy Dougherty	August 1996

   There is no guarantee that there is *any* integral type with
   exactly 32 bits.  It is perfectly legal for a system to have
   sizeof(short) == sizeof(int) == sizeof(long) == 8.

   Similarly, there is no guarantee that I16 and U16 have exactly 16
   bits.

   For dealing with issues that may arise from various 32/64-bit 
   systems, we will ask Configure to check out 
   	SHORTSIZE == sizeof(short)
   	INTSIZE == sizeof(int)
   	LONGSIZE == sizeof(long)
	LONGLONGSIZE == sizeof(long long) (if HAS_LONG_LONG)
   	PTRSIZE == sizeof(void *)
	DOUBLESIZE == sizeof(double)
	LONG_DOUBLESIZE == sizeof(long double) (if HAS_LONG_DOUBLE).
    Most of these are currently unused, but they are mentioned here so
    metaconfig will include the appropriate tests in Configure and
    we can then start to consider how best to deal with long long
    variables.
   Andy Dougherty	April 1998
*/

typedef char		I8;
typedef unsigned char	U8;
/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX PERL_UCHAR_MAX
#define U8_MIN PERL_UCHAR_MIN

typedef short		I16;
typedef unsigned short	U16;
#define I16_MAX PERL_SHORT_MAX
#define I16_MIN PERL_SHORT_MIN
#define U16_MAX PERL_USHORT_MAX
#define U16_MIN PERL_USHORT_MIN

#if LONGSIZE > 4
  typedef int		I32;
  typedef unsigned int	U32;
# define I32_MAX PERL_INT_MAX
# define I32_MIN PERL_INT_MIN
# define U32_MAX PERL_UINT_MAX
# define U32_MIN PERL_UINT_MIN
#else
  typedef long		I32;
  typedef unsigned long	U32;
# define I32_MAX PERL_LONG_MAX
# define I32_MIN PERL_LONG_MIN
# define U32_MAX PERL_ULONG_MAX
# define U32_MIN PERL_ULONG_MIN
#endif

#define BIT_DIGITS(N)   (((N)*146)/485 + 1)  /* log2(10) =~ 146/485 */
#define TYPE_DIGITS(T)  BIT_DIGITS(sizeof(T) * 8)
#define TYPE_CHARS(T)   (TYPE_DIGITS(T) + 2) /* sign, NUL */

#define Ctl(ch) ((ch) & 037)

#define strNE(s1,s2) (strcmp(s1,s2))
#define strEQ(s1,s2) (!strcmp(s1,s2))
#define strLT(s1,s2) (strcmp(s1,s2) < 0)
#define strLE(s1,s2) (strcmp(s1,s2) <= 0)
#define strGT(s1,s2) (strcmp(s1,s2) > 0)
#define strGE(s1,s2) (strcmp(s1,s2) >= 0)
#define strnNE(s1,s2,l) (strncmp(s1,s2,l))
#define strnEQ(s1,s2,l) (!strncmp(s1,s2,l))

#ifdef HAS_MEMCMP
#  define memNE(s1,s2,l) (memcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!memcmp(s1,s2,l))
#else
#  define memNE(s1,s2,l) (bcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!bcmp(s1,s2,l))
#endif

/*
 * Character classes.
 *
 * Unfortunately, the introduction of locales means that we
 * can't trust isupper(), etc. to tell the truth.  And when
 * it comes to /\w+/ with tainting enabled, we *must* be able
 * to trust our character classes.
 *
 * Therefore, the default tests in the text of Perl will be
 * independent of locale.  Any code that wants to depend on
 * the current locale will use the tests that begin with "lc".
 */

#ifdef HAS_SETLOCALE  /* XXX Is there a better test for this? */
#  ifndef CTYPE256
#    define CTYPE256
#  endif
#endif

#define isALNUM(c)	(isALPHA(c) || isDIGIT(c) || (c) == '_')
#define isIDFIRST(c)	(isALPHA(c) || (c) == '_')
#define isALPHA(c)	(isUPPER(c) || isLOWER(c))
#define isSPACE(c) \
	((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) =='\r' || (c) == '\f')
#define isDIGIT(c)	((c) >= '0' && (c) <= '9')
#ifdef EBCDIC
    /* In EBCDIC we do not do locales: therefore() isupper() is fine. */
#   define isUPPER(c)	isupper(c)
#   define isLOWER(c)	islower(c)
#   define isPRINT(c)	isprint(c)
#   define toUPPER(c)	toupper(c)
#   define toLOWER(c)	tolower(c)
#else
#   define isUPPER(c)	((c) >= 'A' && (c) <= 'Z')
#   define isLOWER(c)	((c) >= 'a' && (c) <= 'z')
#   define isPRINT(c)	(((c) > 32 && (c) < 127) || isSPACE(c))
#   define toUPPER(c)	(isLOWER(c) ? (c) - ('a' - 'A') : (c))
#   define toLOWER(c)	(isUPPER(c) ? (c) + ('a' - 'A') : (c))
#endif

#ifdef USE_NEXT_CTYPE

#  define isALNUM_LC(c) \
	(NXIsAlpha((unsigned int)(c)) || NXIsDigit((unsigned int)(c)) || \
	 (char)(c) == '_')
#  define isIDFIRST_LC(c) \
	(NXIsAlpha((unsigned int)(c)) || (char)(c) == '_')
#  define isALPHA_LC(c)		NXIsAlpha((unsigned int)(c))
#  define isSPACE_LC(c)		NXIsSpace((unsigned int)(c))
#  define isDIGIT_LC(c)		NXIsDigit((unsigned int)(c))
#  define isUPPER_LC(c)		NXIsUpper((unsigned int)(c))
#  define isLOWER_LC(c)		NXIsLower((unsigned int)(c))
#  define isPRINT_LC(c)		NXIsPrint((unsigned int)(c))
#  define toUPPER_LC(c)		NXToUpper((unsigned int)(c))
#  define toLOWER_LC(c)		NXToLower((unsigned int)(c))

#else /* !USE_NEXT_CTYPE */
#  if defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))

#    define isALNUM_LC(c) \
	(isalpha((unsigned char)(c)) || \
	 isdigit((unsigned char)(c)) || (char)(c) == '_')
#    define isIDFIRST_LC(c) (isalpha((unsigned char)(c)) || (char)(c) == '_')
#    define isALPHA_LC(c)	isalpha((unsigned char)(c))
#    define isSPACE_LC(c)	isspace((unsigned char)(c))
#    define isDIGIT_LC(c)	isdigit((unsigned char)(c))
#    define isUPPER_LC(c)	isupper((unsigned char)(c))
#    define isLOWER_LC(c)	islower((unsigned char)(c))
#    define isPRINT_LC(c)	isprint((unsigned char)(c))
#    define toUPPER_LC(c)	toupper((unsigned char)(c))
#    define toLOWER_LC(c)	tolower((unsigned char)(c))

#  else

#    define isALNUM_LC(c) \
	(isascii(c) && (isalpha(c) || isdigit(c) || (c) == '_'))
#    define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
#    define isALPHA_LC(c)	(isascii(c) && isalpha(c))
#    define isSPACE_LC(c)	(isascii(c) && isspace(c))
#    define isDIGIT_LC(c)	(isascii(c) && isdigit(c))
#    define isUPPER_LC(c)	(isascii(c) && isupper(c))
#    define isLOWER_LC(c)	(isascii(c) && islower(c))
#    define isPRINT_LC(c)	(isascii(c) && isprint(c))
#    define toUPPER_LC(c)	toupper(c)
#    define toLOWER_LC(c)	tolower(c)

#  endif
#endif /* USE_NEXT_CTYPE */

#ifdef EBCDIC
EXT int ebcdic_control _((int));
#  define toCTRL(c)	ebcdic_control(c)
#else
  /* This conversion works both ways, strangely enough. */
#  define toCTRL(c)    (toUPPER(c) ^ 64)
#endif

/* Line numbers are unsigned, 16 bits. */
typedef U16 line_t;
#ifdef lint
#define NOLINE ((line_t)0)
#else
#define NOLINE ((line_t) 65535)
#endif


/* This looks obsolete (IZ):

   XXX LEAKTEST doesn't really work in perl5.  There are direct calls to
   safemalloc() in the source, so LEAKTEST won't pick them up.
   Further, if you try LEAKTEST, you'll also end up calling
   Safefree, which might call safexfree() on some things that weren't
   malloced with safexmalloc.  The correct "fix" to this, if anyone
   is interested, is to ensure that all calls go through the New and
   Renew macros.
	--Andy Dougherty		August 1996
*/

#ifndef lint

#define NEWSV(x,len)	newSV(len)

#ifndef LEAKTEST

#define New(x,v,n,t)	(v = (t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))
#define Newc(x,v,n,t,c)	(v = (c*)safemalloc((MEM_SIZE)((n)*sizeof(t))))
#define Newz(x,v,n,t)	(v = (t*)safemalloc((MEM_SIZE)((n)*sizeof(t)))), \
			memzero((char*)(v), (n)*sizeof(t))
#define Renew(v,n,t) \
	  (v = (t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Renewc(v,n,t,c) \
	  (v = (c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Safefree(d)	safefree((Malloc_t)(d))

#else /* LEAKTEST */

#define New(x,v,n,t)	(v = (t*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t))))
#define Newc(x,v,n,t,c)	(v = (c*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t))))
#define Newz(x,v,n,t)	(v = (t*)safexmalloc((x),(MEM_SIZE)((n)*sizeof(t)))), \
			 memzero((char*)(v), (n)*sizeof(t))
#define Renew(v,n,t) \
	  (v = (t*)safexrealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Renewc(v,n,t,c) \
	  (v = (c*)safexrealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))
#define Safefree(d)	safexfree((Malloc_t)(d))

#define MAXXCOUNT 1400
#define MAXY_SIZE 80
#define MAXYCOUNT 16			/* (MAXY_SIZE/4 + 1) */
extern long xcount[MAXXCOUNT];
extern long lastxcount[MAXXCOUNT];
extern long xycount[MAXXCOUNT][MAXYCOUNT];
extern long lastxycount[MAXXCOUNT][MAXYCOUNT];

#endif /* LEAKTEST */

#define Move(s,d,n,t)	(void)memmove((char*)(d),(char*)(s), (n) * sizeof(t))
#define Copy(s,d,n,t)	(void)memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
#define Zero(d,n,t)	(void)memzero((char*)(d), (n) * sizeof(t))

#else /* lint */

#define New(x,v,n,s)	(v = Null(s *))
#define Newc(x,v,n,s,c)	(v = Null(s *))
#define Newz(x,v,n,s)	(v = Null(s *))
#define Renew(v,n,s)	(v = Null(s *))
#define Move(s,d,n,t)
#define Copy(s,d,n,t)
#define Zero(d,n,t)
#define Safefree(d)	(d) = (d)

#endif /* lint */

#ifdef USE_STRUCT_COPY
#define StructCopy(s,d,t) (*((t*)(d)) = *((t*)(s)))
#else
#define StructCopy(s,d,t) Copy(s,d,1,t)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\intern.h ===
/*    INTERN.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * EXT  designates a global var which is defined in perl.h
 * dEXT designates a global var which is defined in another
 *      file, so we can't count on finding it in perl.h
 *      (this practice should be avoided).
 */
#undef EXT
#undef dEXT
#undef EXTCONST
#undef dEXTCONST
#if defined(VMS) && !defined(__GNUC__)
    /* Suppress portability warnings from DECC for VMS-specific extensions */
#  ifdef __DECC
#    pragma message disable (GLOBALEXT,NOSHAREEXT,READONLYEXT)
#  endif
#  define EXT globaldef {"$GLOBAL_RW_VARS"} noshare
#  define dEXT globaldef {"$GLOBAL_RW_VARS"} noshare
#  define EXTCONST globaldef {"$GLOBAL_RO_VARS"} readonly
#  define dEXTCONST globaldef {"$GLOBAL_RO_VARS"} readonly
#else
#  ifdef __cplusplus
#   define EXT
#   define dEXT
#   define EXTCONST extern const
#   define dEXTCONST const
#else
#  define EXT
#  define dEXT
#  define EXTCONST const
#  define dEXTCONST const
#endif
#endif

#undef INIT
#define INIT(x) = x

#define DOINIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\intrpvar.h ===
/***********************************************/
/* Global only to current interpreter instance */
/***********************************************/

/* Don't forget to re-run embed.pl to propagate changes! */

/* The 'I' prefix is only needed for vars that need appropriate #defines
 * generated when built with or without MULTIPLICITY.  It is also used
 * to generate the appropriate export list for win32.
 *
 * When building without MULTIPLICITY, these variables will be truly global.
 *
 * Avoid build-specific #ifdefs here, like DEBUGGING.  That way,
 * we can keep binary compatibility of the curinterp structure */

/* pseudo environmental stuff */
PERLVAR(Iorigargc,	int)
PERLVAR(Iorigargv,	char **)
PERLVAR(Ienvgv,		GV *)
PERLVAR(Isiggv,		GV *)
PERLVAR(Iincgv,		GV *)
PERLVAR(Ihintgv,	GV *)
PERLVAR(Iorigfilename,	char *)
PERLVAR(Idiehook,	SV *)
PERLVAR(Iwarnhook,	SV *)
PERLVAR(Iparsehook,	SV *)
PERLVAR(Icddir,		char *)		/* switches */
PERLVAR(Iminus_c,	bool)
PERLVAR(Ipatchlevel[10],char)
PERLVAR(Ilocalpatches,	char **)
PERLVARI(Isplitstr,	char *,	" ")
PERLVAR(Ipreprocess,	bool)
PERLVAR(Iminus_n,	bool)
PERLVAR(Iminus_p,	bool)
PERLVAR(Iminus_l,	bool)
PERLVAR(Iminus_a,	bool)
PERLVAR(Iminus_F,	bool)
PERLVAR(Idoswitches,	bool)
PERLVAR(Idowarn,	bool)
PERLVAR(Idoextract,	bool)
PERLVAR(Isawampersand,	bool)		/* must save all match strings */
PERLVAR(Isawstudy,	bool)		/* do fbm_instr on all strings */
PERLVAR(Isawvec,	bool)
PERLVAR(Iunsafe,	bool)
PERLVAR(Iinplace,	char *)
PERLVAR(Ie_script,	SV *)
PERLVAR(Iperldb,	U32)

/* This value may be raised by extensions for testing purposes */
/* 0=none, 1=full, 2=full with checks */
PERLVARI(Iperl_destruct_level,	int,	0)

/* magical thingies */
PERLVAR(Ibasetime,	Time_t)		/* $^T */
PERLVAR(Iformfeed,	SV *)		/* $^L */


PERLVARI(Imaxsysfd,	I32,	MAXSYSFD)
					/* top fd to pass to subprocesses */
PERLVAR(Imultiline,	int)		/* $*--do strings hold >1 line? */
PERLVAR(Istatusvalue,	I32)		/* $? */
#ifdef VMS
PERLVAR(Istatusvalue_vms,U32)
#endif

/* shortcuts to various I/O objects */
PERLVAR(Istdingv,	GV *)
PERLVAR(Idefgv,		GV *)
PERLVAR(Iargvgv,	GV *)
PERLVAR(Iargvoutgv,	GV *)

/* shortcuts to regexp stuff */
/* XXX these three aren't used anywhere */
PERLVAR(Ileftgv,	GV *)
PERLVAR(Iampergv,	GV *)
PERLVAR(Irightgv,	GV *)

/* this one needs to be moved to thrdvar.h and accessed via
 * find_threadsv() when USE_THREADS */
PERLVAR(Ireplgv,	GV *)

/* shortcuts to misc objects */
PERLVAR(Ierrgv,		GV *)

/* shortcuts to debugging objects */
PERLVAR(IDBgv,		GV *)
PERLVAR(IDBline,	GV *)
PERLVAR(IDBsub,		GV *)
PERLVAR(IDBsingle,	SV *)
PERLVAR(IDBtrace,	SV *)
PERLVAR(IDBsignal,	SV *)
PERLVAR(Ilineary,	AV *)		/* lines of script for debugger */
PERLVAR(Idbargs,	AV *)		/* args to call listed by caller function */

/* symbol tables */
PERLVAR(Idebstash,	HV *)		/* symbol table for perldb package */
PERLVAR(Iglobalstash,	HV *)		/* global keyword overrides imported here */
PERLVAR(Icurstname,	SV *)		/* name of current package */
PERLVAR(Ibeginav,	AV *)		/* names of BEGIN subroutines */
PERLVAR(Iendav,		AV *)		/* names of END subroutines */
PERLVAR(Iinitav,	AV *)		/* names of INIT subroutines */
PERLVAR(Istrtab,	HV *)		/* shared string table */
PERLVARI(Isub_generation,U32,1)		/* incr to invalidate method cache */

/* memory management */
PERLVAR(Isv_count,	I32)		/* how many SV* are currently allocated */
PERLVAR(Isv_objcount,	I32)		/* how many objects are currently allocated */
PERLVAR(Isv_root,	SV*)		/* storage for SVs belonging to interp */
PERLVAR(Isv_arenaroot,	SV*)		/* list of areas for garbage collection */

/* funky return mechanisms */
PERLVAR(Ilastspbase,	I32)
PERLVAR(Ilastsize,	I32)
PERLVAR(Iforkprocess,	int)		/* so do_open |- can return proc# */

/* subprocess state */
PERLVAR(Ifdpid,		AV *)		/* keep fd-to-pid mappings for my_popen */

/* internal state */
PERLVAR(Itainting,	bool)		/* doing taint checks */
PERLVARI(Iop_mask,	char *,	NULL)	/* masked operations for safe evals */
PERLVAR(Ilast_proto, char *)		/* Prototype of last sub seen. */

/* trace state */
PERLVAR(Idlevel,	I32)
PERLVARI(Idlmax,	I32,	128)
PERLVAR(Idebname,	char *)
PERLVAR(Idebdelim,	char *)

/* current interpreter roots */
PERLVAR(Imain_cv,	CV *)
PERLVAR(Imain_root,	OP *)
PERLVAR(Imain_start,	OP *)
PERLVAR(Ieval_root,	OP *)
PERLVAR(Ieval_start,	OP *)

/* runtime control stuff */
PERLVARI(Icurcopdb,	COP *,	NULL)
PERLVARI(Icopline,	line_t,	NOLINE)

/* statics moved here for shared library purposes */
PERLVAR(Istrchop,	SV)		/* return value from chop */
PERLVAR(Ifilemode,	int)		/* so nextargv() can preserve mode */
PERLVAR(Ilastfd,	int)		/* what to preserve mode on */
PERLVAR(Ioldname,	char *)		/* what to preserve mode on */
PERLVAR(IArgv,		char **)	/* stuff to free from do_aexec, vfork safe */
PERLVAR(ICmd,		char *)		/* stuff to free from do_aexec, vfork safe */
PERLVAR(Imystrk,	SV *)		/* temp key string for do_each() */
PERLVAR(Idumplvl,	I32)		/* indentation level on syntax tree dump */
PERLVAR(Ioldlastpm,	PMOP *)		/* for saving regexp context in debugger */
PERLVAR(Igensym,	I32)		/* next symbol for getsym() to define */
PERLVAR(Ipreambled,	bool)
PERLVAR(Ipreambleav,	AV *)
PERLVARI(Ilaststatval,	int,	-1)
PERLVARI(Ilaststype,	I32,	OP_STAT)
PERLVAR(Imess_sv,	SV *)

/* XXX shouldn't these be per-thread? --GSAR */
PERLVAR(Iors,		char *)		/* output record separator $\ */
PERLVAR(Iorslen,	STRLEN)
PERLVAR(Iofmt,		char *)		/* output format for numbers $# */

/* interpreter atexit processing */
PERLVARI(Iexitlist,	PerlExitListEntry *, NULL)
					/* list of exit functions */
PERLVARI(Iexitlistlen,	I32, 0)		/* length of same */
PERLVAR(Imodglobal,	HV *)		/* per-interp module data */

/* these used to be in global before 5.004_68 */
PERLVARI(Iprofiledata,	U32 *,	NULL)	/* table of ops, counts */
PERLVARI(Irsfp,	PerlIO * VOL,	Nullfp) /* current source file pointer */
PERLVARI(Irsfp_filters,	AV *,	Nullav)	/* keeps active source filters */

PERLVAR(Icompiling,	COP)		/* compiling/done executing marker */

PERLVAR(Icompcv,	CV *)		/* currently compiling subroutine */
PERLVAR(Icomppad,	AV *)		/* storage for lexically scoped temporaries */
PERLVAR(Icomppad_name,	AV *)		/* variable names for "my" variables */
PERLVAR(Icomppad_name_fill,	I32)	/* last "introduced" variable offset */
PERLVAR(Icomppad_name_floor,	I32)	/* start of vars in innermost block */

#ifdef HAVE_INTERP_INTERN
PERLVAR(Isys_intern,	struct interp_intern)
					/* platform internals */
#endif

/* more statics moved here */
PERLVARI(Igeneration,	int,	100)	/* from op.c */
PERLVAR(IDBcv,		CV *)		/* from perl.c */
PERLVAR(Iarchpat_auto,	char*)		/* from perl.c */

PERLVARI(Iin_clean_objs,bool,    FALSE)	/* from sv.c */
PERLVARI(Iin_clean_all,	bool,    FALSE)	/* from sv.c */

PERLVAR(Ilinestart,	char *)		/* beg. of most recently read line */
PERLVAR(Ipending_ident,	char)		/* pending identifier lookup */
PERLVAR(Isublex_info,	SUBLEXINFO)	/* from toke.c */

#ifdef USE_THREADS
PERLVAR(Ithrsv,		SV *)		/* struct perl_thread for main thread */
PERLVARI(Ithreadnum,	U32,	0)	/* incremented each thread creation */
PERLVAR(Istrtab_mutex,	perl_mutex)	/* Mutex for string table access */
#endif /* USE_THREADS */

PERLVARI(Ibytecode_iv_overflows,int,	0)	/* from bytecode.h */
PERLVAR(Ibytecode_sv,	SV *)
PERLVAR(Ibytecode_pv,	XPV)
PERLVAR(Ibytecode_obj_list,	void **)
PERLVARI(Ibytecode_obj_list_fill, I32,	-1)

#ifdef PERL_OBJECT
PERLVARI(piMem,		IPerlMem*,  NULL)
PERLVARI(piENV,		IPerlEnv*,  NULL)
PERLVARI(piStdIO,	IPerlStdIO*, NULL)
PERLVARI(piLIO,		IPerlLIO*,  NULL)
PERLVARI(piDir,		IPerlDir*,  NULL)
PERLVARI(piSock,	IPerlSock*, NULL)
PERLVARI(piProc,	IPerlProc*, NULL)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\mg.h ===
/*    mg.h
 *
 *    Copyright (c) 1991-1999, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef STRUCT_MGVTBL_DEFINITION
STRUCT_MGVTBL_DEFINITION;
#else
struct mgvtbl {
    int		(CPERLscope(*svt_get))	_((SV *sv, MAGIC* mg));
    int		(CPERLscope(*svt_set))	_((SV *sv, MAGIC* mg));
    U32		(CPERLscope(*svt_len))	_((SV *sv, MAGIC* mg));
    int		(CPERLscope(*svt_clear))	_((SV *sv, MAGIC* mg));
    int		(CPERLscope(*svt_free))	_((SV *sv, MAGIC* mg));
};
#endif

struct magic {
    MAGIC*	mg_moremagic;
    MGVTBL*	mg_virtual;	/* pointer to magic functions */
    U16		mg_private;
    char	mg_type;
    U8		mg_flags;
    SV*		mg_obj;
    char*	mg_ptr;
    I32		mg_len;
};

#define MGf_TAINTEDDIR 1
#define MGf_REFCOUNTED 2
#define MGf_GSKIP      4

#define MGf_MINMATCH   1

#define MgTAINTEDDIR(mg)	(mg->mg_flags & MGf_TAINTEDDIR)
#define MgTAINTEDDIR_on(mg)	(mg->mg_flags |= MGf_TAINTEDDIR)
#define MgTAINTEDDIR_off(mg)	(mg->mg_flags &= ~MGf_TAINTEDDIR)

#define MgPV(mg,lp)		(((lp = (mg)->mg_len) == HEf_SVKEY) ?   \
				 SvPV((SV*)((mg)->mg_ptr),lp) :		\
				 (mg)->mg_ptr)

#define SvTIED_mg(sv,how) \
    (SvRMAGICAL(sv) ? mg_find((sv),(how)) : Null(MAGIC*))
#define SvTIED_obj(sv,mg) \
    ((mg)->mg_obj ? (mg)->mg_obj : sv_2mortal(newRV(sv)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\netdb.h ===
// netdb.h

// djl
// Provide UNIX compatibility


#ifndef  _INC_NETDB
#define  _INC_NETDB

#include <sys/socket.h>

#endif //_INC_NETDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\keywords.h ===
#define KEY_NULL		0
#define KEY___FILE__		1
#define KEY___LINE__		2
#define KEY___PACKAGE__		3
#define KEY___DATA__		4
#define KEY___END__		5
#define KEY_AUTOLOAD		6
#define KEY_BEGIN		7
#define KEY_CORE		8
#define KEY_DESTROY		9
#define KEY_END			10
#define KEY_EQ			11
#define KEY_GE			12
#define KEY_GT			13
#define KEY_INIT		14
#define KEY_LE			15
#define KEY_LT			16
#define KEY_NE			17
#define KEY_abs			18
#define KEY_accept		19
#define KEY_alarm		20
#define KEY_and			21
#define KEY_atan2		22
#define KEY_bind		23
#define KEY_binmode		24
#define KEY_bless		25
#define KEY_caller		26
#define KEY_chdir		27
#define KEY_chmod		28
#define KEY_chomp		29
#define KEY_chop		30
#define KEY_chown		31
#define KEY_chr			32
#define KEY_chroot		33
#define KEY_close		34
#define KEY_closedir		35
#define KEY_cmp			36
#define KEY_connect		37
#define KEY_continue		38
#define KEY_cos			39
#define KEY_crypt		40
#define KEY_dbmclose		41
#define KEY_dbmopen		42
#define KEY_defined		43
#define KEY_delete		44
#define KEY_die			45
#define KEY_do			46
#define KEY_dump		47
#define KEY_each		48
#define KEY_else		49
#define KEY_elsif		50
#define KEY_endgrent		51
#define KEY_endhostent		52
#define KEY_endnetent		53
#define KEY_endprotoent		54
#define KEY_endpwent		55
#define KEY_endservent		56
#define KEY_eof			57
#define KEY_eq			58
#define KEY_eval		59
#define KEY_exec		60
#define KEY_exists		61
#define KEY_exit		62
#define KEY_exp			63
#define KEY_fcntl		64
#define KEY_fileno		65
#define KEY_flock		66
#define KEY_for			67
#define KEY_foreach		68
#define KEY_fork		69
#define KEY_format		70
#define KEY_formline		71
#define KEY_ge			72
#define KEY_getc		73
#define KEY_getgrent		74
#define KEY_getgrgid		75
#define KEY_getgrnam		76
#define KEY_gethostbyaddr	77
#define KEY_gethostbyname	78
#define KEY_gethostent		79
#define KEY_getlogin		80
#define KEY_getnetbyaddr	81
#define KEY_getnetbyname	82
#define KEY_getnetent		83
#define KEY_getpeername		84
#define KEY_getpgrp		85
#define KEY_getppid		86
#define KEY_getpriority		87
#define KEY_getprotobyname	88
#define KEY_getprotobynumber	89
#define KEY_getprotoent		90
#define KEY_getpwent		91
#define KEY_getpwnam		92
#define KEY_getpwuid		93
#define KEY_getservbyname	94
#define KEY_getservbyport	95
#define KEY_getservent		96
#define KEY_getsockname		97
#define KEY_getsockopt		98
#define KEY_glob		99
#define KEY_gmtime		100
#define KEY_goto		101
#define KEY_grep		102
#define KEY_gt			103
#define KEY_hex			104
#define KEY_if			105
#define KEY_index		106
#define KEY_int			107
#define KEY_ioctl		108
#define KEY_join		109
#define KEY_keys		110
#define KEY_kill		111
#define KEY_last		112
#define KEY_lc			113
#define KEY_lcfirst		114
#define KEY_le			115
#define KEY_length		116
#define KEY_link		117
#define KEY_listen		118
#define KEY_local		119
#define KEY_localtime		120
#define KEY_lock		121
#define KEY_log			122
#define KEY_lstat		123
#define KEY_lt			124
#define KEY_m			125
#define KEY_map			126
#define KEY_mkdir		127
#define KEY_msgctl		128
#define KEY_msgget		129
#define KEY_msgrcv		130
#define KEY_msgsnd		131
#define KEY_my			132
#define KEY_ne			133
#define KEY_next		134
#define KEY_no			135
#define KEY_not			136
#define KEY_oct			137
#define KEY_open		138
#define KEY_opendir		139
#define KEY_or			140
#define KEY_ord			141
#define KEY_pack		142
#define KEY_package		143
#define KEY_pipe		144
#define KEY_pop			145
#define KEY_pos			146
#define KEY_print		147
#define KEY_printf		148
#define KEY_prototype		149
#define KEY_push		150
#define KEY_q			151
#define KEY_qq			152
#define KEY_qr			153
#define KEY_quotemeta		154
#define KEY_qw			155
#define KEY_qx			156
#define KEY_rand		157
#define KEY_read		158
#define KEY_readdir		159
#define KEY_readline		160
#define KEY_readlink		161
#define KEY_readpipe		162
#define KEY_recv		163
#define KEY_redo		164
#define KEY_ref			165
#define KEY_rename		166
#define KEY_require		167
#define KEY_reset		168
#define KEY_return		169
#define KEY_reverse		170
#define KEY_rewinddir		171
#define KEY_rindex		172
#define KEY_rmdir		173
#define KEY_s			174
#define KEY_scalar		175
#define KEY_seek		176
#define KEY_seekdir		177
#define KEY_select		178
#define KEY_semctl		179
#define KEY_semget		180
#define KEY_semop		181
#define KEY_send		182
#define KEY_setgrent		183
#define KEY_sethostent		184
#define KEY_setnetent		185
#define KEY_setpgrp		186
#define KEY_setpriority		187
#define KEY_setprotoent		188
#define KEY_setpwent		189
#define KEY_setservent		190
#define KEY_setsockopt		191
#define KEY_shift		192
#define KEY_shmctl		193
#define KEY_shmget		194
#define KEY_shmread		195
#define KEY_shmwrite		196
#define KEY_shutdown		197
#define KEY_sin			198
#define KEY_sleep		199
#define KEY_socket		200
#define KEY_socketpair		201
#define KEY_sort		202
#define KEY_splice		203
#define KEY_split		204
#define KEY_sprintf		205
#define KEY_sqrt		206
#define KEY_srand		207
#define KEY_stat		208
#define KEY_study		209
#define KEY_sub			210
#define KEY_substr		211
#define KEY_symlink		212
#define KEY_syscall		213
#define KEY_sysopen		214
#define KEY_sysread		215
#define KEY_sysseek		216
#define KEY_system		217
#define KEY_syswrite		218
#define KEY_tell		219
#define KEY_telldir		220
#define KEY_tie			221
#define KEY_tied		222
#define KEY_time		223
#define KEY_times		224
#define KEY_tr			225
#define KEY_truncate		226
#define KEY_uc			227
#define KEY_ucfirst		228
#define KEY_umask		229
#define KEY_undef		230
#define KEY_unless		231
#define KEY_unlink		232
#define KEY_unpack		233
#define KEY_unshift		234
#define KEY_untie		235
#define KEY_until		236
#define KEY_use			237
#define KEY_utime		238
#define KEY_values		239
#define KEY_vec			240
#define KEY_wait		241
#define KEY_waitpid		242
#define KEY_wantarray		243
#define KEY_warn		244
#define KEY_while		245
#define KEY_write		246
#define KEY_x			247
#define KEY_xor			248
#define KEY_y			249
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\nostdio.h ===
/* This is an 1st attempt to stop other include files pulling 
   in real <stdio.h>.
   A more ambitious set of possible symbols can be found in
   sfio.h (inside an _cplusplus gard).
*/
#if !defined(_STDIO_H) && !defined(FILE) && !defined(_STDIO_INCLUDED) && !defined(__STDIO_LOADED)
#define _STDIO_H
#define _STDIO_INCLUDED
#define __STDIO_LOADED
struct _FILE;
#define FILE struct _FILE
#endif

#define _CANNOT "CANNOT"

#undef stdin
#undef stdout
#undef stderr
#undef getc
#undef putc
#undef clearerr
#undef fflush
#undef feof
#undef ferror
#undef fileno
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\tools\x86\perl\lib\core\iperlsys.h ===
/*
 * iperlsys.h - Perl's interface to the system
 *
 * This file defines the system level functionality that perl needs.
 *
 * When using C, this definition is in the form of a set of macros
 * that can be #defined to the system-level function (or a wrapper
 * provided elsewhere).
 *
 * When using C++ with -DPERL_OBJECT, this definition is in the
 * form of a set of virtual base classes which must be subclassed to
 * provide a real implementation.  The Perl Object will use instances
 * of this implementation to use the system-level functionality.
 *
 * GSAR 21-JUN-98
 */

#ifndef __Inc__IPerl___
#define __Inc__IPerl___

/*
 *	PerlXXX_YYY explained - DickH and DougL @ ActiveState.com
 *
 * XXX := functional group
 * YYY := stdlib/OS function name
 *
 * Continuing with the theme of PerlIO, all OS functionality was
 * encapsulated into one of several interfaces.
 *
 * PerlIO - stdio
 * PerlLIO - low level I/O
 * PerlMem - malloc, realloc, free
 * PerlDir - directory related
 * PerlEnv - process environment handling
 * PerlProc - process control
 * PerlSock - socket functions
 *
 *
 * The features of this are:
 * 1. All OS dependant code is in the Perl Host and not the Perl Core.
 *    (At least this is the holy grail goal of this work)
 * 2. The Perl Host (see perl.h for description) can provide a new and
 *    improved interface to OS functionality if required.
 * 3. Developers can easily hook into the OS calls for instrumentation
 *    or diagnostic purposes.
 *
 * What was changed to do this:
 * 1. All calls to OS functions were replaced with PerlXXX_YYY
 *
 */


/*
    Interface for perl stdio functions
*/


/* Clean up (or at least document) the various possible #defines.
   This section attempts to match the 5.003_03 Configure variables
   onto the 5.003_02 header file values.
   I can't figure out where USE_STDIO was supposed to be set.
   --AD
*/
#ifndef USE_PERLIO
# define PERLIO_IS_STDIO
#endif

/* Below is the 5.003_02 stuff. */
#ifdef USE_STDIO
#  ifndef PERLIO_IS_STDIO
#      define PERLIO_IS_STDIO
#  endif
#else
extern void PerlIO_init _((void));
#endif

#ifdef PERL_OBJECT

#ifndef PerlIO
typedef struct _PerlIO PerlIO;
#endif

class IPerlStdIO
{
public:
    virtual PerlIO *	Stdin(void) = 0;
    virtual PerlIO *	Stdout(void) = 0;
    virtual PerlIO *	Stderr(void) = 0;
    virtual PerlIO *	Open(const char *, const char *, int &err) = 0;
    virtual int		Close(PerlIO*, int &err) = 0;
    virtual int		Eof(PerlIO*, int &err) = 0;
    virtual int		Error(PerlIO*, int &err) = 0;
    virtual void	Clearerr(PerlIO*, int &err) = 0;
    virtual int		Getc(PerlIO*, int &err) = 0;
    virtual char *	GetBase(PerlIO *, int &err) = 0;
    virtual int		GetBufsiz(PerlIO *, int &err) = 0;
    virtual int		GetCnt(PerlIO *, int &err) = 0;
    virtual char *	GetPtr(PerlIO *, int &err) = 0;
    virtual char *	Gets(PerlIO*, char*, int, int& err) = 0;
    virtual int		Putc(PerlIO*, int, int &err) = 0;
    virtual int		Puts(PerlIO*, const char *, int &err) = 0;
    virtual int		Flush(PerlIO*, int &err) = 0;
    virtual int		Ungetc(PerlIO*,int, int &err) = 0;
    virtual int		Fileno(PerlIO*, int &err) = 0;
    virtual PerlIO *	Fdopen(int, const char *, int &err) = 0;
    virtual PerlIO *	Reopen(const char*, const char*, PerlIO*, int &err) = 0;
    virtual SSize_t	Read(PerlIO*,void *,Size_t, int &err) = 0;
    virtual SSize_t	Write(PerlIO*,const void *,Size_t, int &err) = 0;
    virtual void	SetBuf(PerlIO *, char*, int &err) = 0;
    virtual int		SetVBuf(PerlIO *, char*, int, Size_t, int &err) = 0;
    virtual void	SetCnt(PerlIO *, int, int &err) = 0;
    virtual void	SetPtrCnt(PerlIO *, char *, int, int& err) = 0;
    virtual void	Setlinebuf(PerlIO*, int &err) = 0;
    virtual int		Printf(PerlIO*, int &err, const char *,...) = 0;
    virtual int		Vprintf(PerlIO*, int &err, const char *, va_list) = 0;
    virtual long	Tell(PerlIO*, int &err) = 0;
    virtual int		Seek(PerlIO*, Off_t, int, int &err) = 0;
    virtual void	Rewind(PerlIO*, int &err) = 0;
    virtual PerlIO *	Tmpfile(int &err) = 0;
    virtual int		Getpos(PerlIO*, Fpos_t *, int &err) = 0;
    virtual int		Setpos(PerlIO*, const Fpos_t *, int &err) = 0;
    virtual void	Init(int &err) = 0;
    virtual void	InitOSExtras(void* p) = 0;
#ifdef WIN32
    virtual int		OpenOSfhandle(long osfhandle, int flags) = 0;
    virtual int		GetOSfhandle(int filenum) = 0;
#endif
};



#ifdef USE_STDIO_PTR
#  define PerlIO_has_cntptr(f)		1       
#  ifdef STDIO_CNT_LVALUE
#    define PerlIO_canset_cnt(f)	1      
#    ifdef STDIO_PTR_LVALUE
#      define PerlIO_fast_gets(f)	1        
#    endif
#  else
#    define PerlIO_canset_cnt(f)	0      
#  endif
#else  /* USE_STDIO_PTR */
#  define PerlIO_has_cntptr(f)		0
#  define PerlIO_canset_cnt(f)		0
#endif /* USE_STDIO_PTR */

#ifndef PerlIO_fast_gets
#define PerlIO_fast_gets(f)		0        
#endif

#ifdef FILE_base
#define PerlIO_has_base(f)		1
#else
#define PerlIO_has_base(f)		0
#endif

#define PerlIO_stdin()		PL_piStdIO->Stdin()
#define PerlIO_stdout()		PL_piStdIO->Stdout()
#define PerlIO_stderr()		PL_piStdIO->Stderr()
#define PerlIO_open(x,y)	PL_piStdIO->Open((x),(y), ErrorNo())
#define PerlIO_close(f)		PL_piStdIO->Close((f), ErrorNo())
#define PerlIO_eof(f)		PL_piStdIO->Eof((f), ErrorNo())
#define PerlIO_error(f)		PL_piStdIO->Error((f), ErrorNo())
#define PerlIO_clearerr(f)	PL_piStdIO->Clearerr((f), ErrorNo())
#define PerlIO_getc(f)		PL_piStdIO->Getc((f), ErrorNo())
#define PerlIO_get_base(f)	PL_piStdIO->GetBase((f), ErrorNo())
#define PerlIO_get_bufsiz(f)	PL_piStdIO->GetBufsiz((f), ErrorNo())
#define PerlIO_get_cnt(f)	PL_piStdIO->GetCnt((f), ErrorNo())
#define PerlIO_get_ptr(f)	PL_piStdIO->GetPtr((f), ErrorNo())
#define PerlIO_putc(f,c)	PL_piStdIO->Putc((f),(c), ErrorNo())
#define PerlIO_puts(f,s)	PL_piStdIO->Puts((f),(s), ErrorNo())
#define PerlIO_flush(f)		PL_piStdIO->Flush((f), ErrorNo())
#define PerlIO_gets(s, n, fp)   PL_piStdIO->Gets((fp), s, n, ErrorNo())
#define PerlIO_ungetc(f,c)	PL_piStdIO->Ungetc((f),(c), ErrorNo())
#define PerlIO_fileno(f)	PL_piStdIO->Fileno((f), ErrorNo())
#define PerlIO_fdopen(f, s)	PL_piStdIO->Fdopen((f),(s), ErrorNo())
#define PerlIO_reopen(p, m, f)  PL_piStdIO->Reopen((p), (m), (f), ErrorNo())
#define PerlIO_read(f,buf,count)					\
	(SSize_t)PL_piStdIO->Read((f), (buf), (count), ErrorNo())
#define PerlIO_write(f,buf,count)					\
	PL_piStdIO->Write((f), (buf), (count), ErrorNo())
#define PerlIO_setbuf(f,b)	PL_piStdIO->SetBuf((f), (b), ErrorNo())
#define PerlIO_setvbuf(f,b,t,s)	PL_piStdIO->SetVBuf((f), (b), (t), (s), ErrorNo())
#define PerlIO_set_cnt(f,c)	PL_piStdIO->SetCnt((f), (c), ErrorNo())
#define PerlIO_set_ptrcnt(f,p,c)					\
	PL_piStdIO->SetPtrCnt((f), (p), (c), ErrorNo())
#define PerlIO_setlinebuf(f)	PL_piStdIO->Setlinebuf((f), ErrorNo())
#define PerlIO_printf		fprintf
#define PerlIO_stdoutf		PL_piStdIO->Printf
#define PerlIO_vprintf(f,fmt,a)	PL_piStdIO->Vprintf((f), ErrorNo(), (fmt),a)          
#define PerlIO_tell(f)		PL_piStdIO->Tell((f), ErrorNo())
#define PerlIO_seek(f,o,w)	PL_piStdIO->Seek((f),(o),(w), ErrorNo())
#define PerlIO_getpos(f,p)	PL_piStdIO->Getpos((f),(p), ErrorNo())
#define PerlIO_setpos(f,p)	PL_piStdIO->Setpos((f),(p), ErrorNo())
#define PerlIO_rewind(f)	PL_piStdIO->Rewind((f), ErrorNo())
#define PerlIO_tmpfile()	PL_piStdIO->Tmpfile(ErrorNo())
#define PerlIO_init()		PL_piStdIO->Init(ErrorNo())
#undef 	init_os_extras
#define init_os_extras()	PL_piStdIO->InitOSExtras(this)

#else	/* PERL_OBJECT */

#include "perlsdio.h"

#endif	/* PERL_OBJECT */

#ifndef PERLIO_IS_STDIO
#ifdef USE_SFIO
#include "perlsfio.h"
#endif /* USE_SFIO */
#endif /* PERLIO_IS_STDIO */

#ifndef EOF
#define EOF (-1)
#endif

/* This is to catch case with no stdio */
#ifndef BUFSIZ
#define BUFSIZ 1024
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#endif

#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

#ifndef SEEK_END
#define SEEK_END 2
#endif

#ifndef PerlIO
struct _PerlIO;
#define PerlIO struct _PerlIO
#endif /* No PerlIO */

#ifndef Fpos_t
#define Fpos_t long
#endif

#ifndef NEXT30_NO_ATTRIBUTE
#ifndef HASATTRIBUTE       /* disable GNU-cc attribute checking? */
#ifdef  __attribute__      /* Avoid possible redefinition errors */
#undef  __attribute__
#endif
#define __attribute__(attr)
#endif
#endif

#ifndef PerlIO_stdoutf
extern int	PerlIO_stdoutf		_((const char *,...))
					__attribute__((format (printf, 1, 2)));
#endif
#ifndef PerlIO_puts
extern int	PerlIO_puts		_((PerlIO *,const char *));
#endif
#ifndef PerlIO_open
extern PerlIO *	PerlIO_open		_((const char *,const char *));
#endif
#ifndef PerlIO_close
extern int	PerlIO_close		_((PerlIO *));
#endif
#ifndef PerlIO_eof
extern int	PerlIO_eof		_((PerlIO *));
#endif
#ifndef PerlIO_error
extern int	PerlIO_error		_((PerlIO *));
#endif
#ifndef PerlIO_clearerr
extern void	PerlIO_clearerr		_((PerlIO *));
#endif
#ifndef PerlIO_getc
extern int	PerlIO_getc		_((PerlIO *));
#endif
#ifndef PerlIO_putc
extern int	PerlIO_putc		_((PerlIO *,int));
#endif
#ifndef PerlIO_flush
extern int	PerlIO_flush		_((PerlIO *));
#endif
#ifndef PerlIO_ungetc
extern int	PerlIO_ungetc		_((PerlIO *,int));
#endif
#ifndef PerlIO_fileno
extern int	PerlIO_fileno		_((PerlIO *));
#endif
#ifndef PerlIO_fdopen
extern PerlIO *	PerlIO_fdopen		_((int, const char *));
#endif
#ifndef PerlIO_importFILE
extern PerlIO *	PerlIO_importFILE	_((FILE *,int));
#endif
#ifndef PerlIO_exportFILE
extern FILE *	PerlIO_exportFILE	_((PerlIO *,int));
#endif
#ifndef PerlIO_findFILE
extern FILE *	PerlIO_findFILE		_((PerlIO *));
#endif
#ifndef PerlIO_releaseFILE
extern void	PerlIO_releaseFILE	_((PerlIO *,FILE *));
#endif
#ifndef PerlIO_read
extern SSize_t	PerlIO_read		_((PerlIO *,void *,Size_t));
#endif
#ifndef PerlIO_write
extern SSize_t	PerlIO_write		_((PerlIO *,const void *,Size_t));
#endif
#ifndef PerlIO_setlinebuf
extern void	PerlIO_setlinebuf	_((PerlIO *));
#endif
#ifndef PerlIO_printf
extern int	PerlIO_printf		_((PerlIO *, const char *,...))
					__attribute__((format (printf, 2, 3)));
#endif
#ifndef PerlIO_sprintf
extern int	PerlIO_sprintf		_((char *, int, const char *,...))
					__attribute__((format (printf, 3, 4)));
#endif
#ifndef PerlIO_vprintf
extern int	PerlIO_vprintf		_((PerlIO *, const char *, va_list));
#endif
#ifndef PerlIO_tell
extern Off_t	PerlIO_tell		_((PerlIO *));
#endif
#ifndef PerlIO_seek
extern int	PerlIO_seek		_((PerlIO *, Off_t, int));
#endif
#ifndef PerlIO_rewind
extern void	PerlIO_rewind		_((PerlIO *));
#endif
#ifndef PerlIO_has_base
extern int	PerlIO_has_base		_((PerlIO *));
#endif
#ifndef PerlIO_has_cntptr
extern int	PerlIO_has_cntptr	_((PerlIO *));
#endif
#ifndef PerlIO_fast_gets
extern int	PerlIO_fast_gets	_((PerlIO *));
#endif
#ifndef PerlIO_canset_cnt
extern int	PerlIO_canset_cnt	_((PerlIO *));
#endif
#ifndef PerlIO_get_ptr
extern STDCHAR * PerlIO_get_ptr		_((PerlIO *));
#endif
#ifndef PerlIO_get_cnt
extern int	PerlIO_get_cnt		_((PerlIO *));
#endif
#ifndef PerlIO_set_cnt
extern void	PerlIO_set_cnt		_((PerlIO *,int));
#endif
#ifndef PerlIO_set_ptrcnt
extern void	PerlIO_set_ptrcnt	_((PerlIO *,STDCHAR *,int));
#endif
#ifndef PerlIO_get_base
extern STDCHAR * PerlIO_get_base	_((PerlIO *));
#endif
#ifndef PerlIO_get_bufsiz
extern int	PerlIO_get_bufsiz	_((PerlIO *));
#endif
#ifndef PerlIO_tmpfile
extern PerlIO *	PerlIO_tmpfile		_((void));
#endif
#ifndef PerlIO_stdin
extern PerlIO *	PerlIO_stdin	_((void));
#endif
#ifndef PerlIO_stdout
extern PerlIO *	PerlIO_stdout	_((void));
#endif
#ifndef PerlIO_stderr
extern PerlIO *	PerlIO_stderr	_((void));
#endif
#ifndef PerlIO_getpos
extern int	PerlIO_getpos		_((PerlIO *,Fpos_t *));
#endif
#ifndef PerlIO_setpos
extern int	PerlIO_setpos		_((PerlIO *,const Fpos_t *));
#endif


/*
 *   Interface for directory functions
 */

#ifdef PERL_OBJECT

class IPerlDir
{
public:
    virtual int		Makedir(const char *dirname, int mode, int &err) = 0;
    virtual int		Chdir(const char *dirname, int &err) = 0;
    virtual int		Rmdir(const char *dirname, int &err) = 0;
    virtual int		Close(DIR *dirp, int &err) = 0;
    virtual DIR *	Open(char *filename, int &err) = 0;
    virtual struct direct *Read(DIR *dirp, int &err) = 0;
    virtual void	Rewind(DIR *dirp, int &err) = 0;
    virtual void	Seek(DIR *dirp, long loc, int &err) = 0;
    virtual long	Tell(DIR *dirp, int &err) = 0;
};

#define PerlDir_mkdir(name, mode)				\
	PL_piDir->Makedir((name), (mode), ErrorNo())
#define PerlDir_chdir(name)					\
	PL_piDir->Chdir((name), ErrorNo())
#define PerlDir_rmdir(name)					\
	PL_piDir->Rmdir((name), ErrorNo())
#define PerlDir_close(dir)					\
	PL_piDir->Close((dir), ErrorNo())
#define PerlDir_open(name)					\
	PL_piDir->Open((name), ErrorNo())
#define PerlDir_read(dir)					\
	PL_piDir->Read((dir), ErrorNo())
#define PerlDir_rewind(dir)					\
	PL_piDir->Rewind((dir), ErrorNo())
#define PerlDir_seek(dir, loc)					\
	PL_piDir->Seek((dir), (loc), ErrorNo())
#define PerlDir_tell(dir)					\
	PL_piDir->Tell((dir), ErrorNo())

#else	/* PERL_OBJECT */

#define PerlDir_mkdir(name, mode)	Mkdir((name), (mode))
#ifdef VMS
#  define PerlDir_chdir(n)		chdir(((n) && *(n)) ? (n) : "SYS$LOGIN")
#else 
#  define PerlDir_chdir(name)		chdir((name))
#endif
#define PerlDir_rmdir(name)		rmdir((name))
#define PerlDir_close(dir)		closedir((dir))
#define PerlDir_open(name)		opendir((name))
#define PerlDir_read(dir)		readdir((dir))
#define PerlDir_rewind(dir)		rewinddir((dir))
#define PerlDir_seek(dir, loc)		seekdir((dir), (loc))
#define PerlDir_tell(dir)		telldir((dir))

#endif	/* PERL_OBJECT */

/*
    Interface for perl environment functions
*/

#ifdef PERL_OBJECT

class IPerlEnv
{
public:
    virtual char *	Getenv(const char *varname, int &err) = 0;
    virtual int		Putenv(const char *envstring, int &err) = 0;
    virtual char *	LibPath(char *patchlevel) =0;
    virtual char *	SiteLibPath(char *patchlevel) =0;
    virtual int		Uname(struct utsname *name, int &err) =0;
};

#define PerlEnv_putenv(str)		PL_piENV->Putenv((str), ErrorNo())
#define PerlEnv_getenv(str)		PL_piENV->Getenv((str), ErrorNo())
#define PerlEnv_uname(name)		PL_piENV->Uname((name), ErrorNo())
#ifdef WIN32
#define PerlEnv_lib_path(str)		PL_piENV->LibPath((str))
#define PerlEnv_sitelib_path(str)	PL_piENV->SiteLibPath((str))
#endif

#else	/* PERL_OBJECT */

#define PerlEnv_putenv(str)		putenv((str))
#define PerlEnv_getenv(str)		getenv((str))
#define PerlEnv_uname(name)		uname((name))

#endif	/* PERL_OBJECT */

/*
    Interface for perl low-level IO functions
*/

#ifdef PERL_OBJECT

class IPerlLIO
{
public:
    virtual int		Access(const char *path, int mode, int &err) = 0;
    virtual int		Chmod(const char *filename, int pmode, int &err) = 0;
    virtual int		Chown(const char *filename, uid_t owner,
			      gid_t group, int &err) = 0;
    virtual int		Chsize(int handle, long size, int &err) = 0;
    virtual int		Close(int handle, int &err) = 0;
    virtual int		Dup(int handle, int &err) = 0;
    virtual int		Dup2(int handle1, int handle2, int &err) = 0;
    virtual int		Flock(int fd, int oper, int &err) = 0;
    virtual int		FileStat(int handle, struct stat *buffer, int &err) = 0;
    virtual int		IOCtl(int i, unsigned int u, char *data, int &err) = 0;
    virtual int		Isatty(int handle, int &err) = 0;
    virtual long	Lseek(int handle, long offset, int origin, int &err) = 0;
    virtual int		Lstat(const char *path, struct stat *buffer, int &err) = 0;
    virtual char *	Mktemp(char *Template, int &err) = 0;
    virtual int		Open(const char *filename, int oflag, int &err) = 0;	
    virtual int		Open(const char *filename, int oflag,
			     int pmode, int &err) = 0;	
    virtual int		Read(int handle, void *buffer,
			     unsigned int count, int &err) = 0;
    virtual int		Rename(const char *oname,
			       const char *newname, int &err) = 0;
    virtual int		Setmode(int handle, int mode, int &err) = 0;
    virtual int		NameStat(const char *path,
				 struct stat *buffer, int &err) = 0;
    virtual char *	Tmpnam(char *string, int &err) = 0;
    virtual int		Umask(int pmode, int &err) = 0;
    virtual int		Unlink(const char *filename, int &err) = 0;
    virtual int		Utime(char *filename, struct utimbuf *times, int &err) = 0;
    virtual int		Write(int handle, const void *buffer,
			      unsigned int count, int &err) = 0;
};

#define PerlLIO_access(file, mode)					\
	PL_piLIO->Access((file), (mode), ErrorNo())
#define PerlLIO_chmod(file, mode)					\
	PL_piLIO->Chmod((file), (mode), ErrorNo())
#define PerlLIO_chown(file, owner, group)				\
	PL_piLIO->Chown((file), (owner), (group), ErrorNo())
#define PerlLIO_chsize(fd, size)					\
	PL_piLIO->Chsize((fd), (size), ErrorNo())
#define PerlLIO_close(fd)						\
	PL_piLIO->Close((fd), ErrorNo())
#define PerlLIO_dup(fd)							\
	PL_piLIO->Dup((fd), ErrorNo())
#define PerlLIO_dup2(fd1, fd2)						\
	PL_piLIO->Dup2((fd1), (fd2), ErrorNo())
#define PerlLIO_flock(fd, op)						\
	PL_piLIO->Flock((fd), (op), ErrorNo())
#define PerlLIO_fstat(fd, buf)						\
	PL_piLIO->FileStat((fd), (buf), ErrorNo())
#define PerlLIO_ioctl(fd, u, buf)					\
	PL_piLIO->IOCtl((fd), (u), (buf), ErrorNo())
#define PerlLIO_isatty(fd)						\
	PL_piLIO->Isatty((fd), ErrorNo())
#define PerlLIO_lseek(fd, offset, mode)					\
	PL_piLIO->Lseek((fd), (offset), (mode), ErrorNo())
#define PerlLIO_lstat(name, buf)					\
	PL_piLIO->Lstat((name), (buf), ErrorNo())
#define PerlLIO_mktemp(file)						\
	PL_piLIO->Mktemp((file), ErrorNo())
#define PerlLIO_open(file, flag)					\
	PL_piLIO->Open((file), (flag), ErrorNo())
#define PerlLIO_open3(file, flag, perm)					\
	PL_piLIO->Open((file), (flag), (perm), ErrorNo())
#define PerlLIO_read(fd, buf, count)					\
	PL_piLIO->Read((fd), (buf), (count), ErrorNo())
#define PerlLIO_rename(oname, newname)					\
	PL_piLIO->Rename((oname), (newname), ErrorNo())
#define PerlLIO_setmode(fd, mode)					\
	PL_piLIO->Setmode((fd), (mode), ErrorNo())
#define PerlLIO_stat(name, buf)						\
	PL_piLIO->NameStat((name), (buf), ErrorNo())
#define PerlLIO_tmpnam(str)						\
	PL_piLIO->Tmpnam((str), ErrorNo())
#define PerlLIO_umask(mode)						\
	PL_piLIO->Umask((mode), ErrorNo())
#define PerlLIO_unlink(file)						\
	PL_piLIO->Unlink((file), ErrorNo())
#define PerlLIO_utime(file, time)					\
	PL_piLIO->Utime((file), (time), ErrorNo())
#define PerlLIO_write(fd, buf, count)					\
	PL_piLIO->Write((fd), (buf), (count), ErrorNo())

#else	/* PERL_OBJECT */

#define PerlLIO_access(file, mode)	access((file), (mode))
#define PerlLIO_chmod(file, mode)	chmod((file), (mode))
#define PerlLIO_chown(file, owner, grp)	chown((file), (owner), (grp))
#define PerlLIO_chsize(fd, size)	chsize((fd), (size))
#define PerlLIO_close(fd)		close((fd))
#define PerlLIO_dup(fd)			dup((fd))
#define PerlLIO_dup2(fd1, fd2)		dup2((fd1), (fd2))
#define PerlLIO_flock(fd, op)		FLOCK((fd), (op))
#define PerlLIO_fstat(fd, buf)		Fstat((fd), (buf))
#define PerlLIO_ioctl(fd, u, buf)	ioctl((fd), (u), (buf))
#define PerlLIO_isatty(fd)		isatty((fd))
#define PerlLIO_lseek(fd, offset, mode)	lseek((fd), (offset), (mode))
#define PerlLIO_lstat(name, buf)	lstat((name), (buf))
#define PerlLIO_mktemp(file)		mktemp((file))
#define PerlLIO_mkstemp(file)		mkstemp((file))
#define PerlLIO_open(file, flag)	open((file), (flag))
#define PerlLIO_open3(file, flag, perm)	open((file), (flag), (perm))
#define PerlLIO_read(fd, buf, count)	read((fd), (buf), (count))
#define PerlLIO_rename(old, new)	rename((old), (new))
#define PerlLIO_setmode(fd, mode)	setmode((fd), (mode))
#define PerlLIO_stat(name, buf)		Stat((name), (buf))
#define PerlLIO_tmpnam(str)		tmpnam((str))
#define PerlLIO_umask(mode)		umask((mode))
#define PerlLIO_unlink(file)		unlink((file))
#define PerlLIO_utime(file, time)	utime((file), (time))
#define PerlLIO_write(fd, buf, count)	write((fd), (buf), (count))

#endif	/* PERL_OBJECT */

/*
    Interface for perl memory allocation
*/

#ifdef PERL_OBJECT

class IPerlMem
{
public:
    virtual void *	Malloc(size_t) = 0;
    virtual void *	Realloc(void*, size_t) = 0;
    virtual void	Free(void*) = 0;
};

#define PerlMem_malloc(size)		PL_piMem->Malloc((size))
#define PerlMem_realloc(buf, size)	PL_piMem->Realloc((buf), (size))
#define PerlMem_free(buf)		PL_piMem->Free((buf))

#else	/* PERL_OBJECT */

#define PerlMem_malloc(size)		malloc((size))
#define PerlMem_realloc(buf, size)	realloc((buf), (size))
#define PerlMem_free(buf)		free((buf))
